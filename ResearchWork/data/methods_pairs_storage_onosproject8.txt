1213
#method_before
@Activate
protected void activate() {
    leadershipService.runForLeadership(SUBSCRIBER_TOPIC);
    localNodeId = clusterService.getLocalNode().id();
    kafkaPublisher.start(kafkaConfigService.getConfigParams());
    startCollector();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    leadershipService.runForLeadership(SUBSCRIBER_TOPIC);
    localNodeId = clusterService.getLocalNode().id();
    startCollector();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    kafkaPublisher.stop();
    stopCollector();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    stopCollector();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void run() {
    // do not allow to proceed without leadership
    NodeId leaderNodeId = leadershipService.getLeader(SUBSCRIBER_TOPIC);
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        log.info("Not a Leader so cannot consume event");
        return;
    }
    try {
        OnosEvent onosEvent = kafkaStore.consumeEvent();
        if (onosEvent != null) {
            kafkaPublisher.send(new ProducerRecord<>(onosEvent.type().toString(), onosEvent.subject())).get();
            log.info("Event Type - {}, Subject {} sent successfully.", onosEvent.type(), onosEvent.subject());
        }
    } catch (InterruptedException e1) {
        log.debug("Thread interupted");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e2) {
        log.error("Cannot publish data to Kafka - {}", e2);
    }
}
#method_after
@Override
public void run() {
    // do not allow to proceed without leadership
    NodeId leaderNodeId = leadershipService.getLeader(SUBSCRIBER_TOPIC);
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        log.debug("Not a Leader so cannot consume event");
        return;
    }
    try {
        OnosEvent onosEvent = kafkaStore.consumeEvent();
        if (onosEvent != null) {
            kafkaPublisher.send(new ProducerRecord<>(onosEvent.type().toString(), onosEvent.subject())).get();
            log.info("Event Type - {}, Subject {} sent successfully.", onosEvent.type(), onosEvent.subject());
        }
    } catch (InterruptedException e1) {
        log.error("Thread interupted");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e2) {
        log.error("Cannot publish data to Kafka - {}", e2);
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    workerThreadPool = Executors.newFixedThreadPool(maxNumOfWorkerThreads, new ThreadFactoryBuilder().setNameFormat("restconf-worker").build());
    // ymsNotificationService = ymsService.getYangNotificationService();
    // listeners = new ListenerTracker();
    // listeners.addListener(ymsNotificationService, new InternalYangNotificationListener());
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    workerThreadPool = Executors.newFixedThreadPool(maxNumOfWorkerThreads, new ThreadFactoryBuilder().setNameFormat("restconf-worker").build());
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    // listeners.removeListeners();
    shutdownAndAwaitTermination(workerThreadPool);
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    shutdownAndAwaitTermination(workerThreadPool);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public ObjectNode runGetOperationOnDataResource(String uri) throws RestconfException {
    // return result;
    return null;
}
#method_after
@Override
public ObjectNode runGetOperationOnDataResource(String uri) throws RestconfException {
    return null;
}
#end_block

#method_before
// private YmsOperationExecutionStatus
// invokeYmsOp(String uri, ObjectNode rootNode,
// YdtContextOperationType opType) {
// // YdtBuilder ydtBuilder = getYdtBuilder(EDIT_CONFIG_REQUEST);
// // //Convert the URI to ydtBuilder
// // convertUriToYdt(uri, ydtBuilder, opType);
// // //set default operation type for the payload node
// // ydtBuilder.setDefaultEditOperationType(opType);
// // //convert the payload json body to ydt
// // convertJsonToYdt(rootNode, ydtBuilder);
// // YmsOperationExecutionStatus status = EXECUTION_EXCEPTION;
// // try {
// //     status = ymsService.executeOperation(ydtBuilder).getYmsOperationResult();
// // } catch (Exception e) {
// //     log.error("YMS operation failed: {}", e.getMessage());
// //     log.debug("Exception in invokeYmsOp: ", e);
// // }
// // return status;
// return null;
// }
@Override
public void runPostOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
// YmsOperationExecutionStatus status =
// invokeYmsOp(uri, rootNode, CREATE);
// if (status != EXECUTION_SUCCESS) {
// throw new RestconfException("YMS post operation failed.",
// INTERNAL_SERVER_ERROR);
// }
}
#method_after
@Override
public void runPostOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
}
#end_block

#method_before
@Override
public void runPutOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
// YmsOperationExecutionStatus status =
// invokeYmsOp(uri, rootNode, REPLACE);
// if (status != EXECUTION_SUCCESS) {
// throw new RestconfException("YMS put operation failed.",
// INTERNAL_SERVER_ERROR);
// }
}
#method_after
@Override
public void runPutOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
}
#end_block

#method_before
@Override
public void runDeleteOperationOnDataResource(String uri) throws RestconfException {
// //Get a root ydtBuilder
// YdtBuilder ydtBuilder = getYdtBuilder(EDIT_CONFIG_REQUEST);
// //Convert the URI to ydtBuilder
// convertUriToYdt(uri, ydtBuilder, DELETE);
// //Execute the delete operation
// YmsOperationExecutionStatus status = ymsService
// .executeOperation(ydtBuilder)
// .getYmsOperationResult();
// if (status != EXECUTION_SUCCESS) {
// throw new RestconfException("YMS delete operation failed.",
// INTERNAL_SERVER_ERROR);
// }
}
#method_after
@Override
public void runDeleteOperationOnDataResource(String uri) throws RestconfException {
}
#end_block

#method_before
@Override
public void runPatchOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
// YmsOperationExecutionStatus status = invokeYmsOp(uri, rootNode, MERGE);
// if (status != EXECUTION_SUCCESS) {
// throw new RestconfException("YMS patch operation failed.",
// INTERNAL_SERVER_ERROR);
// }
}
#method_after
@Override
public void runPatchOperationOnDataResource(String uri, ObjectNode rootNode) throws RestconfException {
}
#end_block

#method_before
@Override
public int getFlowRuleCount() {
    return store.getFlowRuleCount(network.id());
}
#method_after
@Override
public int getFlowRuleCount() {
    return store.getFlowRuleCount(networkId());
}
#end_block

#method_before
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    return store.getFlowEntries(network.id(), deviceId);
}
#method_after
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    return store.getFlowEntries(networkId(), deviceId);
}
#end_block

#method_before
@Override
public void purgeFlowRules(DeviceId deviceId) {
    store.purgeFlowRule(network.id(), deviceId);
}
#method_after
@Override
public void purgeFlowRules(DeviceId deviceId) {
    store.purgeFlowRule(networkId(), deviceId);
}
#end_block

#method_before
@Override
public Iterable<FlowRule> getFlowRulesById(ApplicationId id) {
    DeviceService deviceService = manager.get(network.id(), DeviceService.class);
    Set<FlowRule> flowEntries = Sets.newHashSet();
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(network.id(), d.id())) {
            if (flowEntry.appId() == id.id()) {
                flowEntries.add(flowEntry);
            }
        }
    }
    return flowEntries;
}
#method_after
@Override
public Iterable<FlowRule> getFlowRulesById(ApplicationId id) {
    DeviceService deviceService = manager.get(networkId(), DeviceService.class);
    Set<FlowRule> flowEntries = Sets.newHashSet();
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(networkId(), d.id())) {
            if (flowEntry.appId() == id.id()) {
                flowEntries.add(flowEntry);
            }
        }
    }
    return flowEntries;
}
#end_block

#method_before
@Override
public Iterable<FlowEntry> getFlowEntriesById(ApplicationId id) {
    DeviceService deviceService = manager.get(network.id(), DeviceService.class);
    Set<FlowEntry> flowEntries = Sets.newHashSet();
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(network.id(), d.id())) {
            if (flowEntry.appId() == id.id()) {
                flowEntries.add(flowEntry);
            }
        }
    }
    return flowEntries;
}
#method_after
@Override
public Iterable<FlowEntry> getFlowEntriesById(ApplicationId id) {
    DeviceService deviceService = manager.get(networkId(), DeviceService.class);
    Set<FlowEntry> flowEntries = Sets.newHashSet();
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(networkId(), d.id())) {
            if (flowEntry.appId() == id.id()) {
                flowEntries.add(flowEntry);
            }
        }
    }
    return flowEntries;
}
#end_block

#method_before
@Override
public Iterable<FlowRule> getFlowRulesByGroupId(ApplicationId appId, short groupId) {
    DeviceService deviceService = manager.get(network.id(), DeviceService.class);
    Set<FlowRule> matches = Sets.newHashSet();
    long toLookUp = ((long) appId.id() << 16) | groupId;
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(network.id(), d.id())) {
            if ((flowEntry.id().value() >>> 32) == toLookUp) {
                matches.add(flowEntry);
            }
        }
    }
    return matches;
}
#method_after
@Override
public Iterable<FlowRule> getFlowRulesByGroupId(ApplicationId appId, short groupId) {
    DeviceService deviceService = manager.get(networkId(), DeviceService.class);
    Set<FlowRule> matches = Sets.newHashSet();
    long toLookUp = ((long) appId.id() << 16) | groupId;
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(networkId(), d.id())) {
            if ((flowEntry.id().value() >>> 32) == toLookUp) {
                matches.add(flowEntry);
            }
        }
    }
    return matches;
}
#end_block

#method_before
@Override
public Iterable<TableStatisticsEntry> getFlowTableStatistics(DeviceId deviceId) {
    return store.getTableStatistics(network.id(), deviceId);
}
#method_after
@Override
public Iterable<TableStatisticsEntry> getFlowTableStatistics(DeviceId deviceId) {
    return store.getTableStatistics(networkId(), deviceId);
}
#end_block

#method_before
private void process(Set<FlowRuleOperation> ops) {
    Multimap<DeviceId, FlowRuleBatchEntry> perDeviceBatches = ArrayListMultimap.create();
    for (FlowRuleOperation op : ops) {
        perDeviceBatches.put(op.rule().deviceId(), new FlowRuleBatchEntry(mapOperationType(op.type()), op.rule()));
    }
    pendingDevices.addAll(perDeviceBatches.keySet());
    for (DeviceId deviceId : perDeviceBatches.keySet()) {
        long id = idGenerator.getNewId();
        final FlowRuleBatchOperation b = new FlowRuleBatchOperation(perDeviceBatches.get(deviceId), deviceId, id);
        pendingFlowOperations.put(id, this);
        deviceInstallers.execute(() -> store.storeBatch(network.id(), b));
    }
}
#method_after
private void process(Set<FlowRuleOperation> ops) {
    Multimap<DeviceId, FlowRuleBatchEntry> perDeviceBatches = ArrayListMultimap.create();
    for (FlowRuleOperation op : ops) {
        perDeviceBatches.put(op.rule().deviceId(), new FlowRuleBatchEntry(mapOperationType(op.type()), op.rule()));
    }
    pendingDevices.addAll(perDeviceBatches.keySet());
    for (DeviceId deviceId : perDeviceBatches.keySet()) {
        long id = idGenerator.getNewId();
        final FlowRuleBatchOperation b = new FlowRuleBatchOperation(perDeviceBatches.get(deviceId), deviceId, id);
        pendingFlowOperations.put(id, this);
        deviceInstallers.execute(() -> store.storeBatch(networkId(), b));
    }
}
#end_block

#method_before
@Override
public void flowRemoved(FlowEntry flowEntry) {
    checkNotNull(flowEntry, FLOW_RULE_NULL);
    // FIXME: check validity of provider service
    lastSeen.remove(flowEntry);
    firstSeen.remove(flowEntry);
    FlowEntry stored = store.getFlowEntry(network.id(), flowEntry);
    if (stored == null) {
        log.debug("Rule already evicted from store: {}", flowEntry);
        return;
    }
    if (flowEntry.reason() == FlowEntry.FlowRemoveReason.HARD_TIMEOUT) {
        ((DefaultFlowEntry) stored).setState(FlowEntry.FlowEntryState.REMOVED);
    }
    Device device = deviceService.getDevice(flowEntry.deviceId());
    // FIXME: obtains provider from devices providerId()
    VirtualFlowRuleProvider frp = manager.getVirtualProvider(VirtualFlowRuleProvider.class);
    FlowRuleEvent event = null;
    switch(stored.state()) {
        case ADDED:
        case PENDING_ADD:
            frp.applyFlowRule(network.id(), stored);
            break;
        case PENDING_REMOVE:
        case REMOVED:
            event = store.removeFlowRule(network.id(), stored);
            break;
        default:
            break;
    }
    if (event != null) {
        log.debug("Flow {} removed", flowEntry);
        post(event);
    }
}
#method_after
@Override
public void flowRemoved(FlowEntry flowEntry) {
    checkNotNull(flowEntry, FLOW_RULE_NULL);
    checkValidity();
    lastSeen.remove(flowEntry);
    firstSeen.remove(flowEntry);
    FlowEntry stored = store.getFlowEntry(networkId(), flowEntry);
    if (stored == null) {
        log.debug("Rule already evicted from store: {}", flowEntry);
        return;
    }
    if (flowEntry.reason() == FlowEntry.FlowRemoveReason.HARD_TIMEOUT) {
        ((DefaultFlowEntry) stored).setState(FlowEntry.FlowEntryState.REMOVED);
    }
    // FIXME: obtains provider from devices providerId()
    FlowRuleEvent event = null;
    switch(stored.state()) {
        case ADDED:
        case PENDING_ADD:
            provider().applyFlowRule(networkId(), stored);
            break;
        case PENDING_REMOVE:
        case REMOVED:
            event = store.removeFlowRule(networkId(), stored);
            break;
        default:
            break;
    }
    if (event != null) {
        log.debug("Flow {} removed", flowEntry);
        post(event);
    }
}
#end_block

#method_before
private void flowMissing(FlowEntry flowRule) {
    checkNotNull(flowRule, FLOW_RULE_NULL);
    // FIXME: check validity of provider service
    Device device = deviceService.getDevice(flowRule.deviceId());
    // FIXME: obtains provider from devices providerId()
    VirtualFlowRuleProvider frp = manager.getVirtualProvider(VirtualFlowRuleProvider.class);
    FlowRuleEvent event = null;
    switch(flowRule.state()) {
        case PENDING_REMOVE:
        case REMOVED:
            event = store.removeFlowRule(network.id(), flowRule);
            break;
        case ADDED:
        case PENDING_ADD:
            event = store.pendingFlowRule(network.id(), flowRule);
            try {
                frp.applyFlowRule(network.id(), flowRule);
            } catch (UnsupportedOperationException e) {
                log.warn(e.getMessage());
                if (flowRule instanceof DefaultFlowEntry) {
                    // FIXME modification of "stored" flow entry outside of store
                    ((DefaultFlowEntry) flowRule).setState(FlowEntry.FlowEntryState.FAILED);
                }
            }
            break;
        default:
            log.debug("Flow {} has not been installed.", flowRule);
    }
    if (event != null) {
        log.debug("Flow {} removed", flowRule);
        post(event);
    }
}
#method_after
private void flowMissing(FlowEntry flowRule) {
    checkNotNull(flowRule, FLOW_RULE_NULL);
    checkValidity();
    FlowRuleEvent event = null;
    switch(flowRule.state()) {
        case PENDING_REMOVE:
        case REMOVED:
            event = store.removeFlowRule(networkId(), flowRule);
            break;
        case ADDED:
        case PENDING_ADD:
            event = store.pendingFlowRule(networkId(), flowRule);
            try {
                provider().applyFlowRule(networkId(), flowRule);
            } catch (UnsupportedOperationException e) {
                log.warn(e.getMessage());
                if (flowRule instanceof DefaultFlowEntry) {
                    // FIXME modification of "stored" flow entry outside of store
                    ((DefaultFlowEntry) flowRule).setState(FlowEntry.FlowEntryState.FAILED);
                }
            }
            break;
        default:
            log.debug("Flow {} has not been installed.", flowRule);
    }
    if (event != null) {
        log.debug("Flow {} removed", flowRule);
        post(event);
    }
}
#end_block

#method_before
private void extraneousFlow(FlowRule flowRule) {
    checkNotNull(flowRule, FLOW_RULE_NULL);
    // FIXME: check validity of provider
    VirtualFlowRuleProvider frp = manager.getVirtualProvider(VirtualFlowRuleProvider.class);
    frp.removeFlowRule(network.id(), flowRule);
    log.debug("Flow {} is on switch but not in store.", flowRule);
}
#method_after
private void extraneousFlow(FlowRule flowRule) {
    checkNotNull(flowRule, FLOW_RULE_NULL);
    checkValidity();
    provider().removeFlowRule(networkId(), flowRule);
    log.debug("Flow {} is on switch but not in store.", flowRule);
}
#end_block

#method_before
private void flowAdded(FlowEntry flowEntry) {
    checkNotNull(flowEntry, FLOW_RULE_NULL);
    if (checkRuleLiveness(flowEntry, store.getFlowEntry(network.id(), flowEntry))) {
        FlowRuleEvent event = store.addOrUpdateFlowRule(network.id(), flowEntry);
        if (event == null) {
            log.debug("No flow store event generated.");
        } else {
            log.trace("Flow {} {}", flowEntry, event.type());
            post(event);
        }
    } else {
        log.debug("Removing flow rules....");
        removeFlowRules(flowEntry);
    }
}
#method_after
private void flowAdded(FlowEntry flowEntry) {
    checkNotNull(flowEntry, FLOW_RULE_NULL);
    if (checkRuleLiveness(flowEntry, store.getFlowEntry(networkId(), flowEntry))) {
        FlowRuleEvent event = store.addOrUpdateFlowRule(networkId(), flowEntry);
        if (event == null) {
            log.debug("No flow store event generated.");
        } else {
            log.trace("Flow {} {}", flowEntry, event.type());
            post(event);
        }
    } else {
        log.debug("Removing flow rules....");
        removeFlowRules(flowEntry);
    }
}
#end_block

#method_before
private void pushFlowMetricsInternal(DeviceId deviceId, Iterable<FlowEntry> flowEntries, boolean useMissingFlow) {
    Map<FlowEntry, FlowEntry> storedRules = Maps.newHashMap();
    store.getFlowEntries(network.id(), deviceId).forEach(f -> storedRules.put(f, f));
    for (FlowEntry rule : flowEntries) {
        try {
            FlowEntry storedRule = storedRules.remove(rule);
            if (storedRule != null) {
                if (storedRule.exactMatch(rule)) {
                    // we both have the rule, let's update some info then.
                    flowAdded(rule);
                } else {
                    // the two rules are not an exact match - remove the
                    // switch's rule and install our rule
                    extraneousFlow(rule);
                    flowMissing(storedRule);
                }
            }
        } catch (Exception e) {
            log.debug("Can't process added or extra rule {}", e.getMessage());
        }
    }
    // DO NOT reinstall
    if (useMissingFlow) {
        for (FlowEntry rule : storedRules.keySet()) {
            try {
                // there are rules in the store that aren't on the switch
                log.debug("Adding rule in store, but not on switch {}", rule);
                flowMissing(rule);
            } catch (Exception e) {
                log.debug("Can't add missing flow rule:", e);
            }
        }
    }
}
#method_after
private void pushFlowMetricsInternal(DeviceId deviceId, Iterable<FlowEntry> flowEntries, boolean useMissingFlow) {
    Map<FlowEntry, FlowEntry> storedRules = Maps.newHashMap();
    store.getFlowEntries(networkId(), deviceId).forEach(f -> storedRules.put(f, f));
    for (FlowEntry rule : flowEntries) {
        try {
            FlowEntry storedRule = storedRules.remove(rule);
            if (storedRule != null) {
                if (storedRule.exactMatch(rule)) {
                    // we both have the rule, let's update some info then.
                    flowAdded(rule);
                } else {
                    // the two rules are not an exact match - remove the
                    // switch's rule and install our rule
                    extraneousFlow(rule);
                    flowMissing(storedRule);
                }
            }
        } catch (Exception e) {
            log.debug("Can't process added or extra rule {}", e.getMessage());
        }
    }
    // DO NOT reinstall
    if (useMissingFlow) {
        for (FlowEntry rule : storedRules.keySet()) {
            try {
                // there are rules in the store that aren't on the switch
                log.debug("Adding rule in store, but not on switch {}", rule);
                flowMissing(rule);
            } catch (Exception e) {
                log.debug("Can't add missing flow rule:", e);
            }
        }
    }
}
#end_block

#method_before
public void batchOperationCompleted(long batchId, CompletedBatchOperation operation) {
    store.batchOperationComplete(network.id(), FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(batchId, Collections.emptySet()), operation));
}
#method_after
public void batchOperationCompleted(long batchId, CompletedBatchOperation operation) {
    store.batchOperationComplete(networkId(), FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(batchId, Collections.emptySet()), operation));
}
#end_block

#method_before
@Override
public void pushTableStatistics(DeviceId deviceId, List<TableStatisticsEntry> tableStats) {
    store.updateTableStatistics(network.id(), deviceId, tableStats);
}
#method_after
@Override
public void pushTableStatistics(DeviceId deviceId, List<TableStatisticsEntry> tableStats) {
    store.updateTableStatistics(networkId(), deviceId, tableStats);
}
#end_block

#method_before
// TODO: Right now we only dispatch events at individual flowEntry level.
@Override
public void notify(FlowRuleBatchEvent event) {
    final FlowRuleBatchRequest request = event.subject();
    switch(event.type()) {
        case BATCH_OPERATION_REQUESTED:
            // Request has been forwarded to MASTER Node, and was
            request.ops().forEach(op -> {
                switch(op.operator()) {
                    case ADD:
                        post(new FlowRuleEvent(RULE_ADD_REQUESTED, op.target()));
                        break;
                    case REMOVE:
                        post(new FlowRuleEvent(RULE_REMOVE_REQUESTED, op.target()));
                        break;
                    case MODIFY:
                        // TODO: do something here when the time comes.
                        break;
                    default:
                        log.warn("Unknown flow operation operator: {}", op.operator());
                }
            });
            DeviceId deviceId = event.deviceId();
            FlowRuleBatchOperation batchOperation = request.asBatchOperation(deviceId);
            VirtualFlowRuleProvider flowRuleProvider = getProvider(deviceId);
            if (flowRuleProvider != null) {
                flowRuleProvider.executeBatch(network.id(), batchOperation);
            }
            break;
        case BATCH_OPERATION_COMPLETED:
            // TODO: do post-processing for batch operations.
            break;
        default:
            break;
    }
}
#method_after
// TODO: Right now we only dispatch events at individual flowEntry level.
@Override
public void notify(FlowRuleBatchEvent event) {
    final FlowRuleBatchRequest request = event.subject();
    switch(event.type()) {
        case BATCH_OPERATION_REQUESTED:
            // Request has been forwarded to MASTER Node, and was
            request.ops().forEach(op -> {
                switch(op.operator()) {
                    case ADD:
                        post(new FlowRuleEvent(RULE_ADD_REQUESTED, op.target()));
                        break;
                    case REMOVE:
                        post(new FlowRuleEvent(RULE_REMOVE_REQUESTED, op.target()));
                        break;
                    case MODIFY:
                        // TODO: do something here when the time comes.
                        break;
                    default:
                        log.warn("Unknown flow operation operator: {}", op.operator());
                }
            });
            DeviceId deviceId = event.deviceId();
            FlowRuleBatchOperation batchOperation = request.asBatchOperation(deviceId);
            VirtualFlowRuleProvider provider = innerProviderService.provider();
            if (provider != null) {
                provider.executeBatch(networkId, batchOperation);
            }
            break;
        case BATCH_OPERATION_COMPLETED:
            // TODO: do post-processing for batch operations.
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    CoreService coreService = new TestCoreService();
    virtualNetworkManagerStore.setCoreService(coreService);
    TestUtils.setField(virtualNetworkManagerStore, "storageService", new TestStorageService());
    virtualNetworkManagerStore.activate();
    flowRuleStore = new TestVirtualFlowRuleStore();
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    manager.intentService = intentService;
    TestUtils.setField(manager, "coreService", coreService);
    NetTestTools.injectEventDispatcher(manager, new TestEventDispatcher());
    manager.activate();
    appId = new TestApplicationId("FlowRuleManagerTest");
    testDirectory = new TestServiceDirectory().add(VirtualNetworkStore.class, virtualNetworkManagerStore).add(CoreService.class, coreService).add(VirtualNetworkFlowRuleStore.class, flowRuleStore);
    BaseResource.setServiceDirectory(testDirectory);
    vnet1 = setupVirtualNetworkTopology(tid1);
    vnet2 = setupVirtualNetworkTopology(tid2);
    vnetFlowRuleService1 = new VirtualNetworkFlowRuleManager(manager, vnet1, testDirectory);
    vnetFlowRuleService2 = new VirtualNetworkFlowRuleManager(manager, vnet2, testDirectory);
    vnetFlowRuleService1.addListener(listener1);
    vnetFlowRuleService1.operationsService = MoreExecutors.newDirectExecutorService();
    vnetFlowRuleService2.operationsService = MoreExecutors.newDirectExecutorService();
    vnetFlowRuleService1.deviceInstallers = MoreExecutors.newDirectExecutorService();
    vnetFlowRuleService2.deviceInstallers = MoreExecutors.newDirectExecutorService();
}
#method_after
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    CoreService coreService = new TestCoreService();
    TestUtils.setField(virtualNetworkManagerStore, "coreService", coreService);
    TestUtils.setField(virtualNetworkManagerStore, "storageService", new TestStorageService());
    virtualNetworkManagerStore.activate();
    flowRuleStore = new SimpleVirtualFlowRuleStore();
    providerRegistryService = new VirtualProviderManager();
    providerRegistryService.registerProvider(provider);
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    manager.intentService = intentService;
    TestUtils.setField(manager, "coreService", coreService);
    eventDeliveryService = new TestEventDispatcher();
    NetTestTools.injectEventDispatcher(manager, eventDeliveryService);
    eventDeliveryService.addSink(VirtualEvent.class, listenerRegistryManager);
    appId = new TestApplicationId("FlowRuleManagerTest");
    testDirectory = new TestServiceDirectory().add(VirtualNetworkStore.class, virtualNetworkManagerStore).add(CoreService.class, coreService).add(VirtualProviderRegistryService.class, providerRegistryService).add(EventDeliveryService.class, eventDeliveryService).add(VirtualNetworkFlowRuleStore.class, flowRuleStore);
    TestUtils.setField(manager, "serviceDirectory", testDirectory);
    manager.activate();
    vnet1 = setupVirtualNetworkTopology(tid1);
    vnet2 = setupVirtualNetworkTopology(tid2);
    vnetFlowRuleService1 = new VirtualNetworkFlowRuleManager(manager, vnet1.id());
    vnetFlowRuleService2 = new VirtualNetworkFlowRuleManager(manager, vnet2.id());
    vnetFlowRuleService1.addListener(listener1);
    vnetFlowRuleService2.addListener(listener2);
    vnetFlowRuleService1.operationsService = MoreExecutors.newDirectExecutorService();
    vnetFlowRuleService2.operationsService = MoreExecutors.newDirectExecutorService();
    vnetFlowRuleService1.deviceInstallers = MoreExecutors.newDirectExecutorService();
    vnetFlowRuleService2.deviceInstallers = MoreExecutors.newDirectExecutorService();
    providerService1 = (VirtualFlowRuleProviderService) providerRegistryService.getProviderService(vnet1.id(), provider);
    providerService2 = (VirtualFlowRuleProviderService) providerRegistryService.getProviderService(vnet2.id(), provider);
}
#end_block

#method_before
@Test
public void getFlowEntries() {
    assertTrue("store should be empty", Sets.newHashSet(vnetFlowRuleService1.getFlowEntries(DID1)).isEmpty());
    assertTrue("store should be empty", Sets.newHashSet(vnetFlowRuleService2.getFlowEntries(DID1)).isEmpty());
    FlowRule f1 = addFlowRule(1);
    FlowRule f2 = addFlowRule(2);
    FlowEntry fe1 = new DefaultFlowEntry(f1);
    FlowEntry fe2 = new DefaultFlowEntry(f2);
    assertEquals("2 rules should exist", 2, flowCount(vnetFlowRuleService1));
    assertEquals("0 rules should exist", 0, flowCount(vnetFlowRuleService2));
// FIXME: this test case will be enabled when ONOS-5729 have merged
// vnetFlowRuleService1.getProviderService(provider)
// .pushFlowMetrics(DID1, ImmutableList.of(fe1, fe2));
// validateEvents(listener1, RULE_ADD_REQUESTED, RULE_ADD_REQUESTED,
// RULE_ADDED, RULE_ADDED);
// 
// addFlowRule(1);
// System.err.println("events :" + listener1.events);
// assertEquals("should still be 2 rules", 2, flowCount(vnetFlowRuleService1));
// 
// vnetFlowRuleService1.getProviderService(provider)
// .pushFlowMetrics(DID1, ImmutableList.of(fe1));
// validateEvents(listener1, RULE_UPDATED, RULE_UPDATED);
}
#method_after
@Test
public void getFlowEntries() {
    assertTrue("store should be empty", Sets.newHashSet(vnetFlowRuleService1.getFlowEntries(DID1)).isEmpty());
    assertTrue("store should be empty", Sets.newHashSet(vnetFlowRuleService2.getFlowEntries(DID1)).isEmpty());
    FlowRule f1 = addFlowRule(1);
    FlowRule f2 = addFlowRule(2);
    FlowEntry fe1 = new DefaultFlowEntry(f1);
    FlowEntry fe2 = new DefaultFlowEntry(f2);
    assertEquals("2 rules should exist", 2, flowCount(vnetFlowRuleService1));
    assertEquals("0 rules should exist", 0, flowCount(vnetFlowRuleService2));
    providerService1.pushFlowMetrics(DID1, ImmutableList.of(fe1, fe2));
    validateEvents(listener1, RULE_ADD_REQUESTED, RULE_ADD_REQUESTED, RULE_ADDED, RULE_ADDED);
    addFlowRule(1);
    assertEquals("should still be 2 rules", 2, flowCount(vnetFlowRuleService1));
    System.err.println("events :" + listener1.events);
    assertEquals("0 rules should exist", 0, flowCount(vnetFlowRuleService2));
    providerService1.pushFlowMetrics(DID1, ImmutableList.of(fe1));
    validateEvents(listener1, RULE_UPDATED, RULE_UPDATED);
}
#end_block

#method_before
@Override
public void setDelegate(NetworkId networkId, D delegate) {
    checkState(deligateMap.get(networkId) == null || deligateMap.get(networkId) == delegate, "Store delegate already set");
    deligateMap.putIfAbsent(networkId, delegate);
}
#method_after
@Override
public void setDelegate(NetworkId networkId, D delegate) {
    checkState(delegateMap.get(networkId) == null || delegateMap.get(networkId) == delegate, "Store delegate already set");
    delegateMap.putIfAbsent(networkId, delegate);
}
#end_block

#method_before
@Override
public void unsetDelegate(NetworkId networkId, D delegate) {
    if (deligateMap.get(networkId) == delegate) {
        deligateMap.remove(networkId, delegate);
    }
}
#method_after
@Override
public void unsetDelegate(NetworkId networkId, D delegate) {
    if (delegateMap.get(networkId) == delegate) {
        delegateMap.remove(networkId, delegate);
    }
}
#end_block

#method_before
@Override
public boolean hasDelegate(NetworkId networkId) {
    return deligateMap.get(networkId) != null;
}
#method_after
@Override
public boolean hasDelegate(NetworkId networkId) {
    return delegateMap.get(networkId) != null;
}
#end_block

#method_before
protected void notifyDelegate(NetworkId networkId, E event) {
    if (deligateMap.get(networkId) != null) {
        deligateMap.get(networkId).notify(event);
    }
}
#method_after
protected void notifyDelegate(NetworkId networkId, E event) {
    if (delegateMap.get(networkId) != null) {
        delegateMap.get(networkId).notify(event);
    }
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
    /*
         * As part of the notification support the following files needs to be generated.
         * 1) Subject of the notification(event), this is simple interface with builder class.
         * 2) Event class extending "AbstractEvent" and defining event type enum.
         * 3) Event listener interface extending "EventListener".
         * 4) Event subject class.
         *
         * The manager class needs to extend the "ListenerRegistry".
         */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        if (!isRootNodesCodeGenRequired(this)) {
            if (getChild() != null) {
                generateInterfaceFileForNonDataNodes(this);
            }
        } else {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
            if (getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi() == null || !getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi().equals(SBI)) {
                if (isRpcChildNodePresent(this)) {
                    getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
                }
            }
        }
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        removeEmptyDirectory(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException(getErrorMsg(FAIL_AT_EXIT, this, e.getLocalizedMessage()));
    }
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
    /*
         * As part of the notification support the following files needs to be generated.
         * 1) Subject of the notification(event), this is simple interface with builder class.
         * 2) Event class extending "AbstractEvent" and defining event type enum.
         * 3) Event listener interface extending "EventListener".
         * 4) Event subject class.
         *
         * The manager class needs to extend the "ListenerRegistry".
         */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        if (!isRootNodesCodeGenRequired(this)) {
            if (getChild() != null) {
                generateInterfaceFileForNonDataNodes(this);
            }
        } else {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
            if (getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi() == null || !getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi().equals(SBI)) {
                if (isRpcNotificationPresent(this)) {
                    getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
                }
            }
        }
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        removeEmptyDirectory(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException(getErrorMsg(FAIL_AT_EXIT, this, e.getLocalizedMessage()));
    }
}
#end_block

#method_before
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo info, YangPluginConfig config, String rootPkg) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    updatePackageInfo(info, config, rootPkg);
    if (isRpcChildNodePresent((YangNode) info)) {
        info.getJavaFileInfo().addGeneratedFileTypes(GENERATE_SERVICE_AND_MANAGER);
    }
    generateTempFiles(info, config);
}
#method_after
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo info, YangPluginConfig config, String rootPkg) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    updatePackageInfo(info, config, rootPkg);
    if (isRpcNotificationPresent((YangNode) info)) {
        info.getJavaFileInfo().addGeneratedFileTypes(GENERATE_SERVICE_AND_MANAGER);
    }
    generateTempFiles(info, config);
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
    /*
         * As part of the notification support the following files needs to be generated.
         * 1) Subject of the notification(event), this is simple interface with builder class.
         * 2) Event class extending "AbstractEvent" and defining event type enum.
         * 3) Event listener interface extending "EventListener".
         * 4) Event subject class.
         *
         * The manager class needs to extend the "ListenerRegistry".
         */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        if (!isRootNodesCodeGenRequired(this)) {
            generateInterfaceFileForNonDataNodes(this);
        } else {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
            if (getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi() == null || !getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi().equals(SBI)) {
                if (isRpcChildNodePresent(this)) {
                    getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
                }
            }
        }
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        removeEmptyDirectory(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException(getErrorMsg(FAIL_AT_EXIT, this, e.getLocalizedMessage()));
    }
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
    /*
         * As part of the notification support the following files needs to be generated.
         * 1) Subject of the notification(event), this is simple interface with builder class.
         * 2) Event class extending "AbstractEvent" and defining event type enum.
         * 3) Event listener interface extending "EventListener".
         * 4) Event subject class.
         *
         * The manager class needs to extend the "ListenerRegistry".
         */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        if (!isRootNodesCodeGenRequired(this)) {
            generateInterfaceFileForNonDataNodes(this);
        } else {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
            if (getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi() == null || !getJavaFileInfo().getPluginConfig().getCodeGenerateForSbi().equals(SBI)) {
                if (isRpcNotificationPresent(this)) {
                    getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
                }
            }
        }
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        removeEmptyDirectory(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException(getErrorMsg(FAIL_AT_EXIT, this, e.getLocalizedMessage()));
    }
}
#end_block

#method_before
public void connect(IpAddress ip, TpPort port) {
    connect(ip, port, e -> log.info("Connection to the ovsdb {}:{} failed(cause: {})", ip, port, e));
}
#method_after
public void connect(IpAddress ip, TpPort port) {
    connect(ip, port, e -> log.warn("Connection to the ovsdb {}:{} failed(cause: {})", ip, port, e));
}
#end_block

#method_before
public void populatePortAddressingRules(DeviceId deviceId) {
    rulePopulator.populateRouterIpPunts(deviceId);
    rulePopulator.populateRouterProtocolPunts(deviceId);
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateRouterMacVlanFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#method_after
public void populatePortAddressingRules(DeviceId deviceId) {
    rulePopulator.populateRouterIpPunts(deviceId);
    rulePopulator.populateArpNdpPunts(deviceId);
    // Although device is added, sometimes device store does not have the
    // ports for this device yet. It results in missing filtering rules in the
    // switch. We will attempt it a few times. If it still does not work,
    // user can manually repopulate using CLI command sr-reroute-network
    PortFilterInfo firstRun = rulePopulator.populateRouterMacVlanFilters(deviceId);
    if (firstRun == null) {
        firstRun = new PortFilterInfo(0, 0, 0);
    }
    executorService.schedule(new RetryFilters(deviceId, firstRun), RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public void requestPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean wipeDeferred) {
}
#method_after
@Override
public void requestPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean copy) {
}
#end_block

#method_before
@Override
public void cancelPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean wipeDeferred) {
}
#method_after
@Override
public void cancelPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean copy) {
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(selector, priority, appId, nodeId, deviceId, wipeDeferred);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(selector, priority, appId, nodeId, deviceId, copy);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final DefaultPacketRequest other = (DefaultPacketRequest) obj;
    return Objects.equals(this.selector, other.selector) && Objects.equals(this.priority, other.priority) && Objects.equals(this.appId, other.appId) && Objects.equals(this.nodeId, other.nodeId) && Objects.equals(this.deviceId, other.deviceId) && Objects.equals(this.wipeDeferred, other.wipeDeferred);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final DefaultPacketRequest other = (DefaultPacketRequest) obj;
    return Objects.equals(this.selector, other.selector) && Objects.equals(this.priority, other.priority) && Objects.equals(this.appId, other.appId) && Objects.equals(this.nodeId, other.nodeId) && Objects.equals(this.deviceId, other.deviceId) && Objects.equals(this.copy, other.copy);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this.getClass()).add("selector", selector).add("priority", priority).add("appId", appId).add("nodeId", nodeId).add("applies to", deviceId.map(DeviceId::toString).orElse("all")).add("wipeDeferred", wipeDeferred).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this.getClass()).add("selector", selector).add("priority", priority).add("appId", appId).add("nodeId", nodeId).add("applies to", deviceId.map(DeviceId::toString).orElse("all")).add("copy", copy).toString();
}
#end_block

#method_before
private void print(PacketRequest request) {
    print(FMT, request.nodeId(), request.appId().name(), request.priority(), request.selector().criteria(), request.wipeDeferred());
}
#method_after
private void print(PacketRequest request) {
    print(FMT, request.nodeId(), request.appId().name(), request.priority(), request.selector().criteria(), request.copy());
}
#end_block

#method_before
@Override
public void requestPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean wipeDeferred) {
    checkPermission(PACKET_READ);
    checkNotNull(selector, ERROR_NULL_SELECTOR);
    checkNotNull(appId, ERROR_NULL_APP_ID);
    PacketRequest request = new DefaultPacketRequest(selector, priority, appId, localNodeId, Optional.empty(), wipeDeferred);
    store.requestPackets(request);
}
#method_after
@Override
public void requestPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean copy) {
    checkPermission(PACKET_READ);
    checkNotNull(selector, ERROR_NULL_SELECTOR);
    checkNotNull(appId, ERROR_NULL_APP_ID);
    PacketRequest request = new DefaultPacketRequest(selector, priority, appId, localNodeId, Optional.empty(), copy);
    store.requestPackets(request);
}
#end_block

#method_before
@Override
public void cancelPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean wipeDeferred) {
    checkPermission(PACKET_READ);
    checkNotNull(selector, ERROR_NULL_SELECTOR);
    checkNotNull(appId, ERROR_NULL_APP_ID);
    PacketRequest request = new DefaultPacketRequest(selector, priority, appId, localNodeId, Optional.empty(), wipeDeferred);
    store.cancelPackets(request);
}
#method_after
@Override
public void cancelPackets(TrafficSelector selector, PacketPriority priority, ApplicationId appId, boolean copy) {
    checkPermission(PACKET_READ);
    checkNotNull(selector, ERROR_NULL_SELECTOR);
    checkNotNull(appId, ERROR_NULL_APP_ID);
    PacketRequest request = new DefaultPacketRequest(selector, priority, appId, localNodeId, Optional.empty(), copy);
    store.cancelPackets(request);
}
#end_block

#method_before
private DefaultForwardingObjective.Builder createBuilder(PacketRequest request) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.punt();
    if (request.wipeDeferred()) {
        tBuilder.wipeDeferred();
    }
    return DefaultForwardingObjective.builder().withPriority(request.priority().priorityValue()).withSelector(request.selector()).fromApp(appId).withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(tBuilder.build()).makePermanent();
}
#method_after
private DefaultForwardingObjective.Builder createBuilder(PacketRequest request) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.punt();
    if (!request.copy()) {
        tBuilder.wipeDeferred();
    }
    return DefaultForwardingObjective.builder().withPriority(request.priority().priorityValue()).withSelector(request.selector()).fromApp(appId).withFlag(ForwardingObjective.Flag.VERSATILE).withTreatment(tBuilder.build()).makePermanent();
}
#end_block

#method_before
@Override
public void switchRemoved(Dpid dpid) {
    if (providerService == null) {
        return;
    }
    providerService.deviceDisconnected(deviceId(uri(dpid)));
    stopCollectorIfNeeded(collectors.remove(dpid));
}
#method_after
@Override
public void switchRemoved(Dpid dpid) {
    stopCollectorIfNeeded(collectors.remove(dpid));
    if (providerService == null) {
        return;
    }
    providerService.deviceDisconnected(deviceId(uri(dpid)));
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.registerProperties(getClass());
    baseComponents.forEach(name -> componentService.activate(appId, name));
    modified(context);
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    appId = coreService.registerApplication(APP_NAME);
    componentConfigService.registerProperties(getClass());
    componentConfigService.preSetProperty("org.onosproject.incubator.store.routing.impl.RouteStoreImpl", "distributed", "true");
    baseComponents.forEach(name -> componentService.activate(appId, name));
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    componentConfigService.preSetProperty("org.onosproject.incubator.store.routing.impl.RouteStoreImpl", "distributed", "false");
    log.info("Stopped");
}
#end_block

#method_before
@Activate
public void activate() {
    this.appId = coreService.registerApplication(APP_NAME);
    deviceService.addListener(deviceListener);
    networkConfigService.addListener(networkConfigListener);
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    readConfig();
}
#method_after
@Activate
public void activate() {
    this.appId = coreService.registerApplication(APP_NAME);
    deviceService.addListener(deviceListener);
    networkConfigService.addListener(networkConfigListener);
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    readConfig();
    // FIXME There can be an issue when this component is deactivated before vRouter
    applicationService.registerDeactivateHook(this.appId, () -> provisionDevice(false));
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    provisionDevice(false);
    deviceService.removeListener(deviceListener);
    networkConfigService.removeListener(networkConfigListener);
    hostService.removeListener(hostListener);
    interfaceService.removeListener(interfaceListener);
}
#method_after
@Deactivate
public void deactivate() {
    deviceService.removeListener(deviceListener);
    networkConfigService.removeListener(networkConfigListener);
    hostService.removeListener(hostListener);
    interfaceService.removeListener(interfaceListener);
}
#end_block

#method_before
private void updateInterface(Interface prevIntf, Interface intf) {
    if (!intf.connectPoint().deviceId().equals(controlPlaneConnectPoint.deviceId()) || !interfaces.contains(intf.name())) {
        // Ignore interfaces if they are not on the router switch
        return;
    }
    if (!prevIntf.vlan().equals(intf.vlan()) || !prevIntf.mac().equals(intf)) {
        provisionInterface(prevIntf, false);
        provisionInterface(intf, true);
    } else {
        List<InterfaceIpAddress> removeIps = prevIntf.ipAddressesList().stream().filter(pre -> !intf.ipAddressesList().contains(pre)).collect(Collectors.toList());
        List<InterfaceIpAddress> addIps = intf.ipAddressesList().stream().filter(cur -> !prevIntf.ipAddressesList().contains(cur)).collect(Collectors.toList());
        // removing flows with match parameters present in previous subject
        updateInterfaceForwarding(new Interface(prevIntf.name(), prevIntf.connectPoint(), removeIps, prevIntf.mac(), prevIntf.vlan()), false);
        // adding flows with match parameters present in event subject
        updateInterfaceForwarding(new Interface(intf.name(), intf.connectPoint(), addIps, intf.mac(), intf.vlan()), true);
    }
}
#method_after
private void updateInterface(Interface prevIntf, Interface intf) {
    if (!intf.connectPoint().deviceId().equals(controlPlaneConnectPoint.deviceId()) || !interfaces.contains(intf.name())) {
        // Ignore interfaces if they are not on the router switch
        return;
    }
    if (!prevIntf.vlan().equals(intf.vlan()) || !prevIntf.mac().equals(intf.mac())) {
        provisionInterface(prevIntf, false);
        provisionInterface(intf, true);
    } else {
        List<InterfaceIpAddress> removeIps = prevIntf.ipAddressesList().stream().filter(pre -> !intf.ipAddressesList().contains(pre)).collect(Collectors.toList());
        List<InterfaceIpAddress> addIps = intf.ipAddressesList().stream().filter(cur -> !prevIntf.ipAddressesList().contains(cur)).collect(Collectors.toList());
        // removing flows with match parameters present in previous subject
        updateInterfaceForwarding(new Interface(prevIntf.name(), prevIntf.connectPoint(), removeIps, prevIntf.mac(), prevIntf.vlan()), false);
        // adding flows with match parameters present in event subject
        updateInterfaceForwarding(new Interface(intf.name(), intf.connectPoint(), addIps, intf.mac(), intf.vlan()), true);
    }
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    componentConfigService.registerProperties(getClass());
    modified(context);
    coreAppId = coreService.registerApplication(CoreService.CORE_APP_NAME);
    routerAppId = coreService.registerApplication(RoutingService.ROUTER_APP_ID);
    vrouterAppId = coreService.registerApplication(APP_NAME);
    networkConfigRegistry.registerConfigFactory(mcastConfigFactory);
    networkConfigService.addListener(configListener);
    deviceService.addListener(deviceListener);
    interfaceService.addListener(internalInterfaceList);
    updateConfig();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    componentConfigService.registerProperties(getClass());
    modified(context);
    coreAppId = coreService.registerApplication(CoreService.CORE_APP_NAME);
    routerAppId = coreService.registerApplication(RoutingService.ROUTER_APP_ID);
    vrouterAppId = coreService.registerApplication(APP_NAME);
    networkConfigRegistry.registerConfigFactory(mcastConfigFactory);
    networkConfigService.addListener(configListener);
    deviceService.addListener(deviceListener);
    interfaceService.addListener(internalInterfaceList);
    updateConfig();
    // FIXME: There can be an issue when this component is deactivated before vRouter.
    // This will be addressed in CORD-710.
    applicationService.registerDeactivateHook(vrouterAppId, () -> cleanUp());
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cleanUp();
    routeService.removeListener(routeListener);
    deviceService.removeListener(deviceListener);
    interfaceService.removeListener(internalInterfaceList);
    networkConfigService.removeListener(configListener);
    componentConfigService.unregisterProperties(getClass(), false);
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    // FIXME: This will also remove flows when an instance goes down.
    // This is a temporary solution and should be addressed in CORD-710.
    cleanUp();
    deviceService.removeListener(deviceListener);
    interfaceService.removeListener(internalInterfaceList);
    networkConfigService.removeListener(configListener);
    componentConfigService.unregisterProperties(getClass(), false);
    log.info("Stopped");
}
#end_block

#method_before
private Set<Interface> filterInterfaces(List<String> interfaces) {
    Set<Interface> intfs = interfaceService.getInterfaces().stream().filter(intf -> intf.connectPoint().deviceId().equals(deviceId)).filter(intf -> interfaces.contains(intf.name())).collect(Collectors.toSet());
    return intfs;
}
#method_after
private Set<Interface> filterInterfaces(List<String> interfaces) {
    return interfaceService.getInterfaces().stream().filter(intf -> intf.connectPoint().deviceId().equals(deviceId)).filter(intf -> interfaces.contains(intf.name())).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (!tunnel.annotations().keys().contains(TE_TUNNEL_ANNOTATION)) {
        log.warn("No tunnel key info in tunnel {}", tunnel);
        return;
    }
    String teTunnelKey = tunnel.annotations().value(TE_TUNNEL_ANNOTATION);
    Optional<TeTunnel> optTunnel = tunnelService.getTeTunnels().stream().filter(t -> t.teTunnelKey().toString().equals(teTunnelKey)).findFirst();
    if (!optTunnel.isPresent()) {
        log.warn("No te tunnel map to tunnel {}", tunnel);
        return;
    }
    IetfTe ietfTe = buildIetfTe(optTunnel.get());
    YangCompositeEncoding encoding = codecHandler.encodeCompositeOperation(RESTCONF_ROOT, null, ietfTe, JSON, EDIT_CONFIG_REQUEST);
    String identifier = encoding.getResourceIdentifier();
    String resourceInformation = encoding.getResourceInformation();
    if (srcElement == null) {
        log.error("Can't find remote device for tunnel : {}", tunnel);
        return;
    }
    controller.post((DeviceId) srcElement, identifier, new ByteArrayInputStream(resourceInformation.getBytes()), MEDIA_TYPE_JSON, ObjectNode.class);
}
#method_after
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (!tunnel.annotations().keys().contains(TE_TUNNEL_KEY)) {
        log.warn("No tunnel key info in tunnel {}", tunnel);
        return;
    }
    String teTunnelKey = tunnel.annotations().value(TE_TUNNEL_KEY);
    Optional<TeTunnel> optTunnel = tunnelService.getTeTunnels().stream().filter(t -> t.teTunnelKey().toString().equals(teTunnelKey)).findFirst();
    if (!optTunnel.isPresent()) {
        log.warn("No te tunnel map to tunnel {}", tunnel);
        return;
    }
    IetfTe ietfTe = buildIetfTe(optTunnel.get());
    YangCompositeEncoding encoding = codecHandler.encodeCompositeOperation(RESTCONF_ROOT, null, ietfTe, JSON, EDIT_CONFIG_REQUEST);
    String identifier = encoding.getResourceIdentifier();
    String resourceInformation = encoding.getResourceInformation();
    if (srcElement == null) {
        log.error("Can't find remote device for tunnel : {}", tunnel);
        return;
    }
    controller.post((DeviceId) srcElement, identifier, new ByteArrayInputStream(resourceInformation.getBytes()), MEDIA_TYPE_JSON, ObjectNode.class);
}
#end_block

#method_before
public void addSpeaker(BgpSpeakerConfig speaker) {
    // Create the new speaker node and set the parameters
    ObjectNode speakerNode = JsonNodeFactory.instance.objectNode();
    speakerNode.put(NAME, speaker.name().get());
    speakerNode.put(VLAN, speaker.vlan().toString());
    speakerNode.put(CONNECT_POINT, speaker.connectPoint().elementId().toString() + "/" + speaker.connectPoint().port().toString());
    ArrayNode peersNode = speakerNode.putArray(PEERS);
    for (IpAddress peerAddress : speaker.peers()) {
        peersNode.add(peerAddress.toString());
    }
    // Initialize the encapsulation node if not there yet
    if (!object.hasNonNull(ENCAPSULTATION)) {
        setEncap(EncapsulationType.NONE);
    }
    // Add the new BGP speaker to the existing node array
    ArrayNode speakersArray = bgpSpeakers().isEmpty() ? initBgpSpeakersConfiguration() : (ArrayNode) object.get(SPEAKERS);
    speakersArray.add(speakerNode);
}
#method_after
public void addSpeaker(BgpSpeakerConfig speaker) {
    // Create the new speaker node and set the parameters
    ObjectNode speakerNode = JsonNodeFactory.instance.objectNode();
    speakerNode.put(NAME, speaker.name().get());
    speakerNode.put(VLAN, speaker.vlan().toString());
    speakerNode.put(CONNECT_POINT, speaker.connectPoint().elementId().toString() + "/" + speaker.connectPoint().port().toString());
    ArrayNode peersNode = speakerNode.putArray(PEERS);
    for (IpAddress peerAddress : speaker.peers()) {
        peersNode.add(peerAddress.toString());
    }
    // Add the new BGP speaker to the existing node array
    ArrayNode speakersArray = bgpSpeakers().isEmpty() ? initBgpSpeakersConfiguration() : (ArrayNode) object.get(SPEAKERS);
    speakersArray.add(speakerNode);
}
#end_block

#method_before
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress, EncapsulationType encap) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    ConnectPoint egressPort = egressInterface.connectPoint();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    Set<FilteredConnectPoint> ingressFilteredCPs = Sets.newHashSet();
    // TODO this should be only peering interfaces
    interfaceService.getInterfaces().forEach(intf -> {
        // Get ony ingress interfaces with IPs configured
        if (validIngressIntf(intf, egressInterface)) {
            TrafficSelector.Builder selector = buildIngressTrafficSelector(intf, prefix);
            FilteredConnectPoint ingressFilteredCP = new FilteredConnectPoint(intf.connectPoint(), selector.build());
            ingressFilteredCPs.add(ingressFilteredCP);
        }
    });
    // Build treatment: rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    // Build the egress selector for VLAN Id
    TrafficSelector.Builder selector = buildTrafficSelector(egressInterface);
    FilteredConnectPoint egressFilteredCP = new FilteredConnectPoint(egressPort, selector.build());
    // Set priority
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    // Set key
    Key key = Key.of(prefix.toString(), appId);
    MultiPointToSinglePointIntent.Builder intentBuilder = MultiPointToSinglePointIntent.builder().appId(appId).key(key).filteredIngressPoints(ingressFilteredCPs).filteredEgressPoint(egressFilteredCP).treatment(treatment.build()).priority(priority).constraints(CONSTRAINTS);
    encap(intentBuilder, encap);
    return intentBuilder.build();
}
#method_after
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress, EncapsulationType encap) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    ConnectPoint egressPort = egressInterface.connectPoint();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    Set<FilteredConnectPoint> ingressFilteredCPs = Sets.newHashSet();
    // TODO this should be only peering interfaces
    interfaceService.getInterfaces().forEach(intf -> {
        // Get ony ingress interfaces with IPs configured
        if (validIngressIntf(intf, egressInterface)) {
            TrafficSelector.Builder selector = buildIngressTrafficSelector(intf, prefix);
            FilteredConnectPoint ingressFilteredCP = new FilteredConnectPoint(intf.connectPoint(), selector.build());
            ingressFilteredCPs.add(ingressFilteredCP);
        }
    });
    // Build treatment: rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    // Build the egress selector for VLAN Id
    TrafficSelector.Builder selector = buildTrafficSelector(egressInterface);
    FilteredConnectPoint egressFilteredCP = new FilteredConnectPoint(egressPort, selector.build());
    // Set priority
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    // Set key
    Key key = Key.of(prefix.toString(), appId);
    MultiPointToSinglePointIntent.Builder intentBuilder = MultiPointToSinglePointIntent.builder().appId(appId).key(key).filteredIngressPoints(ingressFilteredCPs).filteredEgressPoint(egressFilteredCP).treatment(treatment.build()).priority(priority).constraints(CONSTRAINTS);
    setEncap(intentBuilder, CONSTRAINTS, encap);
    return intentBuilder.build();
}
#end_block

#method_before
private void encapUpdate() {
    synchronized (this) {
        EncapsulationType encap = encap();
        for (Map.Entry<IpPrefix, MultiPointToSinglePointIntent> entry : routeIntents.entrySet()) {
            // Retrieve the IP prefix and affected intent
            IpPrefix prefix = entry.getKey();
            MultiPointToSinglePointIntent intent = entry.getValue();
            if (intent.constraints().stream().filter(c -> c instanceof EncapsulationConstraint && new EncapsulationConstraint(encap).equals(c)).findAny().isPresent()) {
                MultiPointToSinglePointIntent.Builder intentBuilder = intent.builder();
                encap(intentBuilder, encap);
                MultiPointToSinglePointIntent newIntent = intentBuilder.build();
                routeIntents.put(entry.getKey(), newIntent);
                intentSynchronizer.submit(newIntent);
            }
        }
    }
}
#method_after
private void encapUpdate() {
    synchronized (this) {
        // Get the encapsulation type just set from the configuration
        EncapsulationType encap = encap();
        for (Map.Entry<IpPrefix, MultiPointToSinglePointIntent> entry : routeIntents.entrySet()) {
            // Get each intent currently registered by SDN-IP
            MultiPointToSinglePointIntent intent = entry.getValue();
            // Make sure the same constraint is not already part of the
            // intent constraints
            List<Constraint> constraints = intent.constraints();
            if (!constraints.stream().filter(c -> c instanceof EncapsulationConstraint && new EncapsulationConstraint(encap).equals(c)).findAny().isPresent()) {
                MultiPointToSinglePointIntent.Builder intentBuilder = MultiPointToSinglePointIntent.builder(intent);
                // Set the new encapsulation constraint
                setEncap(intentBuilder, constraints, encap);
                // Build and submit the new intent
                MultiPointToSinglePointIntent newIntent = intentBuilder.build();
                routeIntents.put(entry.getKey(), newIntent);
                intentSynchronizer.submit(newIntent);
            }
        }
    }
}
#end_block

#method_before
private EncapsulationType encap() {
    BgpConfig config = networkConfigService.getConfig(coreService.getAppId(RoutingService.ROUTER_APP_ID), RoutingService.CONFIG_CLASS);
    return config.encap();
}
#method_after
private EncapsulationType encap() {
    SdnIpConfig sdnIpConfig = networkConfigService.getConfig(appId, SdnIpConfig.class);
    if (sdnIpConfig == null) {
        log.debug("No SDN-IP config available");
        return EncapsulationType.NONE;
    } else {
        return sdnIpConfig.encap();
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_REGISTERED:
            break;
        case CONFIG_UNREGISTERED:
            break;
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            if (event.configClass() == RoutingService.CONFIG_CLASS) {
                encapUpdate();
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_REGISTERED:
            break;
        case CONFIG_UNREGISTERED:
            break;
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            if (event.configClass() == SdnIpConfig.class) {
                encapUpdate();
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void setUpConnectivity() {
    BgpConfig config = configService.getConfig(routerAppId, RoutingService.CONFIG_CLASS);
    Set<BgpConfig.BgpSpeakerConfig> bgpSpeakers;
    EncapsulationType encap;
    if (config == null) {
        log.warn("No BGP config available");
        bgpSpeakers = Collections.emptySet();
        encap = null;
    } else {
        bgpSpeakers = config.bgpSpeakers();
        encap = config.encap();
    }
    Map<Key, PointToPointIntent> existingIntents = new HashMap<>(peerIntents);
    for (BgpConfig.BgpSpeakerConfig bgpSpeaker : bgpSpeakers) {
        log.debug("Start to set up BGP paths for BGP speaker: {}", bgpSpeaker);
        buildSpeakerIntents(bgpSpeaker, encap).forEach(i -> {
            PointToPointIntent intent = existingIntents.remove(i.key());
            if (intent == null || !IntentUtils.intentsAreEqual(i, intent)) {
                peerIntents.put(i.key(), i);
                intentSynchronizer.submit(i);
            }
        });
    }
    // Remove any remaining intents that we used to have that we don't need
    // anymore
    existingIntents.values().forEach(i -> {
        peerIntents.remove(i.key());
        intentSynchronizer.withdraw(i);
    });
}
#method_after
private void setUpConnectivity() {
    BgpConfig bgpConfig = configService.getConfig(routerAppId, RoutingService.CONFIG_CLASS);
    SdnIpConfig sdnIpConfig = configService.getConfig(appId, SdnIpConfig.class);
    Set<BgpConfig.BgpSpeakerConfig> bgpSpeakers;
    EncapsulationType encap;
    if (bgpConfig == null) {
        log.debug("No BGP config available");
        bgpSpeakers = Collections.emptySet();
    } else {
        bgpSpeakers = bgpConfig.bgpSpeakers();
    }
    if (sdnIpConfig == null) {
        log.debug("No SDN-IP config available");
        encap = EncapsulationType.NONE;
    } else {
        encap = sdnIpConfig.encap();
    }
    Map<Key, PointToPointIntent> existingIntents = new HashMap<>(peerIntents);
    for (BgpConfig.BgpSpeakerConfig bgpSpeaker : bgpSpeakers) {
        log.debug("Start to set up BGP paths for BGP speaker: {}", bgpSpeaker);
        buildSpeakerIntents(bgpSpeaker, encap).forEach(i -> {
            PointToPointIntent intent = existingIntents.remove(i.key());
            if (intent == null || !IntentUtils.intentsAreEqual(i, intent)) {
                peerIntents.put(i.key(), i);
                intentSynchronizer.submit(i);
            }
        });
    }
    // Remove any remaining intents that we used to have that we don't need
    // anymore
    existingIntents.values().forEach(i -> {
        peerIntents.remove(i.key());
        intentSynchronizer.withdraw(i);
    });
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_REGISTERED:
            break;
        case CONFIG_UNREGISTERED:
            break;
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            if (event.configClass() == RoutingService.CONFIG_CLASS) {
                setUpConnectivity();
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_REGISTERED:
            break;
        case CONFIG_UNREGISTERED:
            break;
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
        case CONFIG_REMOVED:
            if (event.configClass() == RoutingService.CONFIG_CLASS || event.configClass() == SdnIpConfig.class) {
                setUpConnectivity();
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public <S, C extends Config<S>> C getConfig(S subject, Class<C> configClass) {
    ApplicationId appId = new TestApplicationId(RoutingService.ROUTER_APP_ID);
    ObjectMapper mapper = new ObjectMapper();
    ConfigApplyDelegate delegate = new MockCfgDelegate();
    JsonNode emptyTree = new ObjectMapper().createObjectNode();
    BgpConfig bgpConfig = new BgpConfig();
    bgpConfig.init(appId, "bgp-test", emptyTree, mapper, delegate);
    return (C) bgpConfig;
}
#method_after
@Override
public <S, C extends Config<S>> C getConfig(S subject, Class<C> configClass) {
    ApplicationId appId = new TestApplicationId(SdnIp.SDN_IP_APP);
    ObjectMapper mapper = new ObjectMapper();
    ConfigApplyDelegate delegate = new MockCfgDelegate();
    JsonNode emptyTree = new ObjectMapper().createObjectNode();
    SdnIpConfig sdnIpConfig = new SdnIpConfig();
    sdnIpConfig.init(appId, "sdnip-test", emptyTree, mapper, delegate);
    return (C) sdnIpConfig;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp();
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    networkConfigService = createMock(NetworkConfigService.class);
    networkConfigService.addListener(anyObject(NetworkConfigListener.class));
    expectLastCall().anyTimes();
    bgpConfig = createMock(BgpConfig.class);
    // These will set expectations on routingConfig and interfaceService
    bgpSpeakers = setUpBgpSpeakers();
    interfaces = Collections.unmodifiableMap(setUpInterfaces());
    initPeerConnectivity();
    intentList = setUpIntentList();
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp();
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    networkConfigService = createMock(NetworkConfigService.class);
    networkConfigService.addListener(anyObject(NetworkConfigListener.class));
    expectLastCall().anyTimes();
    bgpConfig = createMock(BgpConfig.class);
    sdnIpConfig = createMock(SdnIpConfig.class);
    // These will set expectations on routingConfig and interfaceService
    bgpSpeakers = setUpBgpSpeakers();
    interfaces = Collections.unmodifiableMap(setUpInterfaces());
    initPeerConnectivity();
    intentList = setUpIntentList();
}
#end_block

#method_before
private void initPeerConnectivity() {
    expect(bgpConfig.bgpSpeakers()).andReturn(bgpSpeakers).anyTimes();
    expect(bgpConfig.encap()).andReturn(EncapsulationType.NONE).anyTimes();
    replay(bgpConfig);
    expect(networkConfigService.getConfig(APPID, BgpConfig.class)).andReturn(bgpConfig).anyTimes();
    replay(networkConfigService);
    replay(interfaceService);
    intentSynchronizer = createMock(IntentSynchronizationService.class);
    replay(intentSynchronizer);
    peerConnectivityManager = new PeerConnectivityManager(APPID, intentSynchronizer, networkConfigService, CONFIG_APP_ID, interfaceService);
}
#method_after
private void initPeerConnectivity() {
    expect(bgpConfig.bgpSpeakers()).andReturn(bgpSpeakers).anyTimes();
    replay(bgpConfig);
    expect(networkConfigService.getConfig(APPID, BgpConfig.class)).andReturn(bgpConfig).anyTimes();
    expect(sdnIpConfig.encap()).andReturn(EncapsulationType.NONE).anyTimes();
    replay(sdnIpConfig);
    expect(networkConfigService.getConfig(APPID, SdnIpConfig.class)).andReturn(sdnIpConfig).anyTimes();
    replay(networkConfigService);
    replay(interfaceService);
    intentSynchronizer = createMock(IntentSynchronizationService.class);
    replay(intentSynchronizer);
    peerConnectivityManager = new PeerConnectivityManager(APPID, intentSynchronizer, networkConfigService, CONFIG_APP_ID, interfaceService);
}
#end_block

#method_before
@Test
public void testNullBgpSpeakers() {
    reset(bgpConfig);
    expect(bgpConfig.bgpSpeakers()).andReturn(Collections.emptySet()).anyTimes();
    expect(bgpConfig.encap()).andReturn(EncapsulationType.NONE).anyTimes();
    replay(bgpConfig);
    // We don't expect any intents in this case
    reset(intentSynchronizer);
    replay(intentSynchronizer);
    peerConnectivityManager.start();
    verify(intentSynchronizer);
}
#method_after
@Test
public void testNullBgpSpeakers() {
    reset(bgpConfig);
    expect(bgpConfig.bgpSpeakers()).andReturn(Collections.emptySet()).anyTimes();
    replay(bgpConfig);
    reset(sdnIpConfig);
    expect(sdnIpConfig.encap()).andReturn(EncapsulationType.NONE).anyTimes();
    replay(sdnIpConfig);
    // We don't expect any intents in this case
    reset(intentSynchronizer);
    replay(intentSynchronizer);
    peerConnectivityManager.start();
    verify(intentSynchronizer);
}
#end_block

#method_before
private void setEncap(String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (encapType.equals(EncapsulationType.NONE) && !encapType.toString().equals(encap)) {
        print(ENCAP_NOT_FOUND, encap);
        return;
    }
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(RoutingService.ROUTER_APP_ID);
    BgpConfig config = configService.addConfig(appId, BgpConfig.class);
    config.setEncap(encapType);
    configService.applyConfig(appId, BgpConfig.class, config.node());
}
#method_after
private void setEncap(String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (encapType.equals(EncapsulationType.NONE) && !encapType.toString().equals(encap)) {
        print(ENCAP_NOT_FOUND, encap);
        return;
    }
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(SdnIp.SDN_IP_APP);
    SdnIpConfig config = configService.addConfig(appId, SdnIpConfig.class);
    config.setEncap(encapType);
    config.apply();
// configService.applyConfig(appId, SdnIpConfig.class, config.node());
}
#end_block

#method_before
@Override
public TunnelId setupTunnel(ApplicationId producerId, ElementId srcElementId, Tunnel tunnel, Path path) {
    // TODO: producerId to check if really required to consider while setup the tunnel.
    checkNotNull(tunnel, TUNNNEL_NULL);
    TunnelId tunnelId = store.createOrUpdateTunnel(tunnel, State.INIT);
    if (tunnelId != null) {
        Set<ProviderId> ids = getProviders();
        for (ProviderId providerId : ids) {
            TunnelProvider provider = getProvider(providerId);
            provider.setupTunnel(srcElementId, queryTunnel(tunnelId), path);
        }
    }
    return tunnelId;
}
#method_after
@Override
public TunnelId setupTunnel(ApplicationId producerId, ElementId srcElementId, Tunnel tunnel, Path path) {
    // TODO: producerId to check if really required to consider while setup the tunnel.
    checkNotNull(tunnel, TUNNNEL_NULL);
    TunnelId tunnelId = store.createOrUpdateTunnel(tunnel, State.INIT);
    if (tunnelId != null) {
        Set<ProviderId> ids = getProviders();
        Tunnel newT = queryTunnel(tunnelId);
        for (ProviderId providerId : ids) {
            TunnelProvider provider = getProvider(providerId);
            provider.setupTunnel(srcElementId, newT, path);
        }
    }
    return tunnelId;
}
#end_block

#method_before
@Override
void apply() {
    contexts.forEach(objectiveContext -> {
        synchronized (pendingContexts) {
            pendingContexts.add(objectiveContext);
            flowObjectiveService.apply(objectiveContext.deviceId, objectiveContext.objective);
        }
    });
}
#method_after
@Override
void apply() {
    pendingContexts.addAll(contexts);
    contexts.forEach(objectiveContext -> flowObjectiveService.apply(objectiveContext.deviceId, objectiveContext.objective));
}
#end_block

#method_before
@Override
public String format(Object value) {
    List<String> members = (List<String>) value;
    if (members.isEmpty()) {
        return "(No members for this partition)";
    }
    StringBuilder sb = new StringBuilder("Members: ");
    for (String m : members) {
        sb.append(m).append(COMMA);
    }
    removeTrailingComma(sb);
    return sb.toString();
}
#method_after
@Override
public String format(Object value) {
    List<String> members = (List<String>) value;
    if (members.isEmpty()) {
        return "(No members for this partition)";
    }
    StringBuilder sb = new StringBuilder();
    for (String m : members) {
        sb.append(m).append(COMMA);
    }
    removeTrailingComma(sb);
    return sb.toString();
}
#end_block

#method_before
private String getInputPowerRange(DeviceId deviceId, PortNumber portNumber) {
    Range<Long> range = roadmService.inputPortPowerRange(deviceId, portNumber);
    if (range != null) {
        return range.toString();
    }
    return NA;
}
#method_after
// Returns the input power range as a string, N/A if the port is not an
private String getInputPowerRange(DeviceId deviceId, PortNumber portNumber) {
    Range<Long> range = roadmService.inputPortPowerRange(deviceId, portNumber);
    if (range != null) {
        return range.toString();
    }
    return NA;
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    PortNumber portNumber = PortNumber.portNumber(payload.get(ID).asLong());
    long targetPower = payload.get(TARGET_POWER).asLong();
    boolean validTargetPower;
    Range<Long> range = roadmService.targetPortPowerRange(deviceId, portNumber);
    if (range != null) {
        validTargetPower = range.contains(targetPower);
        if (validTargetPower) {
            roadmService.setTargetPortPower(deviceId, portNumber, targetPower);
        }
        ObjectNode rootNode = objectNode();
        rootNode.put(ID, payload.get(ID).asText());
        rootNode.put(VALID, validTargetPower);
        rootNode.put(MESSAGE, String.format(TARGET_POWER_ERR_MSG, range.toString()));
        sendMessage(ROADM_SET_TARGET_POWER_RESP, rootNode);
    } else {
        log.warn("Unable to determine target power range for device {}", deviceId);
    }
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    PortNumber portNumber = PortNumber.portNumber(payload.get(ID).asLong());
    long targetPower = payload.get(TARGET_POWER).asLong();
    boolean validTargetPower;
    Range<Long> range = roadmService.targetPortPowerRange(deviceId, portNumber);
    if (range != null) {
        validTargetPower = range.contains(targetPower);
        if (validTargetPower) {
            roadmService.setTargetPortPower(deviceId, portNumber, targetPower);
        }
        ObjectNode rootNode = objectNode();
        rootNode.put(ID, payload.get(ID).asText());
        rootNode.put(VALID, validTargetPower);
        rootNode.put(MESSAGE, String.format(TARGET_POWER_ERR_MSG, range.toString()));
        sendMessage(ROADM_SET_TARGET_POWER_RESP, rootNode);
    } else {
        log.warn("Unable to determine target power range for device {}", deviceId);
    }
}
#end_block

#method_before
private PowerConfig<Object> getPowerConfig(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && device.is(PowerConfig.class)) {
        return device.as(PowerConfig.class);
    }
    log.warn("Unable to load PowerConfig for {}", deviceId.toString());
    return null;
}
#method_after
private PowerConfig<Object> getPowerConfig(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && device.is(PowerConfig.class)) {
        return device.as(PowerConfig.class);
    }
    log.warn("Unable to load PowerConfig for {}", deviceId);
    return null;
}
#end_block

#method_before
private LambdaQuery getLambdaQuery(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && device.is(PowerConfig.class)) {
        return device.as(LambdaQuery.class);
    }
    return null;
}
#method_after
private LambdaQuery getLambdaQuery(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null && device.is(LambdaQuery.class)) {
        return device.as(LambdaQuery.class);
    }
    return null;
}
#end_block

#method_before
private void initDevice(DeviceId deviceId) {
    if (!roadmStore.deviceAvailable(deviceId)) {
        roadmStore.addDevice(deviceId);
    }
    log.info("Initialized device {}", deviceId.toString());
}
#method_after
private void initDevice(DeviceId deviceId) {
    if (!roadmStore.deviceAvailable(deviceId)) {
        roadmStore.addDevice(deviceId);
    }
    log.info("Initialized device {}", deviceId);
}
#end_block

#method_before
// Sets the target port powers for a port on a device
// Attempts to read target powers from store. If no value is found then
private void setInitialTargetPortPower(DeviceId deviceId, PortNumber portNumber) {
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig != null) {
        Optional<Range<Long>> range = powerConfig.getTargetPowerRange(portNumber, Direction.ALL);
        if (range.isPresent()) {
            Long power = roadmStore.getTargetPower(deviceId, portNumber);
            if (power == null) {
                // Set default to middle of the range
                power = (range.get().lowerEndpoint() + range.get().upperEndpoint()) / 2;
                roadmStore.setTargetPower(deviceId, portNumber, power);
            }
            powerConfig.setTargetPower(portNumber, Direction.ALL, power);
        }
    } else {
        log.warn("Unable to set default initial powers for port {} on device {}", portNumber.toString(), deviceId.toString());
    }
}
#method_after
// Sets the target port powers for a port on a device
// Attempts to read target powers from store. If no value is found then
private void setInitialTargetPortPower(DeviceId deviceId, PortNumber portNumber) {
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig == null) {
        log.warn("Unable to set default initial powers for port {} on device {}", portNumber, deviceId);
        return;
    }
    Optional<Range<Long>> range = powerConfig.getTargetPowerRange(portNumber, Direction.ALL);
    if (!range.isPresent()) {
        log.warn("No target power range found for port {} on device {}", portNumber, deviceId);
        return;
    }
    Long power = roadmStore.getTargetPower(deviceId, portNumber);
    if (power == null) {
        // Set default to middle of the range
        power = (range.get().lowerEndpoint() + range.get().upperEndpoint()) / 2;
        roadmStore.setTargetPower(deviceId, portNumber, power);
    }
    powerConfig.setTargetPower(portNumber, Direction.ALL, power);
}
#end_block

#method_before
// Sets the target port powers for each each port on a device
// Attempts to read target powers from store. If no value is found then
private void setAllInitialTargetPortPowers(DeviceId deviceId) {
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig != null) {
        List<Port> ports = deviceService.getPorts(deviceId);
        for (Port port : ports) {
            Optional<Range<Long>> range = powerConfig.getTargetPowerRange(port.number(), Direction.ALL);
            if (range.isPresent()) {
                Long power = roadmStore.getTargetPower(deviceId, port.number());
                if (power == null) {
                    // Set default to middle of the range
                    power = (range.get().lowerEndpoint() + range.get().upperEndpoint()) / 2;
                    roadmStore.setTargetPower(deviceId, port.number(), power);
                }
                powerConfig.setTargetPower(port.number(), Direction.ALL, power);
            }
        }
    } else {
        log.warn("Unable to set default initial powers for device {}", deviceId.toString());
    }
}
#method_after
// Sets the target port powers for each each port on a device
// Attempts to read target powers from store. If no value is found then
private void setAllInitialTargetPortPowers(DeviceId deviceId) {
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig == null) {
        log.warn("Unable to set default initial powers for device {}", deviceId);
        return;
    }
    List<Port> ports = deviceService.getPorts(deviceId);
    for (Port port : ports) {
        Optional<Range<Long>> range = powerConfig.getTargetPowerRange(port.number(), Direction.ALL);
        if (range.isPresent()) {
            Long power = roadmStore.getTargetPower(deviceId, port.number());
            if (power == null) {
                // Set default to middle of the range
                power = (range.get().lowerEndpoint() + range.get().upperEndpoint()) / 2;
                roadmStore.setTargetPower(deviceId, port.number(), power);
            }
            powerConfig.setTargetPower(port.number(), Direction.ALL, power);
        } else {
            log.warn("No target power range found for port {} on device {}", port.number(), deviceId);
        }
    }
}
#end_block

#method_before
@Override
public void setTargetPortPower(DeviceId deviceId, PortNumber portNumber, long power) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig != null) {
        roadmStore.setTargetPower(deviceId, portNumber, power);
        powerConfig.setTargetPower(portNumber, Direction.ALL, power);
    } else {
        log.warn("Unable to set target port power for device {}", deviceId.toString());
    }
}
#method_after
@Override
public void setTargetPortPower(DeviceId deviceId, PortNumber portNumber, long power) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig != null) {
        roadmStore.setTargetPower(deviceId, portNumber, power);
        powerConfig.setTargetPower(portNumber, Direction.ALL, power);
    } else {
        log.warn("Unable to set target port power for device {}", deviceId);
    }
}
#end_block

#method_before
@Override
public Long getTargetPortPower(DeviceId deviceId, PortNumber portNumber) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    // getTargetPortPower is not yet implemented in PowerConfig so we access store instead
    return roadmStore.getTargetPower(deviceId, portNumber);
}
#method_after
@Override
public Long getTargetPortPower(DeviceId deviceId, PortNumber portNumber) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    // access store instead
    return roadmStore.getTargetPower(deviceId, portNumber);
}
#end_block

#method_before
@Override
public void setAttenuation(DeviceId deviceId, PortNumber portNumber, OchSignal ochSignal, long attenuation) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    checkNotNull(ochSignal);
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig != null) {
        powerConfig.setTargetPower(portNumber, ochSignal, attenuation);
    } else {
        log.warn("Cannot set attenuation for channel index {} on device {}", ochSignal.spacingMultiplier(), deviceId.toString());
    }
}
#method_after
@Override
public void setAttenuation(DeviceId deviceId, PortNumber portNumber, OchSignal ochSignal, long attenuation) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    checkNotNull(ochSignal);
    PowerConfig<Object> powerConfig = getPowerConfig(deviceId);
    if (powerConfig != null) {
        powerConfig.setTargetPower(portNumber, ochSignal, attenuation);
    } else {
        log.warn("Cannot set attenuation for channel index {} on device {}", ochSignal.spacingMultiplier(), deviceId);
    }
}
#end_block

#method_before
@Override
public Set<OchSignal> queryLambdas(DeviceId deviceId, PortNumber portNumber) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    LambdaQuery lambdaQuery = getLambdaQuery(deviceId);
    if (lambdaQuery != null) {
        return lambdaQuery.queryLambdas(portNumber);
    }
    return null;
}
#method_after
@Override
public Set<OchSignal> queryLambdas(DeviceId deviceId, PortNumber portNumber) {
    checkNotNull(deviceId);
    checkNotNull(portNumber);
    LambdaQuery lambdaQuery = getLambdaQuery(deviceId);
    if (lambdaQuery != null) {
        return lambdaQuery.queryLambdas(portNumber);
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public void createConnection(DeviceId deviceId, int priority, boolean isPermanent, int timeout, PortNumber inPort, PortNumber outPort, OchSignal ochSignal) {
    checkNotNull(deviceId);
    checkNotNull(inPort);
    checkNotNull(outPort);
    FlowRule.Builder flowBuilder = new DefaultFlowRule.Builder();
    flowBuilder.fromApp(appId);
    flowBuilder.withPriority(priority);
    if (isPermanent) {
        flowBuilder.makePermanent();
    } else {
        flowBuilder.makeTemporary(timeout);
    }
    flowBuilder.forDevice(deviceId);
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.add(Criteria.matchInPort(inPort));
    selectorBuilder.add(Criteria.matchOchSignalType(OchSignalType.FIXED_GRID));
    selectorBuilder.add(Criteria.matchLambda(ochSignal));
    flowBuilder.withSelector(selectorBuilder.build());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.add(Instructions.createOutput(outPort));
    flowBuilder.withTreatment(treatmentBuilder.build());
    flowRuleService.applyFlowRules(flowBuilder.build());
    log.info("Created connection from input port {} to output port {}", outPort.toString(), outPort.toLong());
}
#method_after
@Override
public FlowId createConnection(DeviceId deviceId, int priority, boolean isPermanent, int timeout, PortNumber inPort, PortNumber outPort, OchSignal ochSignal) {
    checkNotNull(deviceId);
    checkNotNull(inPort);
    checkNotNull(outPort);
    FlowRule.Builder flowBuilder = new DefaultFlowRule.Builder();
    flowBuilder.fromApp(appId);
    flowBuilder.withPriority(priority);
    if (isPermanent) {
        flowBuilder.makePermanent();
    } else {
        flowBuilder.makeTemporary(timeout);
    }
    flowBuilder.forDevice(deviceId);
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.add(Criteria.matchInPort(inPort));
    selectorBuilder.add(Criteria.matchOchSignalType(OchSignalType.FIXED_GRID));
    selectorBuilder.add(Criteria.matchLambda(ochSignal));
    flowBuilder.withSelector(selectorBuilder.build());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.add(Instructions.createOutput(outPort));
    flowBuilder.withTreatment(treatmentBuilder.build());
    FlowRule flowRule = flowBuilder.build();
    flowRuleService.applyFlowRules(flowRule);
    log.info("Created connection from input port {} to output port {}", inPort.toLong(), outPort.toLong());
    return flowRule.id();
}
#end_block

#method_before
@Override
public void createConnection(DeviceId deviceId, int priority, boolean isPermanent, int timeout, PortNumber inPort, PortNumber outPort, OchSignal ochSignal, int attenuation) {
    checkNotNull(deviceId);
    checkNotNull(inPort);
    checkNotNull(outPort);
    createConnection(deviceId, priority, isPermanent, timeout, inPort, outPort, ochSignal);
    // OchSignal ochSignal = OchSignal.newDwdmSlot(ChannelSpacing.CHL_50GHZ, multiplier);
    delayedSetAttenuation(deviceId, outPort, ochSignal, attenuation);
}
#method_after
@Override
public FlowId createConnection(DeviceId deviceId, int priority, boolean isPermanent, int timeout, PortNumber inPort, PortNumber outPort, OchSignal ochSignal, long attenuation) {
    checkNotNull(deviceId);
    checkNotNull(inPort);
    checkNotNull(outPort);
    FlowId flowId = createConnection(deviceId, priority, isPermanent, timeout, inPort, outPort, ochSignal);
    delayedSetAttenuation(deviceId, outPort, ochSignal, attenuation);
    return flowId;
}
#end_block

#method_before
@Override
public void removeConnection(DeviceId deviceId, FlowId flowId) {
    checkNotNull(deviceId);
    checkNotNull(flowId);
    for (FlowEntry entry : flowRuleService.getFlowEntries(deviceId)) {
        if (entry.id().equals(flowId)) {
            flowRuleService.removeFlowRules(entry);
            log.info("Deleted connection");
            break;
        }
    }
}
#method_after
@Override
public void removeConnection(DeviceId deviceId, FlowId flowId) {
    checkNotNull(deviceId);
    checkNotNull(flowId);
    for (FlowEntry entry : flowRuleService.getFlowEntries(deviceId)) {
        if (entry.id().equals(flowId)) {
            flowRuleService.removeFlowRules(entry);
            log.info("Deleted connection {}", entry.id());
            break;
        }
    }
}
#end_block

#method_before
private void populateRow(TableModel.Row row, FlowEntry entry, DeviceId deviceId) {
    ChannelData channelData = ChannelData.fromFlow(entry);
    row.cell(ID, entry.id().value()).cell(FLOW_ID, entry.id().value()).cell(APP_ID, entry.appId()).cell(PRIORITY, entry.priority()).cell(TIMEOUT, entry.timeout()).cell(PERMANENT, entry.isPermanent()).cell(STATE, entry.state().toString()).cell(IN_PORT, channelData.inPort().toLong()).cell(OUT_PORT, channelData.outPort().toLong()).cell(CHANNEL_SPACING, channelData.ochSignal().channelSpacing().frequency().asHz() / GHZ).cell(CHANNEL_MULTIPLIER, channelData.ochSignal().spacingMultiplier()).cell(CURRENT_POWER, getCurrentPower(deviceId, channelData)).cell(ATTENUATION, getAttenuation(deviceId, channelData));
}
#method_after
private void populateRow(TableModel.Row row, FlowEntry entry, DeviceId deviceId) {
    ChannelData cd = ChannelData.fromFlow(entry);
    row.cell(ID, entry.id().value()).cell(FLOW_ID, entry.id().value()).cell(APP_ID, entry.appId()).cell(PRIORITY, entry.priority()).cell(TIMEOUT, entry.timeout()).cell(PERMANENT, entry.isPermanent()).cell(STATE, entry.state().toString()).cell(IN_PORT, cd.inPort().toLong()).cell(OUT_PORT, cd.outPort().toLong()).cell(CHANNEL_SPACING, cd.ochSignal().channelSpacing().frequency().asHz() / GHZ).cell(CHANNEL_MULTIPLIER, cd.ochSignal().spacingMultiplier()).cell(CURRENT_POWER, getCurrentPower(deviceId, cd)).cell(ATTENUATION, getAttenuation(deviceId, cd));
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    FlowId flowId = FlowId.valueOf(number(payload, FLOW_ID));
    long attenuation = payload.get(ATTENUATION).asLong();
    // Get connection information from the flow
    FlowEntry entry = findFlow(deviceId, flowId);
    if (entry == null) {
        log.error("Unable to find flow rule to set attenuation");
        return;
    }
    ChannelData channelData = ChannelData.fromFlow(entry);
    Range<Long> range = roadmService.attenuationRange(deviceId, channelData.outPort(), channelData.ochSignal());
    boolean validAttenuation = (range != null && range.contains(attenuation));
    if (validAttenuation) {
        roadmService.setAttenuation(deviceId, channelData.outPort(), channelData.ochSignal(), attenuation);
    }
    ObjectNode rootNode = objectNode();
    // Send back flowId so view can identify which callback function to use
    rootNode.put(FLOW_ID, payload.get(FLOW_ID).asText());
    rootNode.put(VALID, validAttenuation);
    if (range != null) {
        rootNode.put(MESSAGE, String.format(ATTENUATION_RANGE_MSG, range.toString()));
    } else {
        rootNode.put(MESSAGE, NO_ATTENUATION_MSG);
    }
    sendMessage(ROADM_SET_ATTENUATION_RESP, rootNode);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    FlowId flowId = FlowId.valueOf(number(payload, FLOW_ID));
    long attenuation = payload.get(ATTENUATION).asLong();
    // Get connection information from the flow
    FlowEntry entry = findFlow(deviceId, flowId);
    if (entry == null) {
        log.error("Unable to find flow rule to set attenuation");
        return;
    }
    ChannelData cd = ChannelData.fromFlow(entry);
    Range<Long> range = roadmService.attenuationRange(deviceId, cd.outPort(), cd.ochSignal());
    boolean validAttenuation = (range != null && range.contains(attenuation));
    if (validAttenuation) {
        roadmService.setAttenuation(deviceId, cd.outPort(), cd.ochSignal(), attenuation);
    }
    ObjectNode rootNode = objectNode();
    // Send back flowId so view can identify which callback function to use
    rootNode.put(FLOW_ID, payload.get(FLOW_ID).asText());
    rootNode.put(VALID, validAttenuation);
    if (range != null) {
        rootNode.put(MESSAGE, String.format(ATTENUATION_RANGE_MSG, range.toString()));
    } else {
        rootNode.put(MESSAGE, NO_ATTENUATION_MSG);
    }
    sendMessage(ROADM_SET_ATTENUATION_RESP, rootNode);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    FlowId flowId = FlowId.valueOf(payload.get(ID).asLong());
    roadmService.removeConnection(deviceId, flowId);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    FlowId flowId = FlowId.valueOf(payload.get(ID).asLong());
    roadmService.removeConnection(deviceId, flowId);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    DeviceId deviceId = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    ObjectNode flowNode = node(payload, FORM_DATA);
    int priority = (int) number(flowNode, PRIORITY);
    boolean permanent = bool(flowNode, PERMANENT);
    int timeout = (int) number(flowNode, TIMEOUT);
    PortNumber inPort = PortNumber.portNumber(number(flowNode, IN_PORT));
    PortNumber outPort = PortNumber.portNumber(number(flowNode, OUT_PORT));
    ObjectNode spacingNode = node(flowNode, CHANNEL_SPACING);
    ChannelSpacing spacing = channelSpacing((int) number(spacingNode, CHANNEL_SPACING_INDEX));
    int multiplier = (int) number(flowNode, CHANNEL_MULTIPLIER);
    OchSignal ochSignal = OchSignal.newDwdmSlot(spacing, multiplier);
    boolean includeAttenuation = bool(flowNode, INCLUDE_ATTENUATION);
    int attenuation = (int) number(flowNode, ATTENUATION);
    boolean validInputPort = roadmService.validInputPort(deviceId, inPort);
    boolean validOutputPort = roadmService.validOutputPort(deviceId, outPort);
    boolean validConnection = roadmService.validConnection(deviceId, inPort, outPort);
    boolean validSpacing = true;
    boolean validChannel = roadmService.validChannel(deviceId, inPort, ochSignal);
    boolean channelAvailable = roadmService.channelAvailable(deviceId, ochSignal);
    boolean validAttenuation = roadmService.attenuationInRange(deviceId, outPort, attenuation);
    if (validConnection && validChannel && channelAvailable) {
        if (includeAttenuation && validAttenuation) {
            roadmService.createConnection(deviceId, priority, permanent, timeout, inPort, outPort, ochSignal, attenuation);
        } else if (!includeAttenuation) {
            roadmService.createConnection(deviceId, priority, permanent, timeout, inPort, outPort, ochSignal);
        }
    }
    // Construct error for channel
    String channelMessage = "Invalid channel";
    if (!validChannel) {
        Set<OchSignal> lambdas = roadmService.queryLambdas(deviceId, outPort);
        if (lambdas != null) {
            Range<Integer> range = channelRange(lambdas);
            if (range.contains(ochSignal.spacingMultiplier())) {
                // Channel spacing error
                validSpacing = false;
            } else {
                channelMessage = String.format(CHANNEL_ERR_MSG, range.toString());
            }
        }
    }
    // Construct error for attenuation
    String attenuationMessage = "Invalid attenuation";
    if (!validAttenuation) {
        Range<Long> range = roadmService.attenuationRange(deviceId, outPort, ochSignal);
        if (range != null) {
            attenuationMessage = String.format(ATTENUATION_ERR_MSG, range.toString());
        }
    }
    // Build response
    ObjectNode node = objectNode();
    node.set(IN_PORT, validationObject(validInputPort, IN_PORT_ERR_MSG));
    node.set(OUT_PORT, validationObject(validOutputPort, OUT_PORT_ERR_MSG));
    node.set(CONNECTION, validationObject(validConnection, CONNECTION_ERR_MSG));
    node.set(CHANNEL_SPACING, validationObject(validChannel || validSpacing, CHANNEL_SPACING_ERR_MSG));
    node.set(CHANNEL_MULTIPLIER, validationObject(validChannel || !validSpacing, channelMessage));
    node.set(CHANNEL_AVAILABLE, validationObject(!validChannel || channelAvailable, CHANNEL_AVAILABLE_ERR_MSG));
    node.set(ATTENUATION, validationObject(validAttenuation, attenuationMessage));
    node.put(INCLUDE_ATTENUATION, includeAttenuation);
    sendMessage(ROADM_CREATE_FLOW_RESP, node);
}
#method_after
@Override
public void process(ObjectNode payload) {
    DeviceId did = DeviceId.deviceId(string(payload, DEV_ID, "(none)"));
    ObjectNode flowNode = node(payload, FORM_DATA);
    int priority = (int) number(flowNode, PRIORITY);
    boolean permanent = bool(flowNode, PERMANENT);
    int timeout = (int) number(flowNode, TIMEOUT);
    PortNumber inPort = PortNumber.portNumber(number(flowNode, IN_PORT));
    PortNumber outPort = PortNumber.portNumber(number(flowNode, OUT_PORT));
    ObjectNode chNode = node(flowNode, CHANNEL_SPACING);
    ChannelSpacing spacing = channelSpacing((int) number(chNode, CHANNEL_SPACING_INDEX));
    int multiplier = (int) number(flowNode, CHANNEL_MULTIPLIER);
    OchSignal och = OchSignal.newDwdmSlot(spacing, multiplier);
    boolean includeAttenuation = bool(flowNode, INCLUDE_ATTENUATION);
    long att = number(flowNode, ATTENUATION);
    boolean validInPort = roadmService.validInputPort(did, inPort);
    boolean validOutPort = roadmService.validOutputPort(did, outPort);
    boolean validConnect = roadmService.validConnection(did, inPort, outPort);
    boolean validSpacing = true;
    boolean validChannel = roadmService.validChannel(did, inPort, och);
    boolean channelAvailable = roadmService.channelAvailable(did, och);
    boolean validAttenuation = roadmService.attenuationInRange(did, outPort, att);
    if (validConnect && validChannel && channelAvailable) {
        if (includeAttenuation && validAttenuation) {
            roadmService.createConnection(did, priority, permanent, timeout, inPort, outPort, och, att);
        } else if (!includeAttenuation) {
            roadmService.createConnection(did, priority, permanent, timeout, inPort, outPort, och);
        }
    }
    // Construct error for channel
    String channelMessage = "Invalid channel";
    if (!validChannel) {
        Set<OchSignal> lambdas = roadmService.queryLambdas(did, outPort);
        if (lambdas != null) {
            Range<Integer> range = channelRange(lambdas);
            if (range.contains(och.spacingMultiplier())) {
                // Channel spacing error
                validSpacing = false;
            } else {
                channelMessage = String.format(CHANNEL_ERR_MSG, range.toString());
            }
        }
    }
    // Construct error for attenuation
    String attenuationMessage = "Invalid attenuation";
    if (!validAttenuation) {
        Range<Long> range = roadmService.attenuationRange(did, outPort, och);
        if (range != null) {
            attenuationMessage = String.format(ATTENUATION_ERR_MSG, range.toString());
        }
    }
    // Build response
    ObjectNode node = objectNode();
    node.set(IN_PORT, validationObject(validInPort, IN_PORT_ERR_MSG));
    node.set(OUT_PORT, validationObject(validOutPort, OUT_PORT_ERR_MSG));
    node.set(CONNECTION, validationObject(validConnect, CONNECTION_ERR_MSG));
    node.set(CHANNEL_SPACING, validationObject(validChannel || validSpacing, CHANNEL_SPACING_ERR_MSG));
    node.set(CHANNEL_MULTIPLIER, validationObject(validChannel || !validSpacing, channelMessage));
    node.set(CHANNEL_AVAILABLE, validationObject(!validChannel || channelAvailable, CHANNEL_AVAILABLE_ERR_MSG));
    node.set(ATTENUATION, validationObject(validAttenuation, attenuationMessage));
    node.put(INCLUDE_ATTENUATION, includeAttenuation);
    sendMessage(ROADM_CREATE_FLOW_RESP, node);
}
#end_block

#method_before
// Add a map to the store for a device if not already added.
@Override
public void addDevice(DeviceId deviceId) {
    if (!powerMap.containsKey(deviceId)) {
        Map<PortNumber, Long> portMap = new HashMap<>();
        powerMap.put(deviceId, portMap);
    }
    log.info("Initializing {}", deviceId.toString());
}
#method_after
// Add a map to the store for a device if not already added.
@Override
public void addDevice(DeviceId deviceId) {
    powerMap.putIfAbsent(deviceId, new HashMap<>());
    log.info("Initializing {}", deviceId);
}
#end_block

#method_before
@Override
public boolean deviceAvailable(DeviceId deviceId) {
    return powerMap.containsKey(deviceId) && powerMap.get(deviceId) != null;
}
#method_after
@Override
public boolean deviceAvailable(DeviceId deviceId) {
    return powerMap.get(deviceId) != null;
}
#end_block

#method_before
@Override
public void setTargetPower(DeviceId deviceId, PortNumber portNumber, long targetPower) {
    if (deviceAvailable(deviceId)) {
        Map<PortNumber, Long> portMap = powerMap.get(deviceId);
        portMap.put(portNumber, targetPower);
        powerMap.put(deviceId, portMap);
    } else {
        log.info("Device " + deviceId.toString() + " not found in store");
    }
}
#method_after
@Override
public void setTargetPower(DeviceId deviceId, PortNumber portNumber, long targetPower) {
    Map<PortNumber, Long> portMap = powerMap.get(deviceId);
    if (portMap != null) {
        portMap.put(portNumber, targetPower);
        powerMap.put(deviceId, portMap);
    } else {
        log.info("Device {} not found in store", deviceId);
    }
}
#end_block

#method_before
@Override
public Long getTargetPower(DeviceId deviceId, PortNumber portNumber) {
    if (deviceAvailable(deviceId)) {
        Map<PortNumber, Long> portMap = powerMap.get(deviceId);
        if (portMap.containsKey(portNumber)) {
            return portMap.get(portNumber);
        }
    }
    return null;
}
#method_after
@Override
public Long getTargetPower(DeviceId deviceId, PortNumber portNumber) {
    Map<PortNumber, Long> portMap = powerMap.get(deviceId);
    if (portMap != null) {
        return portMap.get(portNumber);
    }
    return null;
}
#end_block

#method_before
@Override
public void apply(FlowRuleOperations ops) {
// TODO : call virtual flow rule provider's apply()
}
#method_after
@Override
public void apply(FlowRuleOperations ops) {
    operationsService.execute(new FlowOperationsProcessor(ops));
}
#end_block

#method_before
@Override
public VirtualNetwork network() {
    return network;
}
#method_after
@Override
public VirtualNetwork network() {
    return this.network;
}
#end_block

#method_before
private void mastershipCheck() {
    log.debug("Checking mastership");
    for (Device device : getDevices()) {
        final DeviceId deviceId = device.id();
        MastershipRole myRole = mastershipService.getLocalRole(deviceId);
        log.trace("Checking device {}. Current role is {}", deviceId, myRole);
        if (!isReachable(deviceId)) {
            if (myRole != NONE) {
                // can't be master if device is not reachable
                try {
                    if (myRole == MASTER) {
                        post(store.markOffline(deviceId));
                    }
                    // relinquish master role and ability to be backup.
                    mastershipService.relinquishMastership(deviceId).get();
                } catch (InterruptedException e) {
                    log.warn("Interrupted while reliquishing role for {}", deviceId);
                    Thread.currentThread().interrupt();
                } catch (ExecutionException e) {
                    log.error("Exception thrown while relinquishing role for {}", deviceId, e);
                }
            }
            continue;
        }
        if (myRole != NONE) {
            continue;
        }
        // check if the device has master, if not, mark it offline
        NodeId masterId = mastershipService.getMasterFor(deviceId);
        if (masterId == null) {
            post(store.markOffline(deviceId));
            continue;
        }
        log.info("{} is reachable but did not have a valid role, reasserting", deviceId);
        // isReachable but was not MASTER or STANDBY, get a role and apply
        // Note: NONE triggers request to MastershipService
        reassertRole(deviceId, NONE);
    }
}
#method_after
private void mastershipCheck() {
    log.debug("Checking mastership");
    for (Device device : getDevices()) {
        final DeviceId deviceId = device.id();
        MastershipRole myRole = mastershipService.getLocalRole(deviceId);
        log.trace("Checking device {}. Current role is {}", deviceId, myRole);
        if (!isReachable(deviceId)) {
            if (myRole != NONE) {
                // can't be master if device is not reachable
                try {
                    if (myRole == MASTER) {
                        post(store.markOffline(deviceId));
                    }
                    // relinquish master role and ability to be backup.
                    mastershipService.relinquishMastership(deviceId).get();
                } catch (InterruptedException e) {
                    log.warn("Interrupted while reliquishing role for {}", deviceId);
                    Thread.currentThread().interrupt();
                } catch (ExecutionException e) {
                    log.error("Exception thrown while relinquishing role for {}", deviceId, e);
                }
            } else {
                // check if the device has master, if not, mark it offline
                NodeId masterId = mastershipService.getMasterFor(deviceId);
                // only the nodes which has mastership role can mark any device offline.
                CompletableFuture<MastershipRole> roleFuture = mastershipService.requestRoleFor(deviceId);
                roleFuture.thenAccept(role -> {
                    MastershipTerm term = termService.getMastershipTerm(deviceId);
                    if (term != null && localNodeId.equals(term.master())) {
                        log.info("Marking unreachable device {} offline", deviceId);
                        post(store.markOffline(deviceId));
                    } else {
                        log.info("Failed marking {} offline. {}", deviceId, role);
                    }
                    mastershipService.relinquishMastership(deviceId);
                });
            }
            continue;
        }
        if (myRole != NONE) {
            continue;
        }
        log.info("{} is reachable but did not have a valid role, reasserting", deviceId);
        // isReachable but was not MASTER or STANDBY, get a role and apply
        // Note: NONE triggers request to MastershipService
        reassertRole(deviceId, NONE);
    }
}
#end_block

#method_before
private void removeFloatingIpRules(IpAddress floatingIp, Host associatedVm) {
    Optional<IpAddress> fixedIp = associatedVm.ipAddresses().stream().findFirst();
    if (!fixedIp.isPresent()) {
        log.warn("Failed to remove floating IP({}) from {}", floatingIp, associatedVm);
        return;
    }
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(associatedVm.annotations().value(VXLAN_ID))).matchIPSrc(fixedIp.get().toIpPrefix());
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floatingIp.toIpPrefix());
    gatewayService.getGatewayDeviceIds().forEach(deviceId -> {
        TrafficSelector.Builder sForTrafficFromVmBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floatingIp.toIpPrefix()).matchInPort(nodeService.tunnelPort(deviceId).get());
        RulePopulatorUtil.removeRule(flowObjectiveService, appId, deviceId, sOutgoingBuilder.build(), DefaultTrafficTreatment.builder().build(), ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
        RulePopulatorUtil.removeRule(flowObjectiveService, appId, deviceId, sIncomingBuilder.build(), DefaultTrafficTreatment.builder().build(), ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
        RulePopulatorUtil.removeRule(flowObjectiveService, appId, deviceId, sForTrafficFromVmBuilder.build(), DefaultTrafficTreatment.builder().build(), ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_FOR_TRAFFIC_FROM_VM_PRIORITY);
    });
}
#method_after
private void removeFloatingIpRules(IpAddress floatingIp, Host associatedVm) {
    Optional<IpAddress> fixedIp = associatedVm.ipAddresses().stream().findFirst();
    if (!fixedIp.isPresent()) {
        log.warn("Failed to remove floating IP({}) from {}", floatingIp, associatedVm);
        return;
    }
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(associatedVm.annotations().value(VXLAN_ID))).matchIPSrc(fixedIp.get().toIpPrefix());
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floatingIp.toIpPrefix());
    gatewayService.getGatewayDeviceIds().forEach(deviceId -> {
        TrafficSelector.Builder sForTrafficFromVmBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floatingIp.toIpPrefix()).matchInPort(nodeService.tunnelPort(deviceId).get());
        RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, sOutgoingBuilder.build(), DefaultTrafficTreatment.builder().build(), ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY, false);
        RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, sIncomingBuilder.build(), DefaultTrafficTreatment.builder().build(), ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY, false);
        RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, sForTrafficFromVmBuilder.build(), DefaultTrafficTreatment.builder().build(), ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_FOR_TRAFFIC_FROM_VM_PRIORITY, false);
    });
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    nodeService.removeListener(nodeListener);
    log.info("stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    super.deactivate();
    nodeService.removeListener(nodeListener);
    log.info("stopped");
}
#end_block

#method_before
@Override
protected void hostDetected(Host host) {
// Do nothing
}
#method_after
@Override
protected void hostDetected(Host host) {
    // Installs forwarding flow rules to VMs in different nodes and different subnets
    // that are connected via a router
    Optional<OpenstackRouter> routerOfTheHost = getRouter(host);
    if (!routerOfTheHost.isPresent()) {
        return;
    }
    routableSubNets(routerOfTheHost.get().id()).stream().filter(subnet -> !subnet.id().equals(host.annotations().value(SUBNET_ID))).forEach(subnet -> setForwardingRulesAmongHostsInDifferentCnodes(host, getHosts(subnet), true));
}
#end_block

#method_before
@Override
protected void hostRemoved(Host host) {
// Do nothing
}
#method_after
@Override
protected void hostRemoved(Host host) {
    // Removes forwarding flow rules to VMs in different nodes and different subnets
    // that are connected via a router
    Optional<OpenstackRouter> routerOfTheHost = getRouter(host);
    if (!routerOfTheHost.isPresent()) {
        return;
    }
    routableSubNets(routerOfTheHost.get().id()).stream().filter(subnet -> !subnet.id().equals(host.annotations().value(SUBNET_ID))).forEach(subnet -> setForwardingRulesAmongHostsInDifferentCnodes(host, getHosts(subnet), false));
}
#end_block

#method_before
@Override
public void updateRouter(OpenstackRouter osRouter) {
    if (osRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        openstackService.ports().stream().filter(osPort -> osPort.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE) && osPort.deviceId().equals(osRouter.id())).forEach(osPort -> {
            String subnetId = osPort.fixedIps().keySet().stream().findFirst().get();
            setExternalConnection(osRouter, subnetId);
        });
        log.info("Connected external gateway {} to router {}", osRouter.gatewayExternalInfo().externalFixedIps(), osRouter.name());
    } else {
        openstackService.ports().stream().filter(osPort -> osPort.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE) && osPort.deviceId().equals(osRouter.id())).forEach(osPort -> {
            String subnetId = osPort.fixedIps().keySet().stream().findFirst().get();
            OpenstackSubnet osSubNet = openstackService.subnet(subnetId);
            removeExternalConnection(osRouter, osSubNet);
        });
        log.info("Disconnected external gateway from router {}", osRouter.name());
    }
}
#method_after
@Override
public void updateRouter(OpenstackRouter osRouter) {
    if (osRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        routableSubNets(osRouter.id()).stream().forEach(subnet -> setExternalConnection(osRouter, subnet, true));
        log.info("Connected external gateway {} to router {}", osRouter.gatewayExternalInfo().externalFixedIps(), osRouter.name());
    } else {
        routableSubNets(osRouter.id()).stream().forEach(subnet -> setExternalConnection(osRouter, subnet, false));
        log.info("Disconnected external gateway from router {}", osRouter.name());
    }
}
#end_block

#method_before
private void handleRouterInterfaces(OpenstackRouter osRouter, OpenstackSubnet osSubnetAdded) {
    OpenstackNetwork osNetworkAdded = openstackService.network(osSubnetAdded.networkId());
    if (osNetworkAdded == null) {
        // in case of external network subnet
        return;
    }
    // Sets flow rules for routing among subnets connected to a router.
    setRoutesAmongSubnets(osRouter, osSubnetAdded);
    // Sets flow rules for forwarding "packets going to external networks" to gateway nodes.
    if (osRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        setExternalConnection(osRouter, osSubnetAdded.id());
    }
    // Sets flow rules to handle ping to the virtual gateway.
    Ip4Address vGatewayIp = Ip4Address.valueOf(osSubnetAdded.gatewayIp());
    gatewayService.getGatewayDeviceIds().forEach(deviceId -> populateGatewayIcmpRule(vGatewayIp, deviceId));
}
#method_after
private void handleRouterInterfaces(OpenstackRouter osRouter, OpenstackSubnet osSubnetAdded) {
    OpenstackNetwork osNetworkAdded = openstackService.network(osSubnetAdded.networkId());
    if (osNetworkAdded == null) {
        // in case of external network subnet
        return;
    }
    // Sets flow rules for routing among subnets connected to a router.
    setRoutesAmongSubnets(osRouter, osSubnetAdded, true);
    // Sets flow rules for forwarding "packets going to external networks" to gateway nodes.
    if (osRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        setExternalConnection(osRouter, osSubnetAdded, true);
    }
    // Sets flow rules to handle ping to the virtual gateway.
    Ip4Address vGatewayIp = Ip4Address.valueOf(osSubnetAdded.gatewayIp());
    gatewayService.getGatewayDeviceIds().forEach(deviceId -> setGatewayIcmpRule(vGatewayIp, deviceId, true));
    // Sets east-west routing rules for VMs in different Cnode to Switching Table.
    setForwardingRulesForEastWestRouting(osRouter, osSubnetAdded, true);
}
#end_block

#method_before
private void handleRouterInterfacesRemoved(OpenstackRouter osRouter, OpenstackSubnet osSubnetRemoved) {
    // Removes flow rules for routing among subnets connected to a router.
    removeRoutesAmongSubnets(osRouter, osSubnetRemoved);
    // Removes flow rules for forwarding "packets going to external networks" to gateway nodes.
    if (osRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        removeExternalConnection(osRouter, osSubnetRemoved);
    }
    // Removes flow rules to handle ping to the virtual gateway.
    Ip4Address vGatewayIp = Ip4Address.valueOf(osSubnetRemoved.gatewayIp());
    gatewayService.getGatewayDeviceIds().forEach(deviceId -> removeGatewayIcmpRule(vGatewayIp, deviceId));
}
#method_after
private void handleRouterInterfacesRemoved(OpenstackRouter osRouter, OpenstackSubnet osSubnetRemoved) {
    // Removes flow rules for routing among subnets connected to a router.
    setRoutesAmongSubnets(osRouter, osSubnetRemoved, false);
    // Removes flow rules for forwarding "packets going to external networks" to gateway nodes.
    if (osRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        setExternalConnection(osRouter, osSubnetRemoved, false);
    }
    // Removes flow rules to handle ping to the virtual gateway.
    Ip4Address vGatewayIp = Ip4Address.valueOf(osSubnetRemoved.gatewayIp());
    gatewayService.getGatewayDeviceIds().forEach(deviceId -> setGatewayIcmpRule(vGatewayIp, deviceId, false));
    // Removes east-west routing rules for VMs in different Cnode to Switching Table.
    setForwardingRulesForEastWestRouting(osRouter, osSubnetRemoved, false);
    // Resets east-west routing rules for VMs in different Cnode to Switching Table.
    routableSubNets(osRouter.id()).stream().forEach(subnet -> setForwardingRulesForEastWestRouting(osRouter, subnet, true));
}
#end_block

#method_before
private void setRoutesAmongSubnets(OpenstackRouter osRouter, OpenstackSubnet osSubnetAdded) {
    Set<OpenstackSubnet> routableSubNets = routableSubNets(osRouter.id());
    if (routableSubNets.size() < 2) {
        // no other subnet interface is connected to this router, do nothing
        return;
    }
    Map<String, String> vniMap = new HashMap<>();
    openstackService.networks().forEach(n -> vniMap.put(n.id(), n.segmentId()));
    routableSubNets.stream().filter(subnet -> !subnet.id().equals(osSubnetAdded.id())).filter(subnet -> vniMap.get(subnet.networkId()) != null).forEach(subnet -> nodeService.completeNodes().stream().filter(node -> node.type().equals(COMPUTE)).forEach(node -> {
        populateRoutingRules(node.intBridge(), Integer.parseInt(vniMap.get(subnet.networkId())), Integer.parseInt(vniMap.get(osSubnetAdded.networkId())), subnet, osSubnetAdded);
        populateRoutingRules(node.intBridge(), Integer.parseInt(vniMap.get(osSubnetAdded.networkId())), Integer.parseInt(vniMap.get(subnet.networkId())), osSubnetAdded, subnet);
    }));
}
#method_after
private void setRoutesAmongSubnets(OpenstackRouter osRouter, OpenstackSubnet osSubnetAdded, boolean install) {
    Set<OpenstackSubnet> routableSubNets = routableSubNets(osRouter.id());
    if (routableSubNets.size() < 2) {
        // no other subnet interface is connected to this router, do nothing
        return;
    }
    Map<String, String> vniMap = new HashMap<>();
    openstackService.networks().forEach(n -> vniMap.put(n.id(), n.segmentId()));
    routableSubNets.stream().filter(subnet -> !subnet.id().equals(osSubnetAdded.id())).filter(subnet -> vniMap.get(subnet.networkId()) != null).forEach(subnet -> nodeService.completeNodes().stream().filter(node -> node.type().equals(COMPUTE)).forEach(node -> {
        setRoutingRules(node.intBridge(), Integer.parseInt(vniMap.get(subnet.networkId())), Integer.parseInt(vniMap.get(osSubnetAdded.networkId())), subnet, osSubnetAdded, install);
        setRoutingRules(node.intBridge(), Integer.parseInt(vniMap.get(osSubnetAdded.networkId())), Integer.parseInt(vniMap.get(subnet.networkId())), osSubnetAdded, subnet, install);
    }));
}
#end_block

#method_before
private void setExternalConnection(OpenstackRouter osRouter, String osSubNetId) {
    if (!osRouter.gatewayExternalInfo().isEnablePnat()) {
        log.debug("Source NAT is disabled");
        return;
    }
    OpenstackSubnet osSubNet = openstackService.subnet(osSubNetId);
    OpenstackNetwork osNet = openstackService.network(osSubNet.networkId());
    nodeService.completeNodes().stream().filter(node -> node.type().equals(COMPUTE)).forEach(node -> populateRulesToGateway(node.intBridge(), gatewayService.getGatewayGroupId(node.intBridge()), Long.valueOf(osNet.segmentId()), osSubNet.cidr()));
    // Is this for PNAT ??
    populateRulesForGatewayToController(Long.valueOf(osNet.segmentId()), osSubNet.cidr());
}
#method_after
private void setExternalConnection(OpenstackRouter osRouter, OpenstackSubnet osSubNet, boolean install) {
    if (!osRouter.gatewayExternalInfo().isEnablePnat()) {
        log.debug("Source NAT is disabled");
        return;
    }
    // OpenstackSubnet osSubNet = openstackService.subnet(osSubNetId);
    OpenstackNetwork osNet = openstackService.network(osSubNet.networkId());
    nodeService.completeNodes().stream().filter(node -> node.type().equals(COMPUTE)).forEach(node -> setRulesToGateway(node.intBridge(), gatewayService.getGatewayGroupId(node.intBridge()), Long.valueOf(osNet.segmentId()), osSubNet.cidr(), install));
    // Is this for PNAT ??
    setRulesForGatewayToController(Long.valueOf(osNet.segmentId()), osSubNet.cidr(), install);
}
#end_block

#method_before
@Override
public void reinstallVmFlow(Host host) {
// Do nothing
}
#method_after
@Override
public void reinstallVmFlow(Host host) {
// TODO: implements later
}
#end_block

#method_before
@Override
public void purgeVmFlow(Host host) {
// Do nothing
}
#method_after
@Override
public void purgeVmFlow(Host host) {
// TODO: implements later
}
#end_block

#method_before
private static UnderlayBuilder te2YangConfigUnderlayPrimaryPath(UnderlayBuilder yangBuilder, TeLink teLink) {
    org.onosproject.tetopology.management.api.link.UnderlayPrimaryPath tePath = teLink.primaryPath();
    UnderlayPrimaryPathBuilder pathBuilder = DefaultUnderlayPrimaryPath.builder();
    if (tePath.pathElements() != null) {
        for (PathElement pathElementTe : tePath.pathElements()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.telinkunderlayattributes.underlayprimarypath.PathElement.PathElementBuilder pathElementYangBuilder = DefaultPathElement.builder();
            pathElementYangBuilder = pathElementYangBuilder.pathElementId(pathElementTe.pathElementId());
            // TODO: add some Type cross converter
            // pathElementYangBuilder = pathElementYangBuilder.type(Type pathElementTe.type())
            pathBuilder = pathBuilder.addToPathElement(pathElementYangBuilder.build());
        }
    }
    pathBuilder = pathBuilder.clientIdRef(teLink.underlayTeTopologyId().clientId()).providerIdRef(teLink.underlayTeTopologyId().providerId()).teTopologyIdRef(teLink.underlayTeTopologyId().topologyId());
    return yangBuilder.underlayPrimaryPath(pathBuilder.build());
}
#method_after
private static UnderlayBuilder te2YangConfigUnderlayPrimaryPath(UnderlayBuilder yangBuilder, TeLink teLink, TeTopologyService teTopologyService) {
    org.onosproject.tetopology.management.api.link.UnderlayPrimaryPath tePath = teLink.primaryPath();
    UnderlayPrimaryPathBuilder pathBuilder = DefaultUnderlayPrimaryPath.builder();
    if (tePath.pathElements() != null) {
        for (PathElement pathElementTe : tePath.pathElements()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.telinkunderlayattributes.underlayprimarypath.PathElement.PathElementBuilder pathElementYangBuilder = DefaultPathElement.builder();
            pathElementYangBuilder = pathElementYangBuilder.pathElementId(pathElementTe.pathElementId());
            // TODO: add some Type cross converter
            // pathElementYangBuilder = pathElementYangBuilder.type(Type pathElementTe.type())
            pathBuilder = pathBuilder.addToPathElement(pathElementYangBuilder.build());
        }
    }
    pathBuilder = pathBuilder.clientIdRef(teLink.underlayTeTopologyId().clientId()).providerIdRef(teLink.underlayTeTopologyId().providerId()).teTopologyIdRef(teLink.underlayTeTopologyId().topologyId());
    pathBuilder = pathBuilder.networkIdRef(teTopologyService.networkId(teLink.underlayTeTopologyId()));
    return yangBuilder.underlayPrimaryPath(pathBuilder.build());
}
#end_block

#method_before
private static UnderlayBuilder te2YangConfigUnderlayBackupPaths(UnderlayBuilder yangBuilder, TeLink teLink) {
    List<UnderlayBackupPath> tePaths = teLink.backupPaths();
    for (UnderlayBackupPath tePath : tePaths) {
        UnderlayBackupPathBuilder pathBuilder = DefaultUnderlayBackupPath.builder();
        pathBuilder = pathBuilder.index(tePath.index());
        pathBuilder = pathBuilder.clientIdRef(teLink.underlayTeTopologyId().clientId()).providerIdRef(teLink.underlayTeTopologyId().providerId()).teTopologyIdRef(teLink.underlayTeTopologyId().topologyId());
        for (PathElement backupPathElementTe : tePath.pathElements()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.telinkunderlayattributes.underlaybackuppath.PathElement.PathElementBuilder elementBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.telinkunderlayattributes.underlaybackuppath.DefaultPathElement.builder();
            elementBuilder = elementBuilder.pathElementId(backupPathElementTe.pathElementId());
            // TODO: add some Type cross conversion
            // elementBuilder.type(type);
            pathBuilder = pathBuilder.addToPathElement(elementBuilder.build());
        }
        yangBuilder = yangBuilder.addToUnderlayBackupPath(pathBuilder.build());
    }
    return yangBuilder;
}
#method_after
private static UnderlayBuilder te2YangConfigUnderlayBackupPaths(UnderlayBuilder yangBuilder, TeLink teLink, TeTopologyService teTopologyService) {
    List<UnderlayBackupPath> tePaths = teLink.backupPaths();
    for (UnderlayBackupPath tePath : tePaths) {
        UnderlayBackupPathBuilder pathBuilder = DefaultUnderlayBackupPath.builder();
        pathBuilder = pathBuilder.index(tePath.index());
        pathBuilder = pathBuilder.clientIdRef(teLink.underlayTeTopologyId().clientId()).providerIdRef(teLink.underlayTeTopologyId().providerId()).teTopologyIdRef(teLink.underlayTeTopologyId().topologyId());
        pathBuilder = pathBuilder.networkIdRef(teTopologyService.networkId(teLink.underlayTeTopologyId()));
        for (PathElement backupPathElementTe : tePath.pathElements()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.telinkunderlayattributes.underlaybackuppath.PathElement.PathElementBuilder elementBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.telinkunderlayattributes.underlaybackuppath.DefaultPathElement.builder();
            elementBuilder = elementBuilder.pathElementId(backupPathElementTe.pathElementId());
            // TODO: add some Type cross conversion
            // elementBuilder.type(type);
            pathBuilder = pathBuilder.addToPathElement(elementBuilder.build());
        }
        yangBuilder = yangBuilder.addToUnderlayBackupPath(pathBuilder.build());
    }
    return yangBuilder;
}
#end_block

#method_before
public static NetworkLinkKey yangLinkEvent2NetworkLinkKey(TeLinkEvent yangLinkEvent) {
    // TODO: Implementation will be submitted as a separate review
    NetworkId networkRef = (NetworkId) (yangLinkEvent.networkRef());
    LinkId linkRef = (LinkId) (yangLinkEvent.linkRef());
    KeyId networkId = KeyId.keyId(networkRef.uri().toString());
    KeyId linkId = KeyId.keyId(linkRef.uri().toString());
    NetworkLinkKey networkLinkKey = new NetworkLinkKey(networkId, linkId);
    return networkLinkKey;
}
#method_after
public static NetworkLinkKey yangLinkEvent2NetworkLinkKey(TeLinkEvent yangLinkEvent) {
    NetworkId networkRef = NetworkId.fromString(yangLinkEvent.networkRef().toString());
    LinkId linkRef = LinkId.fromString(yangLinkEvent.linkRef().toString());
    KeyId networkId = KeyId.keyId(networkRef.uri().toString());
    KeyId linkId = KeyId.keyId(linkRef.uri().toString());
    NetworkLinkKey networkLinkKey = new NetworkLinkKey(networkId, linkId);
    return networkLinkKey;
}
#end_block

#method_before
private static Config teNode2YangConfig(TeNode teSubsystemTeNode) {
    checkNotNull(teSubsystemTeNode, E_NULL_TE_SUBSYSTEM_TE_NODE);
    TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesConfigBuilder = DefaultTeNodeAttributes.builder();
    teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.isAbstract(teSubsystemTeNode.flags().get(TeNode.BIT_ABSTRACT));
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teSubsystemTeNode.adminStatus()));
    }
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTeTopologyId() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.underlayTopology(teNode2YangUnderlay(teSubsystemTeNode.underlayTeTopologyId()));
    }
    if (teSubsystemTeNode.connectivityMatrices() != null) {
        teNodeAttributesConfigBuilder = te2YangConnectivityMatrix(teNodeAttributesConfigBuilder, teSubsystemTeNode.connectivityMatrices());
    }
    Config.ConfigBuilder yangConfigBuilder = DefaultConfig.builder();
    yangConfigBuilder = yangConfigBuilder.teNodeAttributes(teNodeAttributesConfigBuilder.build());
    return yangConfigBuilder.build();
}
#method_after
private static Config teNode2YangConfig(TeNode teSubsystemTeNode, TeTopologyService teTopologyService) {
    checkNotNull(teSubsystemTeNode, E_NULL_TE_SUBSYSTEM_TE_NODE);
    TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesConfigBuilder = DefaultTeNodeAttributes.builder();
    teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.isAbstract(teSubsystemTeNode.flags().get(TeNode.BIT_ABSTRACT));
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teSubsystemTeNode.adminStatus()));
    }
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTeTopologyId() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.underlayTopology(teNode2YangUnderlay(teSubsystemTeNode.underlayTeTopologyId(), teTopologyService));
    }
    if (teSubsystemTeNode.connectivityMatrices() != null) {
        teNodeAttributesConfigBuilder = te2YangConnectivityMatrix(teNodeAttributesConfigBuilder, teSubsystemTeNode.connectivityMatrices());
    }
    Config.ConfigBuilder yangConfigBuilder = DefaultConfig.builder();
    yangConfigBuilder = yangConfigBuilder.teNodeAttributes(teNodeAttributesConfigBuilder.build());
    return yangConfigBuilder.build();
}
#end_block

#method_before
private static TeNodeAttributesBuilder te2YangConnectivityMatrix(TeNodeAttributesBuilder teNodeAttributesConfigBuilder, Map<Long, ConnectivityMatrix> connectivityMatrices) {
    ConnectivityMatrixBuilder connectivityMatrixConfigBuilder = DefaultConnectivityMatrix.builder();
    for (Map.Entry<Long, ConnectivityMatrix> teCmEntry : connectivityMatrices.entrySet()) {
        connectivityMatrixConfigBuilder = connectivityMatrixConfigBuilder.id(teCmEntry.getKey()).isAllowed(!teCmEntry.getValue().flags().get(ConnectivityMatrix.BIT_DISALLOWED)).from(// TODO: for now, assuming that there is
        new DefaultFrom.FromBuilder().tpRef(teCmEntry.getValue().from()).build()).to(// TODO: for now, assuming that there is only
        new DefaultTo.ToBuilder().tpRef(teCmEntry.getValue().constrainingElements().get(0)).build());
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.addToConnectivityMatrix(connectivityMatrixConfigBuilder.build());
    }
    return teNodeAttributesConfigBuilder;
}
#method_after
private static TeNodeAttributesBuilder te2YangConnectivityMatrix(TeNodeAttributesBuilder teNodeAttributesConfigBuilder, Map<Long, ConnectivityMatrix> connectivityMatrices) {
    ConnectivityMatrixBuilder connectivityMatrixConfigBuilder = DefaultConnectivityMatrix.builder();
    for (Map.Entry<Long, ConnectivityMatrix> teCmEntry : connectivityMatrices.entrySet()) {
        connectivityMatrixConfigBuilder = connectivityMatrixConfigBuilder.id(teCmEntry.getKey()).isAllowed(!teCmEntry.getValue().flags().get(ConnectivityMatrix.BIT_DISALLOWED)).from(// TODO: for now, assuming that there is
        new DefaultFrom.FromBuilder().tpRef(((TeLinkId) teCmEntry.getValue().from()).value()).build()).to(// TODO: for now, assuming that there is only
        new DefaultTo.ToBuilder().tpRef(((TeLinkId) teCmEntry.getValue().constrainingElements().get(0)).value()).build());
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.addToConnectivityMatrix(connectivityMatrixConfigBuilder.build());
    }
    return teNodeAttributesConfigBuilder;
}
#end_block

#method_before
private static UnderlayTopology teNode2YangUnderlay(TeTopologyKey underlayTopology) {
    UnderlayTopology.UnderlayTopologyBuilder underlayBuilder = DefaultUnderlayTopology.builder().teTopologyIdRef(TeTopologyId.fromString(String.valueOf(underlayTopology.topologyId()))).clientIdRef(underlayTopology.clientId()).providerIdRef(underlayTopology.providerId());
    // .networkIdRef(networkIdRef)
    return underlayBuilder.build();
}
#method_after
private static UnderlayTopology teNode2YangUnderlay(TeTopologyKey underlayTopology, TeTopologyService teTopologyService) {
    UnderlayTopology.UnderlayTopologyBuilder underlayBuilder = DefaultUnderlayTopology.builder().teTopologyIdRef(TeTopologyId.fromString(String.valueOf(underlayTopology.topologyId()))).clientIdRef(underlayTopology.clientId()).providerIdRef(underlayTopology.providerId());
    underlayBuilder = underlayBuilder.networkIdRef(teTopologyService.networkId(underlayTopology));
    return underlayBuilder.build();
}
#end_block

#method_before
private static State teNode2YangState(TeNode teSubsystemTeNode) {
    checkNotNull(teSubsystemTeNode, E_NULL_TE_SUBSYSTEM_TE_NODE);
    TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesStateBuilder = DefaultTeNodeAttributes.builder().isAbstract(teSubsystemTeNode.flags().get(TeNode.BIT_ABSTRACT));
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teSubsystemTeNode.adminStatus()));
    }
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTeTopologyId() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.underlayTopology(teNode2YangUnderlay(teSubsystemTeNode.underlayTeTopologyId()));
    }
    if (teSubsystemTeNode.connectivityMatrices() != null) {
        teNodeAttributesStateBuilder = te2YangConnectivityMatrix(teNodeAttributesStateBuilder, teSubsystemTeNode.connectivityMatrices());
    }
    // TODO: should we ignore this from te to yang? as we've already set yang supportingNode
    // if (teSubsystemTeNode.supportingTeNodeId() != null) {
    // }
    State.StateBuilder yangStateBuilder = DefaultState.builder();
    yangStateBuilder = yangStateBuilder.teNodeAttributes(teNodeAttributesStateBuilder.build());
    if (teSubsystemTeNode.opStatus() != null) {
        yangStateBuilder = yangStateBuilder.operStatus(EnumConverter.teSubsystem2YangOperStatus(teSubsystemTeNode.opStatus()));
    }
    if (teSubsystemTeNode.sourceTeNodeId() != null) {
        InformationSourceState.InformationSourceStateBuilder issBuilder = DefaultInformationSourceState.builder();
        Topology.TopologyBuilder topologyBuilder = DefaultTopology.builder();
        topologyBuilder = topologyBuilder.clientIdRef(teSubsystemTeNode.sourceTeNodeId().clientId()).providerIdRef(teSubsystemTeNode.sourceTeNodeId().providerId()).teTopologyIdRef(teSubsystemTeNode.sourceTeNodeId().topologyId());
        issBuilder = issBuilder.topology(topologyBuilder.build());
        yangStateBuilder.informationSourceState(issBuilder.build());
    }
    return yangStateBuilder.build();
}
#method_after
private static State teNode2YangState(TeNode teSubsystemTeNode, TeTopologyService teTopologyService) {
    checkNotNull(teSubsystemTeNode, E_NULL_TE_SUBSYSTEM_TE_NODE);
    TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesStateBuilder = DefaultTeNodeAttributes.builder().isAbstract(teSubsystemTeNode.flags().get(TeNode.BIT_ABSTRACT));
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teSubsystemTeNode.adminStatus()));
    }
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTeTopologyId() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.underlayTopology(teNode2YangUnderlay(teSubsystemTeNode.underlayTeTopologyId(), teTopologyService));
    }
    if (teSubsystemTeNode.connectivityMatrices() != null) {
        teNodeAttributesStateBuilder = te2YangConnectivityMatrix(teNodeAttributesStateBuilder, teSubsystemTeNode.connectivityMatrices());
    }
    // TODO: should we ignore this from te to yang? as we've already set yang supportingNode
    // if (teSubsystemTeNode.supportingTeNodeId() != null) {
    // }
    State.StateBuilder yangStateBuilder = DefaultState.builder();
    yangStateBuilder = yangStateBuilder.teNodeAttributes(teNodeAttributesStateBuilder.build());
    if (teSubsystemTeNode.opStatus() != null) {
        yangStateBuilder = yangStateBuilder.operStatus(EnumConverter.teSubsystem2YangOperStatus(teSubsystemTeNode.opStatus()));
    }
    if (teSubsystemTeNode.sourceTeNodeId() != null) {
        InformationSourceState.InformationSourceStateBuilder issBuilder = DefaultInformationSourceState.builder();
        Topology.TopologyBuilder topologyBuilder = DefaultTopology.builder();
        topologyBuilder = topologyBuilder.clientIdRef(teSubsystemTeNode.sourceTeNodeId().clientId()).providerIdRef(teSubsystemTeNode.sourceTeNodeId().providerId()).teTopologyIdRef(teSubsystemTeNode.sourceTeNodeId().topologyId());
        issBuilder = issBuilder.topology(topologyBuilder.build());
        yangStateBuilder.informationSourceState(issBuilder.build());
    }
    return yangStateBuilder.build();
}
#end_block

#method_before
private static TunnelTerminationPoint teSubsystem2YangTtp(org.onosproject.tetopology.management.api.node.TunnelTerminationPoint teTunnelTp, Long teTpId) {
    checkNotNull(teTunnelTp, E_NULL_TE_SUBSYSTEM_TE_TUNNEL_TP);
    TunnelTerminationPoint.TunnelTerminationPointBuilder tunnelTpBuilder = DefaultTunnelTerminationPoint.builder().tunnelTpId(ByteUtils.longToBytes(teTpId.longValue()));
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.Config.ConfigBuilder ttpConfigBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.DefaultConfig.builder();
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.State.StateBuilder ttpStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.DefaultState.builder();
    // Assuming teTunnelTp only has one interLayerLock
    if (teTunnelTp.interLayerLockList() != null && !teTunnelTp.interLayerLockList().isEmpty()) {
        ttpConfigBuilder = ttpConfigBuilder.interLayerLockId(teTunnelTp.interLayerLockList().get(0));
        ttpStateBuilder = ttpStateBuilder.interLayerLockId(teTunnelTp.interLayerLockList().get(0));
    }
    // TerminationCapability.TerminationCapabilityBuilder
    // tcapConfigBuilder = DefaultTerminationCapability.builder();
    // // TODO: retrieve more attributes from teTunnelTp and assign to tcapConfigBuilder.
    // // For which ones we can do the conversion?
    // // FIXME: once new yang model is used, we can make llc from teTunnelTp.localLinkConnectivityList()
    // ttpConfigBuilder = ttpConfigBuilder.addToTerminationCapability(tcapConfigBuilder.build());
    // 
    // TerminationCapability.TerminationCapabilityBuilder tcapStateBuilder =
    // DefaultTerminationCapability.builder();
    // // TODO: retrieve more attributes from teTunnelTp and assign to tcapStateBuilder
    // // For which ones we can do the conversion?
    // ttpStateBuilder = ttpStateBuilder.addToTerminationCapability(tcapStateBuilder.build());
    tunnelTpBuilder = tunnelTpBuilder.config(ttpConfigBuilder.build()).state(ttpStateBuilder.build());
    return tunnelTpBuilder.build();
}
#method_after
private static TunnelTerminationPoint teSubsystem2YangTtp(org.onosproject.tetopology.management.api.node.TunnelTerminationPoint teTunnelTp, Long teTpId, TeTopologyService teTopologyService, TeNodeKey teNodeKey) {
    checkNotNull(teTunnelTp, E_NULL_TE_SUBSYSTEM_TE_TUNNEL_TP);
    TunnelTerminationPoint.TunnelTerminationPointBuilder tunnelTpBuilder = DefaultTunnelTerminationPoint.builder().tunnelTpId(ByteUtils.longToBytes(teTpId.longValue()));
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.Config.ConfigBuilder ttpConfigBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.DefaultConfig.builder();
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.State.StateBuilder ttpStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeaugment.te.tunnelterminationpoint.DefaultState.builder();
    // Assuming teTunnelTp only has one interLayerLock
    if (teTunnelTp.interLayerLockList() != null && !teTunnelTp.interLayerLockList().isEmpty()) {
        ttpConfigBuilder = ttpConfigBuilder.interLayerLockId(teTunnelTp.interLayerLockList().get(0));
        ttpStateBuilder = ttpStateBuilder.interLayerLockId(teTunnelTp.interLayerLockList().get(0));
    }
    TerminationCapability.TerminationCapabilityBuilder tcapConfigBuilder = DefaultTerminationCapability.builder();
    // FIXME: once new yang model is used, we can make llc from teTunnelTp.localLinkConnectivityList()
    if (teTunnelTp.localLinkConnectivityList() != null && !teTunnelTp.localLinkConnectivityList().isEmpty()) {
        for (LocalLinkConnectivity llcn : teTunnelTp.localLinkConnectivityList()) {
            TeLinkId telinkId = (TeLinkId) llcn.constrainingElements().get(0);
            TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(teNodeKey, telinkId.value());
            NetworkLinkKey netLinkKey = teTopologyService.linkKey(globalKey);
            NetworkLink networkLink = teTopologyService.network(netLinkKey.networkId()).links().get(netLinkKey.linkId());
            tcapConfigBuilder = tcapConfigBuilder.linkTp(TpId.fromString(networkLink.source().tpId().toString()));
            // convert teLinkId to networkLinkKey
            ttpConfigBuilder = ttpConfigBuilder.addToTerminationCapability(tcapConfigBuilder.build());
        }
        // TODO: retrieve teTunnelTp.switchingLayer() and set it to  ttpConfigBuilder
        TerminationCapability.TerminationCapabilityBuilder tcapStateBuilder = DefaultTerminationCapability.builder();
        // For which ones we can do the conversion?
        for (LocalLinkConnectivity llcn : teTunnelTp.localLinkConnectivityList()) {
            TeLinkId telinkId = (TeLinkId) llcn.constrainingElements().get(0);
            TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(teNodeKey, telinkId.value());
            NetworkLinkKey netLinkKey = teTopologyService.linkKey(globalKey);
            NetworkLink networkLink = teTopologyService.network(netLinkKey.networkId()).links().get(netLinkKey.linkId());
            tcapStateBuilder = tcapStateBuilder.linkTp(TpId.fromString(networkLink.source().tpId().toString()));
            ttpStateBuilder = ttpStateBuilder.addToTerminationCapability(tcapStateBuilder.build());
        }
    }
    tunnelTpBuilder = tunnelTpBuilder.config(ttpConfigBuilder.build()).state(ttpStateBuilder.build());
    return tunnelTpBuilder.build();
}
#end_block

#method_before
public static Node teSubsystem2YangNode(org.onosproject.tetopology.management.api.node.NetworkNode teSubsystem) {
    checkNotNull(teSubsystem, E_NULL_TE_SUBSYSTEM_NODE);
    NodeId nodeId = NodeId.fromString(teSubsystem.nodeId().toString());
    Node.NodeBuilder builder = DefaultNode.builder().nodeId(nodeId);
    if (teSubsystem.supportingNodeIds() != null) {
        List<SupportingNode> sNodes = Lists.newArrayList();
        SupportingNode.SupportingNodeBuilder spNodeBuilder = DefaultSupportingNode.builder();
        for (NetworkNodeKey nodeKey : teSubsystem.supportingNodeIds()) {
            sNodes.add(spNodeBuilder.networkRef(NetworkId.fromString(nodeKey.networkId().toString())).nodeRef(NodeId.fromString(nodeKey.nodeId().toString())).build());
        }
        builder = builder.supportingNode(sNodes);
    }
    if (teSubsystem.terminationPoints() != null) {
        AugmentedNdNode.AugmentedNdNodeBuilder tpAugmentBuilder = DefaultAugmentedNdNode.builder();
        Map<KeyId, TerminationPoint> teSubsystemTeTp = teSubsystem.terminationPoints();
        for (TerminationPoint teTp : teSubsystemTeTp.values()) {
            tpAugmentBuilder.addToTerminationPoint(TerminationPointConverter.teSubsystem2YangTerminationPoint(teTp));
        }
        builder.addYangAugmentedInfo(tpAugmentBuilder.build(), AugmentedNdNode.class);
    }
    if (teSubsystem.teNode() != null) {
        AugmentedNwNode.AugmentedNwNodeBuilder nodeAugmentBuilder = DefaultAugmentedNwNode.builder();
        TeNode teSubsystemTeNode = teSubsystem.teNode();
        TeBuilder yangTeBuilder = DefaultTe.builder();
        yangTeBuilder = yangTeBuilder.teNodeId(TeNodeId.of(DottedQuad.of(Ip4Address.valueOf((int) teSubsystemTeNode.teNodeId()).toString())));
        // Set configuration data
        // Set state data
        yangTeBuilder = yangTeBuilder.config(teNode2YangConfig(teSubsystemTeNode)).state(teNode2YangState(teSubsystemTeNode));
        if (teSubsystemTeNode.tunnelTerminationPoints() != null) {
            for (Map.Entry<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> entry : teSubsystemTeNode.tunnelTerminationPoints().entrySet()) {
                yangTeBuilder = yangTeBuilder.addToTunnelTerminationPoint(teSubsystem2YangTtp(entry.getValue(), entry.getKey()));
            }
        }
        nodeAugmentBuilder = nodeAugmentBuilder.te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(nodeAugmentBuilder.build(), AugmentedNwNode.class);
    }
    return builder.build();
}
#method_after
public static Node teSubsystem2YangNode(org.onosproject.tetopology.management.api.node.NetworkNode teSubsystem, TeTopologyService teTopologyService, TeTopologyKey teTopologyKey) {
    checkNotNull(teSubsystem, E_NULL_TE_SUBSYSTEM_NODE);
    NodeId nodeId = NodeId.fromString(teSubsystem.nodeId().toString());
    Node.NodeBuilder builder = DefaultNode.builder().nodeId(nodeId);
    if (teSubsystem.supportingNodeIds() != null) {
        List<SupportingNode> sNodes = Lists.newArrayList();
        SupportingNode.SupportingNodeBuilder spNodeBuilder = DefaultSupportingNode.builder();
        for (NetworkNodeKey nodeKey : teSubsystem.supportingNodeIds()) {
            sNodes.add(spNodeBuilder.networkRef(NetworkId.fromString(nodeKey.networkId().toString())).nodeRef(NodeId.fromString(nodeKey.nodeId().toString())).build());
        }
        builder = builder.supportingNode(sNodes);
    }
    if (teSubsystem.terminationPoints() != null) {
        AugmentedNdNode.AugmentedNdNodeBuilder tpAugmentBuilder = DefaultAugmentedNdNode.builder();
        Map<KeyId, TerminationPoint> teSubsystemTeTp = teSubsystem.terminationPoints();
        for (TerminationPoint teTp : teSubsystemTeTp.values()) {
            tpAugmentBuilder.addToTerminationPoint(TerminationPointConverter.teSubsystem2YangTerminationPoint(teTp));
        }
        builder.addYangAugmentedInfo(tpAugmentBuilder.build(), AugmentedNdNode.class);
    }
    if (teSubsystem.teNode() != null) {
        AugmentedNwNode.AugmentedNwNodeBuilder nodeAugmentBuilder = DefaultAugmentedNwNode.builder();
        TeNode teSubsystemTeNode = teSubsystem.teNode();
        TeBuilder yangTeBuilder = DefaultTe.builder();
        yangTeBuilder = yangTeBuilder.teNodeId(TeNodeId.of(DottedQuad.of(Ip4Address.valueOf((int) teSubsystemTeNode.teNodeId()).toString())));
        // Set configuration data
        // Set state data
        yangTeBuilder = yangTeBuilder.config(teNode2YangConfig(teSubsystemTeNode, teTopologyService)).state(teNode2YangState(teSubsystemTeNode, teTopologyService));
        if (teSubsystemTeNode.tunnelTerminationPoints() != null) {
            for (Map.Entry<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> entry : teSubsystemTeNode.tunnelTerminationPoints().entrySet()) {
                yangTeBuilder = yangTeBuilder.addToTunnelTerminationPoint(teSubsystem2YangTtp(entry.getValue(), entry.getKey(), teTopologyService, new TeNodeKey(teTopologyKey, teSubsystemTeNode.teNodeId())));
            }
        }
        nodeAugmentBuilder = nodeAugmentBuilder.te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(nodeAugmentBuilder.build(), AugmentedNwNode.class);
    }
    return builder.build();
}
#end_block

#method_before
private static Map<Long, ConnectivityMatrix> yang2TeSubsystemNodeConnectivityMatrix(String networkId, String nodeId, List<org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeconnectivitymatrix.ConnectivityMatrix> yangMatrix) {
    Map<Long, ConnectivityMatrix> teCmList = Maps.newHashMap();
    for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeconnectivitymatrix.ConnectivityMatrix cmYang : yangMatrix) {
        // is this correct?
        ElementType from = new TeLinkId((long) cmYang.from().tpRef());
        // ignore
        UnderlayAbstractPath underlayPath = null;
        // empty merging list for now
        List<ElementType> mergingList = Lists.newArrayList();
        List<ElementType> constrainingElements = Lists.newArrayList();
        // is this correct?
        ElementType to = new TeLinkId((long) cmYang.to().tpRef());
        constrainingElements.add(to);
        // what are the flags in cmYang?
        BitSet flags = new BitSet();
        List<Long> srlgs = Lists.newArrayList();
        if (cmYang.teSrlgs() != null) {
            for (Srlg srlg : cmYang.teSrlgs().value()) {
                srlgs.add(srlg.uint32());
            }
        }
        TePathAttributes teAttributes = new TePathAttributes(cmYang.teDefaultMetric(), cmYang.performanceMetric().measurement().unidirectionalDelay(), srlgs);
        ConnectivityMatrix coreCm = new ConnectivityMatrix(cmYang.id(), from, mergingList, constrainingElements, flags, teAttributes, underlayPath);
        teCmList.put(cmYang.id(), coreCm);
    }
    return teCmList;
}
#method_after
private static Map<Long, ConnectivityMatrix> yang2TeSubsystemNodeConnectivityMatrix(String networkId, String nodeId, List<org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeconnectivitymatrix.ConnectivityMatrix> yangMatrix) {
    Map<Long, ConnectivityMatrix> teCmList = Maps.newHashMap();
    for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.tenodeconnectivitymatrix.ConnectivityMatrix cmYang : yangMatrix) {
        // is this correct?
        ElementType from = new TeLinkId(Long.valueOf(((String) cmYang.from().tpRef())));
        // ignore
        UnderlayAbstractPath underlayPath = null;
        // empty merging list for now
        List<ElementType> mergingList = Lists.newArrayList();
        List<ElementType> constrainingElements = Lists.newArrayList();
        // is this correct?
        ElementType to = new TeLinkId(Long.valueOf(((String) cmYang.to().tpRef())));
        constrainingElements.add(to);
        // what are the flags in cmYang?
        BitSet flags = new BitSet();
        List<Long> srlgs = Lists.newArrayList();
        if (cmYang.teSrlgs() != null) {
            for (Srlg srlg : cmYang.teSrlgs().value()) {
                srlgs.add(srlg.uint32());
            }
        }
        TePathAttributes teAttributes = new TePathAttributes(cmYang.teDefaultMetric(), cmYang.performanceMetric() == null ? null : (cmYang.performanceMetric().measurement() == null ? null : cmYang.performanceMetric().measurement().unidirectionalDelay()), srlgs);
        ConnectivityMatrix coreCm = new ConnectivityMatrix(cmYang.id(), from, mergingList, constrainingElements, flags, teAttributes, underlayPath);
        teCmList.put(cmYang.id(), coreCm);
    }
    return teCmList;
}
#end_block

#method_before
private static Map<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> yang2TeSubsystemTtp(List<TunnelTerminationPoint> ttps) {
    Map<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> ttpsMap = Maps.newHashMap();
    for (TunnelTerminationPoint ttpYang : ttps) {
        // how to find switching type?
        SwitchingType switchingLayer = null;
        // TODO: find proper encoding type from ttpYang.config().encoding();
        EncodingType encodingLayer = null;
        // how to set flags?
        BitSet flags = new BitSet();
        List<Long> interLayerLockList = Lists.newArrayList();
        if (ttpYang.config() != null) {
            // interLayerLock in yang is not a list
            interLayerLockList.add(ttpYang.config().interLayerLockId());
        }
        List<LocalLinkConnectivity> localLinkConnectivityList = Lists.newArrayList();
        // FIXME: once new yang model is used, we can make llc
        // LocalLinkConnectivity llc = new LocalLinkConnectivity(constrainingElements,
        // flags,
        // teAttributes,
        // underlayPath)
        // how to find availableBandwidth?
        float[] availAdaptBandwidth = null;
        org.onosproject.tetopology.management.api.node.TunnelTerminationPoint ttpTe = new org.onosproject.tetopology.management.api.node.DefaultTunnelTerminationPoint(ByteUtils.bytesToLong(ttpYang.tunnelTpId()), switchingLayer, encodingLayer, flags, interLayerLockList, localLinkConnectivityList, availAdaptBandwidth);
        ttpsMap.put(ByteUtils.bytesToLong(ttpYang.tunnelTpId()), ttpTe);
    }
    return ttpsMap;
}
#method_after
private static Map<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> yang2TeSubsystemTtp(List<TunnelTerminationPoint> ttps, Node yangNode) {
    Map<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> ttpsMap = Maps.newHashMap();
    for (TunnelTerminationPoint ttpYang : ttps) {
        // how to find switching type?
        SwitchingType switchingLayer = null;
        // TODO: find proper encoding type from ttpYang.config().encoding();
        EncodingType encodingLayer = null;
        // how to set flags?
        BitSet flags = new BitSet();
        List<Long> interLayerLockList = Lists.newArrayList();
        if (ttpYang.config() != null) {
            // interLayerLock in yang is not a list
            interLayerLockList.add(ttpYang.config().interLayerLockId());
        }
        List<LocalLinkConnectivity> localLinkConnectivityList = Lists.newArrayList();
        // FIXME: once new yang model is used, we can make llc
        ElementType elt = null;
        List<ElementType> eltList = Lists.newArrayList();
        if (ttpYang.config() != null && ttpYang.config().terminationCapability() != null && !ttpYang.config().terminationCapability().isEmpty()) {
            for (TerminationCapability tercap : ttpYang.config().terminationCapability()) {
                if (yangNode.yangAugmentedInfoMap() != null && !yangNode.yangAugmentedInfoMap().isEmpty()) {
                    AugmentedNdNode yangTpNodeAugment = (AugmentedNdNode) yangNode.yangAugmentedInfo(AugmentedNdNode.class);
                    for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.topology.rev20151208.ietfnetworktopology.networks.network.node.augmentedndnode.TerminationPoint tpItem : yangTpNodeAugment.terminationPoint()) {
                        if (tpItem.tpId().uri().string().equals(tercap.linkTp().toString())) {
                            if (tpItem.yangAugmentedInfoMap() != null && !tpItem.yangAugmentedInfoMap().isEmpty()) {
                                AugmentedNtTerminationPoint yangTpAugment = (AugmentedNtTerminationPoint) tpItem.yangAugmentedInfo(AugmentedNtTerminationPoint.class);
                                if (yangTpAugment.te() != null && yangTpAugment.te().teTpId() != null) {
                                    elt = new TeLinkId(Long.valueOf(yangTpAugment.te().teTpId().toString()));
                                    break;
                                }
                            }
                        }
                    }
                }
                eltList.add(elt);
            // tercap.linkTp().toString() //tpId -> tp -> te-tp-id (long)
            }
        }
        // how to find these
        TePathAttributes teAttributes = null;
        // attributes from ttpYang?
        // how to find underlayAbstractPath from ttpYang?
        UnderlayAbstractPath underlayPath = null;
        LocalLinkConnectivity llc = new LocalLinkConnectivity(eltList, flags, teAttributes, underlayPath);
        localLinkConnectivityList.add(llc);
        // how to find availableBandwidth?
        float[] availAdaptBandwidth = null;
        org.onosproject.tetopology.management.api.node.TunnelTerminationPoint ttpTe = new org.onosproject.tetopology.management.api.node.DefaultTunnelTerminationPoint(ByteUtils.bytesToLong(ttpYang.tunnelTpId()), switchingLayer, encodingLayer, flags, interLayerLockList, localLinkConnectivityList, availAdaptBandwidth);
        ttpsMap.put(ByteUtils.bytesToLong(ttpYang.tunnelTpId()), ttpTe);
    }
    return ttpsMap;
}
#end_block

#method_before
private static TeNode yang2TeSubsystemNodeAugment(Te yangNodeAugTe, Network yangNetwork, Node yangNode, Map<KeyId, TerminationPoint> teTps) {
    NodeId yangNodeId = yangNode.nodeId();
    List<SupportingNode> yangSupportNodes = yangNode.supportingNode();
    NetworkId yangNetworkId = yangNetwork.networkId();
    long teNodeId = Ip4Address.valueOf(yangNodeAugTe.teNodeId().dottedQuad().string()).toInt();
    TeTopologyKey underlayTopologyIdId = null;
    // FIXME: yang has a list of supporting nodes, but TeNode only has one
    // supportTeNodeId. How ro retrieve providerId, clientId, topologyId, teNodeId?
    TeNodeKey supportTeNodeId = null;
    // supportTeNodeId = new TeNodeKey(providerId, clientId, topologyId, teNodeId)
    // yangSupportNodes.get(0).
    // ignore
    TeNodeKey sourceTeNodeId = null;
    CommonNodeData teData = null;
    Map<Long, ConnectivityMatrix> connMatrices = null;
    Map<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> ttps = null;
    List<Long> teLinkIds = Lists.newArrayList();
    List<Long> teTpIds = Lists.newArrayList();
    // ********************************************** to find teLinkIds
    if (MapUtils.isNotEmpty(teTps)) {
        for (Map.Entry<KeyId, TerminationPoint> entry : teTps.entrySet()) {
            if (entry.getValue().teTpId() != null) {
                teTpIds.add(entry.getValue().teTpId());
            }
        }
    }
    // ********************************************** to find teTpIds
    if (yangNode.yangAugmentedInfoMap() != null && !yangNode.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNdNode yangTpNodeAugment = (AugmentedNdNode) yangNode.yangAugmentedInfo(AugmentedNdNode.class);
        if (yangTpNodeAugment.terminationPoint() != null) {
            for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.topology.rev20151208.ietfnetworktopology.networks.network.node.augmentedndnode.TerminationPoint yangTpnode : yangTpNodeAugment.terminationPoint()) {
                teTpIds.add(Long.valueOf(yangTpnode.tpId().uri().string()));
            }
        }
    }
    // **********************************************
    Config ynodeAugCfg = yangNodeAugTe.config();
    if (ynodeAugCfg != null) {
        TeNodeAttributes teNodeAttr = ynodeAugCfg.teNodeAttributes();
        if (teNodeAttr != null) {
            if (teNodeAttr.underlayTopology() != null) {
                underlayTopologyIdId = yang2TeSubsystemNodeUnderlayTopology(teNodeAttr.underlayTopology());
            }
            BitSet flags = new BitSet();
            if (teNodeAttr.isAbstract()) {
                flags.set(TeNode.BIT_ABSTRACT);
            }
            teData = new CommonNodeData(// teNodeAttr.name().string(),
            null, EnumConverter.yang2TeSubsystemAdminStatus(teNodeAttr.adminStatus()), EnumConverter.yang2TeSubsystemOpStatus(yangNodeAugTe.state().operStatus()), flags);
            if (teNodeAttr.connectivityMatrix() != null) {
                connMatrices = yang2TeSubsystemNodeConnectivityMatrix(yangNetworkId.uri().toString(), yangNodeId.uri().toString(), teNodeAttr.connectivityMatrix());
            }
        }
    }
    if (yangNodeAugTe.tunnelTerminationPoint() != null) {
        ttps = yang2TeSubsystemTtp(yangNodeAugTe.tunnelTerminationPoint());
    }
    TeNode teNode = new DefaultTeNode(teNodeId, underlayTopologyIdId, supportTeNodeId, sourceTeNodeId, teData, connMatrices, teLinkIds, ttps, teTpIds);
    return teNode;
}
#method_after
private static TeNode yang2TeSubsystemNodeAugment(Te yangNodeAugTe, Network yangNetwork, Node yangNode, Map<KeyId, TerminationPoint> teTps) {
    NodeId yangNodeId = yangNode.nodeId();
    List<SupportingNode> yangSupportNodes = yangNode.supportingNode();
    NetworkId yangNetworkId = yangNetwork.networkId();
    long teNodeId = Ip4Address.valueOf(yangNodeAugTe.teNodeId().dottedQuad().string()).toInt();
    TeTopologyKey underlayTopologyIdId = null;
    // FIXME: yang has a list of supporting nodes, but TeNode only has one
    // supportTeNodeId. How ro retrieve providerId, clientId, topologyId, teNodeId?
    TeNodeKey supportTeNodeId = null;
    // supportTeNodeId = new TeNodeKey(providerId, clientId, topologyId, teNodeId)
    // yangSupportNodes.get(0).
    // ignore
    TeNodeKey sourceTeNodeId = null;
    CommonNodeData teData = null;
    Map<Long, ConnectivityMatrix> connMatrices = null;
    Map<Long, org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> ttps = null;
    List<Long> teLinkIds = Lists.newArrayList();
    List<Long> teTpIds = Lists.newArrayList();
    // ********************************************** to find teLinkIds
    if (MapUtils.isNotEmpty(teTps)) {
        for (Map.Entry<KeyId, TerminationPoint> entry : teTps.entrySet()) {
            if (entry.getValue().teTpId() != null) {
                teTpIds.add(entry.getValue().teTpId());
            }
        }
    }
    // ********************************************** to find teTpIds
    if (yangNode.yangAugmentedInfoMap() != null && !yangNode.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNdNode yangTpNodeAugment = (AugmentedNdNode) yangNode.yangAugmentedInfo(AugmentedNdNode.class);
        if (yangTpNodeAugment.terminationPoint() != null) {
            for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.topology.rev20151208.ietfnetworktopology.networks.network.node.augmentedndnode.TerminationPoint yangTpnode : yangTpNodeAugment.terminationPoint()) {
                teTpIds.add(Long.valueOf(yangTpnode.tpId().uri().string()));
            }
        }
    }
    // **********************************************
    Config ynodeAugCfg = yangNodeAugTe.config();
    if (ynodeAugCfg != null) {
        TeNodeAttributes teNodeAttr = ynodeAugCfg.teNodeAttributes();
        if (teNodeAttr != null) {
            if (teNodeAttr.underlayTopology() != null) {
                underlayTopologyIdId = yang2TeSubsystemNodeUnderlayTopology(teNodeAttr.underlayTopology());
            }
            BitSet flags = new BitSet();
            if (teNodeAttr.isAbstract()) {
                flags.set(TeNode.BIT_ABSTRACT);
            }
            teData = new CommonNodeData(// teNodeAttr.name().string(),
            null, EnumConverter.yang2TeSubsystemAdminStatus(teNodeAttr.adminStatus()), EnumConverter.yang2TeSubsystemOpStatus(yangNodeAugTe.state().operStatus()), flags);
            if (teNodeAttr.connectivityMatrix() != null) {
                connMatrices = yang2TeSubsystemNodeConnectivityMatrix(yangNetworkId.uri().toString(), yangNodeId.uri().toString(), teNodeAttr.connectivityMatrix());
            }
        }
    }
    if (yangNodeAugTe.tunnelTerminationPoint() != null) {
        ttps = yang2TeSubsystemTtp(yangNodeAugTe.tunnelTerminationPoint(), yangNode);
    }
    TeNode teNode = new DefaultTeNode(teNodeId, underlayTopologyIdId, supportTeNodeId, sourceTeNodeId, teData, connMatrices, teLinkIds, ttps, teTpIds);
    return teNode;
}
#end_block

#method_before
public static NetworkNodeKey yangNodeEvent2NetworkNodeKey(TeNodeEvent yangNodeEvent) {
    // TODO: implementation to be submitted as separate review
    NetworkId networkRef = (NetworkId) (yangNodeEvent.networkRef());
    NodeId nodeRef = (NodeId) (yangNodeEvent.nodeRef());
    KeyId networkId = KeyId.keyId(networkRef.uri().toString());
    KeyId nodeId = KeyId.keyId(nodeRef.uri().toString());
    NetworkNodeKey networkNodeKey = new NetworkNodeKey(networkId, nodeId);
    return networkNodeKey;
}
#method_after
public static NetworkNodeKey yangNodeEvent2NetworkNodeKey(TeNodeEvent yangNodeEvent) {
    NetworkId networkRef = NetworkId.fromString(yangNodeEvent.networkRef().toString());
    NodeId nodeRef = NodeId.fromString(yangNodeEvent.nodeRef().toString());
    KeyId networkId = KeyId.keyId(networkRef.uri().toString());
    KeyId nodeId = KeyId.keyId(nodeRef.uri().toString());
    NetworkNodeKey networkNodeKey = new NetworkNodeKey(networkId, nodeId);
    return networkNodeKey;
}
#end_block

#method_before
public static NetworkNode yangNodeEvent2NetworkNode(TeNodeEvent yangNodeEvent, TeTopologyService teTopologyService) {
    // TODO: implementation to be submitted as separate review
    KeyId networkNodeId = yangNodeEvent2NetworkNodeKey(yangNodeEvent).nodeId();
    org.onosproject.tetopology.management.api.Network network = teTopologyService.network(yangNodeEvent2NetworkNodeKey(yangNodeEvent).networkId());
    if (network == null) {
        return null;
    }
    NetworkNode networkNode = network.node(networkNodeId);
    if (networkNode == null) {
        return null;
    }
    List<NetworkNodeKey> supportingNodeIds = networkNode.supportingNodeIds();
    Map<KeyId, TerminationPoint> tps = networkNode.terminationPoints();
    TeNode teNode = networkNode.teNode();
    if (teNode == null) {
        return null;
    }
    TeNode updatedTeNode = yangNodeEvent2TeNode(yangNodeEvent, teNode);
    NetworkNode updatedNetworkNode = new DefaultNetworkNode(networkNodeId, supportingNodeIds, updatedTeNode, tps);
    return updatedNetworkNode;
}
#method_after
public static NetworkNode yangNodeEvent2NetworkNode(TeNodeEvent yangNodeEvent, TeTopologyService teTopologyService) {
    KeyId networkNodeId = yangNodeEvent2NetworkNodeKey(yangNodeEvent).nodeId();
    org.onosproject.tetopology.management.api.Network network = teTopologyService.network(yangNodeEvent2NetworkNodeKey(yangNodeEvent).networkId());
    if (network == null) {
        return null;
    }
    NetworkNode networkNode = network.node(networkNodeId);
    if (networkNode == null) {
        return null;
    }
    List<NetworkNodeKey> supportingNodeIds = networkNode.supportingNodeIds();
    Map<KeyId, TerminationPoint> tps = networkNode.terminationPoints();
    TeNode teNode = networkNode.teNode();
    if (teNode == null) {
        return null;
    }
    TeNode updatedTeNode = yangNodeEvent2TeNode(yangNodeEvent, teNode);
    NetworkNode updatedNetworkNode = new DefaultNetworkNode(networkNodeId, supportingNodeIds, updatedTeNode, tps);
    return updatedNetworkNode;
}
#end_block

#method_before
public static Networks teSubsystem2YangNetworks(org.onosproject.tetopology.management.api.Networks teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, E_NULL_TE_NETWORKS);
    checkNotNull(teSubsystem.networks(), E_NULL_TE_NETWORK_LIST);
    Networks.NetworksBuilder builder = DefaultNetworks.builder().yangNetworksOpType(toNetworksOperationType(operation));
    List<Network> networks = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.Network teNetwork : teSubsystem.networks()) {
        networks.add(teSubsystem2YangNetwork(teNetwork, operation));
    }
    builder.network(networks);
    return builder.build();
}
#method_after
public static Networks teSubsystem2YangNetworks(org.onosproject.tetopology.management.api.Networks teSubsystem, OperationType operation, TeTopologyService teTopologyService) {
    checkNotNull(teSubsystem, E_NULL_TE_NETWORKS);
    checkNotNull(teSubsystem.networks(), E_NULL_TE_NETWORK_LIST);
    Networks.NetworksBuilder builder = DefaultNetworks.builder().yangNetworksOpType(toNetworksOperationType(operation));
    List<Network> networks = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.Network teNetwork : teSubsystem.networks()) {
        networks.add(teSubsystem2YangNetwork(teNetwork, operation, teTopologyService));
    }
    builder.network(networks);
    return builder.build();
}
#end_block

#method_before
private static NetworkBuilder te2YangNodes(NetworkBuilder builder, Map<KeyId, NetworkNode> teNodes) {
    List<Node> nodeList = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.node.NetworkNode node : teNodes.values()) {
        nodeList.add(NodeConverter.teSubsystem2YangNode(node));
    }
    return builder.node(nodeList);
}
#method_after
private static NetworkBuilder te2YangNodes(NetworkBuilder builder, Map<KeyId, NetworkNode> teNodes, TeTopologyService teTopologyService, TeTopologyKey teTopologyKey) {
    List<Node> nodeList = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.node.NetworkNode node : teNodes.values()) {
        nodeList.add(NodeConverter.teSubsystem2YangNode(node, teTopologyService, teTopologyKey));
    }
    return builder.node(nodeList);
}
#end_block

#method_before
public static Network teSubsystem2YangNetwork(org.onosproject.tetopology.management.api.Network teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, E_NULL_TE_NETWORK);
    checkNotNull(teSubsystem.networkId(), E_NULL_TE_NETWORKID);
    // Generate a network builder with the specific networkId.
    NetworkId networkId = NetworkId.fromString(teSubsystem.networkId().toString());
    NetworkBuilder builder = DefaultNetwork.builder().yangNetworkOpType(toNetworksOperationType(operation)).networkId(networkId);
    // Supporting networks
    if (teSubsystem.supportingNetworkIds() != null) {
        builder = te2YangSupportingNetwork(builder, teSubsystem.supportingNetworkIds());
    }
    // Nodes
    if (teSubsystem.nodes() != null) {
        builder = te2YangNodes(builder, teSubsystem.nodes());
    }
    // Network types
    builder = te2YangNetworkType(builder, teSubsystem.teTopologyId());
    // Add links - link is the augmentation
    if (teSubsystem.links() != null) {
        builder = te2YangLinks(builder, teSubsystem.links());
    }
    // TE Topology IDs
    if (teSubsystem.teTopologyId() != null) {
        builder = te2YangTopologyIds(builder, teSubsystem.teTopologyId());
    }
    return builder.build();
}
#method_after
public static Network teSubsystem2YangNetwork(org.onosproject.tetopology.management.api.Network teSubsystem, OperationType operation, TeTopologyService teTopologyService) {
    checkNotNull(teSubsystem, E_NULL_TE_NETWORK);
    checkNotNull(teSubsystem.networkId(), E_NULL_TE_NETWORKID);
    // Generate a network builder with the specific networkId.
    NetworkId networkId = NetworkId.fromString(teSubsystem.networkId().toString());
    NetworkBuilder builder = DefaultNetwork.builder().yangNetworkOpType(toNetworksOperationType(operation)).networkId(networkId);
    // Supporting networks
    if (teSubsystem.supportingNetworkIds() != null) {
        builder = te2YangSupportingNetwork(builder, teSubsystem.supportingNetworkIds());
    }
    // Nodes
    if (teSubsystem.nodes() != null) {
        org.onosproject.tetopology.management.api.Network nt = teTopologyService.network(teSubsystem.networkId());
        TeTopologyKey teTopoKey = new TeTopologyKey(nt.teTopologyId().providerId(), nt.teTopologyId().clientId(), Long.valueOf(nt.teTopologyId().topologyId()));
        builder = te2YangNodes(builder, teSubsystem.nodes(), teTopologyService, teTopoKey);
    }
    // Network types
    builder = te2YangNetworkType(builder, teSubsystem.teTopologyId());
    // Add links - link is the augmentation
    if (teSubsystem.links() != null) {
        builder = te2YangLinks(builder, teSubsystem.links());
    }
    // TE Topology IDs
    if (teSubsystem.teTopologyId() != null) {
        builder = te2YangTopologyIds(builder, teSubsystem.teTopologyId());
    }
    return builder.build();
}
#end_block

#method_before
private static org.onosproject.tetopology.management.api.DefaultNetwork yang2TeDefaultNetwork(Network yangNetwork, org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network yangNetworkState, Networks yangNetworks) {
    checkNotNull(yangNetwork, E_NULL_YANG_NETWORK);
    checkNotNull(yangNetwork.networkId(), E_NULL_YANG_NETWORKID);
    String networkId = yangNetwork.networkId().uri().string();
    KeyId networkKeyId = KeyId.keyId(networkId);
    List<KeyId> supportingNetworkIds = null;
    Map<KeyId, NetworkNode> teNodes = null;
    Map<KeyId, NetworkLink> teLinks = null;
    org.onosproject.tetopology.management.api.TeTopologyId teTopologyId = null;
    boolean serverProvided = false;
    DeviceId ownerId = null;
    // Supporting networks
    if (yangNetwork.supportingNetwork() != null) {
        supportingNetworkIds = Lists.newArrayList();
        for (SupportingNetwork supportNw : yangNetwork.supportingNetwork()) {
            supportingNetworkIds.add(KeyId.keyId(supportNw.networkRef().uri().string()));
        }
    }
    // Nodes
    if (yangNetwork.node() != null) {
        teNodes = Maps.newHashMap();
        for (Node node : yangNetwork.node()) {
            // Convert the Yang Node to a TE node.
            teNodes.put(KeyId.keyId(node.nodeId().uri().string()), NodeConverter.yang2TeSubsystemNode(node, yangNetwork));
        }
    }
    // Links
    if (yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class) != null) {
        AugmentedNdNetwork augmentLink = (AugmentedNdNetwork) yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class);
        teLinks = Maps.newHashMap();
        for (Link link : augmentLink.link()) {
            // Convert the Yang Link to a TE link.
            teLinks.put(KeyId.keyId(link.linkId().uri().string()), LinkConverter.yang2TeSubsystemLink(link, yangNetwork, yangNetworks));
        }
    }
    // TE Topology Ids
    if (yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class) != null) {
        AugmentedNwNetwork augmentTeIds = (AugmentedNwNetwork) yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class);
        teTopologyId = new org.onosproject.tetopology.management.api.TeTopologyId(augmentTeIds.te().clientId().uint32(), augmentTeIds.te().providerId().uint32(), augmentTeIds.te().teTopologyId().string());
    }
    if (yangNetworkState != null) {
        serverProvided = yangNetworkState.serverProvided();
    }
    org.onosproject.tetopology.management.api.DefaultNetwork network = new org.onosproject.tetopology.management.api.DefaultNetwork(networkKeyId, supportingNetworkIds, teNodes, teLinks, teTopologyId, serverProvided, ownerId);
    return network;
}
#method_after
private static org.onosproject.tetopology.management.api.DefaultNetwork yang2TeDefaultNetwork(Network yangNetwork, org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network yangNetworkState, Networks yangNetworks) {
    checkNotNull(yangNetwork, E_NULL_YANG_NETWORK);
    checkNotNull(yangNetwork.networkId(), E_NULL_YANG_NETWORKID);
    String networkId = yangNetwork.networkId().uri().string();
    KeyId networkKeyId = KeyId.keyId(networkId);
    List<KeyId> supportingNetworkIds = null;
    Map<KeyId, NetworkNode> teNodes = null;
    Map<KeyId, NetworkLink> teLinks = null;
    org.onosproject.tetopology.management.api.TeTopologyId teTopologyId = null;
    boolean serverProvided = false;
    DeviceId ownerId = null;
    // Supporting networks
    if (yangNetwork.supportingNetwork() != null) {
        supportingNetworkIds = Lists.newArrayList();
        for (SupportingNetwork supportNw : yangNetwork.supportingNetwork()) {
            supportingNetworkIds.add(KeyId.keyId(supportNw.networkRef().uri().string()));
        }
    }
    // Nodes
    if (yangNetwork.node() != null) {
        teNodes = Maps.newHashMap();
        for (Node node : yangNetwork.node()) {
            // Convert the Yang Node to a TE node.
            teNodes.put(KeyId.keyId(node.nodeId().uri().string()), NodeConverter.yang2TeSubsystemNode(node, yangNetwork));
        }
    }
    // Links
    if (yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class) != null) {
        AugmentedNdNetwork augmentLink = (AugmentedNdNetwork) yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class);
        teLinks = Maps.newHashMap();
        for (Link link : augmentLink.link()) {
            // Convert the Yang Link to a TE link.
            teLinks.put(KeyId.keyId(link.linkId().uri().string()), LinkConverter.yang2TeSubsystemLink(link, yangNetwork, yangNetworks));
        }
    }
    // TE Topology Ids
    if (yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class) != null) {
        AugmentedNwNetwork augmentTeIds = (AugmentedNwNetwork) yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class);
        teTopologyId = new org.onosproject.tetopology.management.api.TeTopologyId(augmentTeIds.te().providerId().uint32(), augmentTeIds.te().clientId().uint32(), augmentTeIds.te().teTopologyId().string());
    }
    if (yangNetworkState != null) {
        serverProvided = yangNetworkState.serverProvided();
    }
    org.onosproject.tetopology.management.api.DefaultNetwork network = new org.onosproject.tetopology.management.api.DefaultNetwork(networkKeyId, supportingNetworkIds, teNodes, teLinks, teTopologyId, serverProvided, ownerId);
    return network;
}
#end_block

#method_before
@Override
public KeyId networkId(TeTopologyKey teTopologyKey) {
    return teTopologyMap.get(teTopologyKey).topologyData().networkId();
}
#method_after
@Override
public KeyId networkId(TeTopologyKey teTopologyKey) {
    return teTopologyMap.get(teTopologyKey) == null || teTopologyMap.get(teTopologyKey).topologyData() == null ? null : teTopologyMap.get(teTopologyKey).topologyData().networkId();
}
#end_block

#method_before
@Override
public NetworkNodeKey nodeKey(TeNodeKey teNodeKey) {
    return teNodeMap.get(teNodeKey).networkNodeKey();
}
#method_after
@Override
public NetworkNodeKey nodeKey(TeNodeKey teNodeKey) {
    return teNodeMap.get(teNodeKey) == null ? null : teNodeMap.get(teNodeKey).networkNodeKey();
}
#end_block

#method_before
@Override
public NetworkLinkKey linkKey(TeLinkTpGlobalKey teLinkKey) {
    return teLinkMap.get(teLinkKey).networkLinkKey();
}
#method_after
@Override
public NetworkLinkKey linkKey(TeLinkTpGlobalKey teLinkKey) {
    return teLinkMap.get(teLinkKey) == null ? null : teLinkMap.get(teLinkKey).networkLinkKey();
}
#end_block

#method_before
private boolean isCustomizedLearnedTopology(TeTopologyKey key) {
    if (store.teTopology(key).flags().get(TeTopology.BIT_CUSTOMIZED) && store.teTopology(key).flags().get(TeTopology.BIT_LEARNT)) {
        return true;
    }
    return false;
}
#method_after
private boolean isCustomizedLearnedTopology(TeTopologyKey key) {
    if (store.teTopology(key).flags().get(BIT_CUSTOMIZED) && store.teTopology(key).flags().get(BIT_LEARNT)) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void run() {
    try {
        TeTopologyMapEvent event;
        while ((event = mapEventQueue.take()) != null) {
            switch(event.type()) {
                case TE_TOPOLOGY_ADDED:
                case TE_TOPOLOGY_UPDATED:
                    TeTopology teTopology = store.teTopology(event.teTopologyKey());
                    post(new TeTopologyEvent(event.type(), teTopology));
                    if (mdsc && event.type() == TE_TOPOLOGY_ADDED && teTopology.flags().get(TeTopology.BIT_CUSTOMIZED) && teTopology.flags().get(TeTopology.BIT_LEARNT)) {
                        mergeTopology(teTopology);
                    }
                    break;
                case TE_TOPOLOGY_REMOVED:
                    post(new TeTopologyEvent(TE_TOPOLOGY_REMOVED, new DefaultTeTopology(event.teTopologyKey(), null, null, null, null)));
                    break;
                case TE_NODE_ADDED:
                case TE_NODE_UPDATED:
                    TeNode teNode = store.teNode(event.teNodeKey());
                    post(new TeTopologyEvent(event.type(), new TeNodeEventSubject(event.teNodeKey(), teNode)));
                    if (mdsc && isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        updateSourceTeNode(mergedTopology.teNodes(), event.teNodeKey().teTopologyKey(), teNode, true);
                    }
                    break;
                case TE_NODE_REMOVED:
                    post(new TeTopologyEvent(TE_NODE_REMOVED, new TeNodeEventSubject(event.teNodeKey(), null)));
                    if (mdsc && isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        removeSourceTeNode(mergedTopology.teNodes(), event.teNodeKey(), true);
                    }
                    break;
                case TE_LINK_ADDED:
                case TE_LINK_UPDATED:
                    TeLink teLink = store.teLink(event.teLinkKey());
                    post(new TeTopologyEvent(event.type(), new TeLinkEventSubject(event.teLinkKey(), teLink)));
                    if (mdsc && isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        Map<TeLinkTpKey, TeLink> teLinks = Maps.newHashMap(mergedTopology.teLinks());
                        updateSourceTeLink(teLinks, event.teLinkKey().teTopologyKey(), teLink, true);
                        updateMergedTopology(mergedTopology.teNodes(), teLinks);
                    }
                    break;
                case TE_LINK_REMOVED:
                    post(new TeTopologyEvent(TE_LINK_REMOVED, new TeLinkEventSubject(event.teLinkKey(), null)));
                    if (mdsc && isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        Map<TeLinkTpKey, TeLink> teLinks = Maps.newHashMap(mergedTopology.teLinks());
                        removeSourceTeLink(teLinks, event.teLinkKey(), true);
                        updateMergedTopology(mergedTopology.teNodes(), teLinks);
                    }
                    break;
                case NETWORK_ADDED:
                case NETWORK_UPDATED:
                    Network network = store.network(event.networkKey());
                    post(new TeTopologyEvent(event.type(), network));
                    break;
                case NETWORK_REMOVED:
                    post(new TeTopologyEvent(NETWORK_REMOVED, new DefaultNetwork(event.networkKey(), null, null, null, null, false, null)));
                    break;
                case NODE_ADDED:
                case NODE_UPDATED:
                    NetworkNode node = store.networkNode(event.networkNodeKey());
                    post(new TeTopologyEvent(event.type(), new NetworkNodeEventSubject(event.networkNodeKey(), node)));
                    break;
                case NODE_REMOVED:
                    post(new TeTopologyEvent(NODE_REMOVED, new NetworkNodeEventSubject(event.networkNodeKey(), null)));
                    break;
                case LINK_ADDED:
                case LINK_UPDATED:
                    NetworkLink link = store.networkLink(event.networkLinkKey());
                    post(new TeTopologyEvent(event.type(), new NetworkLinkEventSubject(event.networkLinkKey(), link)));
                    break;
                case LINK_REMOVED:
                    post(new TeTopologyEvent(LINK_REMOVED, new NetworkLinkEventSubject(event.networkLinkKey(), null)));
                    break;
                default:
                    break;
            }
        }
    } catch (InterruptedException e) {
        log.warn("TopologyMergerTask is interrupted");
    } catch (Exception e) {
        log.warn("Unable to merge topology", e);
    }
}
#method_after
@Override
public void run() {
    try {
        TeTopologyMapEvent event;
        while ((event = mapEventQueue.take()) != null) {
            switch(event.type()) {
                case TE_TOPOLOGY_ADDED:
                case TE_TOPOLOGY_UPDATED:
                    TeTopology teTopology = store.teTopology(event.teTopologyKey());
                    post(new TeTopologyEvent(event.type(), teTopology));
                    if (mdsc && event.type() == TE_TOPOLOGY_ADDED && teTopology.flags().get(BIT_CUSTOMIZED) && teTopology.flags().get(BIT_LEARNT)) {
                        log.debug("TeTopology to be merged: {}", teTopology);
                        mergeTopology(teTopology);
                    }
                    break;
                case TE_TOPOLOGY_REMOVED:
                    post(new TeTopologyEvent(TE_TOPOLOGY_REMOVED, new DefaultTeTopology(event.teTopologyKey(), null, null, null, null)));
                    break;
                case TE_NODE_ADDED:
                case TE_NODE_UPDATED:
                    TeNode teNode = store.teNode(event.teNodeKey());
                    post(new TeTopologyEvent(event.type(), new TeNodeEventSubject(event.teNodeKey(), teNode)));
                    if (mdsc && isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        updateSourceTeNode(mergedTopology.teNodes(), event.teNodeKey().teTopologyKey(), teNode, true);
                    }
                    break;
                case TE_NODE_REMOVED:
                    post(new TeTopologyEvent(TE_NODE_REMOVED, new TeNodeEventSubject(event.teNodeKey(), null)));
                    if (mdsc && isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        removeSourceTeNode(mergedTopology.teNodes(), event.teNodeKey(), true);
                    }
                    break;
                case TE_LINK_ADDED:
                case TE_LINK_UPDATED:
                    TeLink teLink = store.teLink(event.teLinkKey());
                    post(new TeTopologyEvent(event.type(), new TeLinkEventSubject(event.teLinkKey(), teLink)));
                    if (mdsc && isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        Map<TeLinkTpKey, TeLink> teLinks = Maps.newHashMap(mergedTopology.teLinks());
                        updateSourceTeLink(teLinks, event.teLinkKey().teTopologyKey(), teLink, true);
                        updateMergedTopology(mergedTopology.teNodes(), teLinks);
                    }
                    break;
                case TE_LINK_REMOVED:
                    post(new TeTopologyEvent(TE_LINK_REMOVED, new TeLinkEventSubject(event.teLinkKey(), null)));
                    if (mdsc && isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        Map<TeLinkTpKey, TeLink> teLinks = Maps.newHashMap(mergedTopology.teLinks());
                        removeSourceTeLink(teLinks, event.teLinkKey(), true);
                        updateMergedTopology(mergedTopology.teNodes(), teLinks);
                    }
                    break;
                case NETWORK_ADDED:
                case NETWORK_UPDATED:
                    Network network = store.network(event.networkKey());
                    post(new TeTopologyEvent(event.type(), network));
                    break;
                case NETWORK_REMOVED:
                    post(new TeTopologyEvent(NETWORK_REMOVED, new DefaultNetwork(event.networkKey(), null, null, null, null, false, null)));
                    break;
                case NODE_ADDED:
                case NODE_UPDATED:
                    NetworkNode node = store.networkNode(event.networkNodeKey());
                    post(new TeTopologyEvent(event.type(), new NetworkNodeEventSubject(event.networkNodeKey(), node)));
                    break;
                case NODE_REMOVED:
                    post(new TeTopologyEvent(NODE_REMOVED, new NetworkNodeEventSubject(event.networkNodeKey(), null)));
                    break;
                case LINK_ADDED:
                case LINK_UPDATED:
                    NetworkLink link = store.networkLink(event.networkLinkKey());
                    post(new TeTopologyEvent(event.type(), new NetworkLinkEventSubject(event.networkLinkKey(), link)));
                    break;
                case LINK_REMOVED:
                    post(new TeTopologyEvent(LINK_REMOVED, new NetworkLinkEventSubject(event.networkLinkKey(), null)));
                    break;
                default:
                    break;
            }
        }
    } catch (InterruptedException e) {
        log.warn("TopologyMergerTask is interrupted");
    } catch (Exception e) {
        log.warn("Unable to merge topology", e);
    }
}
#end_block

#method_before
private void updateSourceTeNode(Map<Long, TeNode> teNodes, TeTopologyKey srcTopoKey, TeNode srcNode, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcNode.teNodeId());
    Long mergedTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeId);
    boolean addNode = false;
    if (mergedTeNodeId == null) {
        // New node
        addNode = true;
        mergedTeNodeId = nextTeNodeId;
        nextTeNodeId++;
        if (nextTeNodeId >= teNodeIpEnd.toInt()) {
            nextTeNodeId = teNodeIpStart.toInt();
            log.warn("TE node Id is wrapped back");
        }
        sourceNewTeNodeIdMap.put(sourceTeNodeId, mergedTeNodeId);
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No supporting
    TeNodeKey supportTeNodeId = null;
    CommonNodeData common = new CommonNodeData(srcNode.name(), srcNode.adminStatus(), srcNode.opStatus(), // No change
    srcNode.flags());
    Map<Long, ConnectivityMatrix> connMatrices = srcNode.connectivityMatrices();
    // No change
    List<Long> teLinkIds = srcNode.teLinkIds();
    Map<Long, TunnelTerminationPoint> ttps = srcNode.tunnelTerminationPoints();
    // No change
    List<Long> teTpIds = srcNode.teTerminationPointIds();
    DefaultTeNode newNode = new DefaultTeNode(mergedTeNodeId, underlayTopologyId, supportTeNodeId, sourceTeNodeId, common, connMatrices, teLinkIds, ttps, teTpIds);
    teNodes.put(mergedTeNodeId, newNode);
    if (postEvent) {
        // Post event for the TE node in the merged topology
        TeNodeKey globalKey = new TeNodeKey(mergedTopologyKey, mergedTeNodeId);
        post(new TeTopologyEvent(addNode ? TE_NODE_ADDED : TE_NODE_UPDATED, new TeNodeEventSubject(globalKey, newNode)));
        post(new TeTopologyEvent(addNode ? NODE_ADDED : NODE_UPDATED, new NetworkNodeEventSubject(TeMgrUtil.networkNodeKey(globalKey), TeMgrUtil.nodeBuilder(KeyId.keyId(Long.toString(newNode.teNodeId())), newNode))));
    }
}
#method_after
private void updateSourceTeNode(Map<Long, TeNode> teNodes, TeTopologyKey srcTopoKey, TeNode srcNode, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcNode.teNodeId());
    Long mergedTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeId);
    boolean addNode = false;
    if (mergedTeNodeId == null) {
        // New node
        addNode = true;
        mergedTeNodeId = nextTeNodeId;
        nextTeNodeId++;
        if (nextTeNodeId >= teNodeIpEnd.toInt()) {
            nextTeNodeId = teNodeIpStart.toInt();
            log.warn("TE node Id is wrapped back");
        }
        sourceNewTeNodeIdMap.put(sourceTeNodeId, mergedTeNodeId);
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No supporting
    TeNodeKey supportTeNodeId = null;
    CommonNodeData common = new CommonNodeData(srcNode.name(), srcNode.adminStatus(), srcNode.opStatus(), // No change
    srcNode.flags());
    Map<Long, ConnectivityMatrix> connMatrices = srcNode.connectivityMatrices();
    // No change
    List<Long> teLinkIds = srcNode.teLinkIds();
    Map<Long, TunnelTerminationPoint> ttps = srcNode.tunnelTerminationPoints();
    // No change
    List<Long> teTpIds = srcNode.teTerminationPointIds();
    DefaultTeNode newNode = new DefaultTeNode(mergedTeNodeId, underlayTopologyId, supportTeNodeId, sourceTeNodeId, common, connMatrices, teLinkIds, ttps, teTpIds);
    teNodes.put(mergedTeNodeId, newNode);
    if (postEvent) {
        // Post event for the TE node in the merged topology
        TeNodeKey globalKey = new TeNodeKey(mergedTopologyKey, mergedTeNodeId);
        post(new TeTopologyEvent(addNode ? TE_NODE_ADDED : TE_NODE_UPDATED, new TeNodeEventSubject(globalKey, newNode)));
        post(new TeTopologyEvent(addNode ? NODE_ADDED : NODE_UPDATED, new NetworkNodeEventSubject(networkNodeKey(globalKey), nodeBuilder(KeyId.keyId(Ip4Address.valueOf((int) newNode.teNodeId()).toString()), newNode))));
    }
}
#end_block

#method_before
private TeLink updateTeLink(TeLinkTpKey newKey, TeLinkTpKey peerTeLinkKey, TeTopologyKey underlayTopologyId, TeLinkTpGlobalKey supportTeLinkId, TeLinkTpGlobalKey sourceTeLinkId, ExternalLink externalLink, TeLink exLink) {
    UnderlayPath underlayPath = new UnderlayPath(exLink.primaryPath(), exLink.backupPaths(), exLink.tunnelProtectionType(), exLink.sourceTtpId(), exLink.destinationTtpId(), exLink.teTunnelId());
    TePathAttributes teAttributes = new TePathAttributes(exLink.cost(), exLink.delay(), exLink.srlgs());
    LinkBandwidth bandwidth = new LinkBandwidth(exLink.maxBandwidth(), exLink.availBandwidth(), exLink.maxAvailLspBandwidth(), exLink.minAvailLspBandwidth(), exLink.oduResource());
    CommonLinkData common = new CommonLinkData(exLink.adminStatus(), exLink.opStatus(), exLink.flags(), exLink.switchingLayer(), exLink.encodingLayer(), externalLink, underlayPath, teAttributes, exLink.administrativeGroup(), exLink.interLayerLocks(), bandwidth);
    return new DefaultTeLink(newKey, peerTeLinkKey, underlayTopologyId, supportTeLinkId, sourceTeLinkId, common);
}
#method_after
private TeLink updateTeLink(TeLinkTpKey newKey, TeLinkTpKey peerTeLinkKey, TeTopologyKey underlayTopologyId, TeLinkTpGlobalKey supportTeLinkId, TeLinkTpGlobalKey sourceTeLinkId, ExternalLink externalLink, TeLink exLink) {
    UnderlayPath underlayPath = null;
    if (underlayTopologyId != null && underlayTopologyId.equals(exLink.underlayTeTopologyId())) {
        underlayPath = new UnderlayPath(exLink.primaryPath(), exLink.backupPaths(), exLink.tunnelProtectionType(), exLink.sourceTtpId(), exLink.destinationTtpId(), exLink.teTunnelId());
    }
    TePathAttributes teAttributes = new TePathAttributes(exLink.cost(), exLink.delay(), exLink.srlgs());
    LinkBandwidth bandwidth = new LinkBandwidth(exLink.maxBandwidth(), exLink.availBandwidth(), exLink.maxAvailLspBandwidth(), exLink.minAvailLspBandwidth(), exLink.oduResource());
    CommonLinkData common = new CommonLinkData(exLink.adminStatus(), exLink.opStatus(), exLink.flags(), exLink.switchingLayer(), exLink.encodingLayer(), externalLink, underlayPath, teAttributes, exLink.administrativeGroup(), exLink.interLayerLocks(), bandwidth);
    return new DefaultTeLink(newKey, peerTeLinkKey, underlayTopologyId, supportTeLinkId, sourceTeLinkId, common);
}
#end_block

#method_before
public boolean isFirstKey(TeLinkTpKey linkKey) {
    if (firstKey == null) {
        return false;
    }
    return firstKey.equals(linkKey);
}
#method_after
public boolean isFirstKey(TeLinkTpKey linkKey) {
    return firstKey == null ? false : firstKey.equals(linkKey);
}
#end_block

#method_before
public boolean isSecondKey(TeLinkTpKey linkKey) {
    if (secondKey == null) {
        return false;
    }
    return secondKey.equals(linkKey);
}
#method_after
public boolean isSecondKey(TeLinkTpKey linkKey) {
    return secondKey == null ? false : secondKey.equals(linkKey);
}
#end_block

#method_before
private void removeSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeLinkTpGlobalKey teLinkKey, boolean postEvent) {
    TeNodeKey sourceTeNodeKey = teLinkKey.teNodeKey();
    Long newTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeKey);
    if (newTeNodeId == null) {
        return;
    }
    TeLinkTpKey newLinkKey = new TeLinkTpKey(newTeNodeId, teLinkKey.teLinkTpId());
    TeLink teLink = teLinks.remove(newLinkKey);
    if (teLink == null) {
        return;
    }
    // Post event
    if (postEvent) {
        TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(mergedTopologyKey, newLinkKey);
        post(new TeTopologyEvent(TE_LINK_REMOVED, new TeLinkEventSubject(globalKey, null)));
        post(new TeTopologyEvent(LINK_REMOVED, new NetworkLinkEventSubject(TeMgrUtil.networkLinkKey(globalKey), null)));
    }
    if (teLink.externalLink() != null && teLink.externalLink().plugId() != null) {
        // Update the LinkKeyPair in externalLinkMap
        LinkKeyPair pair = externalLinkMap.get(teLink.externalLink().plugId());
        if (pair.isFirstKey(newLinkKey)) {
            pair.setFirstKey(null);
        } else if (pair.isSecondKey(newLinkKey)) {
            pair.setSecondKey(null);
        }
        if (pair.isEmpty()) {
            externalLinkMap.remove(teLink.externalLink().plugId());
        }
    }
    TeLinkTpKey peerTeLinkKey = teLink.peerTeLinkKey();
    if (peerTeLinkKey != null) {
        // Update peerLink's peerTeLinkKey to null
        TeLink peerLink = teLinks.get(peerTeLinkKey);
        if (peerLink == null || peerLink.peerTeLinkKey() == null) {
            return;
        }
        TeLink newPeerLink = updateTeLink(peerTeLinkKey, null, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
        teLinks.put(peerTeLinkKey, newPeerLink);
        if (postEvent) {
            TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey);
            post(new TeTopologyEvent(TE_LINK_UPDATED, new TeLinkEventSubject(globalKey, newPeerLink)));
            post(new TeTopologyEvent(LINK_UPDATED, new NetworkLinkEventSubject(TeMgrUtil.networkLinkKey(globalKey), TeMgrUtil.linkBuilder(TeMgrUtil.toNetworkLinkId(peerTeLinkKey), newPeerLink))));
        }
    }
}
#method_after
private void removeSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeLinkTpGlobalKey teLinkKey, boolean postEvent) {
    TeNodeKey sourceTeNodeKey = teLinkKey.teNodeKey();
    Long newTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeKey);
    if (newTeNodeId == null) {
        return;
    }
    TeLinkTpKey newLinkKey = new TeLinkTpKey(newTeNodeId, teLinkKey.teLinkTpId());
    TeLink teLink = teLinks.remove(newLinkKey);
    if (teLink == null) {
        return;
    }
    // Post event
    if (postEvent) {
        TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(mergedTopologyKey, newLinkKey);
        post(new TeTopologyEvent(TE_LINK_REMOVED, new TeLinkEventSubject(globalKey, null)));
        post(new TeTopologyEvent(LINK_REMOVED, new NetworkLinkEventSubject(networkLinkKey(globalKey), null)));
    }
    if (teLink.externalLink() != null && teLink.externalLink().plugId() != null) {
        // Update the LinkKeyPair in externalLinkMap
        LinkKeyPair pair = externalLinkMap.get(teLink.externalLink().plugId());
        if (pair.isFirstKey(newLinkKey)) {
            pair.setFirstKey(null);
        } else if (pair.isSecondKey(newLinkKey)) {
            pair.setSecondKey(null);
        }
        if (pair.isEmpty()) {
            externalLinkMap.remove(teLink.externalLink().plugId());
        }
    }
    TeLinkTpKey peerTeLinkKey = teLink.peerTeLinkKey();
    if (peerTeLinkKey != null) {
        // Update peerLink's peerTeLinkKey to null
        TeLink peerLink = teLinks.get(peerTeLinkKey);
        if (peerLink == null || peerLink.peerTeLinkKey() == null) {
            return;
        }
        TeLink newPeerLink = updateTeLink(peerTeLinkKey, null, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
        teLinks.put(peerTeLinkKey, newPeerLink);
        if (postEvent) {
            TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey);
            post(new TeTopologyEvent(TE_LINK_UPDATED, new TeLinkEventSubject(globalKey, newPeerLink)));
            post(new TeTopologyEvent(LINK_UPDATED, new NetworkLinkEventSubject(networkLinkKey(globalKey), linkBuilder(toNetworkLinkId(peerTeLinkKey), newPeerLink))));
        }
    }
}
#end_block

#method_before
private void updateSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeTopologyKey srcTopoKey, TeLink srcLink, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcLink.teLinkKey().teNodeId());
    TeLinkTpKey newKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourceTeNodeId), srcLink.teLinkKey().teLinkTpId());
    TeLinkTpKey peerTeLinkKey = null;
    if (srcLink.peerTeLinkKey() != null) {
        TeNodeKey sourcePeerNode = new TeNodeKey(srcTopoKey, srcLink.peerTeLinkKey().teNodeId());
        peerTeLinkKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourcePeerNode), srcLink.peerTeLinkKey().teLinkTpId());
    }
    if (srcLink.externalLink() != null && srcLink.externalLink().plugId() != null) {
        // externalLinkKey doesn't have topology Id.
        // using plugId for now
        LinkKeyPair pair = externalLinkMap.get(srcLink.externalLink().plugId());
        if (pair == null) {
            // Store it in the map
            externalLinkMap.put(srcLink.externalLink().plugId(), new LinkKeyPair(newKey));
        } else {
            if (pair.isFirstKey(newKey)) {
                peerTeLinkKey = pair.secondKey();
            } else if (pair.isSecondKey(newKey)) {
                peerTeLinkKey = pair.firstKey();
            } else if (pair.firstKey() == null) {
                peerTeLinkKey = pair.secondKey();
                pair.setFirstKey(newKey);
            } else if (pair.secondKey() == null) {
                peerTeLinkKey = pair.firstKey();
                pair.setSecondKey(newKey);
            }
            if (peerTeLinkKey != null) {
                TeLink peerLink = teLinks.get(peerTeLinkKey);
                if (peerLink != null && (peerLink.peerTeLinkKey() == null || !peerLink.peerTeLinkKey().equals(newKey))) {
                    // Update peer Link with local link key
                    TeLink newPeerLink = updateTeLink(peerTeLinkKey, newKey, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
                    teLinks.put(peerTeLinkKey, newPeerLink);
                    if (postEvent) {
                        TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey);
                        post(new TeTopologyEvent(TE_LINK_UPDATED, new TeLinkEventSubject(globalKey, newPeerLink)));
                        post(new TeTopologyEvent(LINK_UPDATED, new NetworkLinkEventSubject(TeMgrUtil.networkLinkKey(globalKey), TeMgrUtil.linkBuilder(TeMgrUtil.toNetworkLinkId(peerTeLinkKey), newPeerLink))));
                    }
                }
            }
        }
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No support
    TeLinkTpGlobalKey supportTeLinkId = null;
    // Source link for the new updated link
    TeLinkTpGlobalKey sourceTeLinkId = new TeLinkTpGlobalKey(srcTopoKey, srcLink.teLinkKey());
    TeLink updatedLink = updateTeLink(newKey, peerTeLinkKey, underlayTopologyId, supportTeLinkId, sourceTeLinkId, srcLink.externalLink(), srcLink);
    TeLinkTpGlobalKey newGlobalKey = new TeLinkTpGlobalKey(mergedTopologyKey, newKey);
    boolean newLink = teLinks.get(newKey) == null ? true : false;
    teLinks.put(newKey, updatedLink);
    if (postEvent) {
        // Post event
        post(new TeTopologyEvent(newLink ? TE_LINK_ADDED : TE_LINK_UPDATED, new TeLinkEventSubject(newGlobalKey, updatedLink)));
        post(new TeTopologyEvent(newLink ? LINK_ADDED : LINK_UPDATED, new NetworkLinkEventSubject(TeMgrUtil.networkLinkKey(newGlobalKey), TeMgrUtil.linkBuilder(TeMgrUtil.toNetworkLinkId(updatedLink.teLinkKey()), updatedLink))));
    }
}
#method_after
private void updateSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeTopologyKey srcTopoKey, TeLink srcLink, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcLink.teLinkKey().teNodeId());
    TeLinkTpKey newKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourceTeNodeId), srcLink.teLinkKey().teLinkTpId());
    TeLinkTpKey peerTeLinkKey = null;
    if (srcLink.peerTeLinkKey() != null) {
        TeNodeKey sourcePeerNode = new TeNodeKey(srcTopoKey, srcLink.peerTeLinkKey().teNodeId());
        peerTeLinkKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourcePeerNode), srcLink.peerTeLinkKey().teLinkTpId());
    }
    if (srcLink.externalLink() != null && srcLink.externalLink().plugId() != null) {
        // externalLinkKey doesn't have topology Id.
        // using plugId for now
        LinkKeyPair pair = externalLinkMap.get(srcLink.externalLink().plugId());
        if (pair == null) {
            // Store it in the map
            externalLinkMap.put(srcLink.externalLink().plugId(), new LinkKeyPair(newKey));
        } else {
            if (newKey.equals(pair.firstKey())) {
                peerTeLinkKey = pair.secondKey();
            } else if (newKey.equals(pair.secondKey())) {
                peerTeLinkKey = pair.firstKey();
            } else if (pair.firstKey() == null) {
                peerTeLinkKey = pair.secondKey();
                pair.setFirstKey(newKey);
            } else if (pair.secondKey() == null) {
                peerTeLinkKey = pair.firstKey();
                pair.setSecondKey(newKey);
            }
            if (peerTeLinkKey != null) {
                TeLink peerLink = teLinks.get(peerTeLinkKey);
                if (peerLink != null && (peerLink.peerTeLinkKey() == null || !peerLink.peerTeLinkKey().equals(newKey))) {
                    // Update peer Link with local link key
                    TeLink newPeerLink = updateTeLink(peerTeLinkKey, newKey, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
                    teLinks.put(peerTeLinkKey, newPeerLink);
                    if (postEvent) {
                        TeLinkTpGlobalKey globalKey = new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey);
                        post(new TeTopologyEvent(TE_LINK_UPDATED, new TeLinkEventSubject(globalKey, newPeerLink)));
                        post(new TeTopologyEvent(LINK_UPDATED, new NetworkLinkEventSubject(networkLinkKey(globalKey), linkBuilder(toNetworkLinkId(peerTeLinkKey), newPeerLink))));
                    }
                }
            }
        }
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No support
    TeLinkTpGlobalKey supportTeLinkId = null;
    // Source link for the new updated link
    TeLinkTpGlobalKey sourceTeLinkId = new TeLinkTpGlobalKey(srcTopoKey, srcLink.teLinkKey());
    TeLink updatedLink = updateTeLink(newKey, peerTeLinkKey, underlayTopologyId, supportTeLinkId, sourceTeLinkId, srcLink.externalLink(), srcLink);
    TeLinkTpGlobalKey newGlobalKey = new TeLinkTpGlobalKey(mergedTopologyKey, newKey);
    boolean newLink = teLinks.get(newKey) == null ? true : false;
    teLinks.put(newKey, updatedLink);
    if (postEvent) {
        // Post event
        post(new TeTopologyEvent(newLink ? TE_LINK_ADDED : TE_LINK_UPDATED, new TeLinkEventSubject(newGlobalKey, updatedLink)));
        post(new TeTopologyEvent(newLink ? LINK_ADDED : LINK_UPDATED, new NetworkLinkEventSubject(networkLinkKey(newGlobalKey), linkBuilder(toNetworkLinkId(updatedLink.teLinkKey()), updatedLink))));
    }
}
#end_block

#method_before
private void updateMergedTopology(Map<Long, TeNode> teNodes, Map<TeLinkTpKey, TeLink> teLinks) {
    boolean newTopology = mergedTopology == null;
    BitSet flags = newTopology ? new BitSet(TeConstants.FLAG_MAX_BITS) : mergedTopology.flags();
    flags.set(TeTopology.BIT_MERGED);
    CommonTopologyData commonData = new CommonTopologyData(newTopology ? TeMgrUtil.toNetworkId(mergedTopologyKey) : mergedTopology.networkId(), OptimizationType.NOT_OPTIMIZED, flags, DeviceId.deviceId("localHost"));
    mergedTopology = new DefaultTeTopology(mergedTopologyKey, teNodes, teLinks, Long.toString(mergedTopologyKey.topologyId()), commonData);
    mergedNetwork = TeMgrUtil.networkBuilder(mergedTopology);
    log.info("Nodes# {}, Links# {}", mergedTopology.teNodes().size(), mergedTopology.teLinks().size());
}
#method_after
private void updateMergedTopology(Map<Long, TeNode> teNodes, Map<TeLinkTpKey, TeLink> teLinks) {
    boolean newTopology = mergedTopology == null;
    BitSet flags = newTopology ? new BitSet(TeConstants.FLAG_MAX_BITS) : mergedTopology.flags();
    flags.set(BIT_MERGED);
    CommonTopologyData commonData = new CommonTopologyData(newTopology ? toNetworkId(mergedTopologyKey) : mergedTopology.networkId(), NOT_OPTIMIZED, flags, DeviceId.deviceId("localHost"));
    mergedTopology = new DefaultTeTopology(mergedTopologyKey, teNodes, teLinks, Long.toString(mergedTopologyKey.topologyId()), commonData);
    mergedNetwork = networkBuilder(mergedTopology);
    log.info("Nodes# {}, Links# {}", mergedTopology.teNodes().size(), mergedTopology.teLinks().size());
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    try {
        providerId = cfgService.getConfig(appId, TeTopologyConfig.class).providerId();
        store.setProviderId(providerId);
        teNodeIpStart = cfgService.getConfig(appId, TeTopologyConfig.class).teNodeIpStart();
        teNodeIpEnd = cfgService.getConfig(appId, TeTopologyConfig.class).teNodeIpEnd();
        mdsc = cfgService.getConfig(appId, TeTopologyConfig.class).mdsc().equals(MDSC_MODE);
        nextTeNodeId = teNodeIpStart.toInt();
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    try {
        providerId = cfgService.getConfig(appId, TeTopologyConfig.class).providerId();
        store.setProviderId(providerId);
        teNodeIpStart = cfgService.getConfig(appId, TeTopologyConfig.class).teNodeIpStart();
        teNodeIpEnd = cfgService.getConfig(appId, TeTopologyConfig.class).teNodeIpEnd();
        mdsc = cfgService.getConfig(appId, TeTopologyConfig.class).mdsc().equalsIgnoreCase(MDSC_MODE);
        nextTeNodeId = teNodeIpStart.toInt();
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
}
#end_block

#method_before
@Override
public void updateTeTopology(TeTopology teTopology) {
    TeTopologyKey newKey = null;
    try {
        newKey = newTeTopologyKey(teTopology);
    } catch (ApplicationException e) {
        log.error("Ignoring the non-TE topology");
        return;
    }
    // TE topology is updated here from other APP or NBI, the flag
    // BIT_CUSTOMIZED or BIT_MERGED should be set.
    BitSet flags = teTopology.flags();
    if (flags == null || !(flags.get(TeTopology.BIT_CUSTOMIZED) || flags.get(TeTopology.BIT_MERGED))) {
        log.error("TE topology flags {} are not set properly", flags);
        return;
    }
    if (newKey != null) {
        DefaultTeTopology newTopology = new DefaultTeTopology(newKey == null ? teTopology.teTopologyId() : newKey, teTopology.teNodes(), teTopology.teLinks(), teTopology.teTopologyIdStringValue(), new CommonTopologyData(teTopology));
        // Update with new data
        store.updateTeTopology(newTopology);
    } else {
        store.updateTeTopology(teTopology);
    }
}
#method_after
@Override
public void updateTeTopology(TeTopology teTopology) {
    TeTopologyKey newKey = null;
    try {
        newKey = newTeTopologyKey(teTopology);
    } catch (ApplicationException e) {
        log.error("Ignoring the non-TE topology");
        return;
    }
    // TE topology is updated here from other APP or NBI, the flag
    // BIT_CUSTOMIZED or BIT_MERGED should be set.
    BitSet flags = teTopology.flags();
    if (flags == null || !(flags.get(BIT_CUSTOMIZED) || flags.get(BIT_MERGED))) {
        log.error("TE topology flags {} are not set properly", flags);
        return;
    }
    if (newKey != null) {
        DefaultTeTopology newTopology = new DefaultTeTopology(newKey == null ? teTopology.teTopologyId() : newKey, teTopology.teNodes(), teTopology.teLinks(), teTopology.teTopologyIdStringValue(), new CommonTopologyData(teTopology));
        // Update with new data
        store.updateTeTopology(newTopology);
    } else {
        store.updateTeTopology(teTopology);
    }
}
#end_block

#method_before
@Override
public TeNode teNode(TeNodeKey nodeId) {
    if (nodeId.teTopologyKey().equals(mergedTopologyKey)) {
        return mergedTopology.teNode(nodeId.teNodeId());
    }
    return store.teNode(nodeId);
}
#method_after
@Override
public TeNode teNode(TeNodeKey nodeId) {
    return nodeId.teTopologyKey().equals(mergedTopologyKey) ? mergedTopology.teNode(nodeId.teNodeId()) : store.teNode(nodeId);
}
#end_block

#method_before
@Override
public TeLink teLink(TeLinkTpGlobalKey linkId) {
    if (linkId.teTopologyKey().equals(mergedTopologyKey)) {
        return mergedTopology.teLink(linkId.teLinkTpKey());
    }
    return store.teLink(linkId);
}
#method_after
@Override
public TeLink teLink(TeLinkTpGlobalKey linkId) {
    return linkId.teTopologyKey().equals(mergedTopologyKey) ? mergedTopology.teLink(linkId.teLinkTpKey()) : store.teLink(linkId);
}
#end_block

#method_before
@Override
public TunnelTerminationPoint tunnelTerminationPoint(TtpKey ttpId) {
    if (ttpId.teTopologyKey().equals(mergedTopologyKey)) {
        return mergedTopology.teNode(ttpId.teNodeId()).tunnelTerminationPoint(ttpId.ttpId());
    }
    return store.tunnelTerminationPoint(ttpId);
}
#method_after
@Override
public TunnelTerminationPoint tunnelTerminationPoint(TtpKey ttpId) {
    return ttpId.teTopologyKey().equals(mergedTopologyKey) ? mergedTopology.teNode(ttpId.teNodeId()).tunnelTerminationPoint(ttpId.ttpId()) : store.tunnelTerminationPoint(ttpId);
}
#end_block

#method_before
@Override
public KeyId networkId(TeTopologyKey teTopologyKey) {
    return store.networkId(teTopologyKey);
}
#method_after
@Override
public KeyId networkId(TeTopologyKey teTopologyKey) {
    return teTopologyKey.equals(mergedTopologyKey) ? mergedNetwork.networkId() : store.networkId(teTopologyKey);
}
#end_block

#method_before
@Override
public NetworkNodeKey nodeKey(TeNodeKey teNodeKey) {
    return store.nodeKey(teNodeKey);
}
#method_after
@Override
public NetworkNodeKey nodeKey(TeNodeKey teNodeKey) {
    return teNodeKey.teTopologyKey().equals(mergedTopologyKey) ? networkNodeKey(teNodeKey) : store.nodeKey(teNodeKey);
}
#end_block

#method_before
@Override
public NetworkLinkKey linkKey(TeLinkTpGlobalKey teLinkKey) {
    return store.linkKey(teLinkKey);
}
#method_after
@Override
public NetworkLinkKey linkKey(TeLinkTpGlobalKey teLinkKey) {
    return teLinkKey.teTopologyKey().equals(mergedTopologyKey) ? networkLinkKey(teLinkKey) : store.linkKey(teLinkKey);
}
#end_block

#method_before
@Override
public TerminationPointKey terminationPointKey(TeLinkTpGlobalKey teTpKey) {
    return store.terminationPointKey(teTpKey);
}
#method_after
@Override
public TerminationPointKey terminationPointKey(TeLinkTpGlobalKey teTpKey) {
    return teTpKey.teTopologyKey().equals(mergedTopologyKey) ? new TerminationPointKey(networkNodeKey(teTpKey.teNodeKey()), KeyId.keyId(Long.toString(teTpKey.teLinkTpId()))) : store.terminationPointKey(teTpKey);
}
#end_block

#method_before
private YdtNode moduleHandler(YangSchemaNodeIdentifier id) throws YdtException {
    YangSchemaNode node;
    /*
         * Since XML will not have module name, id.name will be null. In that
         * case get schema node by using namespace. In NBI flow, name will never
         * be null.
         */
    if (id.getName() != null) {
        node = registry.getYangSchemaNodeUsingSchemaName(id.getName());
    } else {
        node = registry.getSchemaWrtNameSpace(id.getNameSpace().getModuleNamespace());
    }
    String namespace = id.getNameSpace().getModuleNamespace();
    /*
         * Checking received schema node is having same namespace as
         * requested by user or not.
         */
    if (node == null || namespace != null && !namespace.equals(node.getYangSchemaNodeIdentifier().getNameSpace().getModuleNamespace())) {
        throw new YdtException(errorMsg(FMT_NOT_EXIST, id.getName()));
    }
    /*
         * If yms operation is for query then no validation need to be
         * performed.
         */
    if (ymsOperationType != YmsOperationType.QUERY_REQUEST) {
        // Checking whether module node is already exits in YDT or not.
        try {
            curNode.getCollidingChild(id);
        } catch (YdtException e) {
            throw new YdtException(e.getLocalizedMessage());
        }
    }
    YdtNode newNode = new YdtSingleInstanceNode(node);
    newNode.setYangSchemaNode(node);
    return newNode;
}
#method_after
private YdtNode moduleHandler(YangSchemaNodeIdentifier id) throws YdtException {
    YangSchemaNode node = registry.getYangSchemaNodeUsingSchemaName(id.getName());
    String namespace = id.getNameSpace().getModuleNamespace();
    /*
         * Checking received schema node is having same namespace as
         * requested by user or not.
         */
    if (node == null || namespace != null && !namespace.equals(node.getYangSchemaNodeIdentifier().getNameSpace().getModuleNamespace())) {
        throw new YdtException(errorMsg(FMT_NOT_EXIST, id.getName()));
    }
    /*
         * If yms operation is for query then no validation need to be
         * performed.
         */
    if (ymsOperationType != YmsOperationType.QUERY_REQUEST) {
        // Checking whether module node is already exits in YDT or not.
        try {
            curNode.getCollidingChild(id);
        } catch (YdtException e) {
            throw new YdtException(e.getLocalizedMessage());
        }
    }
    YdtNode newNode = new YdtSingleInstanceNode(node);
    newNode.setYangSchemaNode(node);
    return newNode;
}
#end_block

#method_before
private void addChild(String name, String namespace, RequestedCardinality cardinality, YdtContextOperationType opType, RequestedCallType callType) throws IllegalArgumentException {
    YdtNode newNode;
    boolean contextSwitch = false;
    YangSchemaNode augmentingSchema = null;
    YangSchemaNodeIdentifier id = getNodeIdentifier(name, namespace);
    try {
        // Module/sub-module node handler.
        if (curNode.equals(rootNode)) {
            newNode = moduleHandler(id);
        } else {
            YangSchemaNode schemaNode;
            YangSchemaNodeContextInfo contextInfo;
            // If namespace given by user null, then take namespace from parent.
            if (namespace == null) {
                id.setNameSpace(curNode.getYangSchemaNode().getNameSpace());
            }
            /*
                 * Get the already exiting YDT node in YDT tree with same
                 * nodeIdentifier
                 */
            newNode = curNode.getCollidingChild(id);
            /*
                 * If colliding child doesn't exist ,
                 * then query yang data model for schema of given node.
                 */
            if (newNode == null) {
                /*
                     * Get Yang Schema node context info which is having
                     * YangSchemaNode and ContextSwitchedNode.
                     */
                contextInfo = curNode.getSchemaNodeContextInfo(id);
                if (contextInfo.getContextSwitchedNode() != null) {
                    augmentingSchema = getAugmentingSchemaNode(id, contextInfo);
                    if (augmentingSchema != null) {
                        /*
                             * As two tree(YDT and YDT Application Tree) are getting
                             * prepared in parallel, So  setting context switch
                             * flag it will help ydt to keep the track whether
                             * ydtApp tree also need to be traversed back to parent
                             * or not with YDT tree traverse to parent call.
                             */
                        contextSwitch = true;
                    }
                }
                schemaNode = contextInfo.getSchemaNode();
            } else {
                /*
                     * If colliding child exist , then it will be leaf-list or list.
                     * If its leaf-list then return and add new requested
                     * value/valueSet in same node else take yang data model
                     * information from colliding child.
                     */
                if (newNode.getYdtType() == MULTI_INSTANCE_LEAF_VALUE_NODE) {
                    curNode = newNode;
                    return;
                }
                schemaNode = newNode.getYangSchemaNode();
            }
            /*
                 * For yms query request node specific validation are not
                 * required as rest-conf can call addChild api for leaf/leaf-list
                 * node addition also in ydt.
                 */
            if (ymsOperationType == YmsOperationType.QUERY_REQUEST) {
                newNode = getYangSchemaNodeTypeSpecificContext(schemaNode);
            } else {
                newNode = getNode(schemaNode, cardinality, callType);
            }
        }
        opType = getValidOpType(opType, ydtDefaultOpType, newNode, curNode);
        newNode.setYdtContextOperationType(opType);
        curNode.addChild(newNode, true);
    } catch (YdtException e) {
        freeRestResources(rootNode);
        throw new IllegalArgumentException(e.getLocalizedMessage());
    }
    // Update parent ydt node map.
    curNode.updateYdtMap(newNode);
    processAppTree(opType, newNode, augmentingSchema, contextSwitch);
    curNode = newNode;
}
#method_after
private void addChild(String name, String namespace, RequestedCardinality cardinality, YdtContextOperationType opType, RequestedCallType callType) throws IllegalArgumentException {
    YdtNode newNode;
    boolean contextSwitch = false;
    YangSchemaNode augmentingSchema = null;
    YangSchemaNodeIdentifier id = getNodeIdentifier(name, namespace);
    if (name == null) {
        if (!curNode.equals(rootNode)) {
            throw new YdtException("Name is null for node other than module");
        }
        /*
             * Since XML will not have module name, id.name will be null. In
             * that case get schema node by using namespace. In NBI flow,
             * name will never be null.
             */
        YangSchemaNode node = registry.getSchemaWrtNameSpace(id.getNameSpace().getModuleNamespace());
        id.setName(node.getName());
    }
    try {
        // Module/sub-module node handler.
        if (curNode.equals(rootNode)) {
            newNode = moduleHandler(id);
        } else {
            YangSchemaNode schemaNode;
            YangSchemaNodeContextInfo contextInfo;
            // If namespace given by user null, then take namespace from parent.
            if (namespace == null) {
                id.setNameSpace(curNode.getYangSchemaNode().getNameSpace());
            }
            /*
                 * Get the already exiting YDT node in YDT tree with same
                 * nodeIdentifier
                 */
            newNode = curNode.getCollidingChild(id);
            /*
                 * If colliding child doesn't exist ,
                 * then query yang data model for schema of given node.
                 */
            if (newNode == null) {
                /*
                     * Get Yang Schema node context info which is having
                     * YangSchemaNode and ContextSwitchedNode.
                     */
                contextInfo = curNode.getSchemaNodeContextInfo(id);
                if (contextInfo.getContextSwitchedNode() != null) {
                    augmentingSchema = getAugmentingSchemaNode(id, contextInfo);
                    if (augmentingSchema != null) {
                        /*
                             * As two tree(YDT and YDT Application Tree) are getting
                             * prepared in parallel, So  setting context switch
                             * flag it will help ydt to keep the track whether
                             * ydtApp tree also need to be traversed back to parent
                             * or not with YDT tree traverse to parent call.
                             */
                        contextSwitch = true;
                    }
                }
                schemaNode = contextInfo.getSchemaNode();
            } else {
                /*
                     * If colliding child exist , then it will be leaf-list or list.
                     * If its leaf-list then return and add new requested
                     * value/valueSet in same node else take yang data model
                     * information from colliding child.
                     */
                if (newNode.getYdtType() == MULTI_INSTANCE_LEAF_VALUE_NODE) {
                    curNode = newNode;
                    return;
                }
                schemaNode = newNode.getYangSchemaNode();
            }
            /*
                 * For yms query request node specific validation are not
                 * required as rest-conf can call addChild api for leaf/leaf-list
                 * node addition also in ydt.
                 */
            if (ymsOperationType == YmsOperationType.QUERY_REQUEST) {
                newNode = getYangSchemaNodeTypeSpecificContext(schemaNode);
            } else {
                newNode = getNode(schemaNode, cardinality, callType);
            }
        }
        opType = getValidOpType(opType, ydtDefaultOpType, newNode, curNode);
        newNode.setYdtContextOperationType(opType);
        curNode.addChild(newNode, true);
    } catch (YdtException e) {
        freeRestResources(rootNode);
        throw new IllegalArgumentException(e.getLocalizedMessage());
    }
    // Update parent ydt node map.
    curNode.updateYdtMap(newNode);
    processAppTree(opType, newNode, augmentingSchema, contextSwitch);
    curNode = newNode;
}
#end_block

#method_before
private void provisionEapol(FilteringObjective filter, EthTypeCriterion ethType, Instructions.OutputInstruction output) {
    TrafficSelector selector = buildSelector(filter.key(), ethType);
    TrafficTreatment treatment = buildTreatment(output);
    buildAndApplyRule(filter, selector, treatment, 1200);
}
#method_after
private void provisionEapol(FilteringObjective filter, EthTypeCriterion ethType, Instructions.OutputInstruction output) {
    TrafficSelector selector = buildSelector(filter.key(), ethType);
    TrafficTreatment treatment = buildTreatment(output);
    buildAndApplyRule(filter, selector, treatment, EAPOL_FLOW_PRIORITY);
}
#end_block

#method_before
private void buildAndApplyRule(FilteringObjective filter, TrafficSelector selector, TrafficTreatment treatment) {
    FlowRule rule = DefaultFlowRule.builder().fromApp(filter.appId()).forDevice(deviceId).forTable(0).makePermanent().withSelector(selector).withTreatment(treatment).withPriority(filter.priority()).build();
    FlowRuleOperations.Builder opsBuilder = FlowRuleOperations.builder();
    switch(filter.type()) {
        case PERMIT:
            opsBuilder.add(rule);
            break;
        case DENY:
            opsBuilder.remove(rule);
            break;
        default:
            log.warn("Unknown filter type : {}", filter.type());
            fail(filter, ObjectiveError.UNSUPPORTED);
    }
    applyFlowRules(opsBuilder, filter);
}
#method_after
private void buildAndApplyRule(FilteringObjective filter, TrafficSelector selector, TrafficTreatment treatment) {
    buildAndApplyRule(filter, selector, treatment, filter.priority());
}
#end_block

#method_before
private DeviceEvent markOfflineInternal(DeviceId deviceId, Timestamp timestamp) {
    Map<ProviderId, DeviceDescriptions> providerDescs = getOrCreateDeviceDescriptionsMap(deviceId);
    // FIXME: We're synchronizing on a local variable; this is questionable
    synchronized (providerDescs) {
        // accept off-line if given timestamp is newer than
        // the latest Timestamp from Primary provider
        DeviceDescriptions primDescs = getPrimaryDescriptions(providerDescs);
        if (primDescs == null) {
            return null;
        }
        Timestamp lastTimestamp = primDescs.getLatestTimestamp();
        if (timestamp.compareTo(lastTimestamp) <= 0) {
            // outdated event ignore
            return null;
        }
        offline.put(deviceId, timestamp);
        Device device = devices.get(deviceId);
        if (device == null) {
            return null;
        }
        boolean removed = availableDevices.remove(deviceId);
        if (removed) {
            return new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, device, null);
        }
        return null;
    }
}
#method_after
private DeviceEvent markOfflineInternal(DeviceId deviceId, Timestamp timestamp) {
    Map<ProviderId, DeviceDescriptions> providerDescs = getOrCreateDeviceDescriptionsMap(deviceId);
    // locking device
    synchronized (providerDescs) {
        // accept off-line if given timestamp is newer than
        // the latest Timestamp from Primary provider
        DeviceDescriptions primDescs = getPrimaryDescriptions(providerDescs);
        if (primDescs == null) {
            return null;
        }
        Timestamp lastTimestamp = primDescs.getLatestTimestamp();
        if (timestamp.compareTo(lastTimestamp) <= 0) {
            // outdated event ignore
            return null;
        }
        offline.put(deviceId, timestamp);
        Device device = devices.get(deviceId);
        if (device == null) {
            return null;
        }
        boolean removed = availableDevices.remove(deviceId);
        if (removed) {
            return new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, device, null);
        }
        return null;
    }
}
#end_block

#method_before
public CarrierEthernetInni build() {
    checkNotNull(cp, "INNI must have an associated Connect Point");
    return new CarrierEthernetInni(cp, cfgId, role, sVlanId, tpid, usedCapacity);
}
#method_after
public CarrierEthernetInni build() {
    return new CarrierEthernetInni(cp, cfgId, role, sVlanId, tpid, usedCapacity);
}
#end_block

#method_before
public CarrierEthernetEnni build() {
    checkNotNull(cp, "ENNI must have an associated Connect Point");
    return new CarrierEthernetEnni(cp, cfgId, role, sVlanId, tpid, usedCapacity);
}
#method_after
public CarrierEthernetEnni build() {
    return new CarrierEthernetEnni(cp, cfgId, role, sVlanId, tpid, usedCapacity);
}
#end_block

#method_before
public CarrierEthernetUni build() {
    checkNotNull(cp, "UNI must have an associated Connect Point");
    return new CarrierEthernetUni(cp, cfgId, role, ceVlanId, bwp);
}
#method_after
public CarrierEthernetUni build() {
    return new CarrierEthernetUni(cp, cfgId, role, ceVlanId, bwp);
}
#end_block

#method_before
// TODO: Add further arguments for VLAN tag preservation, CoS preservation etc.
@Override
protected void execute() {
    CarrierEthernetManager ceManager = get(CarrierEthernetManager.class);
    CarrierEthernetForwardingConstruct fc = new CarrierEthernetForwardingConstruct(argFcId, argFcCfgId, generateServiceType(), generateLtpSet(), null);
    ceManager.installFc(fc);
}
#method_after
// TODO: Add further arguments for VLAN tag preservation, CoS preservation etc.
@Override
protected void execute() {
    CarrierEthernetManager ceManager = get(CarrierEthernetManager.class);
    ceManager.installFc(CarrierEthernetForwardingConstruct.builder().id(argFcId).cfgId(argFcCfgId).type(generateServiceType()).ltpSet(generateLtpSet()).build());
}
#end_block

#method_before
private CarrierEthernetVirtualConnection.Type generateServiceType() {
    if (argEvcType == null) {
        // FIXME: This probably applies only to list of UNIs
        return ((argLtpList.size() > 2) ? CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT : CarrierEthernetVirtualConnection.Type.POINT_TO_POINT);
    } else {
        // TODO: Catch exception
        return CarrierEthernetVirtualConnection.Type.fromString(argEvcType);
    }
}
#method_after
private CarrierEthernetVirtualConnection.Type generateServiceType() {
    if (argEvcType == null) {
        // FIXME: This probably applies only to list of UNIs
        return ((argLtpList.size() > 2) ? CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT : CarrierEthernetVirtualConnection.Type.POINT_TO_POINT);
    } else {
        // TODO: Catch exception
        return CarrierEthernetVirtualConnection.Type.valueOf(argEvcType);
    }
}
#end_block

#method_before
// TODO: Add further arguments for VLAN tag preservation, CoS preservation etc.
@Override
protected void execute() {
    CarrierEthernetManager ceManager = get(CarrierEthernetManager.class);
    CarrierEthernetVirtualConnection evc = new CarrierEthernetVirtualConnection(argEvcId, argEvcCfgId, generateEvcType(), generateMaxNumUni(), generateUniSet(), null);
    ceManager.installEvc(evc);
}
#method_after
// TODO: Add further arguments for VLAN tag preservation, CoS preservation etc.
@Override
protected void execute() {
    CarrierEthernetManager ceManager = get(CarrierEthernetManager.class);
    ceManager.installEvc(CarrierEthernetVirtualConnection.builder().id(argEvcId).cfgId(argEvcCfgId).type(generateEvcType()).maxNumUni(generateMaxNumUni()).uniSet(generateUniSet()).build());
}
#end_block

#method_before
CarrierEthernetVirtualConnection.Type generateEvcType() {
    if (argEvcType == null) {
        return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT : CarrierEthernetVirtualConnection.Type.POINT_TO_POINT);
    } else {
        // TODO: Catch exception
        return CarrierEthernetVirtualConnection.Type.fromString(argEvcType);
    }
}
#method_after
CarrierEthernetVirtualConnection.Type generateEvcType() {
    if (argEvcType == null) {
        return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT : CarrierEthernetVirtualConnection.Type.POINT_TO_POINT);
    } else {
        // TODO: Catch exception
        return CarrierEthernetVirtualConnection.Type.valueOf(argEvcType);
    }
}
#end_block

#method_before
Integer generateMaxNumUni() {
    if (argMaxNumUni == null) {
        if (argEvcType == null) {
            return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.MAX_NUM_UNI : 2);
        } else {
            // TODO: Catch exception
            CarrierEthernetVirtualConnection.Type evcType = CarrierEthernetVirtualConnection.Type.fromString(argEvcType);
            return (evcType.equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT) ? 2 : CarrierEthernetVirtualConnection.MAX_NUM_UNI);
        }
    } else {
        return Integer.valueOf(argMaxNumUni);
    }
}
#method_after
Integer generateMaxNumUni() {
    if (argMaxNumUni == null) {
        if (argEvcType == null) {
            return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.MAX_NUM_UNI : 2);
        } else {
            // TODO: Catch exception
            CarrierEthernetVirtualConnection.Type evcType = CarrierEthernetVirtualConnection.Type.valueOf(argEvcType);
            return (evcType.equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT) ? 2 : CarrierEthernetVirtualConnection.MAX_NUM_UNI);
        }
    } else {
        return Integer.valueOf(argMaxNumUni);
    }
}
#end_block

#method_before
public CarrierEthernetBandwidthProfile build() {
    checkNotNull(cir, "BW Profile must have an associated CIR");
    return new CarrierEthernetBandwidthProfile(id, cfgId, type, cir, eir, cbs, ebs);
}
#method_after
public CarrierEthernetBandwidthProfile build() {
    return new CarrierEthernetBandwidthProfile(id, cfgId, type, cir, eir, cbs, ebs);
}
#end_block

#method_before
public CarrierEthernetForwardingConstruct build() {
    checkNotNull(type, "FC must have a type");
    checkArgument(ltpSet != null && ltpSet.size() > 1, "FC must include at least two LTPs");
    return new CarrierEthernetForwardingConstruct(id, cfgId, type, ltpSet, maxLatency, congruentPaths);
}
#method_after
public CarrierEthernetForwardingConstruct build() {
    checkNotNull(type, "FC must have a type");
    checkArgument(ltpSet != null && ltpSet.size() > 1, "FC must include at least two LTPs");
    return new CarrierEthernetForwardingConstruct(id, cfgId, type, ltpSet, maxLatency);
}
#end_block

#method_before
public static Ethernet buildIcmp6Reply(Ethernet ethRequest) {
    Ethernet ethReply = new Ethernet();
    IPv6 ipv6Request = (IPv6) ethRequest.getPayload();
    IPv6 ipv6Reply = new IPv6();
    byte[] destAddress = ipv6Request.getDestinationAddress();
    ipv6Reply.setDestinationAddress(ipv6Request.getSourceAddress());
    ipv6Reply.setSourceAddress(destAddress);
    ipv6Reply.setHopLimit((byte) 64);
    ICMP6 icmpv6Reply = new ICMP6();
    icmpv6Reply.setPayload(ipv6Request.getPayload().getPayload());
    icmpv6Reply.setIcmpType(ICMP6.ECHO_REPLY);
    icmpv6Reply.setIcmpCode((byte) 0);
    ipv6Reply.setPayload(icmpv6Reply);
    ethReply.setEtherType(Ethernet.TYPE_IPV6);
    ethReply.setVlanID(ethRequest.getVlanID());
    ethReply.setDestinationMACAddress(ethRequest.getSourceMACAddress());
    ethReply.setSourceMACAddress(ethRequest.getDestinationMACAddress());
    ethReply.setPayload(ipv6Reply);
    return ethReply;
}
#method_after
public static Ethernet buildIcmp6Reply(Ethernet ethRequest) {
    if (ethRequest.getEtherType() != Ethernet.TYPE_IPV6) {
        return null;
    }
    IPv6 ipv6Request = (IPv6) ethRequest.getPayload();
    if (ipv6Request.getNextHeader() != IPv6.PROTOCOL_ICMP6) {
        return null;
    }
    Ethernet ethReply = new Ethernet();
    IPv6 ipv6Reply = new IPv6();
    byte[] destAddress = ipv6Request.getDestinationAddress();
    ipv6Reply.setDestinationAddress(ipv6Request.getSourceAddress());
    ipv6Reply.setSourceAddress(destAddress);
    ipv6Reply.setHopLimit((byte) 64);
    ipv6Reply.setNextHeader(IPv6.PROTOCOL_ICMP6);
    ICMP6 icmpv6Reply = new ICMP6();
    icmpv6Reply.setPayload(ipv6Request.getPayload().getPayload());
    icmpv6Reply.setIcmpType(ICMP6.ECHO_REPLY);
    icmpv6Reply.setIcmpCode((byte) 0);
    ipv6Reply.setPayload(icmpv6Reply);
    ethReply.setEtherType(Ethernet.TYPE_IPV6);
    ethReply.setVlanID(ethRequest.getVlanID());
    ethReply.setDestinationMACAddress(ethRequest.getSourceMACAddress());
    ethReply.setSourceMACAddress(ethRequest.getDestinationMACAddress());
    ethReply.setPayload(ipv6Reply);
    return ethReply;
}
#end_block

#method_before
public static byte[] solicitationNodeAddress(byte[] targetIp) {
    return new byte[] { (byte) 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, (byte) 0xff, targetIp[targetIp.length - 3], targetIp[targetIp.length - 2], targetIp[targetIp.length - 1] };
}
#method_after
public static byte[] solicitationNodeAddress(byte[] targetIp) {
    return targetIp.length != Ip6Address.BYTE_LENGTH ? null : new byte[] { (byte) 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, (byte) 0xff, targetIp[targetIp.length - 3], targetIp[targetIp.length - 2], targetIp[targetIp.length - 1] };
}
#end_block

#method_before
public static byte[] multicastMacAddress(byte[] targetIp) {
    return new byte[] { 0x33, 0x33, targetIp[targetIp.length - 4], targetIp[targetIp.length - 3], targetIp[targetIp.length - 2], targetIp[targetIp.length - 1] };
}
#method_after
public static byte[] multicastMacAddress(byte[] targetIp) {
    return targetIp.length != Ip6Address.BYTE_LENGTH ? null : new byte[] { 0x33, 0x33, targetIp[targetIp.length - 4], targetIp[targetIp.length - 3], targetIp[targetIp.length - 2], targetIp[targetIp.length - 1] };
}
#end_block

#method_before
public static Ethernet buildNdpAdv(byte[] srcIp, byte[] srcMac, Ethernet request) {
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(request.getSourceMAC());
    eth.setSourceMACAddress(srcMac);
    eth.setEtherType(Ethernet.TYPE_IPV6);
    eth.setVlanID(request.getVlanID());
    IPv6 requestIp = (IPv6) request.getPayload();
    IPv6 ipv6 = new IPv6();
    ipv6.setSourceAddress(srcIp);
    ipv6.setDestinationAddress(requestIp.getSourceAddress());
    ipv6.setHopLimit((byte) 255);
    ICMP6 icmp6 = new ICMP6();
    icmp6.setIcmpType(ICMP6.NEIGHBOR_ADVERTISEMENT);
    icmp6.setIcmpCode((byte) 0);
    NeighborAdvertisement nadv = new NeighborAdvertisement();
    nadv.setTargetAddress(srcIp);
    nadv.setSolicitedFlag((byte) 1);
    nadv.setOverrideFlag((byte) 1);
    nadv.addOption(NeighborDiscoveryOptions.TYPE_TARGET_LL_ADDRESS, srcMac);
    icmp6.setPayload(nadv);
    ipv6.setPayload(icmp6);
    eth.setPayload(ipv6);
    return eth;
}
#method_after
public static Ethernet buildNdpAdv(byte[] srcIp, byte[] srcMac, Ethernet request) {
    if (srcIp.length != Ip6Address.BYTE_LENGTH || srcMac.length != MacAddress.MAC_ADDRESS_LENGTH) {
        return null;
    }
    if (request.getEtherType() != Ethernet.TYPE_IPV6) {
        return null;
    }
    IPv6 ipv6Request = (IPv6) request.getPayload();
    if (ipv6Request.getNextHeader() != IPv6.PROTOCOL_ICMP6) {
        return null;
    }
    ICMP6 icmpv6 = (ICMP6) ipv6Request.getPayload();
    if (icmpv6.getIcmpType() != ICMP6.NEIGHBOR_SOLICITATION) {
        return null;
    }
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(request.getSourceMAC());
    eth.setSourceMACAddress(srcMac);
    eth.setEtherType(Ethernet.TYPE_IPV6);
    eth.setVlanID(request.getVlanID());
    IPv6 ipv6 = new IPv6();
    ipv6.setSourceAddress(srcIp);
    ipv6.setDestinationAddress(ipv6Request.getSourceAddress());
    ipv6.setHopLimit((byte) 255);
    ICMP6 icmp6 = new ICMP6();
    icmp6.setIcmpType(ICMP6.NEIGHBOR_ADVERTISEMENT);
    icmp6.setIcmpCode((byte) 0);
    NeighborAdvertisement nadv = new NeighborAdvertisement();
    nadv.setTargetAddress(srcIp);
    nadv.setSolicitedFlag((byte) 1);
    nadv.setOverrideFlag((byte) 1);
    nadv.addOption(NeighborDiscoveryOptions.TYPE_TARGET_LL_ADDRESS, srcMac);
    icmp6.setPayload(nadv);
    ipv6.setPayload(icmp6);
    eth.setPayload(ipv6);
    return eth;
}
#end_block

#method_before
private void sendProbe(ConnectPoint connectPoint, IpAddress targetIp, IpAddress sourceIp, MacAddress sourceMac, VlanId vlan) {
    Ethernet probePacket = null;
    if (targetIp.isIp4()) {
        // IPv4: Use ARP
        probePacket = buildArpRequest(targetIp, sourceIp, sourceMac, vlan);
    } else {
        /*
             * IPv6: Use Neighbor Discovery. According to the NDP protocol,
             * we should use the solicitation node address as IPv6 destination
             * and the multicast mac address as Ethernet destination.
             */
        byte[] destIp = IPv6.solicitationNodeAddress(targetIp.toOctets());
        probePacket = NeighborSolicitation.buildNdpSolicit(targetIp.toOctets(), sourceIp.toOctets(), destIp, sourceMac.toBytes(), IPv6.multicastMacAddress(destIp), vlan);
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(connectPoint.port()).build();
    OutboundPacket outboundPacket = new DefaultOutboundPacket(connectPoint.deviceId(), treatment, ByteBuffer.wrap(probePacket.serialize()));
    packetService.emit(outboundPacket);
}
#method_after
private void sendProbe(ConnectPoint connectPoint, IpAddress targetIp, IpAddress sourceIp, MacAddress sourceMac, VlanId vlan) {
    Ethernet probePacket;
    if (targetIp.isIp4()) {
        // IPv4: Use ARP
        probePacket = buildArpRequest(targetIp, sourceIp, sourceMac, vlan);
    } else {
        /*
             * IPv6: Use Neighbor Discovery. According to the NDP protocol,
             * we should use the solicitation node address as IPv6 destination
             * and the multicast mac address as Ethernet destination.
             */
        byte[] destIp = IPv6.solicitationNodeAddress(targetIp.toOctets());
        probePacket = NeighborSolicitation.buildNdpSolicit(targetIp.toOctets(), sourceIp.toOctets(), destIp, sourceMac.toBytes(), IPv6.multicastMacAddress(destIp), vlan);
    }
    if (probePacket == null) {
        log.warn("Not able to build the probe packet");
        return;
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(connectPoint.port()).build();
    OutboundPacket outboundPacket = new DefaultOutboundPacket(connectPoint.deviceId(), treatment, ByteBuffer.wrap(probePacket.serialize()));
    packetService.emit(outboundPacket);
}
#end_block

#method_before
public static Ethernet buildArpRequest(byte[] senderMacAddress, byte[] senderIpAddress, byte[] targetAddress, short vlanId) {
    ARP arpRequest = new ARP();
    arpRequest.setHardwareType(ARP.HW_TYPE_ETHERNET).setProtocolType(ARP.PROTO_TYPE_IP).setHardwareAddressLength((byte) Ethernet.DATALAYER_ADDRESS_LENGTH).setProtocolAddressLength((byte) Ip4Address.BYTE_LENGTH).setOpCode(ARP.OP_REQUEST).setSenderHardwareAddress(senderMacAddress).setTargetHardwareAddress(MacAddress.ZERO.toBytes()).setSenderProtocolAddress(senderIpAddress).setTargetProtocolAddress(targetAddress);
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(MacAddress.BROADCAST.toBytes()).setSourceMACAddress(senderMacAddress).setEtherType(Ethernet.TYPE_ARP).setVlanID(vlanId).setPayload(arpRequest);
    return eth;
}
#method_after
public static Ethernet buildArpRequest(byte[] senderMacAddress, byte[] senderIpAddress, byte[] targetAddress, short vlanId) {
    if (senderMacAddress.length != MacAddress.MAC_ADDRESS_LENGTH || senderIpAddress.length != Ip4Address.BYTE_LENGTH || targetAddress.length != Ip4Address.BYTE_LENGTH) {
        return null;
    }
    ARP arpRequest = new ARP();
    arpRequest.setHardwareType(ARP.HW_TYPE_ETHERNET).setProtocolType(ARP.PROTO_TYPE_IP).setHardwareAddressLength((byte) Ethernet.DATALAYER_ADDRESS_LENGTH).setProtocolAddressLength((byte) Ip4Address.BYTE_LENGTH).setOpCode(ARP.OP_REQUEST).setSenderHardwareAddress(senderMacAddress).setTargetHardwareAddress(MacAddress.ZERO.toBytes()).setSenderProtocolAddress(senderIpAddress).setTargetProtocolAddress(targetAddress);
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(MacAddress.BROADCAST.toBytes()).setSourceMACAddress(senderMacAddress).setEtherType(Ethernet.TYPE_ARP).setVlanID(vlanId).setPayload(arpRequest);
    return eth;
}
#end_block

#method_before
public static Ethernet buildIcmpReply(Ethernet ethRequest) {
    Ethernet ethReply = new Ethernet();
    IPv4 ipRequest = (IPv4) ethRequest.getPayload();
    IPv4 ipReply = new IPv4();
    int destAddress = ipRequest.getDestinationAddress();
    ipReply.setDestinationAddress(ipRequest.getSourceAddress());
    ipReply.setSourceAddress(destAddress);
    ipReply.setTtl((byte) 64);
    ipReply.setChecksum((short) 0);
    ICMP icmpRequest = (ICMP) ipRequest.getPayload();
    ICMP icmpReply = new ICMP();
    icmpReply.setPayload(icmpRequest.getPayload());
    icmpReply.setIcmpType(ICMP.TYPE_ECHO_REPLY);
    icmpReply.setIcmpCode(ICMP.SUBTYPE_ECHO_REPLY);
    icmpReply.setChecksum((short) 0);
    ipReply.setPayload(icmpReply);
    ethReply.setEtherType(Ethernet.TYPE_IPV4);
    ethReply.setVlanID(ethRequest.getVlanID());
    ethReply.setDestinationMACAddress(ethRequest.getSourceMACAddress());
    ethReply.setSourceMACAddress(ethRequest.getDestinationMACAddress());
    ethReply.setPayload(ipReply);
    return ethReply;
}
#method_after
public static Ethernet buildIcmpReply(Ethernet ethRequest) {
    if (ethRequest.getEtherType() != Ethernet.TYPE_IPV4) {
        return null;
    }
    IPv4 ipRequest = (IPv4) ethRequest.getPayload();
    if (ipRequest.getProtocol() != IPv4.PROTOCOL_ICMP) {
        return null;
    }
    Ethernet ethReply = new Ethernet();
    IPv4 ipReply = new IPv4();
    int destAddress = ipRequest.getDestinationAddress();
    ipReply.setDestinationAddress(ipRequest.getSourceAddress());
    ipReply.setSourceAddress(destAddress);
    ipReply.setTtl((byte) 64);
    ipReply.setChecksum((short) 0);
    ipReply.setProtocol(IPv4.PROTOCOL_ICMP);
    ICMP icmpRequest = (ICMP) ipRequest.getPayload();
    ICMP icmpReply = new ICMP();
    icmpReply.setPayload(icmpRequest.getPayload());
    icmpReply.setIcmpType(ICMP.TYPE_ECHO_REPLY);
    icmpReply.setIcmpCode(ICMP.SUBTYPE_ECHO_REPLY);
    icmpReply.setChecksum((short) 0);
    ipReply.setPayload(icmpReply);
    ethReply.setEtherType(Ethernet.TYPE_IPV4);
    ethReply.setVlanID(ethRequest.getVlanID());
    ethReply.setDestinationMACAddress(ethRequest.getSourceMACAddress());
    ethReply.setSourceMACAddress(ethRequest.getDestinationMACAddress());
    ethReply.setPayload(ipReply);
    return ethReply;
}
#end_block

#method_before
public static Ethernet buildNdpSolicit(byte[] targetIp, byte[] sourceIp, byte[] destinationIp, byte[] sourceMac, byte[] destinationMac, VlanId vlan) {
    /*
         * Here we craft the Ethernet packet.
         */
    Ethernet ethernet = new Ethernet();
    ethernet.setEtherType(Ethernet.TYPE_IPV6).setDestinationMACAddress(destinationMac).setSourceMACAddress(sourceMac);
    ethernet.setVlanID(vlan.id());
    /*
         * IPv6 packet is created.
         */
    IPv6 ipv6 = new IPv6();
    ipv6.setSourceAddress(sourceIp);
    ipv6.setDestinationAddress(destinationIp);
    ipv6.setHopLimit((byte) 255);
    /*
         * Create the ICMPv6 packet.
         */
    ICMP6 icmp6 = new ICMP6();
    icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);
    icmp6.setIcmpCode((byte) 0);
    /*
         * Create the Neighbor Solicitation packet.
         */
    NeighborSolicitation ns = new NeighborSolicitation();
    ns.setTargetAddress(targetIp);
    ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);
    /*
         * Set the payloads
         */
    icmp6.setPayload(ns);
    ipv6.setPayload(icmp6);
    ethernet.setPayload(ipv6);
    return ethernet;
}
#method_after
public static Ethernet buildNdpSolicit(byte[] targetIp, byte[] sourceIp, byte[] destinationIp, byte[] sourceMac, byte[] destinationMac, VlanId vlan) {
    if (targetIp.length != Ip6Address.BYTE_LENGTH || sourceIp.length != Ip6Address.BYTE_LENGTH || destinationIp.length != Ip6Address.BYTE_LENGTH || sourceMac.length != MacAddress.MAC_ADDRESS_LENGTH || destinationMac.length != MacAddress.MAC_ADDRESS_LENGTH) {
        return null;
    }
    /*
         * Here we craft the Ethernet packet.
         */
    Ethernet ethernet = new Ethernet();
    ethernet.setEtherType(Ethernet.TYPE_IPV6).setDestinationMACAddress(destinationMac).setSourceMACAddress(sourceMac);
    ethernet.setVlanID(vlan.id());
    /*
         * IPv6 packet is created.
         */
    IPv6 ipv6 = new IPv6();
    ipv6.setSourceAddress(sourceIp);
    ipv6.setDestinationAddress(destinationIp);
    ipv6.setHopLimit((byte) 255);
    /*
         * Create the ICMPv6 packet.
         */
    ICMP6 icmp6 = new ICMP6();
    icmp6.setIcmpType(ICMP6.NEIGHBOR_SOLICITATION);
    icmp6.setIcmpCode((byte) 0);
    /*
         * Create the Neighbor Solicitation packet.
         */
    NeighborSolicitation ns = new NeighborSolicitation();
    ns.setTargetAddress(targetIp);
    ns.addOption(NeighborDiscoveryOptions.TYPE_SOURCE_LL_ADDRESS, sourceMac);
    /*
         * Set the payloads
         */
    icmp6.setPayload(ns);
    ipv6.setPayload(icmp6);
    ethernet.setPayload(ipv6);
    return ethernet;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    UserRoleKey other = (UserRoleKey) obj;
    if (!Objects.equals(roleName, other.roleName)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    UserRoleKey other = (UserRoleKey) obj;
    return Objects.equals(roleName, other.roleName);
}
#end_block

#method_before
@Override
public int hashCode() {
    if (hashValid) {
        return hash;
    }
    int prime = 31;
    int result = 1;
    result = prime * result + Objects.hashCode(userRole);
    result = prime * result + Objects.hashCode(augmentation);
    hash = result;
    hashValid = true;
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(userRoles, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    UserRoles other = (UserRoles) obj;
    if (!Objects.equals(userRole, other.getUserRole())) {
        return false;
    }
    if (getClass() == obj.getClass()) {
        UserRolesImpl otherImpl = (UserRolesImpl) obj;
        if (!Objects.equals(augmentation, otherImpl.augmentation)) {
            return false;
        }
    } else {
        if (!obj.equals(this)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    UserRoles other = (UserRoles) obj;
    if (!Objects.equals(userRoles, other.getUserRoles())) {
        return false;
    }
    UserRolesImpl otherImpl = (UserRolesImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder("UserRoles [");
    boolean first = true;
    if (userRole != null) {
        if (first) {
            first = false;
        } else {
            builder.append(", ");
        }
        builder.append("userRole=");
        builder.append(userRole);
    }
    if (first) {
        first = false;
    } else {
        builder.append(", ");
    }
    builder.append("augmentation=");
    builder.append(augmentation.values());
    return builder.append(']').toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("user roles", userRoles).add("augmentation", augmentation).toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    if (hashValid) {
        return hash;
    }
    final int prime = 31;
    int result = 1;
    result = prime * result + Objects.hashCode(key);
    result = prime * result + Objects.hashCode(roleDescription);
    result = prime * result + Objects.hashCode(roleName);
    result = prime * result + Objects.hashCode(augmentation);
    hash = result;
    hashValid = true;
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(key, roleDescription, roleName, augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder("UserRole [");
    boolean first = true;
    if (key != null) {
        if (first) {
            first = false;
        } else {
            builder.append(", ");
        }
        builder.append("key=");
        builder.append(key);
    }
    if (roleDescription != null) {
        if (first) {
            first = false;
        } else {
            builder.append(", ");
        }
        builder.append("roleDescription=");
        builder.append(roleDescription);
    }
    if (roleName != null) {
        if (first) {
            first = false;
        } else {
            builder.append(", ");
        }
        builder.append("roleName=");
        builder.append(roleName);
    }
    if (first) {
        first = false;
    } else {
        builder.append(", ");
    }
    builder.append("augmentation=");
    builder.append(augmentation.values());
    return builder.append(']').toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("key", key).add("role description", roleDescription).add("role name", roleName).add("augmentation", augmentation).toString();
}
#end_block

#method_before
public ActionDefinitionBuilder parameterValueType(ActionDefinition.ParameterValueType type) {
    parameterValueType = type;
    return this;
}
#method_after
public ActionDefinitionBuilder parameterValueType(ActionDefinition.ParameterValueType type) {
    pvType = type;
    return this;
}
#end_block

#method_before
@Test
public void buildConditionParameterDefinitionWithParameterDefinitions() {
    definitionList = new ArrayList<>();
    definitions = new ConditionParameterDefinitionsBuilder().conditionParameterDefinitions(definitionList).build();
    assertEquals(DEFINITIONS_ERROR_MSG, definitionList, definitions.getConditionParameterDefinitions());
}
#method_after
@Test
public void buildConditionParameterDefinitionWithParameterDefinitions() {
    definitionList = new ArrayList<>();
    definitions = new ConditionParameterDefinitionsBuilder().conditionParameterDefinitions(definitionList).build();
    assertEquals(DEFINITIONS_ERROR_MSG, definitionList, definitions.getDefinitions());
}
#end_block

#method_before
@Test
public void fromConditionParameterDefinitionWithParameterDefinitions() {
    definitionList = new ArrayList<>();
    definitions = new ConditionParameterDefinitionsBuilder().conditionParameterDefinitions(definitionList).build();
    copy = new ConditionParameterDefinitionsBuilder(definitions).build();
    assertEquals(DEFINITIONS_ERROR_MSG, definitionList, copy.getConditionParameterDefinitions());
}
#method_after
@Test
public void fromConditionParameterDefinitionWithParameterDefinitions() {
    definitionList = new ArrayList<>();
    definitions = new ConditionParameterDefinitionsBuilder().conditionParameterDefinitions(definitionList).build();
    copy = new ConditionParameterDefinitionsBuilder(definitions).build();
    assertEquals(DEFINITIONS_ERROR_MSG, definitionList, copy.getDefinitions());
}
#end_block

#method_before
@Test
public void buildActionDefinitionWithActionDefinitionKey() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    listParam = new ActionDefinitionBuilder().key(key).build();
    def = new ActionDefinitionBuilder().key(key).parameterValueType(type).addAugmentation(ActionDefinition.class, listParam).build();
    def = new ActionDefinitionBuilder(def).addAugmentation(ActionDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getActionName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void buildActionDefinitionWithActionDefinitionKey() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    listParam = new ActionDefinitionBuilder().key(key).build();
    def = new ActionDefinitionBuilder().key(key).parameterValueType(type).addAugmentation(ActionDefinition.class, listParam).build();
    def = new ActionDefinitionBuilder(def).addAugmentation(ActionDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getActionName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@Test
public void buildActionDefinitionWithActionName() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    listParam = new ActionDefinitionBuilder().actionName(name).build();
    def = new ActionDefinitionBuilder().parameterValueType(type).actionName(name).addAugmentation(ActionDefinition.class, listParam).build();
    def = new ActionDefinitionBuilder(def).addAugmentation(ActionDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getActionName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void buildActionDefinitionWithActionName() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    listParam = new ActionDefinitionBuilder().actionName(name).build();
    def = new ActionDefinitionBuilder().parameterValueType(type).actionName(name).addAugmentation(ActionDefinition.class, listParam).build();
    def = new ActionDefinitionBuilder(def).addAugmentation(ActionDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getActionName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@Test
public void fromActionWithActionKey() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    def = new ActionDefinitionBuilder().parameterValueType(type).key(key).build();
    copy = new ActionDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getActionName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void fromActionWithActionKey() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    def = new ActionDefinitionBuilder().parameterValueType(type).key(key).build();
    copy = new ActionDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getActionName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@Test
public void fromActionWithActionName() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    def = new ActionDefinitionBuilder().parameterValueType(type).actionName(name).build();
    copy = new ActionDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getActionName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void fromActionWithActionName() {
    name = new ActionName(NAME);
    key = new ActionDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    def = new ActionDefinitionBuilder().parameterValueType(type).actionName(name).build();
    copy = new ActionDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getActionName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ConditionParameterDefinitions other = (ConditionParameterDefinitions) obj;
    if (!Objects.equals(conditionParameterDefinition, other.getConditionParameterDefinitions())) {
        return false;
    }
    ConditionParameterDefinitionsImpl otherImpl = (ConditionParameterDefinitionsImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ConditionParameterDefinitions other = (ConditionParameterDefinitions) obj;
    if (!Objects.equals(conditionParameterDefinition, other.getDefinitions())) {
        return false;
    }
    ConditionParameterDefinitionsImpl otherImpl = (ConditionParameterDefinitionsImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#end_block

#method_before
public ConditionParameterDefinitionBuilder removeAugmentation(Class<? extends ConditionParameterDefinition> augmentationType) {
    this.augmentation.remove(augmentationType);
    return this;
}
#method_after
public ConditionParameterDefinitionBuilder removeAugmentation(Class<? extends ConditionParameterDefinition> augmentationType) {
    augmentation.remove(augmentationType);
    return this;
}
#end_block

#method_before
@Test
public void buildConditionParameterDefinitionWithParameterDefinitionKey() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    listParam = new ConditionParameterDefinitionBuilder().key(key).parameterValueType(type).build();
    def = new ConditionParameterDefinitionBuilder().key(key).parameterValueType(type).addAugmentation(ConditionParameterDefinition.class, listParam).build();
    def = new ConditionParameterDefinitionBuilder(def).addAugmentation(ConditionParameterDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void buildConditionParameterDefinitionWithParameterDefinitionKey() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    listParam = new ConditionParameterDefinitionBuilder().key(key).parameterValueType(type).build();
    def = new ConditionParameterDefinitionBuilder().key(key).parameterValueType(type).addAugmentation(ConditionParameterDefinition.class, listParam).build();
    def = new ConditionParameterDefinitionBuilder(def).addAugmentation(ConditionParameterDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@Test
public void buildConditionParameterDefinitionWithParameterName() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    listParam = new ConditionParameterDefinitionBuilder().key(key).build();
    def = new ConditionParameterDefinitionBuilder().parameterName(name).parameterValueType(type).addAugmentation(ConditionParameterDefinition.class, listParam).build();
    def = new ConditionParameterDefinitionBuilder(def).addAugmentation(ConditionParameterDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void buildConditionParameterDefinitionWithParameterName() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    listParam = new ConditionParameterDefinitionBuilder().key(key).build();
    def = new ConditionParameterDefinitionBuilder().parameterName(name).parameterValueType(type).addAugmentation(ConditionParameterDefinition.class, listParam).build();
    def = new ConditionParameterDefinitionBuilder(def).addAugmentation(ConditionParameterDefinition.class, null).build();
    assertEquals(NAME_ERROR_MSG, name, def.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, def.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@Test
public void fromConditionParameterDefinitionWithParameterDefinitionKey() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    def = new ConditionParameterDefinitionBuilder().key(key).parameterValueType(type).build();
    copy = new ConditionParameterDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void fromConditionParameterDefinitionWithParameterDefinitionKey() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    def = new ConditionParameterDefinitionBuilder().key(key).parameterValueType(type).build();
    copy = new ConditionParameterDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@Test
public void fromConditionParameterWithParameterName() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(0);
    def = new ConditionParameterDefinitionBuilder().parameterName(name).parameterValueType(type).build();
    copy = new ConditionParameterDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#method_after
@Test
public void fromConditionParameterWithParameterName() {
    name = new ParameterName(NAME);
    key = new ConditionParameterDefinitionKey(name);
    type = ParameterValueType.forValue(PARAMETER_VALUE_TYPE_VALID);
    def = new ConditionParameterDefinitionBuilder().parameterName(name).parameterValueType(type).build();
    copy = new ConditionParameterDefinitionBuilder(def).build();
    assertEquals(NAME_ERROR_MSG, name, copy.getParameterName());
    assertEquals(KEY_ERROR_MSG, key, copy.getKey());
    assertEquals(TYPE_ERROR_MSG, type, def.getParameterValueType());
}
#end_block

#method_before
@DELETE
@Path("{mac}/{vlan}")
@Produces(MediaType.APPLICATION_JSON)
public Response removeHost(@PathParam("mac") String mac, @PathParam("vlan") String vlan) {
    Host host = nullIsNotFound(get(HostAdminService.class).getHost(hostId(mac + "/" + vlan)), HOST_NOT_FOUND);
    return ok(codec(Host.class).encode(host, this)).build();
}
#method_after
@DELETE
@Path("{mac}/{vlan}")
@Produces(MediaType.APPLICATION_JSON)
public Response removeHost(@PathParam("mac") String mac, @PathParam("vlan") String vlan) {
    get(HostAdminService.class).removeHost(hostId(mac + "/" + vlan));
    return Response.noContent().build();
}
#end_block

#method_before
@Activate
protected void activate() {
    opticalPathService.addListener(opticalEventListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
}
#method_after
@Activate
protected void activate() {
    opticalPathService.addListener(opticalEventListener);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    opticalPathService.removeListener(opticalEventListener);
    factories.forEach(cfgRegistry::unregisterConfigFactory);
}
#method_after
@Deactivate
protected void deactivate() {
    opticalPathService.removeListener(opticalEventListener);
}
#end_block

#method_before
@Override
public void event(OpticalPathEvent event) {
    log.info("KK: Received {} event!", event.type());
    switch(event.type()) {
        case PATH_INSTALLED:
        case PATH_REMOVED:
            log.info("Optical path event {} received for {}.", event.type(), event.subject());
            opticalConnectStatusMap.put(event.subject(), event.type());
            break;
        default:
            log.error("Unexpected optical event type.");
            break;
    }
}
#method_after
@Override
public void event(OpticalPathEvent event) {
    switch(event.type()) {
        case PATH_INSTALLED:
        case PATH_REMOVED:
            log.info("Optical path event {} received for {}.", event.type(), event.subject());
            opticalConnectStatusMap.put(event.subject(), event.type());
            break;
        default:
            log.error("Unexpected optical event type.");
            break;
    }
}
#end_block

#method_before
private void displayNodes() {
    try {
        int counter = 0;
        print("Total number of entries = %s", nodeTreeMap.size());
        for (BgpNodeLSIdentifier nodes : nodekeySet) {
            if (numberofentries > nodeTreeMap.size() || numberofentries < 0) {
                System.out.print("Wrong Argument");
                break;
            } else if (counter < numberofentries) {
                pathAttrNlriDetailsLocalRib = nodeTreeMap.get(nodes);
                displayNode();
                counter++;
            } else if (counter == 0) {
                pathAttrNlriDetailsLocalRib = nodeTreeMap.get(nodes);
                displayNode();
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Nodes: {}", e.getMessage());
    }
}
#method_after
private void displayNodes() {
    try {
        int counter = 0;
        print("Total number of entries = %s", nodeTreeMap.size());
        for (BgpNodeLSIdentifier nodes : nodekeySet) {
            if (numberofentries > nodeTreeMap.size() || numberofentries < 0) {
                System.out.print("Wrong Argument");
                break;
            } else if (counter < numberofentries) {
                pathAttrNlriDetailsLocalRib = nodeTreeMap.get(nodes);
                displayNode();
                counter++;
            } else if (counter == 0) {
                pathAttrNlriDetailsLocalRib = nodeTreeMap.get(nodes);
                displayNode();
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP nodes: {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayLinks() {
    try {
        int counter = 0;
        print("Total Number of entries = %d", linkTreeMap.size());
        for (BgpLinkLSIdentifier links : linkkeySet) {
            if (numberofentries > linkTreeMap.size() || numberofentries < 0) {
                System.out.print("Wrong Argument");
                break;
            } else if (counter < numberofentries) {
                pathAttrNlriDetailsLocalRib = linkTreeMap.get(links);
                print("Total number of entries = %d", linkTreeMap.size());
                displayLink();
                counter++;
            } else if (counter == 0) {
                pathAttrNlriDetailsLocalRib = linkTreeMap.get(links);
                displayLink();
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Links: {}", e.getMessage());
    }
}
#method_after
private void displayLinks() {
    try {
        int counter = 0;
        print("Total Number of entries = %d", linkTreeMap.size());
        for (BgpLinkLSIdentifier links : linkkeySet) {
            if (numberofentries > linkTreeMap.size() || numberofentries < 0) {
                System.out.print("Wrong Argument");
                break;
            } else if (counter < numberofentries) {
                pathAttrNlriDetailsLocalRib = linkTreeMap.get(links);
                print("Total number of entries = %d", linkTreeMap.size());
                displayLink();
                counter++;
            } else if (counter == 0) {
                pathAttrNlriDetailsLocalRib = linkTreeMap.get(links);
                displayLink();
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP links: {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayPrefix() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<BgpPrefixLSIdentifier, PathAttrNlriDetailsLocalRib> prefixmap = bgpLocalRib.prefixTree();
        Set<BgpPrefixLSIdentifier> prefixkeySet = prefixmap.keySet();
        for (BgpPrefixLSIdentifier prefix : prefixkeySet) {
            pathAttrNlriDetailsLocalRib = prefixmap.get(prefix);
            pathAttrNlriDetails = pathAttrNlriDetailsLocalRib.localRibNlridetails();
            print("No of entries = %d", prefixmap.size());
            System.out.print(pathAttrNlriDetailsLocalRib.toString());
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Prefixes: {}", e.getMessage());
    }
}
#method_after
private void displayPrefix() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<BgpPrefixLSIdentifier, PathAttrNlriDetailsLocalRib> prefixmap = bgpLocalRib.prefixTree();
        Set<BgpPrefixLSIdentifier> prefixkeySet = prefixmap.keySet();
        for (BgpPrefixLSIdentifier prefix : prefixkeySet) {
            pathAttrNlriDetailsLocalRib = prefixmap.get(prefix);
            pathAttrNlriDetails = pathAttrNlriDetailsLocalRib.localRibNlridetails();
            print("No of entries = %d", prefixmap.size());
            System.out.print(pathAttrNlriDetailsLocalRib.toString());
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP prefixes: {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayVpnNodes() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<RouteDistinguisher, Map<BgpNodeLSIdentifier, PathAttrNlriDetailsLocalRib>> vpnNode = bgpLocalRib.vpnNodeTree();
        Set<RouteDistinguisher> vpnNodekeySet = vpnNode.keySet();
        for (RouteDistinguisher vpnNodes : vpnNodekeySet) {
            boolean invalidProcess = true;
            if (vpnId != null && vpnId.trim().equals(vpnNodes.hashCode())) {
                invalidProcess = false;
                displayNodes();
            }
            if (invalidProcess) {
                print("%s\n", "Id " + vpnId + "does not exist...!!!");
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Nodes based on Vpn : {}", e.getMessage());
    }
}
#method_after
private void displayVpnNodes() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<RouteDistinguisher, Map<BgpNodeLSIdentifier, PathAttrNlriDetailsLocalRib>> vpnNode = bgpLocalRib.vpnNodeTree();
        Set<RouteDistinguisher> vpnNodekeySet = vpnNode.keySet();
        for (RouteDistinguisher vpnNodes : vpnNodekeySet) {
            boolean invalidProcess = true;
            if (vpnId != null && vpnId.trim().equals(vpnNodes.hashCode())) {
                invalidProcess = false;
                displayNodes();
            }
            if (invalidProcess) {
                print("%s\n", "Id " + vpnId + "does not exist...!!!");
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP nodes based on VPN : {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayVpnLinks() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<RouteDistinguisher, Map<BgpLinkLSIdentifier, PathAttrNlriDetailsLocalRib>> vpnLink = bgpLocalRib.vpnLinkTree();
        Set<RouteDistinguisher> vpnLinkkeySet = vpnLink.keySet();
        for (RouteDistinguisher vpnLinks : vpnLinkkeySet) {
            boolean invalidProcess = true;
            if (vpnId != null && vpnId.trim().equals(vpnLinks.hashCode())) {
                invalidProcess = false;
                displayLinks();
            }
            if (invalidProcess) {
                print("%s\n", "Id " + vpnId + "does not exist...!!!");
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Links based on Vpn : {}", e.getMessage());
    }
}
#method_after
private void displayVpnLinks() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<RouteDistinguisher, Map<BgpLinkLSIdentifier, PathAttrNlriDetailsLocalRib>> vpnLink = bgpLocalRib.vpnLinkTree();
        Set<RouteDistinguisher> vpnLinkkeySet = vpnLink.keySet();
        for (RouteDistinguisher vpnLinks : vpnLinkkeySet) {
            boolean invalidProcess = true;
            if (vpnId != null && vpnId.trim().equals(vpnLinks.hashCode())) {
                invalidProcess = false;
                displayLinks();
            }
            if (invalidProcess) {
                print("%s\n", "Id " + vpnId + "does not exist...!!!");
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP links based on VPN : {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayVpnPrefix() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<RouteDistinguisher, Map<BgpPrefixLSIdentifier, PathAttrNlriDetailsLocalRib>> vpnPrefix = bgpLocalRib.vpnPrefixTree();
        Set<RouteDistinguisher> vpnPrefixkeySet = vpnPrefix.keySet();
        for (RouteDistinguisher vpnprefixId : vpnPrefixkeySet) {
            boolean invalidProcess = true;
            if (vpnId != null && vpnId.trim().equals(vpnprefixId.hashCode())) {
                invalidProcess = false;
                displayPrefix();
            }
            if (invalidProcess) {
                print("%s\n", "Id " + vpnId + "does not exist...!!!");
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Prefixes based on Vpn : {}", e.getMessage());
    }
}
#method_after
private void displayVpnPrefix() {
    try {
        this.bgpController = get(BgpController.class);
        bgpLocalRib = bgpController.bgpLocalRib();
        Map<RouteDistinguisher, Map<BgpPrefixLSIdentifier, PathAttrNlriDetailsLocalRib>> vpnPrefix = bgpLocalRib.vpnPrefixTree();
        Set<RouteDistinguisher> vpnPrefixkeySet = vpnPrefix.keySet();
        for (RouteDistinguisher vpnprefixId : vpnPrefixkeySet) {
            boolean invalidProcess = true;
            if (vpnId != null && vpnId.trim().equals(vpnprefixId.hashCode())) {
                invalidProcess = false;
                displayPrefix();
            }
            if (invalidProcess) {
                print("%s\n", "Id " + vpnId + "does not exist...!!!");
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP prefixes based on VPN : {}", e.getMessage());
    }
}
#end_block

#method_before
@Override
public void run() {
    log.debug("Connect to peer {}", peerHost);
    InetSocketAddress connectToSocket = new InetSocketAddress(peerHost, peerPort);
    try {
        bgpconfig.setPeerConnState(peerHost, BgpPeerCfg.State.CONNECT);
        peerBootstrap.connect(connectToSocket).addListener(new ChannelFutureListener() {

            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    bgpconfig.setPeerConnState(peerHost, BgpPeerCfg.State.ACTIVE);
                    connectRetryCounter++;
                    log.error("Connection failed, ConnectRetryCounter {} remote host {}", connectRetryCounter, peerHost);
                    /*
                             * Reconnect to peer on failure is exponential till 4 mins, later on retry after every 4
                             * mins.
                             */
                    if (connectRetryTime < RETRY_INTERVAL) {
                        connectRetryTime = (connectRetryTime != 0) ? connectRetryTime * 2 : 1;
                    }
                    scheduleConnectionRetry(connectRetryTime);
                } else {
                    connectRetryCounter++;
                    log.info("Connected to remote host {}, Connect Counter {}", peerHost, connectRetryCounter);
                    disconnectPeer();
                    return;
                }
            }
        });
    } catch (Exception e) {
        log.info("Connect peer exception : " + e.toString());
        disconnectPeer();
    }
}
#method_after
@Override
public void run() {
    log.debug("Connect to peer {}", peerHost);
    InetSocketAddress connectToSocket = new InetSocketAddress(peerHost, peerPort);
    try {
        bgpconfig.setPeerConnState(peerHost, BgpPeerCfg.State.CONNECT);
        peerBootstrap.connect(connectToSocket).addListener(new ChannelFutureListener() {

            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    bgpconfig.setPeerConnState(peerHost, BgpPeerCfg.State.ACTIVE);
                    connectRetryCounter++;
                    log.error("Connection failed, ConnectRetryCounter {} remote host {}", connectRetryCounter, peerHost);
                    /*
                             * Reconnect to peer on failure is exponential till 4 mins, later on retry after every 4
                             * mins.
                             */
                    if (connectRetryTime < RETRY_INTERVAL) {
                        connectRetryTime = (connectRetryTime != 0) ? connectRetryTime * 2 : 1;
                    }
                    scheduleConnectionRetry(connectRetryTime);
                } else {
                    connectRetryCounter++;
                    log.debug("Connected to remote host {}, Connect Counter {}", peerHost, connectRetryCounter);
                    disconnectPeer();
                    return;
                }
            }
        });
    } catch (Exception e) {
        log.debug("Connect peer exception : " + e.toString());
        disconnectPeer();
    }
}
#end_block

#method_before
private void displayActiveSessionException() {
    try {
        this.bgpController = get(BgpController.class);
        Map<String, List<String>> activeSessionExceptionMap = bgpController.activeSessionMap();
        activeSessionExceptionkeySet = activeSessionExceptionMap.keySet();
        if (activeSessionExceptionkeySet.size() > 0) {
            if (peerId != null) {
                if (activeSessionExceptionkeySet.contains(peerId)) {
                    for (String peerIdKey : activeSessionExceptionkeySet) {
                        List activeSessionExceptionlist = activeSessionExceptionMap.get(peerIdKey);
                        System.out.println(activeSessionExceptionlist);
                    }
                } else {
                    System.out.print("Wrong argument");
                }
            } else {
                activeSessionExceptionkeySet = activeSessionExceptionMap.keySet();
                if (activeSessionExceptionkeySet.size() > 0) {
                    for (String peerId : activeSessionExceptionkeySet) {
                        print("PeerId = %s, Exception = %s ", peerId, activeSessionExceptionMap.get(peerId));
                    }
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Exceptions: {}", e.getMessage());
    }
}
#method_after
private void displayActiveSessionException() {
    try {
        this.bgpController = get(BgpController.class);
        Map<String, List<String>> activeSessionExceptionMap = bgpController.activeSessionMap();
        activeSessionExceptionkeySet = activeSessionExceptionMap.keySet();
        if (activeSessionExceptionkeySet.size() > 0) {
            if (peerId != null) {
                if (activeSessionExceptionkeySet.contains(peerId)) {
                    for (String peerIdKey : activeSessionExceptionkeySet) {
                        List activeSessionExceptionlist = activeSessionExceptionMap.get(peerIdKey);
                        System.out.println(activeSessionExceptionlist);
                    }
                } else {
                    System.out.print("Wrong argument");
                }
            } else {
                activeSessionExceptionkeySet = activeSessionExceptionMap.keySet();
                if (activeSessionExceptionkeySet.size() > 0) {
                    for (String peerId : activeSessionExceptionkeySet) {
                        print("PeerId = %s, Exception = %s ", peerId, activeSessionExceptionMap.get(peerId));
                    }
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP exceptions: {}", e.getMessage());
    }
}
#end_block

#method_before
@Override
public void peerErrorMsg(String peerId, Integer errorType, Integer errValue) {
}
#method_after
@Override
public void peerErrorMsg(String peerId, Integer errorType, Integer errValue) {
    return;
}
#end_block

#method_before
public static BgpAttrNodeName read(ChannelBuffer cb) throws BgpParseException {
    byte[] nodeName;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    nodeName = new byte[lsAttrLength];
    cb.readBytes(nodeName);
    log.info("LS attribute node name read");
    return BgpAttrNodeName.of(nodeName);
}
#method_after
public static BgpAttrNodeName read(ChannelBuffer cb) throws BgpParseException {
    byte[] nodeName;
    short lsAttrLength = cb.readShort();
    if (cb.readableBytes() < lsAttrLength) {
        Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.ATTRIBUTE_LENGTH_ERROR, lsAttrLength);
    }
    nodeName = new byte[lsAttrLength];
    cb.readBytes(nodeName);
    log.debug("LS attribute node name read");
    return BgpAttrNodeName.of(nodeName);
}
#end_block

#method_before
public void processUnknownMsg(byte errorCode, byte errorSubCode, byte data) throws BgpParseException, IOException {
    log.debug("UNKNOWN message received");
    byte[] byteArray = new byte[1];
    byteArray[0] = data;
    sendNotification(errorCode, errorSubCode, byteArray);
    channel.close();
}
#method_after
public void processUnknownMsg(byte errorCode, byte errorSubCode, byte data) throws BgpParseException, IOException {
    log.debug("Unknown message received");
    byte[] byteArray = new byte[1];
    byteArray[0] = data;
    sendNotification(errorCode, errorSubCode, byteArray);
    channel.close();
}
#end_block

#method_before
private boolean capabilityValidation(BgpChannelHandler h, BgpOpenMsg openmsg) throws BgpParseException {
    log.debug("capabilityValidation");
    boolean isFourOctetCapabilityExits = false;
    boolean isRpdCapabilityExits = false;
    int capAsNum = 0;
    byte sendReceive = 0;
    List<BgpValueType> capabilityTlv = openmsg.getCapabilityTlv();
    ListIterator<BgpValueType> listIterator = capabilityTlv.listIterator();
    List<BgpValueType> unSupportedCapabilityTlv = new CopyOnWriteArrayList<BgpValueType>();
    ListIterator<BgpValueType> unSupportedCaplistIterator = unSupportedCapabilityTlv.listIterator();
    BgpValueType tempTlv;
    boolean isLargeAsCapabilityCfg = h.bgpconfig.getLargeASCapability();
    boolean isFlowSpecRpdCapabilityCfg = h.bgpconfig.flowSpecRpdCapability();
    boolean isLsCapabilityCfg = h.bgpconfig.getLsCapability();
    boolean isFlowSpecIpv4CapabilityCfg = false;
    boolean isFlowSpecVpnv4CapabilityCfg = false;
    MultiProtocolExtnCapabilityTlv tempCapability;
    boolean isMultiProtocolLsCapability = false;
    boolean isMultiProtocolFlowSpecCapability = false;
    boolean isMultiProtocolVpnFlowSpecCapability = false;
    BgpCfg.FlowSpec flowSpec = h.bgpconfig.flowSpecCapability();
    if (flowSpec == BgpCfg.FlowSpec.IPV4) {
        isFlowSpecIpv4CapabilityCfg = true;
    } else if (flowSpec == BgpCfg.FlowSpec.VPNV4) {
        isFlowSpecVpnv4CapabilityCfg = true;
    } else if (flowSpec == BgpCfg.FlowSpec.IPV4_VPNV4) {
        isFlowSpecIpv4CapabilityCfg = true;
        isFlowSpecVpnv4CapabilityCfg = true;
    }
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv.getType() == MULTI_PROTOCOL_EXTN_CAPA_TYPE) {
            tempCapability = (MultiProtocolExtnCapabilityTlv) tlv;
            if (Constants.SAFI_FLOWSPEC_VALUE == tempCapability.getSafi()) {
                isMultiProtocolFlowSpecCapability = true;
            }
            if (Constants.VPN_SAFI_FLOWSPEC_VALUE == tempCapability.getSafi()) {
                isMultiProtocolVpnFlowSpecCapability = true;
            }
            if (SAFI == tempCapability.getSafi()) {
                isMultiProtocolLsCapability = true;
            }
        }
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
        if (tlv.getType() == RpdCapabilityTlv.TYPE) {
            isRpdCapabilityExits = true;
            sendReceive = ((RpdCapabilityTlv) tlv).sendReceive();
        }
    }
    if (isFourOctetCapabilityExits) {
        if (capAsNum > MAX_AS2_NUM) {
            if (openmsg.getAsNumber() != AS_TRANS) {
                throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.BAD_PEER_AS, null);
            }
        } else {
            if (capAsNum != openmsg.getAsNumber()) {
                throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.BAD_PEER_AS, null);
            }
        }
    }
    if (isRpdCapabilityExits) {
        if (sendReceive > 2) {
            throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_CAPABILITY, null);
        }
    }
    if ((isLsCapabilityCfg)) {
        if (!isMultiProtocolLsCapability) {
            tempTlv = new MultiProtocolExtnCapabilityTlv(AFI, RES, SAFI);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (isFlowSpecIpv4CapabilityCfg) {
        if (!isMultiProtocolFlowSpecCapability) {
            tempTlv = new MultiProtocolExtnCapabilityTlv(Constants.AFI_FLOWSPEC_VALUE, RES, Constants.SAFI_FLOWSPEC_VALUE);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (isFlowSpecVpnv4CapabilityCfg) {
        if (!isMultiProtocolVpnFlowSpecCapability) {
            tempTlv = new MultiProtocolExtnCapabilityTlv(Constants.AFI_FLOWSPEC_VALUE, RES, Constants.VPN_SAFI_FLOWSPEC_VALUE);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if ((isLargeAsCapabilityCfg)) {
        if (!isFourOctetCapabilityExits) {
            tempTlv = new FourOctetAsNumCapabilityTlv(h.bgpconfig.getAsNumber());
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if ((isFlowSpecRpdCapabilityCfg)) {
        if (!isRpdCapabilityExits) {
            tempTlv = new RpdCapabilityTlv(Constants.RPD_CAPABILITY_SEND_VALUE);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (unSupportedCapabilityTlv.size() == MAX_UNSUPPORTED_CAPABILITY) {
        ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
        while (unSupportedCaplistIterator.hasNext()) {
            BgpValueType tlv = unSupportedCaplistIterator.next();
            tlv.write(buffer);
        }
        throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_CAPABILITY, buffer);
    } else {
        return true;
    }
}
#method_after
private boolean capabilityValidation(BgpChannelHandler h, BgpOpenMsg openmsg) throws BgpParseException {
    log.debug("capability validation");
    boolean isFourOctetCapabilityExits = false;
    boolean isRpdCapabilityExits = false;
    int capAsNum = 0;
    byte sendReceive = 0;
    List<BgpValueType> capabilityTlv = openmsg.getCapabilityTlv();
    ListIterator<BgpValueType> listIterator = capabilityTlv.listIterator();
    List<BgpValueType> unSupportedCapabilityTlv = new CopyOnWriteArrayList<BgpValueType>();
    ListIterator<BgpValueType> unSupportedCaplistIterator = unSupportedCapabilityTlv.listIterator();
    BgpValueType tempTlv;
    boolean isLargeAsCapabilityCfg = h.bgpconfig.getLargeASCapability();
    boolean isFlowSpecRpdCapabilityCfg = h.bgpconfig.flowSpecRpdCapability();
    boolean isLsCapabilityCfg = h.bgpconfig.getLsCapability();
    boolean isFlowSpecIpv4CapabilityCfg = false;
    boolean isFlowSpecVpnv4CapabilityCfg = false;
    MultiProtocolExtnCapabilityTlv tempCapability;
    boolean isMultiProtocolLsCapability = false;
    boolean isMultiProtocolFlowSpecCapability = false;
    boolean isMultiProtocolVpnFlowSpecCapability = false;
    BgpCfg.FlowSpec flowSpec = h.bgpconfig.flowSpecCapability();
    if (flowSpec == BgpCfg.FlowSpec.IPV4) {
        isFlowSpecIpv4CapabilityCfg = true;
    } else if (flowSpec == BgpCfg.FlowSpec.VPNV4) {
        isFlowSpecVpnv4CapabilityCfg = true;
    } else if (flowSpec == BgpCfg.FlowSpec.IPV4_VPNV4) {
        isFlowSpecIpv4CapabilityCfg = true;
        isFlowSpecVpnv4CapabilityCfg = true;
    }
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv.getType() == MULTI_PROTOCOL_EXTN_CAPA_TYPE) {
            tempCapability = (MultiProtocolExtnCapabilityTlv) tlv;
            if (Constants.SAFI_FLOWSPEC_VALUE == tempCapability.getSafi()) {
                isMultiProtocolFlowSpecCapability = true;
            }
            if (Constants.VPN_SAFI_FLOWSPEC_VALUE == tempCapability.getSafi()) {
                isMultiProtocolVpnFlowSpecCapability = true;
            }
            if (SAFI == tempCapability.getSafi()) {
                isMultiProtocolLsCapability = true;
            }
        }
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
        if (tlv.getType() == RpdCapabilityTlv.TYPE) {
            isRpdCapabilityExits = true;
            sendReceive = ((RpdCapabilityTlv) tlv).sendReceive();
        }
    }
    if (isFourOctetCapabilityExits) {
        if (capAsNum > MAX_AS2_NUM) {
            if (openmsg.getAsNumber() != AS_TRANS) {
                throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.BAD_PEER_AS, null);
            }
        } else {
            if (capAsNum != openmsg.getAsNumber()) {
                throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.BAD_PEER_AS, null);
            }
        }
    }
    if (isRpdCapabilityExits) {
        if (sendReceive > 2) {
            throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_CAPABILITY, null);
        }
    }
    if ((isLsCapabilityCfg)) {
        if (!isMultiProtocolLsCapability) {
            tempTlv = new MultiProtocolExtnCapabilityTlv(AFI, RES, SAFI);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (isFlowSpecIpv4CapabilityCfg) {
        if (!isMultiProtocolFlowSpecCapability) {
            tempTlv = new MultiProtocolExtnCapabilityTlv(Constants.AFI_FLOWSPEC_VALUE, RES, Constants.SAFI_FLOWSPEC_VALUE);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (isFlowSpecVpnv4CapabilityCfg) {
        if (!isMultiProtocolVpnFlowSpecCapability) {
            tempTlv = new MultiProtocolExtnCapabilityTlv(Constants.AFI_FLOWSPEC_VALUE, RES, Constants.VPN_SAFI_FLOWSPEC_VALUE);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if ((isLargeAsCapabilityCfg)) {
        if (!isFourOctetCapabilityExits) {
            tempTlv = new FourOctetAsNumCapabilityTlv(h.bgpconfig.getAsNumber());
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if ((isFlowSpecRpdCapabilityCfg)) {
        if (!isRpdCapabilityExits) {
            tempTlv = new RpdCapabilityTlv(Constants.RPD_CAPABILITY_SEND_VALUE);
            unSupportedCapabilityTlv.add(tempTlv);
        }
    }
    if (unSupportedCapabilityTlv.size() == MAX_UNSUPPORTED_CAPABILITY) {
        ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
        while (unSupportedCaplistIterator.hasNext()) {
            BgpValueType tlv = unSupportedCaplistIterator.next();
            tlv.write(buffer);
        }
        throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_CAPABILITY, buffer);
    } else {
        return true;
    }
}
#end_block

#method_before
private boolean asNumberValidation(BgpChannelHandler h, BgpOpenMsg openMsg) {
    log.debug("AS Num validation");
    int capAsNum = 0;
    boolean isFourOctetCapabilityExits = false;
    BgpPeerCfg peerCfg = h.bgpconfig.displayPeers(peerAddr);
    List<BgpValueType> capabilityTlv = openMsg.getCapabilityTlv();
    ListIterator<BgpValueType> listIterator = capabilityTlv.listIterator();
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
    }
    if (peerCfg.getAsNumber() > MAX_AS2_NUM) {
        if (openMsg.getAsNumber() != AS_TRANS) {
            return false;
        }
        if (!isFourOctetCapabilityExits) {
            return false;
        }
        if (peerCfg.getAsNumber() != capAsNum) {
            return false;
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (h.bgpconfig.getAsNumber() != capAsNum) {
                return false;
            }
        }
    } else {
        if (openMsg.getAsNumber() != peerCfg.getAsNumber()) {
            return false;
        }
        if (isFourOctetCapabilityExits) {
            if (capAsNum != peerCfg.getAsNumber()) {
                return false;
            }
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (openMsg.getAsNumber() != h.bgpconfig.getAsNumber()) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean asNumberValidation(BgpChannelHandler h, BgpOpenMsg openMsg) {
    log.debug("AS number validation");
    int capAsNum = 0;
    boolean isFourOctetCapabilityExits = false;
    BgpPeerCfg peerCfg = h.bgpconfig.displayPeers(peerAddr);
    List<BgpValueType> capabilityTlv = openMsg.getCapabilityTlv();
    ListIterator<BgpValueType> listIterator = capabilityTlv.listIterator();
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv.getType() == FOUR_OCTET_AS_NUM_CAPA_TYPE) {
            isFourOctetCapabilityExits = true;
            capAsNum = ((FourOctetAsNumCapabilityTlv) tlv).getInt();
        }
    }
    if (peerCfg.getAsNumber() > MAX_AS2_NUM) {
        if (openMsg.getAsNumber() != AS_TRANS) {
            return false;
        }
        if (!isFourOctetCapabilityExits) {
            return false;
        }
        if (peerCfg.getAsNumber() != capAsNum) {
            return false;
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (h.bgpconfig.getAsNumber() != capAsNum) {
                return false;
            }
        }
    } else {
        if (openMsg.getAsNumber() != peerCfg.getAsNumber()) {
            return false;
        }
        if (isFourOctetCapabilityExits) {
            if (capAsNum != peerCfg.getAsNumber()) {
                return false;
            }
        }
        isIbgpSession = peerCfg.getIsIBgp();
        if (isIbgpSession) {
            // IBGP - AS number should be same for Peer and local if it is IBGP
            if (openMsg.getAsNumber() != h.bgpconfig.getAsNumber()) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean addPeer(String routerid, int remoteAs, short holdTime) {
    BgpPeerConfig lspeer = new BgpPeerConfig();
    if (this.bgpPeerTree.get(routerid) == null) {
        lspeer.setPeerRouterId(routerid);
        lspeer.setAsNumber(remoteAs);
        lspeer.setHoldtime(holdTime);
        lspeer.setState(BgpPeerCfg.State.IDLE);
        lspeer.setSelfInnitConnection(false);
        if (this.getAsNumber() == remoteAs) {
            lspeer.setIsIBgp(true);
        } else {
            lspeer.setIsIBgp(false);
        }
        this.bgpPeerTree.put(routerid, lspeer);
        log.debug("added successfully");
        return true;
    } else {
        log.debug("already exists");
        return false;
    }
}
#method_after
@Override
public boolean addPeer(String routerid, int remoteAs, short holdTime) {
    BgpPeerConfig lspeer = new BgpPeerConfig();
    if (this.bgpPeerTree.get(routerid) == null) {
        lspeer.setPeerRouterId(routerid);
        lspeer.setAsNumber(remoteAs);
        lspeer.setHoldtime(holdTime);
        lspeer.setState(BgpPeerCfg.State.IDLE);
        lspeer.setSelfInnitConnection(false);
        if (this.getAsNumber() == remoteAs) {
            lspeer.setIsIBgp(true);
        } else {
            lspeer.setIsIBgp(false);
        }
        this.bgpPeerTree.put(routerid, lspeer);
        log.debug("Added successfully");
        return true;
    } else {
        log.debug("Already exists");
        return false;
    }
}
#end_block

#method_before
@Override
public void write(ChannelBuffer cb, BgpKeepaliveMsgVer4 message) {
    log.info("write marker");
    cb.writeBytes(marker, 0, MARKER_LENGTH);
    log.info("write length of header");
    cb.writeShort(PACKET_MINIMUM_LENGTH);
    log.info("write the type of message");
    cb.writeByte(MSG_TYPE.getType());
}
#method_after
@Override
public void write(ChannelBuffer cb, BgpKeepaliveMsgVer4 message) {
    log.debug("Write marker");
    cb.writeBytes(marker, 0, MARKER_LENGTH);
    log.debug("Write length of header");
    cb.writeShort(PACKET_MINIMUM_LENGTH);
    log.debug("Write the type of message");
    cb.writeByte(MSG_TYPE.getType());
}
#end_block

#method_before
@Override
public void write(ChannelBuffer cb, BgpNotificationMsgVer4 message) throws BgpParseException {
    int msgStartIndex = cb.writerIndex();
    int headerLenIndex = message.bgpHeader.write(cb);
    if (headerLenIndex <= 0) {
        throw new BgpParseException(BgpErrorType.MESSAGE_HEADER_ERROR, (byte) 0, null);
    }
    cb.writeByte(message.errorCode);
    cb.writeByte(message.errorSubCode);
    if (message.data != null) {
        cb.writeBytes(message.data);
    }
    log.info("Update message length field in notification message");
    int length = cb.writerIndex() - msgStartIndex;
    cb.setShort(headerLenIndex, (short) length);
    message.bgpHeader.setLength((short) length);
}
#method_after
@Override
public void write(ChannelBuffer cb, BgpNotificationMsgVer4 message) throws BgpParseException {
    int msgStartIndex = cb.writerIndex();
    int headerLenIndex = message.bgpHeader.write(cb);
    if (headerLenIndex <= 0) {
        throw new BgpParseException(BgpErrorType.MESSAGE_HEADER_ERROR, (byte) 0, null);
    }
    cb.writeByte(message.errorCode);
    cb.writeByte(message.errorSubCode);
    if (message.data != null) {
        cb.writeBytes(message.data);
    }
    log.debug("Update message length field in notification message");
    int length = cb.writerIndex() - msgStartIndex;
    cb.setShort(headerLenIndex, (short) length);
    message.bgpHeader.setLength((short) length);
}
#end_block

#method_before
@Override
public BgpUpdateMsg readFrom(ChannelBuffer cb, BgpHeader bgpHeader) throws BgpParseException {
    if (cb.readableBytes() != (bgpHeader.getLength() - MINIMUM_COMMON_HEADER_LENGTH)) {
        Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.BAD_MESSAGE_LENGTH, bgpHeader.getLength());
    }
    LinkedList<IpPrefix> withDrwRoutes = new LinkedList<>();
    LinkedList<IpPrefix> nlri = new LinkedList<>();
    BgpPathAttributes bgpPathAttributes = new BgpPathAttributes();
    Short withDrwLen = cb.readShort();
    if (cb.readableBytes() < withDrwLen) {
        Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, cb.readableBytes());
    }
    log.info("Reading Withdrawn Routes Length");
    ChannelBuffer tempCb = cb.readBytes(withDrwLen);
    if (withDrwLen != 0) {
        // Parsing WithdrawnRoutes
        withDrwRoutes = parseWithdrawnRoutes(tempCb);
        log.info("WithdrawnRoutes parsed");
    }
    if (cb.readableBytes() < MIN_LEN_AFTER_WITHDRW_ROUTES) {
        log.debug("Bgp Path Attribute len field not present");
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    // Reading Total Path Attribute Length
    short totPathAttrLen = cb.readShort();
    int len = withDrwLen + totPathAttrLen + PACKET_MINIMUM_LENGTH;
    if (len > bgpHeader.getLength()) {
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    log.info("Total Path Attribute Length read");
    if (totPathAttrLen != 0) {
        // Parsing BGPPathAttributes
        if (cb.readableBytes() < totPathAttrLen) {
            Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, cb.readableBytes());
        }
        tempCb = cb.readBytes(totPathAttrLen);
        bgpPathAttributes = BgpPathAttributes.read(tempCb);
    }
    if (cb.readableBytes() > 0) {
        // Parsing NLRI
        nlri = parseNlri(cb);
    }
    return new BgpUpdateMsgVer4(bgpHeader, withDrwRoutes, bgpPathAttributes, nlri);
}
#method_after
@Override
public BgpUpdateMsg readFrom(ChannelBuffer cb, BgpHeader bgpHeader) throws BgpParseException {
    if (cb.readableBytes() != (bgpHeader.getLength() - MINIMUM_COMMON_HEADER_LENGTH)) {
        Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.BAD_MESSAGE_LENGTH, bgpHeader.getLength());
    }
    LinkedList<IpPrefix> withDrwRoutes = new LinkedList<>();
    LinkedList<IpPrefix> nlri = new LinkedList<>();
    BgpPathAttributes bgpPathAttributes = new BgpPathAttributes();
    Short withDrwLen = cb.readShort();
    if (cb.readableBytes() < withDrwLen) {
        Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, cb.readableBytes());
    }
    log.debug("Reading withdrawn routes length");
    ChannelBuffer tempCb = cb.readBytes(withDrwLen);
    if (withDrwLen != 0) {
        // Parsing WithdrawnRoutes
        withDrwRoutes = parseWithdrawnRoutes(tempCb);
        log.debug("Withdrawn routes parsed");
    }
    if (cb.readableBytes() < MIN_LEN_AFTER_WITHDRW_ROUTES) {
        log.debug("Bgp path attribute len field not present");
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    // Reading Total Path Attribute Length
    short totPathAttrLen = cb.readShort();
    int len = withDrwLen + totPathAttrLen + PACKET_MINIMUM_LENGTH;
    if (len > bgpHeader.getLength()) {
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    log.debug("Total path attribute length read");
    if (totPathAttrLen != 0) {
        // Parsing BGPPathAttributes
        if (cb.readableBytes() < totPathAttrLen) {
            Validation.validateLen(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, cb.readableBytes());
        }
        tempCb = cb.readBytes(totPathAttrLen);
        bgpPathAttributes = BgpPathAttributes.read(tempCb);
    }
    if (cb.readableBytes() > 0) {
        // Parsing NLRI
        nlri = parseNlri(cb);
    }
    return new BgpUpdateMsgVer4(bgpHeader, withDrwRoutes, bgpPathAttributes, nlri);
}
#end_block

#method_before
public void selectionProcessPrefix(BgpLSNlri nlri, boolean isVpnRib) throws BgpParseException {
    BgpPeerImpl peer;
    BgpSessionInfo sessionInfo;
    int decisionResult;
    boolean containsKey;
    BgpPrefixLSIdentifier prefixIdentifier = ((BgpPrefixIPv4LSNlriVer4) nlri).getPrefixIdentifier();
    if (prefixTree.containsKey(prefixIdentifier)) {
        log.debug("Local RIB remove prefix: {}", prefixIdentifier.toString());
        prefixTree.remove(prefixIdentifier);
    }
    for (BgpId bgpId : bgpController.connectedPeers().keySet()) {
        peer = (BgpPeerImpl) (bgpController.getPeer(bgpId));
        if (prefixTree.containsKey(prefixIdentifier)) {
            containsKey = (!isVpnRib) ? (peer.adjacencyRib().prefixTree().containsKey(prefixIdentifier)) : (peer.vpnAdjacencyRib().prefixTree().containsKey(prefixIdentifier));
            if (!containsKey) {
                continue;
            }
            sessionInfo = peer.sessionInfo();
            PathAttrNlriDetailsLocalRib detailsLocRib = new PathAttrNlriDetailsLocalRib(sessionInfo.remoteBgpId().ipAddress(), sessionInfo.remoteBgpIdentifier(), sessionInfo.remoteBgpASNum(), sessionInfo.isIbgpSession(), ((!isVpnRib) ? (peer.adjacencyRib().prefixTree().get(prefixIdentifier)) : (peer.vpnAdjacencyRib().prefixTree().get(prefixIdentifier))));
            BgpSelectionAlgo selectionAlgo = new BgpSelectionAlgo();
            decisionResult = selectionAlgo.compare(prefixTree.get(prefixIdentifier), detailsLocRib);
            if (decisionResult < 0) {
                prefixTree.replace(prefixIdentifier, detailsLocRib);
                log.debug("local RIB prefix updated: {}", detailsLocRib.toString());
            }
        } else {
            if (!isVpnRib) {
                if (peer.adjacencyRib().prefixTree().containsKey(prefixIdentifier)) {
                    add(peer.sessionInfo(), nlri, peer.adjacencyRib().prefixTree().get(prefixIdentifier));
                } else {
                    if (peer.vpnAdjacencyRib().prefixTree().containsKey(prefixIdentifier)) {
                        add(peer.sessionInfo(), nlri, peer.vpnAdjacencyRib().prefixTree().get(prefixIdentifier));
                    }
                }
            }
        }
    }
}
#method_after
public void selectionProcessPrefix(BgpLSNlri nlri, boolean isVpnRib) throws BgpParseException {
    BgpPeerImpl peer;
    BgpSessionInfo sessionInfo;
    int decisionResult;
    boolean containsKey;
    BgpPrefixLSIdentifier prefixIdentifier = ((BgpPrefixIPv4LSNlriVer4) nlri).getPrefixIdentifier();
    if (prefixTree.containsKey(prefixIdentifier)) {
        log.debug("Local RIB remove prefix: {}", prefixIdentifier.toString());
        prefixTree.remove(prefixIdentifier);
    }
    for (BgpId bgpId : bgpController.connectedPeers().keySet()) {
        peer = (BgpPeerImpl) (bgpController.getPeer(bgpId));
        if (prefixTree.containsKey(prefixIdentifier)) {
            containsKey = (!isVpnRib) ? (peer.adjacencyRib().prefixTree().containsKey(prefixIdentifier)) : (peer.vpnAdjacencyRib().prefixTree().containsKey(prefixIdentifier));
            if (!containsKey) {
                continue;
            }
            sessionInfo = peer.sessionInfo();
            PathAttrNlriDetailsLocalRib detailsLocRib = new PathAttrNlriDetailsLocalRib(sessionInfo.remoteBgpId().ipAddress(), sessionInfo.remoteBgpIdentifier(), sessionInfo.remoteBgpASNum(), sessionInfo.isIbgpSession(), ((!isVpnRib) ? (peer.adjacencyRib().prefixTree().get(prefixIdentifier)) : (peer.vpnAdjacencyRib().prefixTree().get(prefixIdentifier))));
            BgpSelectionAlgo selectionAlgo = new BgpSelectionAlgo();
            decisionResult = selectionAlgo.compare(prefixTree.get(prefixIdentifier), detailsLocRib);
            if (decisionResult < 0) {
                prefixTree.replace(prefixIdentifier, detailsLocRib);
                log.debug("Local RIB prefix updated: {}", detailsLocRib.toString());
            }
        } else {
            if (!isVpnRib) {
                if (peer.adjacencyRib().prefixTree().containsKey(prefixIdentifier)) {
                    add(peer.sessionInfo(), nlri, peer.adjacencyRib().prefixTree().get(prefixIdentifier));
                } else {
                    if (peer.vpnAdjacencyRib().prefixTree().containsKey(prefixIdentifier)) {
                        add(peer.sessionInfo(), nlri, peer.vpnAdjacencyRib().prefixTree().get(prefixIdentifier));
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void displayPcepSession() {
    try {
        this.pcepClientController = get(PcepClientController.class);
        Map<String, String> pcepSessionMap = pcepClientController.getPcepSessionMap();
        Map<String, Byte> pcepSessionIdMap = pcepClientController.getPcepSessionIdMap();
        pcepSessionKeySet = pcepSessionMap.keySet();
        pcepSessionIdKeySet = pcepSessionIdMap.keySet();
        if (peer != null) {
            if (pcepSessionKeySet.size() > 0) {
                if (pcepSessionKeySet.contains(peer)) {
                    for (String pcepSessionPeer : pcepSessionKeySet) {
                        if (pcepSessionPeer.equals(peer)) {
                            for (String pcepSessionId : pcepSessionIdKeySet) {
                                if (pcepSessionId.equals(peer)) {
                                    sessionId = pcepSessionIdMap.get(pcepSessionId);
                                    sessionStatus = pcepSessionMap.get(pcepSessionPeer);
                                    if (sessionId < 0) {
                                        sessionIdValue = sessionId + 256;
                                    } else {
                                        sessionIdValue = (int) sessionId;
                                    }
                                }
                            }
                            print("SessionIp = %s, Status = %s, sessionId = %s", pcepSessionPeer, sessionStatus, sessionIdValue);
                        }
                    }
                } else {
                    System.out.print("Wrong Peer IP");
                }
            }
        } else {
            if (pcepSessionKeySet.size() > 0) {
                for (String pcepSessionPeer : pcepSessionKeySet) {
                    for (String pcepSessionId : pcepSessionIdKeySet) {
                        if (pcepSessionId.equals(pcepSessionPeer)) {
                            sessionId = pcepSessionIdMap.get(pcepSessionId);
                            sessionStatus = pcepSessionMap.get(pcepSessionPeer);
                            if (sessionId < 0) {
                                sessionIdValue = sessionId + 256;
                            } else {
                                sessionIdValue = (int) sessionId;
                            }
                        }
                    }
                    print("SessionIp = %s, Status = %s, sessionId = %s", pcepSessionPeer, sessionStatus, sessionIdValue);
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying Pcep Session Information: {}", e.getMessage());
    }
}
#method_after
private void displayPcepSession() {
    try {
        this.pcepClientController = get(PcepClientController.class);
        Map<String, String> pcepSessionMap = pcepClientController.getPcepSessionMap();
        Map<String, Byte> pcepSessionIdMap = pcepClientController.getPcepSessionIdMap();
        pcepSessionKeySet = pcepSessionMap.keySet();
        pcepSessionIdKeySet = pcepSessionIdMap.keySet();
        if (peer != null) {
            if (pcepSessionKeySet.size() > 0) {
                if (pcepSessionKeySet.contains(peer)) {
                    for (String pcepSessionPeer : pcepSessionKeySet) {
                        if (pcepSessionPeer.equals(peer)) {
                            for (String pcepSessionId : pcepSessionIdKeySet) {
                                if (pcepSessionId.equals(peer)) {
                                    sessionId = pcepSessionIdMap.get(pcepSessionId);
                                    sessionStatus = pcepSessionMap.get(pcepSessionPeer);
                                    if (sessionId < 0) {
                                        sessionIdValue = sessionId + 256;
                                    } else {
                                        sessionIdValue = (int) sessionId;
                                    }
                                }
                            }
                            print("SessionIp = %s, Status = %s, sessionId = %s", pcepSessionPeer, sessionStatus, sessionIdValue);
                        }
                    }
                } else {
                    System.out.print("Wrong Peer IP");
                }
            }
        } else {
            if (pcepSessionKeySet.size() > 0) {
                for (String pcepSessionPeer : pcepSessionKeySet) {
                    for (String pcepSessionId : pcepSessionIdKeySet) {
                        if (pcepSessionId.equals(pcepSessionPeer)) {
                            sessionId = pcepSessionIdMap.get(pcepSessionId);
                            sessionStatus = pcepSessionMap.get(pcepSessionPeer);
                            if (sessionId < 0) {
                                sessionIdValue = sessionId + 256;
                            } else {
                                sessionIdValue = (int) sessionId;
                            }
                        }
                    }
                    print("SessionIp = %s, Status = %s, sessionId = %s", pcepSessionPeer, sessionStatus, sessionIdValue);
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying PCEP session information: {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayPcepSessionFailureReason() {
    try {
        this.pcepClientController = get(PcepClientController.class);
        Map<String, List<String>> pcepSessionFailureReasonMap = pcepClientController.getPcepExceptions();
        pcepSessionFailurekeySet = pcepSessionFailureReasonMap.keySet();
        if (pcepSessionFailurekeySet.size() > 0) {
            if (peer != null) {
                if (pcepSessionFailurekeySet.contains(peer)) {
                    for (String pcepSessionPeerId : pcepSessionFailurekeySet) {
                        if (pcepSessionPeerId.equals(peer)) {
                            pcepSessionExceptions = pcepSessionFailureReasonMap.get(pcepSessionPeerId);
                            print("PeerId = %s, FailureReason = %s", pcepSessionPeerId, pcepSessionExceptions);
                        }
                    }
                } else {
                    System.out.print("Wrong Peer IP");
                }
            } else {
                pcepSessionFailurekeySet = pcepSessionFailureReasonMap.keySet();
                if (pcepSessionFailurekeySet.size() > 0) {
                    for (String pcepSessionPeerId : pcepSessionFailurekeySet) {
                        pcepSessionExceptions = pcepSessionFailureReasonMap.get(pcepSessionPeerId);
                        print("PeerId = %s, FailureReason = %s", pcepSessionPeerId, pcepSessionExceptions);
                    }
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying Pcep Session Failure Reasons: {}", e.getMessage());
    }
}
#method_after
private void displayPcepSessionFailureReason() {
    try {
        this.pcepClientController = get(PcepClientController.class);
        Map<String, List<String>> pcepSessionFailureReasonMap = pcepClientController.getPcepExceptions();
        pcepSessionFailurekeySet = pcepSessionFailureReasonMap.keySet();
        if (pcepSessionFailurekeySet.size() > 0) {
            if (peer != null) {
                if (pcepSessionFailurekeySet.contains(peer)) {
                    for (String pcepSessionPeerId : pcepSessionFailurekeySet) {
                        if (pcepSessionPeerId.equals(peer)) {
                            pcepSessionExceptions = pcepSessionFailureReasonMap.get(pcepSessionPeerId);
                            print("PeerId = %s, FailureReason = %s", pcepSessionPeerId, pcepSessionExceptions);
                        }
                    }
                } else {
                    System.out.print("Wrong Peer IP");
                }
            } else {
                pcepSessionFailurekeySet = pcepSessionFailureReasonMap.keySet();
                if (pcepSessionFailurekeySet.size() > 0) {
                    for (String pcepSessionPeerId : pcepSessionFailurekeySet) {
                        pcepSessionExceptions = pcepSessionFailureReasonMap.get(pcepSessionPeerId);
                        print("PeerId = %s, FailureReason = %s", pcepSessionPeerId, pcepSessionExceptions);
                    }
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying PCEP session failure reasons: {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayPcepErrorMsgs() {
    try {
        this.pcepClientController = get(PcepClientController.class);
        Map<Integer, Integer> pcepErrorMsgMap = pcepClientController.getPcepErrorMsg();
        pcepErrorMsgKey = pcepErrorMsgMap.keySet();
        if (pcepErrorMsgKey.size() > 0) {
            for (Integer errorType : pcepErrorMsgKey) {
                pcepErrorValue = pcepErrorMsgMap.get(errorType);
                pcepErrorType = PcepErrorType.values()[errorType];
                switch(pcepErrorType) {
                    case SessionEstablishmentFailure:
                        sessionEstablishmentFailureMap = pcepErrorDetail.sessionEstablishmentFailure();
                        Set<Integer> sessionFailureKeySet = sessionEstablishmentFailureMap.keySet();
                        for (Integer sessionFailureKey : sessionFailureKeySet) {
                            if (sessionFailureKey == pcepErrorValue) {
                                System.out.print(sessionEstablishmentFailureMap.get(sessionFailureKey));
                            }
                        }
                    case CapabilityNotSupported:
                        System.out.print("Capability not supported");
                    case UnknownObject:
                        unknownObjectMap = pcepErrorDetail.unknownObject();
                        Set<Integer> unknownObjectKeySet = unknownObjectMap.keySet();
                        for (Integer unknownObjectKey : unknownObjectKeySet) {
                            if (unknownObjectKey == pcepErrorValue) {
                                System.out.print(unknownObjectMap.get(unknownObjectKey));
                            }
                        }
                    case NotSupportedObject:
                        notSupportedObjectMap = pcepErrorDetail.notSupportedObject();
                        Set<Integer> notSupportedObjectKeySet = notSupportedObjectMap.keySet();
                        for (Integer notSupportedObjectKey : notSupportedObjectKeySet) {
                            if (notSupportedObjectKey == pcepErrorValue) {
                                System.out.print(notSupportedObjectMap.get(notSupportedObjectKey));
                            }
                        }
                    case PolicyViolation:
                        policyViolationMap = pcepErrorDetail.policyViolation();
                        Set<Integer> policyViolationKeySet = policyViolationMap.keySet();
                        for (Integer policyViolationKey : policyViolationKeySet) {
                            if (policyViolationKey == pcepErrorValue) {
                                System.out.print(policyViolationMap.get(policyViolationKey));
                            }
                        }
                    case MandatoryObjectMissing:
                        mandatoryObjectMissingMap = pcepErrorDetail.mandatoryObjectMissing();
                        Set<Integer> mandatoryObjectMissingKeySet = mandatoryObjectMissingMap.keySet();
                        for (Integer mandatoryObjectMissingKey : mandatoryObjectMissingKeySet) {
                            if (mandatoryObjectMissingKey == pcepErrorValue) {
                                System.out.print(mandatoryObjectMissingMap.get(mandatoryObjectMissingKey));
                            }
                        }
                    case SynchronizedPathComputationRequestMissing:
                        System.out.print("Synchronized path computation request missing");
                    case UnknownRequestReference:
                        System.out.print("Unknown request reference");
                    case EstablishingSecondPCEPSession:
                        System.out.print("Attempt to establish a second PCEP session");
                    case ReceptionOfInvalidObject:
                        receptionOfInvalidObjectMap = pcepErrorDetail.receptionOfInvalidObject();
                        Set<Integer> receptionOfInvalidObjectKeySet = receptionOfInvalidObjectMap.keySet();
                        for (Integer receptionOfInvalidObjectKey : receptionOfInvalidObjectKeySet) {
                            if (receptionOfInvalidObjectKey == pcepErrorValue) {
                                System.out.print(receptionOfInvalidObjectMap.get(receptionOfInvalidObjectKey));
                            }
                        }
                    case InvalidOperation:
                        invalidOperationMap = pcepErrorDetail.invalidOperation();
                        Set<Integer> invalidOperationKeySet = invalidOperationMap.keySet();
                        for (Integer invalidOperationKey : invalidOperationKeySet) {
                            if (invalidOperationKey == pcepErrorValue) {
                                System.out.print(invalidOperationMap.get(invalidOperationKey));
                            }
                        }
                    case VIRTUALNetworkTLVMissing:
                        System.out.print("VIRTUAL-NETWORK TLV missing");
                    default:
                        System.out.print("Unknown error message");
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying Pcep error messages received: {}", e.getMessage());
    }
}
#method_after
private void displayPcepErrorMsgs() {
    try {
        this.pcepClientController = get(PcepClientController.class);
        Map<Integer, Integer> pcepErrorMsgMap = pcepClientController.getPcepErrorMsg();
        pcepErrorMsgKey = pcepErrorMsgMap.keySet();
        if (pcepErrorMsgKey.size() > 0) {
            for (Integer errorType : pcepErrorMsgKey) {
                pcepErrorValue = pcepErrorMsgMap.get(errorType);
                pcepErrorType = PcepErrorType.values()[errorType];
                switch(pcepErrorType) {
                    case SESSIONESTABLISHMENTFAILURE:
                        sessionEstablishmentFailureMap = pcepErrorDetail.sessionEstablishmentFailure();
                        Set<Integer> sessionFailureKeySet = sessionEstablishmentFailureMap.keySet();
                        for (Integer sessionFailureKey : sessionFailureKeySet) {
                            if (sessionFailureKey == pcepErrorValue) {
                                System.out.print(sessionEstablishmentFailureMap.get(sessionFailureKey));
                            }
                        }
                    case CAPABALITYNOTSUPPORTED:
                        System.out.print("Capability not supported");
                    case UNKNOWNOBJECT:
                        unknownObjectMap = pcepErrorDetail.unknownObject();
                        Set<Integer> unknownObjectKeySet = unknownObjectMap.keySet();
                        for (Integer unknownObjectKey : unknownObjectKeySet) {
                            if (unknownObjectKey == pcepErrorValue) {
                                System.out.print(unknownObjectMap.get(unknownObjectKey));
                            }
                        }
                    case NOTSUPPORTEDOBJECT:
                        notSupportedObjectMap = pcepErrorDetail.notSupportedObject();
                        Set<Integer> notSupportedObjectKeySet = notSupportedObjectMap.keySet();
                        for (Integer notSupportedObjectKey : notSupportedObjectKeySet) {
                            if (notSupportedObjectKey == pcepErrorValue) {
                                System.out.print(notSupportedObjectMap.get(notSupportedObjectKey));
                            }
                        }
                    case POLICYVIOLATION:
                        policyViolationMap = pcepErrorDetail.policyViolation();
                        Set<Integer> policyViolationKeySet = policyViolationMap.keySet();
                        for (Integer policyViolationKey : policyViolationKeySet) {
                            if (policyViolationKey == pcepErrorValue) {
                                System.out.print(policyViolationMap.get(policyViolationKey));
                            }
                        }
                    case MANDATORYOBJECTMISSING:
                        mandatoryObjectMissingMap = pcepErrorDetail.mandatoryObjectMissing();
                        Set<Integer> mandatoryObjectMissingKeySet = mandatoryObjectMissingMap.keySet();
                        for (Integer mandatoryObjectMissingKey : mandatoryObjectMissingKeySet) {
                            if (mandatoryObjectMissingKey == pcepErrorValue) {
                                System.out.print(mandatoryObjectMissingMap.get(mandatoryObjectMissingKey));
                            }
                        }
                    case SYNCHRONIZEDPATHCOMPUTATIONREQUESTMISSING:
                        System.out.print("Synchronized path computation request missing");
                    case UNKNOWNREQUESTREFERENCE:
                        System.out.print("Unknown request reference");
                    case ESTABLISHINGSECONDPCEPSESSION:
                        System.out.print("Attempt to establish a second PCEP session");
                    case RECEPTIONOFINVALIDOBJECT:
                        receptionOfInvalidObjectMap = pcepErrorDetail.receptionOfInvalidObject();
                        Set<Integer> receptionOfInvalidObjectKeySet = receptionOfInvalidObjectMap.keySet();
                        for (Integer receptionOfInvalidObjectKey : receptionOfInvalidObjectKeySet) {
                            if (receptionOfInvalidObjectKey == pcepErrorValue) {
                                System.out.print(receptionOfInvalidObjectMap.get(receptionOfInvalidObjectKey));
                            }
                        }
                    case INVALIDOPERATION:
                        invalidOperationMap = pcepErrorDetail.invalidOperation();
                        Set<Integer> invalidOperationKeySet = invalidOperationMap.keySet();
                        for (Integer invalidOperationKey : invalidOperationKeySet) {
                            if (invalidOperationKey == pcepErrorValue) {
                                System.out.print(invalidOperationMap.get(invalidOperationKey));
                            }
                        }
                    case VIRTUALNETWORKTLVMISSING:
                        System.out.print("VIRTUAL-NETWORK TLV missing");
                    default:
                        System.out.print("Unknown error message");
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying PCEP error messages received: {}", e.getMessage());
    }
}
#end_block

#method_before
@Override
public void peerErrorMsg(String peerId, Integer errorType, Integer errValue) {
}
#method_after
@Override
public void peerErrorMsg(String peerId, Integer errorType, Integer errValue) {
    return;
}
#end_block

#method_before
public static BgpPrefixLSIdentifier parsePrefixIdendifier(ChannelBuffer cb, byte protocolId) throws BgpParseException {
    log.info("Parse Local Node descriptor");
    NodeDescriptors localNodeDescriptors = new NodeDescriptors();
    localNodeDescriptors = parseLocalNodeDescriptors(cb, protocolId);
    log.info("MultiTopologyId TLV cannot repeat more than once");
    List<BgpValueType> prefixDescriptor = new LinkedList<>();
    prefixDescriptor = parsePrefixDescriptors(cb);
    return new BgpPrefixLSIdentifier(localNodeDescriptors, prefixDescriptor);
}
#method_after
public static BgpPrefixLSIdentifier parsePrefixIdendifier(ChannelBuffer cb, byte protocolId) throws BgpParseException {
    log.debug("Parse local node descriptor");
    NodeDescriptors localNodeDescriptors = new NodeDescriptors();
    localNodeDescriptors = parseLocalNodeDescriptors(cb, protocolId);
    log.debug("MultiTopologyId TLV cannot repeat more than once");
    List<BgpValueType> prefixDescriptor = new LinkedList<>();
    prefixDescriptor = parsePrefixDescriptors(cb);
    return new BgpPrefixLSIdentifier(localNodeDescriptors, prefixDescriptor);
}
#end_block

#method_before
@Override
public BgpOpenMsg readFrom(ChannelBuffer cb, BgpHeader bgpHeader) throws BgpParseException {
    byte version;
    short holdTime;
    long asNumber;
    int bgpId;
    byte optParaLen = 0;
    byte optParaType;
    byte capParaLen = 0;
    LinkedList<BgpValueType> capabilityTlv = new LinkedList<>();
    if (cb.readableBytes() < OPEN_MSG_MINIMUM_LENGTH) {
        log.error("[readFrom] Invalid length: Packet size is less than the minimum length ");
        Validation.validateLen(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.BAD_MESSAGE_LENGTH, cb.readableBytes());
    }
    // Read version
    version = cb.readByte();
    if (version != PACKET_VERSION) {
        log.error("[readFrom] Invalid version: " + version);
        throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_VERSION_NUMBER, null);
    }
    // Read AS number
    asNumber = cb.getUnsignedShort(cb.readerIndex());
    cb.readShort();
    log.debug("AS number read");
    // Read Hold timer
    holdTime = cb.readShort();
    log.debug("Holding Time read");
    // Read BGP Identifier
    bgpId = cb.readInt();
    log.debug("BGP identifier read");
    // Read optional parameter length
    optParaLen = cb.readByte();
    log.debug("OPtional parameter length read");
    // Read Capabilities if optional parameter length is greater than 0
    if (optParaLen != 0) {
        // Read optional parameter type
        optParaType = cb.readByte();
        // Read optional parameter length
        capParaLen = cb.readByte();
        if (cb.readableBytes() < capParaLen) {
            throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, (byte) 0, null);
        }
        ChannelBuffer capaCb = cb.readBytes(capParaLen);
        // Parse capabilities only if optional parameter type is 2
        if ((optParaType == OPT_PARA_TYPE_CAPABILITY) && (capParaLen != 0)) {
            capabilityTlv = parseCapabilityTlv(capaCb);
        } else {
            throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_OPTIONAL_PARAMETER, null);
        }
    }
    return new BgpOpenMsgVer4(bgpHeader, version, asNumber, holdTime, bgpId, capabilityTlv);
}
#method_after
@Override
public BgpOpenMsg readFrom(ChannelBuffer cb, BgpHeader bgpHeader) throws BgpParseException {
    byte version;
    short holdTime;
    long asNumber;
    int bgpId;
    byte optParaLen = 0;
    byte optParaType;
    byte capParaLen = 0;
    LinkedList<BgpValueType> capabilityTlv = new LinkedList<>();
    if (cb.readableBytes() < OPEN_MSG_MINIMUM_LENGTH) {
        log.error("[readFrom] Invalid length: Packet size is less than the minimum length ");
        Validation.validateLen(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.BAD_MESSAGE_LENGTH, cb.readableBytes());
    }
    // Read version
    version = cb.readByte();
    if (version != PACKET_VERSION) {
        log.error("[readFrom] Invalid version: " + version);
        throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_VERSION_NUMBER, null);
    }
    // Read AS number
    asNumber = cb.getUnsignedShort(cb.readerIndex());
    cb.readShort();
    log.debug("AS number read");
    // Read Hold timer
    holdTime = cb.readShort();
    log.debug("Holding time read");
    // Read BGP Identifier
    bgpId = cb.readInt();
    log.debug("BGP identifier read");
    // Read optional parameter length
    optParaLen = cb.readByte();
    log.debug("OPtional parameter length read");
    // Read Capabilities if optional parameter length is greater than 0
    if (optParaLen != 0) {
        // Read optional parameter type
        optParaType = cb.readByte();
        // Read optional parameter length
        capParaLen = cb.readByte();
        if (cb.readableBytes() < capParaLen) {
            throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, (byte) 0, null);
        }
        ChannelBuffer capaCb = cb.readBytes(capParaLen);
        // Parse capabilities only if optional parameter type is 2
        if ((optParaType == OPT_PARA_TYPE_CAPABILITY) && (capParaLen != 0)) {
            capabilityTlv = parseCapabilityTlv(capaCb);
        } else {
            throw new BgpParseException(BgpErrorType.OPEN_MESSAGE_ERROR, BgpErrorType.UNSUPPORTED_OPTIONAL_PARAMETER, null);
        }
    }
    return new BgpOpenMsgVer4(bgpHeader, version, asNumber, holdTime, bgpId, capabilityTlv);
}
#end_block

#method_before
protected static LinkedList<BgpValueType> parseCapabilityTlv(ChannelBuffer cb) throws BgpParseException {
    LinkedList<BgpValueType> capabilityTlv = new LinkedList<>();
    while (cb.readableBytes() > 0) {
        BgpValueType tlv;
        short type = cb.readByte();
        short length = cb.readByte();
        switch(type) {
            case FourOctetAsNumCapabilityTlv.TYPE:
                log.debug("FourOctetAsNumCapabilityTlv");
                if (FourOctetAsNumCapabilityTlv.LENGTH != length) {
                    throw new BgpParseException("Invalid length received for FourOctetAsNumCapabilityTlv.");
                }
                if (length > cb.readableBytes()) {
                    throw new BgpParseException("Four octet as num tlv length" + " is more than readableBytes.");
                }
                int as4Num = cb.readInt();
                tlv = new FourOctetAsNumCapabilityTlv(as4Num);
                break;
            case RpdCapabilityTlv.TYPE:
                log.debug("RpdCapability");
                if (RpdCapabilityTlv.LENGTH != length) {
                    throw new BgpParseException("Invalid length received for RpdCapability.");
                }
                if (length > cb.readableBytes()) {
                    throw new BgpParseException("Four octet as num tlv length" + " is more than readableBytes.");
                }
                short rpdAfi = cb.readShort();
                byte rpdAsafi = cb.readByte();
                byte sendReceive = cb.readByte();
                tlv = new RpdCapabilityTlv(sendReceive);
                break;
            case MultiProtocolExtnCapabilityTlv.TYPE:
                log.debug("MultiProtocolExtnCapabilityTlv");
                if (MultiProtocolExtnCapabilityTlv.LENGTH != length) {
                    throw new BgpParseException("Invalid length received for MultiProtocolExtnCapabilityTlv.");
                }
                if (length > cb.readableBytes()) {
                    throw new BgpParseException("BGP LS tlv length is more than readableBytes.");
                }
                short afi = cb.readShort();
                byte res = cb.readByte();
                byte safi = cb.readByte();
                tlv = new MultiProtocolExtnCapabilityTlv(afi, res, safi);
                break;
            default:
                log.debug("Warning: Unsupported TLV: " + type);
                cb.skipBytes(length);
                continue;
        }
        capabilityTlv.add(tlv);
    }
    return capabilityTlv;
}
#method_after
protected static LinkedList<BgpValueType> parseCapabilityTlv(ChannelBuffer cb) throws BgpParseException {
    LinkedList<BgpValueType> capabilityTlv = new LinkedList<>();
    while (cb.readableBytes() > 0) {
        BgpValueType tlv;
        short type = cb.readByte();
        short length = cb.readByte();
        switch(type) {
            case FourOctetAsNumCapabilityTlv.TYPE:
                log.debug("FourOctetAsNumCapabilityTlv");
                if (FourOctetAsNumCapabilityTlv.LENGTH != length) {
                    throw new BgpParseException("Invalid length received for FourOctetAsNumCapabilityTlv.");
                }
                if (length > cb.readableBytes()) {
                    throw new BgpParseException("Four octet as num tlv length" + " is more than readableBytes.");
                }
                int as4Num = cb.readInt();
                tlv = new FourOctetAsNumCapabilityTlv(as4Num);
                break;
            case RpdCapabilityTlv.TYPE:
                log.debug("RpdCapability");
                if (RpdCapabilityTlv.LENGTH != length) {
                    throw new BgpParseException("Invalid length received for RpdCapability.");
                }
                if (length > cb.readableBytes()) {
                    throw new BgpParseException("Four octet as num TLV length" + " is more than readableBytes.");
                }
                short rpdAfi = cb.readShort();
                byte rpdAsafi = cb.readByte();
                byte sendReceive = cb.readByte();
                tlv = new RpdCapabilityTlv(sendReceive);
                break;
            case MultiProtocolExtnCapabilityTlv.TYPE:
                log.debug("MultiProtocolExtnCapabilityTlv");
                if (MultiProtocolExtnCapabilityTlv.LENGTH != length) {
                    throw new BgpParseException("Invalid length received for MultiProtocolExtnCapabilityTlv.");
                }
                if (length > cb.readableBytes()) {
                    throw new BgpParseException("BGP LS tlv length is more than readableBytes.");
                }
                short afi = cb.readShort();
                byte res = cb.readByte();
                byte safi = cb.readByte();
                tlv = new MultiProtocolExtnCapabilityTlv(afi, res, safi);
                break;
            default:
                log.debug("Warning: Unsupported TLV: " + type);
                cb.skipBytes(length);
                continue;
        }
        capabilityTlv.add(tlv);
    }
    return capabilityTlv;
}
#end_block

#method_before
protected int packCapabilityTlv(ChannelBuffer cb, BgpOpenMsgVer4 message) {
    int startIndex = cb.writerIndex();
    int capParaLen = 0;
    int capParaLenIndex = 0;
    LinkedList<BgpValueType> capabilityTlv = message.capabilityTlv;
    ListIterator<BgpValueType> listIterator = capabilityTlv.listIterator();
    if (listIterator.hasNext()) {
        // Set optional parameter type as 2
        cb.writeByte(OPT_PARA_TYPE_CAPABILITY);
        // Store the index of capability parameter length and update length at the end
        capParaLenIndex = cb.writerIndex();
        // Set capability parameter length as 0
        cb.writeByte(0);
        // Update the startIndex to know the length of capability tlv
        startIndex = cb.writerIndex();
    }
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv == null) {
            log.debug("Warning: tlv is null from CapabilityTlv list");
            continue;
        }
        tlv.write(cb);
    }
    capParaLen = cb.writerIndex() - startIndex;
    if (capParaLen != 0) {
        // Update capability parameter length
        cb.setByte(capParaLenIndex, (byte) capParaLen);
    }
    return capParaLen;
}
#method_after
protected int packCapabilityTlv(ChannelBuffer cb, BgpOpenMsgVer4 message) {
    int startIndex = cb.writerIndex();
    int capParaLen = 0;
    int capParaLenIndex = 0;
    LinkedList<BgpValueType> capabilityTlv = message.capabilityTlv;
    ListIterator<BgpValueType> listIterator = capabilityTlv.listIterator();
    if (listIterator.hasNext()) {
        // Set optional parameter type as 2
        cb.writeByte(OPT_PARA_TYPE_CAPABILITY);
        // Store the index of capability parameter length and update length at the end
        capParaLenIndex = cb.writerIndex();
        // Set capability parameter length as 0
        cb.writeByte(0);
        // Update the startIndex to know the length of capability tlv
        startIndex = cb.writerIndex();
    }
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv == null) {
            log.debug("Warning: TLV is null from CapabilityTlv list");
            continue;
        }
        tlv.write(cb);
    }
    capParaLen = cb.writerIndex() - startIndex;
    if (capParaLen != 0) {
        // Update capability parameter length
        cb.setByte(capParaLenIndex, (byte) capParaLen);
    }
    return capParaLen;
}
#end_block

#method_before
public static BgpLinkLSIdentifier parseLinkIdendifier(ChannelBuffer cb, byte protocolId) throws BgpParseException {
    log.info("Parse local node descriptor");
    NodeDescriptors localNodeDescriptors = new NodeDescriptors();
    localNodeDescriptors = parseNodeDescriptors(cb, NodeDescriptors.LOCAL_NODE_DES_TYPE, protocolId);
    log.info("Parse remote node descriptor");
    NodeDescriptors remoteNodeDescriptors = new NodeDescriptors();
    remoteNodeDescriptors = parseNodeDescriptors(cb, NodeDescriptors.REMOTE_NODE_DES_TYPE, protocolId);
    log.info("Parse link descriptor");
    LinkedList<BgpValueType> linkDescriptor = new LinkedList<>();
    linkDescriptor = parseLinkDescriptors(cb);
    return new BgpLinkLSIdentifier(localNodeDescriptors, remoteNodeDescriptors, linkDescriptor);
}
#method_after
public static BgpLinkLSIdentifier parseLinkIdendifier(ChannelBuffer cb, byte protocolId) throws BgpParseException {
    log.debug("Parse local node descriptor");
    NodeDescriptors localNodeDescriptors = new NodeDescriptors();
    localNodeDescriptors = parseNodeDescriptors(cb, NodeDescriptors.LOCAL_NODE_DES_TYPE, protocolId);
    log.debug("Parse remote node descriptor");
    NodeDescriptors remoteNodeDescriptors = new NodeDescriptors();
    remoteNodeDescriptors = parseNodeDescriptors(cb, NodeDescriptors.REMOTE_NODE_DES_TYPE, protocolId);
    log.debug("Parse link descriptor");
    LinkedList<BgpValueType> linkDescriptor = new LinkedList<>();
    linkDescriptor = parseLinkDescriptors(cb);
    return new BgpLinkLSIdentifier(localNodeDescriptors, remoteNodeDescriptors, linkDescriptor);
}
#end_block

#method_before
public static NodeDescriptors parseNodeDescriptors(ChannelBuffer cb, short desType, byte protocolId) throws BgpParseException {
    log.debug("parse Node descriptors");
    ChannelBuffer tempBuf = cb.copy();
    short type = cb.readShort();
    short length = cb.readShort();
    if (cb.readableBytes() < length) {
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(cb.readableBytes() + Constants.TYPE_AND_LEN_AS_SHORT));
    }
    NodeDescriptors nodeIdentifier = new NodeDescriptors();
    ChannelBuffer tempCb = cb.readBytes(length);
    if (type == desType) {
        nodeIdentifier = NodeDescriptors.read(tempCb, length, desType, protocolId);
    } else {
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    return nodeIdentifier;
}
#method_after
public static NodeDescriptors parseNodeDescriptors(ChannelBuffer cb, short desType, byte protocolId) throws BgpParseException {
    log.debug("Parse node descriptors");
    ChannelBuffer tempBuf = cb.copy();
    short type = cb.readShort();
    short length = cb.readShort();
    if (cb.readableBytes() < length) {
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(cb.readableBytes() + Constants.TYPE_AND_LEN_AS_SHORT));
    }
    NodeDescriptors nodeIdentifier = new NodeDescriptors();
    ChannelBuffer tempCb = cb.readBytes(length);
    if (type == desType) {
        nodeIdentifier = NodeDescriptors.read(tempCb, length, desType, protocolId);
    } else {
        throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MALFORMED_ATTRIBUTE_LIST, null);
    }
    return nodeIdentifier;
}
#end_block

#method_before
public static LinkedList<BgpValueType> parseLinkDescriptors(ChannelBuffer cb) throws BgpParseException {
    LinkedList<BgpValueType> linkDescriptor = new LinkedList<>();
    BgpValueType tlv = null;
    int count = 0;
    while (cb.readableBytes() > 0) {
        ChannelBuffer tempBuf = cb.copy();
        short type = cb.readShort();
        short length = cb.readShort();
        if (cb.readableBytes() < length) {
            throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(cb.readableBytes() + Constants.TYPE_AND_LEN_AS_SHORT));
        }
        ChannelBuffer tempCb = cb.readBytes(length);
        switch(type) {
            case LinkLocalRemoteIdentifiersTlv.TYPE:
                tlv = LinkLocalRemoteIdentifiersTlv.read(tempCb);
                break;
            case IPV4_INTERFACE_ADDRESS_TYPE:
                tlv = IPv4AddressTlv.read(tempCb, IPV4_INTERFACE_ADDRESS_TYPE);
                break;
            case IPV4_NEIGHBOR_ADDRESS_TYPE:
                tlv = IPv4AddressTlv.read(tempCb, IPV4_NEIGHBOR_ADDRESS_TYPE);
                break;
            case IPV6_INTERFACE_ADDRESS_TYPE:
                tlv = IPv6AddressTlv.read(tempCb, IPV6_INTERFACE_ADDRESS_TYPE);
                break;
            case IPV6_NEIGHBOR_ADDRESS_TYPE:
                tlv = IPv6AddressTlv.read(tempCb, IPV6_NEIGHBOR_ADDRESS_TYPE);
                break;
            case BgpAttrNodeMultiTopologyId.ATTRNODE_MULTITOPOLOGY:
                tlv = BgpAttrNodeMultiTopologyId.read(tempCb);
                count = count++;
                log.info("MultiTopologyId TLV cannot repeat more than once");
                if (count > 1) {
                    // length + 4 implies data contains type, length and value
                    throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(length + Constants.TYPE_AND_LEN_AS_SHORT));
                }
                break;
            default:
                UnSupportedAttribute.skipBytes(tempCb, length);
        }
        linkDescriptor.add(tlv);
    }
    return linkDescriptor;
}
#method_after
public static LinkedList<BgpValueType> parseLinkDescriptors(ChannelBuffer cb) throws BgpParseException {
    LinkedList<BgpValueType> linkDescriptor = new LinkedList<>();
    BgpValueType tlv = null;
    int count = 0;
    while (cb.readableBytes() > 0) {
        ChannelBuffer tempBuf = cb.copy();
        short type = cb.readShort();
        short length = cb.readShort();
        if (cb.readableBytes() < length) {
            throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(cb.readableBytes() + Constants.TYPE_AND_LEN_AS_SHORT));
        }
        ChannelBuffer tempCb = cb.readBytes(length);
        switch(type) {
            case LinkLocalRemoteIdentifiersTlv.TYPE:
                tlv = LinkLocalRemoteIdentifiersTlv.read(tempCb);
                break;
            case IPV4_INTERFACE_ADDRESS_TYPE:
                tlv = IPv4AddressTlv.read(tempCb, IPV4_INTERFACE_ADDRESS_TYPE);
                break;
            case IPV4_NEIGHBOR_ADDRESS_TYPE:
                tlv = IPv4AddressTlv.read(tempCb, IPV4_NEIGHBOR_ADDRESS_TYPE);
                break;
            case IPV6_INTERFACE_ADDRESS_TYPE:
                tlv = IPv6AddressTlv.read(tempCb, IPV6_INTERFACE_ADDRESS_TYPE);
                break;
            case IPV6_NEIGHBOR_ADDRESS_TYPE:
                tlv = IPv6AddressTlv.read(tempCb, IPV6_NEIGHBOR_ADDRESS_TYPE);
                break;
            case BgpAttrNodeMultiTopologyId.ATTRNODE_MULTITOPOLOGY:
                tlv = BgpAttrNodeMultiTopologyId.read(tempCb);
                count = count++;
                log.debug("MultiTopologyId TLV cannot repeat more than once");
                if (count > 1) {
                    // length + 4 implies data contains type, length and value
                    throw new BgpParseException(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.OPTIONAL_ATTRIBUTE_ERROR, tempBuf.readBytes(length + Constants.TYPE_AND_LEN_AS_SHORT));
                }
                break;
            default:
                UnSupportedAttribute.skipBytes(tempCb, length);
        }
        linkDescriptor.add(tlv);
    }
    return linkDescriptor;
}
#end_block

#method_before
public final boolean isCapabilitySupported(short type, short afi, byte sAfi) {
    List<BgpValueType> capability = sessionInfo.remoteBgpCapability();
    ListIterator<BgpValueType> listIterator = capability.listIterator();
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv.getType() == type) {
            if (tlv.getType() == MultiProtocolExtnCapabilityTlv.TYPE) {
                MultiProtocolExtnCapabilityTlv temp = (MultiProtocolExtnCapabilityTlv) tlv;
                if ((temp.getAfi() == afi) && (temp.getSafi() == sAfi)) {
                    log.debug("multi prorotcol extension capabality TLV is true");
                    return true;
                }
            } else if (tlv.getType() == RpdCapabilityTlv.TYPE) {
                RpdCapabilityTlv temp = (RpdCapabilityTlv) tlv;
                if ((temp.getAfi() == afi) && (temp.getSafi() == sAfi)) {
                    log.debug("RPD capabality TLV is true");
                    return true;
                }
            }
        }
    }
    log.debug("IS capabality is not supported ");
    return false;
}
#method_after
public final boolean isCapabilitySupported(short type, short afi, byte sAfi) {
    List<BgpValueType> capability = sessionInfo.remoteBgpCapability();
    ListIterator<BgpValueType> listIterator = capability.listIterator();
    while (listIterator.hasNext()) {
        BgpValueType tlv = listIterator.next();
        if (tlv.getType() == type) {
            if (tlv.getType() == MultiProtocolExtnCapabilityTlv.TYPE) {
                MultiProtocolExtnCapabilityTlv temp = (MultiProtocolExtnCapabilityTlv) tlv;
                if ((temp.getAfi() == afi) && (temp.getSafi() == sAfi)) {
                    log.debug("Multi prorotcol extension capabality TLV is true");
                    return true;
                }
            } else if (tlv.getType() == RpdCapabilityTlv.TYPE) {
                RpdCapabilityTlv temp = (RpdCapabilityTlv) tlv;
                if ((temp.getAfi() == afi) && (temp.getSafi() == sAfi)) {
                    log.debug("RPD capabality TLV is true");
                    return true;
                }
            }
        }
    }
    log.debug("IS capabality is not supported ");
    return false;
}
#end_block

#method_before
public final void sendFlowSpecUpdateMessageToPeer(FlowSpecOperation operType, BgpFlowSpecRouteKey routeKey, BgpFlowSpecNlri flowSpec, WideCommunity wideCommunity) {
    List<BgpValueType> attributesList = new LinkedList<>();
    byte sessionType = sessionInfo.isIbgpSession() ? (byte) 0 : (byte) 1;
    byte sAfi = Constants.SAFI_FLOWSPEC_VALUE;
    boolean isFsCapabilitySet = isCapabilitySupported(MultiProtocolExtnCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_VALUE, Constants.SAFI_FLOWSPEC_VALUE);
    boolean isVpnFsCapabilitySet = isCapabilitySupported(MultiProtocolExtnCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_VALUE, Constants.VPN_SAFI_FLOWSPEC_VALUE);
    boolean isRpdCapabilitySet = isCapabilitySupported(RpdCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_RPD_VALUE, Constants.SAFI_FLOWSPEC_RPD_VALUE);
    boolean isVpnRpdCapabilitySet = isCapabilitySupported(RpdCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_RPD_VALUE, Constants.VPN_SAFI_FLOWSPEC_RDP_VALUE);
    if ((!isFsCapabilitySet) && (!isVpnFsCapabilitySet) && (!isRpdCapabilitySet) && (!isVpnRpdCapabilitySet)) {
        log.debug("Peer do not support BGP flow spec capability", channel.getRemoteAddress());
        return;
    }
    if (isVpnFsCapabilitySet) {
        sAfi = Constants.VPN_SAFI_FLOWSPEC_VALUE;
    } else if (isVpnRpdCapabilitySet) {
        sAfi = Constants.VPN_SAFI_FLOWSPEC_RDP_VALUE;
    }
    attributesList.add(new Origin((byte) 0));
    if (sessionType != 0) {
        // EBGP
        if (!bgpController.getConfig().getLargeASCapability()) {
            List<Short> aspathSet = new ArrayList<>();
            List<Short> aspathSeq = new ArrayList<>();
            aspathSeq.add((short) bgpController.getConfig().getAsNumber());
            AsPath asPath = new AsPath(aspathSet, aspathSeq);
            attributesList.add(asPath);
        } else {
            List<Integer> aspathSet = new ArrayList<>();
            List<Integer> aspathSeq = new ArrayList<>();
            aspathSeq.add(bgpController.getConfig().getAsNumber());
            As4Path as4Path = new As4Path(aspathSet, aspathSeq);
            attributesList.add(as4Path);
        }
        attributesList.add(new Med(0));
    } else {
        attributesList.add(new AsPath());
        attributesList.add(new Med(0));
        attributesList.add(new LocalPref(100));
    }
    attributesList.add(new BgpExtendedCommunity(flowSpec.fsActionTlv()));
    if (wideCommunity != null) {
        attributesList.add(wideCommunity);
    }
    if (operType == FlowSpecOperation.ADD) {
        attributesList.add(new MpReachNlri(flowSpec, Constants.AFI_FLOWSPEC_VALUE, sAfi));
    } else if (operType == FlowSpecOperation.DELETE) {
        attributesList.add(new MpUnReachNlri(flowSpec, Constants.AFI_FLOWSPEC_VALUE, sAfi));
    }
    BgpMessage msg = Controller.getBgpMessageFactory4().updateMessageBuilder().setBgpPathAttributes(attributesList).build();
    log.debug("Sending Flow spec Update message to {}", channel.getRemoteAddress());
    channel.write(Collections.singletonList(msg));
}
#method_after
public final void sendFlowSpecUpdateMessageToPeer(FlowSpecOperation operType, BgpFlowSpecRouteKey routeKey, BgpFlowSpecNlri flowSpec, WideCommunity wideCommunity) {
    List<BgpValueType> attributesList = new LinkedList<>();
    byte sessionType = sessionInfo.isIbgpSession() ? (byte) 0 : (byte) 1;
    byte sAfi = Constants.SAFI_FLOWSPEC_VALUE;
    boolean isFsCapabilitySet = isCapabilitySupported(MultiProtocolExtnCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_VALUE, Constants.SAFI_FLOWSPEC_VALUE);
    boolean isVpnFsCapabilitySet = isCapabilitySupported(MultiProtocolExtnCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_VALUE, Constants.VPN_SAFI_FLOWSPEC_VALUE);
    boolean isRpdCapabilitySet = isCapabilitySupported(RpdCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_RPD_VALUE, Constants.SAFI_FLOWSPEC_RPD_VALUE);
    boolean isVpnRpdCapabilitySet = isCapabilitySupported(RpdCapabilityTlv.TYPE, Constants.AFI_FLOWSPEC_RPD_VALUE, Constants.VPN_SAFI_FLOWSPEC_RDP_VALUE);
    if ((!isFsCapabilitySet) && (!isVpnFsCapabilitySet) && (!isRpdCapabilitySet) && (!isVpnRpdCapabilitySet)) {
        log.debug("Peer do not support BGP flow spec capability", channel.getRemoteAddress());
        return;
    }
    if (isVpnFsCapabilitySet) {
        sAfi = Constants.VPN_SAFI_FLOWSPEC_VALUE;
    } else if (isVpnRpdCapabilitySet) {
        sAfi = Constants.VPN_SAFI_FLOWSPEC_RDP_VALUE;
    }
    attributesList.add(new Origin((byte) 0));
    if (sessionType != 0) {
        // EBGP
        if (!bgpController.getConfig().getLargeASCapability()) {
            List<Short> aspathSet = new ArrayList<>();
            List<Short> aspathSeq = new ArrayList<>();
            aspathSeq.add((short) bgpController.getConfig().getAsNumber());
            AsPath asPath = new AsPath(aspathSet, aspathSeq);
            attributesList.add(asPath);
        } else {
            List<Integer> aspathSet = new ArrayList<>();
            List<Integer> aspathSeq = new ArrayList<>();
            aspathSeq.add(bgpController.getConfig().getAsNumber());
            As4Path as4Path = new As4Path(aspathSet, aspathSeq);
            attributesList.add(as4Path);
        }
        attributesList.add(new Med(0));
    } else {
        attributesList.add(new AsPath());
        attributesList.add(new Med(0));
        attributesList.add(new LocalPref(100));
    }
    attributesList.add(new BgpExtendedCommunity(flowSpec.fsActionTlv()));
    if (wideCommunity != null) {
        attributesList.add(wideCommunity);
    }
    if (operType == FlowSpecOperation.ADD) {
        attributesList.add(new MpReachNlri(flowSpec, Constants.AFI_FLOWSPEC_VALUE, sAfi));
    } else if (operType == FlowSpecOperation.DELETE) {
        attributesList.add(new MpUnReachNlri(flowSpec, Constants.AFI_FLOWSPEC_VALUE, sAfi));
    }
    BgpMessage msg = Controller.getBgpMessageFactory4().updateMessageBuilder().setBgpPathAttributes(attributesList).build();
    log.debug("Sending flow spec update message to {}", channel.getRemoteAddress());
    channel.write(Collections.singletonList(msg));
}
#end_block

#method_before
public static BgpPathAttributes read(ChannelBuffer cb) throws BgpParseException {
    BgpValueType pathAttribute = null;
    List<BgpValueType> pathAttributeList = new LinkedList<>();
    boolean isOrigin = false;
    boolean isAsPath = false;
    boolean isNextHop = false;
    boolean isMpReach = false;
    boolean isMpUnReach = false;
    while (cb.readableBytes() > 0) {
        cb.markReaderIndex();
        byte flags = cb.readByte();
        byte typeCode = cb.readByte();
        cb.resetReaderIndex();
        switch(typeCode) {
            case Origin.ORIGIN_TYPE:
                pathAttribute = Origin.read(cb);
                isOrigin = ((Origin) pathAttribute).isOriginSet();
                break;
            case AsPath.ASPATH_TYPE:
                pathAttribute = AsPath.read(cb);
                isAsPath = ((AsPath) pathAttribute).isaspathSet();
                break;
            case As4Path.AS4PATH_TYPE:
                pathAttribute = As4Path.read(cb);
                break;
            case NextHop.NEXTHOP_TYPE:
                pathAttribute = NextHop.read(cb);
                isNextHop = ((NextHop) pathAttribute).isNextHopSet();
                break;
            case Med.MED_TYPE:
                pathAttribute = Med.read(cb);
                break;
            case LocalPref.LOCAL_PREF_TYPE:
                pathAttribute = LocalPref.read(cb);
                break;
            case MpReachNlri.MPREACHNLRI_TYPE:
                pathAttribute = MpReachNlri.read(cb);
                isMpReach = ((MpReachNlri) pathAttribute).isMpReachNlriSet();
                break;
            case MpUnReachNlri.MPUNREACHNLRI_TYPE:
                pathAttribute = MpUnReachNlri.read(cb);
                isMpUnReach = ((MpUnReachNlri) pathAttribute).isMpUnReachNlriSet();
                break;
            case LINK_STATE_ATTRIBUTE_TYPE:
                pathAttribute = LinkStateAttributes.read(cb);
                break;
            case EXTENDED_COMMUNITY_TYPE:
                pathAttribute = BgpExtendedCommunity.read(cb);
                break;
            case WideCommunity.TYPE:
                pathAttribute = WideCommunity.read(cb);
                break;
            default:
                log.info("skip bytes for unsupported attribute types");
                UnSupportedAttribute.read(cb);
        }
        pathAttributeList.add(pathAttribute);
    }
    checkMandatoryAttr(isOrigin, isAsPath, isNextHop, isMpReach, isMpUnReach);
    // TODO:if mp_reach or mp_unreach not present ignore the packet
    return new BgpPathAttributes(pathAttributeList);
}
#method_after
public static BgpPathAttributes read(ChannelBuffer cb) throws BgpParseException {
    BgpValueType pathAttribute = null;
    List<BgpValueType> pathAttributeList = new LinkedList<>();
    boolean isOrigin = false;
    boolean isAsPath = false;
    boolean isNextHop = false;
    boolean isMpReach = false;
    boolean isMpUnReach = false;
    while (cb.readableBytes() > 0) {
        cb.markReaderIndex();
        byte flags = cb.readByte();
        byte typeCode = cb.readByte();
        cb.resetReaderIndex();
        switch(typeCode) {
            case Origin.ORIGIN_TYPE:
                pathAttribute = Origin.read(cb);
                isOrigin = ((Origin) pathAttribute).isOriginSet();
                break;
            case AsPath.ASPATH_TYPE:
                pathAttribute = AsPath.read(cb);
                isAsPath = ((AsPath) pathAttribute).isaspathSet();
                break;
            case As4Path.AS4PATH_TYPE:
                pathAttribute = As4Path.read(cb);
                break;
            case NextHop.NEXTHOP_TYPE:
                pathAttribute = NextHop.read(cb);
                isNextHop = ((NextHop) pathAttribute).isNextHopSet();
                break;
            case Med.MED_TYPE:
                pathAttribute = Med.read(cb);
                break;
            case LocalPref.LOCAL_PREF_TYPE:
                pathAttribute = LocalPref.read(cb);
                break;
            case MpReachNlri.MPREACHNLRI_TYPE:
                pathAttribute = MpReachNlri.read(cb);
                isMpReach = ((MpReachNlri) pathAttribute).isMpReachNlriSet();
                break;
            case MpUnReachNlri.MPUNREACHNLRI_TYPE:
                pathAttribute = MpUnReachNlri.read(cb);
                isMpUnReach = ((MpUnReachNlri) pathAttribute).isMpUnReachNlriSet();
                break;
            case LINK_STATE_ATTRIBUTE_TYPE:
                pathAttribute = LinkStateAttributes.read(cb);
                break;
            case EXTENDED_COMMUNITY_TYPE:
                pathAttribute = BgpExtendedCommunity.read(cb);
                break;
            case WideCommunity.TYPE:
                pathAttribute = WideCommunity.read(cb);
                break;
            default:
                log.debug("Skip bytes for unsupported attribute types");
                UnSupportedAttribute.read(cb);
        }
        pathAttributeList.add(pathAttribute);
    }
    checkMandatoryAttr(isOrigin, isAsPath, isNextHop, isMpReach, isMpUnReach);
    // TODO:if mp_reach or mp_unreach not present ignore the packet
    return new BgpPathAttributes(pathAttributeList);
}
#end_block

#method_before
public static void checkMandatoryAttr(boolean isOrigin, boolean isAsPath, boolean isNextHop, boolean isMpReach, boolean isMpUnReach) throws BgpParseException {
    // Mandatory attributes validation not required for MP_UNREACH
    if (isMpUnReach) {
        return;
    }
    if (!isOrigin) {
        log.debug("Mandatory Attributes not Present");
        Validation.validateType(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MISSING_WELLKNOWN_ATTRIBUTE, Origin.ORIGIN_TYPE);
    }
    if (!isAsPath) {
        log.debug("Mandatory Attributes not Present");
        Validation.validateType(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MISSING_WELLKNOWN_ATTRIBUTE, AsPath.ASPATH_TYPE);
    }
    if (!isMpUnReach && !isMpReach && !isNextHop) {
        log.debug("Mandatory Attributes not Present");
        Validation.validateType(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MISSING_WELLKNOWN_ATTRIBUTE, NextHop.NEXTHOP_TYPE);
    }
}
#method_after
public static void checkMandatoryAttr(boolean isOrigin, boolean isAsPath, boolean isNextHop, boolean isMpReach, boolean isMpUnReach) throws BgpParseException {
    // Mandatory attributes validation not required for MP_UNREACH
    if (isMpUnReach) {
        return;
    }
    if (!isOrigin) {
        log.debug("Mandatory attributes not Present");
        Validation.validateType(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MISSING_WELLKNOWN_ATTRIBUTE, Origin.ORIGIN_TYPE);
    }
    if (!isAsPath) {
        log.debug("Mandatory attributes not Present");
        Validation.validateType(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MISSING_WELLKNOWN_ATTRIBUTE, AsPath.ASPATH_TYPE);
    }
    if (!isMpUnReach && !isMpReach && !isNextHop) {
        log.debug("Mandatory attributes not Present");
        Validation.validateType(BgpErrorType.UPDATE_MESSAGE_ERROR, BgpErrorType.MISSING_WELLKNOWN_ATTRIBUTE, NextHop.NEXTHOP_TYPE);
    }
}
#end_block

#method_before
public boolean validateFlowSpec() {
    if (flowSpecCapability() != null) {
        String flowSpec = flowSpecCapability();
        if ((!flowSpec.equals("IPV4")) && (!flowSpec.equals("VPNV4")) && (!flowSpec.equals("IPV4_VPNV4"))) {
            log.info("flow specification capabality is false");
            return false;
        }
    }
    log.info("flow specification capabality is true");
    return true;
}
#method_after
public boolean validateFlowSpec() {
    if (flowSpecCapability() != null) {
        String flowSpec = flowSpecCapability();
        if ((!flowSpec.equals("IPV4")) && (!flowSpec.equals("VPNV4")) && (!flowSpec.equals("IPV4_VPNV4"))) {
            log.debug("Flow specification capabality is false");
            return false;
        }
    }
    log.debug("Flow specification capabality is true");
    return true;
}
#end_block

#method_before
public boolean validateBgpPeers() {
    List<BgpPeerConfig> nodes;
    String connectMode;
    nodes = bgpPeer();
    for (int i = 0; i < nodes.size(); i++) {
        connectMode = nodes.get(i).connectMode();
        if ((IpAddress.valueOf(nodes.get(i).hostname()) == null) || !validateRemoteAs(nodes.get(i).asNumber()) || !validatePeerHoldTime(nodes.get(i).holdTime()) || !(connectMode.equals(PEER_CONNECT_ACTIVE) || connectMode.equals(PEER_CONNECT_PASSIVE))) {
            log.info("BGP peer configration false");
            return false;
        }
    }
    log.info("BGP peer configration true");
    return true;
}
#method_after
public boolean validateBgpPeers() {
    List<BgpPeerConfig> nodes;
    String connectMode;
    nodes = bgpPeer();
    for (int i = 0; i < nodes.size(); i++) {
        connectMode = nodes.get(i).connectMode();
        if ((IpAddress.valueOf(nodes.get(i).hostname()) == null) || !validateRemoteAs(nodes.get(i).asNumber()) || !validatePeerHoldTime(nodes.get(i).holdTime()) || !(connectMode.equals(PEER_CONNECT_ACTIVE) || connectMode.equals(PEER_CONNECT_PASSIVE))) {
            log.debug("BGP peer configration false");
            return false;
        }
    }
    log.debug("BGP peer configration true");
    return true;
}
#end_block

#method_before
public BgpDpid add(final NodeDescriptors value) {
    log.info("BgpDpid :: add function");
    if (value != null) {
        List<BgpValueType> subTlvs = value.getSubTlvs();
        ListIterator<BgpValueType> listIterator = subTlvs.listIterator();
        while (listIterator.hasNext()) {
            BgpValueType tlv = listIterator.next();
            if (tlv.getType() == AutonomousSystemTlv.TYPE) {
                this.stringBuilder.append(":ASN=").append(((AutonomousSystemTlv) tlv).getAsNum());
            } else if (tlv.getType() == BgpLSIdentifierTlv.TYPE) {
                this.stringBuilder.append(":DOMAINID=").append(((BgpLSIdentifierTlv) tlv).getBgpLsIdentifier());
            } else if (tlv.getType() == NodeDescriptors.IGP_ROUTERID_TYPE) {
                if (tlv instanceof IsIsNonPseudonode) {
                    this.stringBuilder.append(":ISOID=").append(isoNodeIdString(((IsIsNonPseudonode) tlv).getIsoNodeId()));
                } else if (tlv instanceof IsIsPseudonode) {
                    IsIsPseudonode isisPseudonode = ((IsIsPseudonode) tlv);
                    this.stringBuilder.append(":ISOID=").append(isoNodeIdString(((IsIsPseudonode) tlv).getIsoNodeId()));
                    this.stringBuilder.append(":PSN=").append(isisPseudonode.getPsnIdentifier());
                } else if (tlv instanceof OspfNonPseudonode) {
                    this.stringBuilder.append(":RID=").append(((OspfNonPseudonode) tlv).getrouterID());
                } else if (tlv instanceof OspfPseudonode) {
                    this.stringBuilder.append(":RID=").append(((OspfPseudonode) tlv).getrouterID());
                }
            }
        }
    }
    return this;
}
#method_after
public BgpDpid add(final NodeDescriptors value) {
    log.debug("BgpDpid :: add function");
    if (value != null) {
        List<BgpValueType> subTlvs = value.getSubTlvs();
        ListIterator<BgpValueType> listIterator = subTlvs.listIterator();
        while (listIterator.hasNext()) {
            BgpValueType tlv = listIterator.next();
            if (tlv.getType() == AutonomousSystemTlv.TYPE) {
                this.stringBuilder.append(":ASN=").append(((AutonomousSystemTlv) tlv).getAsNum());
            } else if (tlv.getType() == BgpLSIdentifierTlv.TYPE) {
                this.stringBuilder.append(":DOMAINID=").append(((BgpLSIdentifierTlv) tlv).getBgpLsIdentifier());
            } else if (tlv.getType() == NodeDescriptors.IGP_ROUTERID_TYPE) {
                if (tlv instanceof IsIsNonPseudonode) {
                    this.stringBuilder.append(":ISOID=").append(isoNodeIdString(((IsIsNonPseudonode) tlv).getIsoNodeId()));
                } else if (tlv instanceof IsIsPseudonode) {
                    IsIsPseudonode isisPseudonode = ((IsIsPseudonode) tlv);
                    this.stringBuilder.append(":ISOID=").append(isoNodeIdString(((IsIsPseudonode) tlv).getIsoNodeId()));
                    this.stringBuilder.append(":PSN=").append(isisPseudonode.getPsnIdentifier());
                } else if (tlv instanceof OspfNonPseudonode) {
                    this.stringBuilder.append(":RID=").append(((OspfNonPseudonode) tlv).getrouterID());
                } else if (tlv instanceof OspfPseudonode) {
                    this.stringBuilder.append(":RID=").append(((OspfPseudonode) tlv).getrouterID());
                }
            }
        }
    }
    return this;
}
#end_block

#method_before
public static URI uri(String value) {
    try {
        return new URI(SCHEME, value, null);
    } catch (URISyntaxException e) {
        log.info("Exception BgpId URI: " + e.toString());
    }
    return null;
}
#method_after
public static URI uri(String value) {
    try {
        return new URI(SCHEME, value, null);
    } catch (URISyntaxException e) {
        log.debug("Exception BgpId URI: " + e.toString());
    }
    return null;
}
#end_block

#method_before
private void displayBgpConfiguration() {
    try {
        this.bgpController = get(BgpController.class);
        bgpCfg = bgpController.getConfig();
        print("RouterID = %s, ASNumber = %s, MaxSession = %s, HoldingTime = %s, LsCapabality = %s," + " LargeAsCapabality = %s, FlowSpecCapabality = %s", bgpCfg.getRouterId(), bgpCfg.getAsNumber(), bgpCfg.getMaxSession(), bgpCfg.getHoldTime(), bgpCfg.getLsCapability(), bgpCfg.getLargeASCapability(), bgpCfg.flowSpecCapability());
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Configuration: {}", e.getMessage());
    }
}
#method_after
private void displayBgpConfiguration() {
    try {
        this.bgpController = get(BgpController.class);
        bgpCfg = bgpController.getConfig();
        print("RouterID = %s, ASNumber = %s, MaxSession = %s, HoldingTime = %s, LsCapabality = %s," + " LargeAsCapabality = %s, FlowSpecCapabality = %s", bgpCfg.getRouterId(), bgpCfg.getAsNumber(), bgpCfg.getMaxSession(), bgpCfg.getHoldTime(), bgpCfg.getLsCapability(), bgpCfg.getLargeASCapability(), bgpCfg.flowSpecCapability());
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP configuration: {}", e.getMessage());
    }
}
#end_block

#method_before
private void displayBgpPeerConfiguration() {
    try {
        this.bgpController = get(BgpController.class);
        BgpCfg bgpCfg = bgpController.getConfig();
        if (bgpCfg == null) {
            return;
        }
        TreeMap<String, BgpPeerCfg> displayPeerTree = bgpCfg.getPeerTree();
        Set<String> peerKey = displayPeerTree.keySet();
        if (peer != null) {
            if (peerKey.size() > 0) {
                for (String peerIdKey : peerKey) {
                    bgpPeerCfg = displayPeerTree.get(peerIdKey);
                    bgpConnectPeer = bgpPeerCfg.connectPeer();
                    if (peerIdKey.equals(peer)) {
                        print("PeerRouterID = %s, PeerHoldingTime = %s, ASNumber = %s, PeerState = %s," + " PeerPort = %s, ConnectRetryCounter = %s", peer, bgpPeerCfg.getHoldtime(), bgpPeerCfg.getAsNumber(), bgpPeerCfg.getState(), bgpConnectPeer.getPeerPort(), bgpConnectPeer.getConnectRetryCounter());
                    }
                }
            }
        } else {
            if (peerKey.size() > 0) {
                for (String peerIdKey : peerKey) {
                    bgpPeerCfg = displayPeerTree.get(peerIdKey);
                    bgpConnectPeer = bgpPeerCfg.connectPeer();
                    print("PeerRouterID = %s, PeerHoldingTime = %s, ASNumber = %s, PeerState = %s, PeerPort = %s," + " ConnectRetryCounter = %s", bgpPeerCfg.getPeerRouterId(), bgpPeerCfg.getHoldtime(), bgpPeerCfg.getAsNumber(), bgpPeerCfg.getState(), bgpConnectPeer.getPeerPort(), bgpConnectPeer.getConnectRetryCounter());
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP Peer Configuration: {}", e.getMessage());
    }
}
#method_after
private void displayBgpPeerConfiguration() {
    try {
        this.bgpController = get(BgpController.class);
        BgpCfg bgpCfg = bgpController.getConfig();
        if (bgpCfg == null) {
            return;
        }
        TreeMap<String, BgpPeerCfg> displayPeerTree = bgpCfg.getPeerTree();
        Set<String> peerKey = displayPeerTree.keySet();
        if (peer != null) {
            if (peerKey.size() > 0) {
                for (String peerIdKey : peerKey) {
                    bgpPeerCfg = displayPeerTree.get(peerIdKey);
                    bgpConnectPeer = bgpPeerCfg.connectPeer();
                    if (peerIdKey.equals(peer)) {
                        print("PeerRouterID = %s, PeerHoldingTime = %s, ASNumber = %s, PeerState = %s," + " PeerPort = %s, ConnectRetryCounter = %s", peer, bgpPeerCfg.getHoldtime(), bgpPeerCfg.getAsNumber(), bgpPeerCfg.getState(), bgpConnectPeer.getPeerPort(), bgpConnectPeer.getConnectRetryCounter());
                    }
                }
            }
        } else {
            if (peerKey.size() > 0) {
                for (String peerIdKey : peerKey) {
                    bgpPeerCfg = displayPeerTree.get(peerIdKey);
                    bgpConnectPeer = bgpPeerCfg.connectPeer();
                    print("PeerRouterID = %s, PeerHoldingTime = %s, ASNumber = %s, PeerState = %s, PeerPort = %s," + " ConnectRetryCounter = %s", bgpPeerCfg.getPeerRouterId(), bgpPeerCfg.getHoldtime(), bgpPeerCfg.getAsNumber(), bgpPeerCfg.getState(), bgpConnectPeer.getPeerPort(), bgpConnectPeer.getConnectRetryCounter());
                }
            }
        }
    } catch (Exception e) {
        log.debug("Error occurred while displaying BGP peer configuration: {}", e.getMessage());
    }
}
#end_block

#method_before
public static BgpNodeLSNlriVer4 read(ChannelBuffer cb, short afi, byte safi) throws BgpParseException {
    boolean isVpn = false;
    RouteDistinguisher routeDistinguisher = null;
    if ((afi == Constants.AFI_VALUE) && (safi == Constants.VPN_SAFI_VALUE)) {
        routeDistinguisher = new RouteDistinguisher();
        routeDistinguisher = RouteDistinguisher.read(cb);
        isVpn = true;
    } else {
        isVpn = false;
    }
    byte protocolId = cb.readByte();
    long identifier = cb.readLong();
    log.info("Parse Local Node Descriptors");
    BgpNodeLSIdentifier localNodeDescriptors = new BgpNodeLSIdentifier();
    localNodeDescriptors = BgpNodeLSIdentifier.parseLocalNodeDescriptors(cb, protocolId);
    return new BgpNodeLSNlriVer4(identifier, protocolId, localNodeDescriptors, isVpn, routeDistinguisher);
}
#method_after
public static BgpNodeLSNlriVer4 read(ChannelBuffer cb, short afi, byte safi) throws BgpParseException {
    boolean isVpn = false;
    RouteDistinguisher routeDistinguisher = null;
    if ((afi == Constants.AFI_VALUE) && (safi == Constants.VPN_SAFI_VALUE)) {
        routeDistinguisher = new RouteDistinguisher();
        routeDistinguisher = RouteDistinguisher.read(cb);
        isVpn = true;
    } else {
        isVpn = false;
    }
    byte protocolId = cb.readByte();
    long identifier = cb.readLong();
    log.debug("Parse local node descriptors");
    BgpNodeLSIdentifier localNodeDescriptors = new BgpNodeLSIdentifier();
    localNodeDescriptors = BgpNodeLSIdentifier.parseLocalNodeDescriptors(cb, protocolId);
    return new BgpNodeLSNlriVer4(identifier, protocolId, localNodeDescriptors, isVpn, routeDistinguisher);
}
#end_block

#method_before
public void run() {
    try {
        final ServerBootstrap bootstrap = createServerBootStrap();
        bootstrap.setOption("reuseAddr", true);
        bootstrap.setOption("child.keepAlive", true);
        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.sendBufferSize", Controller.SEND_BUFFER_SIZE);
        ChannelPipelineFactory pfact = new PcepPipelineFactory(this);
        bootstrap.setPipelineFactory(pfact);
        InetSocketAddress sa = new InetSocketAddress(pcepPort);
        cg = new DefaultChannelGroup();
        cg.add(bootstrap.bind(sa));
        log.info("Listening for PCC connection on {}", sa);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void run() {
    try {
        final ServerBootstrap bootstrap = createServerBootStrap();
        bootstrap.setOption("reuseAddr", true);
        bootstrap.setOption("child.keepAlive", true);
        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.sendBufferSize", Controller.SEND_BUFFER_SIZE);
        ChannelPipelineFactory pfact = new PcepPipelineFactory(this);
        bootstrap.setPipelineFactory(pfact);
        InetSocketAddress sa = new InetSocketAddress(pcepPort);
        cg = new DefaultChannelGroup();
        cg.add(bootstrap.bind(sa));
        log.debug("Listening for PCC connection on {}", sa);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Override
public void removeConnectedClient(PccId pccId) {
    connectedClients.remove(pccId);
    for (PcepClientListener l : pcepClientListener) {
        log.warn("removal for {}", pccId.toString());
        l.clientDisconnected(pccId);
    }
}
#method_after
@Override
public void removeConnectedClient(PccId pccId) {
    connectedClients.remove(pccId);
    for (PcepClientListener l : pcepClientListener) {
        log.warn("Removal for {}", pccId.toString());
        l.clientDisconnected(pccId);
    }
}
#end_block

#method_before
private SummaryFlowEntryWithLoad loadSummaryPortInternal(ConnectPoint cp) {
    checkPermission(STATISTIC_READ);
    Set<FlowEntry> currentStats;
    Set<FlowEntry> previousStats;
    TypedStatistics typedStatistics;
    synchronized (statisticStore) {
        currentStats = statisticStore.getCurrentStatistic(cp);
        if (currentStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        previousStats = statisticStore.getPreviousStatistic(cp);
        if (previousStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        // copy to local flow entry
        typedStatistics = new TypedStatistics(currentStats, previousStats);
        // Check for validity of this stats data
        checkLoadValidity(currentStats, previousStats);
    }
    // current and previous set is not empty!
    Set<FlowEntry> currentSet = typedStatistics.current();
    Set<FlowEntry> previousSet = typedStatistics.previous();
    PollInterval pollIntervalInstance = PollInterval.getInstance();
    Load totalLoad = new DefaultLoad(aggregateBytesSet(currentSet), aggregateBytesSet(previousSet), pollIntervalInstance.getAvgPollInterval());
    Map<FlowRule, FlowEntry> currentMap;
    Map<FlowRule, FlowEntry> previousMap;
    currentMap = typedStatistics.currentImmediate();
    previousMap = typedStatistics.previousImmediate();
    Load immediateLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getPollInterval());
    currentMap = typedStatistics.currentShort();
    previousMap = typedStatistics.previousShort();
    Load shortLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getPollInterval());
    currentMap = typedStatistics.currentMid();
    previousMap = typedStatistics.previousMid();
    Load midLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getMidPollInterval());
    currentMap = typedStatistics.currentLong();
    previousMap = typedStatistics.previousLong();
    Load longLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getLongPollInterval());
    currentMap = typedStatistics.currentUnknown();
    previousMap = typedStatistics.previousUnknown();
    Load unknownLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getPollInterval());
    return new SummaryFlowEntryWithLoad(cp, totalLoad, immediateLoad, shortLoad, midLoad, longLoad, unknownLoad);
}
#method_after
private SummaryFlowEntryWithLoad loadSummaryPortInternal(ConnectPoint cp) {
    checkPermission(STATISTIC_READ);
    Set<FlowEntry> currentStats;
    Set<FlowEntry> previousStats;
    TypedStatistics typedStatistics;
    synchronized (statisticStore) {
        currentStats = statisticStore.getCurrentStatistic(cp);
        if (currentStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        previousStats = statisticStore.getPreviousStatistic(cp);
        if (previousStats == null) {
            return new SummaryFlowEntryWithLoad(cp, new DefaultLoad());
        }
        // copy to local flow entry
        typedStatistics = new TypedStatistics(currentStats, previousStats);
        // Check for validity of this stats data
        checkLoadValidity(currentStats, previousStats);
    }
    // current and previous set is not empty!
    Set<FlowEntry> currentSet = typedStatistics.current();
    Set<FlowEntry> previousSet = typedStatistics.previous();
    PollInterval pollIntervalInstance = PollInterval.getInstance();
    // We assume that default pollInterval is flowPollFrequency in case adaptiveFlowSampling is true or false
    Load totalLoad = new DefaultLoad(aggregateBytesSet(currentSet), aggregateBytesSet(previousSet), pollIntervalInstance.getPollInterval());
    Map<FlowRule, FlowEntry> currentMap;
    Map<FlowRule, FlowEntry> previousMap;
    currentMap = typedStatistics.currentImmediate();
    previousMap = typedStatistics.previousImmediate();
    Load immediateLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getPollInterval());
    currentMap = typedStatistics.currentShort();
    previousMap = typedStatistics.previousShort();
    Load shortLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getPollInterval());
    currentMap = typedStatistics.currentMid();
    previousMap = typedStatistics.previousMid();
    Load midLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getMidPollInterval());
    currentMap = typedStatistics.currentLong();
    previousMap = typedStatistics.previousLong();
    Load longLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getLongPollInterval());
    currentMap = typedStatistics.currentUnknown();
    previousMap = typedStatistics.previousUnknown();
    Load unknownLoad = new DefaultLoad(aggregateBytesMap(currentMap), aggregateBytesMap(previousMap), pollIntervalInstance.getPollInterval());
    return new SummaryFlowEntryWithLoad(cp, totalLoad, immediateLoad, shortLoad, midLoad, longLoad, unknownLoad);
}
#end_block

#method_before
private long getLiveTypePollInterval(FlowEntry.FlowLiveType liveType) {
    // returns the flow live type poll interval value
    PollInterval pollIntervalInstance = PollInterval.getInstance();
    switch(liveType) {
        case LONG:
            return pollIntervalInstance.getLongPollInterval();
        case MID:
            return pollIntervalInstance.getMidPollInterval();
        case SHORT:
        case IMMEDIATE:
        default:
            return pollIntervalInstance.getPollInterval();
    }
}
#method_after
private long getLiveTypePollInterval(FlowEntry.FlowLiveType liveType) {
    // returns the flow live type poll interval value
    PollInterval pollIntervalInstance = PollInterval.getInstance();
    switch(liveType) {
        case LONG:
            return pollIntervalInstance.getLongPollInterval();
        case MID:
            return pollIntervalInstance.getMidPollInterval();
        case SHORT:
        case IMMEDIATE:
        default:
            // UNKNOWN
            return pollIntervalInstance.getPollInterval();
    }
}
#end_block

#method_before
private void checkLoadValidity(Set<FlowEntry> current, Set<FlowEntry> previous) {
    current.stream().forEach(c -> {
        FlowEntry f = previous.stream().filter(p -> c.equals(p)).findAny().orElse(null);
        if (f != null && c.bytes() < f.bytes()) {
            log.debug("FlowStatisticManager:checkLoadValidity():" + "Error: " + c + " :Previous bytes=" + f.bytes() + " is larger than current bytes=" + c.bytes() + " !!!");
        }
    });
}
#method_after
private void checkLoadValidity(Set<FlowEntry> current, Set<FlowEntry> previous) {
    current.forEach(c -> {
        FlowEntry f = previous.stream().filter(p -> c.equals(p)).findAny().orElse(null);
        if (f != null && c.bytes() < f.bytes()) {
            log.debug("FlowStatisticManager:checkLoadValidity():" + "Error: " + c + " :Previous bytes=" + f.bytes() + " is larger than current bytes=" + c.bytes() + " !!!");
        }
    });
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    modified(context);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started with flowPollFrequency = {}, adaptiveFlowSampling = {}", flowPollFrequency, adaptiveFlowSampling);
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    modified(context);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started with flowPollFrequency = {}, adaptiveFlowSampling = {}", flowPollFrequency, adaptiveFlowSampling);
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    stopCollectors();
    providerRegistry.unregister(this);
    providerService = null;
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    stopCollectors();
    providerRegistry.unregister(this);
    providerService = null;
    log.info("Stopped");
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
    boolean newAdaptiveFlowSampling;
    String s = get(properties, "adaptiveFlowSampling");
    newAdaptiveFlowSampling = isNullOrEmpty(s) ? adaptiveFlowSampling : Boolean.parseBoolean(s.trim());
    if (newAdaptiveFlowSampling != adaptiveFlowSampling) {
        // stop previous collector
        stopCollectors();
        adaptiveFlowSampling = newAdaptiveFlowSampling;
        // create new collectors
        createCollectors();
    }
    log.info("Settings: adaptiveFlowSampling={}", adaptiveFlowSampling);
}
#method_after
@Modified
protected void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
    boolean newAdaptiveFlowSampling;
    String s = get(properties, "adaptiveFlowSampling");
    newAdaptiveFlowSampling = isNullOrEmpty(s) ? adaptiveFlowSampling : Boolean.parseBoolean(s.trim());
    if (newAdaptiveFlowSampling != adaptiveFlowSampling) {
        // stop previous collector
        stopCollectors();
        adaptiveFlowSampling = newAdaptiveFlowSampling;
        // create new collectors
        createCollectors();
    }
    log.info("Settings: adaptiveFlowSampling={}", adaptiveFlowSampling);
}
#end_block

#method_before
private void createCollector(OpenFlowSwitch sw) {
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Constructor
        NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(driverService, sw, flowPollFrequency);
        fsc.start();
        afsCollectors.put(new Dpid(sw.getId()), fsc);
    } else {
        FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
        fsc.start();
        simpleCollectors.put(new Dpid(sw.getId()), fsc);
    }
    TableStatisticsCollector tsc = new TableStatisticsCollector(timer, sw, flowPollFrequency);
    tsc.start();
    tableStatsCollectors.put(new Dpid(sw.getId()), tsc);
}
#method_after
private void createCollector(OpenFlowSwitch sw) {
    if (sw == null) {
        return;
    }
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Constructor
        NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(driverService, sw, flowPollFrequency);
        fsc.start();
        stopCollectorIfNeeded(afsCollectors.put(new Dpid(sw.getId()), fsc));
    } else {
        FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
        fsc.start();
        stopCollectorIfNeeded(simpleCollectors.put(new Dpid(sw.getId()), fsc));
    }
    TableStatisticsCollector tsc = new TableStatisticsCollector(timer, sw, flowPollFrequency);
    tsc.start();
    stopCollectorIfNeeded(tableStatsCollectors.put(new Dpid(sw.getId()), tsc));
}
#end_block

#method_before
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    checkNotNull(batch);
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    Dpid dpid = Dpid.dpid(batch.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()), Optional.of(driverService));
        NewAdaptiveFlowStatsCollector collector = afsCollectors.get(dpid);
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#method_after
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    checkNotNull(batch);
    Dpid dpid = Dpid.dpid(batch.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    // If switch no longer exists, simply return.
    if (sw == null) {
        Set<FlowRule> failures = ImmutableSet.copyOf(Lists.transform(batch.getOperations(), e -> e.target()));
        providerService.batchOperationCompleted(batch.id(), new CompletedBatchOperation(false, failures, batch.deviceId()));
        return;
    }
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()), Optional.of(driverService));
        NewAdaptiveFlowStatsCollector collector = afsCollectors.get(dpid);
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#end_block

#method_before
@Override
public void switchAdded(Dpid dpid) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    createCollector(controller.getSwitch(dpid));
}
#method_after
@Override
public void switchAdded(Dpid dpid) {
    createCollector(controller.getSwitch(dpid));
}
#end_block

#method_before
@Override
public void switchRemoved(Dpid dpid) {
    if (adaptiveFlowSampling) {
        NewAdaptiveFlowStatsCollector collector = afsCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    } else {
        FlowStatsCollector collector = simpleCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    }
    TableStatisticsCollector tsc = tableStatsCollectors.remove(dpid);
    if (tsc != null) {
        tsc.stop();
    }
}
#method_after
@Override
public void switchRemoved(Dpid dpid) {
    if (adaptiveFlowSampling) {
        stopCollectorIfNeeded(afsCollectors.remove(dpid));
    } else {
        stopCollectorIfNeeded(simpleCollectors.remove(dpid));
    }
    stopCollectorIfNeeded(tableStatsCollectors.remove(dpid));
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(deviceId, removed, driverService).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            OFErrorMsg error = (OFErrorMsg) msg;
            if (error.getErrType() == OFErrorType.FLOW_MOD_FAILED) {
                OFFlowModFailedErrorMsg fmFailed = (OFFlowModFailedErrorMsg) error;
                if (fmFailed.getData().getParsedMessage().isPresent()) {
                    OFMessage m = fmFailed.getData().getParsedMessage().get();
                    OFFlowMod fm = (OFFlowMod) m;
                    InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                    if (entry != null) {
                        entry.appendFailure(new FlowEntryBuilder(deviceId, fm, driverService).build());
                    } else {
                        log.error("No matching batch for this error: {}", error);
                    }
                } else {
                    // FIXME: Potentially add flowtracking to avoid this message.
                    log.error("Flow installation failed but switch didn't" + " tell us which one.");
                }
            }
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (providerService == null) {
        // We are shutting down, nothing to be done
        return;
    }
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(deviceId, removed, driverService).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.TABLE) {
                pushTableStatistics(dpid, (OFTableStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            handleErrorMsg(deviceId, msg);
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
@Override
public long life() {
    return life;
}
#method_after
@Override
public long life() {
    return life(SECONDS);
}
#end_block

#method_before
@Override
public long life() {
    return life;
}
#method_after
@Override
public long life(TimeUnit timeUnit) {
    return timeUnit.convert(life, NANOSECONDS);
}
#end_block

#method_before
@Override
public void setLife(long life) {
    this.life = life;
}
#method_after
@Override
public void setLife(long life) {
    setLife(life, SECONDS);
}
#end_block

#method_before
@Override
public void setLife(long life) {
    this.life = life;
}
#method_after
@Override
public void setLife(long life, TimeUnit timeUnit) {
    this.life = timeUnit.toNanos(life);
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    configService.registerProperties(getClass());
    idGenerator = coreService.getIdGenerator(FlowRuleService.FLOW_OP_TOPIC);
    local = clusterService.getLocalNode().id();
    messageHandlingExecutor = Executors.newFixedThreadPool(msgHandlerPoolSize, groupedThreads("onos/store/flow", "message-handlers", log));
    registerMessageHandlers(messageHandlingExecutor);
    if (backupEnabled) {
        replicaInfoManager.addListener(flowTable);
        backupTask = backupSenderExecutor.scheduleWithFixedDelay(flowTable::backup, 0, backupPeriod, TimeUnit.MILLISECONDS);
    }
    deviceTableStats = storageService.<DeviceId, List<TableStatisticsEntry>>eventuallyConsistentMapBuilder().withName("onos-flow-table-stats").withSerializer(SERIALIZER_BUILDER).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    deviceTableStats.addListener(tableStatsListener);
    logConfig("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    configService.registerProperties(getClass());
    idGenerator = coreService.getIdGenerator(FlowRuleService.FLOW_OP_TOPIC);
    local = clusterService.getLocalNode().id();
    eventHandler = Executors.newSingleThreadExecutor(groupedThreads("onos/flow", "event-handler", log));
    messageHandlingExecutor = Executors.newFixedThreadPool(msgHandlerPoolSize, groupedThreads("onos/store/flow", "message-handlers", log));
    registerMessageHandlers(messageHandlingExecutor);
    if (backupEnabled) {
        replicaInfoManager.addListener(flowTable);
        backupTask = backupSenderExecutor.scheduleWithFixedDelay(flowTable::backup, 0, backupPeriod, TimeUnit.MILLISECONDS);
    }
    deviceTableStats = storageService.<DeviceId, List<TableStatisticsEntry>>eventuallyConsistentMapBuilder().withName("onos-flow-table-stats").withSerializer(serializerBuilder).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    deviceTableStats.addListener(tableStatsListener);
    logConfig("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    if (backupEnabled) {
        replicaInfoManager.removeListener(flowTable);
        backupTask.cancel(true);
    }
    configService.unregisterProperties(getClass(), false);
    unregisterMessageHandlers();
    deviceTableStats.removeListener(tableStatsListener);
    deviceTableStats.destroy();
    messageHandlingExecutor.shutdownNow();
    backupSenderExecutor.shutdownNow();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    if (backupEnabled) {
        replicaInfoManager.removeListener(flowTable);
        backupTask.cancel(true);
    }
    configService.unregisterProperties(getClass(), false);
    unregisterMessageHandlers();
    deviceTableStats.removeListener(tableStatsListener);
    deviceTableStats.destroy();
    eventHandler.shutdownNow();
    messageHandlingExecutor.shutdownNow();
    backupSenderExecutor.shutdownNow();
    log.info("Stopped");
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        backupEnabled = DEFAULT_BACKUP_ENABLED;
        logConfig("Default config");
        return;
    }
    Dictionary properties = context.getProperties();
    int newPoolSize;
    boolean newBackupEnabled;
    int newBackupPeriod;
    try {
        String s = get(properties, "msgHandlerPoolSize");
        newPoolSize = isNullOrEmpty(s) ? msgHandlerPoolSize : Integer.parseInt(s.trim());
        s = get(properties, "backupEnabled");
        newBackupEnabled = isNullOrEmpty(s) ? backupEnabled : Boolean.parseBoolean(s.trim());
        s = get(properties, "backupPeriod");
        newBackupPeriod = isNullOrEmpty(s) ? backupPeriod : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newPoolSize = MESSAGE_HANDLER_THREAD_POOL_SIZE;
        newBackupEnabled = DEFAULT_BACKUP_ENABLED;
        newBackupPeriod = DEFAULT_BACKUP_PERIOD_MILLIS;
    }
    boolean restartBackupTask = false;
    if (newBackupEnabled != backupEnabled) {
        backupEnabled = newBackupEnabled;
        if (!backupEnabled) {
            replicaInfoManager.removeListener(flowTable);
            if (backupTask != null) {
                backupTask.cancel(false);
                backupTask = null;
            }
        } else {
            replicaInfoManager.addListener(flowTable);
        }
        restartBackupTask = backupEnabled;
    }
    if (newBackupPeriod != backupPeriod) {
        backupPeriod = newBackupPeriod;
        restartBackupTask = backupEnabled;
    }
    if (restartBackupTask) {
        if (backupTask != null) {
            // cancel previously running task
            backupTask.cancel(false);
        }
        backupTask = backupSenderExecutor.scheduleWithFixedDelay(flowTable::backup, 0, backupPeriod, TimeUnit.MILLISECONDS);
    }
    if (newPoolSize != msgHandlerPoolSize) {
        msgHandlerPoolSize = newPoolSize;
        ExecutorService oldMsgHandler = messageHandlingExecutor;
        messageHandlingExecutor = Executors.newFixedThreadPool(msgHandlerPoolSize, groupedThreads("onos/store/flow", "message-handlers", log));
        // replace previously registered handlers.
        registerMessageHandlers(messageHandlingExecutor);
        oldMsgHandler.shutdown();
    }
    logConfig("Reconfigured");
}
#method_after
@SuppressWarnings("rawtypes")
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        backupEnabled = DEFAULT_BACKUP_ENABLED;
        logConfig("Default config");
        return;
    }
    Dictionary properties = context.getProperties();
    int newPoolSize;
    boolean newBackupEnabled;
    int newBackupPeriod;
    int newBackupCount;
    try {
        String s = get(properties, "msgHandlerPoolSize");
        newPoolSize = isNullOrEmpty(s) ? msgHandlerPoolSize : Integer.parseInt(s.trim());
        s = get(properties, "backupEnabled");
        newBackupEnabled = isNullOrEmpty(s) ? backupEnabled : Boolean.parseBoolean(s.trim());
        s = get(properties, "backupPeriod");
        newBackupPeriod = isNullOrEmpty(s) ? backupPeriod : Integer.parseInt(s.trim());
        s = get(properties, "backupCount");
        newBackupCount = isNullOrEmpty(s) ? backupCount : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newPoolSize = MESSAGE_HANDLER_THREAD_POOL_SIZE;
        newBackupEnabled = DEFAULT_BACKUP_ENABLED;
        newBackupPeriod = DEFAULT_BACKUP_PERIOD_MILLIS;
        newBackupCount = DEFAULT_MAX_BACKUP_COUNT;
    }
    boolean restartBackupTask = false;
    if (newBackupEnabled != backupEnabled) {
        backupEnabled = newBackupEnabled;
        if (!backupEnabled) {
            replicaInfoManager.removeListener(flowTable);
            if (backupTask != null) {
                backupTask.cancel(false);
                backupTask = null;
            }
        } else {
            replicaInfoManager.addListener(flowTable);
        }
        restartBackupTask = backupEnabled;
    }
    if (newBackupPeriod != backupPeriod) {
        backupPeriod = newBackupPeriod;
        restartBackupTask = backupEnabled;
    }
    if (restartBackupTask) {
        if (backupTask != null) {
            // cancel previously running task
            backupTask.cancel(false);
        }
        backupTask = backupSenderExecutor.scheduleWithFixedDelay(flowTable::backup, 0, backupPeriod, TimeUnit.MILLISECONDS);
    }
    if (newPoolSize != msgHandlerPoolSize) {
        msgHandlerPoolSize = newPoolSize;
        ExecutorService oldMsgHandler = messageHandlingExecutor;
        messageHandlingExecutor = Executors.newFixedThreadPool(msgHandlerPoolSize, groupedThreads("onos/store/flow", "message-handlers", log));
        // replace previously registered handlers.
        registerMessageHandlers(messageHandlingExecutor);
        oldMsgHandler.shutdown();
    }
    if (backupCount != newBackupCount) {
        backupCount = newBackupCount;
    }
    logConfig("Reconfigured");
}
#end_block

#method_before
private void registerMessageHandlers(ExecutorService executor) {
    clusterCommunicator.addSubscriber(APPLY_BATCH_FLOWS, new OnStoreBatch(), executor);
    clusterCommunicator.<FlowRuleBatchEvent>addSubscriber(REMOTE_APPLY_COMPLETED, SERIALIZER::decode, this::notifyDelegate, executor);
    clusterCommunicator.addSubscriber(GET_FLOW_ENTRY, SERIALIZER::decode, flowTable::getFlowEntry, SERIALIZER::encode, executor);
    clusterCommunicator.addSubscriber(GET_DEVICE_FLOW_ENTRIES, SERIALIZER::decode, flowTable::getFlowEntries, SERIALIZER::encode, executor);
    clusterCommunicator.addSubscriber(REMOVE_FLOW_ENTRY, SERIALIZER::decode, this::removeFlowRuleInternal, SERIALIZER::encode, executor);
    clusterCommunicator.addSubscriber(REMOVE_FLOW_ENTRY, SERIALIZER::decode, this::removeFlowRuleInternal, SERIALIZER::encode, executor);
    clusterCommunicator.addSubscriber(FLOW_TABLE_BACKUP, SERIALIZER::decode, flowTable::onBackupReceipt, SERIALIZER::encode, executor);
}
#method_after
private void registerMessageHandlers(ExecutorService executor) {
    clusterCommunicator.addSubscriber(APPLY_BATCH_FLOWS, new OnStoreBatch(), executor);
    clusterCommunicator.<FlowRuleBatchEvent>addSubscriber(REMOTE_APPLY_COMPLETED, serializer::decode, this::notifyDelegate, executor);
    clusterCommunicator.addSubscriber(GET_FLOW_ENTRY, serializer::decode, flowTable::getFlowEntry, serializer::encode, executor);
    clusterCommunicator.addSubscriber(GET_DEVICE_FLOW_ENTRIES, serializer::decode, flowTable::getFlowEntries, serializer::encode, executor);
    clusterCommunicator.addSubscriber(REMOVE_FLOW_ENTRY, serializer::decode, this::removeFlowRuleInternal, serializer::encode, executor);
    clusterCommunicator.addSubscriber(REMOVE_FLOW_ENTRY, serializer::decode, this::removeFlowRuleInternal, serializer::encode, executor);
    clusterCommunicator.addSubscriber(FLOW_TABLE_BACKUP, serializer::decode, flowTable::onBackupReceipt, serializer::encode, executor);
}
#end_block

#method_before
private void logConfig(String prefix) {
    log.info("{} with msgHandlerPoolSize = {}; backupEnabled = {}, backupPeriod = {}", prefix, msgHandlerPoolSize, backupEnabled, backupPeriod);
}
#method_after
private void logConfig(String prefix) {
    log.info("{} with msgHandlerPoolSize = {}; backupEnabled = {}, backupPeriod = {}, backupCount = {}", prefix, msgHandlerPoolSize, backupEnabled, backupPeriod, backupCount);
}
#end_block

#method_before
@Override
public FlowEntry getFlowEntry(FlowRule rule) {
    NodeId master = mastershipService.getMasterFor(rule.deviceId());
    if (master == null) {
        log.debug("Failed to getFlowEntry: No master for {}", rule.deviceId());
        return null;
    }
    if (Objects.equals(local, master)) {
        return flowTable.getFlowEntry(rule);
    }
    log.trace("Forwarding getFlowEntry to {}, which is the primary (master) for device {}", master, rule.deviceId());
    return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(rule, FlowStoreMessageSubjects.GET_FLOW_ENTRY, SERIALIZER::encode, SERIALIZER::decode, master), FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, null);
}
#method_after
@Override
public FlowEntry getFlowEntry(FlowRule rule) {
    NodeId master = mastershipService.getMasterFor(rule.deviceId());
    if (master == null) {
        log.debug("Failed to getFlowEntry: No master for {}", rule.deviceId());
        return null;
    }
    if (Objects.equals(local, master)) {
        return flowTable.getFlowEntry(rule);
    }
    log.trace("Forwarding getFlowEntry to {}, which is the primary (master) for device {}", master, rule.deviceId());
    return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(rule, FlowStoreMessageSubjects.GET_FLOW_ENTRY, serializer::encode, serializer::decode, master), FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, null);
}
#end_block

#method_before
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (master == null) {
        log.debug("Failed to getFlowEntries: No master for {}", deviceId);
        return Collections.emptyList();
    }
    if (Objects.equals(local, master)) {
        return flowTable.getFlowEntries(deviceId);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", master, deviceId);
    return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(deviceId, FlowStoreMessageSubjects.GET_DEVICE_FLOW_ENTRIES, SERIALIZER::encode, SERIALIZER::decode, master), FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, Collections.emptyList());
}
#method_after
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (master == null) {
        log.debug("Failed to getFlowEntries: No master for {}", deviceId);
        return Collections.emptyList();
    }
    if (Objects.equals(local, master)) {
        return flowTable.getFlowEntries(deviceId);
    }
    log.trace("Forwarding getFlowEntries to {}, which is the primary (master) for device {}", master, deviceId);
    return Tools.futureGetOrElse(clusterCommunicator.sendAndReceive(deviceId, FlowStoreMessageSubjects.GET_DEVICE_FLOW_ENTRIES, serializer::encode, serializer::decode, master), FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, Collections.emptyList());
}
#end_block

#method_before
@Override
public void storeBatch(FlowRuleBatchOperation operation) {
    if (operation.getOperations().isEmpty()) {
        notifyDelegate(FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(operation.id(), Collections.emptySet()), new CompletedBatchOperation(true, Collections.emptySet(), operation.deviceId())));
        return;
    }
    DeviceId deviceId = operation.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (master == null) {
        log.warn("No master for {} : flows will be marked for removal", deviceId);
        updateStoreInternal(operation);
        notifyDelegate(FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(operation.id(), Collections.emptySet()), new CompletedBatchOperation(true, Collections.emptySet(), operation.deviceId())));
        return;
    }
    if (Objects.equals(local, master)) {
        storeBatchInternal(operation);
        return;
    }
    log.trace("Forwarding storeBatch to {}, which is the primary (master) for device {}", master, deviceId);
    clusterCommunicator.unicast(operation, APPLY_BATCH_FLOWS, SERIALIZER::encode, master).whenComplete((result, error) -> {
        if (error != null) {
            log.warn("Failed to storeBatch: {} to {}", operation, master, error);
            Set<FlowRule> allFailures = operation.getOperations().stream().map(op -> op.target()).collect(Collectors.toSet());
            notifyDelegate(FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(operation.id(), Collections.emptySet()), new CompletedBatchOperation(false, allFailures, deviceId)));
        }
    });
}
#method_after
@Override
public void storeBatch(FlowRuleBatchOperation operation) {
    if (operation.getOperations().isEmpty()) {
        notifyDelegate(FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(operation.id(), Collections.emptySet()), new CompletedBatchOperation(true, Collections.emptySet(), operation.deviceId())));
        return;
    }
    DeviceId deviceId = operation.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (master == null) {
        log.warn("No master for {} : flows will be marked for removal", deviceId);
        updateStoreInternal(operation);
        notifyDelegate(FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(operation.id(), Collections.emptySet()), new CompletedBatchOperation(true, Collections.emptySet(), operation.deviceId())));
        return;
    }
    if (Objects.equals(local, master)) {
        storeBatchInternal(operation);
        return;
    }
    log.trace("Forwarding storeBatch to {}, which is the primary (master) for device {}", master, deviceId);
    clusterCommunicator.unicast(operation, APPLY_BATCH_FLOWS, serializer::encode, master).whenComplete((result, error) -> {
        if (error != null) {
            log.warn("Failed to storeBatch: {} to {}", operation, master, error);
            Set<FlowRule> allFailures = operation.getOperations().stream().map(op -> op.target()).collect(Collectors.toSet());
            notifyDelegate(FlowRuleBatchEvent.completed(new FlowRuleBatchRequest(operation.id(), Collections.emptySet()), new CompletedBatchOperation(false, allFailures, deviceId)));
        }
    });
}
#end_block

#method_before
private FlowRuleEvent addOrUpdateFlowRuleInternal(FlowEntry rule) {
    // check if this new rule is an update to an existing entry
    StoredFlowEntry stored = flowTable.getFlowEntry(rule);
    if (stored != null) {
        // FIXME modification of "stored" flow entry outside of flow table
        stored.setBytes(rule.bytes());
        stored.setLife(rule.life());
        stored.setLiveType(rule.liveType());
        stored.setPackets(rule.packets());
        stored.setLastSeen();
        if (stored.state() == FlowEntryState.PENDING_ADD) {
            stored.setState(FlowEntryState.ADDED);
            return new FlowRuleEvent(Type.RULE_ADDED, rule);
        }
        return new FlowRuleEvent(Type.RULE_UPDATED, rule);
    }
    // TODO: Confirm if this behavior is correct. See SimpleFlowRuleStore
    // TODO: also update backup if the behavior is correct.
    flowTable.add(rule);
    return null;
}
#method_after
private FlowRuleEvent addOrUpdateFlowRuleInternal(FlowEntry rule) {
    // check if this new rule is an update to an existing entry
    StoredFlowEntry stored = flowTable.getFlowEntry(rule);
    if (stored != null) {
        // FIXME modification of "stored" flow entry outside of flow table
        stored.setBytes(rule.bytes());
        stored.setLife(rule.life(TimeUnit.NANOSECONDS), TimeUnit.NANOSECONDS);
        stored.setLiveType(rule.liveType());
        stored.setPackets(rule.packets());
        stored.setLastSeen();
        if (stored.state() == FlowEntryState.PENDING_ADD) {
            stored.setState(FlowEntryState.ADDED);
            return new FlowRuleEvent(Type.RULE_ADDED, rule);
        }
        return new FlowRuleEvent(Type.RULE_UPDATED, rule);
    }
    // TODO: Confirm if this behavior is correct. See SimpleFlowRuleStore
    // TODO: also update backup if the behavior is correct.
    flowTable.add(rule);
    return null;
}
#end_block

#method_before
@Override
public FlowRuleEvent removeFlowRule(FlowEntry rule) {
    final DeviceId deviceId = rule.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (Objects.equals(local, master)) {
        // bypass and handle it locally
        return removeFlowRuleInternal(rule);
    }
    if (master == null) {
        log.warn("Failed to removeFlowRule: No master for {}", deviceId);
        // TODO: revisit if this should be null (="no-op") or Exception
        return null;
    }
    log.trace("Forwarding removeFlowRule to {}, which is the master for device {}", master, deviceId);
    return Futures.get(clusterCommunicator.sendAndReceive(rule, REMOVE_FLOW_ENTRY, SERIALIZER::encode, SERIALIZER::decode, master), FLOW_RULE_STORE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS, RuntimeException.class);
}
#method_after
@Override
public FlowRuleEvent removeFlowRule(FlowEntry rule) {
    final DeviceId deviceId = rule.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (Objects.equals(local, master)) {
        // bypass and handle it locally
        return removeFlowRuleInternal(rule);
    }
    if (master == null) {
        log.warn("Failed to removeFlowRule: No master for {}", deviceId);
        // TODO: revisit if this should be null (="no-op") or Exception
        return null;
    }
    log.trace("Forwarding removeFlowRule to {}, which is the master for device {}", master, deviceId);
    return Futures.getUnchecked(clusterCommunicator.sendAndReceive(rule, REMOVE_FLOW_ENTRY, serializer::encode, serializer::decode, master));
}
#end_block

#method_before
@Override
public void batchOperationComplete(FlowRuleBatchEvent event) {
    // FIXME: need a per device pending response
    NodeId nodeId = pendingResponses.remove(event.subject().batchId());
    if (nodeId == null) {
        notifyDelegate(event);
    } else {
        // TODO check unicast return value
        clusterCommunicator.unicast(event, REMOTE_APPLY_COMPLETED, SERIALIZER::encode, nodeId);
    // error log: log.warn("Failed to respond to peer for batch operation result");
    }
}
#method_after
@Override
public void batchOperationComplete(FlowRuleBatchEvent event) {
    // FIXME: need a per device pending response
    NodeId nodeId = pendingResponses.remove(event.subject().batchId());
    if (nodeId == null) {
        notifyDelegate(event);
    } else {
        // TODO check unicast return value
        clusterCommunicator.unicast(event, REMOTE_APPLY_COMPLETED, serializer::encode, nodeId);
    // error log: log.warn("Failed to respond to peer for batch operation result");
    }
}
#end_block

#method_before
@Override
public void handle(final ClusterMessage message) {
    FlowRuleBatchOperation operation = SERIALIZER.decode(message.payload());
    log.debug("received batch request {}", operation);
    final DeviceId deviceId = operation.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (!Objects.equals(local, master)) {
        Set<FlowRule> failures = new HashSet<>(operation.size());
        for (FlowRuleBatchEntry op : operation.getOperations()) {
            failures.add(op.target());
        }
        CompletedBatchOperation allFailed = new CompletedBatchOperation(false, failures, deviceId);
        // This node is no longer the master, respond as all failed.
        // TODO: we might want to wrap response in envelope
        // to distinguish sw programming failure and hand over
        // it make sense in the latter case to retry immediately.
        message.respond(SERIALIZER.encode(allFailed));
        return;
    }
    pendingResponses.put(operation.id(), message.sender());
    storeBatchInternal(operation);
}
#method_after
@Override
public void handle(final ClusterMessage message) {
    FlowRuleBatchOperation operation = serializer.decode(message.payload());
    log.debug("received batch request {}", operation);
    final DeviceId deviceId = operation.deviceId();
    NodeId master = mastershipService.getMasterFor(deviceId);
    if (!Objects.equals(local, master)) {
        Set<FlowRule> failures = new HashSet<>(operation.size());
        for (FlowRuleBatchEntry op : operation.getOperations()) {
            failures.add(op.target());
        }
        CompletedBatchOperation allFailed = new CompletedBatchOperation(false, failures, deviceId);
        // This node is no longer the master, respond as all failed.
        // TODO: we might want to wrap response in envelope
        // to distinguish sw programming failure and hand over
        // it make sense in the latter case to retry immediately.
        message.respond(serializer.encode(allFailed));
        return;
    }
    pendingResponses.put(operation.id(), message.sender());
    storeBatchInternal(operation);
}
#end_block

#method_before
@Override
public void event(ReplicaInfoEvent event) {
    if (!backupEnabled) {
        return;
    }
    if (event.type() == ReplicaInfoEvent.Type.BACKUPS_CHANGED) {
        DeviceId deviceId = event.subject();
        NodeId master = mastershipService.getMasterFor(deviceId);
        if (!Objects.equals(local, master)) {
            // ignore since this event is for a device this node does not manage.
            return;
        }
        NodeId newBackupNode = getBackupNode(deviceId);
        NodeId currentBackupNode = lastBackupNodes.get(deviceId);
        if (Objects.equals(newBackupNode, currentBackupNode)) {
            // ignore since backup location hasn't changed.
            return;
        }
        if (currentBackupNode != null && newBackupNode == null) {
            // Current backup node is most likely down and no alternate backup node
            // has been chosen. Clear current backup location so that we can resume
            // backups when either current backup comes online or a different backup node
            // is chosen.
            log.warn("Lost backup location {} for deviceId {} and no alternate backup node exists. " + "Flows can be lost if the master goes down", currentBackupNode, deviceId);
            lastBackupNodes.remove(deviceId);
            lastBackupTimes.remove(deviceId);
            return;
        // TODO: Pick any available node as backup and ensure hand-off occurs when
        // a new master is elected.
        }
        log.debug("Backup location for {} has changed from {} to {}.", deviceId, currentBackupNode, newBackupNode);
        backupSenderExecutor.schedule(() -> backupFlowEntries(newBackupNode, Sets.newHashSet(deviceId)), 0, TimeUnit.SECONDS);
    }
}
#method_after
@Override
public void event(ReplicaInfoEvent event) {
    eventHandler.execute(() -> handleEvent(event));
}
#end_block

#method_before
private void backupFlowEntries(NodeId nodeId, Set<DeviceId> deviceIds) {
    if (deviceIds.isEmpty()) {
        return;
    }
    log.debug("Sending flowEntries for devices {} to {} as backup.", deviceIds, nodeId);
    Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>> deviceFlowEntries = Maps.newConcurrentMap();
    deviceIds.forEach(id -> deviceFlowEntries.put(id, ImmutableMap.copyOf(getFlowTable(id))));
    clusterCommunicator.<Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>>, Set<DeviceId>>sendAndReceive(deviceFlowEntries, FLOW_TABLE_BACKUP, SERIALIZER::encode, SERIALIZER::decode, nodeId).whenComplete((backedupDevices, error) -> {
        Set<DeviceId> devicesNotBackedup = error != null ? deviceFlowEntries.keySet() : Sets.difference(deviceFlowEntries.keySet(), backedupDevices);
        if (devicesNotBackedup.size() > 0) {
            log.warn("Failed to backup devices: {}. Reason: {}", devicesNotBackedup, error.getMessage());
        }
        if (backedupDevices != null) {
            backedupDevices.forEach(id -> {
                lastBackupTimes.put(id, System.currentTimeMillis());
                lastBackupNodes.put(id, nodeId);
            });
        }
    });
}
#method_after
private void backupFlowEntries(NodeId nodeId, Set<DeviceId> deviceIds) {
    if (deviceIds.isEmpty()) {
        return;
    }
    log.debug("Sending flowEntries for devices {} to {} for backup.", deviceIds, nodeId);
    Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>> deviceFlowEntries = Maps.newConcurrentMap();
    deviceIds.forEach(id -> deviceFlowEntries.put(id, getFlowTableCopy(id)));
    clusterCommunicator.<Map<DeviceId, Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>>, Set<DeviceId>>sendAndReceive(deviceFlowEntries, FLOW_TABLE_BACKUP, serializer::encode, serializer::decode, nodeId).whenComplete((backedupDevices, error) -> {
        Set<DeviceId> devicesNotBackedup = error != null ? deviceFlowEntries.keySet() : Sets.difference(deviceFlowEntries.keySet(), backedupDevices);
        if (devicesNotBackedup.size() > 0) {
            log.warn("Failed to backup devices: {}. Reason: {}, Node: {}", devicesNotBackedup, error != null ? error.getMessage() : "none", nodeId);
        }
        if (backedupDevices != null) {
            backedupDevices.forEach(id -> {
                lastBackupTimes.put(new BackupOperation(nodeId, id), System.currentTimeMillis());
            });
        }
    });
}
#end_block

#method_before
private Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>> getFlowTable(DeviceId deviceId) {
    if (persistenceEnabled) {
        return flowEntries.computeIfAbsent(deviceId, id -> persistenceService.<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>persistentMapBuilder().withName("FlowTable:" + deviceId.toString()).withSerializer(new Serializer() {

            @Override
            public <T> byte[] encode(T object) {
                return SERIALIZER.encode(object);
            }

            @Override
            public <T> T decode(byte[] bytes) {
                return SERIALIZER.decode(bytes);
            }
        }).build());
    } else {
        return flowEntries.computeIfAbsent(deviceId, id -> Maps.newConcurrentMap());
    }
}
#method_after
private Map<FlowId, Map<StoredFlowEntry, StoredFlowEntry>> getFlowTable(DeviceId deviceId) {
    if (persistenceEnabled) {
        return flowEntries.computeIfAbsent(deviceId, id -> persistenceService.<FlowId, Map<StoredFlowEntry, StoredFlowEntry>>persistentMapBuilder().withName("FlowTable:" + deviceId.toString()).withSerializer(new Serializer() {

            @Override
            public <T> byte[] encode(T object) {
                return serializer.encode(object);
            }

            @Override
            public <T> T decode(byte[] bytes) {
                return serializer.decode(bytes);
            }
        }).build());
    } else {
        return flowEntries.computeIfAbsent(deviceId, id -> Maps.newConcurrentMap());
    }
}
#end_block

#method_before
private void backup() {
    if (!backupEnabled) {
        return;
    }
    try {
        // determine the set of devices that we need to backup during this run.
        Set<DeviceId> devicesToBackup = mastershipService.getDevicesOf(local).stream().filter(deviceId -> {
            Long lastBackupTime = lastBackupTimes.get(deviceId);
            Long lastUpdateTime = lastUpdateTimes.get(deviceId);
            NodeId lastBackupNode = lastBackupNodes.get(deviceId);
            NodeId newBackupNode = getBackupNode(deviceId);
            return lastBackupTime == null || !Objects.equals(lastBackupNode, newBackupNode) || (lastUpdateTime != null && lastUpdateTime > lastBackupTime);
        }).collect(Collectors.toSet());
        // compute a mapping from node to the set of devices whose flow entries it should backup
        Map<NodeId, Set<DeviceId>> devicesToBackupByNode = Maps.newHashMap();
        devicesToBackup.forEach(deviceId -> {
            NodeId backupLocation = getBackupNode(deviceId);
            if (backupLocation != null) {
                devicesToBackupByNode.computeIfAbsent(backupLocation, nodeId -> Sets.newHashSet()).add(deviceId);
            }
        });
        // send the device flow entries to their respective backup nodes
        devicesToBackupByNode.forEach(this::sendBackups);
    } catch (Exception e) {
        log.error("Backup failed.", e);
    }
}
#method_after
private void backup() {
    if (!backupEnabled) {
        return;
    }
    try {
        // compute a mapping from node to the set of devices whose flow entries it should backup
        Map<NodeId, Set<DeviceId>> devicesToBackupByNode = Maps.newHashMap();
        flowEntries.keySet().forEach(deviceId -> {
            List<NodeId> backupNodes = getBackupNodes(deviceId);
            backupNodes.forEach(backupNode -> {
                if (lastBackupTimes.getOrDefault(new BackupOperation(backupNode, deviceId), 0L) < lastUpdateTimes.getOrDefault(deviceId, 0L)) {
                    devicesToBackupByNode.computeIfAbsent(backupNode, nodeId -> Sets.newHashSet()).add(deviceId);
                }
            });
        });
        // send the device flow entries to their respective backup nodes
        devicesToBackupByNode.forEach(this::sendBackups);
    } catch (Exception e) {
        log.error("Backup failed.", e);
    }
}
#end_block

#method_before
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).makeTemporary(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
                if (stat.getVersion() != OFVersion.OF_10) {
                    builder.forTable(stat.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(stat.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), liveType, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                }
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).makeTemporary(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue());
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(removed.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), liveType, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                }
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).makeTemporary(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = FlowEntry.FlowLiveType.IMMEDIATE;
                    return new DefaultFlowEntry(builder.build(), flowState, 0, liveType, 0, 0);
                } else {
                    return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
                }
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#method_after
public FlowEntry build(FlowEntryState... state) {
    FlowRule.Builder builder;
    try {
        switch(this.type) {
            case STAT:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(stat.getPriority()).makeTemporary(stat.getIdleTimeout()).withCookie(stat.getCookie().getValue());
                if (stat.getVersion() != OFVersion.OF_10) {
                    builder.forTable(stat.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(stat.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, SECONDS.toNanos(stat.getDurationSec()) + stat.getDurationNsec(), NANOSECONDS, liveType, stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.ADDED, stat.getDurationSec(), stat.getPacketCount().getValue(), stat.getByteCount().getValue());
                }
            case REMOVED:
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withPriority(removed.getPriority()).makeTemporary(removed.getIdleTimeout()).withCookie(removed.getCookie().getValue()).withReason(FlowRule.FlowRemoveReason.parseShort(removed.getReason()));
                if (removed.getVersion() != OFVersion.OF_10) {
                    builder.forTable(removed.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = afsc.calFlowLiveType(removed.getDurationSec());
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, SECONDS.toNanos(removed.getDurationSec()) + removed.getDurationNsec(), NANOSECONDS, liveType, removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                } else {
                    return new DefaultFlowEntry(builder.build(), FlowEntryState.REMOVED, removed.getDurationSec(), removed.getPacketCount().getValue(), removed.getByteCount().getValue());
                }
            case MOD:
                FlowEntryState flowState = state.length > 0 ? state[0] : FlowEntryState.FAILED;
                builder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(buildSelector()).withTreatment(buildTreatment()).withPriority(flowMod.getPriority()).makeTemporary(flowMod.getIdleTimeout()).withCookie(flowMod.getCookie().getValue());
                if (flowMod.getVersion() != OFVersion.OF_10) {
                    builder.forTable(flowMod.getTableId().getValue());
                }
                if (afsc != null) {
                    FlowEntry.FlowLiveType liveType = FlowEntry.FlowLiveType.IMMEDIATE;
                    return new DefaultFlowEntry(builder.build(), flowState, 0, liveType, 0, 0);
                } else {
                    return new DefaultFlowEntry(builder.build(), flowState, 0, 0, 0);
                }
            default:
                log.error("Unknown flow type : {}", this.type);
                return null;
        }
    } catch (UnsupportedOperationException e) {
        log.warn("Error building flow entry", e);
        return null;
    }
}
#end_block

#method_before
public static TrafficTreatment.Builder configureTreatmentBuilder(List<OFAction> actions, TrafficTreatment.Builder builder, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter interpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        interpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        interpreter = null;
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    CircuitSignalID circuitSignalID = ((OFOxmOchSigid) ct.getField()).getValue();
                    builder.add(Instructions.modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
                } else if (interpreter != null) {
                    builder.extension(interpreter.mapAction(exp), deviceId);
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField, driverHandler, deviceId);
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls(new EthType(popMpls.getEthertype().getValue()));
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new DefaultGroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                builder.pushVlan();
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#method_after
public static TrafficTreatment.Builder configureTreatmentBuilder(List<OFAction> actions, TrafficTreatment.Builder builder, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter interpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        interpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        interpreter = null;
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanPcp(pcp.getVlanPcp().getValue());
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06 || exp.getExperimenter() == 0x748771) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    CircuitSignalID circuitSignalID = ((OFOxmOchSigid) ct.getField()).getValue();
                    builder.add(Instructions.modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
                } else if (interpreter != null) {
                    builder.extension(interpreter.mapAction(exp), deviceId);
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                OFActionSetField setField = (OFActionSetField) act;
                handleSetField(builder, setField, driverHandler, deviceId);
                break;
            case POP_MPLS:
                OFActionPopMpls popMpls = (OFActionPopMpls) act;
                builder.popMpls(new EthType(popMpls.getEthertype().getValue()));
                break;
            case PUSH_MPLS:
                builder.pushMpls();
                break;
            case COPY_TTL_IN:
                builder.copyTtlIn();
                break;
            case COPY_TTL_OUT:
                builder.copyTtlOut();
                break;
            case DEC_MPLS_TTL:
                builder.decMplsTtl();
                break;
            case DEC_NW_TTL:
                builder.decNwTtl();
                break;
            case GROUP:
                OFActionGroup group = (OFActionGroup) act;
                builder.group(new DefaultGroupId(group.getGroup().getGroupNumber()));
                break;
            case SET_QUEUE:
                OFActionSetQueue setQueue = (OFActionSetQueue) act;
                builder.setQueue(setQueue.getQueueId());
                break;
            case ENQUEUE:
                OFActionEnqueue enqueue = (OFActionEnqueue) act;
                builder.setQueue(enqueue.getQueueId(), PortNumber.portNumber(enqueue.getPort().getPortNumber()));
                break;
            case STRIP_VLAN:
            case POP_VLAN:
                builder.popVlan();
                break;
            case PUSH_VLAN:
                OFActionPushVlan pushVlan = (OFActionPushVlan) act;
                builder.pushVlan(new EthType((short) pushVlan.getEthertype().getValue()));
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_PBB:
            case PUSH_PBB:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder;
}
#end_block

#method_before
private static void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                    break;
                } catch (UnsupportedOperationException e) {
                    log.debug("Unsupported action extension; defaulting to native OF");
                }
            }
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                } catch (UnsupportedOperationException e) {
                    log.debug(e.getMessage());
                }
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
        case ARP_SHA:
        case ARP_SPA:
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#method_after
private static void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                    break;
                } catch (UnsupportedOperationException e) {
                    log.debug("Unsupported action extension; defaulting to native OF");
                }
            }
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<OFBooleanValue> mplsBos = (OFOxm<OFBooleanValue>) oxm;
            builder.setMplsBos(mplsBos.getValue().getValue());
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
        case NSP:
        case NSI:
        case NSH_C1:
        case NSH_C2:
        case NSH_C3:
        case NSH_C4:
        case NSH_MDTYPE:
        case NSH_NP:
        case ENCAP_ETH_SRC:
        case ENCAP_ETH_DST:
        case ENCAP_ETH_TYPE:
        case TUN_GPE_NP:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                } catch (UnsupportedOperationException e) {
                    log.debug(e.getMessage());
                }
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.ArpOpcode> arpop = (OFOxm<org.projectfloodlight.openflow.types.ArpOpcode>) oxm;
            builder.setArpOp((short) arpop.getValue().getOpcode());
            break;
        case ARP_SHA:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> arpsha = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setArpSha(MacAddress.valueOf(arpsha.getValue().getLong()));
            break;
        case ARP_SPA:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> arpspa = (OFOxm<IPv4Address>) oxm;
            builder.setArpSpa(Ip4Address.valueOf(arpspa.getValue().getInt()));
            break;
        case OFDPA_MPLS_TYPE:
        case OFDPA_OVID:
        case OFDPA_MPLS_L2_PORT:
        case OFDPA_QOS_INDEX:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                    break;
                } catch (UnsupportedOperationException e) {
                    log.warn("Unsupported action extension");
                }
            }
            break;
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#end_block

#method_before
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    Ip4Address ip;
    DriverHandler driverHandler = getDriver(deviceId);
    ExtensionSelectorInterpreter selectorInterpreter;
    if (driverHandler.hasBehaviour(ExtensionSelectorInterpreter.class)) {
        selectorInterpreter = driverHandler.behaviour(ExtensionSelectorInterpreter.class);
    } else {
        selectorInterpreter = null;
    }
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                if (match.isPartiallyMasked(MatchField.ETH_DST)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_DST);
                    builder.matchEthDstMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                    builder.matchEthDst(mac);
                }
                break;
            case ETH_SRC:
                if (match.isPartiallyMasked(MatchField.ETH_SRC)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_SRC);
                    builder.matchEthSrcMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                    builder.matchEthSrc(mac);
                }
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                if (selectorInterpreter != null && selectorInterpreter.supported(ExtensionSelectorTypes.OFDPA_MATCH_VLAN_VID.type())) {
                    if (match.getVersion().equals(OFVersion.OF_13)) {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.VLAN_VID);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } else {
                        break;
                    }
                } else {
                    VlanId vlanId = null;
                    if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                        Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                        if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                            vlanId = VlanId.ANY;
                        }
                    } else {
                        if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                            vlanId = VlanId.NONE;
                        } else {
                            vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                        }
                    }
                    if (vlanId != null) {
                        builder.matchVlanId(vlanId);
                    }
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case EXP_OCH_SIG_ID:
                try {
                    CircuitSignalID expSigId = match.get(MatchField.EXP_OCH_SIG_ID);
                    builder.add(matchLambda(Lambda.ochSignal(lookupGridType(expSigId.getGridType()), lookupChannelSpacing(expSigId.getChannelSpacing()), expSigId.getChannelNumber(), expSigId.getSpectralWidth())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_OCH_SIGTYPE:
                try {
                    U8 expOchSigType = match.get(MatchField.EXP_OCH_SIGTYPE);
                    builder.add(matchOchSignalType(lookupOchSignalType((byte) expOchSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_ODU_SIG_ID:
                OduSignalId oduSignalId = OduSignalId.oduSignalId(match.get(MatchField.EXP_ODU_SIG_ID).getTpn(), match.get(MatchField.EXP_ODU_SIG_ID).getTslen(), match.get(MatchField.EXP_ODU_SIG_ID).getTsmap());
                builder.add(matchOduSignalId(oduSignalId));
                break;
            case EXP_ODU_SIGTYPE:
                try {
                    U8 oduSigType = match.get(MatchField.EXP_ODU_SIGTYPE);
                    builder.add(matchOduSignalType(lookupOduSignalType((byte) oduSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
                int arpOp = match.get(MatchField.ARP_OP).getOpcode();
                builder.matchArpOp(arpOp);
                break;
            case ARP_SHA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_SHA).getLong());
                builder.matchArpSha(mac);
                break;
            case ARP_SPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_SPA).getInt());
                builder.matchArpSpa(ip);
                break;
            case ARP_THA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_THA).getLong());
                builder.matchArpTha(mac);
                break;
            case ARP_TPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_TPA).getInt());
                builder.matchArpTpa(ip);
                break;
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#method_after
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    Ip4Address ip;
    DriverHandler driverHandler = getDriver(deviceId);
    ExtensionSelectorInterpreter selectorInterpreter;
    if (driverHandler.hasBehaviour(ExtensionSelectorInterpreter.class)) {
        selectorInterpreter = driverHandler.behaviour(ExtensionSelectorInterpreter.class);
    } else {
        selectorInterpreter = null;
    }
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                if (match.isPartiallyMasked(MatchField.ETH_DST)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_DST);
                    builder.matchEthDstMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                    builder.matchEthDst(mac);
                }
                break;
            case ETH_SRC:
                if (match.isPartiallyMasked(MatchField.ETH_SRC)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_SRC);
                    builder.matchEthSrcMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                    builder.matchEthSrc(mac);
                }
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                if (selectorInterpreter != null && selectorInterpreter.supported(ExtensionSelectorTypes.OFDPA_MATCH_VLAN_VID.type())) {
                    if (match.getVersion().equals(OFVersion.OF_13)) {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.VLAN_VID);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } else {
                        break;
                    }
                } else {
                    VlanId vlanId = null;
                    if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                        Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                        if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                            vlanId = VlanId.ANY;
                        }
                    } else {
                        if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                            vlanId = VlanId.NONE;
                        } else {
                            vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                        }
                    }
                    if (vlanId != null) {
                        builder.matchVlanId(vlanId);
                    }
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case EXP_OCH_SIG_ID:
                try {
                    CircuitSignalID expSigId = match.get(MatchField.EXP_OCH_SIG_ID);
                    builder.add(matchLambda(Lambda.ochSignal(lookupGridType(expSigId.getGridType()), lookupChannelSpacing(expSigId.getChannelSpacing()), expSigId.getChannelNumber(), expSigId.getSpectralWidth())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_OCH_SIGTYPE:
                try {
                    U8 expOchSigType = match.get(MatchField.EXP_OCH_SIGTYPE);
                    builder.add(matchOchSignalType(lookupOchSignalType((byte) expOchSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_ODU_SIG_ID:
                OduSignalId oduSignalId = OduSignalId.oduSignalId(match.get(MatchField.EXP_ODU_SIG_ID).getTpn(), match.get(MatchField.EXP_ODU_SIG_ID).getTslen(), match.get(MatchField.EXP_ODU_SIG_ID).getTsmap());
                builder.add(matchOduSignalId(oduSignalId));
                break;
            case EXP_ODU_SIGTYPE:
                try {
                    U8 oduSigType = match.get(MatchField.EXP_ODU_SIGTYPE);
                    builder.add(matchOduSignalType(lookupOduSignalType((byte) oduSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
                int arpOp = match.get(MatchField.ARP_OP).getOpcode();
                builder.matchArpOp(arpOp);
                break;
            case ARP_SHA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_SHA).getLong());
                builder.matchArpSha(mac);
                break;
            case ARP_SPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_SPA).getInt());
                builder.matchArpSpa(ip);
                break;
            case ARP_THA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_THA).getLong());
                builder.matchArpTha(mac);
                break;
            case ARP_TPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_TPA).getInt());
                builder.matchArpTpa(ip);
                break;
            case NSP:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.NSP);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case NSI:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.NSI);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case ENCAP_ETH_TYPE:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.ENCAP_ETH_TYPE);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case OFDPA_OVID:
                if (selectorInterpreter != null && selectorInterpreter.supported(ExtensionSelectorTypes.OFDPA_MATCH_OVID.type())) {
                    if (match.getVersion().equals(OFVersion.OF_13)) {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.OFDPA_OVID);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } else {
                        break;
                    }
                }
                break;
            case OFDPA_MPLS_L2_PORT:
                if (selectorInterpreter != null && selectorInterpreter.supported(ExtensionSelectorTypes.OFDPA_MATCH_MPLS_L2_PORT.type())) {
                    if (match.getVersion().equals(OFVersion.OF_13)) {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.OFDPA_MPLS_L2_PORT);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } else {
                        break;
                    }
                }
                break;
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#end_block

#method_before
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty(), Optional.of(driverService)).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(match).setTableId(tableId).setOutPort(ofPort).build();
    // Wait for 1 second until the FlowRuleProvider finishes to process FlowStatReply message
    int loop = 0;
    while (getFlowMissingXid() != NO_FLOW_MISSING_XID) {
        if (loop++ < SLEEP_LOOP_COUNT) {
            log.debug("ofFlowStatsRequestFlowSend: previous FlowStatsRequestAll (xid={})" + " does not be processed yet, do sleep for {} ms, for {}", getFlowMissingXid(), SLEEP_MS, sw.getStringId());
            try {
                sleep(SLEEP_MS);
            } catch (InterruptedException ie) {
                log.debug("ofFlowStatsRequestFlowSend: Interrupted Exception = {}, for {}", ie.toString(), sw.getStringId());
            }
        } else {
            log.debug("ofFlowStatsRequestFlowSend: previous FlowStatsRequestAll (xid={})" + " does not be processed yet, for {} ms," + " just set xid with NO_FLOW_MISSING_XID, for {}", getFlowMissingXid(), loop * SLEEP_MS, sw.getStringId());
            setFlowMissingXid(NO_FLOW_MISSING_XID);
            break;
        }
    }
    sw.sendMsg(request);
}
#method_after
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty(), Optional.of(driverService)).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(match).setTableId(tableId).setOutPort(ofPort).build();
    // Wait for 1 second until the FlowRuleProvider finishes to process FlowStatReply message
    int loop = 0;
    boolean interrupted = false;
    while (!interrupted && getFlowMissingXid() != NO_FLOW_MISSING_XID) {
        if (loop++ < SLEEP_LOOP_COUNT) {
            log.debug("ofFlowStatsRequestFlowSend: previous FlowStatsRequestAll (xid={})" + " does not be processed yet, do sleep for {} ms, for {}", getFlowMissingXid(), SLEEP_MS, sw.getStringId());
            try {
                sleep(SLEEP_MS);
            } catch (InterruptedException ie) {
                log.debug("ofFlowStatsRequestFlowSend: Interrupted Exception = {}, for {}", ie.toString(), sw.getStringId());
                // for exiting while loop gracefully
                interrupted = true;
            }
        } else {
            log.debug("ofFlowStatsRequestFlowSend: previous FlowStatsRequestAll (xid={})" + " does not be processed yet, for {} ms," + " just set xid with NO_FLOW_MISSING_XID, for {}", getFlowMissingXid(), loop * SLEEP_MS, sw.getStringId());
            setFlowMissingXid(NO_FLOW_MISSING_XID);
            break;
        }
    }
    sw.sendMsg(request);
}
#end_block

#method_before
private void checkAndMoveLiveFlowAll() {
    Iterable<FlowEntry> flowEntries = flowRuleService.getFlowEntries(did);
    flowEntries.forEach(fe -> {
        checkAndMoveLiveFlowInternal((StoredFlowEntry) fe);
    });
    // print table counts for debug
    if (log.isDebugEnabled()) {
        Iterable<FlowEntry> fes;
        synchronized (this) {
            long totalFlowCount = flowRuleService.getFlowRuleCount();
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.IMMEDIATE);
            long immediateFlowCount = Iterables.size(fes);
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.SHORT);
            long shortFlowCount = Iterables.size(fes);
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.MID);
            long midFlowCount = Iterables.size(fes);
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.LONG);
            long longFlowCount = Iterables.size(fes);
            log.trace(CHECK_AND_MOVE_COUNT_LOG, totalFlowCount, immediateFlowCount, shortFlowCount, midFlowCount, longFlowCount);
            if (immediateFlowCount < 0) {
                log.error("Immediate flow count is negative");
            }
        }
    }
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#method_after
private void checkAndMoveLiveFlowAll() {
    Iterable<FlowEntry> flowEntries = flowRuleService.getFlowEntries(did);
    flowEntries.forEach(fe -> {
        checkAndMoveLiveFlowInternal((StoredFlowEntry) fe);
    });
    // print table counts for debug
    if (log.isDebugEnabled()) {
        Iterable<FlowEntry> fes;
        synchronized (this) {
            long totalFlowCount = flowRuleService.getFlowRuleCount();
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.IMMEDIATE);
            long immediateFlowCount = Iterables.size(fes);
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.SHORT);
            long shortFlowCount = Iterables.size(fes);
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.MID);
            long midFlowCount = Iterables.size(fes);
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.LONG);
            long longFlowCount = Iterables.size(fes);
            fes = flowRuleService.getFlowEntriesByLiveType(did, FlowEntry.FlowLiveType.UNKNOWN);
            long unknownFlowCount = Iterables.size(fes);
            log.trace(CHECK_AND_MOVE_COUNT_LOG, totalFlowCount, immediateFlowCount, shortFlowCount, midFlowCount, longFlowCount, unknownFlowCount);
            if (immediateFlowCount < 0) {
                log.error("Immediate flow count is negative");
            }
        }
    }
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#end_block

#method_before
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    compilePredicate();
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service, coreService);
    if (outputJson()) {
        print("%s", json(flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#method_after
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    compilePredicate();
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service, coreService);
    if (outputJson()) {
        print("%s", json(flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#end_block

#method_before
protected void printFlows(Device d, List<FlowEntry> flows, CoreService coreService) {
    boolean empty = flows == null || flows.isEmpty();
    print("deviceId=%s, flowRuleCount=%d", d.id(), empty ? 0 : flows.size());
    if (empty || countOnly) {
        return;
    }
    for (FlowEntry f : flows) {
        if (shortOutput) {
            print(SHORT_FORMAT, f.state(), f.bytes(), f.packets(), f.tableId(), f.priority(), f.selector().criteria(), printTreatment(f.treatment()));
        } else {
            ApplicationId appId = coreService.getAppId(f.appId());
            print(LONG_FORMAT, Long.toHexString(f.id().value()), f.state(), f.bytes(), f.packets(), f.life(), f.liveType(), f.priority(), f.tableId(), appId != null ? appId.name() : "<none>", f.payLoad() == null ? null : f.payLoad().payLoad().toString(), f.selector().criteria(), f.treatment());
        }
    }
}
#method_after
protected void printFlows(Device d, List<FlowEntry> flows, CoreService coreService) {
    List<FlowEntry> filteredFlows = flows.stream().filter(f -> contentFilter.filter(f)).collect(Collectors.toList());
    boolean empty = filteredFlows == null || filteredFlows.isEmpty();
    print("deviceId=%s, flowRuleCount=%d", d.id(), empty ? 0 : filteredFlows.size());
    if (empty || countOnly) {
        return;
    }
    for (FlowEntry f : filteredFlows) {
        if (shortOutput) {
            print(SHORT_FORMAT, f.state(), f.bytes(), f.packets(), f.tableId(), f.priority(), f.selector().criteria(), printTreatment(f.treatment()));
        } else {
            ApplicationId appId = coreService.getAppId(f.appId());
            print(LONG_FORMAT, Long.toHexString(f.id().value()), f.state(), f.bytes(), f.packets(), f.life(), f.liveType(), f.priority(), f.tableId(), appId != null ? appId.name() : "<none>", f.payLoad() == null ? null : f.payLoad().payLoad().toString(), f.selector().criteria(), f.treatment());
        }
    }
}
#end_block

#method_before
@Override
public long life() {
    return baseValue + 11;
}
#method_after
@Override
public long life() {
    return life(SECONDS);
}
#end_block

#method_before
@Override
public long life() {
    return baseValue + 11;
}
#method_after
@Override
public long life(TimeUnit timeUnit) {
    return SECONDS.convert(baseValue + 11, timeUnit);
}
#end_block

#method_before
@Before
public void setUpTest() {
    // Mock device service
    expect(mockDeviceService.getDevice(deviceId1)).andReturn(device1);
    expect(mockDeviceService.getDevice(deviceId2)).andReturn(device2);
    expect(mockDeviceService.getDevices()).andReturn(ImmutableSet.of(device1, device2));
    // Mock Core Service
    expect(mockCoreService.getAppId(anyShort())).andReturn(NetTestTools.APP_ID).anyTimes();
    expect(mockCoreService.registerApplication(FlowRuleCodec.REST_APP_ID)).andReturn(APP_ID).anyTimes();
    replay(mockCoreService);
    // Register the services needed for the test
    final CodecManager codecService = new CodecManager();
    codecService.activate();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(FlowRuleService.class, mockFlowService).add(DeviceService.class, mockDeviceService).add(CodecService.class, codecService).add(CoreService.class, mockCoreService);
    BaseResource.setServiceDirectory(testDirectory);
}
#method_after
@Before
public void setUpTest() {
    // Mock device service
    expect(mockDeviceService.getDevice(deviceId1)).andReturn(device1);
    expect(mockDeviceService.getDevice(deviceId2)).andReturn(device2);
    expect(mockDeviceService.getDevices()).andReturn(ImmutableSet.of(device1, device2));
    // Mock Core Service
    expect(mockCoreService.getAppId(anyShort())).andReturn(NetTestTools.APP_ID).anyTimes();
    expect(mockCoreService.getAppId(anyString())).andReturn(NetTestTools.APP_ID).anyTimes();
    expect(mockCoreService.registerApplication(FlowRuleCodec.REST_APP_ID)).andReturn(APP_ID).anyTimes();
    replay(mockCoreService);
    // Register the services needed for the test
    final CodecManager codecService = new CodecManager();
    codecService.activate();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(FlowRuleService.class, mockFlowService).add(DeviceService.class, mockDeviceService).add(CodecService.class, codecService).add(CoreService.class, mockCoreService).add(ApplicationService.class, mockApplicationService);
    BaseResource.setServiceDirectory(testDirectory);
}
#end_block

#method_before
private static FlowJsonMatcher matchesFlow(FlowEntry flow, String expectedAppName) {
    return new FlowJsonMatcher(flow, expectedAppName);
}
#method_after
private static FlowEntryJsonMatcher matchesFlow(FlowEntry flow, String expectedAppName) {
    return new FlowEntryJsonMatcher(flow, expectedAppName);
}
#end_block

#method_before
private static FlowJsonArrayMatcher hasFlow(FlowEntry flow) {
    return new FlowJsonArrayMatcher(flow);
}
#method_after
private static FlowEntryJsonArrayMatcher hasFlow(FlowEntry flow) {
    return new FlowEntryJsonArrayMatcher(flow);
}
#end_block

#method_before
private long typedPollInterval(FlowEntry fe) {
    checkNotNull(fe, "FlowEntry cannot be null");
    PollInterval pollIntervalInstance = PollInterval.getInstance();
    switch(fe.liveType()) {
        case LONG:
            return pollIntervalInstance.getLongPollInterval();
        case MID:
            return pollIntervalInstance.getMidPollInterval();
        case SHORT:
        case IMMEDIATE:
        default:
            return pollIntervalInstance.getPollInterval();
    }
}
#method_after
private long typedPollInterval(FlowEntry fe) {
    checkNotNull(fe, "FlowEntry cannot be null");
    PollInterval pollIntervalInstance = PollInterval.getInstance();
    switch(fe.liveType()) {
        case LONG:
            return pollIntervalInstance.getLongPollInterval();
        case MID:
            return pollIntervalInstance.getMidPollInterval();
        case SHORT:
        case IMMEDIATE:
        case UNKNOWN:
        default:
            return pollIntervalInstance.getPollInterval();
    }
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("disabledPorts:%d, suppressedPorts:%d, filteredPorts:%d", disabledPorts, suppressedPorts, filteredPorts);
}
#method_after
@Override
public String toString() {
    MoreObjects.ToStringHelper helper = toStringHelper(this).add("disabledPorts", disabledPorts).add("suppressedPorts", suppressedPorts).add("filteredPorts", filteredPorts);
    return helper.toString();
}
#end_block

#method_before
@Test
public void isAttached() {
    VplsConfig vpls = createNewVpls();
    assertTrue("Connect point not correctly attached to the VPLS", vpls.isAttached(CP1));
    assertTrue("Interface not correctly attached to the VPLS", vpls.isAttached(IF4));
    assertTrue("Interface not correctly attached to the VPLS", vpls.isAttached(IF4));
    assertFalse("Unexpected connect point attached to the VPLS", vpls.isAttached(CP_NON_EXIST));
    assertFalse("Unexpected interface attached to the VPLS", vpls.isAttached(IF_NON_EXIST));
}
#method_after
@Test
public void isAttached() {
    VplsConfig vpls = createNewVpls();
    assertTrue("Interface not correctly attached to the VPLS", vpls.isAttached(IF4));
    assertTrue("Interface not correctly attached to the VPLS", vpls.isAttached(IF4));
    assertFalse("Unexpected interface attached to the VPLS", vpls.isAttached(IF_NON_EXIST));
}
#end_block

#method_before
private VplsConfig createInitialVpls() {
    Set<String> ifaces = new HashSet<>(Arrays.asList(IF1, IF2, IF3));
    Set<String> cps = new HashSet<>(Arrays.asList(CP1, CP2));
    return new VplsConfig(VPLS1, ifaces, cps, EncapsulationType.NONE);
}
#method_after
private VplsConfig createInitialVpls() {
    Set<String> ifaces = new HashSet<>(Arrays.asList(IF1, IF2, IF3));
    return new VplsConfig(VPLS1, ifaces, EncapsulationType.NONE);
}
#end_block

#method_before
private VplsConfig createNewVpls() {
    Set<String> ifaces = new HashSet<>(Arrays.asList(IF4, IF5));
    Set<String> cps = new HashSet<>(Arrays.asList(CP1, CP2));
    return new VplsConfig(NEWVPLS, ifaces, cps, EncapsulationType.NONE);
}
#method_after
private VplsConfig createNewVpls() {
    Set<String> ifaces = new HashSet<>(Arrays.asList(IF4, IF5));
    return new VplsConfig(NEWVPLS, ifaces, EncapsulationType.NONE);
}
#end_block

#method_before
protected boolean isAttached(String point) {
    Set<String> points = Sets.newHashSet();
    points.addAll(ifaces);
    points.addAll(cps);
    return points.stream().anyMatch(point::equals);
}
#method_after
protected boolean isAttached(String iface) {
    return ifaces.stream().anyMatch(iface::equals);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof VplsConfig) {
        VplsConfig that = (VplsConfig) obj;
        return Objects.equals(name, that.name) && Objects.equals(ifaces, that.ifaces) && Objects.equals(cps, that.cps) && Objects.equals(encap, that.encap);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof VplsConfig) {
        VplsConfig that = (VplsConfig) obj;
        return Objects.equals(name, that.name) && Objects.equals(ifaces, that.ifaces) && Objects.equals(encap, that.encap);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(name, ifaces, cps, encap);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(name, ifaces, encap);
}
#end_block

#method_before
@Before
public void setUp() {
    vplsNeighbourHandler = new VplsNeighbourHandler();
    SetMultimap<String, Interface> ifacesByVpls = HashMultimap.create();
    ifacesByVpls.put(VPLS1, V100H1);
    ifacesByVpls.put(VPLS1, V200H1);
    ifacesByVpls.put(VPLS1, V300H1);
    ifacesByVpls.put(VPLS2, V100H2);
    ifacesByVpls.put(VPLS2, V200H2);
    SetMultimap<String, ConnectPoint> cpsByVpls = HashMultimap.create();
    cpsByVpls.put(VPLS3, OF5P1);
    cpsByVpls.put(VPLS3, OF5P2);
    HashMap<String, EncapsulationType> encap = Maps.newHashMap();
    vplsNeighbourHandler.vplsConfigService = new TestVplsConfigService(ifacesByVpls, cpsByVpls, encap);
    vplsNeighbourHandler.deviceService = new TestDeviceService();
    vplsNeighbourHandler.interfaceService = new TestInterfaceService();
    vplsNeighbourHandler.neighbourService = new TestNeighbourService();
    hostService = new TestHostService();
}
#method_after
@Before
public void setUp() {
    vplsNeighbourHandler = new VplsNeighbourHandler();
    SetMultimap<String, Interface> ifacesByVpls = HashMultimap.create();
    ifacesByVpls.put(VPLS1, V100H1);
    ifacesByVpls.put(VPLS1, V200H1);
    ifacesByVpls.put(VPLS1, V300H1);
    ifacesByVpls.put(VPLS2, V100H2);
    ifacesByVpls.put(VPLS2, V200H2);
    ifacesByVpls.put(VPLS3, VNONEH1);
    ifacesByVpls.put(VPLS3, VNONEH2);
    ifacesByVpls.put(VPLS4, V400H1);
    ifacesByVpls.put(VPLS4, VNONEH3);
    HashMap<String, EncapsulationType> encap = Maps.newHashMap();
    vplsNeighbourHandler.vplsConfigService = new TestVplsConfigService(ifacesByVpls, encap);
    vplsNeighbourHandler.interfaceService = new TestInterfaceService();
    vplsNeighbourHandler.neighbourService = new TestNeighbourService();
    hostService = new TestHostService();
}
#end_block

#method_before
@Test
public void vpls1RequestMessage() {
    // Request messages from v100h1 (VPLS 1) should be received by v200h1 and v300h1
    TestMessageContext requestMessage = makeBroadcastRequestContext(v100Host1);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H1, V300H1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResultsIfaces);
    // Request messages from v200h1 (VPLS 1) should be received by v100h1 and v300h1
    requestMessage = makeBroadcastRequestContext(v200Host1);
    expectInterfaces = ImmutableSet.of(V100H1, V300H1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResultsIfaces);
    // Request from v300h1 (VPLS 1) should be received by v100h1 and v200h1
    requestMessage = makeBroadcastRequestContext(v300Host1);
    expectInterfaces = ImmutableSet.of(V100H1, V200H1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResultsIfaces);
}
#method_after
@Test
public void vpls1RequestMessage() {
    // Request messages from v100h1 (VPLS 1) should be received by v200h1 and v300h1
    TestMessageContext requestMessage = makeBroadcastRequestContext(v100Host1);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H1, V300H1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResults);
    // Request messages from v200h1 (VPLS 1) should be received by v100h1 and v300h1
    requestMessage = makeBroadcastRequestContext(v200Host1);
    expectInterfaces = ImmutableSet.of(V100H1, V300H1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResults);
    // Request from v300h1 (VPLS 1) should be received by v100h1 and v200h1
    requestMessage = makeBroadcastRequestContext(v300Host1);
    expectInterfaces = ImmutableSet.of(V100H1, V200H1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResults);
}
#end_block

#method_before
@Test
public void vpls2RequestMessage() {
    // Request messages from v100h2 (VPLS 2) should be received by v200h2
    TestMessageContext requestMessage = makeBroadcastRequestContext(v100Host2);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H2);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResultsIfaces);
    // Request messages from v200h2 (VPLS 2) should be received by v100h2
    requestMessage = makeBroadcastRequestContext(v200Host2);
    expectInterfaces = ImmutableSet.of(V100H2);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResultsIfaces);
}
#method_after
@Test
public void vpls2RequestMessage() {
    // Request messages from v100h2 (VPLS 2) should be received by v200h2
    TestMessageContext requestMessage = makeBroadcastRequestContext(v100Host2);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H2);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResults);
    // Request messages from v200h2 (VPLS 2) should be received by v100h2
    requestMessage = makeBroadcastRequestContext(v200Host2);
    expectInterfaces = ImmutableSet.of(V100H2);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResults);
}
#end_block

#method_before
@Test
public void vpls3RequestMessage() {
    // Request messages from Host3 (VPLS 3) should be received by Host4
    TestMessageContext requestMessage = makeBroadcastRequestContext(host3);
    Set<ConnectPoint> expectCPs = ImmutableSet.of(OF5P2);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(CPS_NOT_EXPECTED, expectCPs, requestMessage.forwardResultsCPs);
    // Request messages from Host4 (VPLS 3) should be received by Host3
    requestMessage = makeBroadcastRequestContext(host4);
    expectCPs = ImmutableSet.of(OF5P1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(CPS_NOT_EXPECTED, expectCPs, requestMessage.forwardResultsCPs);
}
#method_after
@Test
public void vpls3RequestMessage() {
    // Request messages from vNoneHost1 (VPLS 3) should be received by vNoneHost2
    TestMessageContext requestMessage = makeBroadcastRequestContext(vNoneHost1);
    Set<Interface> expectInterfaces = ImmutableSet.of(VNONEH2);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResults);
    // Request messages from vNoneh2 (VPLS 3) should be received by vNoneh1
    requestMessage = makeBroadcastRequestContext(vNoneHost2);
    expectInterfaces = ImmutableSet.of(VNONEH1);
    vplsNeighbourHandler.handleRequest(requestMessage);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, requestMessage.forwardResults);
}
#end_block

#method_before
@Test
public void vpls1ReplyMessage() {
    // Reply messages from v100h1 (VPLS 1) should be received by v200h1
    TestMessageContext replyMessage = makeReplyContext(v100Host1, v200Host1);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResultsIfaces);
    // Reply messages from v200h1 (VPLS 1) should be received by v300h1
    replyMessage = makeReplyContext(v200Host1, v300Host1);
    expectInterfaces = ImmutableSet.of(V300H1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResultsIfaces);
    // Reply messages from v300h1 (VPLS 1) should be received by v100h1
    replyMessage = makeReplyContext(v300Host1, v100Host1);
    expectInterfaces = ImmutableSet.of(V100H1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResultsIfaces);
}
#method_after
@Test
public void vpls1ReplyMessage() {
    // Reply messages from v100h1 (VPLS 1) should be received by v200h1
    TestMessageContext replyMessage = makeReplyContext(v100Host1, v200Host1);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
    // Reply messages from v200h1 (VPLS 1) should be received by v300h1
    replyMessage = makeReplyContext(v200Host1, v300Host1);
    expectInterfaces = ImmutableSet.of(V300H1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
    // Reply messages from v300h1 (VPLS 1) should be received by v100h1
    replyMessage = makeReplyContext(v300Host1, v100Host1);
    expectInterfaces = ImmutableSet.of(V100H1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
}
#end_block

#method_before
@Test
public void vpls2ReplyMessage() {
    // Reply messages from v100h2 (VPLS 2) should be received by v200h2
    TestMessageContext replyMessage = makeReplyContext(v100Host2, v200Host2);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H2);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResultsIfaces);
    // Reply messages from v200h2 (VPLS 2) should be received by v100h2
    replyMessage = makeReplyContext(v200Host2, v100Host2);
    expectInterfaces = ImmutableSet.of(V100H2);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResultsIfaces);
}
#method_after
@Test
public void vpls2ReplyMessage() {
    // Reply messages from v100h2 (VPLS 2) should be received by v200h2
    TestMessageContext replyMessage = makeReplyContext(v100Host2, v200Host2);
    Set<Interface> expectInterfaces = ImmutableSet.of(V200H2);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
    // Reply messages from v200h2 (VPLS 2) should be received by v100h2
    replyMessage = makeReplyContext(v200Host2, v100Host2);
    expectInterfaces = ImmutableSet.of(V100H2);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
}
#end_block

#method_before
@Test
public void vpls3ReplyMessage() {
    // Reply messages from Host3 (VPLS 3) should be received by Host4
    TestMessageContext replyMessage = makeReplyContext(host3, host4);
    Set<ConnectPoint> expectCPs = ImmutableSet.of(OF5P2);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(CPS_NOT_EXPECTED, expectCPs, replyMessage.forwardResultsCPs);
    // Reply messages from Host4 (VPLS 3) should be received by Host3
    replyMessage = makeReplyContext(host4, host3);
    expectCPs = ImmutableSet.of(OF5P1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(CPS_NOT_EXPECTED, expectCPs, replyMessage.forwardResultsCPs);
}
#method_after
@Test
public void vpls3ReplyMessage() {
    // Reply messages from vNoneh1 (VPLS 3) should be received by vNoneh2
    TestMessageContext replyMessage = makeReplyContext(vNoneHost1, vNoneHost2);
    Set<Interface> expectInterfaces = ImmutableSet.of(VNONEH2);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
    // Reply messages from vNoneh2 (VPLS 3) should be received by vNoneh1
    replyMessage = makeReplyContext(vNoneHost2, vNoneHost1);
    expectInterfaces = ImmutableSet.of(VNONEH1);
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
}
#end_block

#method_before
@Test
public void wrongReplyMessage() {
    // Reply message from v100h1 (VPLS 1) to v100h2 (VPLS 2).
    // Forward results should be empty
    TestMessageContext replyMessage = makeReplyContext(v100Host1, v100Host2);
    Set<Interface> expectInterfaces = ImmutableSet.of();
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResultsIfaces);
    // Reply message from v200h2 (VPLS 2) to v300h1 (VPLS 1).
    // Forward results should be empty
    replyMessage = makeReplyContext(v200Host2, v300Host1);
    expectInterfaces = ImmutableSet.of();
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResultsIfaces);
}
#method_after
@Test
public void wrongReplyMessage() {
    // Reply message from v100h1 (VPLS 1) to v100h2 (VPLS 2).
    // Forward results should be empty
    TestMessageContext replyMessage = makeReplyContext(v100Host1, v100Host2);
    Set<Interface> expectInterfaces = ImmutableSet.of();
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
    // Reply message from v200h2 (VPLS 2) to v300h1 (VPLS 1).
    // Forward results should be empty
    replyMessage = makeReplyContext(v200Host2, v300Host1);
    expectInterfaces = ImmutableSet.of();
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
    // Reply message from vNoneh1 (VPLS 3) to v400h1 (VPLS 4).
    // Forward results should be empty
    replyMessage = makeReplyContext(vNoneHost1, v400Host1);
    expectInterfaces = ImmutableSet.of();
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
    // Reply message from vNoneh3 (VPLS 4) to vNoneH2 (VPLS 3).
    // Forward results should be empty
    replyMessage = makeReplyContext(vNoneHost3, vNoneHost2);
    expectInterfaces = ImmutableSet.of();
    vplsNeighbourHandler.handleReply(replyMessage, hostService);
    assertEquals(IFACES_NOT_EXPECTED, expectInterfaces, replyMessage.forwardResults);
}
#end_block

#method_before
@Override
public void forward(ConnectPoint outPort) {
    forwardResultsCPs.add(outPort);
}
#method_after
@Override
public void forward(ConnectPoint outPort) {
}
#end_block

#method_before
@Override
public void forward(Interface outIntf) {
    forwardResultsIfaces.add(outIntf);
}
#method_after
@Override
public void forward(Interface outIntf) {
    forwardResults.add(outIntf);
}
#end_block

#method_before
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, Set<String> cpNames, String encap) {
    if (!cpsByVplsName.containsKey(vplsName)) {
        cpNames.forEach(cpName -> {
            availableCPs.forEach(cp -> {
                if (cpName.equals(cp.deviceId() + "/" + cp.port())) {
                    cpsByVplsName.put(vplsName, cp);
                }
            });
        });
    }
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            availableInterfaces.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
    }
}
#method_after
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, String encap) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            availableInterfaces.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
    }
}
#end_block

#method_before
@Override
public void removeVpls(String vplsName) {
    if (cpsByVplsName.containsKey(vplsName)) {
        cpsByVplsName.removeAll(vplsName);
    }
    if (ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.removeAll(vplsName);
    }
}
#method_after
@Override
public void removeVpls(String vplsName) {
    if (ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.removeAll(vplsName);
    }
}
#end_block

#method_before
@Override
public void cleanVplsConfig() {
    cpsByVplsName.clear();
    ifacesByVplsName.clear();
}
#method_after
@Override
public void cleanVplsConfig() {
    ifacesByVplsName.clear();
}
#end_block

#method_before
protected static boolean ifaceAlreadyAssociated(String ifaceName) {
    return vplsConfigService.ifaces().stream().anyMatch(iface -> iface.name().equals(ifaceName));
}
#method_after
protected static boolean ifaceAlreadyAssociated(String ifaceName) {
    return vplsConfigService.allIfaces().stream().anyMatch(iface -> iface.name().equals(ifaceName));
}
#end_block

#method_before
public Set<VplsConfig> vplss() {
    Set<VplsConfig> vplss = Sets.newHashSet();
    JsonNode vplsNode = object.get(VPLS);
    if (vplsNode == null) {
        return vplss;
    }
    vplsNode.forEach(jsonNode -> {
        String name = jsonNode.get(NAME).asText();
        Set<String> cps = Sets.newHashSet();
        JsonNode vplsCPs = jsonNode.path(CP);
        if (vplsCPs.toString().isEmpty()) {
            vplsCPs = ((ObjectNode) jsonNode).putArray(CP);
        }
        vplsCPs.forEach(cpsNode -> cps.add(cpsNode.asText()));
        Set<String> ifaces = Sets.newHashSet();
        JsonNode vplsIfaces = jsonNode.path(INTERFACE);
        if (vplsIfaces.toString().isEmpty()) {
            vplsIfaces = ((ObjectNode) jsonNode).putArray(INTERFACE);
        }
        vplsIfaces.forEach(ifacesNode -> ifaces.add(ifacesNode.asText()));
        String encap = null;
        if (jsonNode.hasNonNull(ENCAPSULATION)) {
            encap = jsonNode.get(ENCAPSULATION).asText();
        }
        vplss.add(new VplsConfig(name, ifaces, cps, EncapsulationType.enumFromString(encap)));
    });
    return vplss;
}
#method_after
public Set<VplsConfig> vplss() {
    Set<VplsConfig> vplss = Sets.newHashSet();
    JsonNode vplsNode = object.get(VPLS);
    if (vplsNode == null) {
        return vplss;
    }
    vplsNode.forEach(jsonNode -> {
        String name = jsonNode.get(NAME).asText();
        Set<String> ifaces = Sets.newHashSet();
        JsonNode vplsIfaces = jsonNode.path(INTERFACE);
        if (vplsIfaces.toString().isEmpty()) {
            vplsIfaces = ((ObjectNode) jsonNode).putArray(INTERFACE);
        }
        vplsIfaces.forEach(ifacesNode -> ifaces.add(ifacesNode.asText()));
        String encap = null;
        if (jsonNode.hasNonNull(ENCAPSULATION)) {
            encap = jsonNode.get(ENCAPSULATION).asText();
        }
        vplss.add(new VplsConfig(name, ifaces, EncapsulationType.enumFromString(encap)));
    });
    return vplss;
}
#end_block

#method_before
public void addVpls(VplsConfig vpls) {
    ObjectNode vplsNode = JsonNodeFactory.instance.objectNode();
    vplsNode.put(NAME, vpls.name());
    ArrayNode ifacesNode = vplsNode.putArray(INTERFACE);
    vpls.ifaces().forEach(ifacesNode::add);
    ArrayNode cpsNode = vplsNode.putArray(CP);
    vpls.cps().forEach(cpsNode::add);
    vplsNode.put(ENCAPSULATION, vpls.encap().toString());
    ArrayNode vplsArray = vplss().isEmpty() ? initVplsConfiguration() : (ArrayNode) object.get(VPLS);
    vplsArray.add(vplsNode);
}
#method_after
public void addVpls(VplsConfig vpls) {
    ObjectNode vplsNode = JsonNodeFactory.instance.objectNode();
    vplsNode.put(NAME, vpls.name());
    ArrayNode ifacesNode = vplsNode.putArray(INTERFACE);
    vpls.ifaces().forEach(ifacesNode::add);
    vplsNode.put(ENCAPSULATION, vpls.encap().toString());
    ArrayNode vplsArray = vplss().isEmpty() ? initVplsConfiguration() : (ArrayNode) object.get(VPLS);
    vplsArray.add(vplsNode);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(Vpls.VPLS_APP);
    deviceService.addListener(deviceListener);
    interfaceService.addListener(interfaceListener);
    configService.addListener(configListener);
    configNeighbourHandler();
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(Vpls.VPLS_APP);
    interfaceService.addListener(interfaceListener);
    configService.addListener(configListener);
    configNeighbourHandler();
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    deviceService.removeListener(deviceListener);
    interfaceService.removeListener(interfaceListener);
    configService.removeListener(configListener);
    neighbourService.unregisterNeighbourHandlers(appId);
}
#method_after
@Deactivate
protected void deactivate() {
    interfaceService.removeListener(interfaceListener);
    configService.removeListener(configListener);
    neighbourService.unregisterNeighbourHandlers(appId);
}
#end_block

#method_before
private void configNeighbourHandler() {
    neighbourService.unregisterNeighbourHandlers(appId);
    Set<Interface> interfaces = vplsConfigService.allIfaces();
    // Interfaces
    interfaceService.getInterfaces().stream().filter(interfaces::contains).forEach(intf -> {
        neighbourService.registerNeighbourHandler(intf, neighbourHandler, appId);
    });
    // Connect points
    vplsConfigService.cps().stream().forEach(cp -> {
        neighbourService.registerNeighbourHandler(cp, neighbourHandler, appId);
    });
}
#method_after
private void configNeighbourHandler() {
    neighbourService.unregisterNeighbourHandlers(appId);
    Set<Interface> interfaces = vplsConfigService.allIfaces();
    interfaceService.getInterfaces().stream().filter(interfaces::contains).forEach(intf -> {
        neighbourService.registerNeighbourHandler(intf, neighbourHandler, appId);
    });
}
#end_block

#method_before
protected void handleRequest(NeighbourMessageContext context) {
    Multimap<String, Object> networkPoints = generateNetworkPoints(context);
    networkPoints.values().forEach(point -> {
        if (point instanceof Interface) {
            Interface intf = (Interface) point;
            if (!intf.connectPoint().equals(context.inPort())) {
                context.forward(intf);
            }
        } else if (point instanceof ConnectPoint) {
            ConnectPoint cp = (ConnectPoint) point;
            if (!cp.equals(context.inPort())) {
                context.forward(cp);
            }
        }
    });
}
#method_after
protected void handleRequest(NeighbourMessageContext context) {
    SetMultimap<String, Interface> interfaces = vplsConfigService.ifacesByVplsName(context.vlan(), context.inPort());
    if (interfaces != null) {
        interfaces.values().stream().filter(intf -> !context.inPort().equals(intf.connectPoint())).forEach(context::forward);
    } else {
        log.debug(CAN_NOT_FIND_VPLS, context.inPort(), context.vlan());
    }
}
#end_block

#method_before
protected void handleReply(NeighbourMessageContext context, HostService hostService) {
    Set<Host> hosts = hostService.getHostsByMac(context.dstMac());
    Multimap<String, Object> networkPoints = generateNetworkPoints(context);
    hosts.forEach(host -> networkPoints.values().forEach(point -> {
        if (point instanceof Interface) {
            Interface intf = (Interface) point;
            if (intf.connectPoint().equals(host.location()) && host.vlan().equals(intf.vlan())) {
                context.forward(intf);
            }
        }
        if (point instanceof ConnectPoint) {
            ConnectPoint cp = (ConnectPoint) point;
            if (cp.equals(host.location())) {
                context.forward(cp);
            }
        }
    }));
}
#method_after
protected void handleReply(NeighbourMessageContext context, HostService hostService) {
    Set<Host> hosts = hostService.getHostsByMac(context.dstMac());
    SetMultimap<String, Interface> interfaces = vplsConfigService.ifacesByVplsName(context.vlan(), context.inPort());
    if (interfaces != null) {
        hosts.forEach(host -> interfaces.values().stream().filter(intf -> intf.connectPoint().equals(host.location())).filter(intf -> intf.vlan().equals(host.vlan())).forEach(context::forward));
    } else {
        log.debug(CAN_NOT_FIND_VPLS, context.inPort(), context.vlan());
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    idGenerator = new TestIdGenerator();
    Intent.bindIdGenerator(idGenerator);
    applicationService = createMock(ApplicationService.class);
    configService = createMock(NetworkConfigService.class);
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(APPID);
    replay(coreService);
    hostsAvailable = Sets.newHashSet();
    hostService = new TestHostService(hostsAvailable);
    intentService = new TestIntentService();
    TestIntentSynchronizer intentSynchronizer = new TestIntentSynchronizer(intentService);
    deviceService = createMock(VplsNeighbourHandlerTest.TestDeviceService.class);
    deviceService.addListener(anyObject(DeviceListener.class));
    expectLastCall().anyTimes();
    addCPConfig();
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    addIfaceConfig();
    Map<String, EncapsulationType> encapByVpls = new HashMap<>();
    encapByVpls.put(VPLS1, VLAN);
    encapByVpls.put(VPLS2, NONE);
    encapByVpls.put(VPLS3, NONE);
    vplsConfigService = new TestVplsConfigService(interfacesByVpls, cpsByVpls, encapByVpls);
    vpls = new Vpls();
    vpls.applicationService = applicationService;
    vpls.coreService = coreService;
    vpls.hostService = hostService;
    vpls.vplsConfigService = vplsConfigService;
    vpls.deviceService = deviceService;
    vpls.intentService = intentService;
    vpls.interfaceService = interfaceService;
    vpls.configService = configService;
    vpls.intentSynchronizer = intentSynchronizer;
}
#method_after
@Before
public void setUp() throws Exception {
    idGenerator = new TestIdGenerator();
    Intent.bindIdGenerator(idGenerator);
    applicationService = createMock(ApplicationService.class);
    configService = createMock(NetworkConfigService.class);
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(APPID);
    replay(coreService);
    hostsAvailable = Sets.newHashSet();
    hostService = new TestHostService(hostsAvailable);
    intentService = new TestIntentService();
    TestIntentSynchronizer intentSynchronizer = new TestIntentSynchronizer(intentService);
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    addIfaceConfig();
    interfacesByVpls.put(VPLS1, V100H1);
    interfacesByVpls.put(VPLS1, V200H1);
    interfacesByVpls.put(VPLS1, V300H1);
    interfacesByVpls.put(VPLS2, V100H2);
    interfacesByVpls.put(VPLS2, V200H2);
    interfacesByVpls.put(VPLS2, V300H2);
    interfacesByVpls.put(VPLS3, VNONEH1);
    interfacesByVpls.put(VPLS3, VNONEH2);
    interfacesByVpls.put(VPLS4, V400H1);
    interfacesByVpls.put(VPLS4, VNONEH3);
    Map<String, EncapsulationType> encapByVpls = new HashMap<>();
    encapByVpls.put(VPLS1, VLAN);
    encapByVpls.put(VPLS2, NONE);
    encapByVpls.put(VPLS3, NONE);
    encapByVpls.put(VPLS4, NONE);
    vplsConfigService = new TestVplsConfigService(interfacesByVpls, encapByVpls);
    vpls = new Vpls();
    vpls.applicationService = applicationService;
    vpls.coreService = coreService;
    vpls.hostService = hostService;
    vpls.vplsConfigService = vplsConfigService;
    vpls.intentService = intentService;
    vpls.interfaceService = interfaceService;
    vpls.configService = configService;
    vpls.intentSynchronizer = intentSynchronizer;
}
#end_block

#method_before
private void addIfaceConfig() {
    Set<Interface> interfaces = ImmutableSet.copyOf(AVAILABLE_INTERFACES);
    Set<Interface> vlanOneSet = ImmutableSet.of(V100H1, V100H2);
    Set<Interface> vlanTwoSet = ImmutableSet.of(V200H1, V200H2);
    Set<Interface> vlanThreeSet = ImmutableSet.of(V300H1, V300H2);
    AVAILABLE_INTERFACES.forEach(intf -> {
        expect(interfaceService.getInterfacesByPort(intf.connectPoint())).andReturn(Sets.newHashSet(intf)).anyTimes();
    });
    expect(interfaceService.getInterfacesByVlan(VLAN100)).andReturn(vlanOneSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN200)).andReturn(vlanTwoSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN300)).andReturn(vlanThreeSet).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    replay(interfaceService);
}
#method_after
private void addIfaceConfig() {
    Set<Interface> interfaces = ImmutableSet.copyOf(AVAILABLE_INTERFACES);
    Set<Interface> vlanOneSet = ImmutableSet.of(V100H1, V100H2);
    Set<Interface> vlanTwoSet = ImmutableSet.of(V200H1, V200H2);
    Set<Interface> vlanThreeSet = ImmutableSet.of(VNONEH1, VNONEH2);
    Set<Interface> vlanFourSet = ImmutableSet.of(V400H1, VNONEH3);
    AVAILABLE_INTERFACES.forEach(intf -> {
        expect(interfaceService.getInterfacesByPort(intf.connectPoint())).andReturn(Sets.newHashSet(intf)).anyTimes();
    });
    expect(interfaceService.getInterfacesByVlan(VLAN100)).andReturn(vlanOneSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN200)).andReturn(vlanTwoSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN300)).andReturn(vlanThreeSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN400)).andReturn(vlanFourSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VlanId.NONE)).andReturn(vlanFourSet).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    replay(interfaceService);
}
#end_block

#method_before
@Test
public void activateNoHosts() {
    fillCPs();
    fillInterfaces();
    vpls.activate();
    List<Intent> expectedIntents = Lists.newArrayList();
    Set<FilteredConnectPoint> fcPoints;
    fcPoints = buildFCPoints(ImmutableSet.of(V100H1, V200H1, V300H1));
    expectedIntents.addAll(generateVplsBrc(fcPoints, VPLS1, VLAN));
    fcPoints = buildFCPoints(ImmutableSet.of(V100H2, V200H2, V300H2));
    expectedIntents.addAll(generateVplsBrc(fcPoints, VPLS2, NONE));
    fcPoints = buildFCPoints(ImmutableSet.of(CP8, CP9));
    expectedIntents.addAll(generateVplsBrc(fcPoints, VPLS3, NONE));
    checkIntents(expectedIntents);
}
#method_after
@Test
public void activateNoHosts() {
    vpls.activate();
    List<Intent> expectedIntents = Lists.newArrayList();
    Set<FilteredConnectPoint> fcPoints;
    fcPoints = buildFCPoints(ImmutableSet.of(V100H1, V200H1, V300H1));
    expectedIntents.addAll(generateVplsBrc(fcPoints, VPLS1, VLAN));
    fcPoints = buildFCPoints(ImmutableSet.of(V100H2, V200H2, V300H2));
    expectedIntents.addAll(generateVplsBrc(fcPoints, VPLS2, NONE));
    fcPoints = buildFCPoints(ImmutableSet.of(VNONEH1, VNONEH2));
    expectedIntents.addAll(generateVplsBrc(fcPoints, VPLS3, NONE));
    fcPoints = buildFCPoints(ImmutableSet.of(V400H1, VNONEH3));
    expectedIntents.addAll(generateVplsBrc(fcPoints, VPLS4, NONE));
    checkIntents(expectedIntents);
}
#end_block

#method_before
private Set<FilteredConnectPoint> buildFCPoints(Collection<Object> points) {
    // Build all filtered connected points in the VPLS
    return points.stream().map(point -> {
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
        if (point instanceof Interface) {
            Interface specPoint = (Interface) point;
            if (!specPoint.vlan().equals(VlanId.NONE)) {
                selectorBuilder.matchVlanId(specPoint.vlan());
            }
            return new FilteredConnectPoint(specPoint.connectPoint(), selectorBuilder.build());
        } else {
            ConnectPoint specPoint = (ConnectPoint) point;
            return new FilteredConnectPoint(specPoint, selectorBuilder.build());
        }
    }).collect(Collectors.toSet());
}
#method_after
private Set<FilteredConnectPoint> buildFCPoints(Collection<Interface> interfaces) {
    // Build all filtered connected points in the VPLS
    return interfaces.stream().map(intf -> {
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
        if (!intf.vlan().equals(VlanId.NONE)) {
            selectorBuilder.matchVlanId(intf.vlan());
        }
        return new FilteredConnectPoint(intf.connectPoint(), selectorBuilder.build());
    }).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, Set<String> cpNames, String encap) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            AVAILABLE_INTERFACES.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
    }
    if (!cpsByVplsName.containsKey(vplsName)) {
        cpNames.forEach(cpName -> {
            AVAILABLE_CPS.forEach(cp -> {
                if (cpName.equals(cp.deviceId() + "/" + cp.port())) {
                    cpsByVplsName.put(vplsName, cp);
                }
            });
        });
    }
    if (!ifacesByVplsName.containsKey(vplsName) || !cpsByVplsName.containsKey(vplsName)) {
        encapsByVplsName.put(vplsName, valueOf(encap));
    }
}
#method_after
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, String encap) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            AVAILABLE_INTERFACES.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
    }
    if (!ifacesByVplsName.containsKey(vplsName)) {
        encapsByVplsName.put(vplsName, valueOf(encap));
    }
}
#end_block

#method_before
@Override
public void removeVpls(String vplsName) {
    if (cpsByVplsName.containsKey(vplsName)) {
        cpsByVplsName.removeAll(vplsName);
    }
    if (ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.removeAll(vplsName);
    }
}
#method_after
@Override
public void removeVpls(String vplsName) {
    if (ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.removeAll(vplsName);
    }
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(VPLS_APP);
    intentInstaller = new IntentInstaller(appId, intentService, intentSynchronizer);
    applicationService.registerDeactivateHook(appId, () -> {
        intentSynchronizer.removeIntentsByAppId(appId);
    });
    hostService.addListener(hostListener);
    if (deviceService != null) {
        deviceService.addListener(deviceListener);
    }
    interfaceService.addListener(interfaceListener);
    configService.addListener(configListener);
    setupConnectivity(false);
    log.info("Activated");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(VPLS_APP);
    intentInstaller = new IntentInstaller(appId, intentService, intentSynchronizer);
    applicationService.registerDeactivateHook(appId, () -> {
        intentSynchronizer.removeIntentsByAppId(appId);
    });
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    configService.addListener(configListener);
    setupConnectivity(false);
    log.info("Activated");
}
#end_block

#method_before
private void setupConnectivity(boolean isNetworkConfigEvent) {
    Set<String> vplsAffectedByApi = new HashSet<>(vplsConfigService.vplsAffectedByApi());
    if (isNetworkConfigEvent && vplsAffectedByApi.isEmpty()) {
        vplsAffectedByApi.addAll(vplsConfigService.vplsNamesOld());
    }
    // Interfaces
    SetMultimap<String, Interface> networkInterfaces = vplsConfigService.ifacesByVplsName();
    // Connect points
    SetMultimap<String, ConnectPoint> networkCPs = vplsConfigService.cpsByVplsName();
    // Gather all interfaces and connect points
    Multimap<String, Object> networkPoints = ArrayListMultimap.create();
    networkPoints.putAll(networkInterfaces);
    networkPoints.putAll(networkCPs);
    networkPoints.asMap().forEach((vplsName, points) -> {
        // Add hosts that belongs to the specific VPLS
        Set<Host> hosts = Sets.newHashSet();
        points.forEach(point -> {
            if (point instanceof Interface) {
                Interface specPoint = (Interface) point;
                hostService.getConnectedHosts(specPoint.connectPoint()).stream().filter(host -> host.vlan().equals(specPoint.vlan())).forEach(hosts::add);
            }
            if (point instanceof ConnectPoint) {
                ConnectPoint specPoint = (ConnectPoint) point;
                hostService.getConnectedHosts(specPoint).stream().forEach(hosts::add);
            }
        });
        EncapsulationType encap = vplsConfigService.encap(vplsName);
        // Set up connectivity for both interfaces and connect points
        setupConnectivity(vplsName, points, hosts, encap, vplsAffectedByApi.contains(vplsName));
        vplsAffectedByApi.remove(vplsName);
    });
    if (!vplsAffectedByApi.isEmpty()) {
        for (String networkName : vplsAffectedByApi) {
            withdrawIntents(networkName, Lists.newArrayList());
        }
    }
}
#method_after
private void setupConnectivity(boolean isNetworkConfigEvent) {
    SetMultimap<String, Interface> networkInterfaces = vplsConfigService.ifacesByVplsName();
    Set<String> vplsAffectedByApi = new HashSet<>(vplsConfigService.vplsAffectedByApi());
    if (isNetworkConfigEvent && vplsAffectedByApi.isEmpty()) {
        vplsAffectedByApi.addAll(vplsConfigService.vplsNamesOld());
    }
    networkInterfaces.asMap().forEach((vplsName, interfaces) -> {
        Set<Host> hosts = Sets.newHashSet();
        interfaces.forEach(intf -> {
            // Add hosts that belongs to the specific VPLS
            hostService.getConnectedHosts(intf.connectPoint()).stream().filter(host -> host.vlan().equals(intf.vlan())).forEach(hosts::add);
        });
        EncapsulationType encap = vplsConfigService.encap(vplsName);
        setupConnectivity(vplsName, interfaces, hosts, encap, vplsAffectedByApi.contains(vplsName));
        vplsAffectedByApi.remove(vplsName);
    });
    if (!vplsAffectedByApi.isEmpty()) {
        for (String vplsName : vplsAffectedByApi) {
            withdrawIntents(vplsName, Lists.newArrayList());
        }
    }
}
#end_block

#method_before
private void setupConnectivity(String vplsName, Collection<Object> points, Set<Host> hosts, EncapsulationType encap, boolean affectedByApi) {
    List<Intent> intents = Lists.newArrayList();
    List<Key> keys = Lists.newArrayList();
    Set<FilteredConnectPoint> fcPoints = buildFCPoints(points);
    intents.addAll(buildUnicastIntents(vplsName, hosts, fcPoints, encap, affectedByApi));
    intents.addAll(buildBroadcastIntents(vplsName, fcPoints, encap, affectedByApi));
    if (affectedByApi) {
        intents.forEach(intent -> keys.add(intent.key()));
        withdrawIntents(vplsName, keys);
    }
    intentInstaller.submitIntents(intents);
}
#method_after
private void setupConnectivity(String vplsName, Collection<Interface> interfaces, Set<Host> hosts, EncapsulationType encap, boolean affectedByApi) {
    List<Intent> intents = Lists.newArrayList();
    List<Key> keys = Lists.newArrayList();
    Set<FilteredConnectPoint> fcPoints = buildFCPoints(interfaces);
    intents.addAll(buildBroadcastIntents(vplsName, fcPoints, encap, affectedByApi));
    intents.addAll(buildUnicastIntents(vplsName, hosts, fcPoints, encap, affectedByApi));
    if (affectedByApi) {
        intents.forEach(intent -> keys.add(intent.key()));
        withdrawIntents(vplsName, keys);
    }
    intentInstaller.submitIntents(intents);
}
#end_block

#method_before
private Set<FilteredConnectPoint> buildFCPoints(Collection<Object> points) {
    // Build all filtered connected points in the VPLS
    return points.stream().map(point -> {
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
        if (point instanceof Interface) {
            Interface specPoint = (Interface) point;
            if (!specPoint.vlan().equals(VlanId.NONE)) {
                selectorBuilder.matchVlanId(specPoint.vlan());
            }
            return new FilteredConnectPoint(specPoint.connectPoint(), selectorBuilder.build());
        } else {
            ConnectPoint specPoint = (ConnectPoint) point;
            return new FilteredConnectPoint(specPoint, selectorBuilder.build());
        }
    }).collect(Collectors.toSet());
}
#method_after
private Set<FilteredConnectPoint> buildFCPoints(Collection<Interface> interfaces) {
    // Build all filtered connected points in the VPLS
    return interfaces.stream().map(intf -> {
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
        if (!intf.vlan().equals(VlanId.NONE)) {
            selectorBuilder.matchVlanId(intf.vlan());
        }
        return new FilteredConnectPoint(intf.connectPoint(), selectorBuilder.build());
    }).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public void addVpls(String vplsName, Set<String> ifaces, Set<String> cps, String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (ifacesOfVpls.containsKey(vplsName) || cpsOfVpls.containsKey(vplsName)) {
        if (ifaces.isEmpty()) {
            return;
        }
        ifaces.forEach(iface -> vplsAppConfig.addIface(vplsName, iface));
        if (cps.isEmpty()) {
            return;
        }
        cps.forEach(cp -> vplsAppConfig.addCP(vplsName, cp));
        vplsAppConfig.setEncap(vplsName, encapType);
    } else {
        vplsAppConfig.addVpls(new VplsConfig(vplsName, ifaces, cps, encapType));
    }
    vplsAffectedByApi.add(vplsName);
    applyConfig(vplsAppConfig);
}
#method_after
@Override
public void addVpls(String vplsName, Set<String> ifaces, String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (ifacesOfVpls.containsKey(vplsName)) {
        if (ifaces.isEmpty()) {
            return;
        }
        ifaces.forEach(iface -> vplsAppConfig.addIface(vplsName, iface));
        vplsAppConfig.setEncap(vplsName, encapType);
    } else {
        vplsAppConfig.addVpls(new VplsConfig(vplsName, ifaces, encapType));
    }
    vplsAffectedByApi.add(vplsName);
    applyConfig(vplsAppConfig);
}
#end_block

#method_before
@Override
public void setEncap(String vplsName, String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (ifacesOfVpls.containsKey(vplsName) || cpsOfVpls.containsKey(vplsName)) {
        vplsAppConfig.setEncap(vplsName, encapType);
        vplsAffectedByApi.add(vplsName);
        applyConfig(vplsAppConfig);
    }
}
#method_after
@Override
public void setEncap(String vplsName, String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (ifacesOfVpls.containsKey(vplsName)) {
        vplsAppConfig.setEncap(vplsName, encapType);
        vplsAffectedByApi.add(vplsName);
        applyConfig(vplsAppConfig);
    }
}
#end_block

#method_before
@Override
public void cleanVplsConfig() {
    Multimap<String, Object> networkPoints = ArrayListMultimap.create();
    networkPoints.putAll(ifacesOfVpls);
    networkPoints.putAll(cpsOfVpls);
    networkPoints.entries().forEach(e -> {
        vplsAppConfig.removeVpls(e.getKey());
        vplsAffectedByApi.add(e.getKey());
    });
    applyConfig(vplsAppConfig);
}
#method_after
@Override
public void cleanVplsConfig() {
    ifacesOfVpls.entries().forEach(e -> {
        vplsAppConfig.removeVpls(e.getKey());
        vplsAffectedByApi.add(e.getKey());
    });
    applyConfig(vplsAppConfig);
}
#end_block

#method_before
private void loadConfiguration() {
    loadAppId();
    vplsAppConfig = configService.getConfig(vplsAppId, VplsAppConfig.class);
    if (vplsAppConfig == null) {
        log.warn(CONFIG_NULL);
        configService.addConfig(vplsAppId, VplsAppConfig.class);
        return;
    }
    oldIfacesOfVpls = ifacesOfVpls;
    cpsOfVpls = getConfigCPs();
    ifacesOfVpls = getConfigInterfaces();
    vplsCPs = getConfigCPointsFromCPs();
    vplsIfaces = getConfigCPointsFromIfaces();
    vplsEncaps = getConfigEncap();
    log.debug(CONFIG_CHANGED, cpsOfVpls, ifacesOfVpls);
}
#method_after
private void loadConfiguration() {
    loadAppId();
    vplsAppConfig = configService.getConfig(vplsAppId, VplsAppConfig.class);
    if (vplsAppConfig == null) {
        log.warn(CONFIG_NULL);
        configService.addConfig(vplsAppId, VplsAppConfig.class);
        return;
    }
    oldIfacesOfVpls = ifacesOfVpls;
    ifacesOfVpls = getConfigInterfaces();
    vplsIfaces = getConfigCPointsFromIfaces();
    vplsEncaps = getConfigEncap();
    log.debug(CONFIG_CHANGED, ifacesOfVpls);
}
#end_block

#method_before
@Override
public void addVpls(String vplsName, Set<String> ifaces, Set<String> cps, String encap) {
}
#method_after
@Override
public void addVpls(String vplsName, Set<String> ifaces, String encap) {
}
#end_block

#method_before
@Override
protected void execute() {
    Set<String> vplsNames = vplsConfigService.vplsNames();
    encapByVplsName = vplsConfigService.encapByVplsName();
    if (!isNullOrEmpty(vplsName)) {
        // A VPLS name is provided. Check first if the VPLS exists
        if (VplsCommandUtils.vplsExists(vplsName)) {
            fillAndShow(vplsName);
        } else {
            print(VplsCommandUtils.VPLS_NOT_FOUND, vplsName);
        }
    } else {
        // No VPLS names are provided. Display all VPLSs configured
        vplsNames.forEach(this::fillAndShow);
    }
}
#method_after
@Override
protected void execute() {
    Set<String> vplsNames = vplsConfigService.vplsNames();
    Map<String, EncapsulationType> encapByVplsName = vplsConfigService.encapByVplsName();
    if (!isNullOrEmpty(vplsName)) {
        // A VPLS name is provided. Check first if the VPLS exists
        if (VplsCommandUtils.vplsExists(vplsName)) {
            print(VplsCommandUtils.VPLS_DISPLAY, vplsName, VplsCommandUtils.ifacesFromVplsName(vplsName).toString(), encapByVplsName.get(vplsName).toString());
        } else {
            print(VplsCommandUtils.VPLS_NOT_FOUND, vplsName);
        }
    } else {
        // No VPLS names are provided. Display all VPLSs configured
        vplsNames.forEach(vplsName -> {
            print(VplsCommandUtils.VPLS_DISPLAY, vplsName, VplsCommandUtils.ifacesFromVplsName(vplsName).toString(), encapByVplsName.get(vplsName).toString());
        });
    }
}
#end_block

#method_before
@Override
protected void execute() {
    // Check if the VPLS name is already configured
    if (VplsCommandUtils.vplsExists(vplsName)) {
        print(VplsCommandUtils.VPLS_ALREADY_EXISTS, vplsName);
        return;
    }
    vplsConfigService.addVpls(vplsName, new HashSet<>(), new HashSet<>(), null);
}
#method_after
@Override
protected void execute() {
    // Check if the VPLS name is already configured
    if (VplsCommandUtils.vplsExists(vplsName)) {
        print(VplsCommandUtils.VPLS_ALREADY_EXISTS, vplsName);
        return;
    }
    vplsConfigService.addVpls(vplsName, new HashSet<>(), null);
}
#end_block

#method_before
private VirtualNetwork setupVirtualNetworkTopology() {
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    VirtualDevice virtualDevice1 = manager.createVirtualDevice(virtualNetwork.id(), DID1);
    VirtualDevice virtualDevice2 = manager.createVirtualDevice(virtualNetwork.id(), DID2);
    VirtualDevice virtualDevice3 = manager.createVirtualDevice(virtualNetwork.id(), DID3);
    VirtualDevice virtualDevice4 = manager.createVirtualDevice(virtualNetwork.id(), DID4);
    VirtualDevice virtualDevice5 = manager.createVirtualDevice(virtualNetwork.id(), DID5);
    ConnectPoint cp1 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(1));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(1), cp1);
    ConnectPoint cp2 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(2));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(2), cp2);
    ConnectPoint cp3 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(3));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(3), cp3);
    ConnectPoint cp4 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(4));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(4), cp4);
    ConnectPoint cp5 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(5));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(5), cp5);
    cp6 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(6));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(6), cp6);
    cp7 = new ConnectPoint(virtualDevice4.id(), PortNumber.portNumber(7));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice4.id(), PortNumber.portNumber(7), cp7);
    ConnectPoint cp8 = new ConnectPoint(virtualDevice4.id(), PortNumber.portNumber(8));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice4.id(), PortNumber.portNumber(8), cp8);
    ConnectPoint cp9 = new ConnectPoint(virtualDevice5.id(), PortNumber.portNumber(9));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice5.id(), PortNumber.portNumber(9), cp9);
    VirtualLink link1 = manager.createVirtualLink(virtualNetwork.id(), cp1, cp3);
    virtualNetworkManagerStore.updateLink(link1, link1.tunnelId(), Link.State.ACTIVE);
    VirtualLink link2 = manager.createVirtualLink(virtualNetwork.id(), cp3, cp1);
    virtualNetworkManagerStore.updateLink(link2, link2.tunnelId(), Link.State.ACTIVE);
    VirtualLink link3 = manager.createVirtualLink(virtualNetwork.id(), cp4, cp5);
    virtualNetworkManagerStore.updateLink(link3, link3.tunnelId(), Link.State.ACTIVE);
    VirtualLink link4 = manager.createVirtualLink(virtualNetwork.id(), cp5, cp4);
    virtualNetworkManagerStore.updateLink(link4, link4.tunnelId(), Link.State.ACTIVE);
    VirtualLink link5 = manager.createVirtualLink(virtualNetwork.id(), cp8, cp9);
    virtualNetworkManagerStore.updateLink(link5, link5.tunnelId(), Link.State.ACTIVE);
    VirtualLink link6 = manager.createVirtualLink(virtualNetwork.id(), cp9, cp8);
    virtualNetworkManagerStore.updateLink(link6, link6.tunnelId(), Link.State.ACTIVE);
    topologyService = manager.get(virtualNetwork.id(), TopologyService.class);
    topologyProvider = new VirtualNetworkTopologyProvider();
    topologyProvider.topologyService = topologyService;
    return virtualNetwork;
}
#method_after
private VirtualNetwork setupVirtualNetworkTopology() {
    manager.registerTenantId(TenantId.tenantId(tenantIdValue1));
    VirtualNetwork virtualNetwork = manager.createVirtualNetwork(TenantId.tenantId(tenantIdValue1));
    VirtualDevice virtualDevice1 = manager.createVirtualDevice(virtualNetwork.id(), DID1);
    VirtualDevice virtualDevice2 = manager.createVirtualDevice(virtualNetwork.id(), DID2);
    VirtualDevice virtualDevice3 = manager.createVirtualDevice(virtualNetwork.id(), DID3);
    VirtualDevice virtualDevice4 = manager.createVirtualDevice(virtualNetwork.id(), DID4);
    VirtualDevice virtualDevice5 = manager.createVirtualDevice(virtualNetwork.id(), DID5);
    ConnectPoint cp1 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(1));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(1), cp1);
    ConnectPoint cp2 = new ConnectPoint(virtualDevice1.id(), PortNumber.portNumber(2));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice1.id(), PortNumber.portNumber(2), cp2);
    ConnectPoint cp3 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(3));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(3), cp3);
    ConnectPoint cp4 = new ConnectPoint(virtualDevice2.id(), PortNumber.portNumber(4));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice2.id(), PortNumber.portNumber(4), cp4);
    ConnectPoint cp5 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(5));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(5), cp5);
    cp6 = new ConnectPoint(virtualDevice3.id(), PortNumber.portNumber(6));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice3.id(), PortNumber.portNumber(6), cp6);
    cp7 = new ConnectPoint(virtualDevice4.id(), PortNumber.portNumber(7));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice4.id(), PortNumber.portNumber(7), cp7);
    ConnectPoint cp8 = new ConnectPoint(virtualDevice4.id(), PortNumber.portNumber(8));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice4.id(), PortNumber.portNumber(8), cp8);
    ConnectPoint cp9 = new ConnectPoint(virtualDevice5.id(), PortNumber.portNumber(9));
    manager.createVirtualPort(virtualNetwork.id(), virtualDevice5.id(), PortNumber.portNumber(9), cp9);
    VirtualLink link1 = manager.createVirtualLink(virtualNetwork.id(), cp1, cp3);
    virtualNetworkManagerStore.updateLink(link1, link1.tunnelId(), Link.State.ACTIVE);
    VirtualLink link2 = manager.createVirtualLink(virtualNetwork.id(), cp3, cp1);
    virtualNetworkManagerStore.updateLink(link2, link2.tunnelId(), Link.State.ACTIVE);
    VirtualLink link3 = manager.createVirtualLink(virtualNetwork.id(), cp4, cp5);
    virtualNetworkManagerStore.updateLink(link3, link3.tunnelId(), Link.State.ACTIVE);
    VirtualLink link4 = manager.createVirtualLink(virtualNetwork.id(), cp5, cp4);
    virtualNetworkManagerStore.updateLink(link4, link4.tunnelId(), Link.State.ACTIVE);
    VirtualLink link5 = manager.createVirtualLink(virtualNetwork.id(), cp8, cp9);
    virtualNetworkManagerStore.updateLink(link5, link5.tunnelId(), Link.State.ACTIVE);
    VirtualLink link6 = manager.createVirtualLink(virtualNetwork.id(), cp9, cp8);
    virtualNetworkManagerStore.updateLink(link6, link6.tunnelId(), Link.State.ACTIVE);
    topologyService = manager.get(virtualNetwork.id(), TopologyService.class);
    topologyProvider = new DefaultVirtualNetworkProvider();
    try {
        TestUtils.setField(topologyProvider, "topologyService", topologyService);
    } catch (TestUtils.TestUtilsException e) {
        e.printStackTrace();
    }
    return virtualNetwork;
}
#end_block

#method_before
@Override
public Builder of(Tunnel tunnel) {
    this.id = TunnelId.valueOf(tunnel.tunnelId().id());
    this.source = tunnel.path().src().deviceId().toString();
    this.destination = tunnel.path().dst().deviceId().toString();
    this.name = tunnel.tunnelName().toString();
    // LSP type
    String lspType = tunnel.annotations().value(PcepAnnotationKeys.LSP_SIG_TYPE);
    if (lspType != null) {
        this.lspType = LspType.values()[LspType.valueOf(lspType).type()];
    }
    // Cost type
    String costType = tunnel.annotations().value(PcepAnnotationKeys.COST_TYPE);
    if (costType != null) {
        this.costConstraint = CostConstraint.of(CostConstraint.Type.valueOf(costType));
    }
    // Bandwidth
    String bandwidth = tunnel.annotations().value(PcepAnnotationKeys.BANDWIDTH);
    if (bandwidth != null) {
        this.bandwidthConstraint = BandwidthConstraint.of(Double.parseDouble(bandwidth), DataRateUnit.valueOf("BPS"));
    }
    PceStore pceStore = get(PceStore.class);
    List<ExplicitPathInfo> explicitPathInfoList = pceStore.getTunnelNameExplicitPathInfoMap(tunnel.tunnelName().value());
    if (explicitPathInfoList != null) {
        this.explicitPathInfo = explicitPathInfoList;
    }
    return this;
}
#method_after
@Override
public Builder of(Tunnel tunnel, List<ExplicitPathInfo> explicitPathInfoList) {
    this.id = TunnelId.valueOf(tunnel.tunnelId().id());
    this.source = tunnel.path().src().deviceId().toString();
    this.destination = tunnel.path().dst().deviceId().toString();
    this.name = tunnel.tunnelName().toString();
    // LSP type
    String lspType = tunnel.annotations().value(PcepAnnotationKeys.LSP_SIG_TYPE);
    if (lspType != null) {
        this.lspType = LspType.values()[LspType.valueOf(lspType).type()];
    }
    // Cost type
    String costType = tunnel.annotations().value(PcepAnnotationKeys.COST_TYPE);
    if (costType != null) {
        this.costConstraint = CostConstraint.of(CostConstraint.Type.valueOf(costType));
    }
    // Bandwidth
    String bandwidth = tunnel.annotations().value(PcepAnnotationKeys.BANDWIDTH);
    if (bandwidth != null) {
        this.bandwidthConstraint = BandwidthConstraint.of(Double.parseDouble(bandwidth), DataRateUnit.valueOf("BPS"));
    }
    // Explicit Path
    if (explicitPathInfoList != null) {
        this.explicitPathInfo = explicitPathInfoList;
    }
    return this;
}
#end_block

#method_before
private List<Path> computeExplicitPath(List<ExplicitPathInfo> explicitPathInfo, DeviceId src, DeviceId dst, List<Constraint> constraints) {
    List<Path> finalComputedPath = new LinkedList<>();
    for (ExplicitPathInfo info : explicitPathInfo) {
        /*
             * If explicit path object is LOOSE,
             * 1) If specified as DeviceId (node) :
             * If it is source , compute from source to destination (partial computation not required),
             * otherwise compute from specified source to specified device
             * 2) If specified as Link :
             * Compute partial path from source to link's source , if path exists compute from link's source to dst
             */
        if (info.type().equals(ExplicitPathInfo.Type.LOOSE)) {
            if (info.value() instanceof DeviceId) {
                // If deviceId is source no need to compute
                if (!(info.value()).equals(src)) {
                    log.debug("computeExplicitPath :: Loose , device");
                    finalComputedPath = computePartialPath(finalComputedPath, src, (DeviceId) info.value(), constraints);
                    log.debug("finalComputedPath in computeExplicitPath ::" + finalComputedPath);
                }
            } else if (info.value() instanceof Link) {
                if ((((Link) info.value()).src().deviceId().equals(src)) || (!finalComputedPath.isEmpty() && finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(((Link) info.value()).src().deviceId()))) {
                    finalComputedPath = computePartialPath(finalComputedPath, src, ((Link) info.value()).dst().deviceId(), constraints);
                } else {
                    finalComputedPath = computePartialPath(finalComputedPath, src, ((Link) info.value()).src().deviceId(), constraints) != null ? computePartialPath(finalComputedPath, src, ((Link) info.value()).dst().deviceId(), constraints) : null;
                }
            }
        /*
                 * If explicit path object is STRICT,
                 * 1) If specified as DeviceId (node) :
                 * Check whether partial computed path has reachable to strict specified node or
                 * strict node is the source, if no set path as null else do nothing
                 * 2) If specified as Link :
                 * Check whether partial computed path has reachable to strict link's src, if yes compute
                 * path from strict link's src to link's dst (to include specified link)
                 */
        } else if (info.type().equals(ExplicitPathInfo.Type.STRICT)) {
            if (info.value() instanceof DeviceId) {
                log.debug("computeExplicitPath :: Strict , device");
                if (!(!finalComputedPath.isEmpty() && finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(info.value())) && !info.value().equals(src)) {
                    finalComputedPath = null;
                }
            } else if (info.value() instanceof Link) {
                log.info("computeExplicitPath :: Strict");
                finalComputedPath = ((Link) info.value()).src().deviceId().equals(src) || !finalComputedPath.isEmpty() && finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(((Link) info.value()).src().deviceId()) ? computePartialPath(finalComputedPath, src, ((Link) info.value()).dst().deviceId(), constraints) : null;
                if (finalComputedPath != null && !finalComputedPath.get(finalComputedPath.size() - 1).links().contains((Link) info.value())) {
                    finalComputedPath = null;
                }
            }
        }
        if (finalComputedPath == null) {
            return null;
        }
    }
    // Destination is not reached in Partial computed path then compute till destination
    if (finalComputedPath.isEmpty() || !finalComputedPath.isEmpty() && !finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(dst)) {
        finalComputedPath = computePartialPath(finalComputedPath, src, dst, constraints);
        if (finalComputedPath == null) {
            return null;
        }
    }
    return finalComputedPath;
}
#method_after
private List<Path> computeExplicitPath(List<ExplicitPathInfo> explicitPathInfo, DeviceId src, DeviceId dst, List<Constraint> constraints) {
    List<Path> finalComputedPath = new LinkedList<>();
    for (ExplicitPathInfo info : explicitPathInfo) {
        /*
             * If explicit path object is LOOSE,
             * 1) If specified as DeviceId (node) :
             * If it is source , compute from source to destination (partial computation not required),
             * otherwise compute from specified source to specified device
             * 2) If specified as Link :
             * Compute partial path from source to link's source , if path exists compute from link's source to dst
             */
        if (info.type().equals(ExplicitPathInfo.Type.LOOSE)) {
            if (info.value() instanceof DeviceId) {
                // If deviceId is source no need to compute
                if (!(info.value()).equals(src)) {
                    log.debug("computeExplicitPath :: Loose , device");
                    finalComputedPath = computePartialPath(finalComputedPath, src, (DeviceId) info.value(), constraints);
                    log.debug("finalComputedPath in computeExplicitPath ::" + finalComputedPath);
                }
            } else if (info.value() instanceof Link) {
                if ((((Link) info.value()).src().deviceId().equals(src)) || (!finalComputedPath.isEmpty() && finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(((Link) info.value()).src().deviceId()))) {
                    finalComputedPath = computePartialPath(finalComputedPath, src, ((Link) info.value()).dst().deviceId(), constraints);
                } else {
                    finalComputedPath = computePartialPath(finalComputedPath, src, ((Link) info.value()).src().deviceId(), constraints) != null ? computePartialPath(finalComputedPath, src, ((Link) info.value()).dst().deviceId(), constraints) : null;
                }
            }
        /*
                 * If explicit path object is STRICT,
                 * 1) If specified as DeviceId (node) :
                 * Check whether partial computed path has reachable to strict specified node orde
                 * strict node is the source, if no set path as null else do nothing
                 * 2) If specified as Link :
                 * Check whether partial computed path has reachable to strict link's src, if yes compute
                 * path from strict link's src to link's dst (to include specified link)
                 */
        } else if (info.type().equals(ExplicitPathInfo.Type.STRICT)) {
            if (info.value() instanceof DeviceId) {
                log.debug("computeExplicitPath :: Strict , device");
                if (!(!finalComputedPath.isEmpty() && finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(info.value())) && !info.value().equals(src)) {
                    finalComputedPath = null;
                }
            } else if (info.value() instanceof Link) {
                log.info("computeExplicitPath :: Strict");
                finalComputedPath = ((Link) info.value()).src().deviceId().equals(src) || !finalComputedPath.isEmpty() && finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(((Link) info.value()).src().deviceId()) ? computePartialPath(finalComputedPath, src, ((Link) info.value()).dst().deviceId(), constraints) : null;
                if (finalComputedPath != null && !finalComputedPath.get(finalComputedPath.size() - 1).links().contains((Link) info.value())) {
                    finalComputedPath = null;
                }
            }
        }
        if (finalComputedPath == null) {
            return null;
        }
    }
    // Destination is not reached in Partial computed path then compute till destination
    if (finalComputedPath.isEmpty() || !finalComputedPath.isEmpty() && !finalComputedPath.get(finalComputedPath.size() - 1).dst().deviceId().equals(dst)) {
        finalComputedPath = computePartialPath(finalComputedPath, src, dst, constraints);
        if (finalComputedPath == null) {
            return null;
        }
    }
    return finalComputedPath;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response queryAllPath() {
    log.debug("Query all paths.");
    Iterable<Tunnel> tunnels = get(PceService.class).queryAllPath();
    ObjectNode result = mapper().createObjectNode();
    ArrayNode pathEntry = result.putArray("paths");
    if (tunnels != null) {
        for (final Tunnel tunnel : tunnels) {
            PcePath path = DefaultPcePath.builder().of(tunnel).build();
            pathEntry.add(codec(PcePath.class).encode(path, this));
        }
    }
    return ok(result.toString()).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response queryAllPath() {
    log.debug("Query all paths.");
    PceService pceService = get(PceService.class);
    Iterable<Tunnel> tunnels = pceService.queryAllPath();
    ObjectNode result = mapper().createObjectNode();
    ArrayNode pathEntry = result.putArray("paths");
    if (tunnels != null) {
        for (final Tunnel tunnel : tunnels) {
            PcePath path = DefaultPcePath.builder().of(tunnel, pceService.explicitPathInfoList(tunnel.tunnelName().value())).build();
            pathEntry.add(codec(PcePath.class).encode(path, this));
        }
    }
    return ok(result.toString()).build();
}
#end_block

#method_before
@GET
@Path("{path_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response queryPath(@PathParam("path_id") String id) {
    log.debug("Query path by identifier {}.", id);
    Tunnel tunnel = nullIsNotFound(get(PceService.class).queryPath(TunnelId.valueOf(id)), PCE_PATH_NOT_FOUND);
    PcePath path = DefaultPcePath.builder().of(tunnel).build();
    if (path == null) {
        return Response.status(OK).entity(PCE_SETUP_PATH_FAILED).build();
    }
    ObjectNode result = mapper().createObjectNode();
    result.set("path", codec(PcePath.class).encode(path, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{path_id}")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Response queryPath(@PathParam("path_id") String id) {
    log.debug("Query path by identifier {}.", id);
    PceService pceService = get(PceService.class);
    Tunnel tunnel = nullIsNotFound(pceService.queryPath(TunnelId.valueOf(id)), PCE_PATH_NOT_FOUND);
    PcePath path = DefaultPcePath.builder().of(tunnel, pceService.explicitPathInfoList(tunnel.tunnelName().value())).build();
    if (path == null) {
        return Response.status(OK).entity(PCE_SETUP_PATH_FAILED).build();
    }
    ObjectNode result = mapper().createObjectNode();
    result.set("path", codec(PcePath.class).encode(path, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@Before
public void setUpTest() {
    // Mock environment setup
    MockPceCodecContext context = new MockPceCodecContext();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(PceService.class, pceService).add(TunnelService.class, tunnelService).add(PceStore.class, pceStore).add(CodecService.class, context.codecManager());
    BaseResource.setServiceDirectory(testDirectory);
    // Tunnel creation
    // Links
    ProviderId providerId = new ProviderId("of", "foo");
    deviceId1 = DeviceId.deviceId("of:A");
    deviceId2 = DeviceId.deviceId("of:B");
    deviceId3 = DeviceId.deviceId("of:C");
    deviceId4 = DeviceId.deviceId("of:D");
    deviceId5 = DeviceId.deviceId("of:E");
    port1 = PortNumber.portNumber(1);
    port2 = PortNumber.portNumber(2);
    port3 = PortNumber.portNumber(3);
    port4 = PortNumber.portNumber(4);
    port5 = PortNumber.portNumber(5);
    List<Link> linkList = new LinkedList<>();
    Link l1 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key1", "yahoo").build()).src(new ConnectPoint(deviceId1, port1)).dst(new ConnectPoint(deviceId2, port2)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l1);
    Link l2 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key2", "yahoo").build()).src(new ConnectPoint(deviceId2, port2)).dst(new ConnectPoint(deviceId3, port3)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l2);
    Link l3 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key3", "yahoo").build()).src(new ConnectPoint(deviceId3, port3)).dst(new ConnectPoint(deviceId4, port4)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l3);
    Link l4 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key4", "yahoo").build()).src(new ConnectPoint(deviceId4, port4)).dst(new ConnectPoint(deviceId5, port5)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l4);
    // Path
    path = new DefaultPath(providerId, linkList, 10);
    // Annotations
    DefaultAnnotations.Builder builderAnn = DefaultAnnotations.builder();
    builderAnn.set(PcepAnnotationKeys.LSP_SIG_TYPE, "WITH_SIGNALLING");
    builderAnn.set(PcepAnnotationKeys.COST_TYPE, "COST");
    builderAnn.set(PcepAnnotationKeys.BANDWIDTH, "200");
    // Tunnel
    tunnel = new DefaultTunnel(producerName, src, dst, Tunnel.Type.VXLAN, Tunnel.State.ACTIVE, groupId, tunnelId, tunnelName, path, builderAnn.build());
}
#method_after
@Before
public void setUpTest() {
    // Mock environment setup
    MockPceCodecContext context = new MockPceCodecContext();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(PceService.class, pceService).add(TunnelService.class, tunnelService).add(PceStore.class, pceStore).add(CodecService.class, context.codecManager());
    BaseResource.setServiceDirectory(testDirectory);
    // Tunnel creation
    // Links
    ProviderId providerId = new ProviderId("of", "foo");
    deviceId1 = DeviceId.deviceId("of:A");
    deviceId2 = DeviceId.deviceId("of:B");
    deviceId3 = DeviceId.deviceId("of:C");
    deviceId4 = DeviceId.deviceId("of:D");
    deviceId5 = DeviceId.deviceId("of:E");
    port1 = PortNumber.portNumber(1);
    port2 = PortNumber.portNumber(2);
    port3 = PortNumber.portNumber(3);
    port4 = PortNumber.portNumber(4);
    port5 = PortNumber.portNumber(5);
    List<Link> linkList = new LinkedList<>();
    Link l1 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key1", "yahoo").build()).src(new ConnectPoint(deviceId1, port1)).dst(new ConnectPoint(deviceId2, port2)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l1);
    Link l2 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key2", "yahoo").build()).src(new ConnectPoint(deviceId2, port2)).dst(new ConnectPoint(deviceId3, port3)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l2);
    Link l3 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key3", "yahoo").build()).src(new ConnectPoint(deviceId3, port3)).dst(new ConnectPoint(deviceId4, port4)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l3);
    Link l4 = DefaultLink.builder().providerId(providerId).annotations(DefaultAnnotations.builder().set("key4", "yahoo").build()).src(new ConnectPoint(deviceId4, port4)).dst(new ConnectPoint(deviceId5, port5)).type(DIRECT).state(Link.State.ACTIVE).build();
    linkList.add(l4);
    // Path
    path = new DefaultPath(providerId, linkList, 10);
    // Annotations
    DefaultAnnotations.Builder builderAnn = DefaultAnnotations.builder();
    builderAnn.set(PcepAnnotationKeys.LSP_SIG_TYPE, "WITH_SIGNALLING");
    builderAnn.set(PcepAnnotationKeys.COST_TYPE, "COST");
    builderAnn.set(PcepAnnotationKeys.BANDWIDTH, "200");
    // Tunnel
    tunnel = new DefaultTunnel(producerName, src, dst, Tunnel.Type.VXLAN, Tunnel.State.ACTIVE, groupId, tunnelId, tunnelName, path, builderAnn.build());
    explicitPathInfoList = Lists.newLinkedList();
    ExplicitPathInfo obj = new ExplicitPathInfo(ExplicitPathInfo.Type.LOOSE, deviceId2);
    explicitPathInfoList.add(obj);
}
#end_block

#method_before
@Test
public void testGetTunnelId() {
    expect(pceService.queryPath(anyObject())).andReturn(tunnel).anyTimes();
    replay(pceService);
    WebTarget wt = target();
    String response = wt.path("path/1").request().get(String.class);
    JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
}
#method_after
@Test
public void testGetTunnelId() {
    expect(pceService.queryPath(anyObject())).andReturn(tunnel).anyTimes();
    expect(pceService.explicitPathInfoList(tunnel.tunnelName().value())).andReturn(explicitPathInfoList).anyTimes();
    replay(pceService);
    WebTarget wt = target();
    String response = wt.path("path/1").request().get(String.class);
    JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
}
#end_block

#method_before
public Boolean colorAware() {
    return colorAware;
}
#method_after
public boolean colorAware() {
    return colorAware;
}
#end_block

#method_before
public static BandwidthProfile fromMeter(Meter meter) {
    checkNotNull(meter);
    checkArgument(meter.bands().size() <= 2, "Meter must have no more than two bands.");
    Iterator<Band> bandIterator = meter.bands().iterator();
    Band bandOne = bandIterator.next();
    Band bandTwo = bandIterator.hasNext() ? bandIterator.next() : null;
    // Assign values to yellowBand and redBand depending on the number of bands in the meter
    // If only one band exists it will be designated as the redBand
    // If two bands exist, the one with the lower rate will be the yellowBand and the other the redBand
    Band yellowBand = (bandTwo == null ? null : bandTwo.rate() > bandOne.rate() ? bandOne : bandTwo);
    Band redBand = (bandTwo == null ? bandOne : yellowBand == bandOne ? bandTwo : bandOne);
    BandwidthProfile.Builder bandwidthProfileBuilder = new Builder().name(meter.id().toString()).colorAware(false).greenAction(new BandwidthProfileAction.Builder().action(BandwidthProfileAction.Action.PASS).build());
    if (yellowBand != null) {
        // Try to add yellow action; CIR/CBS will be obtained from yellowBand and PIR/PBS from redBand
        BandwidthProfileAction yellowAction = getBandwidthProfileActionFromBand(yellowBand);
        checkNotNull(yellowAction, "Could not obtain yellow action from meter band");
        bandwidthProfileBuilder.cir(kBytesPerSecondToBandwidth(yellowBand.rate())).cbs(yellowBand.burst() == null ? null : yellowBand.burst().intValue()).pir(kBytesPerSecondToBandwidth(redBand.rate())).pbs(redBand.burst() == null ? null : redBand.burst().intValue()).yellowAction(yellowAction);
    } else {
        // No yellow action to add; CIR/CBS will be obtained from redBand
        bandwidthProfileBuilder.cir(kBytesPerSecondToBandwidth(redBand.rate())).cbs(redBand.burst() == null ? null : redBand.burst().intValue());
    }
    // Try to add red action in any case
    BandwidthProfileAction redAction = getBandwidthProfileActionFromBand(redBand);
    checkNotNull(redAction, "Could not obtain red action from meter band");
    return bandwidthProfileBuilder.redAction(redAction).build();
}
#method_after
public static BandwidthProfile fromMeter(Meter meter) {
    checkNotNull(meter);
    checkArgument(meter.bands().size() <= 2, "Meter must have no more than two bands.");
    Iterator<Band> bandIterator = meter.bands().iterator();
    Band bandOne = bandIterator.next();
    Band bandTwo = bandIterator.hasNext() ? bandIterator.next() : null;
    // Assign values to yellowBand and redBand depending on
    // the number of bands in the meter.
    // If only one band exists it will be designated as the redBand.
    // If two bands exist, the one with the lower rate will be
    // the yellowBand and the other the redBand.
    Band yellowBand = (bandTwo == null ? null : bandTwo.rate() > bandOne.rate() ? bandOne : bandTwo);
    Band redBand = (bandTwo == null ? bandOne : yellowBand == bandOne ? bandTwo : bandOne);
    BandwidthProfile.Builder bandwidthProfileBuilder = new Builder().name(meter.id().toString()).colorAware(false).greenAction(getBuilder(Action.PASS).build());
    if (yellowBand != null) {
        // Try to add yellow action; CIR/CBS will be obtained from
        // yellowBand and PIR/PBS from redBand.
        BandwidthProfileAction yellowAction = getBwProfileActionFromBand(yellowBand);
        checkNotNull(yellowAction, "Could not obtain yellow action from meter band");
        bandwidthProfileBuilder.cir(Bandwidth.kBps(yellowBand.rate())).cbs(yellowBand.burst() == null ? null : yellowBand.burst().intValue()).pir(Bandwidth.kBps(redBand.rate())).pbs(redBand.burst() == null ? null : redBand.burst().intValue()).yellowAction(yellowAction);
    } else {
        // No yellow action to add; CIR/CBS will be obtained from redBand
        bandwidthProfileBuilder.cir(Bandwidth.kBps(redBand.rate())).cbs(redBand.burst() == null ? null : redBand.burst().intValue());
    }
    // Try to add red action in any case
    BandwidthProfileAction redAction = getBwProfileActionFromBand(redBand);
    checkNotNull(redAction, "Could not obtain red action from meter band");
    return bandwidthProfileBuilder.redAction(redAction).build();
}
#end_block

#method_before
public Builder colorAware(Boolean colorAware) {
    this.colorAware = colorAware;
    return this;
}
#method_after
public Builder colorAware(boolean colorAware) {
    this.colorAware = colorAware;
    return this;
}
#end_block

#method_before
public BandwidthProfile build() {
    checkNotNull(name, "Bandwidth profile must have a name");
    checkNotNull(cir, "Bandwidth profile must have a CIR");
    checkNotNull(greenAction, "Bandwidth profile must have a green action");
    checkNotNull(redAction, "Bandwidth profile must have a red action");
    checkArgument(pir != null || pbs == null, "Bandwidth profile cannot have PBS without PIR");
    checkArgument(pir == null || ebs == null, "Bandwidth profile cannot have both PIR and EBS");
    checkArgument(yellowAction == null && pir == null && ebs == null || yellowAction != null && (pir != null ^ ebs != null), "Bandwidth profile must have a yellow action only when either PIR or EBS are defined");
    return new BandwidthProfile(name, cir, pir, cbs, pbs, ebs, greenAction, yellowAction, redAction, colorAware);
}
#method_after
public BandwidthProfile build() {
    checkNotNull(name, "Bandwidth profile must have a name");
    checkNotNull(cir, "Bandwidth profile must have a CIR");
    checkNotNull(greenAction, "Bandwidth profile must have a green action");
    checkNotNull(redAction, "Bandwidth profile must have a red action");
    checkArgument(pir != null || pbs == null, "Bandwidth profile cannot have PBS without PIR");
    checkArgument(pir == null || ebs == null, "Bandwidth profile cannot have both PIR and EBS");
    checkArgument(yellowAction == null && pir == null && ebs == null || yellowAction != null && (pir != null ^ ebs != null), "Bandwidth profile must have a yellow action only " + "when either PIR or EBS are defined");
    return new BandwidthProfile(name, cir, pir, cbs, pbs, ebs, greenAction, yellowAction, redAction, colorAware);
}
#end_block

#method_before
@Override
public String encodeYdtToProtocolFormat(YdtBuilder builder, YmsOperationType protocolOperation) {
    ObjectNode jsonNode = convertYdtToJson(builder.getRootNode().getName(), builder.getRootNode(), ymsService.getYdtWalker());
    return jsonToString(jsonNode);
}
#method_after
@Override
public String encodeYdtToProtocolFormat(YdtBuilder builder) {
    ObjectNode jsonNode = convertYdtToJson(builder.getRootNode().getName(), builder.getRootNode(), ymsService.getYdtWalker());
    return jsonToString(jsonNode);
}
#end_block

#method_before
@Override
public YangCompositeEncoding encodeYdtToCompositeProtocolFormat(YdtBuilder builder, YmsOperationType protocolOperation) {
    YdtContext rootNode = builder.getRootNode();
    String rootName = rootNode.getName();
    YdtContext child = rootNode.getFirstChild();
    String name = child.getName();
    String url = rootName + SLASH + DATA + SLASH + name;
    ObjectNode objectNode = convertYdtToJson(name, child, ymsService.getYdtWalker());
    String payload = jsonToString((ObjectNode) objectNode.get(name));
    return new YangCompositeEncodingImpl(URI, url, payload);
}
#method_after
@Override
public YangCompositeEncoding encodeYdtToCompositeProtocolFormat(YdtBuilder builder) {
    YdtContext rootNode = builder.getRootNode();
    String rootName = rootNode.getName();
    YdtContext child = rootNode.getFirstChild();
    String name = child.getName();
    String url = rootName + SLASH + DATA + SLASH + name;
    ObjectNode objectNode = convertYdtToJson(name, child, ymsService.getYdtWalker());
    String payload = jsonToString((ObjectNode) objectNode.get(name));
    return new YangCompositeEncodingImpl(URI, url, payload);
}
#end_block

#method_before
@Override
public YdtBuilder decodeProtocolDataToYdt(String protocolData, Object schemaRegistryForYdt, YmsOperationType opType) {
    // Get a new builder
    YdtBuilder builder = ymsService.getYdtBuilder(RESTCONF_ROOT, null, opType, schemaRegistryForYdt);
    convertJsonToYdt(toJson(protocolData), builder);
    return builder;
}
#method_after
@Override
public YdtBuilder decodeProtocolDataToYdt(String protocolData, Object schemaRegistry, YmsOperationType opType) {
    // Get a new builder
    YdtBuilder builder = ymsService.getYdtBuilder(RESTCONF_ROOT, null, opType, schemaRegistry);
    convertJsonToYdt(toJson(protocolData), builder);
    return builder;
}
#end_block

#method_before
@Override
public YdtBuilder decodeCompositeProtocolDataToYdt(YangCompositeEncoding protocolData, Object schemaRegistryForYdt, YmsOperationType opType) {
    // opType should be QUERY_REPLY
    // Get a new builder
    YdtBuilder builder = ymsService.getYdtBuilder(RESTCONF_ROOT, null, opType, schemaRegistryForYdt);
    // Convert the URI to ydtBuilder
    // YdtContextOperationType should be NONE for URI in QUERY_RESPONSE.
    convertUriToYdt(protocolData.getResourceIdentifier(), builder, NONE);
    // Set default operation type for the payload node, is this for resource data?
    // NULL/EMPTY for Resource data
    builder.setDefaultEditOperationType(null);
    // Convert the payload json body to ydt
    convertJsonToYdt(toJson(protocolData.getResourceInformation()), builder);
    return builder;
}
#method_after
@Override
public YdtBuilder decodeCompositeProtocolDataToYdt(YangCompositeEncoding protocolData, Object schemaRegistry, YmsOperationType opType) {
    YdtBuilder builder = ymsService.getYdtBuilder(RESTCONF_ROOT, null, opType, schemaRegistry);
    // YdtContextOperationType should be NONE for URI in QUERY_RESPONSE.
    convertUriToYdt(protocolData.getResourceIdentifier(), builder, NONE);
    // NULL/EMPTY for Resource data
    builder.setDefaultEditOperationType(null);
    // Convert the payload json body to ydt
    convertJsonToYdt(toJson(protocolData.getResourceInformation()), builder);
    return builder;
}
#end_block

#method_before
@Override
public String getResourceIdentifier() {
    return resourceIdentifier;
}
#method_after
public String getResourceIdentifier() {
    return resourceIdentifier;
}
#end_block

#method_before
@Override
public YangResourceIdentifierType getResourceIdentifierType() {
    return resourceIdentifierType;
}
#method_after
public YangResourceIdentifierType getResourceIdentifierType() {
    return resourceIdentifierType;
}
#end_block

#method_before
@Override
public String getResourceInformation() {
    return resourceInformation;
}
#method_after
public String getResourceInformation() {
    return resourceInformation;
}
#end_block

#method_before
@Activate
public void activate() {
    codecHandler = ymsService.getYangCodecHandler();
    codecHandler.addDeviceSchema(IetfTe.class);
    collectInitialTunnels();
    subscribe();
    log.info("started");
}
#method_after
@Activate
public void activate() {
    tunnelProviderRegistry.register(this);
    codecHandler = ymsService.getYangCodecHandler();
    codecHandler.addDeviceSchema(IetfTe.class);
    collectInitialTunnels();
    subscribe();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    unsubscribe();
    log.info("stopped");
}
#method_after
@Deactivate
public void deactivate() {
    tunnelProviderRegistry.unregister(this);
    unsubscribe();
    log.info("Stopped");
}
#end_block

#method_before
private void collectInitialTunnels() {
    for (DeviceId deviceId : controller.getDevices().keySet()) {
        ObjectNode jsonNodes = executeGetRequest(deviceId);
        if (jsonNodes == null) {
            continue;
        }
        ObjectNode tunnelsNode = (ObjectNode) jsonNodes.get(TUNNELS);
        if (tunnelsNode == null) {
            continue;
        }
        Tunnels teTunnels = getYangTunnelsObject(tunnelsNode);
        updateTeTunnels(teTunnels);
    }
}
#method_after
private void collectInitialTunnels() {
    for (DeviceId deviceId : controller.getDevices().keySet()) {
        ObjectNode jsonNodes = executeGetRequest(deviceId);
        if (jsonNodes == null) {
            continue;
        }
        ObjectNode tunnelsNode = (ObjectNode) jsonNodes.get(TUNNELS);
        if (tunnelsNode == null) {
            continue;
        }
        Tunnels teTunnels = getYangTunnelsObject(tunnelsNode);
        if (teTunnels == null) {
            continue;
        }
        updateTeTunnels(teTunnels);
    }
}
#end_block

#method_before
private void subscribe() {
    for (DeviceId deviceId : controller.getDevices().keySet()) {
        try {
            controller.enableNotifications(deviceId, TUNNELS_URL, MEDIA_TYPE_JSON, listener);
        } catch (Exception e) {
            log.error("Failed to subscribe for {} : {}", deviceId.toString(), e.getMessage());
        }
    }
}
#method_after
private void subscribe() {
    for (DeviceId deviceId : controller.getDevices().keySet()) {
        try {
            controller.enableNotifications(deviceId, TUNNELS_URL, MEDIA_TYPE_JSON, listener);
        } catch (Exception e) {
            log.error("Failed to subscribe for {} : {}", deviceId, e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    TeTunnel teTunnel = tunnelService.getTeTunnel(tunnel.tunnelId());
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.rev20160705.ietfte.tunnelsgrouping.tunnels.Tunnel yangTunnel = te2YangTunnelConverter(teTunnel);
    IetfTe ietfTe = buildIetfTeWithTunnels(Lists.newArrayList(yangTunnel));
    YangCompositeEncoding encoding = codecHandler.encodeCompositeOperation(RESTCONF_ROOT, null, ietfTe, JSON_ENCODING, EDIT_CONFIG_REQUEST);
    String identifier = encoding.getResourceIdentifier();
    String resourceInformation = encoding.getResourceInformation();
    // TODO provide the device Id
    controller.post(null, identifier, new ByteArrayInputStream(resourceInformation.getBytes()), MediaType.APPLICATION_JSON, ObjectNode.class);
}
#method_after
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    TeTunnel teTunnel = tunnelService.getTeTunnel(tunnel.tunnelId());
    long tid = teTunnel.srcNode().topologyId();
    checkState(tid == teTunnel.dstNode().topologyId(), SHOULD_IN_ONE);
    setupTunnel(getOwnDevice(tid), tunnel, path);
}
#end_block

#method_before
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
}
#method_after
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    TeTunnel teTunnel = tunnelService.getTeTunnel(tunnel.tunnelId());
    IetfTe ietfTe = buildIetfTe(teTunnel);
    YangCompositeEncoding encoding = codecHandler.encodeCompositeOperation(RESTCONF_ROOT, null, ietfTe, JSON, EDIT_CONFIG_REQUEST);
    String identifier = encoding.getResourceIdentifier();
    String resourceInformation = encoding.getResourceInformation();
    if (srcElement == null) {
        log.error("Can't find remote device for tunnel : {}", tunnel);
        return;
    }
    log.info("Create tunnel get here");
    controller.post((DeviceId) srcElement, identifier, new ByteArrayInputStream(resourceInformation.getBytes()), MediaType.APPLICATION_JSON, ObjectNode.class);
}
#end_block

#method_before
@Override
public void releaseTunnel(Tunnel tunnel) {
}
#method_after
@Override
public void releaseTunnel(Tunnel tunnel) {
// TODO implement release tunnel method
}
#end_block

#method_before
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
}
#method_after
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
// TODO implement release tunnel with src method
}
#end_block

#method_before
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
}
#method_after
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
// TODO implement update tunnel method
}
#end_block

#method_before
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
}
#method_after
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
// TODO implement update tunnel with src method
}
#end_block

#method_before
@Override
public TunnelId tunnelAdded(TunnelDescription tunnel) {
    return null;
}
#method_after
@Override
public TunnelId tunnelAdded(TunnelDescription tunnel) {
    // TODO implement tunnel add method when te tunnel app merged to core
    return null;
}
#end_block

#method_before
@Override
public void tunnelRemoved(TunnelDescription tunnel) {
}
#method_after
@Override
public void tunnelRemoved(TunnelDescription tunnel) {
// TODO implement tunnel remove method when te tunnel app merged to core
}
#end_block

#method_before
@Override
public void tunnelUpdated(TunnelDescription tunnel) {
}
#method_after
@Override
public void tunnelUpdated(TunnelDescription tunnel) {
// TODO implement tunnel update method when te tunnel app merged to core
}
#end_block

#method_before
private Tunnels getYangTunnelsObject(ObjectNode tunnelsNode) {
    checkNotNull(tunnelsNode, "Input object node should not be null");
    YangCompositeEncoding yce = new YangCompositeEncodingImpl(URI, TUNNELS_URL, jsonToString(tunnelsNode));
    Object yo = codecHandler.decode(yce, JSON_ENCODING, QUERY_REPLY);
    if ((yo == null)) {
        log.error("YMS decoder returns null");
    }
    IetfTe ietfTe = null;
    Tunnels tunnels = null;
    if (yo instanceof List) {
        List<Object> list = (List<Object>) yo;
        ietfTe = (IetfTe) list.get(DEFAULT_INDEX);
    }
    if (ietfTe != null && ietfTe.te() != null) {
        tunnels = ietfTe.te().tunnels();
    }
    return tunnels;
}
#method_after
private Tunnels getYangTunnelsObject(ObjectNode tunnelsNode) {
    checkNotNull(tunnelsNode, "Input object node should not be null");
    YangCompositeEncoding yce = new YangCompositeEncodingImpl(URI, TUNNELS_URL, jsonToString(tunnelsNode));
    Object yo = codecHandler.decode(yce, JSON, QUERY_REPLY);
    if (yo == null) {
        log.error("YMS decoder returns null");
        return null;
    }
    IetfTe ietfTe = null;
    Tunnels tunnels = null;
    if (yo instanceof List) {
        List<Object> list = (List<Object>) yo;
        ietfTe = (IetfTe) list.get(DEFAULT_INDEX);
    }
    if (ietfTe != null && ietfTe.te() != null) {
        tunnels = ietfTe.te().tunnels();
    }
    return tunnels;
}
#end_block

#method_before
private void updateTeTunnels(Tunnels tunnels) {
    TeTopologyKey topologyId = getTopologyId();
    tunnels.tunnel().stream().map(tunnel -> yang2TeTunnel(tunnel, topologyId)).peek(teTunnel -> providerService.updateTeTunnel(teTunnel));
}
#method_after
private void updateTeTunnels(Tunnels tunnels) {
    TeTopologyKey key = getTopologyKey();
    tunnels.tunnel().forEach(tunnel -> {
        DefaultTeTunnel teTunnel = yang2TeTunnel(tunnel, key);
        providerService.updateTeTunnel(teTunnel);
    });
}
#end_block

#method_before
@Override
public <T> void handleNotificationEvent(DeviceId deviceId, T eventJsonString) {
    ObjectNode response = toJson((String) eventJsonString);
    if (response == null) {
        return;
    }
    JsonNode teNode = response.get(TE);
    if (teNode == null) {
        log.info("Illegal te json object from {}", deviceId.toString());
        return;
    }
    JsonNode tunnelsNode = teNode.get(TUNNELS);
    if (tunnelsNode == null) {
        log.info("Illegal tunnel json object from {}", deviceId.toString());
        return;
    }
    Tunnels tunnels = getYangTunnelsObject((ObjectNode) tunnelsNode);
    updateTeTunnels(tunnels);
}
#method_after
@Override
public void handleNotificationEvent(DeviceId deviceId, Object eventJsonString) {
    ObjectNode response = toJson((String) eventJsonString);
    if (response == null) {
        return;
    }
    JsonNode teNode = response.get(TE);
    if (teNode == null) {
        log.error("Illegal te json object from {}", deviceId);
        return;
    }
    JsonNode tunnelsNode = teNode.get(TUNNELS);
    if (tunnelsNode == null) {
        log.error("Illegal tunnel json object from {}", deviceId);
        return;
    }
    Tunnels tunnels = getYangTunnelsObject((ObjectNode) tunnelsNode);
    if (tunnels == null) {
        return;
    }
    updateTeTunnels(tunnels);
}
#end_block

#method_before
public static String jsonToString(ObjectNode node) {
    ObjectWriter ow = new ObjectMapper().writer().withDefaultPrettyPrinter();
    String jsonString = null;
    try {
        jsonString = ow.writeValueAsString(node);
    } catch (JsonProcessingException e) {
        e.printStackTrace();
    }
    return jsonString;
}
#method_after
public static String jsonToString(ObjectNode node) {
    ObjectWriter ow = new ObjectMapper().writer().withDefaultPrettyPrinter();
    String jsonString = null;
    try {
        jsonString = ow.writeValueAsString(node);
    } catch (JsonProcessingException e) {
        log.error("Parse json to string failed {}", e.getMessage());
    }
    return jsonString;
}
#end_block

#method_before
@Activate
public void activate() {
    // Get the codec handler.
    codecHandler = ymsService.getYangCodecHandler();
    // Register all three IETF Topology YANG model schema with YMS.
    codecHandler.addDeviceSchema(IetfNetwork.class);
    codecHandler.addDeviceSchema(IetfNetworkTopology.class);
    codecHandler.addDeviceSchema(IetfTeTopology.class);
    // Register JSON CODEC functions
    codecHandler.registerOverriddenCodec(new DefaultJsonCodec(ymsService), YangProtocolEncodingFormat.JSON_ENCODING);
    appId = coreService.registerApplication(APP_NAME);
    topologyProviderService = topologyProviderRegistry.register(this);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgLister);
    executor.execute(TeTopologyRestconfProvider.this::connectDevices);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    // Get the codec handler.
    codecHandler = ymsService.getYangCodecHandler();
    // Register all three IETF Topology YANG model schema with YMS.
    codecHandler.addDeviceSchema(IetfNetwork.class);
    codecHandler.addDeviceSchema(IetfNetworkTopology.class);
    codecHandler.addDeviceSchema(IetfTeTopology.class);
    // Register JSON CODEC functions
    codecHandler.registerOverriddenCodec(new DefaultJsonCodec(ymsService), YangProtocolEncodingFormat.JSON);
    appId = coreService.registerApplication(APP_NAME);
    topologyProviderService = topologyProviderRegistry.register(this);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgLister);
    executor.execute(TeTopologyRestconfProvider.this::connectDevices);
    log.info("Started");
}
#end_block

#method_before
private void retrieveTopology(DeviceId deviceId) {
    // Retrieve IETF Network at top level.
    InputStream jsonStream = restconfClient.get(deviceId, IETF_NETWORK_URI, JSON);
    if (jsonStream == null) {
        log.warn("Unable to retrieve network Topology from restconf server {}", deviceId);
        return;
    }
    // Need to convert Input stream to String.
    StringWriter writer = new StringWriter();
    try {
        IOUtils.copy(jsonStream, writer, StandardCharsets.UTF_8);
    } catch (IOException e) {
        log.warn("There is an exception {} for copy jsonStream to stringWriter for restconf {}", e.getMessage(), deviceId);
        return;
    }
    String jsonString = writer.toString();
    String networkLevelJsonString = getNetworkLevelJsonResponse(jsonString);
    YangCompositeEncodingImpl yce = new YangCompositeEncodingImpl(YangResourceIdentifierType.URI, IETF_NETWORK_URI, networkLevelJsonString);
    Object yo = codecHandler.decode(yce, YangProtocolEncodingFormat.JSON_ENCODING, YmsOperationType.QUERY_REPLY);
    if ((yo == null)) {
        log.error("YMS decoder returns {} for restconf {}", yo, deviceId);
        return;
    }
    // YMS returns an ArrayList in a single Object (i.e. yo in this case)
    // this means yo is actually an ArrayList of size 1
    IetfNetwork ietfNetwork = ((List<IetfNetwork>) yo).get(0);
    if (ietfNetwork.networks() != null && ietfNetwork.networks().network() != null) {
        // Convert the YO to TE Core data and update TE Core.
        for (Network nw : ietfNetwork.networks().network()) {
            topologyProviderService.networkUpdated(NetworkConverter.yang2TeSubsystemNetwork(nw));
        }
    }
// TODO: Uncomment when YMS fixes the issue in NetworkState translation (network-ref)
// org.onosproject.tetopology.management.utils.Networks networks =
// NetworkConverter.yang2TeSubsystemNetworks(ietfNetwork.networks(),
// ietfNetwork.networksState());
// if (networks == null || networks.networks() == null) {
// log.error("Yang2Te returns null for restconf {}", deviceId);
// return;
// }
// for (org.onosproject.tetopology.management.utils.Network network : networks.networks()) {
// topologyProviderService.networkUpdated(network);
// }
// TODO: Uncomment when the RESTCONF server and the RESTCONF client
// both fully support notifications in Ibis Release
// RestConfNotificationEventListener callBackListener = new RestConfNotificationEventListenerImpl();
// restconfClient.enableNotifications(deviceId, IETF_NOTIFICATION_URI, JSON, callBackListener);
}
#method_after
private void retrieveTopology(DeviceId deviceId) {
    // Retrieve IETF Network at top level.
    InputStream jsonStream = restconfClient.get(deviceId, IETF_NETWORK_URI, JSON);
    if (jsonStream == null) {
        log.warn("Unable to retrieve network Topology from restconf " + "server {}", deviceId);
        return;
    }
    // Need to convert Input stream to String.
    StringWriter writer = new StringWriter();
    try {
        IOUtils.copy(jsonStream, writer, StandardCharsets.UTF_8);
    } catch (IOException e) {
        log.warn("There is an exception {} for copy jsonStream to " + "stringWriter for restconf {}", e.getMessage(), deviceId);
        return;
    }
    String jsonString = writer.toString();
    String networkLevelJsonString = removePrefixTagFromJson(jsonString, IETF_NETWORKS_PREFIX);
    YangCompositeEncodingImpl yce = new YangCompositeEncodingImpl(YangResourceIdentifierType.URI, IETF_NETWORK_URI, networkLevelJsonString);
    Object yo = codecHandler.decode(yce, YangProtocolEncodingFormat.JSON, YmsOperationType.QUERY_REPLY);
    if ((yo == null)) {
        log.error("YMS decoder returns {} for restconf {}", yo, deviceId);
        return;
    }
    // YMS returns an ArrayList in a single Object (i.e. yo in this case)
    // this means yo is actually an ArrayList of size 1
    IetfNetwork ietfNetwork = ((List<IetfNetwork>) yo).get(0);
    if (ietfNetwork.networks() != null && ietfNetwork.networks().network() != null) {
        // Convert the YO to TE Core data and update TE Core.
        for (Network nw : ietfNetwork.networks().network()) {
            topologyProviderService.networkUpdated(NetworkConverter.yang2TeSubsystemNetwork(nw, ietfNetwork.networks()));
        }
    }
    // TODO: Uncomment when YMS fixes the issue in NetworkState translation (network-ref)
    // org.onosproject.tetopology.management.api.Networks networks =
    // NetworkConverter.yang2TeSubsystemNetworks(ietfNetwork.networks(),
    // ietfNetwork.networksState());
    // if (networks == null || networks.networks() == null) {
    // log.error("Yang2Te returns null for restconf {}", deviceId);
    // return;
    // }
    // for (org.onosproject.tetopology.management.api.Network network : networks.networks()) {
    // topologyProviderService.networkUpdated(network);
    // }
    RestConfNotificationEventListener<String> callBackListener = new InternalRestconfNotificationEventListener();
    restconfClient.enableNotifications(deviceId, IETF_NOTIFICATION_URI, "application/json", callBackListener);
}
#end_block

#method_before
private void connectDevices() {
    RestProviderConfig cfg = cfgService.getConfig(appId, RestProviderConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            // Precomputing the devices to be removed
            Set<RestSBDevice> toBeRemoved = new HashSet<>(controller.getDevices().values());
            toBeRemoved.removeAll(cfg.getDevicesAddresses());
            // Adding new devices
            cfg.getDevicesAddresses().stream().filter(device -> {
                device.setActive(false);
                controller.addDevice(device);
                return testDeviceConnection(device);
            }).forEach(device -> {
                deviceAdded(device);
            });
            // Removing devices not wanted anymore
            toBeRemoved.forEach(device -> deviceRemoved(device.deviceId()));
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    log.debug("REST Devices {}", controller.getDevices());
    addedDevices.forEach(this::discoverPorts);
    addedDevices.clear();
}
#method_after
private void connectDevices() {
    RestProviderConfig cfg = cfgService.getConfig(appId, RestProviderConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            // Precomputing the devices to be removed
            Set<RestSBDevice> toBeRemoved = new HashSet<>(controller.getDevices().values());
            toBeRemoved.removeAll(cfg.getDevicesAddresses());
            // Adding new devices
            cfg.getDevicesAddresses().stream().filter(device -> {
                device.setActive(false);
                controller.addDevice(device);
                return testDeviceConnection(device);
            }).forEach(device -> {
                deviceAdded(device);
            });
            // Removing devices not wanted anymore
            toBeRemoved.forEach(device -> deviceRemoved(device.deviceId()));
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    log.debug("REST Devices {}", controller.getDevices());
    addedDevices.clear();
}
#end_block

#method_before
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else if (device.is(DeviceDescriptionDiscovery.class)) {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
    } else {
        log.warn("No portGetter behaviour for device {}", deviceId);
    }
}
#method_after
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
    }
}
#end_block

#method_before
private Set<ArrayList<DeviceId>> computeRouteChange() {
    Set<ArrayList<DeviceId>> routes = new HashSet<>();
    for (Device sw : srManager.deviceService.getDevices()) {
        DeviceId rootSw = sw.id();
        log.debug("Computing the impacted routes for device {}", rootSw);
        if (!srManager.mastershipService.isLocalMaster(rootSw)) {
            log.debug("No mastership for {} ... skipping route optimization", rootSw);
            continue;
        }
        if (log.isTraceEnabled()) {
            log.trace("link of {} - ", rootSw);
            for (Link link : srManager.linkService.getDeviceLinks(rootSw)) {
                log.trace("{} -> {} ", link.src().deviceId(), link.dst().deviceId());
            }
        }
        EcmpShortestPathGraph currEcmpSpg = currentEcmpSpgMap.get(rootSw);
        if (currEcmpSpg == null) {
            log.debug("No existing ECMP graph for device {}", rootSw);
            ArrayList<DeviceId> route = new ArrayList<>();
            route.add(rootSw);
            routes.add(route);
            continue;
        }
        EcmpShortestPathGraph newEcmpSpg = updatedEcmpSpgMap.get(rootSw);
        // currentEcmpSpgMap.put(rootSw, newEcmpSpg);
        HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchViaCurrent = currEcmpSpg.getAllLearnedSwitchesAndVia();
        HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchViaUpdated = newEcmpSpg.getAllLearnedSwitchesAndVia();
        if (log.isTraceEnabled()) {
            log.trace("Root switch: {}", rootSw);
            log.trace("  Current/Existing SPG: {}", currEcmpSpg);
            log.trace("       New/Updated SPG: {}", newEcmpSpg);
        }
        // may have come up
        for (Integer itrIdx : switchViaUpdated.keySet()) {
            HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMapUpdated = switchViaUpdated.get(itrIdx);
            for (DeviceId targetSw : swViaMapUpdated.keySet()) {
                ArrayList<ArrayList<DeviceId>> viaUpdated = swViaMapUpdated.get(targetSw);
                ArrayList<ArrayList<DeviceId>> via = getVia(switchViaCurrent, targetSw);
                if ((via == null) || !viaUpdated.equals(via)) {
                    log.debug("Impacted route:{} -> {}", targetSw, rootSw);
                    ArrayList<DeviceId> route = new ArrayList<>();
                    route.add(targetSw);
                    route.add(rootSw);
                    routes.add(route);
                }
            }
        }
        // may have been removed
        for (Integer itrIdx : switchViaCurrent.keySet()) {
            HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchViaCurrent.get(itrIdx);
            for (DeviceId targetSw : swViaMap.keySet()) {
                ArrayList<ArrayList<DeviceId>> via = swViaMap.get(targetSw);
                ArrayList<ArrayList<DeviceId>> viaUpdated = getVia(switchViaUpdated, targetSw);
                if ((viaUpdated == null) || !via.equals(viaUpdated)) {
                    log.debug("Impacted route:{} -> {}", targetSw, rootSw);
                    ArrayList<DeviceId> route = new ArrayList<>();
                    route.add(targetSw);
                    route.add(rootSw);
                    routes.add(route);
                }
            }
        }
    }
    for (ArrayList<DeviceId> route : routes) {
        log.debug("Route changes Target -> Root");
        if (route.size() == 1) {
            log.debug(" : all -> {}", route.get(0));
        } else {
            log.debug(" : {} -> {}", route.get(0), route.get(1));
        }
    }
    return routes;
}
#method_after
private Set<ArrayList<DeviceId>> computeRouteChange() {
    ImmutableSet.Builder<ArrayList<DeviceId>> changedRoutesBuilder = ImmutableSet.builder();
    for (Device sw : srManager.deviceService.getDevices()) {
        DeviceId rootSw = sw.id();
        log.debug("Computing the impacted routes for device {}", rootSw);
        if (!srManager.mastershipService.isLocalMaster(rootSw)) {
            log.debug("No mastership for {} ... skipping route optimization", rootSw);
            continue;
        }
        if (log.isTraceEnabled()) {
            log.trace("link of {} - ", rootSw);
            for (Link link : srManager.linkService.getDeviceLinks(rootSw)) {
                log.trace("{} -> {} ", link.src().deviceId(), link.dst().deviceId());
            }
        }
        EcmpShortestPathGraph currEcmpSpg = currentEcmpSpgMap.get(rootSw);
        if (currEcmpSpg == null) {
            log.debug("No existing ECMP graph for device {}", rootSw);
            changedRoutesBuilder.add(Lists.newArrayList(rootSw));
            continue;
        }
        EcmpShortestPathGraph newEcmpSpg = updatedEcmpSpgMap.get(rootSw);
        if (log.isTraceEnabled()) {
            log.trace("Root switch: {}", rootSw);
            log.trace("  Current/Existing SPG: {}", currEcmpSpg);
            log.trace("       New/Updated SPG: {}", newEcmpSpg);
        }
        // first use the updated/new map to compare to current/existing map
        // as new links may have come up
        changedRoutesBuilder.addAll(compareGraphs(newEcmpSpg, currEcmpSpg, rootSw));
        // then use the current/existing map to compare to updated/new map
        // as switch may have been removed
        changedRoutesBuilder.addAll(compareGraphs(currEcmpSpg, newEcmpSpg, rootSw));
    }
    Set<ArrayList<DeviceId>> changedRoutes = changedRoutesBuilder.build();
    for (ArrayList<DeviceId> route : changedRoutes) {
        log.debug("Route changes Target -> Root");
        if (route.size() == 1) {
            log.debug(" : all -> {}", route.get(0));
        } else {
            log.debug(" : {} -> {}", route.get(0), route.get(1));
        }
    }
    return changedRoutes;
}
#end_block

#method_before
private ArrayList<ArrayList<DeviceId>> getVia(HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia, DeviceId srcSw) {
    for (Integer itrIdx : switchVia.keySet()) {
        HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
        if (swViaMap.get(srcSw) == null) {
            continue;
        } else {
            return swViaMap.get(srcSw);
        }
    }
    return null;
}
#method_after
private ArrayList<ArrayList<DeviceId>> getVia(HashMap<Integer, HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>>> switchVia, DeviceId targetSw) {
    for (Integer itrIdx : switchVia.keySet()) {
        HashMap<DeviceId, ArrayList<ArrayList<DeviceId>>> swViaMap = switchVia.get(itrIdx);
        if (swViaMap.get(targetSw) == null) {
            continue;
        } else {
            return swViaMap.get(targetSw);
        }
    }
    return null;
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder hostSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API);
    hostsConsistentMap = storageService.<HostId, DefaultHost>consistentMapBuilder().withName("onos-hosts").withRelaxedReadConsistency().withSerializer(Serializer.using(hostSerializer.build())).build();
    hosts = hostsConsistentMap.asJavaMap();
    prevHosts.putAll(hosts);
    hostsConsistentMap.addListener(hostLocationTracker);
    loadHostsByIp();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder hostSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API);
    hostsConsistentMap = storageService.<HostId, DefaultHost>consistentMapBuilder().withName("onos-hosts").withRelaxedReadConsistency().withSerializer(Serializer.using(hostSerializer.build())).build();
    hosts = hostsConsistentMap.asJavaMap();
    prevHosts.putAll(hosts);
    hostsConsistentMap.addListener(hostLocationTracker);
    executor = newSingleThreadScheduledExecutor(groupedThreads("onos/hosts", "store", log));
    statusChangeListener = status -> {
        if (status == Status.ACTIVE) {
            executor.execute(this::loadHostsByIp);
        }
    };
    hostsConsistentMap.addStatusChangeListener(statusChangeListener);
    loadHostsByIp();
    log.info("Started");
}
#end_block

#method_before
private void loadHostsByIp() {
    hostsByIp = new ConcurrentHashMap<IpAddress, Set<Host>>();
    hosts.values().forEach(host -> {
        host.ipAddresses().forEach(ip -> {
            Set<Host> existingHosts = hostsByIp.get(host.ipAddresses());
            if (existingHosts == null) {
                hostsByIp.put(ip, Sets.newHashSet(host));
            } else {
                existingHosts.add(host);
            }
        });
    });
}
#method_after
private void loadHostsByIp() {
    hostsByIp = new ConcurrentHashMap<IpAddress, Set<Host>>();
    hostsConsistentMap.asJavaMap().values().forEach(host -> {
        host.ipAddresses().forEach(ip -> {
            Set<Host> existingHosts = hostsByIp.get(ip);
            if (existingHosts == null) {
                hostsByIp.put(ip, addHosts(host));
            } else {
                existingHosts.add(host);
            }
        });
    });
}
#end_block

#method_before
@Override
public HostEvent createOrUpdateHost(ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    hostsConsistentMap.computeIf(hostId, existingHost -> shouldUpdate(existingHost, providerId, hostId, hostDescription, replaceIPs), (id, existingHost) -> {
        HostLocation location = hostDescription.location();
        final Set<IpAddress> addresses;
        if (existingHost == null || replaceIPs) {
            addresses = ImmutableSet.copyOf(hostDescription.ipAddress());
        } else {
            addresses = Sets.newHashSet(existingHost.ipAddresses());
            addresses.addAll(hostDescription.ipAddress());
        }
        final Annotations annotations;
        if (existingHost != null) {
            annotations = merge((DefaultAnnotations) existingHost.annotations(), hostDescription.annotations());
        } else {
            annotations = hostDescription.annotations();
        }
        return new DefaultHost(providerId, hostId, hostDescription.hwAddress(), hostDescription.vlan(), location, addresses, annotations);
    });
    return null;
}
#method_after
@Override
public HostEvent createOrUpdateHost(ProviderId providerId, HostId hostId, HostDescription hostDescription, boolean replaceIPs) {
    hostsConsistentMap.computeIf(hostId, existingHost -> shouldUpdate(existingHost, providerId, hostId, hostDescription, replaceIPs), (id, existingHost) -> {
        HostLocation location = hostDescription.location();
        final Set<IpAddress> addresses;
        if (existingHost == null || replaceIPs) {
            addresses = ImmutableSet.copyOf(hostDescription.ipAddress());
        } else {
            addresses = Sets.newHashSet(existingHost.ipAddresses());
            addresses.addAll(hostDescription.ipAddress());
        }
        final Annotations annotations;
        final boolean configured;
        if (existingHost != null) {
            annotations = merge((DefaultAnnotations) existingHost.annotations(), hostDescription.annotations());
            configured = existingHost.configured();
        } else {
            annotations = hostDescription.annotations();
            configured = hostDescription.configured();
        }
        return new DefaultHost(providerId, hostId, hostDescription.hwAddress(), hostDescription.vlan(), location, addresses, configured, annotations);
    });
    return null;
}
#end_block

#method_before
@Override
public HostEvent removeIp(HostId hostId, IpAddress ipAddress) {
    hosts.compute(hostId, (id, existingHost) -> {
        if (existingHost != null) {
            checkState(Objects.equals(hostId.mac(), existingHost.mac()), "Existing and new MAC addresses differ.");
            checkState(Objects.equals(hostId.vlanId(), existingHost.vlan()), "Existing and new VLANs differ.");
            Set<IpAddress> addresses = existingHost.ipAddresses();
            if (addresses != null && addresses.contains(ipAddress)) {
                addresses = new HashSet<>(existingHost.ipAddresses());
                addresses.remove(ipAddress);
                return new DefaultHost(existingHost.providerId(), hostId, existingHost.mac(), existingHost.vlan(), existingHost.location(), ImmutableSet.copyOf(addresses), existingHost.annotations());
            } else {
                return existingHost;
            }
        }
        return null;
    });
    return null;
}
#method_after
@Override
public HostEvent removeIp(HostId hostId, IpAddress ipAddress) {
    hosts.compute(hostId, (id, existingHost) -> {
        if (existingHost != null) {
            checkState(Objects.equals(hostId.mac(), existingHost.mac()), "Existing and new MAC addresses differ.");
            checkState(Objects.equals(hostId.vlanId(), existingHost.vlan()), "Existing and new VLANs differ.");
            Set<IpAddress> addresses = existingHost.ipAddresses();
            if (addresses != null && addresses.contains(ipAddress)) {
                addresses = new HashSet<>(existingHost.ipAddresses());
                addresses.remove(ipAddress);
                removeIpFromHostsByIp(existingHost, ipAddress);
                return new DefaultHost(existingHost.providerId(), hostId, existingHost.mac(), existingHost.vlan(), existingHost.location(), ImmutableSet.copyOf(addresses), existingHost.annotations());
            } else {
                return existingHost;
            }
        }
        return null;
    });
    return null;
}
#end_block

#method_before
@Override
public Set<Host> getHosts(IpAddress ip) {
    return hostsByIp.get(ip);
}
#method_after
@Override
public Set<Host> getHosts(IpAddress ip) {
    Set<Host> hosts = hostsByIp.get(ip);
    return hosts != null ? ImmutableSet.copyOf(hosts) : ImmutableSet.of();
}
#end_block

#method_before
private void updateHostsByIp(DefaultHost host) {
    host.ipAddresses().forEach(ip -> {
        Set<Host> existingHosts = hostsByIp.get(ip);
        if (existingHosts != null && existingHosts.size() > 0) {
            Iterator<Host> iterator = existingHosts.iterator();
            boolean exists = false;
            while (iterator.hasNext()) {
                Host existingHost = iterator.next();
                if (existingHost.id().equals(host.id())) {
                    exists = true;
                    existingHosts.remove(existingHost);
                    existingHosts.add(host);
                }
            }
            if (!exists) {
                existingHosts.add(host);
            }
        } else {
            hostsByIp.put(ip, Sets.newHashSet(host));
        }
    });
}
#method_after
private void updateHostsByIp(DefaultHost host) {
    host.ipAddresses().forEach(ip -> {
        hostsByIp.compute(ip, (k, v) -> v == null ? addHosts(host) : updateHosts(v, host));
    });
}
#end_block

#method_before
private void removeHostsByIp(DefaultHost host) {
    host.ipAddresses().forEach(ip -> {
        Set<Host> existingHosts = hostsByIp.get(ip);
        if (existingHosts != null && existingHosts.size() > 1) {
            Iterator<Host> iterator = existingHosts.iterator();
            while (iterator.hasNext()) {
                Host existingHost = iterator.next();
                if (existingHost.id().equals(host.id())) {
                    existingHosts.remove(existingHost);
                }
            }
        } else if (existingHosts != null && existingHosts.size() == 1) {
            hostsByIp.remove(ip);
        }
    });
}
#method_after
private void removeHostsByIp(DefaultHost host) {
    host.ipAddresses().forEach(ip -> {
        hostsByIp.computeIfPresent(ip, (k, v) -> removeHosts(v, host));
    });
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    InputStream jsonStream = SegmentRoutingAppConfigTest.class.getResourceAsStream("/app.json");
    InputStream invalidJsonStream = SegmentRoutingAppConfigTest.class.getResourceAsStream("/app-invalid.json");
    InputStream extendedJsonStream = SegmentRoutingAppConfigTest.class.getResourceAsStream("/app-mpls-ecmp.json");
    String key = SegmentRoutingManager.SR_APP_ID;
    ApplicationId subject = new TestApplicationId(key);
    ObjectMapper mapper = new ObjectMapper();
    JsonNode jsonNode = mapper.readTree(jsonStream);
    JsonNode invalidJsonNode = mapper.readTree(invalidJsonStream);
    JsonNode extendedJsonNode = mapper.readTree(extendedJsonStream);
    ConfigApplyDelegate delegate = new MockDelegate();
    config = new SegmentRoutingAppConfig();
    config.init(subject, key, jsonNode, mapper, delegate);
    invalidConfig = new SegmentRoutingAppConfig();
    invalidConfig.init(subject, key, invalidJsonNode, mapper, delegate);
    extendedConfig = new SegmentRoutingAppConfig();
    extendedConfig.init(subject, key, extendedJsonNode, mapper, delegate);
}
#method_after
@Before
public void setUp() throws Exception {
    InputStream jsonStream = SegmentRoutingAppConfigTest.class.getResourceAsStream("/app.json");
    InputStream invalidJsonStream = SegmentRoutingAppConfigTest.class.getResourceAsStream("/app-invalid.json");
    InputStream mplsEcmpJsonStream = SegmentRoutingAppConfigTest.class.getResourceAsStream("/app-ecmp.json");
    String key = SegmentRoutingManager.SR_APP_ID;
    ApplicationId subject = new TestApplicationId(key);
    ObjectMapper mapper = new ObjectMapper();
    JsonNode jsonNode = mapper.readTree(jsonStream);
    JsonNode invalidJsonNode = mapper.readTree(invalidJsonStream);
    JsonNode mplsEcmpJsonNode = mapper.readTree(mplsEcmpJsonStream);
    ConfigApplyDelegate delegate = new MockDelegate();
    config = new SegmentRoutingAppConfig();
    config.init(subject, key, jsonNode, mapper, delegate);
    invalidConfig = new SegmentRoutingAppConfig();
    invalidConfig.init(subject, key, invalidJsonNode, mapper, delegate);
    mplsEcmpConfig = new SegmentRoutingAppConfig();
    mplsEcmpConfig.init(subject, key, mplsEcmpJsonNode, mapper, delegate);
}
#end_block

#method_before
@Test
public void testIsValid() throws Exception {
    assertTrue(config.isValid());
    assertFalse(invalidConfig.isValid());
    assertTrue(extendedConfig.isValid());
}
#method_after
@Test
public void testIsValid() throws Exception {
    assertTrue(config.isValid());
    assertFalse(invalidConfig.isValid());
    assertTrue(mplsEcmpConfig.isValid());
}
#end_block

#method_before
@Test
public void testMplsEcmp() {
    boolean mplsEcmp = extendedConfig.mplsEcmp();
    assertThat(mplsEcmp, is(true));
}
#method_after
@Test
public void testMplsEcmp() {
    boolean mplsEcmp = mplsEcmpConfig.mplsEcmp();
    assertThat(mplsEcmp, is(true));
}
#end_block

#method_before
@Test
public void testSetMplsEcmp() {
    /*
         * In the extended config the value is true.
         */
    boolean mplsEcmp = extendedConfig.mplsEcmp();
    assertThat(mplsEcmp, is(true));
    extendedConfig.setMplsEcmp(false);
    mplsEcmp = extendedConfig.mplsEcmp();
    assertThat(mplsEcmp, is(false));
    /*
         * In the config the value is not set,
         */
    mplsEcmp = config.mplsEcmp();
    assertThat(mplsEcmp, is(false));
    config.setMplsEcmp(true);
    mplsEcmp = config.mplsEcmp();
    assertThat(mplsEcmp, is(true));
}
#method_after
@Test
public void testSetMplsEcmp() {
    /*
         * In the config the value is not set.
         */
    boolean mplsEcmp = config.mplsEcmp();
    assertThat(mplsEcmp, is(false));
    config.setMplsEcmp(true);
    mplsEcmp = config.mplsEcmp();
    assertThat(mplsEcmp, is(true));
    /*
         * In the mplsEcmpConfig the value is true,
         */
    mplsEcmp = mplsEcmpConfig.mplsEcmp();
    assertThat(mplsEcmp, is(true));
    config.setMplsEcmp(false);
    mplsEcmp = config.mplsEcmp();
    assertThat(mplsEcmp, is(false));
}
#end_block

#method_before
public boolean getMplsEcmp() {
    return cfgService.getConfig(this.appId, SegmentRoutingAppConfig.class).mplsEcmp();
}
#method_after
public boolean getMplsEcmp() {
    SegmentRoutingAppConfig segmentRoutingAppConfig = cfgService.getConfig(this.appId, SegmentRoutingAppConfig.class);
    return segmentRoutingAppConfig != null && segmentRoutingAppConfig.mplsEcmp();
}
#end_block

#method_before
@Override
public boolean isValid() {
    return hasFields(VROUTER_MACS, VROUTER_ID, SUPPRESS_SUBNET, SUPPRESS_HOST_BY_PORT, SUPPRESS_HOST_BY_PROVIDER) && isBoolean(MPLS_ECMP, OPTIONAL) && vRouterMacs() != null && vRouterId() != null && suppressSubnet() != null && suppressHostByPort() != null && suppressHostByProvider() != null && mplsEcmp() != null;
}
#method_after
@Override
public boolean isValid() {
    return hasOnlyFields(VROUTER_MACS, VROUTER_ID, SUPPRESS_SUBNET, SUPPRESS_HOST_BY_PORT, SUPPRESS_HOST_BY_PROVIDER, MPLS_ECMP) && vRouterMacs() != null && vRouterId() != null && suppressSubnet() != null && suppressHostByPort() != null && suppressHostByProvider() != null;
}
#end_block

#method_before
public Boolean mplsEcmp() {
    return get(MPLS_ECMP, false);
}
#method_after
public boolean mplsEcmp() {
    return get(MPLS_ECMP, false);
}
#end_block

#method_before
@Override
public byte[] serialize() {
    return APPKRYO.serialize(0);
}
#method_after
@Override
public byte[] serialize() {
    return APPKRYO.serialize(true);
}
#end_block

#method_before
@Override
public byte[] serialize() {
    return APPKRYO.serialize(0);
}
#method_after
@Override
public byte[] serialize() {
    return APPKRYO.serialize(true);
}
#end_block

#method_before
@Override
public byte[] serialize() {
    return APPKRYO.serialize(0);
}
#method_after
@Override
public byte[] serialize() {
    return APPKRYO.serialize(true);
}
#end_block

#method_before
@Override
public byte[] serialize() {
    return APPKRYO.serialize(0);
}
#method_after
@Override
public byte[] serialize() {
    return APPKRYO.serialize(true);
}
#end_block

#method_before
public LispMapNotify processMapRegister(LispMessage message) {
    LispMapRegister register = (LispMapRegister) message;
    if (!checkMapRegisterAuthData(register)) {
        log.warn("Unmatched authentication data of Map-Register");
        return null;
    }
    NotifyBuilder notifyBuilder = new DefaultNotifyBuilder();
    notifyBuilder.withKeyId(authInfo.lispAuthMethod());
    notifyBuilder.withAuthDataLength(valueOf(authInfo.lispAuthMethod()).getHashLength());
    notifyBuilder.withAuthKey(authInfo.lispAuthKey());
    notifyBuilder.withNonce(register.getNonce());
    notifyBuilder.withMapRecords(register.getMapRecords());
    LispMapNotify notify = notifyBuilder.build();
    InetSocketAddress address = new InetSocketAddress(register.getSender().getAddress(), MAP_NOTIFY_PORT);
    notify.configSender(address);
    register.getMapRecords().forEach(record -> {
        LispEidRecord eidRecord = new LispEidRecord(record.getMaskLength(), record.getEidPrefixAfi());
        eidRlocMap.insertMapRecord(eidRecord, record);
    });
    return notify;
}
#method_after
public LispMapNotify processMapRegister(LispMessage message) {
    LispMapRegister register = (LispMapRegister) message;
    if (!checkMapRegisterAuthData(register)) {
        log.warn("Unmatched authentication data of Map-Register");
        return null;
    }
    NotifyBuilder notifyBuilder = new DefaultNotifyBuilder();
    notifyBuilder.withKeyId(authConfig.lispAuthKeyId());
    notifyBuilder.withAuthDataLength(valueOf(authConfig.lispAuthKeyId()).getHashLength());
    notifyBuilder.withAuthKey(authConfig.lispAuthKey());
    notifyBuilder.withNonce(register.getNonce());
    notifyBuilder.withMapRecords(register.getMapRecords());
    LispMapNotify notify = notifyBuilder.build();
    InetSocketAddress address = new InetSocketAddress(register.getSender().getAddress(), MAP_NOTIFY_PORT);
    notify.configSender(address);
    register.getMapRecords().forEach(record -> {
        LispEidRecord eidRecord = new LispEidRecord(record.getMaskLength(), record.getEidPrefixAfi());
        eidRlocMap.insertMapRecord(eidRecord, record);
    });
    return notify;
}
#end_block

#method_before
public LispInfoReply processInfoRequest(LispMessage message) {
    LispInfoRequest request = (LispInfoRequest) message;
    if (!checkInfoRequestAuthData(request)) {
        log.warn("Unmatched authentication data of Info-Request");
        return null;
    }
    NatAddressBuilder natBuilder = new NatAddressBuilder();
    try {
        LispAfiAddress msAddress = new LispIpv4Address(IpAddress.valueOf(InetAddress.getLocalHost()));
        natBuilder.withMsRlocAddress(msAddress);
        natBuilder.withMsUdpPortNumber((short) INFO_REPLY_PORT);
        // try to extract global ETR RLOC address from info-request
        IpAddress globalRlocIp = IpAddress.valueOf(request.getSender().getAddress());
        LispAfiAddress globalRlocAddress;
        if (globalRlocIp.isIp4()) {
            globalRlocAddress = new LispIpv4Address(globalRlocIp);
        } else {
            globalRlocAddress = new LispIpv6Address(globalRlocIp);
        }
        natBuilder.withGlobalEtrRlocAddress(globalRlocAddress);
        natBuilder.withEtrUdpPortNumber((short) request.getSender().getPort());
        natBuilder.withPrivateEtrRlocAddress(new LispNoAddress());
    // TODO: need to specify RTR addresses
    } catch (UnknownHostException e) {
        log.warn("Fails during formulate NAT address", e);
    }
    InfoReplyBuilder replyBuilder = new DefaultLispInfoReply.DefaultInfoReplyBuilder();
    replyBuilder.withKeyId(request.getKeyId());
    replyBuilder.withAuthDataLength(valueOf(authInfo.lispAuthMethod()).getHashLength());
    replyBuilder.withAuthKey(authInfo.lispAuthKey());
    replyBuilder.withNonce(request.getNonce());
    replyBuilder.withEidPrefix(request.getPrefix());
    replyBuilder.withMaskLength(request.getMaskLength());
    replyBuilder.withTtl(request.getTtl());
    replyBuilder.withNatLcafAddress(natBuilder.build());
    replyBuilder.withIsInfoReply(true);
    LispInfoReply reply = replyBuilder.build();
    reply.configSender(request.getSender());
    return reply;
}
#method_after
public LispInfoReply processInfoRequest(LispMessage message) {
    LispInfoRequest request = (LispInfoRequest) message;
    if (!checkInfoRequestAuthData(request)) {
        log.warn("Unmatched authentication data of Info-Request");
        return null;
    }
    NatAddressBuilder natBuilder = new NatAddressBuilder();
    try {
        LispAfiAddress msAddress = new LispIpv4Address(IpAddress.valueOf(InetAddress.getLocalHost()));
        natBuilder.withMsRlocAddress(msAddress);
        natBuilder.withMsUdpPortNumber((short) INFO_REPLY_PORT);
        // try to extract global ETR RLOC address from info-request
        IpAddress globalRlocIp = IpAddress.valueOf(request.getSender().getAddress());
        LispAfiAddress globalRlocAddress;
        if (globalRlocIp.isIp4()) {
            globalRlocAddress = new LispIpv4Address(globalRlocIp);
        } else {
            globalRlocAddress = new LispIpv6Address(globalRlocIp);
        }
        natBuilder.withGlobalEtrRlocAddress(globalRlocAddress);
        natBuilder.withEtrUdpPortNumber((short) request.getSender().getPort());
        natBuilder.withPrivateEtrRlocAddress(new LispNoAddress());
    // TODO: need to specify RTR addresses
    } catch (UnknownHostException e) {
        log.warn("Fails during formulate NAT address", e);
    }
    InfoReplyBuilder replyBuilder = new DefaultLispInfoReply.DefaultInfoReplyBuilder();
    replyBuilder.withKeyId(request.getKeyId());
    replyBuilder.withAuthDataLength(valueOf(authConfig.lispAuthKeyId()).getHashLength());
    replyBuilder.withAuthKey(authConfig.lispAuthKey());
    replyBuilder.withNonce(request.getNonce());
    replyBuilder.withEidPrefix(request.getPrefix());
    replyBuilder.withMaskLength(request.getMaskLength());
    replyBuilder.withTtl(request.getTtl());
    replyBuilder.withNatLcafAddress(natBuilder.build());
    replyBuilder.withIsInfoReply(true);
    LispInfoReply reply = replyBuilder.build();
    reply.configSender(request.getSender());
    return reply;
}
#end_block

#method_before
private boolean checkMapRegisterAuthData(LispMapRegister register) {
    RegisterBuilder registerBuilder = new DefaultRegisterBuilder();
    registerBuilder.withKeyId(register.getKeyId());
    registerBuilder.withAuthKey(authInfo.lispAuthKey());
    registerBuilder.withNonce(register.getNonce());
    registerBuilder.withIsProxyMapReply(register.isProxyMapReply());
    registerBuilder.withIsWantMapNotify(register.isWantMapNotify());
    registerBuilder.withMapRecords(register.getMapRecords());
    LispMapRegister authRegister = registerBuilder.build();
    return Arrays.equals(authRegister.getAuthData(), register.getAuthData());
}
#method_after
private boolean checkMapRegisterAuthData(LispMapRegister register) {
    RegisterBuilder registerBuilder = new DefaultRegisterBuilder();
    registerBuilder.withKeyId(register.getKeyId());
    registerBuilder.withAuthKey(authConfig.lispAuthKey());
    registerBuilder.withNonce(register.getNonce());
    registerBuilder.withIsProxyMapReply(register.isProxyMapReply());
    registerBuilder.withIsWantMapNotify(register.isWantMapNotify());
    registerBuilder.withMapRecords(register.getMapRecords());
    LispMapRegister authRegister = registerBuilder.build();
    return Arrays.equals(authRegister.getAuthData(), register.getAuthData());
}
#end_block

#method_before
private boolean checkInfoRequestAuthData(LispInfoRequest request) {
    InfoRequestBuilder requestBuilder = new DefaultInfoRequestBuilder();
    requestBuilder.withKeyId(request.getKeyId());
    requestBuilder.withAuthKey(authInfo.lispAuthKey());
    requestBuilder.withNonce(request.getNonce());
    requestBuilder.withTtl(request.getTtl());
    requestBuilder.withEidPrefix(request.getPrefix());
    requestBuilder.withIsInfoReply(request.isInfoReply());
    requestBuilder.withMaskLength(request.getMaskLength());
    LispInfoRequest authRequest = requestBuilder.build();
    return Arrays.equals(authRequest.getAuthData(), request.getAuthData());
}
#method_after
private boolean checkInfoRequestAuthData(LispInfoRequest request) {
    InfoRequestBuilder requestBuilder = new DefaultInfoRequestBuilder();
    requestBuilder.withKeyId(request.getKeyId());
    requestBuilder.withAuthKey(authConfig.lispAuthKey());
    requestBuilder.withNonce(request.getNonce());
    requestBuilder.withTtl(request.getTtl());
    requestBuilder.withEidPrefix(request.getPrefix());
    requestBuilder.withIsInfoReply(request.isInfoReply());
    requestBuilder.withMaskLength(request.getMaskLength());
    LispInfoRequest authRequest = requestBuilder.build();
    return Arrays.equals(authRequest.getAuthData(), request.getAuthData());
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    coreService.registerApplication(APP_ID);
    initAuthInfo(context.getProperties());
    bootstrap.start();
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    coreService.registerApplication(APP_ID);
    initAuthConfig(context.getProperties());
    bootstrap.start();
    log.info("Started");
}
#end_block

#method_before
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String lispAuthKeyStr = Tools.get(properties, "lispAuthKey");
    lispAuthKey = lispAuthKeyStr != null ? lispAuthKeyStr : DEFAULT_LISP_AUTH_KEY;
    authInfo.updateLispAuthKey(lispAuthKey);
    log.info("Configured. LISP authentication key is {}", lispAuthKey);
    Integer lispAuthMethodInt = Tools.getIntegerProperty(properties, "lispAuthMethod");
    if (lispAuthMethodInt == null) {
        lispAuthMethod = DEFAULT_LISP_AUTH_METHOD;
        log.info("LISP authentication method is not configured, default value is {}", lispAuthMethod);
    } else {
        lispAuthMethod = lispAuthMethodInt;
        log.info("Configured. LISP authentication method is configured to {}", lispAuthMethod);
    }
    authInfo.updateLispAuthMethod(lispAuthMethod);
}
#method_after
private void readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    String lispAuthKeyStr = Tools.get(properties, "lispAuthKey");
    lispAuthKey = lispAuthKeyStr != null ? lispAuthKeyStr : DEFAULT_LISP_AUTH_KEY;
    authConfig.updateLispAuthKey(lispAuthKey);
    log.info("Configured. LISP authentication key is {}", lispAuthKey);
    Integer lispAuthMethodInt = Tools.getIntegerProperty(properties, "lispAuthKeyId");
    if (lispAuthMethodInt == null) {
        lispAuthKeyId = DEFAULT_LISP_AUTH_KEY_ID;
        log.info("LISP authentication method is not configured, default value is {}", lispAuthKeyId);
    } else {
        lispAuthKeyId = lispAuthMethodInt;
        log.info("Configured. LISP authentication method is configured to {}", lispAuthKeyId);
    }
    authConfig.updateLispAuthKeyId(lispAuthKeyId);
}
#end_block

#method_before
@Override
public String toString() {
    final StringBuffer sb = new StringBuffer("\n");
    final IPacket pkt = this.getPayload();
    if (pkt instanceof ARP) {
        sb.append("arp");
    } else if (pkt instanceof LLDP) {
        sb.append("lldp");
    } else if (pkt instanceof ICMP) {
        sb.append("icmp");
    } else if (pkt instanceof IPv4) {
        sb.append("ip");
    } else if (pkt instanceof DHCP) {
        sb.append("dhcp");
    } else {
        /*
             * When we don't know the protocol, we print using
             * the well known hex format instead of a decimal
             * value.
             */
        sb.append(Integer.toHexString(this.getEtherType() & 0xffff));
    }
    sb.append("\ndl_vlan: ");
    if (this.getVlanID() == Ethernet.VLAN_UNTAGGED) {
        sb.append("untagged");
    } else {
        sb.append(this.getVlanID());
    }
    sb.append("\ndl_vlan_pcp: ");
    sb.append(this.getPriorityCode());
    sb.append("\ndl_src: ");
    sb.append(bytesToHex(this.getSourceMACAddress()));
    sb.append("\ndl_dst: ");
    sb.append(bytesToHex(this.getDestinationMACAddress()));
    if (pkt instanceof ARP) {
        final ARP p = (ARP) pkt;
        sb.append("\nnw_src: ");
        sb.append(IPv4.fromIPv4Address(IPv4.toIPv4Address(p.getSenderProtocolAddress())));
        sb.append("\nnw_dst: ");
        sb.append(IPv4.fromIPv4Address(IPv4.toIPv4Address(p.getTargetProtocolAddress())));
    } else if (pkt instanceof LLDP) {
        sb.append("lldp packet");
    } else if (pkt instanceof ICMP) {
        final ICMP icmp = (ICMP) pkt;
        sb.append("\nicmp_type: ");
        sb.append(icmp.getIcmpType());
        sb.append("\nicmp_code: ");
        sb.append(icmp.getIcmpCode());
    } else if (pkt instanceof IPv4) {
        final IPv4 p = (IPv4) pkt;
        sb.append("\nnw_src: ");
        sb.append(IPv4.fromIPv4Address(p.getSourceAddress()));
        sb.append("\nnw_dst: ");
        sb.append(IPv4.fromIPv4Address(p.getDestinationAddress()));
        sb.append("\nnw_tos: ");
        sb.append(p.getDiffServ());
        sb.append("\nnw_proto: ");
        sb.append(p.getProtocol());
        IPacket payload = pkt.getPayload();
        if (payload != null) {
            if (payload instanceof TCP) {
                sb.append("\ntp_src: ");
                sb.append(((TCP) payload).getSourcePort());
                sb.append("\ntp_dst: ");
                sb.append(((TCP) payload).getDestinationPort());
            } else if (payload instanceof UDP) {
                sb.append("\ntp_src: ");
                sb.append(((UDP) payload).getSourcePort());
                sb.append("\ntp_dst: ");
                sb.append(((UDP) payload).getDestinationPort());
            } else if (payload instanceof ICMP) {
                final ICMP icmp = (ICMP) payload;
                sb.append("\nicmp_type: ");
                sb.append(icmp.getIcmpType());
                sb.append("\nicmp_code: ");
                sb.append(icmp.getIcmpCode());
            }
        }
    } else if (pkt instanceof IPv6) {
        final IPv6 ipv6 = (IPv6) pkt;
        sb.append("\nipv6_src: ");
        sb.append(Ip6Address.valueOf(ipv6.getSourceAddress()).toString());
        sb.append("\nipv6_dst: ");
        sb.append(Ip6Address.valueOf(ipv6.getDestinationAddress()).toString());
        sb.append("\nipv6_proto: ");
        sb.append(ipv6.getNextHeader());
        IPacket payload = pkt.getPayload();
        if (payload != null && payload instanceof ICMP6) {
            final ICMP6 icmp6 = (ICMP6) payload;
            sb.append("\nicmp6_type: ");
            sb.append(icmp6.getIcmpType());
            sb.append("\nicmp6_code: ");
            sb.append(icmp6.getIcmpCode());
            payload = payload.getPayload();
            if (payload != null) {
                if (payload instanceof NeighborSolicitation) {
                    final NeighborSolicitation ns = (NeighborSolicitation) payload;
                    sb.append("\nns_target_addr: ");
                    sb.append(Ip6Address.valueOf(ns.getTargetAddress()).toString());
                    ns.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof NeighborAdvertisement) {
                    final NeighborAdvertisement na = (NeighborAdvertisement) payload;
                    sb.append("\nna_target_addr: ");
                    sb.append(Ip6Address.valueOf(na.getTargetAddress()).toString());
                    sb.append("\nna_solicited_flag: ");
                    sb.append(na.getSolicitedFlag());
                    sb.append("\nna_router_flag: ");
                    sb.append(na.getRouterFlag());
                    sb.append("\nna_override_flag: ");
                    sb.append(na.getOverrideFlag());
                    na.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof RouterSolicitation) {
                    final RouterSolicitation rs = (RouterSolicitation) payload;
                    sb.append("\nrs");
                    rs.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof RouterAdvertisement) {
                    final RouterAdvertisement ra = (RouterAdvertisement) payload;
                    sb.append("\nra_hop_limit: ");
                    sb.append(ra.getCurrentHopLimit());
                    sb.append("\nra_mflag: ");
                    sb.append(ra.getMFlag());
                    sb.append("\nra_oflag: ");
                    sb.append(ra.getOFlag());
                    sb.append("\nra_reachable_time: ");
                    sb.append(ra.getReachableTime());
                    sb.append("\nra_retransmit_time: ");
                    sb.append(ra.getRetransmitTimer());
                    sb.append("\nra_router_lifetime: ");
                    sb.append(ra.getRouterLifetime());
                    ra.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof Redirect) {
                    final Redirect rd = (Redirect) payload;
                    sb.append("\nrd_target_addr: ");
                    sb.append(Ip6Address.valueOf(rd.getTargetAddress()).toString());
                    rd.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                }
            }
        }
    } else if (pkt instanceof DHCP) {
        sb.append("\ndhcp packet");
    } else if (pkt instanceof Data) {
        sb.append("\ndata packet");
    } else if (pkt instanceof LLC) {
        sb.append("\nllc packet");
    } else {
        sb.append("\nunknown packet");
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    final StringBuffer sb = new StringBuffer("\n");
    final IPacket pkt = this.getPayload();
    if (pkt instanceof ARP) {
        sb.append("arp");
    } else if (pkt instanceof LLDP) {
        sb.append("lldp");
    } else if (pkt instanceof ICMP) {
        sb.append("icmp");
    } else if (pkt instanceof IPv4) {
        sb.append("ip");
    } else if (pkt instanceof DHCP) {
        sb.append("dhcp");
    } else {
        /*
             * When we don't know the protocol, we print using
             * the well known hex format instead of a decimal
             * value.
             */
        sb.append(String.format(HEX_PROTO, Integer.toHexString(this.getEtherType() & 0xffff)));
    }
    sb.append("\ndl_vlan: ");
    if (this.getVlanID() == Ethernet.VLAN_UNTAGGED) {
        sb.append("untagged");
    } else {
        sb.append(this.getVlanID());
    }
    sb.append("\ndl_vlan_pcp: ");
    sb.append(this.getPriorityCode());
    sb.append("\ndl_src: ");
    sb.append(bytesToHex(this.getSourceMACAddress()));
    sb.append("\ndl_dst: ");
    sb.append(bytesToHex(this.getDestinationMACAddress()));
    if (pkt instanceof ARP) {
        final ARP p = (ARP) pkt;
        sb.append("\nnw_src: ");
        sb.append(IPv4.fromIPv4Address(IPv4.toIPv4Address(p.getSenderProtocolAddress())));
        sb.append("\nnw_dst: ");
        sb.append(IPv4.fromIPv4Address(IPv4.toIPv4Address(p.getTargetProtocolAddress())));
    } else if (pkt instanceof LLDP) {
        sb.append("lldp packet");
    } else if (pkt instanceof ICMP) {
        final ICMP icmp = (ICMP) pkt;
        sb.append("\nicmp_type: ");
        sb.append(icmp.getIcmpType());
        sb.append("\nicmp_code: ");
        sb.append(icmp.getIcmpCode());
    } else if (pkt instanceof IPv4) {
        final IPv4 p = (IPv4) pkt;
        sb.append("\nnw_src: ");
        sb.append(IPv4.fromIPv4Address(p.getSourceAddress()));
        sb.append("\nnw_dst: ");
        sb.append(IPv4.fromIPv4Address(p.getDestinationAddress()));
        sb.append("\nnw_tos: ");
        sb.append(p.getDiffServ());
        sb.append("\nnw_proto: ");
        sb.append(p.getProtocol());
        IPacket payload = pkt.getPayload();
        if (payload != null) {
            if (payload instanceof TCP) {
                sb.append("\ntp_src: ");
                sb.append(((TCP) payload).getSourcePort());
                sb.append("\ntp_dst: ");
                sb.append(((TCP) payload).getDestinationPort());
            } else if (payload instanceof UDP) {
                sb.append("\ntp_src: ");
                sb.append(((UDP) payload).getSourcePort());
                sb.append("\ntp_dst: ");
                sb.append(((UDP) payload).getDestinationPort());
            } else if (payload instanceof ICMP) {
                final ICMP icmp = (ICMP) payload;
                sb.append("\nicmp_type: ");
                sb.append(icmp.getIcmpType());
                sb.append("\nicmp_code: ");
                sb.append(icmp.getIcmpCode());
            }
        }
    } else if (pkt instanceof IPv6) {
        final IPv6 ipv6 = (IPv6) pkt;
        sb.append("\nipv6_src: ");
        sb.append(Ip6Address.valueOf(ipv6.getSourceAddress()).toString());
        sb.append("\nipv6_dst: ");
        sb.append(Ip6Address.valueOf(ipv6.getDestinationAddress()).toString());
        sb.append("\nipv6_proto: ");
        sb.append(ipv6.getNextHeader());
        IPacket payload = pkt.getPayload();
        if (payload != null && payload instanceof ICMP6) {
            final ICMP6 icmp6 = (ICMP6) payload;
            sb.append("\nicmp6_type: ");
            sb.append(icmp6.getIcmpType());
            sb.append("\nicmp6_code: ");
            sb.append(icmp6.getIcmpCode());
            payload = payload.getPayload();
            if (payload != null) {
                if (payload instanceof NeighborSolicitation) {
                    final NeighborSolicitation ns = (NeighborSolicitation) payload;
                    sb.append("\nns_target_addr: ");
                    sb.append(Ip6Address.valueOf(ns.getTargetAddress()).toString());
                    ns.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof NeighborAdvertisement) {
                    final NeighborAdvertisement na = (NeighborAdvertisement) payload;
                    sb.append("\nna_target_addr: ");
                    sb.append(Ip6Address.valueOf(na.getTargetAddress()).toString());
                    sb.append("\nna_solicited_flag: ");
                    sb.append(na.getSolicitedFlag());
                    sb.append("\nna_router_flag: ");
                    sb.append(na.getRouterFlag());
                    sb.append("\nna_override_flag: ");
                    sb.append(na.getOverrideFlag());
                    na.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof RouterSolicitation) {
                    final RouterSolicitation rs = (RouterSolicitation) payload;
                    sb.append("\nrs");
                    rs.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof RouterAdvertisement) {
                    final RouterAdvertisement ra = (RouterAdvertisement) payload;
                    sb.append("\nra_hop_limit: ");
                    sb.append(ra.getCurrentHopLimit());
                    sb.append("\nra_mflag: ");
                    sb.append(ra.getMFlag());
                    sb.append("\nra_oflag: ");
                    sb.append(ra.getOFlag());
                    sb.append("\nra_reachable_time: ");
                    sb.append(ra.getReachableTime());
                    sb.append("\nra_retransmit_time: ");
                    sb.append(ra.getRetransmitTimer());
                    sb.append("\nra_router_lifetime: ");
                    sb.append(ra.getRouterLifetime());
                    ra.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                } else if (payload instanceof Redirect) {
                    final Redirect rd = (Redirect) payload;
                    sb.append("\nrd_target_addr: ");
                    sb.append(Ip6Address.valueOf(rd.getTargetAddress()).toString());
                    rd.getOptions().forEach(option -> {
                        sb.append("\noption_type: ");
                        sb.append(option.type());
                        sb.append("\noption_data: ");
                        sb.append(bytesToHex(option.data()));
                    });
                }
            }
        }
    } else if (pkt instanceof DHCP) {
        sb.append("\ndhcp packet");
    } else if (pkt instanceof Data) {
        sb.append("\ndata packet");
    } else if (pkt instanceof LLC) {
        sb.append("\nllc packet");
    } else {
        sb.append("\nunknown packet");
    }
    return sb.toString();
}
#end_block

#method_before
@Activate
public void activate() {
    log.info("RESTCONF SBI Started");
    if (ymsService != null) {
        ymsService.registerDefaultCodec(new JsonYdtCodec(ymsService), YangProtocolEncodingFormat.JSON_ENCODING);
    }
}
#method_after
@Activate
public void activate() {
    log.info("RESTCONF SBI Started");
    if (ymsService != null) {
        ymsService.registerDefaultCodec(new JsonYdtCodec(ymsService), YangProtocolEncodingFormat.JSON);
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        /*
                 * ONOS-5675: Each Event Consumer creates and listens
                 * to its own unique BlockingQueue. We use the thread ID
                 * as the Queue ID. (1) Do not use thread name because it is
                 * not unique. i.e., Use thread ID instead. (2) Do not call
                 * get-thread-ID in the constructor, because the thread is not
                 * created yet and thus no unique thread ID can be obtained
                 * in constructor.
                 */
        queueId = String.valueOf(Thread.currentThread().getId());
        eventQueueList.put(queueId, bqueue);
        log.debug("EventConsumer thread created: {}", queueId);
        ObjectNode chunk;
        while ((chunk = bqueue.take()) != null) {
            output.write(chunk.toString().concat(EOL));
        }
    } catch (IOException e) {
        log.debug("chunkedOuput is closed: {}", this.bqueue.toString());
        /*
                 * Remove queue from the queue list, so that the event producer
                 * (i.e., listener) would stop working.
                 */
        eventQueueList.remove(this.queueId);
    } catch (InterruptedException e) {
        log.error("ERROR: EventConsumer: bqueue.take() " + "has been interrupted.");
        log.debug("EventConsumer Exception:", e);
    } finally {
        try {
            output.close();
            log.debug("EventConsumer thread terminated: {}", queueId);
        } catch (IOException e) {
            log.error("ERROR: EventConsumer: ", e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        queueId = String.valueOf(Thread.currentThread().getId());
        eventQueueList.put(queueId, bqueue);
        log.debug("EventConsumer thread created: {}", queueId);
        ObjectNode chunk;
        while ((chunk = bqueue.take()) != null) {
            output.write(chunk.toString().concat(EOL));
        }
    } catch (IOException e) {
        log.debug("chunkedOuput is closed: {}", this.bqueue.toString());
        /*
                 * Remove queue from the queue list, so that the event producer
                 * (i.e., listener) would stop working.
                 */
        eventQueueList.remove(this.queueId);
    } catch (InterruptedException e) {
        log.error("ERROR: EventConsumer: bqueue.take() " + "has been interrupted.");
        log.debug("EventConsumer Exception:", e);
    } finally {
        try {
            output.close();
            log.debug("EventConsumer thread terminated: {}", queueId);
        } catch (IOException e) {
            log.error("ERROR: EventConsumer: ", e);
        }
    }
}
#end_block

#method_before
@Override
public boolean addTeTunnel(TeTunnel teTunnel) {
    if (teTunnel == null) {
        log.warn("teTunnel is null");
        return false;
    }
    if (teTunnels.containsKey(teTunnel.teTunnelKey())) {
        log.warn("teTunnel exist");
        return false;
    }
    teTunnels.put(teTunnel.teTunnelKey(), teTunnel);
    return true;
}
#method_after
@Override
public boolean addTeTunnel(TeTunnel teTunnel) {
    if (teTunnel == null) {
        log.warn("teTunnel is null");
        return false;
    }
    if (teTunnels.containsKey(teTunnel.teTunnelKey())) {
        log.warn("teTunnel already exist");
        return false;
    }
    teTunnels.put(teTunnel.teTunnelKey(), teTunnel);
    return true;
}
#end_block

#method_before
@Override
public void setTunnelId(TeTunnelKey teTunnelKey, TunnelId tunnelId) {
    tunnelIds.remove(teTunnelKey);
    tunnelIds.put(teTunnelKey, tunnelId);
}
#method_after
@Override
public void setTunnelId(TeTunnelKey teTunnelKey, TunnelId tunnelId) {
    tunnelIds.put(teTunnelKey, tunnelId);
}
#end_block

#method_before
@Override
public void updateTeTunnel(TeTunnel teTunnel) {
    if (teTunnel == null) {
        return;
    }
    teTunnels.remove(teTunnel.teTunnelKey());
    teTunnels.put(teTunnel.teTunnelKey(), teTunnel);
}
#method_after
@Override
public void updateTeTunnel(TeTunnel teTunnel) {
    if (teTunnel == null) {
        log.warn("TeTunnel is null");
        return;
    }
    teTunnels.put(teTunnel.teTunnelKey(), teTunnel);
}
#end_block

#method_before
@Override
public Collection<TeTunnel> getTeTunnels() {
    return teTunnels.values();
}
#method_after
@Override
public Collection<TeTunnel> getTeTunnels() {
    return ImmutableList.copyOf(teTunnels.values());
}
#end_block

#method_before
@Override
public Collection<TeTunnel> getTeTunnels(TeTunnel.Type type) {
    return teTunnels.values().stream().filter(teTunnel -> teTunnel.type().equals(type)).collect(Collectors.toList());
}
#method_after
@Override
public Collection<TeTunnel> getTeTunnels(TeTunnel.Type type) {
    return ImmutableList.copyOf(teTunnels.values().stream().filter(teTunnel -> teTunnel.type().equals(type)).collect(Collectors.toList()));
}
#end_block

#method_before
@Override
public Collection<TeTunnel> getTeTunnels(TeTopologyKey teTopologyKey) {
    return teTunnels.values().stream().filter(teTunnel -> teTunnel.teTunnelKey().teTopologyKey().equals(teTopologyKey)).collect(Collectors.toList());
}
#method_after
@Override
public Collection<TeTunnel> getTeTunnels(TeTopologyKey teTopologyKey) {
    return ImmutableList.copyOf(teTunnels.values().stream().filter(teTunnel -> teTunnel.teTunnelKey().teTopologyKey().equals(teTopologyKey)).collect(Collectors.toList()));
}
#end_block

#method_before
@Override
public TunnelId createTeTunnel(TeTunnel teTunnel) {
    if (!store.addTeTunnel(teTunnel)) {
        log.error("can not add teTunnel");
        return null;
    }
    TunnelId tunnelId = TunnelId.valueOf(teTunnel.teTunnelKey().toString());
    Tunnel tunnel = new DefaultTunnel(ProviderId.NONE, new TeTunnelEndpoint(teTunnel.srcNode(), teTunnel.srcTp()), new TeTunnelEndpoint(teTunnel.dstNode(), teTunnel.dstTp()), Tunnel.Type.MPLS, new DefaultGroupId(0), tunnelId, TunnelName.tunnelName(teTunnel.name()), null, null);
    store.setTunnelId(teTunnel.teTunnelKey(), tunnelId);
    TeTopology srcTopology = teTopologyService.teTopology(teTopologyService.teNode(teTunnel.srcNode()).underlayTeTopologyId());
    if (srcTopology == null) {
        srcTopology = teTopologyService.teTopology(teTunnel.srcNode().teTopologyKey());
    }
    DeviceId domainId = srcTopology.ownerId();
    TunnelId id = tunnelService.setupTunnel(appId, domainId, tunnel, null);
    if (id == null) {
        log.error("can not create tunnel for te {}", teTunnel.teTunnelKey());
        return null;
    }
    if (!id.equals(tunnelId)) {
        // this should not happen
        log.warn("tunnelId changed");
        store.setTunnelId(teTunnel.teTunnelKey(), id);
    }
    return id;
}
#method_after
@Override
public TunnelId createTeTunnel(TeTunnel teTunnel) {
    if (!store.addTeTunnel(teTunnel)) {
        log.error("can not add teTunnel: {}", teTunnel);
        return null;
    }
    TunnelId tunnelId = TunnelId.valueOf(teTunnel.teTunnelKey().toString());
    Tunnel tunnel = new DefaultTunnel(ProviderId.NONE, new TeTunnelEndpoint(teTunnel.srcNode(), teTunnel.srcTp()), new TeTunnelEndpoint(teTunnel.dstNode(), teTunnel.dstTp()), Tunnel.Type.MPLS, new DefaultGroupId(0), tunnelId, TunnelName.tunnelName(teTunnel.name()), null, DefaultAnnotations.builder().build());
    store.setTunnelId(teTunnel.teTunnelKey(), tunnelId);
    TeTopology srcTopology = teTopologyService.teTopology(teTopologyService.teNode(teTunnel.srcNode()).underlayTeTopologyId());
    if (srcTopology == null) {
        srcTopology = teTopologyService.teTopology(teTunnel.srcNode().teTopologyKey());
    }
    DeviceId domainId = srcTopology.ownerId();
    TunnelId id = tunnelService.setupTunnel(appId, domainId, tunnel, null);
    if (id == null) {
        log.error("can not create tunnel for te {}", teTunnel.teTunnelKey());
        store.removeTeTunnel(teTunnel.teTunnelKey());
        return null;
    }
    if (!id.equals(tunnelId)) {
        // this should not happen
        log.error("tunnelId changed, oldId:{}, newId:{}", tunnelId, id);
        store.setTunnelId(teTunnel.teTunnelKey(), id);
    }
    return id;
}
#end_block

#method_before
@Override
public void removeTeTunnel(TeTunnelKey teTunnelKey) {
    tunnelAdminService.updateTunnelState(tunnelService.queryTunnel(getTunnelId(teTunnelKey)), Tunnel.State.REMOVING);
    List<TeTunnelKey> segmentTunnels = getTeTunnel(teTunnelKey).segmentTunnels();
    if (segmentTunnels == null || segmentTunnels.isEmpty()) {
        // remove a domain tunnel
        tunnelAdminService.removeTunnel(getTunnelId(teTunnelKey));
    // then wait the tunnel to be removed, see teTunnelRemoved()
    }
}
#method_after
@Override
public void removeTeTunnel(TeTunnelKey teTunnelKey) {
    tunnelAdminService.updateTunnelState(tunnelService.queryTunnel(getTunnelId(teTunnelKey)), Tunnel.State.REMOVING);
    List<TeTunnelKey> segmentTunnels = getTeTunnel(teTunnelKey).segmentTunnels();
    if (segmentTunnels == null || segmentTunnels.isEmpty()) {
        // this is a single domain tunnel, removes it right away
        tunnelAdminService.removeTunnel(getTunnelId(teTunnelKey));
    }
}
#end_block

#method_before
@Override
public void setSegmentTunnel(TeTunnelKey e2eTunnelKye, List<TeTunnelKey> segmentTunnels) {
    TeTunnel e2eTunnel = store.getTeTunnel(e2eTunnelKye);
    if (e2eTunnel == null) {
        log.error("unknown e2eTunnel", e2eTunnelKye);
        return;
    }
    e2eTunnel.segmentTunnels(segmentTunnels);
    for (TeTunnelKey key : segmentTunnels) {
        TeTunnel segmentTunnel = store.getTeTunnel(key);
        if (segmentTunnel == null) {
            log.warn("unknown segmentTunnel", key);
            continue;
        }
        segmentTunnel.e2eTunnel(e2eTunnelKye);
    }
}
#method_after
@Override
public void setSegmentTunnel(TeTunnelKey e2eTunnelKey, List<TeTunnelKey> segmentTunnels) {
    TeTunnel e2eTunnel = store.getTeTunnel(e2eTunnelKey);
    if (e2eTunnel == null) {
        log.error("unknown e2eTunnel: {}", e2eTunnelKey);
        return;
    }
    e2eTunnel.segmentTunnels(segmentTunnels);
    for (TeTunnelKey key : segmentTunnels) {
        TeTunnel segmentTunnel = store.getTeTunnel(key);
        if (segmentTunnel == null) {
            log.warn("unknown segmentTunnel: {}", key);
            continue;
        }
        segmentTunnel.e2eTunnel(e2eTunnelKey);
    }
}
#end_block

#method_before
@Override
public TeTunnel getTeTunnel(TeTunnelKey teTunnelKey) {
    return store.getTeTunnel(teTunnelKey);
}
#method_after
@Override
public TeTunnel getTeTunnel(TeTunnelKey key) {
    return store.getTeTunnel(key);
}
#end_block

#method_before
@Override
public TeTunnel getTeTunnel(TunnelId tunnelId) {
    return store.getTeTunnel(tunnelId);
}
#method_after
@Override
public TeTunnel getTeTunnel(TunnelId id) {
    return store.getTeTunnel(id);
}
#end_block

#method_before
@Override
public TunnelId getTunnelId(TeTunnelKey teTunnelKey) {
    return store.getTunnelId(teTunnelKey);
}
#method_after
@Override
public TunnelId getTunnelId(TeTunnelKey key) {
    return store.getTunnelId(key);
}
#end_block

#method_before
@Override
public Collection<TeTunnel> getTeTunnels(TeTopologyKey teTopologyKey) {
    return store.getTeTunnels(teTopologyKey);
}
#method_after
@Override
public Collection<TeTunnel> getTeTunnels(TeTopologyKey key) {
    return store.getTeTunnels(key);
}
#end_block

#method_before
@Override
public void teTunnelRemoved(TeTunnel teTunnel) {
    TeTunnelKey e2eTunnel = teTunnel.e2eTunnel();
    store.removeTeTunnel(teTunnel.teTunnelKey());
    // it's a segment tunnel
    if (e2eTunnel != null) {
        boolean finished = true;
        for (TeTunnelKey key : getTeTunnel(e2eTunnel).segmentTunnels()) {
            if (getTeTunnel(key) != null) {
                // FIXME need a better way to determine whether a segment tunnel is removed.
                finished = false;
            }
        }
        if (finished) {
            // all segment tunnels are removed
            tunnelAdminService.removeTunnel(getTunnelId(e2eTunnel));
            store.removeTeTunnel(e2eTunnel);
        }
    }
}
#method_after
@Override
public void teTunnelRemoved(TeTunnel teTunnel) {
    TeTunnelKey e2eTunnelKey = teTunnel.e2eTunnel();
    store.removeTeTunnel(teTunnel.teTunnelKey());
    // it's a segment tunnel
    if (e2eTunnelKey != null) {
        boolean finished = true;
        for (TeTunnelKey key : getTeTunnel(e2eTunnelKey).segmentTunnels()) {
            if (getTeTunnel(key) != null) {
                // FIXME need a better way to determine whether a segment tunnel is removed.
                finished = false;
            }
        }
        if (finished) {
            // all segment tunnels are removed
            tunnelAdminService.removeTunnel(getTunnelId(e2eTunnelKey));
            store.removeTeTunnel(e2eTunnelKey);
        }
    }
}
#end_block

#method_before
public static KeyId toNetworkLinkId(TeLinkTpKey key) {
    return KeyId.keyId(new StringBuilder().append("teNodeId/").append(Ip4Address.valueOf((int) key.teNodeId()).toString()).append("/teLinkId/").append(key.teLinkTpId()).toString());
}
#method_after
public static KeyId toNetworkLinkId(TeLinkTpKey key) {
    return KeyId.keyId(new StringBuilder().append(TENODE_ID).append(Ip4Address.valueOf((int) key.teNodeId()).toString()).append(TELINK_ID).append(key.teLinkTpId()).toString());
}
#end_block

#method_before
public static KeyId toNetworkId(TeTopologyId teTopologyId) {
    return KeyId.keyId(new StringBuilder().append("providerId/").append(teTopologyId.providerId()).append("/clientId/").append(teTopologyId.clientId()).append("/topologyId/").append(teTopologyId.topologyId()).toString());
}
#method_after
public static KeyId toNetworkId(TeTopologyId teTopologyId) {
    return KeyId.keyId(new StringBuilder().append(PROVIDER_ID).append(teTopologyId.providerId()).append(CLIENT_ID).append(teTopologyId.clientId()).append(TOPOLOGY_ID).append(teTopologyId.topologyId()).toString());
}
#end_block

#method_before
public static KeyId toNetworkId(TeTopologyKey teTopologyKey) {
    return KeyId.keyId(new StringBuilder().append("providerId/").append(teTopologyKey.providerId()).append("/clientId/").append(teTopologyKey.clientId()).append("/topologyId/").append(teTopologyKey.topologyId()).toString());
}
#method_after
public static KeyId toNetworkId(TeTopologyKey teTopologyKey) {
    return KeyId.keyId(new StringBuilder().append(PROVIDER_ID).append(teTopologyKey.providerId()).append(CLIENT_ID).append(teTopologyKey.clientId()).append(TOPOLOGY_ID).append(teTopologyKey.topologyId()).toString());
}
#end_block

#method_before
public static Network networkBuilder(TeTopology teTopology) {
    KeyId networkId = TeMgrUtil.toNetworkId(teTopology.teTopologyId());
    TeTopologyId topologyId = teTopologyId(teTopology);
    Map<KeyId, NetworkNode> nodes = null;
    if (!MapUtils.isEmpty(teTopology.teNodes())) {
        nodes = Maps.newConcurrentMap();
        for (TeNode tenode : teTopology.teNodes().values()) {
            KeyId key = KeyId.keyId(Long.toString(tenode.teNodeId()));
            nodes.put(key, nodeBuilder(key, tenode));
        }
    }
    Map<KeyId, NetworkLink> links = null;
    if (!MapUtils.isEmpty(teTopology.teLinks())) {
        links = Maps.newConcurrentMap();
        for (TeLink telink : teTopology.teLinks().values()) {
            KeyId key = TeMgrUtil.toNetworkLinkId(telink.teLinkKey());
            links.put(key, linkBuilder(key, telink));
        }
    }
    return new DefaultNetwork(networkId, null, nodes, links, topologyId, false, teTopology.ownerId());
}
#method_after
public static Network networkBuilder(TeTopology teTopology) {
    KeyId networkId = TeMgrUtil.toNetworkId(teTopology.teTopologyId());
    TeTopologyId topologyId = teTopologyId(teTopology);
    Map<KeyId, NetworkNode> nodes = null;
    if (MapUtils.isNotEmpty(teTopology.teNodes())) {
        nodes = Maps.newHashMap();
        for (TeNode tenode : teTopology.teNodes().values()) {
            KeyId key = KeyId.keyId(Long.toString(tenode.teNodeId()));
            nodes.put(key, nodeBuilder(key, tenode));
        }
    }
    Map<KeyId, NetworkLink> links = null;
    if (MapUtils.isNotEmpty(teTopology.teLinks())) {
        links = Maps.newHashMap();
        for (TeLink telink : teTopology.teLinks().values()) {
            KeyId key = TeMgrUtil.toNetworkLinkId(telink.teLinkKey());
            links.put(key, linkBuilder(key, telink));
        }
    }
    return new DefaultNetwork(networkId, null, nodes, links, topologyId, false, teTopology.ownerId());
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTeLink) {
        InternalTeLink that = (InternalTeLink) object;
        return Objects.equal(this.peerTeLinkKey, that.peerTeLinkKey) && Objects.equal(this.underlayTopologyKey, that.underlayTopologyKey) && Objects.equal(this.supportingLinkKey, that.supportingLinkKey) && Objects.equal(this.sourceTeLinkKey, that.sourceTeLinkKey) && Objects.equal(this.networkLinkKey, that.networkLinkKey) && Objects.equal(this.teData, that.teData);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTeLink) {
        InternalTeLink that = (InternalTeLink) object;
        return Objects.equal(peerTeLinkKey, that.peerTeLinkKey) && Objects.equal(underlayTopologyKey, that.underlayTopologyKey) && Objects.equal(supportingLinkKey, that.supportingLinkKey) && Objects.equal(sourceTeLinkKey, that.sourceTeLinkKey) && Objects.equal(networkLinkKey, that.networkLinkKey) && Objects.equal(teData, that.teData);
    }
    return false;
}
#end_block

#method_before
public List<NetworkLinkKey> supportingLinkIds() {
    return supportingLinkIds;
}
#method_after
public List<NetworkLinkKey> supportingLinkIds() {
    return supportingLinkIds == null ? null : ImmutableList.copyOf(supportingLinkIds);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalNetworkLink) {
        InternalNetworkLink that = (InternalNetworkLink) object;
        return Objects.equal(this.source, that.source) && Objects.equal(this.destination, that.destination) && Objects.equal(this.supportingLinkIds, that.supportingLinkIds) && Objects.equal(this.teLinkKey, that.teLinkKey);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalNetworkLink) {
        InternalNetworkLink that = (InternalNetworkLink) object;
        return Objects.equal(source, that.source) && Objects.equal(destination, that.destination) && Objects.equal(supportingLinkIds, that.supportingLinkIds) && Objects.equal(teLinkKey, that.teLinkKey);
    }
    return false;
}
#end_block

#method_before
public List<NetworkNodeKey> supportingNodeIds() {
    return supportingNodeIds;
}
#method_after
public List<NetworkNodeKey> supportingNodeIds() {
    return supportingNodeIds == null ? null : ImmutableList.copyOf(supportingNodeIds);
}
#end_block

#method_before
public void setSupportingNodeIds(List<NetworkNodeKey> supportingNodeIds) {
    this.supportingNodeIds = supportingNodeIds;
}
#method_after
public void setSupportingNodeIds(List<NetworkNodeKey> supportingNodeIds) {
    this.supportingNodeIds = supportingNodeIds == null ? null : Lists.newArrayList(supportingNodeIds);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalNetworkNode) {
        InternalNetworkNode that = (InternalNetworkNode) object;
        return Objects.equal(this.supportingNodeIds, that.supportingNodeIds) && Objects.equal(this.tpIds, that.tpIds) && Objects.equal(this.teNodeKey, that.teNodeKey);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalNetworkNode) {
        InternalNetworkNode that = (InternalNetworkNode) object;
        return Objects.equal(supportingNodeIds, that.supportingNodeIds) && Objects.equal(tpIds, that.tpIds) && Objects.equal(teNodeKey, that.teNodeKey);
    }
    return false;
}
#end_block

#method_before
@Activate
public void activate() {
    activateBasics();
    appId = coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    executor = newFixedThreadPool(MAX_THREADS, groupedThreads("onos/topo", "build-%d", log));
    cfgService.addListener(cfgLister);
    executor.execute(new TopologyMergerTask());
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    activateBasics();
    appId = coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    executor = newFixedThreadPool(MAX_THREADS, groupedThreads("onos/tetopology", "build-%d", log));
    cfgService.addListener(cfgLister);
    executor.execute(new TopologyMergerTask());
    log.info("Started");
}
#end_block

#method_before
@Override
public void run() {
    try {
        TeTopologyMapEvent event;
        while ((event = mapEventQueue.take()) != null) {
            switch(event.type()) {
                case TE_TOPOLOGY_ADDED:
                case TE_TOPOLOGY_UPDATED:
                    TeTopology teTopology = store.teTopology(event.teTopologyKey());
                    post(new TeTopologyEvent(event.type(), teTopology));
                    if (event.type() == Type.TE_TOPOLOGY_ADDED && teTopology.flags().get(TeTopology.BIT_CUSTOMIZED) && teTopology.flags().get(TeTopology.BIT_LEARNT)) {
                        mergeTopology(teTopology);
                    }
                    break;
                case TE_TOPOLOGY_REMOVED:
                    post(new TeTopologyEvent(Type.TE_TOPOLOGY_REMOVED, new DefaultTeTopology(event.teTopologyKey(), null, null, null, null)));
                    break;
                case TE_NODE_ADDED:
                case TE_NODE_UPDATED:
                    TeNode teNode = store.teNode(event.teNodeKey());
                    post(new TeTopologyEvent(event.type(), new TeNodeEventSubject(event.teNodeKey(), teNode)));
                    if (isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        updateSourceTeNode(mergedTopology.teNodes(), event.teNodeKey().teTopologyKey(), teNode, true);
                    }
                    break;
                case TE_NODE_REMOVED:
                    post(new TeTopologyEvent(Type.TE_NODE_REMOVED, new TeNodeEventSubject(event.teNodeKey(), null)));
                    if (isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        removeSourceTeNode(mergedTopology.teNodes(), event.teNodeKey(), true);
                    }
                    break;
                case TE_LINK_ADDED:
                case TE_LINK_UPDATED:
                    TeLink teLink = store.teLink(event.teLinkKey());
                    post(new TeTopologyEvent(event.type(), new TeLinkEventSubject(event.teLinkKey(), teLink)));
                    if (isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        updateSourceTeLink(mergedTopology.teLinks(), event.teLinkKey().teTopologyKey(), teLink, true);
                    }
                    break;
                case TE_LINK_REMOVED:
                    post(new TeTopologyEvent(Type.TE_LINK_REMOVED, new TeLinkEventSubject(event.teLinkKey(), null)));
                    if (isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        removeSourceTeLink(mergedTopology.teLinks(), event.teLinkKey(), true);
                    }
                    break;
                case NETWORK_ADDED:
                case NETWORK_UPDATED:
                    Network network = store.network(event.networkKey());
                    post(new TeTopologyEvent(event.type(), network));
                    break;
                case NETWORK_REMOVED:
                    post(new TeTopologyEvent(Type.NETWORK_REMOVED, new DefaultNetwork(event.networkKey(), null, null, null, null, false, null)));
                    break;
                case NODE_ADDED:
                case NODE_UPDATED:
                    NetworkNode node = store.networkNode(event.networkNodeKey());
                    post(new TeTopologyEvent(event.type(), new NetworkNodeEventSubject(event.networkNodeKey(), node)));
                    break;
                case NODE_REMOVED:
                    post(new TeTopologyEvent(Type.NODE_REMOVED, new NetworkNodeEventSubject(event.networkNodeKey(), null)));
                    break;
                case LINK_ADDED:
                case LINK_UPDATED:
                    NetworkLink link = store.networkLink(event.networkLinkKey());
                    post(new TeTopologyEvent(event.type(), new NetworkLinkEventSubject(event.networkLinkKey(), link)));
                    break;
                case LINK_REMOVED:
                    post(new TeTopologyEvent(Type.LINK_REMOVED, new NetworkLinkEventSubject(event.networkLinkKey(), null)));
                    break;
                default:
                    break;
            }
        }
    } catch (Exception e) {
        log.warn("Unable to merge topology", e);
    }
}
#method_after
@Override
public void run() {
    try {
        TeTopologyMapEvent event;
        while ((event = mapEventQueue.take()) != null) {
            switch(event.type()) {
                case TE_TOPOLOGY_ADDED:
                case TE_TOPOLOGY_UPDATED:
                    TeTopology teTopology = store.teTopology(event.teTopologyKey());
                    post(new TeTopologyEvent(event.type(), teTopology));
                    if (event.type() == TE_TOPOLOGY_ADDED && teTopology.flags().get(TeTopology.BIT_CUSTOMIZED) && teTopology.flags().get(TeTopology.BIT_LEARNT)) {
                        mergeTopology(teTopology);
                    }
                    break;
                case TE_TOPOLOGY_REMOVED:
                    post(new TeTopologyEvent(TE_TOPOLOGY_REMOVED, new DefaultTeTopology(event.teTopologyKey(), null, null, null, null)));
                    break;
                case TE_NODE_ADDED:
                case TE_NODE_UPDATED:
                    TeNode teNode = store.teNode(event.teNodeKey());
                    post(new TeTopologyEvent(event.type(), new TeNodeEventSubject(event.teNodeKey(), teNode)));
                    if (isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        updateSourceTeNode(mergedTopology.teNodes(), event.teNodeKey().teTopologyKey(), teNode, true);
                    }
                    break;
                case TE_NODE_REMOVED:
                    post(new TeTopologyEvent(TE_NODE_REMOVED, new TeNodeEventSubject(event.teNodeKey(), null)));
                    if (isCustomizedLearnedTopology(event.teNodeKey().teTopologyKey())) {
                        removeSourceTeNode(mergedTopology.teNodes(), event.teNodeKey(), true);
                    }
                    break;
                case TE_LINK_ADDED:
                case TE_LINK_UPDATED:
                    TeLink teLink = store.teLink(event.teLinkKey());
                    post(new TeTopologyEvent(event.type(), new TeLinkEventSubject(event.teLinkKey(), teLink)));
                    if (isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        Map<TeLinkTpKey, TeLink> teLinks = Maps.newHashMap(mergedTopology.teLinks());
                        updateSourceTeLink(teLinks, event.teLinkKey().teTopologyKey(), teLink, true);
                        updateMergedTopology(mergedTopology.teNodes(), teLinks);
                    }
                    break;
                case TE_LINK_REMOVED:
                    post(new TeTopologyEvent(TE_LINK_REMOVED, new TeLinkEventSubject(event.teLinkKey(), null)));
                    if (isCustomizedLearnedTopology(event.teLinkKey().teTopologyKey())) {
                        Map<TeLinkTpKey, TeLink> teLinks = Maps.newHashMap(mergedTopology.teLinks());
                        removeSourceTeLink(teLinks, event.teLinkKey(), true);
                        updateMergedTopology(mergedTopology.teNodes(), teLinks);
                    }
                    break;
                case NETWORK_ADDED:
                case NETWORK_UPDATED:
                    Network network = store.network(event.networkKey());
                    post(new TeTopologyEvent(event.type(), network));
                    break;
                case NETWORK_REMOVED:
                    post(new TeTopologyEvent(NETWORK_REMOVED, new DefaultNetwork(event.networkKey(), null, null, null, null, false, null)));
                    break;
                case NODE_ADDED:
                case NODE_UPDATED:
                    NetworkNode node = store.networkNode(event.networkNodeKey());
                    post(new TeTopologyEvent(event.type(), new NetworkNodeEventSubject(event.networkNodeKey(), node)));
                    break;
                case NODE_REMOVED:
                    post(new TeTopologyEvent(NODE_REMOVED, new NetworkNodeEventSubject(event.networkNodeKey(), null)));
                    break;
                case LINK_ADDED:
                case LINK_UPDATED:
                    NetworkLink link = store.networkLink(event.networkLinkKey());
                    post(new TeTopologyEvent(event.type(), new NetworkLinkEventSubject(event.networkLinkKey(), link)));
                    break;
                case LINK_REMOVED:
                    post(new TeTopologyEvent(LINK_REMOVED, new NetworkLinkEventSubject(event.networkLinkKey(), null)));
                    break;
                default:
                    break;
            }
        }
    } catch (InterruptedException e) {
        log.warn("TopologyMergerTask is interrupted");
    } catch (Exception e) {
        log.warn("Unable to merge topology", e);
    }
}
#end_block

#method_before
private void removeSourceTeNode(Map<Long, TeNode> teNodes, TeNodeKey srcNodeKey, boolean postEvent) {
    Long mergedTeNodeId = sourceNewTeNodeIdMap.remove(srcNodeKey);
    if (mergedTeNodeId == null) {
        return;
    }
    if (teNodes.remove(mergedTeNodeId) != null && postEvent) {
        post(new TeTopologyEvent(Type.TE_NODE_REMOVED, new TeNodeEventSubject(new TeNodeKey(mergedTopologyKey, mergedTeNodeId), null)));
    }
}
#method_after
private void removeSourceTeNode(Map<Long, TeNode> teNodes, TeNodeKey srcNodeKey, boolean postEvent) {
    Long mergedTeNodeId = sourceNewTeNodeIdMap.remove(srcNodeKey);
    if (mergedTeNodeId == null) {
        return;
    }
    if (teNodes.remove(mergedTeNodeId) != null && postEvent) {
        post(new TeTopologyEvent(TE_NODE_REMOVED, new TeNodeEventSubject(new TeNodeKey(mergedTopologyKey, mergedTeNodeId), null)));
    }
}
#end_block

#method_before
private void updateSourceTeNode(Map<Long, TeNode> teNodes, TeTopologyKey srcTopoKey, TeNode srcNode, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcNode.teNodeId());
    Long mergedTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeId);
    boolean addNode = false;
    if (mergedTeNodeId == null) {
        // New node
        addNode = true;
        mergedTeNodeId = nextTeNodeId;
        nextTeNodeId++;
        if (nextTeNodeId >= teNodeIpEnd.toInt()) {
            nextTeNodeId = teNodeIpStart.toInt();
            log.warn("TE node Id is wrapped back");
        }
        sourceNewTeNodeIdMap.put(sourceTeNodeId, mergedTeNodeId);
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No supporting
    TeNodeKey supportTeNodeId = null;
    CommonNodeData common = new CommonNodeData(srcNode.name(), srcNode.adminStatus(), srcNode.opStatus(), // No change
    srcNode.flags());
    Map<Long, ConnectivityMatrix> connMatrices = srcNode.connectivityMatrices();
    // No change
    List<Long> teLinkIds = srcNode.teLinkIds();
    Map<Long, TunnelTerminationPoint> ttps = srcNode.tunnelTerminationPoints();
    // No change
    List<Long> teTpIds = srcNode.teTerminationPointIds();
    DefaultTeNode newNode = new DefaultTeNode(mergedTeNodeId, underlayTopologyId, supportTeNodeId, sourceTeNodeId, common, connMatrices, teLinkIds, ttps, teTpIds);
    teNodes.put(mergedTeNodeId, newNode);
    if (postEvent) {
        // Post event for the TE node in the merged topology
        Type type = addNode ? Type.TE_NODE_ADDED : Type.TE_NODE_UPDATED;
        TeNodeKey globalKey = new TeNodeKey(mergedTopologyKey, mergedTeNodeId);
        post(new TeTopologyEvent(type, new TeNodeEventSubject(globalKey, newNode)));
    }
}
#method_after
private void updateSourceTeNode(Map<Long, TeNode> teNodes, TeTopologyKey srcTopoKey, TeNode srcNode, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcNode.teNodeId());
    Long mergedTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeId);
    boolean addNode = false;
    if (mergedTeNodeId == null) {
        // New node
        addNode = true;
        mergedTeNodeId = nextTeNodeId;
        nextTeNodeId++;
        if (nextTeNodeId >= teNodeIpEnd.toInt()) {
            nextTeNodeId = teNodeIpStart.toInt();
            log.warn("TE node Id is wrapped back");
        }
        sourceNewTeNodeIdMap.put(sourceTeNodeId, mergedTeNodeId);
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No supporting
    TeNodeKey supportTeNodeId = null;
    CommonNodeData common = new CommonNodeData(srcNode.name(), srcNode.adminStatus(), srcNode.opStatus(), // No change
    srcNode.flags());
    Map<Long, ConnectivityMatrix> connMatrices = srcNode.connectivityMatrices();
    // No change
    List<Long> teLinkIds = srcNode.teLinkIds();
    Map<Long, TunnelTerminationPoint> ttps = srcNode.tunnelTerminationPoints();
    // No change
    List<Long> teTpIds = srcNode.teTerminationPointIds();
    DefaultTeNode newNode = new DefaultTeNode(mergedTeNodeId, underlayTopologyId, supportTeNodeId, sourceTeNodeId, common, connMatrices, teLinkIds, ttps, teTpIds);
    teNodes.put(mergedTeNodeId, newNode);
    if (postEvent) {
        // Post event for the TE node in the merged topology
        TeNodeKey globalKey = new TeNodeKey(mergedTopologyKey, mergedTeNodeId);
        post(new TeTopologyEvent(addNode ? TE_NODE_ADDED : TE_NODE_UPDATED, new TeNodeEventSubject(globalKey, newNode)));
        post(new TeTopologyEvent(addNode ? NODE_ADDED : NODE_UPDATED, new NetworkNodeEventSubject(TeMgrUtil.networkNodeKey(globalKey), TeMgrUtil.nodeBuilder(KeyId.keyId(Long.toString(newNode.teNodeId())), newNode))));
    }
}
#end_block

#method_before
private void mergeNodes(Map<Long, TeNode> nodes, TeTopology topology) {
    if (!MapUtils.isEmpty(topology.teNodes())) {
        for (Map.Entry<Long, TeNode> entry : topology.teNodes().entrySet()) {
            updateSourceTeNode(nodes, topology.teTopologyId(), entry.getValue(), false);
        }
    }
}
#method_after
private void mergeNodes(Map<Long, TeNode> nodes, TeTopology topology) {
    if (!MapUtils.isEmpty(topology.teNodes())) {
        for (Map.Entry<Long, TeNode> entry : topology.teNodes().entrySet()) {
            updateSourceTeNode(nodes, topology.teTopologyId(), entry.getValue(), mergedTopology != null);
        }
    }
}
#end_block

#method_before
private void removeSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeLinkTpGlobalKey teLinkKey, boolean postEvent) {
    TeNodeKey sourceTeNodeKey = teLinkKey.teNodeKey();
    Long newTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeKey);
    if (newTeNodeId == null) {
        return;
    }
    TeLinkTpKey newLinkKey = new TeLinkTpKey(newTeNodeId, teLinkKey.teLinkTpId());
    TeLink teLink = teLinks.remove(newLinkKey);
    if (teLink == null) {
        return;
    }
    // Post event
    if (postEvent) {
        post(new TeTopologyEvent(Type.TE_LINK_REMOVED, new TeLinkEventSubject(new TeLinkTpGlobalKey(mergedTopologyKey, newLinkKey), null)));
    }
    if (teLink.externalLink() != null && teLink.externalLink().plugId() != null) {
        // Update the LinkKeyPair in externalLinkMap
        LinkKeyPair pair = externalLinkMap.get(teLink.externalLink().plugId());
        if (pair != null && pair.firstKey() != null && pair.firstKey().equals(newLinkKey)) {
            pair.setFirstKey(null);
        } else if (pair != null && pair.secondKey() != null && pair.secondKey().equals(newLinkKey)) {
            pair.setSecondKey(null);
        }
        if (pair != null && pair.firstKey() == null && pair.secondKey() == null) {
            externalLinkMap.remove(teLink.externalLink().plugId());
        }
    }
    TeLinkTpKey peerTeLinkKey = teLink.peerTeLinkKey();
    if (peerTeLinkKey != null) {
        // Update peerLink's peerTeLinkKey to null
        TeLink peerLink = teLinks.get(peerTeLinkKey);
        if (peerLink == null) {
            return;
        }
        TeLink newPeerLink = updateTeLink(peerTeLinkKey, null, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
        teLinks.put(peerTeLinkKey, newPeerLink);
        if (postEvent) {
            post(new TeTopologyEvent(Type.TE_LINK_UPDATED, new TeLinkEventSubject(new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey), newPeerLink)));
        }
    }
}
#method_after
private void removeSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeLinkTpGlobalKey teLinkKey, boolean postEvent) {
    TeNodeKey sourceTeNodeKey = teLinkKey.teNodeKey();
    Long newTeNodeId = sourceNewTeNodeIdMap.get(sourceTeNodeKey);
    if (newTeNodeId == null) {
        return;
    }
    TeLinkTpKey newLinkKey = new TeLinkTpKey(newTeNodeId, teLinkKey.teLinkTpId());
    TeLink teLink = teLinks.remove(newLinkKey);
    if (teLink == null) {
        return;
    }
    // Post event
    if (postEvent) {
        post(new TeTopologyEvent(TE_LINK_REMOVED, new TeLinkEventSubject(new TeLinkTpGlobalKey(mergedTopologyKey, newLinkKey), null)));
    }
    if (teLink.externalLink() != null && teLink.externalLink().plugId() != null) {
        // Update the LinkKeyPair in externalLinkMap
        LinkKeyPair pair = externalLinkMap.get(teLink.externalLink().plugId());
        if (pair != null && pair.firstKey() != null && pair.firstKey().equals(newLinkKey)) {
            pair.setFirstKey(null);
        } else if (pair != null && pair.secondKey() != null && pair.secondKey().equals(newLinkKey)) {
            pair.setSecondKey(null);
        }
        if (pair != null && pair.firstKey() == null && pair.secondKey() == null) {
            externalLinkMap.remove(teLink.externalLink().plugId());
        }
    }
    TeLinkTpKey peerTeLinkKey = teLink.peerTeLinkKey();
    if (peerTeLinkKey != null) {
        // Update peerLink's peerTeLinkKey to null
        TeLink peerLink = teLinks.get(peerTeLinkKey);
        if (peerLink == null) {
            return;
        }
        TeLink newPeerLink = updateTeLink(peerTeLinkKey, null, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
        teLinks.put(peerTeLinkKey, newPeerLink);
        if (postEvent) {
            post(new TeTopologyEvent(TE_LINK_UPDATED, new TeLinkEventSubject(new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey), newPeerLink)));
        }
    }
}
#end_block

#method_before
private void updateSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeTopologyKey srcTopoKey, TeLink srcLink, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcLink.teLinkKey().teNodeId());
    TeLinkTpKey newKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourceTeNodeId), srcLink.teLinkKey().teLinkTpId());
    TeLinkTpKey peerTeLinkKey = null;
    if (srcLink.peerTeLinkKey() != null) {
        TeNodeKey sourcePeerNode = new TeNodeKey(srcTopoKey, srcLink.peerTeLinkKey().teNodeId());
        peerTeLinkKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourcePeerNode), srcLink.peerTeLinkKey().teLinkTpId());
    }
    if (srcLink.externalLink() != null && srcLink.externalLink().plugId() != null) {
        // externalLinkKey doesn't have topology Id.
        // using plugId for now
        LinkKeyPair pair = externalLinkMap.get(srcLink.externalLink().plugId());
        if (pair != null) {
            if (pair.firstKey() == null) {
                peerTeLinkKey = pair.secondKey;
                pair.setFirstKey(newKey);
            } else {
                peerTeLinkKey = pair.firstKey;
                pair.setSecondKey(newKey);
            }
            TeLink peerLink = teLinks.get(peerTeLinkKey);
            if (peerLink != null) {
                // Update peer Link with local link key
                TeLink newPeerLink = updateTeLink(peerTeLinkKey, newKey, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
                teLinks.put(peerTeLinkKey, newPeerLink);
                if (postEvent) {
                    post(new TeTopologyEvent(Type.TE_LINK_UPDATED, new TeLinkEventSubject(new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey), newPeerLink)));
                }
            }
        } else {
            // Store it in the map
            externalLinkMap.put(srcLink.externalLink().plugId(), new LinkKeyPair(newKey));
        }
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No support
    TeLinkTpGlobalKey supportTeLinkId = null;
    // Source link for the new updated link
    TeLinkTpGlobalKey sourceTeLinkId = new TeLinkTpGlobalKey(srcTopoKey, srcLink.teLinkKey());
    TeLink updatedLink = updateTeLink(newKey, peerTeLinkKey, underlayTopologyId, supportTeLinkId, sourceTeLinkId, srcLink.externalLink(), srcLink);
    TeLinkTpGlobalKey newGlobalKey = new TeLinkTpGlobalKey(mergedTopologyKey, newKey);
    boolean newLink = teLinks.get(newGlobalKey) == null ? true : false;
    teLinks.put(newKey, updatedLink);
    // Post event
    if (postEvent) {
        Type type = newLink ? Type.TE_LINK_ADDED : Type.TE_LINK_UPDATED;
        post(new TeTopologyEvent(type, new TeLinkEventSubject(newGlobalKey, updatedLink)));
    }
}
#method_after
private void updateSourceTeLink(Map<TeLinkTpKey, TeLink> teLinks, TeTopologyKey srcTopoKey, TeLink srcLink, boolean postEvent) {
    TeNodeKey sourceTeNodeId = new TeNodeKey(srcTopoKey, srcLink.teLinkKey().teNodeId());
    TeLinkTpKey newKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourceTeNodeId), srcLink.teLinkKey().teLinkTpId());
    TeLinkTpKey peerTeLinkKey = null;
    if (srcLink.peerTeLinkKey() != null) {
        TeNodeKey sourcePeerNode = new TeNodeKey(srcTopoKey, srcLink.peerTeLinkKey().teNodeId());
        peerTeLinkKey = new TeLinkTpKey(sourceNewTeNodeIdMap.get(sourcePeerNode), srcLink.peerTeLinkKey().teLinkTpId());
    }
    if (srcLink.externalLink() != null && srcLink.externalLink().plugId() != null) {
        // externalLinkKey doesn't have topology Id.
        // using plugId for now
        LinkKeyPair pair = externalLinkMap.get(srcLink.externalLink().plugId());
        if (pair != null) {
            if (pair.firstKey() == null) {
                peerTeLinkKey = pair.secondKey;
                pair.setFirstKey(newKey);
            } else {
                peerTeLinkKey = pair.firstKey;
                pair.setSecondKey(newKey);
            }
            TeLink peerLink = teLinks.get(peerTeLinkKey);
            if (peerLink != null) {
                // Update peer Link with local link key
                TeLink newPeerLink = updateTeLink(peerTeLinkKey, newKey, peerLink.underlayTeTopologyId(), peerLink.supportingTeLinkId(), peerLink.sourceTeLinkId(), peerLink.externalLink(), peerLink);
                teLinks.put(peerTeLinkKey, newPeerLink);
                if (postEvent) {
                    post(new TeTopologyEvent(TE_LINK_UPDATED, new TeLinkEventSubject(new TeLinkTpGlobalKey(mergedTopologyKey, peerTeLinkKey), newPeerLink)));
                }
            }
        } else {
            // Store it in the map
            externalLinkMap.put(srcLink.externalLink().plugId(), new LinkKeyPair(newKey));
        }
    }
    // No underlay
    TeTopologyKey underlayTopologyId = null;
    // No support
    TeLinkTpGlobalKey supportTeLinkId = null;
    // Source link for the new updated link
    TeLinkTpGlobalKey sourceTeLinkId = new TeLinkTpGlobalKey(srcTopoKey, srcLink.teLinkKey());
    TeLink updatedLink = updateTeLink(newKey, peerTeLinkKey, underlayTopologyId, supportTeLinkId, sourceTeLinkId, srcLink.externalLink(), srcLink);
    TeLinkTpGlobalKey newGlobalKey = new TeLinkTpGlobalKey(mergedTopologyKey, newKey);
    boolean newLink = teLinks.get(newGlobalKey) == null ? true : false;
    teLinks.put(newKey, updatedLink);
    if (postEvent) {
        // Post event
        post(new TeTopologyEvent(newLink ? TE_LINK_ADDED : TE_LINK_UPDATED, new TeLinkEventSubject(newGlobalKey, updatedLink)));
        post(new TeTopologyEvent(newLink ? LINK_ADDED : LINK_UPDATED, new NetworkLinkEventSubject(TeMgrUtil.networkLinkKey(newGlobalKey), TeMgrUtil.linkBuilder(TeMgrUtil.toNetworkLinkId(updatedLink.teLinkKey()), updatedLink))));
    }
}
#end_block

#method_before
private void mergeLinks(Map<TeLinkTpKey, TeLink> teLinks, TeTopology topology) {
    if (!MapUtils.isEmpty(topology.teLinks())) {
        for (Map.Entry<TeLinkTpKey, TeLink> entry : topology.teLinks().entrySet()) {
            TeLink srcLink = entry.getValue();
            updateSourceTeLink(teLinks, topology.teTopologyId(), srcLink, false);
        }
    }
}
#method_after
private void mergeLinks(Map<TeLinkTpKey, TeLink> teLinks, TeTopology topology) {
    if (!MapUtils.isEmpty(topology.teLinks())) {
        for (Map.Entry<TeLinkTpKey, TeLink> entry : topology.teLinks().entrySet()) {
            TeLink srcLink = entry.getValue();
            updateSourceTeLink(teLinks, topology.teTopologyId(), srcLink, mergedTopology != null);
        }
    }
}
#end_block

#method_before
private void mergeTopology(TeTopology topology) {
    boolean newTopology = mergedTopology == null;
    mergedTopologyKey = newTopology ? new TeTopologyKey(providerId, DEFAULT_CLIENT_ID, store.nextTeTopologyId()) : mergedTopology.teTopologyId();
    Map<Long, TeNode> teNodes = newTopology || mergedTopology.teNodes() == null ? Maps.newConcurrentMap() : mergedTopology.teNodes();
    mergeNodes(teNodes, topology);
    Map<TeLinkTpKey, TeLink> teLinks = newTopology || mergedTopology.teLinks() == null ? Maps.newConcurrentMap() : mergedTopology.teLinks();
    mergeLinks(teLinks, topology);
    BitSet flags = mergedTopology == null ? new BitSet(TeConstants.FLAG_MAX_BITS) : mergedTopology.flags();
    flags.set(TeTopology.BIT_MERGED);
    CommonTopologyData commonData = new CommonTopologyData(newTopology ? TeMgrUtil.toNetworkId(mergedTopologyKey) : mergedTopology.networkId(), OptimizationType.NOT_OPTIMIZED, flags, DeviceId.deviceId("localHost"));
    if (newTopology) {
        mergedTopology = new DefaultTeTopology(mergedTopologyKey, teNodes, teLinks, Long.toString(mergedTopologyKey.topologyId()), commonData);
    }
    log.info("mergedTopology {}", mergedTopology);
    log.info("Nodes# {}, Links# {}", mergedTopology.teNodes().size(), mergedTopology.teLinks().size());
    // Post events for the merged network topology;
    TeTopologyEvent.Type teType = newTopology ? TeTopologyEvent.Type.TE_TOPOLOGY_ADDED : TeTopologyEvent.Type.TE_TOPOLOGY_UPDATED;
    post(new TeTopologyEvent(teType, mergedTopology));
    TeTopologyEvent.Type networkType = newTopology ? TeTopologyEvent.Type.NETWORK_ADDED : TeTopologyEvent.Type.NETWORK_UPDATED;
    mergedNetwork = TeMgrUtil.networkBuilder(mergedTopology);
    post(new TeTopologyEvent(networkType, mergedNetwork));
}
#method_after
private void mergeTopology(TeTopology topology) {
    boolean newTopology = mergedTopology == null;
    mergedTopologyKey = newTopology ? new TeTopologyKey(providerId, DEFAULT_CLIENT_ID, store.nextTeTopologyId()) : mergedTopology.teTopologyId();
    Map<Long, TeNode> teNodes = newTopology || mergedTopology.teNodes() == null ? Maps.newHashMap() : Maps.newHashMap(mergedTopology.teNodes());
    mergeNodes(teNodes, topology);
    Map<TeLinkTpKey, TeLink> teLinks = newTopology || mergedTopology.teLinks() == null ? Maps.newHashMap() : Maps.newHashMap(mergedTopology.teLinks());
    mergeLinks(teLinks, topology);
    updateMergedTopology(teNodes, teLinks);
    log.info("mergedTopology {}", mergedTopology);
    if (newTopology) {
        // Post events for the merged network topology;
        post(new TeTopologyEvent(TE_TOPOLOGY_ADDED, mergedTopology));
        post(new TeTopologyEvent(NETWORK_ADDED, mergedNetwork));
    }
}
#end_block

#method_before
@Override
public TeTopologies teTopologies() {
    TeTopologies teTopologies = store.teTopologies();
    if (mergedTopology != null) {
        teTopologies.teTopologies().put(mergedTopology.teTopologyId(), mergedTopology);
    }
    return store.teTopologies();
}
#method_after
@Override
public TeTopologies teTopologies() {
    Map<TeTopologyKey, TeTopology> map;
    if (MapUtils.isNotEmpty(store.teTopologies().teTopologies())) {
        map = Maps.newHashMap(store.teTopologies().teTopologies());
    } else {
        map = Maps.newHashMap();
    }
    if (mergedTopology != null) {
        map.put(mergedTopologyKey, mergedTopology);
    }
    return new DefaultTeTopologies(store.teTopologies().name(), map);
}
#end_block

#method_before
@Override
public TeTopology teTopology(TeTopologyKey topologyId) {
    if (mergedTopology != null && topologyId.equals(mergedTopology.teTopologyId())) {
        return mergedTopology;
    }
    return store.teTopology(topologyId);
}
#method_after
@Override
public TeTopology teTopology(TeTopologyKey topologyId) {
    if (mergedTopology != null && topologyId.equals(mergedTopologyKey)) {
        return mergedTopology;
    }
    return store.teTopology(topologyId);
}
#end_block

#method_before
@Override
public Networks networks() {
    List<Network> networks = store.networks();
    if (mergedNetwork != null) {
        networks.add(mergedNetwork);
    }
    return new DefaultNetworks(networks);
}
#method_after
@Override
public Networks networks() {
    List<Network> networks;
    if (CollectionUtils.isNotEmpty(store.networks())) {
        networks = Lists.newArrayList(store.networks());
    } else {
        networks = Lists.newArrayList();
    }
    if (mergedNetwork != null) {
        networks.add(mergedNetwork);
    }
    return new DefaultNetworks(networks);
}
#end_block

#method_before
@Override
public TeNode teNode(TeNodeKey nodeId) {
    return store.teNode(nodeId);
}
#method_after
@Override
public TeNode teNode(TeNodeKey nodeId) {
    if (nodeId.teTopologyKey().equals(mergedTopologyKey)) {
        return mergedTopology.teNode(nodeId.teNodeId());
    }
    return store.teNode(nodeId);
}
#end_block

#method_before
@Override
public TeLink teLink(TeLinkTpGlobalKey linkId) {
    return store.teLink(linkId);
}
#method_after
@Override
public TeLink teLink(TeLinkTpGlobalKey linkId) {
    if (linkId.teTopologyKey().equals(mergedTopologyKey)) {
        return mergedTopology.teLink(linkId.teLinkTpKey());
    }
    return store.teLink(linkId);
}
#end_block

#method_before
@Override
public TunnelTerminationPoint tunnelTerminationPoint(TtpKey ttpId) {
    return store.tunnelTerminationPoint(ttpId);
}
#method_after
@Override
public TunnelTerminationPoint tunnelTerminationPoint(TtpKey ttpId) {
    if (ttpId.teTopologyKey().equals(mergedTopologyKey)) {
        return mergedTopology.teNode(ttpId.teNodeId()).tunnelTerminationPoint(ttpId.ttpId());
    }
    return store.tunnelTerminationPoint(ttpId);
}
#end_block

#method_before
public List<TerminationPointKey> supportingTpIds() {
    return supportingTpIds;
}
#method_after
public List<TerminationPointKey> supportingTpIds() {
    return supportingTpIds == null ? null : ImmutableList.copyOf(supportingTpIds);
}
#end_block

#method_before
public void setSupportingTpIds(List<TerminationPointKey> supportingTpIds) {
    this.supportingTpIds = supportingTpIds;
}
#method_after
public void setSupportingTpIds(List<TerminationPointKey> supportingTpIds) {
    this.supportingTpIds = supportingTpIds == null ? null : Lists.newArrayList(supportingTpIds);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTerminationPoint) {
        InternalTerminationPoint that = (InternalTerminationPoint) object;
        return Objects.equal(this.supportingTpIds, that.supportingTpIds) && Objects.equal(this.teTpKey, that.teTpKey);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTerminationPoint) {
        InternalTerminationPoint that = (InternalTerminationPoint) object;
        return Objects.equal(supportingTpIds, that.supportingTpIds) && Objects.equal(teTpKey, that.teTpKey);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTeTopology) {
        InternalTeTopology that = (InternalTeTopology) object;
        return Objects.equal(this.teTopologyId, that.teTopologyId) && Objects.equal(this.teNodeKeys, that.teNodeKeys) && Objects.equal(this.teLinkKeys, that.teLinkKeys) && Objects.equal(this.topologyData, that.topologyData);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTeTopology) {
        InternalTeTopology that = (InternalTeTopology) object;
        return Objects.equal(teTopologyId, that.teTopologyId) && Objects.equal(teNodeKeys, that.teNodeKeys) && Objects.equal(teLinkKeys, that.teLinkKeys) && Objects.equal(topologyData, that.topologyData);
    }
    return false;
}
#end_block

#method_before
@Override
public void event(MapEvent<TeTopologyKey, InternalTeTopology> event) {
    TeTopologyEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            type = TeTopologyEvent.Type.TE_TOPOLOGY_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate()) {
                // Masked by the child events (e.g. Removal)
                break;
            }
            type = TeTopologyEvent.Type.TE_TOPOLOGY_UPDATED;
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.TE_TOPOLOGY_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setTeTopologyKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#method_after
@Override
public void event(MapEvent<TeTopologyKey, InternalTeTopology> event) {
    Type type = null;
    switch(event.type()) {
        case INSERT:
            type = TE_TOPOLOGY_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate()) {
                // Masked by the child events (e.g. Removal)
                break;
            }
            type = TE_TOPOLOGY_UPDATED;
            break;
        case REMOVE:
            type = TE_TOPOLOGY_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setTeTopologyKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<KeyId, InternalNetwork> event) {
    TeTopologyEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            type = TeTopologyEvent.Type.NETWORK_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate()) {
                // Masked by the child events (e.g. Removal)
                break;
            }
            type = TeTopologyEvent.Type.NETWORK_UPDATED;
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.NETWORK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setNetworkKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#method_after
@Override
public void event(MapEvent<KeyId, InternalNetwork> event) {
    Type type = null;
    switch(event.type()) {
        case INSERT:
            type = NETWORK_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate()) {
                // Masked by the child events (e.g. Removal)
                break;
            }
            type = NETWORK_UPDATED;
            break;
        case REMOVE:
            type = NETWORK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setNetworkKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<TeNodeKey, InternalTeNode> event) {
    // Event should be ignored when the topology is not there.
    if (teTopologyMap.get(event.key().teTopologyKey()) == null) {
        return;
    }
    TeTopologyEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = TeTopologyEvent.Type.TE_NODE_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate() || event.newValue().value().parentUpdate()) {
                // Masked by the child event (e.g. Removal) or parent event
                break;
            }
            type = TeTopologyEvent.Type.TE_NODE_UPDATED;
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.TE_NODE_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setTeNodeKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#method_after
@Override
public void event(MapEvent<TeNodeKey, InternalTeNode> event) {
    // Event should be ignored when the topology is not there.
    if (teTopologyMap.get(event.key().teTopologyKey()) == null) {
        return;
    }
    Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = TE_NODE_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate() || event.newValue().value().parentUpdate()) {
                // Masked by the child event (e.g. Removal) or parent event
                break;
            }
            type = TE_NODE_UPDATED;
            break;
        case REMOVE:
            type = TE_NODE_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setTeNodeKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<NetworkNodeKey, InternalNetworkNode> event) {
    // Event should be ignored when the network is not there.
    if (networkMap.get(event.key().networkId()) == null) {
        return;
    }
    TeTopologyEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = TeTopologyEvent.Type.NODE_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate() || event.newValue().value().parentUpdate()) {
                // Masked by the child event (e.g. Removal) or parent event
                break;
            }
            type = TeTopologyEvent.Type.NODE_UPDATED;
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.NODE_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setNetworkNodeKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#method_after
@Override
public void event(MapEvent<NetworkNodeKey, InternalNetworkNode> event) {
    // Event should be ignored when the network is not there.
    if (networkMap.get(event.key().networkId()) == null) {
        return;
    }
    Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = NODE_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().childUpdate() || event.newValue().value().parentUpdate()) {
                // Masked by the child event (e.g. Removal) or parent event
                break;
            }
            type = NODE_UPDATED;
            break;
        case REMOVE:
            type = NODE_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setNetworkNodeKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<TeLinkTpGlobalKey, InternalTeLink> event) {
    // Event should be ignored when the topology or locol node is not there.
    if (teTopologyMap.get(event.key().teTopologyKey()) == null || teNodeMap.get(event.key().teNodeKey()) == null) {
        return;
    }
    TeTopologyEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = TeTopologyEvent.Type.TE_LINK_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().parentUpdate()) {
                // Masked by parent event
                break;
            }
            type = TeTopologyEvent.Type.TE_LINK_UPDATED;
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.TE_LINK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setTeLinkKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#method_after
@Override
public void event(MapEvent<TeLinkTpGlobalKey, InternalTeLink> event) {
    // Event should be ignored when the topology or locol node is not there.
    if (teTopologyMap.get(event.key().teTopologyKey()) == null || teNodeMap.get(event.key().teNodeKey()) == null) {
        return;
    }
    Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = TE_LINK_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().parentUpdate()) {
                // Masked by parent event
                break;
            }
            type = TE_LINK_UPDATED;
            break;
        case REMOVE:
            type = TE_LINK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setTeLinkKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#end_block

#method_before
@Override
public void event(MapEvent<NetworkLinkKey, InternalNetworkLink> event) {
    // Event should be ignored when the network is not there.
    if (networkMap.get(event.key().networkId()) == null) {
        return;
    }
    TeTopologyEvent.Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = TeTopologyEvent.Type.LINK_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the child event (e.g. Removal) or parent event
                break;
            }
            type = TeTopologyEvent.Type.LINK_UPDATED;
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.LINK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setNetworkLinkKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#method_after
@Override
public void event(MapEvent<NetworkLinkKey, InternalNetworkLink> event) {
    // Event should be ignored when the network is not there.
    if (networkMap.get(event.key().networkId()) == null) {
        return;
    }
    Type type = null;
    switch(event.type()) {
        case INSERT:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the parent event (e.g. Add)
                break;
            }
            type = LINK_ADDED;
            break;
        case UPDATE:
            if (event.newValue().value().parentUpdate()) {
                // Masked by the child event (e.g. Removal) or parent event
                break;
            }
            type = LINK_UPDATED;
            break;
        case REMOVE:
            type = LINK_REMOVED;
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    if (type != null) {
        TeTopologyMapEvent mapEvent = new TeTopologyMapEvent(type);
        mapEvent.setNetworkLinkKey(event.key());
        try {
            mapEventQueue.put(mapEvent);
        } catch (InterruptedException e) {
            log.warn("Unable to queue event {} ", mapEvent, e);
        }
    }
}
#end_block

#method_before
@Override
public TeTopologies teTopologies() {
    Map<TeTopologyKey, TeTopology> teTopologies = Maps.newConcurrentMap();
    if (!MapUtils.isEmpty(teTopologyMap)) {
        for (TeTopologyKey key : teTopologyMap.keySet()) {
            teTopologies.put(key, teTopology(key));
        }
    }
    return new DefaultTeTopologies(STORE_NAME, teTopologies);
}
#method_after
@Override
public TeTopologies teTopologies() {
    Map<TeTopologyKey, TeTopology> teTopologies = Maps.newHashMap();
    if (MapUtils.isNotEmpty(teTopologyMap)) {
        for (TeTopologyKey key : teTopologyMap.keySet()) {
            teTopologies.put(key, teTopology(key));
        }
    }
    return new DefaultTeTopologies(STORE_NAME, teTopologies);
}
#end_block

#method_before
private TeTopology teTopology(TeTopologyKey topologyId, InternalTeTopology intTopology) {
    if (intTopology == null) {
        return null;
    }
    Map<Long, TeNode> teNodes = null;
    if (!CollectionUtils.isEmpty(intTopology.teNodeKeys())) {
        teNodes = Maps.newConcurrentMap();
        for (TeNodeKey key : intTopology.teNodeKeys()) {
            teNodes.put(key.teNodeId(), teNode(key));
        }
    }
    Map<TeLinkTpKey, TeLink> teLinks = null;
    if (!CollectionUtils.isEmpty(intTopology.teLinkKeys())) {
        teLinks = Maps.newConcurrentMap();
        for (TeLinkTpGlobalKey key : intTopology.teLinkKeys()) {
            teLinks.put(key.teLinkTpKey(), teLink(key));
        }
    }
    return new DefaultTeTopology(topologyId, teNodes, teLinks, intTopology.teTopologyId(), intTopology.topologyData());
}
#method_after
private TeTopology teTopology(TeTopologyKey topologyId, InternalTeTopology intTopology) {
    if (intTopology == null) {
        return null;
    }
    Map<Long, TeNode> teNodes = null;
    if (CollectionUtils.isNotEmpty(intTopology.teNodeKeys())) {
        teNodes = Maps.newHashMap();
        for (TeNodeKey key : intTopology.teNodeKeys()) {
            teNodes.put(key.teNodeId(), teNode(key));
        }
    }
    Map<TeLinkTpKey, TeLink> teLinks = null;
    if (CollectionUtils.isNotEmpty(intTopology.teLinkKeys())) {
        teLinks = Maps.newHashMap();
        for (TeLinkTpGlobalKey key : intTopology.teLinkKeys()) {
            teLinks.put(key.teLinkTpKey(), teLink(key));
        }
    }
    return new DefaultTeTopology(topologyId, teNodes, teLinks, intTopology.teTopologyId(), intTopology.topologyData());
}
#end_block

#method_before
private void removeTopologyeMapEntrys(InternalTeTopology curTopology) {
    // Remove TE nodes
    if (!CollectionUtils.isEmpty(curTopology.teNodeKeys())) {
        for (TeNodeKey key : curTopology.teNodeKeys()) {
            removeTeNode(key, true);
        }
    }
    // Remove TE Links
    if (!CollectionUtils.isEmpty(curTopology.teLinkKeys())) {
        for (TeLinkTpGlobalKey key : curTopology.teLinkKeys()) {
            removeTeLink(key, true);
        }
    }
}
#method_after
private void removeTopologyeMapEntrys(InternalTeTopology curTopology) {
    // Remove TE nodes
    if (CollectionUtils.isNotEmpty(curTopology.teNodeKeys())) {
        for (TeNodeKey key : curTopology.teNodeKeys()) {
            removeTeNode(key, true);
        }
    }
    // Remove TE Links
    if (CollectionUtils.isNotEmpty(curTopology.teLinkKeys())) {
        for (TeLinkTpGlobalKey key : curTopology.teLinkKeys()) {
            removeTeLink(key, true);
        }
    }
}
#end_block

#method_before
@Override
public void updateTeTopology(TeTopology teTopology) {
    InternalTeTopology curTopology = teTopologyMap.get(teTopology.teTopologyId());
    if (curTopology != null) {
        // Existing topology update
        // Remove existing map entries first, which should be removed by
        // its own events
        removeTopologyeMapEntrys(curTopology);
    }
    // Update TE nodes
    List<NetworkNodeKey> nodeIds = null;
    if (!MapUtils.isEmpty(teTopology.teNodes())) {
        nodeIds = Lists.newArrayList();
        for (Map.Entry<Long, TeNode> entry : teTopology.teNodes().entrySet()) {
            TeNodeKey teNodeKey = new TeNodeKey(teTopology.teTopologyId(), entry.getKey());
            NetworkNodeKey nodeKey = TeMgrUtil.networkNodeKey(teNodeKey);
            updateTeNode(teNodeKey, entry.getValue(), true, true, nodeKey);
            nodeIds.add(nodeKey);
        }
    }
    // Update TE links
    List<NetworkLinkKey> linkIds = null;
    if (!MapUtils.isEmpty(teTopology.teLinks())) {
        linkIds = Lists.newArrayList();
        for (Map.Entry<TeLinkTpKey, TeLink> entry : teTopology.teLinks().entrySet()) {
            TeLinkTpGlobalKey teLinkKey = new TeLinkTpGlobalKey(teTopology.teTopologyId(), entry.getKey());
            NetworkLinkKey linkKey = TeMgrUtil.networkLinkKey(teLinkKey);
            updateTeLink(teLinkKey, entry.getValue(), true, true, linkKey);
            linkIds.add(linkKey);
        }
    }
    // Finally Update teTopologyMap
    InternalTeTopology newTopology = new InternalTeTopology(teTopology);
    teTopologyMap.put(teTopology.teTopologyId(), newTopology);
    if (curTopology == null) {
        // New topology, update networkMap
        InternalNetwork intNetwork = new InternalNetwork();
        intNetwork.setServerProvided(false);
        intNetwork.setTeTopologyKey(teTopology.teTopologyId());
        intNetwork.setNodeIds(nodeIds);
        intNetwork.setLinkIds(linkIds);
        networkMap.put(teTopology.networkId(), intNetwork);
    }
}
#method_after
@Override
public void updateTeTopology(TeTopology teTopology) {
    InternalTeTopology curTopology = teTopologyMap.get(teTopology.teTopologyId());
    // Update TE nodes
    List<NetworkNodeKey> nodeIds = null;
    if (MapUtils.isNotEmpty(teTopology.teNodes())) {
        nodeIds = Lists.newArrayList();
        for (Map.Entry<Long, TeNode> entry : teTopology.teNodes().entrySet()) {
            TeNodeKey teNodeKey = new TeNodeKey(teTopology.teTopologyId(), entry.getKey());
            NetworkNodeKey nodeKey = TeMgrUtil.networkNodeKey(teNodeKey);
            updateTeNode(teNodeKey, entry.getValue(), true, true, nodeKey);
            nodeIds.add(nodeKey);
        }
    }
    // Update TE links
    List<NetworkLinkKey> linkIds = null;
    if (MapUtils.isNotEmpty(teTopology.teLinks())) {
        linkIds = Lists.newArrayList();
        for (Map.Entry<TeLinkTpKey, TeLink> entry : teTopology.teLinks().entrySet()) {
            TeLinkTpGlobalKey teLinkKey = new TeLinkTpGlobalKey(teTopology.teTopologyId(), entry.getKey());
            NetworkLinkKey linkKey = TeMgrUtil.networkLinkKey(teLinkKey);
            updateTeLink(teLinkKey, entry.getValue(), true, true, linkKey);
            linkIds.add(linkKey);
        }
    }
    // Finally Update teTopologyMap
    InternalTeTopology newTopology = new InternalTeTopology(teTopology);
    teTopologyMap.put(teTopology.teTopologyId(), newTopology);
    if (curTopology == null) {
        // New topology, update networkMap
        InternalNetwork intNetwork = new InternalNetwork();
        intNetwork.setServerProvided(false);
        intNetwork.setTeTopologyKey(teTopology.teTopologyId());
        intNetwork.setNodeIds(nodeIds);
        intNetwork.setLinkIds(linkIds);
        networkMap.put(teTopology.networkId(), intNetwork);
    }
}
#end_block

#method_before
private Network network(KeyId networkId, InternalNetwork curNetwork) {
    if (curNetwork == null) {
        return null;
    }
    List<KeyId> supportingNetworkIds = curNetwork.supportingNetworkIds();
    Map<KeyId, NetworkNode> nodes = null;
    if (!CollectionUtils.isEmpty(curNetwork.nodeIds())) {
        nodes = Maps.newConcurrentMap();
        for (NetworkNodeKey key : curNetwork.nodeIds()) {
            nodes.put(key.nodeId(), networkNode(key));
        }
    }
    Map<KeyId, NetworkLink> links = null;
    if (!CollectionUtils.isEmpty(curNetwork.linkIds())) {
        links = Maps.newConcurrentMap();
        for (NetworkLinkKey key : curNetwork.linkIds()) {
            links.put(key.linkId(), networkLink(key));
        }
    }
    TeTopologyId topologyId = null;
    DeviceId ownerId = null;
    if (curNetwork.teTopologyKey() != null && teTopology(curNetwork.teTopologyKey()) != null) {
        topologyId = new TeTopologyId(curNetwork.teTopologyKey().providerId(), curNetwork.teTopologyKey().clientId(), teTopology(curNetwork.teTopologyKey()).teTopologyIdStringValue());
        ownerId = teTopology(curNetwork.teTopologyKey()).ownerId();
    }
    return new DefaultNetwork(networkId, supportingNetworkIds, nodes, links, topologyId, curNetwork.serverProvided(), ownerId);
}
#method_after
private Network network(KeyId networkId, InternalNetwork curNetwork) {
    if (curNetwork == null) {
        return null;
    }
    List<KeyId> supportingNetworkIds = curNetwork.supportingNetworkIds();
    Map<KeyId, NetworkNode> nodes = null;
    if (CollectionUtils.isNotEmpty(curNetwork.nodeIds())) {
        nodes = Maps.newHashMap();
        for (NetworkNodeKey key : curNetwork.nodeIds()) {
            nodes.put(key.nodeId(), networkNode(key));
        }
    }
    Map<KeyId, NetworkLink> links = null;
    if (CollectionUtils.isNotEmpty(curNetwork.linkIds())) {
        links = Maps.newHashMap();
        for (NetworkLinkKey key : curNetwork.linkIds()) {
            links.put(key.linkId(), networkLink(key));
        }
    }
    TeTopologyId topologyId = null;
    DeviceId ownerId = null;
    if (curNetwork.teTopologyKey() != null && teTopologyMap.get(curNetwork.teTopologyKey()) != null) {
        topologyId = new TeTopologyId(curNetwork.teTopologyKey().providerId(), curNetwork.teTopologyKey().clientId(), teTopologyMap.get(curNetwork.teTopologyKey()).teTopologyId());
        ownerId = teTopologyMap.get(curNetwork.teTopologyKey()).topologyData().ownerId();
    }
    return new DefaultNetwork(networkId, supportingNetworkIds, nodes, links, topologyId, curNetwork.serverProvided(), ownerId);
}
#end_block

#method_before
private void removeNetworkMapEntrys(InternalNetwork curNetwork, boolean teRemove) {
    // Remove TE nodes
    if (!CollectionUtils.isEmpty(curNetwork.nodeIds())) {
        for (NetworkNodeKey key : curNetwork.nodeIds()) {
            removeNetworkNode(key, teRemove);
        }
    }
    // Remove TE Links
    if (!CollectionUtils.isEmpty(curNetwork.linkIds())) {
        for (NetworkLinkKey key : curNetwork.linkIds()) {
            removeNetworkLink(key, teRemove);
        }
    }
}
#method_after
private void removeNetworkMapEntrys(InternalNetwork curNetwork, boolean teRemove) {
    // Remove TE nodes
    if (CollectionUtils.isNotEmpty(curNetwork.nodeIds())) {
        for (NetworkNodeKey key : curNetwork.nodeIds()) {
            removeNetworkNode(key, teRemove);
        }
    }
    // Remove TE Links
    if (CollectionUtils.isNotEmpty(curNetwork.linkIds())) {
        for (NetworkLinkKey key : curNetwork.linkIds()) {
            removeNetworkLink(key, teRemove);
        }
    }
}
#end_block

#method_before
@Override
public void updateNetwork(Network network) {
    InternalNetwork curNetwork = networkMap.get(network.networkId());
    if (curNetwork != null) {
        // Existing topology update
        // Remove existing map entries first,
        removeNetworkMapEntrys(curNetwork, false);
    }
    TeTopologyKey topoKey = null;
    if (network.teTopologyId() != null) {
        topoKey = newTeTopologyKey(network.teTopologyId());
    }
    // Update TE nodes
    List<TeNodeKey> teNodeKeys = null;
    if (!MapUtils.isEmpty(network.nodes())) {
        teNodeKeys = Lists.newArrayList();
        for (Map.Entry<KeyId, NetworkNode> entry : network.nodes().entrySet()) {
            NetworkNodeKey nodeKey = new NetworkNodeKey(network.networkId(), entry.getKey());
            TeNodeKey teNodeKey = null;
            if (topoKey != null && entry.getValue().teNode() != null) {
                teNodeKey = new TeNodeKey(topoKey, entry.getValue().teNode().teNodeId());
            }
            updateNetworkNode(nodeKey, entry.getValue(), true, false, teNodeKey);
            teNodeKeys.add(teNodeKey);
        }
    }
    // Update TE links
    List<TeLinkTpGlobalKey> teLinkKeys = null;
    if (!MapUtils.isEmpty(network.links())) {
        teLinkKeys = Lists.newArrayList();
        for (Map.Entry<KeyId, NetworkLink> entry : network.links().entrySet()) {
            NetworkLinkKey linkKey = new NetworkLinkKey(network.networkId(), entry.getKey());
            TeLinkTpGlobalKey teLinkKey = null;
            if (topoKey != null && entry.getValue().teLink() != null) {
                teLinkKey = new TeLinkTpGlobalKey(topoKey, entry.getValue().teLink().teLinkKey());
            }
            updateNetworkLink(linkKey, entry.getValue(), true, false, teLinkKey);
            teLinkKeys.add(teLinkKey);
        }
    }
    // New network, update TE Topology first
    if (curNetwork == null) {
        InternalTeTopology intTopo = new InternalTeTopology(network.teTopologyId().topologyId());
        intTopo.setTeNodeKeys(teNodeKeys);
        intTopo.setTeLinkKeys(teLinkKeys);
        BitSet flags = new BitSet(TeConstants.FLAG_MAX_BITS);
        flags.set(TeTopology.BIT_LEARNT);
        if (network.teTopologyId().clientId() == TeTopologyManager.DEFAULT_PROVIDER_ID) {
            // Hard rule for now
            flags.set(TeTopology.BIT_CUSTOMIZED);
        }
        CommonTopologyData common = new CommonTopologyData(network.networkId(), OptimizationType.NOT_OPTIMIZED, flags, network.ownerId());
        intTopo.setTopologydata(common);
        teTopologyMap.put(topoKey, intTopo);
    }
    // Finally Update networkMap
    InternalNetwork newNetwork = new InternalNetwork(network);
    newNetwork.setTeTopologyKey(topoKey);
    networkMap.put(network.networkId(), newNetwork);
}
#method_after
@Override
public void updateNetwork(Network network) {
    InternalNetwork curNetwork = networkMap.get(network.networkId());
    TeTopologyKey topoKey = null;
    if (network.teTopologyId() != null) {
        topoKey = newTeTopologyKey(network.teTopologyId());
    }
    // Update TE nodes
    List<TeNodeKey> teNodeKeys = null;
    if (MapUtils.isNotEmpty(network.nodes())) {
        teNodeKeys = Lists.newArrayList();
        for (Map.Entry<KeyId, NetworkNode> entry : network.nodes().entrySet()) {
            NetworkNodeKey nodeKey = new NetworkNodeKey(network.networkId(), entry.getKey());
            TeNodeKey teNodeKey = null;
            if (topoKey != null && entry.getValue().teNode() != null) {
                teNodeKey = new TeNodeKey(topoKey, entry.getValue().teNode().teNodeId());
            }
            updateNetworkNode(nodeKey, entry.getValue(), true, false, teNodeKey);
            teNodeKeys.add(teNodeKey);
        }
    }
    // Update TE links
    List<TeLinkTpGlobalKey> teLinkKeys = null;
    if (MapUtils.isNotEmpty(network.links())) {
        teLinkKeys = Lists.newArrayList();
        for (Map.Entry<KeyId, NetworkLink> entry : network.links().entrySet()) {
            NetworkLinkKey linkKey = new NetworkLinkKey(network.networkId(), entry.getKey());
            TeLinkTpGlobalKey teLinkKey = null;
            if (topoKey != null && entry.getValue().teLink() != null) {
                teLinkKey = new TeLinkTpGlobalKey(topoKey, entry.getValue().teLink().teLinkKey());
            }
            updateNetworkLink(linkKey, entry.getValue(), true, false, teLinkKey);
            teLinkKeys.add(teLinkKey);
        }
    }
    // New network, update TE Topology first
    if (curNetwork == null) {
        InternalTeTopology intTopo = new InternalTeTopology(network.teTopologyId().topologyId());
        intTopo.setTeNodeKeys(teNodeKeys);
        intTopo.setTeLinkKeys(teLinkKeys);
        BitSet flags = new BitSet(TeConstants.FLAG_MAX_BITS);
        flags.set(TeTopology.BIT_LEARNT);
        if (network.teTopologyId().clientId() == TeTopologyManager.DEFAULT_PROVIDER_ID) {
            // Hard rule for now
            flags.set(TeTopology.BIT_CUSTOMIZED);
        }
        CommonTopologyData common = new CommonTopologyData(network.networkId(), OptimizationType.NOT_OPTIMIZED, flags, network.ownerId());
        intTopo.setTopologydata(common);
        teTopologyMap.put(topoKey, intTopo);
    }
    // Finally Update networkMap
    InternalNetwork newNetwork = new InternalNetwork(network);
    newNetwork.setTeTopologyKey(topoKey);
    networkMap.put(network.networkId(), newNetwork);
}
#end_block

#method_before
private TeNode teNode(TeNodeKey nodeKey, InternalTeNode intNode) {
    if (intNode == null) {
        return null;
    }
    Map<Long, ConnectivityMatrix> connMatrices = null;
    if (!CollectionUtils.isEmpty(intNode.connMatrixKeys())) {
        connMatrices = Maps.newConcurrentMap();
        for (ConnectivityMatrixKey key : intNode.connMatrixKeys()) {
            connMatrices.put(key.entryId(), connMatrixMap.get(key));
        }
    }
    List<Long> teLinkIds = null;
    if (!CollectionUtils.isEmpty(intNode.teLinkTpKeys())) {
        teLinkIds = Lists.newArrayList();
        for (TeLinkTpGlobalKey key : intNode.teLinkTpKeys()) {
            teLinkIds = TeUtils.addListElement(teLinkIds, key.teLinkTpId());
        }
    }
    List<Long> tps = null;
    if (!CollectionUtils.isEmpty(intNode.teTpKeys())) {
        tps = Lists.newArrayList();
        for (TeLinkTpGlobalKey key : intNode.teTpKeys()) {
            tps = TeUtils.addListElement(tps, key.teLinkTpId());
        }
    }
    Map<Long, TunnelTerminationPoint> ttps = null;
    if (!CollectionUtils.isEmpty(intNode.ttpKeys())) {
        ttps = Maps.newConcurrentMap();
        for (TtpKey key : intNode.ttpKeys()) {
            ttps.put(key.ttpId(), ttpMap.get(key));
        }
    }
    return new DefaultTeNode(nodeKey.teNodeId(), intNode.underlayTopologyKey(), intNode.supportNodeKey(), intNode.sourceTeNodeKey(), intNode.teData(), connMatrices, teLinkIds, ttps, tps);
}
#method_after
private TeNode teNode(TeNodeKey nodeKey, InternalTeNode intNode) {
    if (intNode == null) {
        return null;
    }
    Map<Long, ConnectivityMatrix> connMatrices = null;
    if (CollectionUtils.isNotEmpty(intNode.connMatrixKeys())) {
        connMatrices = Maps.newHashMap();
        for (ConnectivityMatrixKey key : intNode.connMatrixKeys()) {
            connMatrices.put(key.entryId(), connMatrixMap.get(key));
        }
    }
    List<Long> teLinkIds = null;
    if (CollectionUtils.isNotEmpty(intNode.teLinkTpKeys())) {
        teLinkIds = Lists.newArrayList();
        for (TeLinkTpGlobalKey key : intNode.teLinkTpKeys()) {
            teLinkIds = TeUtils.addListElement(teLinkIds, key.teLinkTpId());
        }
    }
    List<Long> tps = null;
    if (CollectionUtils.isNotEmpty(intNode.teTpKeys())) {
        tps = Lists.newArrayList();
        for (TeLinkTpGlobalKey key : intNode.teTpKeys()) {
            tps = TeUtils.addListElement(tps, key.teLinkTpId());
        }
    }
    Map<Long, TunnelTerminationPoint> ttps = null;
    if (CollectionUtils.isNotEmpty(intNode.ttpKeys())) {
        ttps = Maps.newHashMap();
        for (TtpKey key : intNode.ttpKeys()) {
            ttps.put(key.ttpId(), ttpMap.get(key));
        }
    }
    return new DefaultTeNode(nodeKey.teNodeId(), intNode.underlayTopologyKey(), intNode.supportNodeKey(), intNode.sourceTeNodeKey(), intNode.teData(), connMatrices, teLinkIds, ttps, tps);
}
#end_block

#method_before
private void removeTeNodeMapEntrys(InternalTeNode intNode) {
    // Remove connMatrixMap entries for the node
    if (!CollectionUtils.isEmpty(intNode.connMatrixKeys())) {
        for (ConnectivityMatrixKey key : intNode.connMatrixKeys()) {
            connMatrixMap.remove(key);
        }
    }
    // Remove ttpMap entries for the node
    if (!CollectionUtils.isEmpty(intNode.ttpKeys())) {
        for (TtpKey key : intNode.ttpKeys()) {
            ttpMap.remove(key);
        }
    }
}
#method_after
private void removeTeNodeMapEntrys(InternalTeNode intNode) {
    // Remove connMatrixMap entries for the node
    if (CollectionUtils.isNotEmpty(intNode.connMatrixKeys())) {
        for (ConnectivityMatrixKey key : intNode.connMatrixKeys()) {
            connMatrixMap.remove(key);
        }
    }
    // Remove ttpMap entries for the node
    if (CollectionUtils.isNotEmpty(intNode.ttpKeys())) {
        for (TtpKey key : intNode.ttpKeys()) {
            ttpMap.remove(key);
        }
    }
}
#end_block

#method_before
private void updateTeNode(TeNodeKey nodeKey, TeNode node, boolean parentUpdate, boolean teNodeUpdate, NetworkNodeKey networkNodeKey) {
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo == null && !parentUpdate) {
        log.error("TE Topology is not in dataStore for nodeUpdate {}", nodeKey);
        return;
    }
    InternalTeNode curNode = teNodeMap.get(nodeKey);
    // Update connMatrixMap
    if (!MapUtils.isEmpty(node.connectivityMatrices())) {
        for (Map.Entry<Long, ConnectivityMatrix> entry : node.connectivityMatrices().entrySet()) {
            connMatrixMap.put(new ConnectivityMatrixKey(nodeKey, entry.getKey()), entry.getValue());
        }
    }
    // Update ttpMap
    if (!MapUtils.isEmpty(node.tunnelTerminationPoints())) {
        for (Map.Entry<Long, TunnelTerminationPoint> entry : node.tunnelTerminationPoints().entrySet()) {
            ttpMap.put(new TtpKey(nodeKey, entry.getKey()), entry.getValue());
        }
    }
    // Update TE Termination Points
    // Update teNodeMap
    InternalTeNode intNode = new InternalTeNode(nodeKey, node, networkNodeKey, parentUpdate);
    teNodeMap.put(nodeKey, intNode);
    if (curNode == null && !parentUpdate && intTopo != null) {
        // Update InternalTeTopology
        intTopo.setChildUpdate(true);
        TeUtils.addListElement(intTopo.teNodeKeys(), nodeKey);
    }
    // Update networkNodeMap
    if (teNodeUpdate) {
        updateNetworkNode(networkNodeKey, networkNode(node), parentUpdate, teNodeUpdate, nodeKey);
    }
}
#method_after
private void updateTeNode(TeNodeKey nodeKey, TeNode node, boolean parentUpdate, boolean teNodeUpdate, NetworkNodeKey networkNodeKey) {
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo == null && !parentUpdate) {
        log.error("TE Topology is not in dataStore for nodeUpdate {}", nodeKey);
        return;
    }
    InternalTeNode curNode = teNodeMap.get(nodeKey);
    // Update connMatrixMap
    if (MapUtils.isNotEmpty(node.connectivityMatrices())) {
        for (Map.Entry<Long, ConnectivityMatrix> entry : node.connectivityMatrices().entrySet()) {
            connMatrixMap.put(new ConnectivityMatrixKey(nodeKey, entry.getKey()), entry.getValue());
        }
    }
    // Update ttpMap
    if (MapUtils.isNotEmpty(node.tunnelTerminationPoints())) {
        for (Map.Entry<Long, TunnelTerminationPoint> entry : node.tunnelTerminationPoints().entrySet()) {
            ttpMap.put(new TtpKey(nodeKey, entry.getKey()), entry.getValue());
        }
    }
    // Update teNodeMap
    InternalTeNode intNode = new InternalTeNode(nodeKey, node, networkNodeKey, parentUpdate);
    teNodeMap.put(nodeKey, intNode);
    if (curNode == null && !parentUpdate && intTopo != null) {
        // Update InternalTeTopology
        intTopo.setChildUpdate(true);
        TeUtils.addListElement(intTopo.teNodeKeys(), nodeKey);
    }
    // Update networkNodeMap
    if (teNodeUpdate) {
        updateNetworkNode(networkNodeKey, networkNode(node), parentUpdate, teNodeUpdate, nodeKey);
    }
}
#end_block

#method_before
private NetworkNode networkNode(TeNode node) {
    KeyId nodeId = KeyId.keyId(Long.toString(node.teNodeId()));
    List<NetworkNodeKey> supportingNodeIds = null;
    if (node.supportingTeNodeId() != null) {
        supportingNodeIds = Lists.newArrayList();
        supportingNodeIds.add(new NetworkNodeKey(TeMgrUtil.toNetworkId((node.supportingTeNodeId().teTopologyKey())), KeyId.keyId(Long.toString(node.supportingTeNodeId().teNodeId()))));
    }
    Map<KeyId, TerminationPoint> tps = null;
    if (node.teTerminationPointIds() != null) {
        tps = Maps.newConcurrentMap();
        for (Long teTpId : node.teTerminationPointIds()) {
            tps.put(KeyId.keyId(Long.toString(teTpId)), new DefaultTerminationPoint(KeyId.keyId(Long.toString(teTpId)), null, teTpId));
        }
    }
    return new DefaultNetworkNode(nodeId, supportingNodeIds, node, tps);
}
#method_after
private NetworkNode networkNode(TeNode node) {
    KeyId nodeId = KeyId.keyId(Long.toString(node.teNodeId()));
    List<NetworkNodeKey> supportingNodeIds = null;
    if (node.supportingTeNodeId() != null) {
        supportingNodeIds = Lists.newArrayList();
        supportingNodeIds.add(new NetworkNodeKey(TeMgrUtil.toNetworkId((node.supportingTeNodeId().teTopologyKey())), KeyId.keyId(Long.toString(node.supportingTeNodeId().teNodeId()))));
    }
    Map<KeyId, TerminationPoint> tps = null;
    if (node.teTerminationPointIds() != null) {
        tps = Maps.newHashMap();
        for (Long teTpId : node.teTerminationPointIds()) {
            tps.put(KeyId.keyId(Long.toString(teTpId)), new DefaultTerminationPoint(KeyId.keyId(Long.toString(teTpId)), null, teTpId));
        }
    }
    return new DefaultNetworkNode(nodeId, supportingNodeIds, node, tps);
}
#end_block

#method_before
private void removeTeNode(TeNodeKey nodeKey, boolean teNodeRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo != null && !CollectionUtils.isEmpty(intTopo.teNodeKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teNodeKeys().remove(nodeKey);
    }
    // Then remove it from teNodeMap
    InternalTeNode node = teNodeMap.remove(nodeKey);
    removeTeNodeMapEntrys(node);
    // Remove it from networkNodeMap
    if (teNodeRemove && node != null) {
        removeNetworkNode(node.networkNodeKey(), teNodeRemove);
    }
}
#method_after
private void removeTeNode(TeNodeKey nodeKey, boolean teNodeRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo != null && CollectionUtils.isNotEmpty(intTopo.teNodeKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teNodeKeys().remove(nodeKey);
    }
    // Then remove it from teNodeMap
    InternalTeNode node = teNodeMap.remove(nodeKey);
    removeTeNodeMapEntrys(node);
    // Remove it from networkNodeMap
    if (teNodeRemove && node != null) {
        removeNetworkNode(node.networkNodeKey(), teNodeRemove);
    }
}
#end_block

#method_before
private NetworkNode networkNode(NetworkNodeKey nodeKey, InternalNetworkNode intNode) {
    if (intNode == null) {
        return null;
    }
    Map<KeyId, TerminationPoint> tps = Maps.newConcurrentMap();
    for (KeyId tpId : intNode.tpIds()) {
        tps.put(tpId, terminationPoint(new TerminationPointKey(nodeKey, tpId)));
    }
    return new DefaultNetworkNode(nodeKey.nodeId(), intNode.supportingNodeIds(), teNode(intNode.teNodeKey()), tps);
}
#method_after
private NetworkNode networkNode(NetworkNodeKey nodeKey, InternalNetworkNode intNode) {
    if (intNode == null) {
        return null;
    }
    Map<KeyId, TerminationPoint> tps = Maps.newHashMap();
    for (KeyId tpId : intNode.tpIds()) {
        tps.put(tpId, terminationPoint(new TerminationPointKey(nodeKey, tpId)));
    }
    return new DefaultNetworkNode(nodeKey.nodeId(), intNode.supportingNodeIds(), teNode(intNode.teNodeKey()), tps);
}
#end_block

#method_before
private void updateNetworkNode(NetworkNodeKey nodeKey, NetworkNode node, boolean parentUpdate, boolean teNodeUpdate, TeNodeKey teNodeKey) {
    InternalNetwork intNework = null;
    if (!parentUpdate) {
        intNework = networkMap.get(nodeKey.networkId());
        if (intNework == null) {
            log.error("Network is not in dataStore for nodeUpdate {}", nodeKey);
            return;
        }
    }
    InternalNetworkNode exNode = networkNodeMap.get(nodeKey);
    if (exNode != null && !CollectionUtils.isEmpty(exNode.tpIds())) {
        // Remove the TerminationPoints first
        for (KeyId tpId : exNode.tpIds()) {
            removeTerminationPoint(new TerminationPointKey(nodeKey, tpId));
        }
    }
    if (!MapUtils.isEmpty(node.terminationPoints())) {
        // Update with new TerminationPoints
        for (Map.Entry<KeyId, TerminationPoint> entry : node.terminationPoints().entrySet()) {
            updateTerminationPoint(new TerminationPointKey(nodeKey, entry.getKey()), entry.getValue(), parentUpdate, teNodeKey);
        }
    }
    // Update teNodeMap first
    if (!teNodeUpdate && teNodeKey != null && node.teNode() != null) {
        updateTeNode(teNodeKey, node.teNode(), parentUpdate, teNodeUpdate, nodeKey);
    }
    // Update networkNodeMap
    InternalNetworkNode intNode = new InternalNetworkNode(node, parentUpdate);
    intNode.setTeNodeKey(teNodeKey);
    networkNodeMap.put(nodeKey, intNode);
    if (exNode == null && !parentUpdate && intNework != null) {
        // Update the InternalNetwork
        intNework.setChildUpdate(true);
        TeUtils.addListElement(intNework.nodeIds(), nodeKey);
    }
}
#method_after
private void updateNetworkNode(NetworkNodeKey nodeKey, NetworkNode node, boolean parentUpdate, boolean teNodeUpdate, TeNodeKey teNodeKey) {
    InternalNetwork intNework = null;
    if (!parentUpdate) {
        intNework = networkMap.get(nodeKey.networkId());
        if (intNework == null) {
            log.error("Network is not in dataStore for nodeUpdate {}", nodeKey);
            return;
        }
    }
    InternalNetworkNode exNode = networkNodeMap.get(nodeKey);
    if (exNode != null && CollectionUtils.isNotEmpty(exNode.tpIds())) {
        // Remove the TerminationPoints first
        for (KeyId tpId : exNode.tpIds()) {
            removeTerminationPoint(new TerminationPointKey(nodeKey, tpId));
        }
    }
    if (MapUtils.isNotEmpty(node.terminationPoints())) {
        // Update with new TerminationPoints
        for (Map.Entry<KeyId, TerminationPoint> entry : node.terminationPoints().entrySet()) {
            updateTerminationPoint(new TerminationPointKey(nodeKey, entry.getKey()), entry.getValue(), parentUpdate, teNodeKey);
        }
    }
    // Update teNodeMap first
    if (!teNodeUpdate && teNodeKey != null && node.teNode() != null) {
        updateTeNode(teNodeKey, node.teNode(), parentUpdate, teNodeUpdate, nodeKey);
    }
    // Update networkNodeMap
    InternalNetworkNode intNode = new InternalNetworkNode(node, parentUpdate);
    intNode.setTeNodeKey(teNodeKey);
    networkNodeMap.put(nodeKey, intNode);
    if (exNode == null && !parentUpdate && intNework != null) {
        // Update the InternalNetwork
        intNework.setChildUpdate(true);
        TeUtils.addListElement(intNework.nodeIds(), nodeKey);
    }
}
#end_block

#method_before
private void removeNetworkNode(NetworkNodeKey nodeKey, boolean teNodeRemove) {
    // Update the InternalNetwork
    InternalNetwork intNework = networkMap.get(nodeKey.networkId());
    if (intNework != null && !CollectionUtils.isEmpty(intNework.nodeIds())) {
        intNework.setChildUpdate(true);
        intNework.nodeIds().remove(nodeKey.nodeId());
    }
    InternalNetworkNode intNode = networkNodeMap.remove(nodeKey);
    if (intNode != null && !CollectionUtils.isEmpty(intNode.tpIds())) {
        // Remove the TerminationPoints first
        for (KeyId tpId : intNode.tpIds()) {
            removeTerminationPoint(new TerminationPointKey(nodeKey, tpId));
        }
    }
    if (!teNodeRemove && intNode != null) {
        // Now remove it from teNodeMap
        removeTeNode(intNode.teNodeKey(), teNodeRemove);
    }
}
#method_after
private void removeNetworkNode(NetworkNodeKey nodeKey, boolean teNodeRemove) {
    // Update the InternalNetwork
    InternalNetwork intNework = networkMap.get(nodeKey.networkId());
    if (intNework != null && CollectionUtils.isNotEmpty(intNework.nodeIds())) {
        intNework.setChildUpdate(true);
        intNework.nodeIds().remove(nodeKey.nodeId());
    }
    InternalNetworkNode intNode = networkNodeMap.remove(nodeKey);
    if (intNode != null && CollectionUtils.isNotEmpty(intNode.tpIds())) {
        // Remove the TerminationPoints first
        for (KeyId tpId : intNode.tpIds()) {
            removeTerminationPoint(new TerminationPointKey(nodeKey, tpId));
        }
    }
    if (!teNodeRemove && intNode != null) {
        // Now remove it from teNodeMap
        removeTeNode(intNode.teNodeKey(), teNodeRemove);
    }
}
#end_block

#method_before
private void removeTeLink(TeLinkTpGlobalKey linkKey, boolean teLinkRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(linkKey.teTopologyKey());
    if (intTopo != null && !CollectionUtils.isEmpty(intTopo.teLinkKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teLinkKeys().remove(linkKey);
    }
    // Remove it from InternalTeNode
    InternalTeNode intNode = teNodeMap.get(linkKey.teNodeKey());
    if (intNode != null && !CollectionUtils.isEmpty(intNode.teLinkTpKeys())) {
        intNode.setChildUpdate(true);
        intNode.teLinkTpKeys().remove(linkKey);
    }
    // Then remove it from teLinkMap
    InternalTeLink link = teLinkMap.remove(linkKey);
    if (teLinkRemove && link != null) {
        // Remove it from networkLinkMap
        removeNetworkLink(link.networkLinkKey(), teLinkRemove);
    }
}
#method_after
private void removeTeLink(TeLinkTpGlobalKey linkKey, boolean teLinkRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(linkKey.teTopologyKey());
    if (intTopo != null && CollectionUtils.isNotEmpty(intTopo.teLinkKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teLinkKeys().remove(linkKey);
    }
    // Remove it from InternalTeNode
    InternalTeNode intNode = teNodeMap.get(linkKey.teNodeKey());
    if (intNode != null && CollectionUtils.isNotEmpty(intNode.teLinkTpKeys())) {
        intNode.setChildUpdate(true);
        intNode.teLinkTpKeys().remove(linkKey);
    }
    // Then remove it from teLinkMap
    InternalTeLink link = teLinkMap.remove(linkKey);
    if (teLinkRemove && link != null) {
        // Remove it from networkLinkMap
        removeNetworkLink(link.networkLinkKey(), teLinkRemove);
    }
}
#end_block

#method_before
private void removeNetworkLink(NetworkLinkKey linkKey, boolean teLinkRemove) {
    // Update the InternalNetwork
    InternalNetwork intNework = networkMap.get(linkKey.networkId());
    if (intNework != null && !CollectionUtils.isEmpty(intNework.linkIds())) {
        intNework.setChildUpdate(true);
        intNework.linkIds().remove(linkKey.linkId());
    }
    // Remove it from networkLinkMap
    InternalNetworkLink intLink = networkLinkMap.remove(linkKey);
    if (!teLinkRemove && intLink != null && intLink.teLinkKey() != null) {
        // Now remove it from teLinkMap
        removeTeLink(intLink.teLinkKey(), teLinkRemove);
    }
}
#method_after
private void removeNetworkLink(NetworkLinkKey linkKey, boolean teLinkRemove) {
    // Update the InternalNetwork
    InternalNetwork intNework = networkMap.get(linkKey.networkId());
    if (intNework != null && CollectionUtils.isNotEmpty(intNework.linkIds())) {
        intNework.setChildUpdate(true);
        intNework.linkIds().remove(linkKey.linkId());
    }
    // Remove it from networkLinkMap
    InternalNetworkLink intLink = networkLinkMap.remove(linkKey);
    if (!teLinkRemove && intLink != null && intLink.teLinkKey() != null) {
        // Now remove it from teLinkMap
        removeTeLink(intLink.teLinkKey(), teLinkRemove);
    }
}
#end_block

#method_before
@Override
public void removeTerminationPoint(TerminationPointKey tpKey) {
    // Update InternalNetworkNode
    InternalNetworkNode intNode = networkNodeMap.get(tpKey.nodeId());
    if (intNode != null && !CollectionUtils.isEmpty(intNode.tpIds())) {
        intNode.setChildUpdate(true);
        intNode.tpIds().remove(tpKey.tpId());
    }
    // Remove it from tpMap
    InternalTerminationPoint tp = tpMap.remove(tpKey);
    // Remove it from tpKeyMap
    if (tp != null) {
        tpKeyMap.remove(tp.teTpKey());
    }
}
#method_after
@Override
public void removeTerminationPoint(TerminationPointKey tpKey) {
    // Update InternalNetworkNode
    InternalNetworkNode intNode = networkNodeMap.get(tpKey.nodeId());
    if (intNode != null && CollectionUtils.isNotEmpty(intNode.tpIds())) {
        intNode.setChildUpdate(true);
        intNode.tpIds().remove(tpKey.tpId());
    }
    // Remove it from tpMap
    InternalTerminationPoint tp = tpMap.remove(tpKey);
    // Remove it from tpKeyMap
    if (tp != null) {
        tpKeyMap.remove(tp.teTpKey());
    }
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTeNode) {
        InternalTeNode that = (InternalTeNode) object;
        return Objects.equal(this.teData, that.teData) && Objects.equal(this.underlayTopologyKey, that.underlayTopologyKey) && Objects.equal(this.supportNodeKey, that.supportNodeKey) && Objects.equal(this.sourceTeNodeKey, that.sourceTeNodeKey) && Objects.equal(this.connMatrixKeys, that.connMatrixKeys) && Objects.equal(this.teLinkTpKeys, that.teLinkTpKeys) && Objects.equal(this.ttpKeys, that.ttpKeys) && Objects.equal(this.networkNodeKey, that.networkNodeKey);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof InternalTeNode) {
        InternalTeNode that = (InternalTeNode) object;
        return Objects.equal(teData, that.teData) && Objects.equal(underlayTopologyKey, that.underlayTopologyKey) && Objects.equal(supportNodeKey, that.supportNodeKey) && Objects.equal(sourceTeNodeKey, that.sourceTeNodeKey) && Objects.equal(connMatrixKeys, that.connMatrixKeys) && Objects.equal(teLinkTpKeys, that.teLinkTpKeys) && Objects.equal(ttpKeys, that.ttpKeys) && Objects.equal(networkNodeKey, that.networkNodeKey);
    }
    return false;
}
#end_block

#method_before
public List<KeyId> supportingNetworkIds() {
    return supportingNetworkIds;
}
#method_after
public List<KeyId> supportingNetworkIds() {
    if (supportingNetworkIds == null) {
        return null;
    }
    return ImmutableList.copyOf(supportingNetworkIds);
}
#end_block

#method_before
@Override
public String name() {
    return teData.name();
}
#method_after
@Override
public String name() {
    if (teData == null) {
        return null;
    }
    return teData.name();
}
#end_block

#method_before
@Override
public BitSet flags() {
    return teData.flags();
}
#method_after
@Override
public BitSet flags() {
    if (teData == null) {
        return null;
    }
    return teData.flags();
}
#end_block

#method_before
@Override
public Map<Long, ConnectivityMatrix> connectivityMatrices() {
    return connMatrices;
}
#method_after
@Override
public Map<Long, ConnectivityMatrix> connectivityMatrices() {
    if (connMatrices == null) {
        return null;
    }
    return ImmutableMap.copyOf(connMatrices);
}
#end_block

#method_before
@Override
public List<Long> teLinkIds() {
    return teLinkIds;
}
#method_after
@Override
public List<Long> teLinkIds() {
    if (teLinkIds == null) {
        return null;
    }
    return ImmutableList.copyOf(teLinkIds);
}
#end_block

#method_before
@Override
public Map<Long, TunnelTerminationPoint> tunnelTerminationPoints() {
    return ttps;
}
#method_after
@Override
public Map<Long, TunnelTerminationPoint> tunnelTerminationPoints() {
    if (ttps == null) {
        return null;
    }
    return ImmutableMap.copyOf(ttps);
}
#end_block

#method_before
@Override
public TeStatus adminStatus() {
    return teData.adminStatus();
}
#method_after
@Override
public TeStatus adminStatus() {
    if (teData == null) {
        return null;
    }
    return teData.adminStatus();
}
#end_block

#method_before
@Override
public TeStatus opStatus() {
    return teData.opStatus();
}
#method_after
@Override
public TeStatus opStatus() {
    if (teData == null) {
        return null;
    }
    return teData.opStatus();
}
#end_block

#method_before
@Override
public List<Long> teTerminationPointIds() {
    return teTpIds;
}
#method_after
@Override
public List<Long> teTerminationPointIds() {
    return Collections.unmodifiableList(teTpIds);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeNode) {
        DefaultTeNode that = (DefaultTeNode) object;
        return Objects.equal(this.teNodeId, that.teNodeId) && Objects.equal(this.underlayTopologyId, that.underlayTopologyId) && Objects.equal(this.supportTeNodeId, that.supportTeNodeId) && Objects.equal(this.sourceTeNodeId, that.sourceTeNodeId) && Objects.equal(this.teData, that.teData) && Objects.equal(this.connMatrices, that.connMatrices) && Objects.equal(this.teLinkIds, that.teLinkIds) && Objects.equal(this.ttps, that.ttps) && Objects.equal(this.teTpIds, that.teTpIds);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeNode) {
        DefaultTeNode that = (DefaultTeNode) object;
        return Objects.equal(teNodeId, that.teNodeId) && Objects.equal(underlayTopologyId, that.underlayTopologyId) && Objects.equal(supportTeNodeId, that.supportTeNodeId) && Objects.equal(sourceTeNodeId, that.sourceTeNodeId) && Objects.equal(teData, that.teData) && Objects.equal(connMatrices, that.connMatrices) && Objects.equal(teLinkIds, that.teLinkIds) && Objects.equal(ttps, that.ttps) && Objects.equal(teTpIds, that.teTpIds);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof NetworkLinkEventSubject) {
        NetworkLinkEventSubject that = (NetworkLinkEventSubject) object;
        return Objects.equal(this.key, that.key) && Objects.equal(this.networkLink, that.networkLink);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof NetworkLinkEventSubject) {
        NetworkLinkEventSubject that = (NetworkLinkEventSubject) object;
        return Objects.equal(key, that.key) && Objects.equal(networkLink, that.networkLink);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeNodeEventSubject) {
        TeNodeEventSubject that = (TeNodeEventSubject) object;
        return Objects.equal(this.key, that.key) && Objects.equal(this.teNode, that.teNode);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeNodeEventSubject) {
        TeNodeEventSubject that = (TeNodeEventSubject) object;
        return Objects.equal(key, that.key) && Objects.equal(teNode, that.teNode);
    }
    return false;
}
#end_block

#method_before
public List<PathElement> pathElements() {
    return pathElements;
}
#method_after
public List<PathElement> pathElements() {
    return Collections.unmodifiableList(pathElements);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof ProviderClientId) {
        ProviderClientId that = (ProviderClientId) object;
        return Objects.equal(this.providerId, that.providerId) && Objects.equal(this.clientId, that.clientId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof ProviderClientId) {
        ProviderClientId that = (ProviderClientId) object;
        return Objects.equal(providerId, that.providerId) && Objects.equal(clientId, that.clientId);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof CommonTopologyData) {
        CommonTopologyData that = (CommonTopologyData) object;
        return Objects.equal(this.optimization, that.optimization) && Objects.equal(this.flags, that.flags) && Objects.equal(this.networkId, that.networkId) && Objects.equal(this.ownerId, that.ownerId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof CommonTopologyData) {
        CommonTopologyData that = (CommonTopologyData) object;
        return Objects.equal(optimization, that.optimization) && Objects.equal(flags, that.flags) && Objects.equal(networkId, that.networkId) && Objects.equal(ownerId, that.ownerId);
    }
    return false;
}
#end_block

#method_before
@Override
public List<NetworkNodeKey> supportingNodeIds() {
    return supportingNodeIds;
}
#method_after
@Override
public List<NetworkNodeKey> supportingNodeIds() {
    if (supportingNodeIds == null) {
        return null;
    }
    return ImmutableList.copyOf(supportingNodeIds);
}
#end_block

#method_before
@Override
public Map<KeyId, TerminationPoint> terminationPoints() {
    return tps;
}
#method_after
@Override
public Map<KeyId, TerminationPoint> terminationPoints() {
    if (tps == null) {
        return null;
    }
    return ImmutableMap.copyOf(tps);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetworkNode) {
        DefaultNetworkNode that = (DefaultNetworkNode) object;
        return Objects.equal(this.id, that.id) && Objects.equal(this.supportingNodeIds, that.supportingNodeIds) && Objects.equal(this.teNode, that.teNode) && Objects.equal(this.tps, that.tps);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetworkNode) {
        DefaultNetworkNode that = (DefaultNetworkNode) object;
        return Objects.equal(id, that.id) && Objects.equal(supportingNodeIds, that.supportingNodeIds) && Objects.equal(teNode, that.teNode) && Objects.equal(tps, that.tps);
    }
    return false;
}
#end_block

#method_before
@Override
public List<NetworkLinkKey> supportingLinkIds() {
    return supportingLinkIds;
}
#method_after
@Override
public List<NetworkLinkKey> supportingLinkIds() {
    if (supportingLinkIds == null) {
        return null;
    }
    return ImmutableList.copyOf(supportingLinkIds);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetworkLink) {
        DefaultNetworkLink that = (DefaultNetworkLink) object;
        return Objects.equal(this.linkId, that.linkId) && Objects.equal(this.source, that.source) && Objects.equal(this.destination, that.destination) && Objects.equal(this.supportingLinkIds, that.supportingLinkIds) && Objects.equal(this.teLink, that.teLink);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetworkLink) {
        DefaultNetworkLink that = (DefaultNetworkLink) object;
        return Objects.equal(linkId, that.linkId) && Objects.equal(source, that.source) && Objects.equal(destination, that.destination) && Objects.equal(supportingLinkIds, that.supportingLinkIds) && Objects.equal(teLink, that.teLink);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLinkEventSubject) {
        TeLinkEventSubject that = (TeLinkEventSubject) object;
        return Objects.equal(this.key, that.key) && Objects.equal(this.teLink, that.teLink);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLinkEventSubject) {
        TeLinkEventSubject that = (TeLinkEventSubject) object;
        return Objects.equal(key, that.key) && Objects.equal(teLink, that.teLink);
    }
    return false;
}
#end_block

#method_before
public List<Long> srlgs() {
    return srlgs;
}
#method_after
public List<Long> srlgs() {
    if (srlgs == null) {
        return null;
    }
    return ImmutableList.copyOf(srlgs);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TePathAttributes) {
        TePathAttributes that = (TePathAttributes) object;
        return Objects.equal(this.cost, that.cost) && Objects.equal(this.delay, that.delay) && Objects.equal(this.srlgs, that.srlgs);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TePathAttributes) {
        TePathAttributes that = (TePathAttributes) object;
        return Objects.equal(cost, that.cost) && Objects.equal(delay, that.delay) && Objects.equal(srlgs, that.srlgs);
    }
    return false;
}
#end_block

#method_before
public TeTopologyKey teTopologyKey() {
    return new TeTopologyKey(providerId(), clientId(), topologyId());
}
#method_after
@Override
public TeTopologyKey teTopologyKey() {
    return new TeTopologyKey(providerId(), clientId(), topologyId());
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLinkTpGlobalKey) {
        if (!super.equals(object)) {
            return false;
        }
        TeLinkTpGlobalKey that = (TeLinkTpGlobalKey) object;
        return Objects.equal(this.teLinkTpId, that.teLinkTpId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLinkTpGlobalKey) {
        if (!super.equals(object)) {
            return false;
        }
        TeLinkTpGlobalKey that = (TeLinkTpGlobalKey) object;
        return Objects.equal(teLinkTpId, that.teLinkTpId);
    }
    return false;
}
#end_block

#method_before
protected ToStringHelper toTeLinkTpKeyStringHelper() {
    return toTopologyKeyStringHelper().add("teLinkTpId", teLinkTpId);
}
#method_after
protected ToStringHelper toTeLinkTpKeyStringHelper() {
    return toTeNodeKeyStringHelper().add("teLinkTpId", teLinkTpId);
}
#end_block

#method_before
public ConnectivityMatrixKey key() {
    return key;
}
#method_after
public long key() {
    return key;
}
#end_block

#method_before
public List<ElementType> mergingList() {
    return mergingList;
}
#method_after
public List<ElementType> mergingList() {
    if (mergingList == null) {
        return null;
    }
    return ImmutableList.copyOf(mergingList);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("key", key).add("from", from).add("mergingList", mergingList).add("constrainingElements", constrainingElements()).add("flags", flags()).add("teAttibutes", teAttibutes()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("key", key).add("from", from).add("mergingList", mergingList).add("constrainingElements", constrainingElements()).add("flags", flags()).add("teAttributes", teAttributes()).toString();
}
#end_block

#method_before
@Override
public BitSet flags() {
    return common.flags();
}
#method_after
@Override
public BitSet flags() {
    if (common == null) {
        return null;
    }
    return common.flags();
}
#end_block

#method_before
@Override
public OptimizationType optimization() {
    return common.optimization();
}
#method_after
@Override
public OptimizationType optimization() {
    if (common == null) {
        return null;
    }
    return common.optimization();
}
#end_block

#method_before
@Override
public Map<Long, TeNode> teNodes() {
    return teNodes;
}
#method_after
@Override
public Map<Long, TeNode> teNodes() {
    if (teNodes == null) {
        return null;
    }
    return ImmutableMap.copyOf(teNodes);
}
#end_block

#method_before
@Override
public Map<TeLinkTpKey, TeLink> teLinks() {
    return teLinks;
}
#method_after
@Override
public Map<TeLinkTpKey, TeLink> teLinks() {
    if (teLinks == null) {
        return null;
    }
    return ImmutableMap.copyOf(teLinks);
}
#end_block

#method_before
@Override
public KeyId networkId() {
    return common.networkId();
}
#method_after
@Override
public KeyId networkId() {
    if (common == null) {
        return null;
    }
    return common.networkId();
}
#end_block

#method_before
@Override
public DeviceId ownerId() {
    return common.ownerId();
}
#method_after
@Override
public DeviceId ownerId() {
    if (common == null) {
        return null;
    }
    return common.ownerId();
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeTopology) {
        DefaultTeTopology that = (DefaultTeTopology) object;
        return Objects.equal(this.teKey, that.teKey) && Objects.equal(this.teNodes, that.teNodes) && Objects.equal(this.teLinks, that.teLinks) && Objects.equal(this.common, that.common) && Objects.equal(this.idString, that.idString);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeTopology) {
        DefaultTeTopology that = (DefaultTeTopology) object;
        return Objects.equal(teKey, that.teKey) && Objects.equal(teNodes, that.teNodes) && Objects.equal(teLinks, that.teLinks) && Objects.equal(common, that.common) && Objects.equal(idString, that.idString);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof ExternalLink) {
        ExternalLink that = (ExternalLink) object;
        return Objects.equal(this.externalLinkKey, that.externalLinkKey) && Objects.equal(this.plugId, that.plugId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof ExternalLink) {
        ExternalLink that = (ExternalLink) object;
        return Objects.equal(externalLinkKey, that.externalLinkKey) && Objects.equal(plugId, that.plugId);
    }
    return false;
}
#end_block

#method_before
private static NetworkBuilder te2YangNodes(NetworkBuilder builder, Map<KeyId, NetworkNode> teNodes) {
    List<Node> nodeList = Lists.newArrayList();
    // Add each node
    for (org.onosproject.tetopology.management.api.node.NetworkNode node : teNodes.values()) {
        // Convert the te node to a YO.
        nodeList.add(NodeConverter.teSubsystem2YangNode(node));
    }
    return builder.node(nodeList);
}
#method_after
private static NetworkBuilder te2YangNodes(NetworkBuilder builder, Map<KeyId, NetworkNode> teNodes) {
    List<Node> nodeList = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.node.NetworkNode node : teNodes.values()) {
        nodeList.add(NodeConverter.teSubsystem2YangNode(node));
    }
    return builder.node(nodeList);
}
#end_block

#method_before
private static NetworkBuilder te2YangLinks(NetworkBuilder builder, Map<KeyId, NetworkLink> teLinks) {
    List<Link> linkList = Lists.newArrayList();
    // Add each link
    for (org.onosproject.tetopology.management.api.link.NetworkLink link : teLinks.values()) {
        // Convert the te link to a YO
        linkList.add(LinkConverter.teSubsystem2YangLink(link));
    }
    AugmentedNdNetworkBuilder ndAugment = DefaultAugmentedNdNetwork.builder();
    ndAugment.link(linkList);
    builder.addYangAugmentedInfo(ndAugment.build(), AugmentedNdNetwork.class);
    return builder;
}
#method_after
private static NetworkBuilder te2YangLinks(NetworkBuilder builder, Map<KeyId, NetworkLink> teLinks) {
    List<Link> linkList = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.link.NetworkLink link : teLinks.values()) {
        linkList.add(LinkConverter.teSubsystem2YangLink(link));
    }
    AugmentedNdNetworkBuilder ndAugment = DefaultAugmentedNdNetwork.builder();
    ndAugment.link(linkList);
    builder.addYangAugmentedInfo(ndAugment.build(), AugmentedNdNetwork.class);
    return builder;
}
#end_block

#method_before
private static org.onosproject.tetopology.management.api.DefaultNetwork yang2TeDefaultNetwork(Network yangNetwork, org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network yangNetworkState) {
    checkNotNull(yangNetwork, E_NULL_YANG_NETWORK);
    checkNotNull(yangNetwork.networkId(), E_NULL_YANG_NETWORKID);
    String networkId = yangNetwork.networkId().uri().string();
    org.onosproject.tetopology.management.api.DefaultNetwork.Builder teNetworkBuilder = new org.onosproject.tetopology.management.api.DefaultNetwork.Builder(KeyId.keyId(networkId));
    // Supporting networks
    if (yangNetwork.supportingNetwork() != null) {
        List<KeyId> supportingNetworkIds = Lists.newArrayList();
        for (SupportingNetwork supportNw : yangNetwork.supportingNetwork()) {
            supportingNetworkIds.add(KeyId.keyId(supportNw.networkRef().uri().string()));
        }
        teNetworkBuilder.setSupportingNetworkIds(supportingNetworkIds);
    }
    // Nodes
    if (yangNetwork.node() != null) {
        Map<KeyId, org.onosproject.tetopology.management.api.node.NetworkNode> teNodes = Maps.newHashMap();
        for (Node node : yangNetwork.node()) {
            // Convert the Yang Node to a TE node.
            teNodes.put(KeyId.keyId(node.nodeId().uri().string()), NodeConverter.yang2TeSubsystemNode(node, yangNetwork.networkId()));
        }
        teNetworkBuilder.setNodes(teNodes);
    }
    // Links
    if (yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class) != null) {
        AugmentedNdNetwork augmentLink = (AugmentedNdNetwork) yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class);
        Map<KeyId, org.onosproject.tetopology.management.api.link.NetworkLink> teLinks = Maps.newHashMap();
        for (Link link : augmentLink.link()) {
            // Convert the Yang Link to a TE link.
            teLinks.put(KeyId.keyId(link.linkId().uri().string()), LinkConverter.yang2TeSubsystemLink(link, yangNetwork.networkId()));
        }
        teNetworkBuilder.setLinks(teLinks);
    }
    // TE Topology Ids
    if (yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class) != null) {
        AugmentedNwNetwork augmentTeIds = (AugmentedNwNetwork) yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class);
        org.onosproject.tetopology.management.api.TeTopologyId teTopologyId = new org.onosproject.tetopology.management.api.TeTopologyId(augmentTeIds.te().clientId().uint32(), augmentTeIds.te().providerId().uint32(), augmentTeIds.te().teTopologyId().string());
        teNetworkBuilder.setTeTopologyId(teTopologyId);
    }
    if (yangNetworkState != null) {
        teNetworkBuilder.setServerProvided(yangNetworkState.serverProvided());
    }
    return teNetworkBuilder.build();
}
#method_after
private static org.onosproject.tetopology.management.api.DefaultNetwork yang2TeDefaultNetwork(Network yangNetwork, org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network yangNetworkState) {
    checkNotNull(yangNetwork, E_NULL_YANG_NETWORK);
    checkNotNull(yangNetwork.networkId(), E_NULL_YANG_NETWORKID);
    String networkId = yangNetwork.networkId().uri().string();
    KeyId networkKeyId = KeyId.keyId(networkId);
    List<KeyId> supportingNetworkIds = null;
    Map<KeyId, NetworkNode> teNodes = null;
    Map<KeyId, NetworkLink> teLinks = null;
    org.onosproject.tetopology.management.api.TeTopologyId teTopologyId = null;
    boolean serverProvided = false;
    DeviceId ownerId = null;
    // Supporting networks
    if (yangNetwork.supportingNetwork() != null) {
        supportingNetworkIds = Lists.newArrayList();
        for (SupportingNetwork supportNw : yangNetwork.supportingNetwork()) {
            supportingNetworkIds.add(KeyId.keyId(supportNw.networkRef().uri().string()));
        }
    }
    // Nodes
    if (yangNetwork.node() != null) {
        teNodes = Maps.newHashMap();
        for (Node node : yangNetwork.node()) {
            // Convert the Yang Node to a TE node.
            teNodes.put(KeyId.keyId(node.nodeId().uri().string()), NodeConverter.yang2TeSubsystemNode(node, yangNetwork.networkId()));
        }
    }
    // Links
    if (yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class) != null) {
        AugmentedNdNetwork augmentLink = (AugmentedNdNetwork) yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class);
        teLinks = Maps.newHashMap();
        for (Link link : augmentLink.link()) {
            // Convert the Yang Link to a TE link.
            teLinks.put(KeyId.keyId(link.linkId().uri().string()), LinkConverter.yang2TeSubsystemLink(link, yangNetwork.networkId()));
        }
    }
    // TE Topology Ids
    if (yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class) != null) {
        AugmentedNwNetwork augmentTeIds = (AugmentedNwNetwork) yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class);
        teTopologyId = new org.onosproject.tetopology.management.api.TeTopologyId(augmentTeIds.te().clientId().uint32(), augmentTeIds.te().providerId().uint32(), augmentTeIds.te().teTopologyId().string());
    }
    if (yangNetworkState != null) {
        serverProvided = yangNetworkState.serverProvided();
    }
    org.onosproject.tetopology.management.api.DefaultNetwork network = new org.onosproject.tetopology.management.api.DefaultNetwork(networkKeyId, supportingNetworkIds, teNodes, teLinks, teTopologyId, serverProvided, ownerId);
    return network;
}
#end_block

#method_before
@Override
public List<KeyId> supportingNetworkIds() {
    return supportingNetworkIds;
}
#method_after
@Override
public List<KeyId> supportingNetworkIds() {
    if (supportingNetworkIds == null) {
        return null;
    }
    return ImmutableList.copyOf(supportingNetworkIds);
}
#end_block

#method_before
@Override
public Map<KeyId, NetworkNode> nodes() {
    return nodes;
}
#method_after
@Override
public Map<KeyId, NetworkNode> nodes() {
    if (nodes == null) {
        return null;
    }
    return ImmutableMap.copyOf(nodes);
}
#end_block

#method_before
@Override
public Map<KeyId, NetworkLink> links() {
    return links;
}
#method_after
@Override
public Map<KeyId, NetworkLink> links() {
    if (links == null) {
        return null;
    }
    return ImmutableMap.copyOf(links);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetwork) {
        DefaultNetwork that = (DefaultNetwork) object;
        return Objects.equal(this.networkId, that.networkId) && Objects.equal(this.supportingNetworkIds, that.supportingNetworkIds) && Objects.equal(this.nodes, that.nodes) && Objects.equal(this.links, that.links) && Objects.equal(this.serverProvided, that.serverProvided) && Objects.equal(this.teTopologyId, that.teTopologyId) && Objects.equal(this.ownerId, that.ownerId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetwork) {
        DefaultNetwork that = (DefaultNetwork) object;
        return Objects.equal(networkId, that.networkId) && Objects.equal(supportingNetworkIds, that.supportingNetworkIds) && Objects.equal(nodes, that.nodes) && Objects.equal(links, that.links) && Objects.equal(serverProvided, that.serverProvided) && Objects.equal(teTopologyId, that.teTopologyId) && Objects.equal(ownerId, that.ownerId);
    }
    return false;
}
#end_block

#method_before
public List<UnderlayBackupPath> backupPaths() {
    return backupPaths;
}
#method_after
public List<UnderlayBackupPath> backupPaths() {
    if (backupPaths == null) {
        return null;
    }
    return ImmutableList.copyOf(backupPaths);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof UnderlayPath) {
        UnderlayPath that = (UnderlayPath) object;
        return Objects.equal(this.primaryPath, that.primaryPath) && Objects.equal(this.backupPaths, that.backupPaths) && Objects.equal(this.tunnelProtectionType, that.tunnelProtectionType) && Objects.equal(this.srcTtpId, that.srcTtpId) && Objects.equal(this.dstTtpId, that.dstTtpId) && Objects.equal(this.teTunnelId, that.teTunnelId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof UnderlayPath) {
        UnderlayPath that = (UnderlayPath) object;
        return Objects.equal(primaryPath, that.primaryPath) && Objects.equal(backupPaths, that.backupPaths) && Objects.equal(tunnelProtectionType, that.tunnelProtectionType) && Objects.equal(srcTtpId, that.srcTtpId) && Objects.equal(dstTtpId, that.dstTtpId) && Objects.equal(teTunnelId, that.teTunnelId);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (object instanceof TerminationPointKey) {
        if (!super.equals(object)) {
            return false;
        }
        TerminationPointKey that = (TerminationPointKey) object;
        return Objects.equal(this.tpId, that.tpId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (object instanceof TerminationPointKey) {
        if (!super.equals(object)) {
            return false;
        }
        TerminationPointKey that = (TerminationPointKey) object;
        return Objects.equal(tpId, that.tpId);
    }
    return false;
}
#end_block

#method_before
@Override
public List<TerminationPointKey> supportingTpIds() {
    return supportingTpIds;
}
#method_after
@Override
public List<TerminationPointKey> supportingTpIds() {
    if (supportingTpIds == null) {
        return null;
    }
    return ImmutableList.copyOf(supportingTpIds);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTerminationPoint) {
        DefaultTerminationPoint that = (DefaultTerminationPoint) object;
        return Objects.equal(this.tpId, that.tpId) && Objects.equal(this.supportingTpIds, that.supportingTpIds) && Objects.equal(this.teTpId, that.teTpId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTerminationPoint) {
        DefaultTerminationPoint that = (DefaultTerminationPoint) object;
        return Objects.equal(tpId, that.tpId) && Objects.equal(supportingTpIds, that.supportingTpIds) && Objects.equal(teTpId, that.teTpId);
    }
    return false;
}
#end_block

#method_before
public static <T> List<T> addListElement(List<T> list, T element) {
    if (list == null) {
        list = Lists.newArrayList();
    }
    list.add(element);
    return list;
}
#method_after
public static <T> List<T> addListElement(List<T> list, T element) {
    if (element == null) {
        return list;
    }
    List<T> result = (list == null) ? Lists.newArrayList() : list;
    result.add(element);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLinkTpKey) {
        TeLinkTpKey that = (TeLinkTpKey) object;
        return Objects.equal(this.teNodeId, that.teNodeId) && Objects.equal(this.teLinkTpId, that.teLinkTpId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLinkTpKey) {
        TeLinkTpKey that = (TeLinkTpKey) object;
        return Objects.equal(teNodeId, that.teNodeId) && Objects.equal(teLinkTpId, that.teLinkTpId);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof OduResource) {
        OduResource that = (OduResource) object;
        return Objects.equal(this.odu0s, that.odu0s) && Objects.equal(this.odu1s, that.odu1s) && Objects.equal(this.odu2s, that.odu2s) && Objects.equal(this.odu2es, that.odu2es) && Objects.equal(this.odu3s, that.odu3s) && Objects.equal(this.odu4s, that.odu4s) && Objects.equal(this.oduFlexes, that.oduFlexes);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof OduResource) {
        OduResource that = (OduResource) object;
        return (this.odu0s == that.odu0s) && (this.odu1s == that.odu1s) && (this.odu2s == that.odu2s) && (this.odu2es == that.odu2es) && (this.odu3s == that.odu3s) && (this.odu4s == that.odu4s) && (this.oduFlexes == that.oduFlexes);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof NodeTpKey) {
        NodeTpKey that = (NodeTpKey) object;
        return Objects.equal(this.nodeId, that.nodeId) && Objects.equal(this.tpId, that.tpId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof NodeTpKey) {
        NodeTpKey that = (NodeTpKey) object;
        return Objects.equal(nodeId, that.nodeId) && Objects.equal(tpId, that.tpId);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof CommonNodeData) {
        CommonNodeData that = (CommonNodeData) object;
        return Objects.equal(this.name, that.name) && Objects.equal(this.adminStatus, that.adminStatus) && Objects.equal(this.opStatus, that.opStatus) && Objects.equal(this.flags, that.flags);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof CommonNodeData) {
        CommonNodeData that = (CommonNodeData) object;
        return Objects.equal(name, that.name) && Objects.equal(adminStatus, that.adminStatus) && Objects.equal(opStatus, that.opStatus) && Objects.equal(flags, that.flags);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeTopologyKey) {
        if (!super.equals(object)) {
            return false;
        }
        TeTopologyKey that = (TeTopologyKey) object;
        return Objects.equal(this.topologyId, that.topologyId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeTopologyKey) {
        if (!super.equals(object)) {
            return false;
        }
        TeTopologyKey that = (TeTopologyKey) object;
        return Objects.equal(topologyId, that.topologyId);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TtpKey) {
        if (!super.equals(object)) {
            return false;
        }
        TtpKey that = (TtpKey) object;
        return Objects.equal(this.ttpId, that.ttpId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TtpKey) {
        if (!super.equals(object)) {
            return false;
        }
        TtpKey that = (TtpKey) object;
        return Objects.equal(ttpId, that.ttpId);
    }
    return false;
}
#end_block

#method_before
@Override
public List<Network> networks() {
    return networks;
}
#method_after
@Override
public List<Network> networks() {
    if (networks == null) {
        return null;
    }
    return ImmutableList.copyOf(networks);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetworks) {
        DefaultNetworks that = (DefaultNetworks) object;
        return Objects.equal(this.networks, that.networks);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultNetworks) {
        DefaultNetworks that = (DefaultNetworks) object;
        return Objects.equal(networks, that.networks);
    }
    return false;
}
#end_block

#method_before
@Override
public BitSet flags() {
    return teData.flags();
}
#method_after
@Override
public BitSet flags() {
    if (teData == null) {
        return null;
    }
    return teData.flags();
}
#end_block

#method_before
@Override
public SwitchingType switchingLayer() {
    return teData.switchingLayer();
}
#method_after
@Override
public SwitchingType switchingLayer() {
    if (teData == null) {
        return null;
    }
    return teData.switchingLayer();
}
#end_block

#method_before
@Override
public EncodingType encodingLayer() {
    return teData.encodingLayer();
}
#method_after
@Override
public EncodingType encodingLayer() {
    if (teData == null) {
        return null;
    }
    return teData.encodingLayer();
}
#end_block

#method_before
@Override
public ExternalLink externalLink() {
    return teData.externalLink();
}
#method_after
@Override
public ExternalLink externalLink() {
    if (teData == null) {
        return null;
    }
    return teData.externalLink();
}
#end_block

#method_before
@Override
public UnderlayPrimaryPath primaryPath() {
    return teData.underlayPath().primaryPath();
}
#method_after
@Override
public UnderlayPrimaryPath primaryPath() {
    if (teData == null || teData.underlayPath() == null) {
        return null;
    }
    return teData.underlayPath().primaryPath();
}
#end_block

#method_before
@Override
public List<UnderlayBackupPath> backupPaths() {
    return teData.underlayPath().backupPaths();
}
#method_after
@Override
public List<UnderlayBackupPath> backupPaths() {
    if (teData == null || teData.underlayPath() == null) {
        return null;
    }
    return teData.underlayPath().backupPaths();
}
#end_block

#method_before
@Override
public TunnelProtectionType tunnelProtectionType() {
    return teData.underlayPath().tunnelProtectionType();
}
#method_after
@Override
public TunnelProtectionType tunnelProtectionType() {
    if (teData == null || teData.underlayPath() == null) {
        return null;
    }
    return teData.underlayPath().tunnelProtectionType();
}
#end_block

#method_before
@Override
public long sourceTtpId() {
    return teData.underlayPath().srcTtpId();
}
#method_after
@Override
public long sourceTtpId() {
    if (teData == null || teData.underlayPath() == null) {
        return TeConstants.NIL_LONG_VALUE;
    }
    return teData.underlayPath().srcTtpId();
}
#end_block

#method_before
@Override
public long destinationTtpId() {
    return teData.underlayPath().dstTtpId();
}
#method_after
@Override
public long destinationTtpId() {
    if (teData == null || teData.underlayPath() == null) {
        return TeConstants.NIL_LONG_VALUE;
    }
    return teData.underlayPath().dstTtpId();
}
#end_block

#method_before
@Override
public TeTunnelId teTunnelId() {
    return teData.underlayPath().teTunnelId();
}
#method_after
@Override
public TeTunnelId teTunnelId() {
    if (teData == null || teData.underlayPath() == null) {
        return null;
    }
    return teData.underlayPath().teTunnelId();
}
#end_block

#method_before
@Override
public long cost() {
    return teData.teAttributes().cost();
}
#method_after
@Override
public long cost() {
    if (teData == null || teData.teAttributes() == null) {
        return TeConstants.NIL_LONG_VALUE;
    }
    return teData.teAttributes().cost();
}
#end_block

#method_before
@Override
public long delay() {
    return teData.teAttributes().delay();
}
#method_after
@Override
public long delay() {
    if (teData == null || teData.teAttributes() == null) {
        return TeConstants.NIL_LONG_VALUE;
    }
    return teData.teAttributes().delay();
}
#end_block

#method_before
@Override
public List<Long> srlgs() {
    return teData.teAttributes().srlgs();
}
#method_after
@Override
public List<Long> srlgs() {
    if (teData == null || teData.teAttributes() == null) {
        return null;
    }
    return teData.teAttributes().srlgs();
}
#end_block

#method_before
@Override
public Long administrativeGroup() {
    return teData.adminGroup();
}
#method_after
@Override
public Long administrativeGroup() {
    if (teData == null) {
        return null;
    }
    return teData.adminGroup();
}
#end_block

#method_before
@Override
public List<Long> interLayerLocks() {
    return teData.interLayerLocks();
}
#method_after
@Override
public List<Long> interLayerLocks() {
    if (teData == null) {
        return null;
    }
    return teData.interLayerLocks();
}
#end_block

#method_before
@Override
public float[] maxBandwidth() {
    return teData.bandwidth().maxBandwidth();
}
#method_after
@Override
public float[] maxBandwidth() {
    if (teData == null || teData.bandwidth() == null) {
        return null;
    }
    return teData.bandwidth().maxBandwidth();
}
#end_block

#method_before
@Override
public OduResource oduResource() {
    return teData.bandwidth().oduResource();
}
#method_after
@Override
public OduResource oduResource() {
    if (teData == null || teData.bandwidth() == null) {
        return null;
    }
    return teData.bandwidth().oduResource();
}
#end_block

#method_before
@Override
public TeStatus adminStatus() {
    return teData.adminStatus();
}
#method_after
@Override
public TeStatus adminStatus() {
    if (teData == null) {
        return null;
    }
    return teData.adminStatus();
}
#end_block

#method_before
@Override
public TeStatus opStatus() {
    return teData.opStatus();
}
#method_after
@Override
public TeStatus opStatus() {
    if (teData == null) {
        return null;
    }
    return teData.opStatus();
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeLink) {
        DefaultTeLink that = (DefaultTeLink) object;
        return Objects.equal(this.teLinkKey, that.teLinkKey) && Objects.equal(this.peerTeLinkKey, that.peerTeLinkKey) && Objects.equal(this.underlayTopologyId, that.underlayTopologyId) && Objects.equal(this.supportTeLinkId, that.supportTeLinkId) && Objects.equal(this.sourceTeLinkId, that.sourceTeLinkId) && Objects.equal(this.teData, that.teData);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeLink) {
        DefaultTeLink that = (DefaultTeLink) object;
        return Objects.equal(teLinkKey, that.teLinkKey) && Objects.equal(peerTeLinkKey, that.peerTeLinkKey) && Objects.equal(underlayTopologyId, that.underlayTopologyId) && Objects.equal(supportTeLinkId, that.supportTeLinkId) && Objects.equal(sourceTeLinkId, that.sourceTeLinkId) && Objects.equal(teData, that.teData);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof PathElement) {
        PathElement that = (PathElement) object;
        return Objects.equal(this.pathElementId, that.pathElementId) && Objects.equal(this.teNodeId(), that.teNodeId) && Objects.equal(this.type, that.type) && Objects.equal(this.loose, that.loose);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof PathElement) {
        PathElement that = (PathElement) object;
        return Objects.equal(pathElementId, that.pathElementId) && Objects.equal(teNodeId, that.teNodeId) && Objects.equal(type, that.type) && Objects.equal(loose, that.loose);
    }
    return false;
}
#end_block

#method_before
public float[] maxBandwidth() {
    return maxBandwidth;
}
#method_after
public float[] maxBandwidth() {
    if (maxBandwidth == null) {
        return null;
    }
    return Arrays.copyOf(maxBandwidth, maxBandwidth.length);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(maxBandwidth, avaiBandwidth, maxAvialLspBandwidth, minAvialLspBandwidth, odu);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(maxBandwidth, availBandwidth, maxAvailLspBandwidth, minAvailLspBandwidth, odu);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof LinkBandwidth) {
        LinkBandwidth that = (LinkBandwidth) object;
        return Objects.equal(this.maxBandwidth, that.maxBandwidth) && Objects.equal(this.avaiBandwidth, that.avaiBandwidth) && Objects.equal(this.maxAvialLspBandwidth, that.maxAvialLspBandwidth) && Objects.equal(this.minAvialLspBandwidth, that.minAvialLspBandwidth) && Objects.equal(this.odu, that.odu);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof LinkBandwidth) {
        LinkBandwidth that = (LinkBandwidth) object;
        return Objects.equal(maxBandwidth, that.maxBandwidth) && Objects.equal(availBandwidth, that.availBandwidth) && Objects.equal(maxAvailLspBandwidth, that.maxAvailLspBandwidth) && Objects.equal(minAvailLspBandwidth, that.minAvailLspBandwidth) && Objects.equal(odu, that.odu);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("maxBandwidth", maxBandwidth).add("avaiBandwidth", avaiBandwidth).add("maxAvialLspBandwidth", maxAvialLspBandwidth).add("minAvialLspBandwidth", minAvialLspBandwidth).add("odu", odu).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("maxBandwidth", maxBandwidth).add("availBandwidth", availBandwidth).add("maxAvailLspBandwidth", maxAvailLspBandwidth).add("minAvailLspBandwidth", minAvailLspBandwidth).add("odu", odu).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof NetworkNodeEventSubject) {
        NetworkNodeEventSubject that = (NetworkNodeEventSubject) object;
        return Objects.equal(this.key, that.key) && Objects.equal(this.node, that.node);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof NetworkNodeEventSubject) {
        NetworkNodeEventSubject that = (NetworkNodeEventSubject) object;
        return Objects.equal(key, that.key) && Objects.equal(node, that.node);
    }
    return false;
}
#end_block

#method_before
public List<ElementType> constrainingElements() {
    return constrainingElements;
}
#method_after
public List<ElementType> constrainingElements() {
    return Collections.unmodifiableList(constrainingElements);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(constrainingElements, flags, teAttibutes, underlayPath);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(constrainingElements, flags, teAttributes, underlayPath);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof AbstractConnectivity) {
        AbstractConnectivity that = (AbstractConnectivity) object;
        return Objects.equal(this.constrainingElements, that.constrainingElements) && Objects.equal(this.flags, that.flags) && Objects.equal(this.teAttibutes, that.teAttibutes) && Objects.equal(this.underlayPath, that.underlayPath);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof AbstractConnectivity) {
        AbstractConnectivity that = (AbstractConnectivity) object;
        return Objects.equal(constrainingElements, that.constrainingElements) && Objects.equal(flags, that.flags) && Objects.equal(teAttributes, that.teAttributes) && Objects.equal(underlayPath, that.underlayPath);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("constrainingElements", constrainingElements).add("flags", flags).add("teAttibutes", teAttibutes).add("underlayPath", underlayPath).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("constrainingElements", constrainingElements).add("flags", flags).add("teAttributes", teAttributes).add("underlayPath", underlayPath).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeTunnelId) {
        TeTunnelId that = (TeTunnelId) object;
        return Objects.equal(this.srcTeNodeId, that.srcTeNodeId) && Objects.equal(this.dstTeNodeId, that.dstTeNodeId) && Objects.equal(this.tunnelId, that.tunnelId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeTunnelId) {
        TeTunnelId that = (TeTunnelId) object;
        return (srcTeNodeId == that.srcTeNodeId) && (dstTeNodeId == that.dstTeNodeId) && (tunnelId == that.tunnelId);
    }
    return false;
}
#end_block

#method_before
public List<Long> interLayerLocks() {
    return interLayerLocks;
}
#method_after
public List<Long> interLayerLocks() {
    if (interLayerLocks == null) {
        return null;
    }
    return ImmutableList.copyOf(interLayerLocks);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof CommonLinkData) {
        CommonLinkData that = (CommonLinkData) object;
        return Objects.equal(this.adminStatus, that.adminStatus) && Objects.equal(this.opStatus, that.opStatus) && Objects.equal(this.flags, that.flags) && Objects.equal(this.switchingLayer, that.switchingLayer) && Objects.equal(this.encodingLayer, that.encodingLayer) && Objects.equal(this.externalLink, that.externalLink) && Objects.equal(this.underlayPath, that.underlayPath) && Objects.equal(this.teAttributes, that.teAttributes) && Objects.equal(this.interLayerLocks, that.interLayerLocks) && Objects.equal(this.bandwidth, that.bandwidth);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof CommonLinkData) {
        CommonLinkData that = (CommonLinkData) object;
        return Objects.equal(adminStatus, that.adminStatus) && Objects.equal(opStatus, that.opStatus) && Objects.equal(flags, that.flags) && Objects.equal(switchingLayer, that.switchingLayer) && Objects.equal(encodingLayer, that.encodingLayer) && Objects.equal(externalLink, that.externalLink) && Objects.equal(underlayPath, that.underlayPath) && Objects.equal(teAttributes, that.teAttributes) && Objects.equal(interLayerLocks, that.interLayerLocks) && Objects.equal(bandwidth, that.bandwidth);
    }
    return false;
}
#end_block

#method_before
@Override
public List<TeTopology> teTopologies() {
    return teTopologies;
}
#method_after
@Override
public Map<TeTopologyKey, TeTopology> teTopologies() {
    if (teTopologies == null) {
        return null;
    }
    return ImmutableMap.copyOf(teTopologies);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeTopologies) {
        DefaultTeTopologies that = (DefaultTeTopologies) object;
        return Objects.equal(this.name, that.name) && Objects.equal(this.teTopologies, that.teTopologies);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof DefaultTeTopologies) {
        DefaultTeTopologies that = (DefaultTeTopologies) object;
        return Objects.equal(name, that.name) && Objects.equal(teTopologies, that.teTopologies);
    }
    return false;
}
#end_block

#method_before
@Override
public Iterable<FlowEntry> getFlowRulesById(ApplicationId id) {
    checkPermission(FLOWRULE_READ);
    Set<FlowEntry> flowEntries = Sets.newHashSet();
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(d.id())) {
            if (flowEntry.appId() == id.id()) {
                flowEntries.add(flowEntry);
            }
        }
    }
    return flowEntries;
}
#method_after
@Deprecated
@Override
public Iterable<FlowRule> getFlowRulesById(ApplicationId id) {
    checkPermission(FLOWRULE_READ);
    Set<FlowRule> flowEntries = Sets.newHashSet();
    for (Device d : deviceService.getDevices()) {
        for (FlowEntry flowEntry : store.getFlowEntries(d.id())) {
            if (flowEntry.appId() == id.id()) {
                flowEntries.add(flowEntry);
            }
        }
    }
    return flowEntries;
}
#end_block

#method_before
@Override
public Iterable<FlowEntry> getFlowRulesById(ApplicationId id) {
    return null;
}
#method_after
@Override
public Iterable<FlowRule> getFlowRulesById(ApplicationId id) {
    return null;
}
#end_block

#method_before
@Test
public void testGetFlowByAppId() {
    setupMockFlowRules();
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    expect(mockFlowService.getFlowRulesById(APP_ID)).andReturn(flowRules).anyTimes();
    replay(mockFlowService);
    final WebTarget wt = target();
    final String response = wt.path("/flows/application/1").request().get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("flows"));
    final JsonArray jsonFlows = result.get("flows").asArray();
    assertThat(jsonFlows, notNullValue());
    assertThat(jsonFlows, hasFlowRule(flowRule1));
    assertThat(jsonFlows, hasFlowRule(flowRule2));
    assertThat(jsonFlows, hasFlowRule(flowRule3));
    assertThat(jsonFlows, hasFlowRule(flowRule4));
}
#method_after
@Test
public void testGetFlowByAppId() {
    setupMockFlows();
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    expect(mockFlowService.getFlowEntriesById(APP_ID)).andReturn(flowEntries).anyTimes();
    replay(mockFlowService);
    final WebTarget wt = target();
    final String response = wt.path("/flows/application/1").request().get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("flows"));
    final JsonArray jsonFlows = result.get("flows").asArray();
    assertThat(jsonFlows, notNullValue());
    assertThat(jsonFlows, hasFlowRule(flow1));
    assertThat(jsonFlows, hasFlowRule(flow2));
    assertThat(jsonFlows, hasFlowRule(flow3));
    assertThat(jsonFlows, hasFlowRule(flow4));
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response getFlowByAppId(@PathParam("appId") String appId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    final Iterable<FlowEntry> flowEntries = service.getFlowRulesById(idInstant);
    flowEntries.forEach(flow -> flowsNode.add(codec(FlowEntry.class).encode(flow, this)));
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response getFlowByAppId(@PathParam("appId") String appId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    final Iterable<FlowEntry> flowEntries = service.getFlowEntriesById(idInstant);
    flowEntries.forEach(flow -> flowsNode.add(codec(FlowEntry.class).encode(flow, this)));
    return ok(root).build();
}
#end_block

#method_before
private FlowEntry findFlowById(String appIdText, String flowId) {
    String strippedFlowId = flowId.replaceAll(OX, EMPTY);
    FlowRuleService fs = get(FlowRuleService.class);
    int appIdInt = Integer.parseInt(appIdText);
    ApplicationId appId = new DefaultApplicationId(appIdInt, DETAILS);
    Iterable<FlowEntry> entries = fs.getFlowRulesById(appId);
    for (FlowEntry entry : entries) {
        if (entry.id().toString().equals(strippedFlowId)) {
            return entry;
        }
    }
    return null;
}
#method_after
private FlowEntry findFlowById(String appIdText, String flowId) {
    String strippedFlowId = flowId.replaceAll(OX, EMPTY);
    FlowRuleService fs = get(FlowRuleService.class);
    int appIdInt = Integer.parseInt(appIdText);
    ApplicationId appId = new DefaultApplicationId(appIdInt, DETAILS);
    Iterable<FlowEntry> entries = fs.getFlowEntriesById(appId);
    for (FlowEntry entry : entries) {
        if (entry.id().toString().equals(strippedFlowId)) {
            return entry;
        }
    }
    return null;
}
#end_block

#method_before
static void setDataFromStringValue(YangType<?> type, String leafValue, Method parentSetterMethod, Object parentBuilderObject, YdtExtendedContext ydtExtendedContext) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    switch(type.getDataType()) {
        case INT8:
            parentSetterMethod.invoke(parentBuilderObject, Byte.parseByte(leafValue));
            break;
        case UINT8:
        case INT16:
            parentSetterMethod.invoke(parentBuilderObject, Short.parseShort(leafValue));
            break;
        case UINT16:
        case INT32:
            parentSetterMethod.invoke(parentBuilderObject, Integer.parseInt(leafValue));
            break;
        case UINT32:
        case INT64:
            parentSetterMethod.invoke(parentBuilderObject, Long.parseLong(leafValue));
            break;
        case UINT64:
            parentSetterMethod.invoke(parentBuilderObject, new BigInteger(leafValue));
            break;
        case EMPTY:
        case BOOLEAN:
            parentSetterMethod.invoke(parentBuilderObject, Boolean.parseBoolean(leafValue));
            break;
        case STRING:
            parentSetterMethod.invoke(parentBuilderObject, leafValue);
            break;
        case BINARY:
            parentSetterMethod.invoke(parentBuilderObject, Base64.getDecoder().decode(leafValue));
            break;
        case BITS:
            YangBits yangBits = (YangBits) type.getDataTypeExtendedInfo();
            parentSetterMethod.invoke(parentBuilderObject, getBitSetValueFromString(yangBits, leafValue));
            break;
        case DECIMAL64:
            parentSetterMethod.invoke(parentBuilderObject, new BigDecimal(leafValue));
            break;
        case DERIVED:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, false);
            break;
        case UNION:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, false);
            break;
        case LEAFREF:
            parseLeafRefTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue);
            break;
        case ENUMERATION:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, true);
            break;
        default:
            log.error(E_DATA_TYPE_NOT_SUPPORT);
    }
}
#method_after
static void setDataFromStringValue(YangType<?> type, String leafValue, Method parentSetterMethod, Object parentBuilderObject, YdtExtendedContext ydtExtendedContext) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    switch(type.getDataType()) {
        case INT8:
            parentSetterMethod.invoke(parentBuilderObject, Byte.parseByte(leafValue));
            break;
        case UINT8:
        case INT16:
            parentSetterMethod.invoke(parentBuilderObject, Short.parseShort(leafValue));
            break;
        case UINT16:
        case INT32:
            parentSetterMethod.invoke(parentBuilderObject, Integer.parseInt(leafValue));
            break;
        case UINT32:
        case INT64:
            parentSetterMethod.invoke(parentBuilderObject, Long.parseLong(leafValue));
            break;
        case UINT64:
            parentSetterMethod.invoke(parentBuilderObject, new BigInteger(leafValue));
            break;
        case EMPTY:
        case BOOLEAN:
            parentSetterMethod.invoke(parentBuilderObject, Boolean.parseBoolean(leafValue));
            break;
        case STRING:
            parentSetterMethod.invoke(parentBuilderObject, leafValue);
            break;
        case BINARY:
            byte[] value = Base64.getDecoder().decode(leafValue);
            parentSetterMethod.invoke(parentBuilderObject, value);
            break;
        case BITS:
            YangBits yangBits = (YangBits) type.getDataTypeExtendedInfo();
            parentSetterMethod.invoke(parentBuilderObject, getBitSetValueFromString(yangBits, leafValue));
            break;
        case DECIMAL64:
            parentSetterMethod.invoke(parentBuilderObject, new BigDecimal(leafValue));
            break;
        case DERIVED:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, false);
            break;
        case UNION:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, false);
            break;
        case LEAFREF:
            parseLeafRefTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue);
            break;
        case ENUMERATION:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, true);
            break;
        default:
            log.error(E_DATA_TYPE_NOT_SUPPORT);
    }
}
#end_block

#method_before
private static BitSet getBitSetValueFromString(YangBits yangBits, String leafValue) {
    String[] bitNames = leafValue.trim().split(Pattern.quote(SPACE));
    Map<String, YangBit> bitNameMap = yangBits.getBitNameMap();
    BitSet bitDataSet = new BitSet();
    YangBit bit;
    for (String bitName : bitNames) {
        bit = bitNameMap.get(bitName);
        if (bit == null) {
            throw new YobException("Unable to find corresponding bit" + " position for bit name: " + bitName);
        }
        bitDataSet.set(bit.getPosition());
    }
    return bitDataSet;
}
#method_after
private static BitSet getBitSetValueFromString(YangBits yangBits, String leafValue) {
    String[] bitNames = leafValue.trim().split(SPACE);
    Map<String, YangBit> bitNameMap = yangBits.getBitNameMap();
    BitSet bitDataSet = new BitSet();
    YangBit bit;
    for (String bitName : bitNames) {
        bit = bitNameMap.get(bitName);
        if (bit == null) {
            throw new YobException("Unable to find corresponding bit" + " position for bit : " + bitName);
        }
        bitDataSet.set(bit.getPosition());
    }
    return bitDataSet;
}
#end_block

#method_before
@Override
public void setInParent(YdtExtendedContext leafListYdtNode, YangSchemaRegistry schemaRegistry) {
    Class<?> parentBuilderClass = null;
    YangSchemaNode yangSchemaNode = leafListYdtNode.getYangSchemaNode();
    YdtExtendedContext parentYdtNode = (YdtExtendedContext) leafListYdtNode.getParent();
    YobWorkBench parentYobWorkBench = (YobWorkBench) parentYdtNode.getAppInfo(YOB);
    Set<String> valueSet = leafListYdtNode.getValueSet();
    for (String value : valueSet) {
        try {
            String setterInParent = yangSchemaNode.getJavaAttributeName();
            Object parentBuilderObject = parentYobWorkBench.getParentBuilder(leafListYdtNode, schemaRegistry);
            parentBuilderClass = parentBuilderObject.getClass();
            Field leafName = parentBuilderClass.getDeclaredField(setterInParent);
            ParameterizedType genericListType = (ParameterizedType) leafName.getGenericType();
            Class<?> genericListClass = (Class<?>) genericListType.getActualTypeArguments()[0];
            Method parentSetterMethod = parentBuilderClass.getDeclaredMethod(ADD_TO + getCapitalCase(setterInParent), genericListClass);
            JavaQualifiedTypeInfoContainer javaQualifiedType = (JavaQualifiedTypeInfoContainer) yangSchemaNode;
            YangType<?> yangType = ((YangLeafList) javaQualifiedType).getDataType();
            YobUtils.setDataFromStringValue(yangType, value, parentSetterMethod, parentBuilderObject, leafListYdtNode);
        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
            log.error(E_FAIL_TO_INVOKE_METHOD + parentBuilderClass.getName());
        }
    }
}
#method_after
@Override
public void setInParent(YdtExtendedContext leafListNode, YangSchemaRegistry schemaRegistry) {
    Class<?> parentBuilderClass = null;
    YangSchemaNode yangSchemaNode = leafListNode.getYangSchemaNode();
    YdtExtendedContext parentYdtNode = (YdtExtendedContext) leafListNode.getParent();
    YobWorkBench parentYobWorkBench = (YobWorkBench) parentYdtNode.getAppInfo(YOB);
    Set<String> valueSet = leafListNode.getValueSet();
    for (String value : valueSet) {
        try {
            String setterInParent = yangSchemaNode.getJavaAttributeName();
            Object builderObject = parentYobWorkBench.getParentBuilder(leafListNode, schemaRegistry);
            parentBuilderClass = builderObject.getClass();
            Field leafName = parentBuilderClass.getDeclaredField(setterInParent);
            ParameterizedType genericListType = (ParameterizedType) leafName.getGenericType();
            Class<?> genericListClass = (Class<?>) genericListType.getActualTypeArguments()[0];
            Method setterMethod = parentBuilderClass.getDeclaredMethod(ADD_TO + getCapitalCase(setterInParent), genericListClass);
            JavaQualifiedTypeInfoContainer javaQualifiedType = (JavaQualifiedTypeInfoContainer) yangSchemaNode;
            YangType<?> yangType = ((YangLeafList) javaQualifiedType).getDataType();
            YobUtils.setDataFromStringValue(yangType, value, setterMethod, builderObject, leafListNode);
        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
            log.error(L_FAIL_TO_INVOKE_METHOD, parentBuilderClass.getName());
            throw new YobException(E_FAIL_TO_INVOKE_METHOD + parentBuilderClass.getName());
        }
    }
}
#end_block

#method_before
@Test
public void caseInChoice() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1A1, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals(yangObject.getClass(), YmsTopologyOpParam.class);
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", topology.node().size(), 1);
    assertEquals("Node type is not DefaultNode", topology.node().get(0).getClass(), DefaultNode.class);
    Node node = topology.node().get(0);
    assertNotNull("choice1 is not set in node", node.choice1());
    assertEquals("choice 1 type is not ", node.choice1().getClass(), DefaultCase1a.class);
    Case1a case1a = (Case1a) node.choice1();
    assertNotNull("leaf1a1 is not set in case", case1a.leaf1A1());
    assertEquals("leaf1a1 type is not correct", case1a.leaf1A1().getClass(), String.class);
    assertEquals("leaf1a1 value is not correct", case1a.leaf1A1(), STR_LEAF_VALUE);
}
#method_after
@Test
public void caseInChoice() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1A1, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals("YANG object created is not topology object", YmsTopologyOpParam.class, yangObject.getClass());
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", 1, topology.node().size());
    assertEquals("Node type is not DefaultNode", DefaultNode.class, topology.node().get(0).getClass());
    Node node = topology.node().get(0);
    assertNotNull("choice1 is not set in node", node.choice1());
    assertEquals("choice 1 type is not ", DefaultCase1a.class, node.choice1().getClass());
    Case1a case1a = (Case1a) node.choice1();
    assertNotNull("leaf1a1 is not set in case", case1a.leaf1A1());
    assertEquals("leaf1a1 type is not correct", String.class, case1a.leaf1A1().getClass());
    assertEquals("leaf1a1 value is not correct", STR_LEAF_VALUE, case1a.leaf1A1());
}
#end_block

#method_before
@Test
public void caseWithMultiAttribute() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1A1, null, STR_LEAF_VALUE);
    ydtBuilder.traverseToParent();
    ydtBuilder.addLeaf(LEAF_1A2, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals(yangObject.getClass(), YmsTopologyOpParam.class);
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", topology.node().size(), 1);
    assertEquals("Node type is not DefaultNode", topology.node().get(0).getClass(), DefaultNode.class);
    Node node = topology.node().get(0);
    assertNotNull("choice1 is not set in node", node.choice1());
    assertEquals("choice 1 type is not ", node.choice1().getClass(), DefaultCase1a.class);
    Case1a case1a = (Case1a) node.choice1();
    assertNotNull("leaf1a1 is not set in case", case1a.leaf1A1());
    assertEquals("leaf1a1 type is not correct", case1a.leaf1A1().getClass(), String.class);
    assertEquals("leaf1a1 value is not correct", case1a.leaf1A1(), STR_LEAF_VALUE);
    assertNotNull("leaf1a2 is not set in case", case1a.leaf1A2());
    assertEquals("leaf1a2 type is not correct", case1a.leaf1A2().getClass(), String.class);
    assertEquals("leaf1a1 value is not correct", case1a.leaf1A1(), STR_LEAF_VALUE);
}
#method_after
@Test
public void caseWithMultiAttribute() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1A1, null, STR_LEAF_VALUE);
    ydtBuilder.traverseToParent();
    ydtBuilder.addLeaf(LEAF_1A2, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals("YANG object created is not topology object", YmsTopologyOpParam.class, yangObject.getClass());
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", 1, topology.node().size());
    assertEquals("Node type is not DefaultNode", DefaultNode.class, topology.node().get(0).getClass());
    Node node = topology.node().get(0);
    assertNotNull("choice1 is not set in node", node.choice1());
    assertEquals("choice 1 type is not ", DefaultCase1a.class, node.choice1().getClass());
    Case1a case1a = (Case1a) node.choice1();
    assertNotNull("leaf1a1 is not set in case", case1a.leaf1A1());
    assertEquals("leaf1a1 type is not correct", String.class, case1a.leaf1A1().getClass());
    assertEquals("leaf1a1 value is not correct", STR_LEAF_VALUE, case1a.leaf1A1());
    assertNotNull("leaf1a2 is not set in case", case1a.leaf1A2());
    assertEquals("leaf1a2 type is not correct", String.class, case1a.leaf1A2().getClass());
    assertEquals("leaf1a1 value is not correct", STR_LEAF_VALUE, case1a.leaf1A1());
}
#end_block

#method_before
@Test
public void recursiveChoice() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1BIA, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals(yangObject.getClass(), YmsTopologyOpParam.class);
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", topology.node().size(), 1);
    assertEquals("Node type is not DefaultNode", topology.node().get(0).getClass(), DefaultNode.class);
    Node node = topology.node().get(0);
    assertNotNull("Choice 1 is not set in Node", node.choice1());
    assertEquals("Choice 1 is not of type DefaultCase1b", node.choice1().getClass(), DefaultCase1b.class);
    Case1b case1b = (Case1b) node.choice1();
    assertNotNull("Case1b does not have child choice1b ", case1b.choice1b());
    assertEquals("choice1b is not of type DefaultCase1Bi", case1b.choice1b().getClass(), DefaultCase1Bi.class);
    Case1Bi case1Bi = (Case1Bi) case1b.choice1b();
    assertNotNull("leaf1bia is not set", case1Bi.leaf1Bia());
    assertEquals("leaf1bia type is not string", case1Bi.leaf1Bia().getClass(), String.class);
    assertEquals("leaf1bia value is wrong", case1Bi.leaf1Bia(), STR_LEAF_VALUE);
}
#method_after
@Test
public void recursiveChoice() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1BIA, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals("YANG object created is not topology object", YmsTopologyOpParam.class, yangObject.getClass());
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", 1, topology.node().size());
    assertEquals("Node type is not DefaultNode", DefaultNode.class, topology.node().get(0).getClass());
    Node node = topology.node().get(0);
    assertNotNull("Choice 1 is not set in Node", node.choice1());
    assertEquals("Choice 1 is not of type DefaultCase1b", DefaultCase1b.class, node.choice1().getClass());
    Case1b case1b = (Case1b) node.choice1();
    assertNotNull("Case1b does not have child choice1b ", case1b.choice1b());
    assertEquals("choice1b is not of type DefaultCase1Bi", DefaultCase1Bi.class, case1b.choice1b().getClass());
    Case1Bi case1Bi = (Case1Bi) case1b.choice1b();
    assertNotNull("leaf1bia is not set", case1Bi.leaf1Bia());
    assertEquals("leaf1bia type is not string", String.class, case1Bi.leaf1Bia().getClass());
    assertEquals("leaf1bia value is wrong", STR_LEAF_VALUE, case1Bi.leaf1Bia());
}
#end_block

#method_before
@Test
public void recursiveChoiceWithMultipleAttribute() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1BIA, null, STR_LEAF_VALUE);
    ydtBuilder.traverseToParent();
    ydtBuilder.addLeaf(LEAF_1BIB, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals(yangObject.getClass(), YmsTopologyOpParam.class);
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", topology.node().size(), 1);
    assertEquals("Node type is not DefaultNode", topology.node().get(0).getClass(), DefaultNode.class);
    Node node = topology.node().get(0);
    assertNotNull("Choice 1 is not set in Node", node.choice1());
    assertEquals("Choice 1 is not of type DefaultCase1b", node.choice1().getClass(), DefaultCase1b.class);
    Case1b case1b = (Case1b) node.choice1();
    assertNotNull("Case1b does not have child choice1b ", case1b.choice1b());
    assertEquals("choice1b is not of type DefaultCase1Bi", case1b.choice1b().getClass(), DefaultCase1Bi.class);
    Case1Bi case1Bi = (Case1Bi) case1b.choice1b();
    assertNotNull("leaf1bia is not set", case1Bi.leaf1Bia());
    assertEquals("leaf1bia type is not string", case1Bi.leaf1Bia().getClass(), String.class);
    assertEquals("leaf1bia value is wrong", case1Bi.leaf1Bia(), STR_LEAF_VALUE);
    assertNotNull("leaf1bib is not set", case1Bi.leaf1Bib());
    assertEquals("leaf1bia type is not string", case1Bi.leaf1Bib().getClass(), String.class);
    assertEquals("leaf1bia value is wrong", case1Bi.leaf1Bib(), STR_LEAF_VALUE);
}
#method_after
@Test
public void recursiveChoiceWithMultipleAttribute() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(LEAF_1BIA, null, STR_LEAF_VALUE);
    ydtBuilder.traverseToParent();
    ydtBuilder.addLeaf(LEAF_1BIB, null, STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull(yangObject);
    assertEquals("YANG object created is not topology object", YmsTopologyOpParam.class, yangObject.getClass());
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("Failed to build the object", topology.node());
    assertEquals("Single node entry is expected", 1, topology.node().size());
    assertEquals("Node type is not DefaultNode", DefaultNode.class, topology.node().get(0).getClass());
    Node node = topology.node().get(0);
    assertNotNull("Choice 1 is not set in Node", node.choice1());
    assertEquals("Choice 1 is not of type DefaultCase1b", DefaultCase1b.class, node.choice1().getClass());
    Case1b case1b = (Case1b) node.choice1();
    assertNotNull("Case1b does not have child choice1b ", case1b.choice1b());
    assertEquals("choice1b is not of type DefaultCase1Bi", DefaultCase1Bi.class, case1b.choice1b().getClass());
    Case1Bi case1Bi = (Case1Bi) case1b.choice1b();
    assertNotNull("leaf1bia is not set", case1Bi.leaf1Bia());
    assertEquals("leaf1bia type is not string", String.class, case1Bi.leaf1Bia().getClass());
    assertEquals("leaf1bia value is wrong", STR_LEAF_VALUE, case1Bi.leaf1Bia());
    assertNotNull("leaf1bib is not set", case1Bi.leaf1Bib());
    assertEquals("leaf1bia type is not string", String.class, case1Bi.leaf1Bib().getClass());
    assertEquals("leaf1bia value is wrong", STR_LEAF_VALUE, case1Bi.leaf1Bib());
}
#end_block

#method_before
static void setDataFromStringValue(YangType<?> type, String leafValue, Method parentSetterMethod, Object parentBuilderObject, YdtExtendedContext ydtExtendedContext) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    switch(type.getDataType()) {
        case INT8:
            {
                parentSetterMethod.invoke(parentBuilderObject, Byte.parseByte(leafValue));
                break;
            }
        case UINT8:
        case INT16:
            {
                parentSetterMethod.invoke(parentBuilderObject, Short.parseShort(leafValue));
                break;
            }
        case UINT16:
        case INT32:
            {
                parentSetterMethod.invoke(parentBuilderObject, Integer.parseInt(leafValue));
                break;
            }
        case UINT32:
        case INT64:
            {
                parentSetterMethod.invoke(parentBuilderObject, Long.parseLong(leafValue));
                break;
            }
        case UINT64:
            {
                parentSetterMethod.invoke(parentBuilderObject, new BigInteger(leafValue));
                break;
            }
        case EMPTY:
        case BOOLEAN:
            {
                parentSetterMethod.invoke(parentBuilderObject, Boolean.parseBoolean(leafValue));
                break;
            }
        case STRING:
            {
                parentSetterMethod.invoke(parentBuilderObject, leafValue);
                break;
            }
        case BINARY:
            {
                parentSetterMethod.invoke(parentBuilderObject, new YangBinary(leafValue));
                break;
            }
        case BITS:
            {
                // TODO
                break;
            }
        case DECIMAL64:
            {
                parentSetterMethod.invoke(parentBuilderObject, new BigDecimal(leafValue));
                break;
            }
        case DERIVED:
            {
                parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, false);
                break;
            }
        case UNION:
            {
                // TODO
                break;
            }
        case LEAFREF:
            {
                // TODO
                break;
            }
        case ENUMERATION:
            {
                parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, true);
                break;
            }
        default:
            {
                log.error(E_DATA_TYPE_NOT_SUPPORT);
            }
    }
}
#method_after
static void setDataFromStringValue(YangType<?> type, String leafValue, Method parentSetterMethod, Object parentBuilderObject, YdtExtendedContext ydtExtendedContext) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    switch(type.getDataType()) {
        case INT8:
            parentSetterMethod.invoke(parentBuilderObject, Byte.parseByte(leafValue));
            break;
        case UINT8:
        case INT16:
            parentSetterMethod.invoke(parentBuilderObject, Short.parseShort(leafValue));
            break;
        case UINT16:
        case INT32:
            parentSetterMethod.invoke(parentBuilderObject, Integer.parseInt(leafValue));
            break;
        case UINT32:
        case INT64:
            parentSetterMethod.invoke(parentBuilderObject, Long.parseLong(leafValue));
            break;
        case UINT64:
            parentSetterMethod.invoke(parentBuilderObject, new BigInteger(leafValue));
            break;
        case EMPTY:
        case BOOLEAN:
            parentSetterMethod.invoke(parentBuilderObject, Boolean.parseBoolean(leafValue));
            break;
        case STRING:
            parentSetterMethod.invoke(parentBuilderObject, leafValue);
            break;
        case BINARY:
            parentSetterMethod.invoke(parentBuilderObject, new YangBinary(leafValue));
            break;
        case BITS:
            // TODO
            break;
        case DECIMAL64:
            parentSetterMethod.invoke(parentBuilderObject, new BigDecimal(leafValue));
            break;
        case DERIVED:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, false);
            break;
        case UNION:
            // TODO
            break;
        case LEAFREF:
            // TODO
            break;
        case ENUMERATION:
            parseDerivedTypeInfo(ydtExtendedContext, parentSetterMethod, parentBuilderObject, leafValue, true);
            break;
        default:
            log.error(E_DATA_TYPE_NOT_SUPPORT);
    }
}
#end_block

#method_before
private static void parseDerivedTypeInfo(YdtExtendedContext ydtExtendedContext, Method parentSetterMethod, Object parentBuilderObject, String leafValue, boolean isEnum) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Constructor<?> childConstructor = null;
    Object childValue = null;
    Object childObject = null;
    Method childMethod = null;
    YangSchemaNode yangJavaModule = ydtExtendedContext.getYangSchemaNode();
    String packageName = yangJavaModule.getJavaPackage();
    String className = getCapitalCase(yangJavaModule.getJavaClassNameOrBuiltInType());
    String qualifiedClassName = packageName + PERIOD + className;
    ClassLoader classLoader = getClassLoader(null, qualifiedClassName, ydtExtendedContext, null);
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(E_FAIL_TO_LOAD_CLASS + packageName + PERIOD + className);
    }
    if (!isEnum) {
        if (childSetClass != null) {
            childConstructor = childSetClass.getDeclaredConstructor();
        }
        if (childConstructor != null) {
            childConstructor.setAccessible(true);
        }
        try {
            if (childConstructor != null) {
                childObject = childConstructor.newInstance();
            }
        } catch (InstantiationException e) {
            log.error(E_FAIL_TO_LOAD_CONSTRUCTOR + className);
        }
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
        }
    } else {
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(OF, String.class);
        }
    // leafValue = JavaIdentifierSyntax.getEnumJavaAttribute(leafValue);
    // leafValue = leafValue.toUpperCase();
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(childObject, leafValue);
    }
    parentSetterMethod.invoke(parentBuilderObject, childValue);
}
#method_after
private static void parseDerivedTypeInfo(YdtExtendedContext ydtExtendedContext, Method parentSetterMethod, Object parentBuilderObject, String leafValue, boolean isEnum) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
    Class<?> childSetClass = null;
    Constructor<?> childConstructor = null;
    Object childValue = null;
    Object childObject = null;
    Method childMethod = null;
    YangSchemaNode yangJavaModule = ydtExtendedContext.getYangSchemaNode();
    String qualifiedClassName = yangJavaModule.getJavaPackage() + PERIOD + getCapitalCase(yangJavaModule.getJavaClassNameOrBuiltInType());
    ClassLoader classLoader = getClassLoader(null, qualifiedClassName, ydtExtendedContext, null);
    try {
        childSetClass = classLoader.loadClass(qualifiedClassName);
    } catch (ClassNotFoundException e) {
        log.error(L_FAIL_TO_LOAD_CLASS, qualifiedClassName);
    }
    if (!isEnum) {
        if (childSetClass != null) {
            childConstructor = childSetClass.getDeclaredConstructor();
        }
        if (childConstructor != null) {
            childConstructor.setAccessible(true);
        }
        try {
            if (childConstructor != null) {
                childObject = childConstructor.newInstance();
            }
        } catch (InstantiationException e) {
            log.error(E_FAIL_TO_LOAD_CONSTRUCTOR, qualifiedClassName);
        }
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(FROM_STRING, String.class);
        }
    } else {
        if (childSetClass != null) {
            childMethod = childSetClass.getDeclaredMethod(OF, String.class);
        }
    // leafValue = JavaIdentifierSyntax.getEnumJavaAttribute(leafValue);
    // leafValue = leafValue.toUpperCase();
    }
    if (childMethod != null) {
        childValue = childMethod.invoke(childObject, leafValue);
    }
    parentSetterMethod.invoke(parentBuilderObject, childValue);
}
#end_block

#method_before
static ClassLoader getClassLoader(YangSchemaRegistry registry, String qualifiedClassName, YdtExtendedContext curNode, YdtExtendedContext rootNode) {
    if (rootNode != null && curNode == rootNode) {
        YangSchemaNode curSchemaNode = curNode.getYangSchemaNode();
        while (!(curSchemaNode instanceof RpcNotificationContainer)) {
            curNode = (YdtExtendedContext) curNode.getParent();
            if (curNode == null) {
                throw new YobException(E_INVALID_DATA_TREE);
            }
            curSchemaNode = curNode.getYangSchemaNode();
        }
        Class<?> regClass = registry.getRegisteredClass(curSchemaNode, qualifiedClassName);
        return regClass.getClassLoader();
    } else {
        YdtExtendedContext parent = (YdtExtendedContext) curNode.getParent();
        YobWorkBench parentBuilderContainer = (YobWorkBench) parent.getAppInfo(YOB);
        Object parentObj = parentBuilderContainer.getParentBuilder(curNode, registry);
        return parentObj.getClass().getClassLoader();
    }
}
#method_after
static ClassLoader getClassLoader(YangSchemaRegistry registry, String qualifiedClassName, YdtExtendedContext curNode, YdtExtendedContext rootNode) {
    if (rootNode != null && curNode == rootNode) {
        YangSchemaNode curSchemaNode = curNode.getYangSchemaNode();
        while (!(curSchemaNode instanceof RpcNotificationContainer)) {
            curNode = (YdtExtendedContext) curNode.getParent();
            if (curNode == null) {
                throw new YobException(E_INVALID_DATA_TREE);
            }
            curSchemaNode = curNode.getYangSchemaNode();
        }
        Class<?> regClass = registry.getRegisteredClass(curSchemaNode, qualifiedClassName);
        return regClass.getClassLoader();
    }
    YdtExtendedContext parent = (YdtExtendedContext) curNode.getParent();
    YobWorkBench parentBuilderContainer = (YobWorkBench) parent.getAppInfo(YOB);
    Object parentObj = parentBuilderContainer.getParentBuilder(curNode, registry);
    return parentObj.getClass().getClassLoader();
}
#end_block

#method_before
@Test
public void augmentedLeaf() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(ROUTER_ID, "urn:ip:topo", STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull("Fail to create augmented YANG object", yangObject);
    assertEquals("invalid augmented node created", yangObject.getClass(), YmsTopologyOpParam.class);
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("failed to build augmented node", topology.node());
    assertEquals("Single node entry is expected", topology.node().size(), 1);
    assertEquals("Node type is not DefaultNode", topology.node().get(0).getClass(), DefaultNode.class);
    DefaultNode node = (DefaultNode) topology.node().get(0);
    assertNotNull("Augmented info is missing", node.yangAugmentedInfo(AugmentedTopoNode.class));
    assertEquals("Augmented class is incorrect", node.yangAugmentedInfo(AugmentedTopoNode.class).getClass(), DefaultAugmentedTopoNode.class);
    DefaultAugmentedTopoNode augmentedNode = (DefaultAugmentedTopoNode) node.yangAugmentedInfo(AugmentedTopoNode.class);
    assertThat("Augmented leaf value is incorrect", augmentedNode.routerId(), is(STR_LEAF_VALUE));
}
#method_after
@Test
public void augmentedLeaf() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(ROUTER_ID, "urn:ip:topo", STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull("Fail to create augmented YANG object", yangObject);
    assertEquals("invalid augmented node created", YmsTopologyOpParam.class, yangObject.getClass());
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("failed to build augmented node", topology.node());
    assertEquals("Single node entry is expected", 1, topology.node().size());
    assertEquals("Node type is not DefaultNode", DefaultNode.class, topology.node().get(0).getClass());
    DefaultNode node = (DefaultNode) topology.node().get(0);
    assertNotNull("Augmented info is missing", node.yangAugmentedInfo(AugmentedTopoNode.class));
    assertEquals("Augmented class is incorrect", DefaultAugmentedTopoNode.class, node.yangAugmentedInfo(AugmentedTopoNode.class).getClass());
    DefaultAugmentedTopoNode augmentedNode = (DefaultAugmentedTopoNode) node.yangAugmentedInfo(AugmentedTopoNode.class);
    assertThat("Augmented leaf value is incorrect", augmentedNode.routerId(), is(STR_LEAF_VALUE));
}
#end_block

#method_before
@Test
public void augmentedLeaves() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(ROUTER_ID, "urn:ip:topo", STR_LEAF_VALUE);
    ydtBuilder.traverseToParent();
    ydtBuilder.addLeaf(ROUTER_IP, "urn:ip:topo", STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull("Fail to create augmented YANG object", yangObject);
    assertEquals("invalid augmented node created", yangObject.getClass(), YmsTopologyOpParam.class);
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("failed to build augmented node", topology.node());
    assertEquals("Single node entry is expected", topology.node().size(), 1);
    assertEquals("Node type is not DefaultNode", topology.node().get(0).getClass(), DefaultNode.class);
    DefaultNode node = (DefaultNode) topology.node().get(0);
    assertNotNull("Augmented info is missing", node.yangAugmentedInfo(AugmentedTopoNode.class));
    assertEquals("Augmented class is incorrect", node.yangAugmentedInfo(AugmentedTopoNode.class).getClass(), DefaultAugmentedTopoNode.class);
    DefaultAugmentedTopoNode augmentedNode = (DefaultAugmentedTopoNode) node.yangAugmentedInfo(AugmentedTopoNode.class);
    assertThat("Augmented router id is incorrect", augmentedNode.routerId(), is(STR_LEAF_VALUE));
    assertThat("Augmented router ip is incorrect", augmentedNode.routerIp(), is(STR_LEAF_VALUE));
}
#method_after
@Test
public void augmentedLeaves() throws IOException {
    YangRequestWorkBench ydtBuilder = new YangRequestWorkBench(ROOT_DATA_RESOURCE, null, null, utils.schemaRegistry(), true);
    ydtBuilder.addChild(TOPOLOGY, null, NONE);
    ydtBuilder.addChild(NODE, null);
    ydtBuilder.addLeaf(ROUTER_ID, "urn:ip:topo", STR_LEAF_VALUE);
    ydtBuilder.traverseToParent();
    ydtBuilder.addLeaf(ROUTER_IP, "urn:ip:topo", STR_LEAF_VALUE);
    YdtContext logicalRoot = ydtBuilder.getRootNode();
    YdtExtendedContext appRoot = (YdtExtendedContext) logicalRoot.getFirstChild();
    DefaultYobBuilder yobBuilder = new DefaultYobBuilder();
    Object yangObject = yobBuilder.getYangObject(appRoot, utils.schemaRegistry());
    assertNotNull("Fail to create augmented YANG object", yangObject);
    assertEquals("invalid augmented node created", YmsTopologyOpParam.class, yangObject.getClass());
    YmsTopologyOpParam topology = (YmsTopologyOpParam) yangObject;
    assertNotNull("failed to build augmented node", topology.node());
    assertEquals("Single node entry is expected", 1, topology.node().size());
    assertEquals("Node type is not DefaultNode", DefaultNode.class, topology.node().get(0).getClass());
    DefaultNode node = (DefaultNode) topology.node().get(0);
    assertNotNull("Augmented info is missing", node.yangAugmentedInfo(AugmentedTopoNode.class));
    assertEquals("Augmented class is incorrect", DefaultAugmentedTopoNode.class, node.yangAugmentedInfo(AugmentedTopoNode.class).getClass());
    DefaultAugmentedTopoNode augmentedNode = (DefaultAugmentedTopoNode) node.yangAugmentedInfo(AugmentedTopoNode.class);
    assertThat("Augmented router id is incorrect", augmentedNode.routerId(), is(STR_LEAF_VALUE));
    assertThat("Augmented router ip is incorrect", augmentedNode.routerIp(), is(STR_LEAF_VALUE));
}
#end_block

#method_before
public void createBuilder(YdtExtendedContext curNode, YdtExtendedContext rootNode, YangSchemaRegistry registry) {
    String setterMethodName = null;
    YangSchemaNode yangSchemaNode = curNode.getYangSchemaNode();
    String qualifiedClassName = getQualifiedDefaultClass(yangSchemaNode);
    ClassLoader classLoader = YobUtils.getClassLoader(registry, qualifiedClassName, curNode, rootNode);
    if (curNode != rootNode) {
        setterMethodName = yangSchemaNode.getJavaAttributeName();
    }
    Object workBench = new YobWorkBench(yangSchemaNode, classLoader, qualifiedClassName, setterMethodName);
    curNode.addAppInfo(YOB, workBench);
}
#method_after
public void createBuilder(YdtExtendedContext curNode, YdtExtendedContext rootNode, YangSchemaRegistry registry) {
    String setterName = null;
    YangSchemaNode node = curNode.getYangSchemaNode();
    String qualName = getQualifiedDefaultClass(node);
    ClassLoader classLoader = YobUtils.getClassLoader(registry, qualName, curNode, rootNode);
    if (curNode != rootNode) {
        setterName = node.getJavaAttributeName();
    }
    Object workBench = new YobWorkBench(node, classLoader, qualName, setterName);
    curNode.addAppInfo(YOB, workBench);
}
#end_block

#method_before
void buildObject(YdtExtendedContext ydtNode) {
    buildNonSchemaAttributes(ydtNode);
    Object builderObject = builderOrBuiltObject.getBuilderObject();
    Class<?> defaultBuilderClass = builderOrBuiltObject.yangBuilderClass;
    // set the operation type
    setOperationType(ydtNode);
    // Invoking the build method to get built object from build method.
    try {
        Method method = defaultBuilderClass.getDeclaredMethod(BUILD);
        if (method == null) {
            log.error(E_FAIL_TO_GET_METHOD + defaultBuilderClass.getName());
            throw new YobException(E_FAIL_TO_GET_METHOD + defaultBuilderClass.getName());
        }
        Object builtObject = method.invoke(builderObject);
        // The built object will be maintained in ydt context and same will
        // be used while setting into parent method.
        builderOrBuiltObject.setBuiltObject(builtObject);
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
        log.error(E_FAIL_TO_BUILD + defaultBuilderClass.getName());
        throw new YobException(E_FAIL_TO_BUILD + defaultBuilderClass.getName());
    }
}
#method_after
void buildObject(YdtExtendedContext ydtNode) {
    buildNonSchemaAttributes(ydtNode);
    Object builderObject = builderOrBuiltObject.getBuilderObject();
    Class<?> defaultBuilderClass = builderOrBuiltObject.yangBuilderClass;
    // set the operation type
    setOperationType(ydtNode);
    // Invoking the build method to get built object from build method.
    try {
        Method method = defaultBuilderClass.getDeclaredMethod(BUILD);
        if (method == null) {
            log.error(L_FAIL_TO_GET_METHOD, defaultBuilderClass.getName());
            throw new YobException(E_FAIL_TO_GET_METHOD + defaultBuilderClass.getName());
        }
        Object builtObject = method.invoke(builderObject);
        // The built object will be maintained in ydt context and same will
        // be used while setting into parent method.
        builderOrBuiltObject.setBuiltObject(builtObject);
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
        log.error(L_FAIL_TO_BUILD, defaultBuilderClass.getName());
        throw new YobException(E_FAIL_TO_BUILD + defaultBuilderClass.getName());
    }
}
#end_block

#method_before
private static void setObjectInBuilder(Object builder, String setter, YdtType nodeType, Object attribute) {
    Class<?> builderClass = builder.getClass();
    String builderClassName = builderClass.getName();
    try {
        Class<?> type = null;
        Field fieldName = builderClass.getDeclaredField(setter);
        if (fieldName != null) {
            type = fieldName.getType();
        }
        Method method;
        if (nodeType == MULTI_INSTANCE_NODE) {
            if (fieldName != null) {
                ParameterizedType genericTypes = (ParameterizedType) fieldName.getGenericType();
                type = (Class<?>) genericTypes.getActualTypeArguments()[0];
            }
            method = builderClass.getDeclaredMethod(ADD_TO + getCapitalCase(setter), type);
        } else {
            method = builderClass.getDeclaredMethod(setter, type);
        }
        method.invoke(builder, attribute);
    } catch (NoSuchFieldException e) {
        log.error(E_FAIL_TO_GET_FIELD + builderClassName);
        throw new YobException(E_FAIL_TO_GET_FIELD + builderClassName);
    } catch (NoSuchMethodException e) {
        log.error(E_FAIL_TO_GET_METHOD + builderClassName);
        throw new YobException(E_FAIL_TO_GET_METHOD + builderClassName);
    } catch (InvocationTargetException | IllegalAccessException e) {
        log.error(E_FAIL_TO_INVOKE_METHOD + builderClassName);
        throw new YobException(E_FAIL_TO_INVOKE_METHOD + builderClassName);
    }
}
#method_after
private static void setObjectInBuilder(Object builder, String setter, YdtType nodeType, Object attribute) {
    Class<?> builderClass = builder.getClass();
    String builderClassName = builderClass.getName();
    try {
        Class<?> type = null;
        Field fieldName = builderClass.getDeclaredField(setter);
        if (fieldName != null) {
            type = fieldName.getType();
        }
        Method method;
        if (nodeType == MULTI_INSTANCE_NODE) {
            if (fieldName != null) {
                ParameterizedType genericTypes = (ParameterizedType) fieldName.getGenericType();
                type = (Class<?>) genericTypes.getActualTypeArguments()[0];
            }
            method = builderClass.getDeclaredMethod(ADD_TO + getCapitalCase(setter), type);
        } else {
            method = builderClass.getDeclaredMethod(setter, type);
        }
        method.invoke(builder, attribute);
    } catch (NoSuchFieldException e) {
        log.error(L_FAIL_TO_GET_FIELD, builderClassName);
        throw new YobException(E_FAIL_TO_GET_FIELD + builderClassName);
    } catch (NoSuchMethodException e) {
        log.error(L_FAIL_TO_GET_METHOD, builderClassName);
        throw new YobException(E_FAIL_TO_GET_METHOD + builderClassName);
    } catch (InvocationTargetException | IllegalAccessException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, builderClassName);
        throw new YobException(E_FAIL_TO_INVOKE_METHOD + builderClassName);
    }
}
#end_block

#method_before
private static void addInAugmentation(Object builder, String className, Object instance) {
    Class<?>[] interfaces = instance.getClass().getInterfaces();
    if (interfaces == null) {
        throw new YobException(E_FAIL_TO_LOAD_CLASS + className);
    }
    int i;
    for (i = 0; i < interfaces.length; i++) {
        if (interfaces[i].getName().equals(className)) {
            break;
        }
    }
    if (i == interfaces.length) {
        throw new YobException(E_FAIL_TO_LOAD_CLASS + className);
    }
    Class<?> builderClass = builder.getClass();
    String builderClassName = builderClass.getName();
    try {
        Method method = builderClass.getDeclaredMethod(ADD_AUGMENT_METHOD, Object.class, Class.class);
        method.invoke(builder, instance, interfaces[i]);
    } catch (NoSuchMethodException e) {
        log.error(E_FAIL_TO_GET_METHOD + builderClassName);
        throw new YobException(E_FAIL_TO_GET_METHOD + builderClassName);
    } catch (InvocationTargetException | IllegalAccessException e) {
        log.error(E_FAIL_TO_INVOKE_METHOD + builderClassName);
        throw new YobException(E_FAIL_TO_INVOKE_METHOD + builderClassName);
    }
}
#method_after
private static void addInAugmentation(Object builder, String className, Object instance) {
    Class<?>[] interfaces = instance.getClass().getInterfaces();
    if (interfaces == null) {
        throw new YobException(E_FAIL_TO_LOAD_CLASS + className);
    }
    int i;
    for (i = 0; i < interfaces.length; i++) {
        if (interfaces[i].getName().equals(className)) {
            break;
        }
    }
    if (i == interfaces.length) {
        throw new YobException(E_FAIL_TO_LOAD_CLASS + className);
    }
    Class<?> builderClass = builder.getClass();
    String builderClassName = builderClass.getName();
    try {
        Method method = builderClass.getDeclaredMethod(ADD_AUGMENT_METHOD, Object.class, Class.class);
        method.invoke(builder, instance, interfaces[i]);
    } catch (NoSuchMethodException e) {
        log.error(L_FAIL_TO_GET_METHOD, builderClassName);
        throw new YobException(E_FAIL_TO_GET_METHOD + builderClassName);
    } catch (InvocationTargetException | IllegalAccessException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, builderClassName);
        throw new YobException(E_FAIL_TO_INVOKE_METHOD + builderClassName);
    }
}
#end_block

#method_before
@Override
public void setInParent(YdtExtendedContext leafNode, YangSchemaRegistry schemaRegistry) {
    Class<?> parentBuilderClass = null;
    try {
        YangSchemaNode schemaNode = leafNode.getYangSchemaNode();
        String setterInParent = schemaNode.getJavaAttributeName();
        YdtExtendedContext parentNode = (YdtExtendedContext) leafNode.getParent();
        YobWorkBench workBench = (YobWorkBench) parentNode.getAppInfo(YOB);
        Object parentBuilderObject = workBench.getParentBuilder(leafNode, schemaRegistry);
        parentBuilderClass = parentBuilderObject.getClass();
        Field leafName = parentBuilderClass.getDeclaredField(setterInParent);
        Method parentSetterMethod = parentBuilderClass.getDeclaredMethod(setterInParent, leafName.getType());
        YangType<?> yangType = ((YangLeaf) schemaNode).getDataType();
        YobUtils.setDataFromStringValue(yangType, leafNode.getValue(), parentSetterMethod, parentBuilderObject, leafNode);
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
        log.error(E_FAIL_TO_INVOKE_METHOD + parentBuilderClass.getName());
    }
}
#method_after
@Override
public void setInParent(YdtExtendedContext leafNode, YangSchemaRegistry schemaRegistry) {
    Class<?> builderClass = null;
    try {
        YangSchemaNode schemaNode = leafNode.getYangSchemaNode();
        String setterInParent = schemaNode.getJavaAttributeName();
        YdtExtendedContext parentNode = (YdtExtendedContext) leafNode.getParent();
        YobWorkBench workBench = (YobWorkBench) parentNode.getAppInfo(YOB);
        Object builderObject = workBench.getParentBuilder(leafNode, schemaRegistry);
        builderClass = builderObject.getClass();
        Field leafName = builderClass.getDeclaredField(setterInParent);
        Method setterMethod = builderClass.getDeclaredMethod(setterInParent, leafName.getType());
        YangType<?> yangType = ((YangLeaf) schemaNode).getDataType();
        YobUtils.setDataFromStringValue(yangType, leafNode.getValue(), setterMethod, builderObject, leafNode);
    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | NoSuchFieldException e) {
        log.error(L_FAIL_TO_INVOKE_METHOD, builderClass.getName());
        throw new YobException(E_FAIL_TO_INVOKE_METHOD + builderClass.getName());
    }
}
#end_block

#method_before
@Override
public void registerApplication(Object appObject, Class<?> serviceClass) {
    BundleContext bundleContext = getBundle(serviceClass).getBundleContext();
    String jarPath = getJarPathFromBundleLocation(bundleContext.getBundle().getLocation(), bundleContext.getProperty(USER_DIRECTORY));
    // process application registration.
    processRegistration(serviceClass, appObject, jarPath);
}
#method_after
@Override
public void registerApplication(Object appObject, Class<?> serviceClass) {
    BundleContext bundleContext = getBundle(serviceClass).getBundleContext();
    String jarPath = getJarPathFromBundleLocation(bundleContext.getBundle().getLocation(), bundleContext.getProperty(USER_DIRECTORY));
    processRegistration(serviceClass, appObject, jarPath);
}
#end_block

#method_before
@Override
public void registerService(Object manager, Class<?> service, List<String> features) {
    // perform registration of service
    schemaRegistryExecutor.execute(() -> {
        schemaRegistry.registerApplication(manager, service);
        // process notification registration.
        processNotificationRegistration(service, manager);
    });
// TODO implementation based on supported features.
}
#method_after
@Override
public void registerService(Object manager, Class<?> service, List<String> features) {
    schemaRegistryExecutor.execute(() -> {
        schemaRegistry.registerApplication(manager, service);
        processNotificationRegistration(service, manager);
    });
// TODO implementation based on supported features.
}
#end_block

#method_before
public static DeviceDescription parseJuniperDescription(DeviceId deviceId, HierarchicalConfiguration sysInfoCfg, String chassisText) {
    String hw = "UNKNOWN";
    String sw = "UNKNOWN";
    String serial = "UNKNOWN";
    List<HierarchicalConfiguration> list = sysInfoCfg.configurationsAt("system-information");
    for (HierarchicalConfiguration info : list) {
        hw = info.getString("hardware-model");
        sw = info.getString("os-name") + " " + info.getString("os-version");
        serial = info.getString("serial-number");
    }
    String patternString = ".*Private base address\\s*([:,0-9,a-f,A-F]*).*";
    Pattern pattern = Pattern.compile(patternString, Pattern.DOTALL);
    Matcher matcher = pattern.matcher(chassisText);
    if (matcher.lookingAt()) {
        String chassis = matcher.group(1);
        MacAddress chassisMac = MacAddress.valueOf(chassis);
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.ROUTER, "JUNIPER", hw, sw, serial, new ChassisId(chassisMac.toLong()), DefaultAnnotations.EMPTY);
    }
    return new DefaultDeviceDescription(deviceId.uri(), Device.Type.ROUTER, "JUNIPER", hw, sw, serial, null, DefaultAnnotations.EMPTY);
}
#method_after
public static DeviceDescription parseJuniperDescription(DeviceId deviceId, HierarchicalConfiguration sysInfoCfg, String chassisText) {
    HierarchicalConfiguration info = sysInfoCfg.configurationAt(SYS_INFO);
    String hw = info.getString(HW_MODEL) == null ? UNKNOWN : info.getString(HW_MODEL);
    String sw = UNKNOWN;
    if (info.getString(OS_NAME) != null || info.getString(OS_VER) != null) {
        sw = info.getString(OS_NAME) + " " + info.getString(OS_VER);
    }
    String serial = info.getString(SER_NUM) == null ? UNKNOWN : info.getString(SER_NUM);
    Matcher matcher = ADD_PATTERN.matcher(chassisText);
    if (matcher.lookingAt()) {
        String chassis = matcher.group(1);
        MacAddress chassisMac = MacAddress.valueOf(chassis);
        return new DefaultDeviceDescription(deviceId.uri(), ROUTER, JUNIPER, hw, sw, serial, new ChassisId(chassisMac.toLong()), DefaultAnnotations.EMPTY);
    }
    return new DefaultDeviceDescription(deviceId.uri(), ROUTER, JUNIPER, hw, sw, serial, null, DefaultAnnotations.EMPTY);
}
#end_block

#method_before
public static List<PortDescription> parseJuniperPorts(HierarchicalConfiguration cfg) {
    List<PortDescription> portDescriptions = Lists.newArrayList();
    List<HierarchicalConfiguration> subtrees = cfg.configurationsAt("interface-information");
    for (HierarchicalConfiguration interfInfo : subtrees) {
        List<HierarchicalConfiguration> interfaceTree = interfInfo.configurationsAt("physical-interface");
        for (HierarchicalConfiguration interf : interfaceTree) {
            if (interf != null) {
                if (interf.getString("if-type") != null && interf.getString("speed") != null) {
                    if (interf.getString("if-type").contains("Ethernet") && interf.getString("speed").contains("mbps")) {
                        portDescriptions.add(parseDefaultPort(interf));
                    }
                } else if (interf.getString("logical-interface.encapsulation") != null && !interf.getString("name").contains("pfe") && interf.getString("logical-interface.encapsulation").contains("ENET2")) {
                    portDescriptions.add(parseLogicalPort(interf));
                } else if (interf.getString("name").contains("lo")) {
                    portDescriptions.add(parseLoopback(interf));
                }
            }
        }
    }
    return portDescriptions;
}
#method_after
public static List<PortDescription> parseJuniperPorts(HierarchicalConfiguration cfg) {
    // This methods ignores some internal ports
    List<PortDescription> portDescriptions = Lists.newArrayList();
    List<HierarchicalConfiguration> subtrees = cfg.configurationsAt(IF_INFO);
    for (HierarchicalConfiguration interfInfo : subtrees) {
        List<HierarchicalConfiguration> interfaceTree = interfInfo.configurationsAt(IF_PHY);
        for (HierarchicalConfiguration interf : interfaceTree) {
            if (interf != null) {
                if (interf.getString(IF_TYPE) != null && interf.getString(SPEED) != null) {
                    if (interf.getString(IF_TYPE).contains(ETH) && interf.getString(SPEED).contains(MBPS)) {
                        portDescriptions.add(parseDefaultPort(interf));
                    }
                } else if (interf.getString(IF_LO_ENCAP) != null && !interf.getString(NAME).contains("pfe") && interf.getString(IF_LO_ENCAP).contains("ENET2")) {
                    portDescriptions.add(parseLogicalPort(interf));
                } else if (interf.getString(NAME).contains("lo")) {
                    portDescriptions.add(parseLoopback(interf));
                }
            }
        }
    }
    return portDescriptions;
}
#end_block

#method_before
private static PortDescription parseLoopback(HierarchicalConfiguration cfg) {
    String name = cfg.getString("logical-interface.name").trim();
    PortNumber portNumber = PortNumber.portNumber(name.replace("lo0.", ""));
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, name);
    String ip = cfg.getString("logical-interface.address-family.interface-address.ifa-local");
    if (ip != null) {
        annotationsBuilder.set("ip", ip);
    }
    return new DefaultPortDescription(portNumber, true, Port.Type.COPPER, 1000, annotationsBuilder.build());
}
#method_after
private static PortDescription parseLoopback(HierarchicalConfiguration cfg) {
    String name = cfg.getString(IF_LO_NAME).trim();
    PortNumber portNumber = portNumber(name.replace("lo0.", ""));
    Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, name);
    String ip = cfg.getString(IF_LO_ADD);
    if (ip != null) {
        annotationsBuilder.set("ip", ip);
    }
    return new DefaultPortDescription(portNumber, true, COPPER, DEFAULT_PORT_SPEED, annotationsBuilder.build());
}
#end_block

#method_before
private static DefaultPortDescription parseDefaultPort(HierarchicalConfiguration cfg) {
    PortNumber portNumber = PortNumber.portNumber(cfg.getString("local-index"));
    boolean enabled = cfg.getString("admin-status").equals("up");
    int speed = Integer.parseInt(cfg.getString("speed").replaceAll("mbps", ""));
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, cfg.getString("name").trim());
    String ip = cfg.getString("logical-interface.address-family.interface-address.ifa-local");
    if (ip != null) {
        annotationsBuilder.set("ip", ip);
    }
    return new DefaultPortDescription(portNumber, enabled, Port.Type.COPPER, speed, annotationsBuilder.build());
}
#method_after
private static DefaultPortDescription parseDefaultPort(HierarchicalConfiguration cfg) {
    PortNumber portNumber = portNumber(cfg.getString(LO_INDEX));
    boolean enabled = cfg.getString(STATUS).equals("up");
    int speed = parseInt(cfg.getString(SPEED).replaceAll(MBPS, ""));
    Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, cfg.getString(NAME).trim());
    setIpIfPresent(cfg, annotationsBuilder);
    return new DefaultPortDescription(portNumber, enabled, COPPER, speed, annotationsBuilder.build());
}
#end_block

#method_before
private static DefaultPortDescription parseLogicalPort(HierarchicalConfiguration cfg) {
    String name = cfg.getString("name").trim();
    String index = cfg.getString("snmp-index").trim();
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, name).set("index", index);
    String ip = cfg.getString("logical-interface.address-family.interface-address.ifa-local");
    if (ip != null) {
        annotationsBuilder.set("ip", ip);
    }
    PortNumber portNumber = PortNumber.portNumber(cfg.getString("logical-interface.local-index"));
    if (name != null) {
        if (name.contains("-")) {
            String[] splitted = name.split("-");
            String typeInt = "[" + splitted[0] + "]";
            String number = splitted[1].replace("/", "");
            number = "(" + number + ")";
            portNumber = PortNumber.fromString(typeInt + number);
        }
    }
    boolean enabled = false;
    if (cfg.getString("logical-interface.if-config-flags.iff-up") != null) {
        enabled = true;
    }
    // FIXME: port speed should be exposed
    int speed = 1000;
    return new DefaultPortDescription(portNumber, enabled, Port.Type.COPPER, speed, annotationsBuilder.build());
}
#method_after
private static DefaultPortDescription parseLogicalPort(HierarchicalConfiguration cfg) {
    String name = cfg.getString(NAME).trim();
    String index = cfg.getString(SNMP_INDEX).trim();
    Builder annotationsBuilder = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, name).set("index", index);
    setIpIfPresent(cfg, annotationsBuilder);
    PortNumber portNumber = portNumberFromName(cfg.getString(IF_LO_INDEX), name);
    boolean enabled = false;
    if (cfg.getString(IF_LO_STATUS) != null) {
        enabled = true;
    }
    // FIXME: port speed should be exposed
    return new DefaultPortDescription(portNumber, enabled, COPPER, DEFAULT_PORT_SPEED, annotationsBuilder.build());
}
#end_block

#method_before
@Override
public Set<LinkDescription> getLinks() {
    DeviceId localDeviceId = this.handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(localDeviceId).getSession();
    String reply;
    try {
        reply = session.get(requestBuilder());
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    log.debug("Reply from device {} : {}", localDeviceId, reply);
    Set<LinkAbstraction> linkAbstractions = parseJuniperLldp(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes())));
    log.debug("Set of LinkAbstraction discovered {}", linkAbstractions);
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Set<LinkDescription> descriptions = new HashSet<>();
    // for each lldp neighbor create two LinkDescription
    for (LinkAbstraction linkAbstraction : linkAbstractions) {
        // find source port by local port name
        Optional<Port> localPort = deviceService.getPorts(localDeviceId).stream().filter(port -> {
            if (port.annotations().value(AnnotationKeys.PORT_NAME) != null && port.annotations().value(AnnotationKeys.PORT_NAME).equals(linkAbstraction.localPortName)) {
                return true;
            }
            return false;
        }).findAny();
        if (!localPort.isPresent()) {
            log.warn("Port name {} does not exist in device {}", linkAbstraction.localPortName, localDeviceId);
            continue;
        }
        // find destination device by remote chassis id
        com.google.common.base.Optional<Device> dev = Iterables.tryFind(deviceService.getAvailableDevices(), input -> input.chassisId().equals(linkAbstraction.remoteChassisId));
        if (!dev.isPresent()) {
            log.warn("Device with chassis ID {} does not exist", linkAbstraction.remoteChassisId.toString());
            continue;
        }
        Device remoteDevice = dev.get();
        // find destination port by interface index
        Optional<Port> remotePort = deviceService.getPorts(remoteDevice.id()).stream().filter(port -> {
            if (port.annotations().value("index") != null && Integer.parseInt(port.annotations().value("index")) == linkAbstraction.remotePortIndex) {
                return true;
            }
            return false;
        }).findAny();
        if (!remotePort.isPresent()) {
            log.warn("Port with index {} does not exist in device {}", linkAbstraction.remotePortIndex, remoteDevice.id());
            continue;
        }
        // create bidirectional LinkDescription
        ConnectPoint local = new ConnectPoint(localDeviceId, localPort.get().number());
        ConnectPoint remote = new ConnectPoint(remoteDevice.id(), remotePort.get().number());
        DefaultAnnotations annotations = DefaultAnnotations.builder().set("layer", "IP").build();
        descriptions.add(new DefaultLinkDescription(local, remote, Link.Type.INDIRECT, false, annotations));
        descriptions.add(new DefaultLinkDescription(remote, local, Link.Type.INDIRECT, false, annotations));
    }
    return descriptions;
}
#method_after
@Override
public Set<LinkDescription> getLinks() {
    DeviceId localDeviceId = this.handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(localDeviceId).getSession();
    String reply;
    try {
        reply = session.get(requestBuilder(REQ_LLDP_NBR_INFO));
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException(FAILED_CFG, e));
    }
    log.debug("Reply from device {} : {}", localDeviceId, reply);
    Set<LinkAbstraction> linkAbstractions = parseJuniperLldp(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes())));
    log.debug("Set of LinkAbstraction discovered {}", linkAbstractions);
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Set<LinkDescription> descriptions = new HashSet<>();
    // for each lldp neighbor create two LinkDescription
    for (LinkAbstraction linkAbs : linkAbstractions) {
        // find source port by local port name
        Optional<Port> localPort = deviceService.getPorts(localDeviceId).stream().filter(port -> {
            if (linkAbs.localPortName.equals(port.annotations().value(PORT_NAME))) {
                return true;
            }
            return false;
        }).findAny();
        if (!localPort.isPresent()) {
            log.warn("Port name {} does not exist in device {}", linkAbs.localPortName, localDeviceId);
            continue;
        }
        // find destination device by remote chassis id
        com.google.common.base.Optional<Device> dev = Iterables.tryFind(deviceService.getAvailableDevices(), input -> input.chassisId().equals(linkAbs.remoteChassisId));
        if (!dev.isPresent()) {
            log.warn("Device with chassis ID {} does not exist", linkAbs.remoteChassisId);
            continue;
        }
        Device remoteDevice = dev.get();
        // find destination port by interface index
        Optional<Port> remotePort = deviceService.getPorts(remoteDevice.id()).stream().filter(port -> {
            if (port.annotations().value("index") != null && Integer.parseInt(port.annotations().value("index")) == linkAbs.remotePortIndex) {
                return true;
            }
            return false;
        }).findAny();
        if (!remotePort.isPresent()) {
            log.warn("Port with index {} does not exist in device {}", linkAbs.remotePortIndex, remoteDevice.id());
            continue;
        }
        JuniperUtils.createBiDirLinkDescription(localDeviceId, localPort.get(), remoteDevice.id(), remotePort.get(), descriptions);
    }
    return descriptions;
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    String sysInfo;
    String chassis;
    try {
        sysInfo = session.get(requestBuilder("<get-system-information/>"));
        chassis = session.get(requestBuilder("<get-chassis-mac-addresses/>"));
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    DeviceDescription description = JuniperUtils.parseJuniperDescription(deviceId, XmlConfigParser.loadXml(new ByteArrayInputStream(sysInfo.getBytes())), chassis);
    return description;
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    DeviceId deviceId = handler().data().deviceId();
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    String sysInfo;
    String chassis;
    try {
        sysInfo = session.get(requestBuilder(REQ_SYS_INFO));
        chassis = session.get(requestBuilder(REQ_MAC_ADD_INFO));
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException(FAILED_CFG, e));
    }
    DeviceDescription description = JuniperUtils.parseJuniperDescription(deviceId, XmlConfigParser.loadXml(new ByteArrayInputStream(sysInfo.getBytes())), chassis);
    log.debug("Device  description {}", description);
    return description;
}
#end_block

#method_before
@Override
public List<PortDescription> discoverPortDetails() {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.get(requestBuilder("<get-interface-information/>"));
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve configuration.", e));
    }
    List<PortDescription> descriptions = JuniperUtils.parseJuniperPorts(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes())));
    log.info("Discovered ports {}", descriptions);
    return descriptions;
}
#method_after
@Override
public List<PortDescription> discoverPortDetails() {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.get(requestBuilder(REQ_IF_INFO));
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException(FAILED_CFG, e));
    }
    List<PortDescription> descriptions = JuniperUtils.parseJuniperPorts(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes())));
    log.debug("Discovered ports {}", descriptions);
    return descriptions;
}
#end_block

#method_before
@Override
public void writeTo(ByteBuf byteBuf, LispInfoRequest message) throws LispWriterException {
    DefaultLispInfo.serialize(byteBuf, message);
    // fill <Nothing Follows AFI=0> field
    byteBuf.writeShort(0);
}
#method_after
@Override
public void writeTo(ByteBuf byteBuf, LispInfoRequest message) throws LispWriterException {
    DefaultLispInfo.serialize(byteBuf, message);
    // Fill AFI=0, no address
    new LispAfiAddress.AfiAddressWriter().writeTo(byteBuf, new LispNoAddress());
}
#end_block

#method_before
private void setupConnectivity(boolean isNetworkConfigEvent) {
    SetMultimap<String, Interface> networkInterfaces = vplsConfigService.ifacesByVplsName();
    Set<String> vplsAffectedByApi = new HashSet<>(vplsConfigService.vplsAffectedByApi());
    if (isNetworkConfigEvent && vplsAffectedByApi.isEmpty()) {
        vplsAffectedByApi.addAll(vplsConfigService.vplsNamesOld());
    }
    networkInterfaces.asMap().forEach((vplsName, interfaces) -> {
        Set<Host> hosts = Sets.newHashSet();
        interfaces.forEach(intf -> {
            // Add hosts that belongs to the specific VPLS
            hostService.getConnectedHosts(intf.connectPoint()).stream().filter(host -> host.vlan().equals(intf.vlan())).forEach(hosts::add);
        });
        EncapsulationType encapType = vplsConfigService.encapType(vplsName);
        boolean doEncap = vplsConfigService.encap(vplsName);
        EncapsulationType encap = null;
        if (encapType != null && doEncap == true) {
            encap = encapType;
        }
        setupConnectivity(vplsName, interfaces, hosts, encap, vplsAffectedByApi.contains(vplsName));
        vplsAffectedByApi.remove(vplsName);
    });
    if (!vplsAffectedByApi.isEmpty()) {
        for (String networkName : vplsAffectedByApi) {
            withdrawIntents(networkName, Lists.newArrayList());
        }
    }
}
#method_after
private void setupConnectivity(boolean isNetworkConfigEvent) {
    SetMultimap<String, Interface> networkInterfaces = vplsConfigService.ifacesByVplsName();
    Set<String> vplsAffectedByApi = new HashSet<>(vplsConfigService.vplsAffectedByApi());
    if (isNetworkConfigEvent && vplsAffectedByApi.isEmpty()) {
        vplsAffectedByApi.addAll(vplsConfigService.vplsNamesOld());
    }
    networkInterfaces.asMap().forEach((vplsName, interfaces) -> {
        Set<Host> hosts = Sets.newHashSet();
        interfaces.forEach(intf -> {
            // Add hosts that belongs to the specific VPLS
            hostService.getConnectedHosts(intf.connectPoint()).stream().filter(host -> host.vlan().equals(intf.vlan())).forEach(hosts::add);
        });
        EncapsulationType encap = vplsConfigService.encap(vplsName);
        setupConnectivity(vplsName, interfaces, hosts, encap, vplsAffectedByApi.contains(vplsName));
        vplsAffectedByApi.remove(vplsName);
    });
    if (!vplsAffectedByApi.isEmpty()) {
        for (String vplsName : vplsAffectedByApi) {
            withdrawIntents(vplsName, Lists.newArrayList());
        }
    }
}
#end_block

#method_before
public boolean encap() {
    return encap;
}
#method_after
public EncapsulationType encap() {
    return encap;
}
#end_block

#method_before
public boolean isAttached(String iface) {
    return ifaces.stream().anyMatch(i -> i.equals(iface));
}
#method_after
public boolean isAttached(String iface) {
    return ifaces.stream().anyMatch(iface::equals);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof VplsConfig) {
        final VplsConfig that = (VplsConfig) obj;
        return Objects.equals(this.name, that.name) && Objects.equals(this.ifaces, that.ifaces) && Objects.equals(this.encapType, that.encapType) && Objects.equals(this.encap, that.encap);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof VplsConfig) {
        VplsConfig that = (VplsConfig) obj;
        return Objects.equals(name, that.name) && Objects.equals(ifaces, that.ifaces) && Objects.equals(encap, that.encap);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(name, ifaces, encapType, encap);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(name, ifaces, encap);
}
#end_block

#method_before
protected void handleRequest(NeighbourMessageContext context) {
    SetMultimap<String, Interface> vplsNetwork = vplsConfigService.ifacesByVplsName(context.vlan(), context.inPort());
    if (vplsNetwork != null) {
        Collection<Interface> vplsInterfaces = vplsNetwork.values();
        vplsInterfaces.stream().filter(intf -> !context.inPort().equals(intf.connectPoint())).forEach(context::forward);
    } else {
        log.debug(CAN_NOT_FIND_NETWORK, context.inPort(), context.vlan());
    }
}
#method_after
protected void handleRequest(NeighbourMessageContext context) {
    SetMultimap<String, Interface> vpls = vplsConfigService.ifacesByVplsName(context.vlan(), context.inPort());
    if (vpls != null) {
        Collection<Interface> vplsInterfaces = vpls.values();
        vplsInterfaces.stream().filter(intf -> !context.inPort().equals(intf.connectPoint())).forEach(context::forward);
    } else {
        log.debug(CAN_NOT_FIND_VPLS, context.inPort(), context.vlan());
    }
}
#end_block

#method_before
protected void handleReply(NeighbourMessageContext context, HostService hostService) {
    SetMultimap<String, Interface> vplsNetwork = vplsConfigService.ifacesByVplsName(context.vlan(), context.inPort());
    Set<Host> hosts = hostService.getHostsByMac(context.dstMac());
    if (vplsNetwork != null) {
        Collection<Interface> vplsInterfaces = vplsNetwork.values();
        hosts.forEach(host -> vplsInterfaces.stream().filter(intf -> intf.connectPoint().equals(host.location())).filter(intf -> intf.vlan().equals(host.vlan())).forEach(context::forward));
    } else {
        log.debug(CAN_NOT_FIND_NETWORK, context.inPort(), context.vlan());
    }
}
#method_after
protected void handleReply(NeighbourMessageContext context, HostService hostService) {
    SetMultimap<String, Interface> vpls = vplsConfigService.ifacesByVplsName(context.vlan(), context.inPort());
    Set<Host> hosts = hostService.getHostsByMac(context.dstMac());
    if (vpls != null) {
        Collection<Interface> vplsInterfaces = vpls.values();
        hosts.forEach(host -> vplsInterfaces.stream().filter(intf -> intf.connectPoint().equals(host.location())).filter(intf -> intf.vlan().equals(host.vlan())).forEach(context::forward));
    } else {
        log.debug(CAN_NOT_FIND_VPLS, context.inPort(), context.vlan());
    }
}
#end_block

#method_before
@Override
protected void execute() {
    if (vplsConfigService.vplsNames().contains(vplsName)) {
        print(VPLS_EXIST, vplsName);
        return;
    }
    vplsConfigService.addVpls(vplsName, new HashSet<>(), null, false);
}
#method_after
@Override
protected void execute() {
    // Check if the VPLS name is already configured
    if (VplsCommandUtils.vplsExists(vplsName)) {
        print(VplsCommandUtils.VPLS_ALREADY_EXISTS, vplsName);
        return;
    }
    vplsConfigService.addVpls(vplsName, new HashSet<>(), null);
}
#end_block

#method_before
@Override
protected void execute() {
    if (!vplsConfigService.vplsNames().contains(vplsName)) {
        print(VPLS_NOT_FOUND, vplsName);
        return;
    }
    if (vplsConfigService.allIfaces().stream().anyMatch(e -> e.name().equals(ifaceName))) {
        print(IFACE_EXIST, ifaceName, vplsConfigService.ifacesByVplsName().entries().stream().filter(e -> e.getValue().name().equals(ifaceName)).map(Map.Entry::getKey).findFirst().get());
        return;
    }
    vplsConfigService.addIface(vplsName, ifaceName);
}
#method_after
@Override
protected void execute() {
    // Check if the VPLS exists
    if (!VplsCommandUtils.vplsExists(vplsName)) {
        print(VplsCommandUtils.VPLS_NOT_FOUND, vplsName);
        return;
    }
    // Check if the interface exists
    if (!VplsCommandUtils.ifaceExists(ifaceName)) {
        print(VplsCommandUtils.IFACE_NOT_FOUND, ifaceName);
        return;
    }
    // Check if the interface is already associated to a VPLS
    if (VplsCommandUtils.ifaceAlreadyAssociated(ifaceName)) {
        print(VplsCommandUtils.IFACE_ALREADY_ASSOCIATED, ifaceName, VplsCommandUtils.vplsNameFromIfaceName(ifaceName));
        return;
    }
    vplsConfigService.addIface(vplsName, ifaceName);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    JsonNode tree = new ObjectMapper().readTree(JSON_TREE);
    vplsAppConfig.init(APP_ID, APP_NAME, tree, mapper, delegate);
    JsonNode emptyTree = new ObjectMapper().readTree(EMPTY_JSON_TREE);
    emptyVplsAppConfig.init(APP_ID, APP_NAME, emptyTree, mapper, delegate);
    networks.add(initialNetwork);
}
#method_after
@Before
public void setUp() throws Exception {
    JsonNode tree = new ObjectMapper().readTree(JSON_TREE);
    vplsAppConfig.init(APP_ID, APP_NAME, tree, mapper, delegate);
    JsonNode emptyTree = new ObjectMapper().readTree(EMPTY_JSON_TREE);
    emptyVplsAppConfig.init(APP_ID, APP_NAME, emptyTree, mapper, delegate);
    vplss.add(initialVpls);
}
#end_block

#method_before
@Override
protected void execute() {
    Set<Interface> ifaces = vplsConfigService.allIfaces();
    if (!ifaces.stream().map(Interface::name).anyMatch(ifaceName::equals)) {
        print(NO_CONFIGURATION, ifaceName);
    }
    vplsConfigService.removeIface(ifaceName);
}
#method_after
@Override
protected void execute() {
    if (!VplsCommandUtils.vplsExists(vplsName)) {
        print(VplsCommandUtils.VPLS_NOT_FOUND, vplsName);
        return;
    }
    if (!VplsCommandUtils.ifaceExists(ifaceName)) {
        print(VplsCommandUtils.IFACE_NOT_FOUND, ifaceName);
        return;
    }
    if (!VplsCommandUtils.ifaceAlreadyAssociated(ifaceName)) {
        print(VplsCommandUtils.IFACE_NOT_ASSOCIATED, ifaceName, VplsCommandUtils.vplsNameFromIfaceName(ifaceName));
        return;
    }
    vplsConfigService.removeIface(ifaceName);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    idGenerator = new TestIdGenerator();
    Intent.bindIdGenerator(idGenerator);
    applicationService = createMock(ApplicationService.class);
    configService = createMock(NetworkConfigService.class);
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(APPID);
    replay(coreService);
    hostsAvailable = Sets.newHashSet();
    hostService = new TestHostService(hostsAvailable);
    intentService = new TestIntentService();
    TestIntentSynchronizer intentSynchronizer = new TestIntentSynchronizer(intentService);
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    addIntfConfig();
    SetMultimap<String, Interface> vplsNetworks = HashMultimap.create();
    vplsNetworks.put(NET1, v100h1);
    vplsNetworks.put(NET1, v200h1);
    vplsNetworks.put(NET1, v300h1);
    vplsNetworks.put(NET2, v100h2);
    vplsNetworks.put(NET2, v200h2);
    vplsNetworks.put(NET2, v300h2);
    vplsConfigService = new TestVplsConfigService(vplsNetworks);
    vpls = new Vpls();
    vpls.applicationService = applicationService;
    vpls.coreService = coreService;
    vpls.hostService = hostService;
    vpls.vplsConfigService = vplsConfigService;
    vpls.intentService = intentService;
    vpls.interfaceService = interfaceService;
    vpls.configService = configService;
    vpls.intentSynchronizer = intentSynchronizer;
}
#method_after
@Before
public void setUp() throws Exception {
    idGenerator = new TestIdGenerator();
    Intent.bindIdGenerator(idGenerator);
    applicationService = createMock(ApplicationService.class);
    configService = createMock(NetworkConfigService.class);
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication(APP_NAME)).andReturn(APPID);
    replay(coreService);
    hostsAvailable = Sets.newHashSet();
    hostService = new TestHostService(hostsAvailable);
    intentService = new TestIntentService();
    TestIntentSynchronizer intentSynchronizer = new TestIntentSynchronizer(intentService);
    interfaceService = createMock(InterfaceService.class);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expectLastCall().anyTimes();
    addIfaceConfig();
    SetMultimap<String, Interface> interfacesByVpls = HashMultimap.create();
    interfacesByVpls.put(VPLS1, V100H1);
    interfacesByVpls.put(VPLS1, V200H1);
    interfacesByVpls.put(VPLS1, V300H1);
    interfacesByVpls.put(VPLS2, V100H2);
    interfacesByVpls.put(VPLS2, V200H2);
    interfacesByVpls.put(VPLS2, V300H2);
    Map<String, EncapsulationType> encapByVpls = new HashMap<>();
    encapByVpls.put(VPLS1, VLAN);
    encapByVpls.put(VPLS2, NONE);
    vplsConfigService = new TestVplsConfigService(interfacesByVpls, encapByVpls);
    vpls = new Vpls();
    vpls.applicationService = applicationService;
    vpls.coreService = coreService;
    vpls.hostService = hostService;
    vpls.vplsConfigService = vplsConfigService;
    vpls.intentService = intentService;
    vpls.interfaceService = interfaceService;
    vpls.configService = configService;
    vpls.intentSynchronizer = intentSynchronizer;
}
#end_block

#method_before
private List<SinglePointToMultiPointIntent> generateVplsBrc(Set<FilteredConnectPoint> fcPoints, String name) {
    List<SinglePointToMultiPointIntent> intents = Lists.newArrayList();
    fcPoints.forEach(point -> {
        Set<FilteredConnectPoint> otherPoints = fcPoints.stream().filter(fcp -> !fcp.equals(point)).collect(Collectors.toSet());
        Key brckey = buildKey(PREFIX_BROADCAST, point.connectPoint(), name, MacAddress.BROADCAST);
        intents.add(buildBrcIntent(brckey, point, otherPoints));
    });
    return intents;
}
#method_after
private List<SinglePointToMultiPointIntent> generateVplsBrc(Set<FilteredConnectPoint> fcPoints, String name, EncapsulationType encap) {
    List<SinglePointToMultiPointIntent> intents = Lists.newArrayList();
    fcPoints.forEach(point -> {
        Set<FilteredConnectPoint> otherPoints = fcPoints.stream().filter(fcp -> !fcp.equals(point)).collect(Collectors.toSet());
        Key brckey = buildKey(PREFIX_BROADCAST, point.connectPoint(), name, MacAddress.BROADCAST);
        intents.add(buildBrcIntent(brckey, point, otherPoints, encap));
    });
    return intents;
}
#end_block

#method_before
private List<MultiPointToSinglePointIntent> generateVplsUni(Set<FilteredConnectPoint> fcPoints, Set<Host> hosts, String name) {
    List<MultiPointToSinglePointIntent> intents = Lists.newArrayList();
    hosts.forEach(host -> {
        FilteredConnectPoint hostPoint = getHostPoint(host, fcPoints);
        Set<FilteredConnectPoint> otherPoints = fcPoints.stream().filter(fcp -> !fcp.equals(hostPoint)).collect(Collectors.toSet());
        Key uniKey = buildKey(PREFIX_UNICAST, host.location(), name, host.mac());
        intents.add(buildUniIntent(uniKey, otherPoints, hostPoint, host));
    });
    return intents;
}
#method_after
private List<MultiPointToSinglePointIntent> generateVplsUni(Set<FilteredConnectPoint> fcPoints, Set<Host> hosts, String name, EncapsulationType encap) {
    List<MultiPointToSinglePointIntent> intents = Lists.newArrayList();
    hosts.forEach(host -> {
        FilteredConnectPoint hostPoint = getHostPoint(host, fcPoints);
        Set<FilteredConnectPoint> otherPoints = fcPoints.stream().filter(fcp -> !fcp.equals(hostPoint)).collect(Collectors.toSet());
        Key uniKey = buildKey(PREFIX_UNICAST, host.location(), name, host.mac());
        intents.add(buildUniIntent(uniKey, otherPoints, hostPoint, host, encap));
    });
    return intents;
}
#end_block

#method_before
private void checkIntents(List<Intent> intents) {
    assertEquals(intents.size(), intentService.getIntentCount());
    for (Intent intentOne : intents) {
        boolean found = false;
        for (Intent intentTwo : intentService.getIntents()) {
            if (intentOne.key().equals(intentTwo.key())) {
                found = true;
                assertTrue(format(COMPARE, intentOne, intentTwo), IntentUtils.intentsAreEqual(intentOne, intentTwo));
                break;
            }
        }
        assertTrue(found);
    }
}
#method_after
private void checkIntents(List<Intent> intents) {
    assertEquals("The number of intents submitted differs from the number" + "of intents expected", intents.size(), intentService.getIntentCount());
    for (Intent intentOne : intents) {
        boolean found = false;
        for (Intent intentTwo : intentService.getIntents()) {
            if (intentOne.key().equals(intentTwo.key())) {
                found = true;
                assertTrue(format("The intent submitted is different from" + "the intent expected", intentOne, intentTwo), IntentUtils.intentsAreEqual(intentOne, intentTwo));
                break;
            }
        }
        assertTrue("The intent submitted is not equal to any of the expected" + "intents", found);
    }
}
#end_block

#method_before
private SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts) {
    SinglePointToMultiPointIntent intent;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intent = SinglePointToMultiPointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).priority(PRIORITY_OFFSET).build();
    return intent;
}
#method_after
private SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts, EncapsulationType encap) {
    SinglePointToMultiPointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intentBuilder = SinglePointToMultiPointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).priority(PRIORITY_OFFSET);
    encap(intentBuilder, encap);
    return intentBuilder.build();
}
#end_block

#method_before
private MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    return MultiPointToSinglePointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).priority(PRIORITY_OFFSET).build();
}
#method_after
private MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host, EncapsulationType encap) {
    MultiPointToSinglePointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    intentBuilder = MultiPointToSinglePointIntent.builder().appId(APPID).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).priority(PRIORITY_OFFSET);
    encap(intentBuilder, encap);
    return intentBuilder.build();
}
#end_block

#method_before
private Set<FilteredConnectPoint> buildFCPoints(Set<Interface> interfaces) {
    // Build all filtered connected point in the network
    return interfaces.stream().map(intf -> {
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
        if (!intf.vlan().equals(VlanId.NONE)) {
            selectorBuilder.matchVlanId(intf.vlan());
        }
        return new FilteredConnectPoint(intf.connectPoint(), selectorBuilder.build());
    }).collect(Collectors.toSet());
}
#method_after
private Set<FilteredConnectPoint> buildFCPoints(Set<Interface> interfaces) {
    // Build all filtered connected point for the VPLS
    return interfaces.stream().map(intf -> {
        TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
        if (!intf.vlan().equals(VlanId.NONE)) {
            selectorBuilder.matchVlanId(intf.vlan());
        }
        return new FilteredConnectPoint(intf.connectPoint(), selectorBuilder.build());
    }).collect(Collectors.toSet());
}
#end_block

#method_before
private Key buildKey(String prefix, ConnectPoint cPoint, String networkName, MacAddress hostMac) {
    String keyString = networkName + DASH + prefix + DASH + cPoint.deviceId() + DASH + cPoint.port() + DASH + hostMac;
    return Key.of(keyString, APPID);
}
#method_after
private Key buildKey(String prefix, ConnectPoint cPoint, String vplsName, MacAddress hostMac) {
    String keyString = vplsName + DASH + prefix + DASH + cPoint.deviceId() + DASH + cPoint.port() + DASH + hostMac;
    return Key.of(keyString, APPID);
}
#end_block

#method_before
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, EncapsulationType encapType, boolean encap) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            avaliableInterfaces.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
    }
}
#method_after
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, String encap) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            AVALIABLE_INTERFACES.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
        encapsByVplsName.put(vplsName, valueOf(encap));
    }
}
#end_block

#method_before
@Override
public void removeVpls(String name) {
    if (ifacesByVplsName.containsKey(name)) {
        ifacesByVplsName.removeAll(name);
    }
}
#method_after
@Override
public void removeVpls(String vplsName) {
    if (ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.removeAll(vplsName);
    }
}
#end_block

#method_before
@Override
public void addIface(String name, String iface) {
    if (!ifacesByVplsName.containsKey(name)) {
        avaliableInterfaces.forEach(intf -> {
            if (intf.name().equals(iface)) {
                ifacesByVplsName.put(name, intf);
            }
        });
    }
}
#method_after
@Override
public void addIface(String vplsName, String iface) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        AVALIABLE_INTERFACES.forEach(intf -> {
            if (intf.name().equals(iface)) {
                ifacesByVplsName.put(vplsName, intf);
            }
        });
    }
}
#end_block

#method_before
@Override
public void setEncap(String name, boolean encapsulation) {
}
#method_after
@Override
public void setEncap(String vplsName, String encap) {
    encapsByVplsName.put(vplsName, EncapsulationType.enumFromString(encap));
}
#end_block

#method_before
@Override
public boolean encap(String name) {
    return false;
}
#method_after
@Override
public EncapsulationType encap(String vplsName) {
    EncapsulationType encap = null;
    if (encapsByVplsName.containsKey(vplsName)) {
        encap = encapsByVplsName.get(vplsName);
    }
    return encap;
}
#end_block

#method_before
@Override
public SetMultimap<String, Interface> ifacesByVplsName(VlanId vlan, ConnectPoint connectPoint) {
    String vplsNetworkName = ifacesByVplsName.entries().stream().filter(e -> e.getValue().connectPoint().equals(connectPoint)).filter(e -> e.getValue().vlan().equals(vlan)).map(e -> e.getKey()).findFirst().orElse(null);
    SetMultimap<String, Interface> result = HashMultimap.create();
    if (vplsNetworkName != null && ifacesByVplsName.containsKey(vplsNetworkName)) {
        ifacesByVplsName.get(vplsNetworkName).forEach(intf -> result.put(vplsNetworkName, intf));
        return result;
    }
    return null;
}
#method_after
@Override
public SetMultimap<String, Interface> ifacesByVplsName(VlanId vlan, ConnectPoint connectPoint) {
    String vplsName = ifacesByVplsName.entries().stream().filter(e -> e.getValue().connectPoint().equals(connectPoint)).filter(e -> e.getValue().vlan().equals(vlan)).map(e -> e.getKey()).findFirst().orElse(null);
    SetMultimap<String, Interface> result = HashMultimap.create();
    if (vplsName != null && ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.get(vplsName).forEach(intf -> result.put(vplsName, intf));
        return result;
    }
    return null;
}
#end_block

#method_before
@Override
protected void execute() {
    if (!vplsConfigService.vplsNames().contains(vplsName)) {
        print(VPLS_NOT_FOUND, vplsName);
        return;
    }
    vplsConfigService.removeVpls(vplsName);
}
#method_after
@Override
protected void execute() {
    if (!VplsCommandUtils.vplsExists(vplsName)) {
        print(VplsCommandUtils.VPLS_NOT_FOUND, vplsName);
        return;
    }
    vplsConfigService.removeVpls(vplsName);
}
#end_block

#method_before
@Override
protected void execute() {
    vplsConfigService.vplsNames().forEach(vpls -> {
        print("%s", vpls);
    });
}
#method_after
@Override
protected void execute() {
    vplsConfigService.vplsNames().forEach(vpls -> {
        print(VplsCommandUtils.VPLS_NAME, vpls);
    });
}
#end_block

#method_before
@Before
public void setUp() {
    vplsNeighbourHandler = new VplsNeighbourHandler();
    SetMultimap<String, Interface> vplsNetworks = HashMultimap.create();
    vplsNetworks.put("net1", v100h1);
    vplsNetworks.put("net1", v200h1);
    vplsNetworks.put("net1", v300h1);
    vplsNetworks.put("net2", v100h2);
    vplsNetworks.put("net2", v200h2);
    vplsNeighbourHandler.vplsConfigService = new TestVplsConfigService(vplsNetworks);
    vplsNeighbourHandler.interfaceService = new TestInterfaceService();
    vplsNeighbourHandler.neighbourService = new TestNeighbourService();
    hostService = new TestHostService();
}
#method_after
@Before
public void setUp() {
    vplsNeighbourHandler = new VplsNeighbourHandler();
    SetMultimap<String, Interface> ifacesByVpls = HashMultimap.create();
    ifacesByVpls.put(VPLS1, V100H1);
    ifacesByVpls.put(VPLS1, V200H1);
    ifacesByVpls.put(VPLS1, V300H1);
    ifacesByVpls.put(VPLS2, V100H2);
    ifacesByVpls.put(VPLS2, V200H2);
    HashMap<String, EncapsulationType> encap = Maps.newHashMap();
    vplsNeighbourHandler.vplsConfigService = new TestVplsConfigService(ifacesByVpls, encap);
    vplsNeighbourHandler.interfaceService = new TestInterfaceService();
    vplsNeighbourHandler.neighbourService = new TestNeighbourService();
    hostService = new TestHostService();
}
#end_block

#method_before
private Host makeHost(MacAddress mac, VlanId vlan, ConnectPoint cp) {
    return new DefaultHost(pid, HostId.hostId(mac, vlan), mac, vlan, new HostLocation(cp, 0), Sets.newHashSet());
}
#method_after
private Host makeHost(MacAddress mac, VlanId vlan, ConnectPoint cp) {
    return new DefaultHost(PID, HostId.hostId(mac, vlan), mac, vlan, new HostLocation(cp, 0), Sets.newHashSet());
}
#end_block

#method_before
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, EncapsulationType encapType, boolean encap) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            avaliableInterfaces.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
    }
}
#method_after
@Override
public void addVpls(String vplsName, Set<String> ifaceNames, String encap) {
    if (!ifacesByVplsName.containsKey(vplsName)) {
        ifaceNames.forEach(ifaceName -> {
            availableInterfaces.forEach(iface -> {
                if (iface.name().equals(ifaceName)) {
                    ifacesByVplsName.put(vplsName, iface);
                }
            });
        });
    }
}
#end_block

#method_before
@Override
public void removeVpls(String name) {
    if (ifacesByVplsName.containsKey(name)) {
        ifacesByVplsName.removeAll(name);
    }
}
#method_after
@Override
public void removeVpls(String vplsName) {
    if (ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.removeAll(vplsName);
    }
}
#end_block

#method_before
@Override
public void addIface(String name, String ifaceName) {
    avaliableInterfaces.forEach(intf -> {
        if (intf.name().equals(ifaceName)) {
            ifacesByVplsName.put(name, intf);
        }
    });
}
#method_after
@Override
public void addIface(String vplsName, String ifaceName) {
    availableInterfaces.forEach(intf -> {
        if (intf.name().equals(ifaceName)) {
            ifacesByVplsName.put(vplsName, intf);
        }
    });
}
#end_block

#method_before
@Override
public SetMultimap<String, Interface> ifacesByVplsName(VlanId vlan, ConnectPoint connectPoint) {
    String vplsNetworkName = ifacesByVplsName.entries().stream().filter(e -> e.getValue().connectPoint().equals(connectPoint)).filter(e -> e.getValue().vlan().equals(vlan)).map(e -> e.getKey()).findFirst().orElse(null);
    SetMultimap<String, Interface> result = HashMultimap.create();
    if (vplsNetworkName != null && ifacesByVplsName.containsKey(vplsNetworkName)) {
        ifacesByVplsName.get(vplsNetworkName).forEach(intf -> result.put(vplsNetworkName, intf));
        return result;
    }
    return null;
}
#method_after
@Override
public SetMultimap<String, Interface> ifacesByVplsName(VlanId vlan, ConnectPoint connectPoint) {
    String vplsName = ifacesByVplsName.entries().stream().filter(e -> e.getValue().connectPoint().equals(connectPoint)).filter(e -> e.getValue().vlan().equals(vlan)).map(e -> e.getKey()).findFirst().orElse(null);
    SetMultimap<String, Interface> result = HashMultimap.create();
    if (vplsName != null && ifacesByVplsName.containsKey(vplsName)) {
        ifacesByVplsName.get(vplsName).forEach(intf -> result.put(vplsName, intf));
        return result;
    }
    return null;
}
#end_block

#method_before
@Override
public Set<Interface> getInterfaces() {
    return avaliableInterfaces;
}
#method_after
@Override
public Set<Interface> getInterfaces() {
    return availableInterfaces;
}
#end_block

#method_before
@Override
public Interface getInterfaceByName(ConnectPoint connectPoint, String name) {
    return avaliableInterfaces.stream().filter(intf -> intf.name().equals(name)).findFirst().orElse(null);
}
#method_after
@Override
public Interface getInterfaceByName(ConnectPoint connectPoint, String name) {
    return availableInterfaces.stream().filter(intf -> intf.name().equals(name)).findFirst().orElse(null);
}
#end_block

#method_before
@Override
public Set<Interface> getInterfacesByPort(ConnectPoint port) {
    return avaliableInterfaces.stream().filter(intf -> intf.connectPoint().equals(port)).collect(Collectors.toSet());
}
#method_after
@Override
public Set<Interface> getInterfacesByPort(ConnectPoint port) {
    return availableInterfaces.stream().filter(intf -> intf.connectPoint().equals(port)).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Set<Interface> getInterfacesByIp(IpAddress ip) {
    return avaliableInterfaces.stream().filter(intf -> intf.ipAddressesList().contains(ip)).collect(Collectors.toSet());
}
#method_after
@Override
public Set<Interface> getInterfacesByIp(IpAddress ip) {
    return availableInterfaces.stream().filter(intf -> intf.ipAddressesList().contains(ip)).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Set<Interface> getInterfacesByVlan(VlanId vlan) {
    return avaliableInterfaces.stream().filter(intf -> intf.vlan().equals(vlan)).collect(Collectors.toSet());
}
#method_after
@Override
public Set<Interface> getInterfacesByVlan(VlanId vlan) {
    return availableInterfaces.stream().filter(intf -> intf.vlan().equals(vlan)).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Interface getMatchingInterface(IpAddress ip) {
    return avaliableInterfaces.stream().filter(intf -> intf.ipAddressesList().contains(ip)).findFirst().orElse(null);
}
#method_after
@Override
public Interface getMatchingInterface(IpAddress ip) {
    return availableInterfaces.stream().filter(intf -> intf.ipAddressesList().contains(ip)).findFirst().orElse(null);
}
#end_block

#method_before
@Override
public void addVpls(String name, Set<String> ifaces, EncapsulationType encapType, boolean encap) {
    VplsConfig vpls;
    if (ifacesOfVpls.containsKey(name)) {
        if (ifaces.isEmpty()) {
            return;
        }
        ifaces.forEach(iface -> vplsAppConfig.addIface(name, iface));
        vplsAppConfig.setEncap(name, encap);
    } else {
        vpls = new VplsConfig(name, ifaces, encapType, encap);
        vplsAppConfig.addVpls(vpls);
    }
    vplsAffectedByApi.add(name);
    applyConfig(vplsAppConfig);
}
#method_after
@Override
public void addVpls(String vplsName, Set<String> ifaces, String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (ifacesOfVpls.containsKey(vplsName)) {
        if (ifaces.isEmpty()) {
            return;
        }
        ifaces.forEach(iface -> vplsAppConfig.addIface(vplsName, iface));
        vplsAppConfig.setEncap(vplsName, encapType);
    } else {
        vplsAppConfig.addVpls(new VplsConfig(vplsName, ifaces, encapType));
    }
    vplsAffectedByApi.add(vplsName);
    applyConfig(vplsAppConfig);
}
#end_block

#method_before
@Override
public void removeVpls(String name) {
    if (ifacesOfVpls.containsKey(name)) {
        vplsAppConfig.removeVpls(name);
        vplsAffectedByApi.add(name);
        applyConfig(vplsAppConfig);
    }
}
#method_after
@Override
public void removeVpls(String vplsName) {
    if (ifacesOfVpls.containsKey(vplsName)) {
        vplsAppConfig.removeVpls(vplsName);
        vplsAffectedByApi.add(vplsName);
        applyConfig(vplsAppConfig);
    }
}
#end_block

#method_before
@Override
public void addIface(String name, String iface) {
    if (ifacesOfVpls.containsKey(name)) {
        vplsAppConfig.addIface(name, iface);
        vplsAffectedByApi.add(name);
        applyConfig(vplsAppConfig);
    }
}
#method_after
@Override
public void addIface(String vplsName, String iface) {
    if (ifacesOfVpls.containsKey(vplsName)) {
        vplsAppConfig.addIface(vplsName, iface);
        vplsAffectedByApi.add(vplsName);
        applyConfig(vplsAppConfig);
    }
}
#end_block

#method_before
@Override
public void setEncap(String name, boolean encap) {
    if (ifacesOfVpls.containsKey(name)) {
        vplsAppConfig.setEncap(name, encap);
        vplsAffectedByApi.add(name);
        applyConfig(vplsAppConfig);
    }
}
#method_after
@Override
public void setEncap(String vplsName, String encap) {
    EncapsulationType encapType = EncapsulationType.enumFromString(encap);
    if (ifacesOfVpls.containsKey(vplsName)) {
        vplsAppConfig.setEncap(vplsName, encapType);
        vplsAffectedByApi.add(vplsName);
        applyConfig(vplsAppConfig);
    }
}
#end_block

#method_before
@Override
public boolean encap(String name) {
    return false;
}
#method_after
@Override
public EncapsulationType encap(String vplsName) {
    EncapsulationType encap = null;
    if (vplsEncaps.containsKey(vplsName)) {
        encap = vplsEncaps.get(vplsName);
    }
    return encap;
}
#end_block

#method_before
@Override
public Set<Interface> allIfaces() {
    Set<Interface> allInterfaces = new HashSet<>();
    vplsNetworks.values().forEach(allInterfaces::add);
    return allInterfaces;
}
#method_after
@Override
public Set<Interface> allIfaces() {
    Set<Interface> allVplsInterfaces = new HashSet<>();
    vplsIfaces.values().forEach(allVplsInterfaces::add);
    return allVplsInterfaces;
}
#end_block

#method_before
@Override
public Set<Interface> ifaces(String name) {
    Set<Interface> vplsInterfaces = new HashSet<>();
    vplsNetworks.get(name).forEach(vplsInterfaces::add);
    return vplsInterfaces;
}
#method_after
@Override
public Set<Interface> ifaces(String vplsName) {
    Set<Interface> vplsInterfaces = new HashSet<>();
    vplsIfaces.get(vplsName).forEach(vplsInterfaces::add);
    return vplsInterfaces;
}
#end_block

#method_before
@Override
public SetMultimap<String, Interface> ifacesByVplsName() {
    return ImmutableSetMultimap.copyOf(vplsNetworks);
}
#method_after
@Override
public SetMultimap<String, Interface> ifacesByVplsName() {
    return ImmutableSetMultimap.copyOf(vplsIfaces);
}
#end_block

#method_before
@Override
public SetMultimap<String, Interface> ifacesByVplsName(VlanId vlan, ConnectPoint connectPoint) {
    String vplsNetworkName = vplsNetworks.entries().stream().filter(e -> e.getValue().connectPoint().equals(connectPoint)).filter(e -> e.getValue().vlan().equals(vlan)).map(e -> e.getKey()).findFirst().orElse(null);
    SetMultimap<String, Interface> result = HashMultimap.create();
    if (vplsNetworkName != null && vplsNetworks.containsKey(vplsNetworkName)) {
        vplsNetworks.get(vplsNetworkName).forEach(intf -> result.put(vplsNetworkName, intf));
        return result;
    }
    return null;
}
#method_after
@Override
public SetMultimap<String, Interface> ifacesByVplsName(VlanId vlan, ConnectPoint connectPoint) {
    String vplsName = vplsIfaces.entries().stream().filter(e -> e.getValue().connectPoint().equals(connectPoint)).filter(e -> e.getValue().vlan().equals(vlan)).map(e -> e.getKey()).findFirst().orElse(null);
    SetMultimap<String, Interface> result = HashMultimap.create();
    if (vplsName != null && vplsIfaces.containsKey(vplsName)) {
        vplsIfaces.get(vplsName).forEach(intf -> result.put(vplsName, intf));
        return result;
    }
    return null;
}
#end_block

#method_before
private void loadConfiguration() {
    loadAppId();
    vplsAppConfig = configService.getConfig(vplsAppId, VplsAppConfig.class);
    if (vplsAppConfig == null) {
        log.warn(CONFIG_NULL);
        configService.addConfig(vplsAppId, VplsAppConfig.class);
        return;
    }
    oldIfacesOfVpls = ifacesOfVpls;
    ifacesOfVpls = getConfigInterfaces();
    vplsNetworks = getConfigCPoints();
    log.debug(CONFIG_CHANGED, ifacesOfVpls);
}
#method_after
private void loadConfiguration() {
    loadAppId();
    vplsAppConfig = configService.getConfig(vplsAppId, VplsAppConfig.class);
    if (vplsAppConfig == null) {
        log.warn(CONFIG_NULL);
        configService.addConfig(vplsAppId, VplsAppConfig.class);
        return;
    }
    oldIfacesOfVpls = ifacesOfVpls;
    ifacesOfVpls = getConfigInterfaces();
    vplsIfaces = getConfigCPoints();
    vplsEncaps = getConfigEncap();
    log.debug(CONFIG_CHANGED, ifacesOfVpls);
}
#end_block

#method_before
private SetMultimap<String, String> getConfigInterfaces() {
    SetMultimap<String, String> confIntfByVpls = HashMultimap.create();
    vplsAppConfig.vplsNetworks().forEach(vpls -> {
        if (vpls.ifaces().isEmpty()) {
            confIntfByVpls.put(vpls.name(), EMPTY);
        } else {
            vpls.ifaces().forEach(iface -> confIntfByVpls.put(vpls.name(), iface));
        }
    });
    return confIntfByVpls;
}
#method_after
private SetMultimap<String, String> getConfigInterfaces() {
    SetMultimap<String, String> confIntfByVpls = HashMultimap.create();
    vplsAppConfig.vplss().forEach(vpls -> {
        if (vpls.ifaces().isEmpty()) {
            confIntfByVpls.put(vpls.name(), EMPTY);
        } else {
            vpls.ifaces().forEach(iface -> confIntfByVpls.put(vpls.name(), iface));
        }
    });
    return confIntfByVpls;
}
#end_block

#method_before
@Override
protected void execute() {
    if (!vplsConfigService.vplsNames().contains(vplsName)) {
        print(VPLS_NOT_FOUND, vplsName);
        return;
    }
    vplsConfigService.setEncap(vplsName, encap);
}
#method_after
@Override
protected void execute() {
    if (!VplsCommandUtils.vplsExists(vplsName)) {
        print(VplsCommandUtils.VPLS_NOT_FOUND, vplsName);
        return;
    }
    vplsConfigService.setEncap(vplsName, encap);
}
#end_block

#method_before
@Override
protected void execute() {
    Set<String> vplsNames = vplsConfigService.vplsNames();
    SetMultimap<String, Interface> ifacesByVplsName = vplsConfigService.ifacesByVplsName();
    Set<String> ifaceNames = Sets.newHashSet();
    if (!isNullOrEmpty(vplsName)) {
        if (vplsNames.contains(vplsName)) {
            ifacesByVplsName.get(vplsName).stream().map(Interface::name).forEach(ifaceNames::add);
            print(NAME_FORMAT, vplsName, ifaceNames);
        } else {
            print(VPLS_NOT_FOUND, vplsName);
        }
    } else {
        vplsNames.forEach(vplsName -> {
            ifaceNames.clear();
            ifacesByVplsName.get(vplsName).stream().map(Interface::name).forEach(ifaceNames::add);
            print(NAME_FORMAT, vplsName, ifaceNames);
        });
    }
}
#method_after
@Override
protected void execute() {
    Set<String> vplsNames = vplsConfigService.vplsNames();
    Map<String, EncapsulationType> encapByVplsName = vplsConfigService.encapByVplsName();
    if (!isNullOrEmpty(vplsName)) {
        // A VPLS name is provided. Check first if the VPLS exists
        if (VplsCommandUtils.vplsExists(vplsName)) {
            print(VplsCommandUtils.VPLS_DISPLAY, vplsName, VplsCommandUtils.ifacesFromVplsName(vplsName).toString(), encapByVplsName.get(vplsName).toString());
        } else {
            print(VplsCommandUtils.VPLS_NOT_FOUND, vplsName);
        }
    } else {
        // No VPLS names are provided. Display all VPLSs configured
        vplsNames.forEach(vplsName -> {
            print(VplsCommandUtils.VPLS_DISPLAY, vplsName, VplsCommandUtils.ifacesFromVplsName(vplsName).toString(), encapByVplsName.get(vplsName).toString());
        });
    }
}
#end_block

#method_before
protected SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts, EncapsulationType encap) {
    log.debug("Building broadcast intent %s for source %s", SP2MP, src);
    SinglePointToMultiPointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intentBuilder = SinglePointToMultiPointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).priority(PRIORITY_OFFSET);
    // encapsulation type
    if (encap != null) {
        if (encap.equals(EncapsulationType.VLAN)) {
            intentBuilder.constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN)));
        } else if (encap.equals(EncapsulationType.MPLS)) {
            intentBuilder.constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.MPLS)));
        }
    }
    return intentBuilder.build();
}
#method_after
protected SinglePointToMultiPointIntent buildBrcIntent(Key key, FilteredConnectPoint src, Set<FilteredConnectPoint> dsts, EncapsulationType encap) {
    log.debug("Building broadcast intent {} for source {}", SP2MP, src);
    SinglePointToMultiPointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(MacAddress.BROADCAST).build();
    intentBuilder = SinglePointToMultiPointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoint(src).filteredEgressPoints(dsts).priority(PRIORITY_OFFSET);
    encap(intentBuilder, encap);
    return intentBuilder.build();
}
#end_block

#method_before
protected MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host, EncapsulationType encap) {
    log.debug("Building unicast intent %s for destination %s", MP2SP, dst);
    MultiPointToSinglePointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    intentBuilder = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).priority(PRIORITY_OFFSET);
    // encapsulation type
    if (encap != null) {
        if (encap.equals(EncapsulationType.VLAN)) {
            intentBuilder.constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN)));
        } else if (encap.equals(EncapsulationType.MPLS)) {
            intentBuilder.constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.MPLS)));
        }
    }
    return intentBuilder.build();
}
#method_after
protected MultiPointToSinglePointIntent buildUniIntent(Key key, Set<FilteredConnectPoint> srcs, FilteredConnectPoint dst, Host host, EncapsulationType encap) {
    log.debug("Building unicast intent {} for destination {}", MP2SP, dst);
    MultiPointToSinglePointIntent.Builder intentBuilder;
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(host.mac()).build();
    intentBuilder = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector).filteredIngressPoints(srcs).filteredEgressPoint(dst).priority(PRIORITY_OFFSET);
    encap(intentBuilder, encap);
    return intentBuilder.build();
}
#end_block

#method_before
protected Key buildKey(String prefix, ConnectPoint cPoint, String networkName, MacAddress hostMac) {
    String keyString = networkName + SEPARATOR + prefix + SEPARATOR + cPoint.deviceId() + SEPARATOR + cPoint.port() + SEPARATOR + hostMac;
    return Key.of(keyString, appId);
}
#method_after
protected Key buildKey(String prefix, ConnectPoint cPoint, String vplsName, MacAddress hostMac) {
    String keyString = vplsName + SEPARATOR + prefix + SEPARATOR + cPoint.deviceId() + SEPARATOR + cPoint.port() + SEPARATOR + hostMac;
    return Key.of(keyString, appId);
}
#end_block

#method_before
protected boolean intentExists(Key intentKey) {
    if (intentService.getIntent(intentKey) == null) {
        return false;
    }
    // Intent does not exist if intent withdrawn
    IntentState currentIntentState = intentService.getIntentState(intentKey);
    if (WITHDRAWN_INTENT_STATES.contains(currentIntentState)) {
        return false;
    }
    return true;
}
#method_after
protected boolean intentExists(Key intentKey) {
    if (intentService.getIntent(intentKey) == null) {
        return false;
    }
    // Intent does not exist if intent withdrawn
    IntentState currentIntentState = intentService.getIntentState(intentKey);
    return !WITHDRAWN_INTENT_STATES.contains(currentIntentState);
}
#end_block

#method_before
public VplsConfig getVplsWithName(String name) {
    for (VplsConfig vpls : vplsNetworks()) {
        if (vpls.name().equals(name)) {
            return vpls;
        }
    }
    return null;
}
#method_after
public VplsConfig getVplsWithName(String name) {
    return vplss().stream().filter(vpls -> vpls.name().equals(name)).findFirst().orElse(null);
}
#end_block

#method_before
public void addVpls(VplsConfig vpls) {
    ObjectNode vplsNode = JsonNodeFactory.instance.objectNode();
    vplsNode.put(NAME, vpls.name());
    ArrayNode ifacesNode = vplsNode.putArray(INTERFACE);
    vpls.ifaces().forEach(ifacesNode::add);
    vplsNode.put(ENCAPSULATION_TYPE, vpls.encapType());
    vplsNode.put(ENCAPSULATION, vpls.encap());
    ArrayNode vplsArray = vplsNetworks().isEmpty() ? initVplsConfiguration() : (ArrayNode) object.get(VPLS);
    vplsArray.add(vplsNode);
}
#method_after
public void addVpls(VplsConfig vpls) {
    ObjectNode vplsNode = JsonNodeFactory.instance.objectNode();
    vplsNode.put(NAME, vpls.name());
    ArrayNode ifacesNode = vplsNode.putArray(INTERFACE);
    vpls.ifaces().forEach(ifacesNode::add);
    vplsNode.put(ENCAPSULATION, vpls.encap().toString());
    ArrayNode vplsArray = vplss().isEmpty() ? initVplsConfiguration() : (ArrayNode) object.get(VPLS);
    vplsArray.add(vplsNode);
}
#end_block

#method_before
public void removeVpls(String name) {
    ArrayNode configuredVpls = (ArrayNode) object.get(VPLS);
    for (int i = 0; i < configuredVpls.size(); i++) {
        if (configuredVpls.get(i).hasNonNull(NAME) && configuredVpls.get(i).get(NAME).asText().equals(name)) {
            configuredVpls.remove(i);
            return;
        }
    }
}
#method_after
public void removeVpls(String vplsName) {
    ArrayNode configuredVpls = (ArrayNode) object.get(VPLS);
    for (int i = 0; i < configuredVpls.size(); i++) {
        if (configuredVpls.get(i).hasNonNull(NAME) && configuredVpls.get(i).get(NAME).asText().equals(vplsName)) {
            configuredVpls.remove(i);
            return;
        }
    }
}
#end_block

#method_before
public VplsConfig vplsFromIface(String iface) {
    for (VplsConfig vpls : vplsNetworks()) {
        if (vpls.isAttached(iface)) {
            return vpls;
        }
    }
    return null;
}
#method_after
public VplsConfig vplsFromIface(String iface) {
    for (VplsConfig vpls : vplss()) {
        if (vpls.isAttached(iface)) {
            return vpls;
        }
    }
    return null;
}
#end_block

#method_before
public void addIface(String name, String iface) {
    JsonNode vplsNodes = object.get(VPLS);
    vplsNodes.forEach(vplsNode -> {
        if (hasNamedNode(vplsNode, name)) {
            ArrayNode ifacesNode = (ArrayNode) vplsNode.get(INTERFACE);
            for (int i = 0; i < ifacesNode.size(); i++) {
                if (ifacesNode.get(i).asText().equals(iface)) {
                    // Interface already exists.
                    return;
                }
            }
            ifacesNode.add(iface);
        }
    });
}
#method_after
public void addIface(String vplsName, String iface) {
    JsonNode vplsNodes = object.get(VPLS);
    vplsNodes.forEach(vplsNode -> {
        if (hasNamedNode(vplsNode, vplsName)) {
            ArrayNode ifacesNode = (ArrayNode) vplsNode.get(INTERFACE);
            for (int i = 0; i < ifacesNode.size(); i++) {
                if (ifacesNode.get(i).asText().equals(iface)) {
                    // Interface already exists.
                    return;
                }
            }
            ifacesNode.add(iface);
        }
    });
}
#end_block

#method_before
public void setEncap(String name, boolean encap) {
    JsonNode vplsNodes = object.get(VPLS);
    vplsNodes.forEach(vplsNode -> {
        if (hasNamedNode(vplsNode, name)) {
            ((ObjectNode) vplsNode).put(ENCAPSULATION, encap);
        }
    });
}
#method_after
public void setEncap(String vplsName, EncapsulationType encap) {
    JsonNode vplsNodes = object.get(VPLS);
    vplsNodes.forEach(vplsNode -> {
        if (hasNamedNode(vplsNode, vplsName)) {
            ((ObjectNode) vplsNode).put(ENCAPSULATION, encap.toString());
        }
    });
}
#end_block

#method_before
@Before
public void setUp() {
    sut = new LinkCollectionIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    Intent.bindIdGenerator(idGenerator);
    intent = LinkCollectionIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).links(links).ingressPoints(ImmutableSet.of(d1p1)).egressPoints(ImmutableSet.of(d3p1)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(LinkCollectionIntent.class, sut);
    intentExtensionService.unregisterCompiler(LinkCollectionIntent.class);
    registrator = new IntentConfigurableRegistrator();
    registrator.extensionService = intentExtensionService;
    registrator.cfgService = new ComponentConfigAdapter();
    registrator.activate();
    sut.registrator = registrator;
    replay(coreService, intentExtensionService);
}
#method_after
@Before
public void setUp() {
    sut = new LinkCollectionIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    Intent.bindIdGenerator(idGenerator);
    intent = LinkCollectionIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).links(links).ingressPoints(ImmutableSet.of(d1p1)).egressPoints(ImmutableSet.of(d3p1)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(LinkCollectionIntent.class, sut);
    intentExtensionService.unregisterCompiler(LinkCollectionIntent.class);
    registrator = new IntentConfigurableRegistrator();
    registrator.extensionService = intentExtensionService;
    registrator.cfgService = new ComponentConfigAdapter();
    registrator.activate();
    sut.registrator = registrator;
    LinkCollectionCompiler.optimize = false;
    LinkCollectionCompiler.copyTtl = false;
    replay(coreService, intentExtensionService);
}
#end_block

#method_before
@Before
public void setUp() {
    sut = new LinkCollectionIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    Intent.bindIdGenerator(idGenerator);
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(LinkCollectionIntent.class, sut);
    intentExtensionService.unregisterCompiler(LinkCollectionIntent.class);
    registrator = new IntentConfigurableRegistrator();
    registrator.extensionService = intentExtensionService;
    registrator.cfgService = new ComponentConfigAdapter();
    registrator.activate();
    sut.registrator = registrator;
    sut.resourceService = new MockResourceService();
    replay(coreService, intentExtensionService);
}
#method_after
@Before
public void setUp() {
    sut = new LinkCollectionIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    Intent.bindIdGenerator(idGenerator);
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(LinkCollectionIntent.class, sut);
    intentExtensionService.unregisterCompiler(LinkCollectionIntent.class);
    registrator = new IntentConfigurableRegistrator();
    registrator.extensionService = intentExtensionService;
    registrator.cfgService = new ComponentConfigAdapter();
    registrator.activate();
    sut.registrator = registrator;
    sut.resourceService = new MockResourceService();
    LinkCollectionCompiler.optimize = false;
    LinkCollectionCompiler.copyTtl = false;
    replay(coreService, intentExtensionService);
}
#end_block

#method_before
private Intent createLinkCollectionIntent(Set<Link> links, double cost, PointToPointIntent intent) {
    return LinkCollectionIntent.builder().appId(intent.appId()).selector(intent.selector()).treatment(intent.treatment()).links(ImmutableSet.copyOf(links)).filteredIngressPoints(ImmutableSet.of(intent.filteredIngressPoint())).filteredEgressPoints(ImmutableSet.of(intent.filteredEgressPoint())).applyTreatmentOnEgress(true).constraints(intent.constraints()).priority(intent.priority()).cost(cost).build();
}
#method_after
private Intent createLinkCollectionIntent(Set<Link> links, double cost, PointToPointIntent intent) {
    return LinkCollectionIntent.builder().key(intent.key()).appId(intent.appId()).selector(intent.selector()).treatment(intent.treatment()).links(ImmutableSet.copyOf(links)).filteredIngressPoints(ImmutableSet.of(intent.filteredIngressPoint())).filteredEgressPoints(ImmutableSet.of(intent.filteredEgressPoint())).applyTreatmentOnEgress(true).constraints(intent.constraints()).priority(intent.priority()).cost(cost).build();
}
#end_block

#method_before
@Test
public void testSingleLongPathCompilation() {
    HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO);
    assertThat(intent, is(notNullValue()));
    String[] hops = { HOST_ONE, "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", HOST_TWO };
    HostToHostIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(2));
    Intent forwardResultIntent = result.get(0);
    assertThat(forwardResultIntent instanceof LinkCollectionIntent, is(true));
    Intent reverseResultIntent = result.get(1);
    assertThat(reverseResultIntent instanceof LinkCollectionIntent, is(true));
    if (forwardResultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent forwardLinckCollectionIntent = (LinkCollectionIntent) forwardResultIntent;
        assertThat(forwardLinckCollectionIntent.links(), hasSize(7));
        Set<FilteredConnectPoint> ingressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint("h1", 1)));
        assertThat(forwardLinckCollectionIntent.filteredIngressPoints(), is(ingressPoints));
        assertThat(forwardLinckCollectionIntent.links(), linksHasPath("h1", "h2"));
        assertThat(forwardLinckCollectionIntent.links(), linksHasPath("h2", "h3"));
        assertThat(forwardLinckCollectionIntent.links(), linksHasPath("h3", "h4"));
        assertThat(forwardLinckCollectionIntent.links(), linksHasPath("h4", "h5"));
        assertThat(forwardLinckCollectionIntent.links(), linksHasPath("h5", "h6"));
        assertThat(forwardLinckCollectionIntent.links(), linksHasPath("h6", "h7"));
        assertThat(forwardLinckCollectionIntent.links(), linksHasPath("h7", "h8"));
        Set<FilteredConnectPoint> egressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint("h8", 1)));
        assertThat(forwardLinckCollectionIntent.filteredEgressPoints(), is(egressPoints));
    }
    if (reverseResultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent reverseLinkCollectionIntent = (LinkCollectionIntent) reverseResultIntent;
        assertThat(reverseLinkCollectionIntent.links(), hasSize(7));
        Set<FilteredConnectPoint> ingressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint("h8", 1)));
        assertThat(reverseLinkCollectionIntent.filteredIngressPoints(), is(ingressPoints));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("h2", "h1"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("h3", "h2"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("h4", "h3"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("h5", "h4"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("h6", "h5"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("h7", "h6"));
        assertThat(reverseLinkCollectionIntent.links(), linksHasPath("h8", "h7"));
        Set<FilteredConnectPoint> egressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint("h1", 1)));
        assertThat(reverseLinkCollectionIntent.filteredEgressPoints(), is(egressPoints));
    }
}
#method_after
@Test
public void testSingleLongPathCompilation() {
    HostToHostIntent intent = makeIntent(HOST_ONE, HOST_TWO);
    assertThat(intent, is(notNullValue()));
    String[] hops = { HOST_ONE, HOP_1, HOP_2, HOP_3, HOP_4, HOP_5, HOP_6, HOP_7, HOP_8, HOST_TWO };
    HostToHostIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(Matchers.notNullValue()));
    assertThat(result, hasSize(2));
    Intent forwardIntent = result.get(0);
    assertThat(forwardIntent instanceof LinkCollectionIntent, is(true));
    Intent reverseIntent = result.get(1);
    assertThat(reverseIntent instanceof LinkCollectionIntent, is(true));
    LinkCollectionIntent forwardLCIntent = (LinkCollectionIntent) forwardIntent;
    Set<Link> links = forwardLCIntent.links();
    assertThat(links, hasSize(7));
    Set<FilteredConnectPoint> ingressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(HOP_1, PORT_1)));
    assertThat(forwardLCIntent.filteredIngressPoints(), is(ingressPoints));
    assertThat(links, linksHasPath(HOP_1, HOP_2));
    assertThat(links, linksHasPath(HOP_2, HOP_3));
    assertThat(links, linksHasPath(HOP_3, HOP_4));
    assertThat(links, linksHasPath(HOP_4, HOP_5));
    assertThat(links, linksHasPath(HOP_5, HOP_6));
    assertThat(links, linksHasPath(HOP_6, HOP_7));
    assertThat(links, linksHasPath(HOP_7, HOP_8));
    Set<FilteredConnectPoint> egressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(HOP_8, PORT_1)));
    assertThat(forwardLCIntent.filteredEgressPoints(), is(egressPoints));
    LinkCollectionIntent reverseLCIntent = (LinkCollectionIntent) reverseIntent;
    links = reverseLCIntent.links();
    assertThat(reverseLCIntent.links(), hasSize(7));
    ingressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(HOP_8, PORT_1)));
    assertThat(reverseLCIntent.filteredIngressPoints(), is(ingressPoints));
    assertThat(links, linksHasPath(HOP_2, HOP_1));
    assertThat(links, linksHasPath(HOP_3, HOP_2));
    assertThat(links, linksHasPath(HOP_4, HOP_3));
    assertThat(links, linksHasPath(HOP_5, HOP_4));
    assertThat(links, linksHasPath(HOP_6, HOP_5));
    assertThat(links, linksHasPath(HOP_7, HOP_6));
    assertThat(links, linksHasPath(HOP_8, HOP_7));
    egressPoints = ImmutableSet.of(new FilteredConnectPoint(connectPoint(HOP_1, PORT_1)));
    assertThat(reverseLCIntent.filteredEgressPoints(), is(egressPoints));
}
#end_block

#method_before
@Override
public List<Intent> compile(HostToHostIntent intent, List<Intent> installable) {
    // If source and destination are the same, there are never any installables.
    if (Objects.equals(intent.one(), intent.two())) {
        return ImmutableList.of();
    }
    boolean isAsymmetric = intent.constraints().contains(new AsymmetricPathConstraint());
    Path pathOne = getPath(intent, intent.one(), intent.two());
    Path pathTwo = isAsymmetric ? getPath(intent, intent.two(), intent.one()) : invertPath(pathOne);
    Host one = hostService.getHost(intent.one());
    Host two = hostService.getHost(intent.two());
    return Arrays.asList(creatLinkCollectionIntent(pathOne, one, two, intent), creatLinkCollectionIntent(pathTwo, two, one, intent));
}
#method_after
@Override
public List<Intent> compile(HostToHostIntent intent, List<Intent> installable) {
    // If source and destination are the same, there are never any installables.
    if (Objects.equals(intent.one(), intent.two())) {
        return ImmutableList.of();
    }
    boolean isAsymmetric = intent.constraints().contains(new AsymmetricPathConstraint());
    Path pathOne = getPath(intent, intent.one(), intent.two());
    Path pathTwo = isAsymmetric ? getPath(intent, intent.two(), intent.one()) : invertPath(pathOne);
    Host one = hostService.getHost(intent.one());
    Host two = hostService.getHost(intent.two());
    return Arrays.asList(createLinkCollectionIntent(pathOne, one, two, intent), createLinkCollectionIntent(pathTwo, two, one, intent));
}
#end_block

#method_before
@Test
public void testAddDevicesPostWithoutRegion() {
    expect(mockRegionService.getRegion(anyObject())).andReturn(null).anyTimes();
    replay(mockRegionService);
    WebTarget wt = target();
    InputStream jsonStream = RegionsResourceTest.class.getResourceAsStream("region-deviceIds.json");
    Response response = wt.path("regions/" + region1.id().toString() + "/devices").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_NOT_FOUND));
    verify(mockRegionService);
}
#method_after
@Test
public void testAddDevicesPostWithoutRegion() {
    expect(mockRegionService.getRegion(anyObject())).andReturn(null).anyTimes();
    replay(mockRegionService);
    WebTarget wt = target();
    InputStream jsonStream = RegionsResourceTest.class.getResourceAsStream("region-deviceIds.json");
    Response response = wt.path("regions/" + region1.id() + "/devices").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_NOT_FOUND));
    verify(mockRegionService);
}
#end_block

#method_before
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    // first we need to check whether this is an ECM
    if (msg instanceof LispEncapsulatedControl) {
        LispMessage innerMsg = extractLispMessage((LispEncapsulatedControl) msg);
        if (innerMsg instanceof LispMapRequest) {
            LispMapResolver mapResolver = new LispMapResolver();
            LispMessage lispMessage = mapResolver.processMapRequest((LispEncapsulatedControl) msg);
            // try to remove the received map-request message from buffer
            ReferenceCountUtil.release(msg);
            ctx.writeAndFlush(lispMessage);
        }
    }
    if (msg instanceof LispMapRegister) {
        LispMapServer mapServer = new LispMapServer();
        LispMapNotify mapNotify = mapServer.processMapRegister((LispMapRegister) msg);
        // try to remove the received map-register message from buffer
        ReferenceCountUtil.release(msg);
        ctx.writeAndFlush(mapNotify);
    }
    if (msg instanceof LispInfoRequest) {
        LispMapServer mapServer = new LispMapServer();
        LispInfoReply infoReply = mapServer.processInfoRequest((LispInfoRequest) msg);
        // try to remove the received info-request message from buffer
        ReferenceCountUtil.release(msg);
        ctx.writeAndFlush(infoReply);
    }
}
#method_after
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    try {
        // first we need to check whether this is an ECM
        if (msg instanceof LispEncapsulatedControl) {
            LispMessage innerMsg = extractLispMessage((LispEncapsulatedControl) msg);
            if (innerMsg instanceof LispMapRequest) {
                LispMapResolver mapResolver = new LispMapResolver();
                LispMessage lispMessage = mapResolver.processMapRequest((LispEncapsulatedControl) msg);
                ctx.writeAndFlush(lispMessage);
            }
        }
        if (msg instanceof LispMapRegister) {
            LispMapServer mapServer = new LispMapServer();
            LispMapNotify mapNotify = mapServer.processMapRegister((LispMapRegister) msg);
            ctx.writeAndFlush(mapNotify);
        }
    } finally {
        ReferenceCountUtil.release(msg);
    }
    if (msg instanceof LispInfoRequest) {
        LispMapServer mapServer = new LispMapServer();
        LispInfoReply infoReply = mapServer.processInfoRequest((LispInfoRequest) msg);
        // try to remove the received info-request message from buffer
        ReferenceCountUtil.release(msg);
        ctx.writeAndFlush(infoReply);
    }
}
#end_block

#method_before
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    log.warn(cause.getMessage());
    ctx.close();
}
#method_after
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    log.warn(cause.getMessage());
// TODO: add error handle mechanisms for each cases
}
#end_block

#method_before
@Before
public void setup() {
    InfoReplyBuilder builder1 = new DefaultInfoReplyBuilder();
    short msUdpPortNumber1 = 80;
    short etrUdpPortNumber1 = 100;
    LispIpv4Address globalEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    LispIpv4Address msRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    LispIpv4Address privateEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.3"));
    LispIpv4Address address1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.4"));
    LispNatLcafAddress natLcafAddress1 = new LispNatLcafAddress.NatAddressBuilder().withLength((short) 0).withMsUdpPortNumber(msUdpPortNumber1).withEtrUdpPortNumber(etrUdpPortNumber1).withGlobalEtrRlocAddress(globalEtrRlocAddress1).withMsRlocAddress(msRlocAddress1).withPrivateEtrRlocAddress(privateEtrRlocAddress1).build();
    reply1 = builder1.withNonce(1L).withKeyId((short) 1).withAuthKey(AUTH_KEY).withIsInfoReply(false).withMaskLength((byte) 1).withEidPrefix(address1).withNatLcafAddress(natLcafAddress1).build();
    InfoReplyBuilder builder2 = new DefaultInfoReplyBuilder();
    sameAsReply1 = builder2.withNonce(1L).withKeyId((short) 1).withAuthKey(AUTH_KEY).withIsInfoReply(false).withMaskLength((byte) 1).withEidPrefix(address1).withNatLcafAddress(natLcafAddress1).build();
    InfoReplyBuilder builder3 = new DefaultInfoReplyBuilder();
    short msUdpPortNumber2 = 81;
    short etrUdpPortNumber2 = 101;
    LispIpv4Address globalEtrRlocAddress2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.1"));
    LispIpv4Address msRlocAddress2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.2"));
    LispIpv4Address privateEtrRlocAddress2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.3"));
    LispIpv4Address address2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.4"));
    LispNatLcafAddress natLcafAddress2 = new LispNatLcafAddress.NatAddressBuilder().withLength((short) 0).withMsUdpPortNumber(msUdpPortNumber2).withEtrUdpPortNumber(etrUdpPortNumber2).withGlobalEtrRlocAddress(globalEtrRlocAddress2).withMsRlocAddress(msRlocAddress2).withPrivateEtrRlocAddress(privateEtrRlocAddress2).build();
    reply2 = builder3.withNonce(2L).withKeyId((short) 2).withAuthKey(AUTH_KEY).withIsInfoReply(true).withMaskLength((byte) 1).withEidPrefix(address2).withNatLcafAddress(natLcafAddress2).build();
}
#method_after
@Before
public void setup() {
    InfoReplyBuilder builder1 = new DefaultInfoReplyBuilder();
    short msUdpPortNumber1 = 80;
    short etrUdpPortNumber1 = 100;
    LispIpv4Address globalEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    LispIpv4Address msRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    LispIpv4Address privateEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.3"));
    LispIpv4Address address1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.4"));
    LispNatLcafAddress natLcafAddress1 = new NatAddressBuilder().withLength((short) 0).withMsUdpPortNumber(msUdpPortNumber1).withEtrUdpPortNumber(etrUdpPortNumber1).withGlobalEtrRlocAddress(globalEtrRlocAddress1).withMsRlocAddress(msRlocAddress1).withPrivateEtrRlocAddress(privateEtrRlocAddress1).build();
    reply1 = builder1.withNonce(1L).withKeyId((short) 1).withAuthKey(AUTH_KEY).withIsInfoReply(false).withMaskLength((byte) 1).withEidPrefix(address1).withNatLcafAddress(natLcafAddress1).build();
    InfoReplyBuilder builder2 = new DefaultInfoReplyBuilder();
    sameAsReply1 = builder2.withNonce(1L).withKeyId((short) 1).withAuthKey(AUTH_KEY).withIsInfoReply(false).withMaskLength((byte) 1).withEidPrefix(address1).withNatLcafAddress(natLcafAddress1).build();
    InfoReplyBuilder builder3 = new DefaultInfoReplyBuilder();
    short msUdpPortNumber2 = 81;
    short etrUdpPortNumber2 = 101;
    LispIpv4Address globalEtrRlocAddress2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.1"));
    LispIpv4Address msRlocAddress2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.2"));
    LispIpv4Address privateEtrRlocAddress2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.3"));
    LispIpv4Address address2 = new LispIpv4Address(IpAddress.valueOf("192.168.2.4"));
    LispNatLcafAddress natLcafAddress2 = new NatAddressBuilder().withLength((short) 0).withMsUdpPortNumber(msUdpPortNumber2).withEtrUdpPortNumber(etrUdpPortNumber2).withGlobalEtrRlocAddress(globalEtrRlocAddress2).withMsRlocAddress(msRlocAddress2).withPrivateEtrRlocAddress(privateEtrRlocAddress2).build();
    reply2 = builder3.withNonce(2L).withKeyId((short) 2).withAuthKey(AUTH_KEY).withIsInfoReply(true).withMaskLength((byte) 1).withEidPrefix(address2).withNatLcafAddress(natLcafAddress2).build();
}
#end_block

#method_before
@Test
public void testConstruction() {
    DefaultLispInfoReply reply = (DefaultLispInfoReply) reply1;
    LispIpv4Address address = new LispIpv4Address(IpAddress.valueOf("192.168.1.4"));
    short msUdpPortNumber1 = 80;
    short etrUdpPortNumber1 = 100;
    LispIpv4Address globalEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    LispIpv4Address msRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    LispIpv4Address privateEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.3"));
    LispNatLcafAddress natLcafAddress = new LispNatLcafAddress.NatAddressBuilder().withLength((short) 0).withMsUdpPortNumber(msUdpPortNumber1).withEtrUdpPortNumber(etrUdpPortNumber1).withGlobalEtrRlocAddress(globalEtrRlocAddress1).withMsRlocAddress(msRlocAddress1).withPrivateEtrRlocAddress(privateEtrRlocAddress1).build();
    assertThat(reply.isInfoReply(), is(false));
    assertThat(reply.getNonce(), is(1L));
    assertThat(reply.getKeyId(), is((short) 1));
    assertThat(reply.getMaskLength(), is((byte) 1));
    assertThat(reply.getPrefix(), is(address));
    assertThat(reply.getNatLcafAddress(), is(natLcafAddress));
}
#method_after
@Test
public void testConstruction() {
    DefaultLispInfoReply reply = (DefaultLispInfoReply) reply1;
    LispIpv4Address address = new LispIpv4Address(IpAddress.valueOf("192.168.1.4"));
    short msUdpPortNumber1 = 80;
    short etrUdpPortNumber1 = 100;
    LispIpv4Address globalEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.1"));
    LispIpv4Address msRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.2"));
    LispIpv4Address privateEtrRlocAddress1 = new LispIpv4Address(IpAddress.valueOf("192.168.1.3"));
    LispNatLcafAddress natLcafAddress = new NatAddressBuilder().withLength((short) 0).withMsUdpPortNumber(msUdpPortNumber1).withEtrUdpPortNumber(etrUdpPortNumber1).withGlobalEtrRlocAddress(globalEtrRlocAddress1).withMsRlocAddress(msRlocAddress1).withPrivateEtrRlocAddress(privateEtrRlocAddress1).build();
    assertThat(reply.isInfoReply(), is(false));
    assertThat(reply.getNonce(), is(1L));
    assertThat(reply.getKeyId(), is((short) 1));
    assertThat(reply.getMaskLength(), is((byte) 1));
    assertThat(reply.getPrefix(), is(address));
    assertThat(reply.getNatLcafAddress(), is(natLcafAddress));
}
#end_block

#method_before
@Override
public boolean isRelevant(DeviceEvent event) {
    return event.subject().type() == SWITCH && event.type() == DEVICE_REMOVED;
}
#method_after
@Override
public boolean isRelevant(DeviceEvent event) {
    return event.subject().type() != CONTROLLER && event.type() == DEVICE_REMOVED;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.net.intent");
    registrator.registerCompiler(LinkCollectionIntent.class, this, false);
    labelAllocator = new LabelAllocator(resourceService);
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.net.intent");
    registrator.registerCompiler(LinkCollectionIntent.class, this, false);
    if (labelAllocator == null) {
        labelAllocator = new LabelAllocator(resourceService);
    }
}
#end_block

#method_before
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint) x).findAny();
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    List<FlowRule> rules = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        rules.addAll(createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels));
    }
    return Collections.singletonList(new FlowRuleIntent(appId, rules, intent.resources()));
}
#method_after
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    List<FlowRule> rules = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keySet()) {
        rules.addAll(createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels));
    }
    return Collections.singletonList(new FlowRuleIntent(appId, rules, intent.resources()));
}
#end_block

#method_before
@Override
protected List<FlowRule> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> labels) {
    List<FlowRule> rules = new ArrayList<>(inPorts.size());
    /**
     * Looking for the encapsulation constraint
     */
    Optional<EncapsulationConstraint> encapConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint) x).findAny();
    inPorts.forEach(inport -> {
        ForwardingInstructions instructions = null;
        if (!encapConstraint.isPresent() || intent.links().isEmpty()) {
            instructions = this.createForwardingInstructions(intent, inport, deviceId, outPorts);
        } else {
            /**
             * We retrieve the labels for this iteration;
             */
            Identifier<?> inLabel = labels.get(new ConnectPoint(deviceId, inport));
            Map<ConnectPoint, Identifier<?>> outLabels = Maps.newHashMap();
            outPorts.forEach(outPort -> {
                ConnectPoint key = new ConnectPoint(deviceId, outPort);
                outLabels.put(key, labels.get(key));
            });
            instructions = this.createForwardingInstructions(intent, inport, inLabel, deviceId, outPorts, outLabels, encapConstraint.get().encapType());
        }
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(instructions.selector()).withTreatment(instructions.treatment()).withPriority(intent.priority()).fromApp(appId).makePermanent().build();
        rules.add(rule);
    });
    return rules;
}
#method_after
@Override
protected List<FlowRule> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> labels) {
    List<FlowRule> rules = new ArrayList<>(inPorts.size());
    /*
         * Looking for the encapsulation constraint
         */
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    inPorts.forEach(inport -> {
        ForwardingInstructions instructions = this.createForwardingInstruction(encapConstraint, intent, inport, outPorts, deviceId, labels);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(instructions.selector()).withTreatment(instructions.treatment()).withPriority(intent.priority()).fromApp(appId).makePermanent().build();
        rules.add(rule);
    });
    return rules;
}
#end_block

#method_before
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, DeviceId deviceId, Set<PortNumber> outPorts) {
    /**
     * We build an empty treatment and we initialize the selector with
     * the intent selector.
     */
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
    selectorBuilder.matchInPort(inPort);
    if (!intent.applyTreatmentOnEgress()) {
        /**
         * We assume this set of instructions is called by
         * a mp2sp intent
         */
        if (intent.filteredEgressPoints().size() != 1) {
            throw new IntentCompilationException("Egress points not equal to 1 " + "and apply treatment at ingress, " + "which treaments should I apply ???");
        }
        /**
         * We try to understand if the device is one of the ingress points.
         */
        Optional<FilteredConnectPoint> filteredIngressPoint = getFilteredConnectPointFromIntent(deviceId, inPort, intent);
        /**
         * We retrieve from the Intent the unique egress points.
         */
        Optional<FilteredConnectPoint> filteredEgressPoint = intent.filteredEgressPoints().stream().findFirst();
        /**
         * We check if the device is the ingress device
         */
        if (filteredIngressPoint.isPresent()) {
            /**
             * We are at ingress, so basically what we have to do is this:
             * apply a set of operations (treatment, FEP) in order to have
             * a transition from the initial state to the final state.
             *
             * We initialize the treatment with the Intent treatment
             */
            intent.treatment().allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
            /**
             * We check if the egress point is set.
             */
            if (filteredEgressPoint.isPresent()) {
                /**
                 * We build the final selector, adding the selector
                 * of the FIP to the Intent selector and potentially
                 * overriding its matches.
                 */
                filteredIngressPoint.get().trafficSelector().criteria().forEach(selectorBuilder::add);
                /**
                 * We define the transition FIP->FEP, basically
                 * the set of the operations we need for reaching
                 * the final state.
                 */
                TrafficTreatment forwardingTreatment = forwardingTreatment(filteredIngressPoint.get().trafficSelector(), filteredEgressPoint.get().trafficSelector(), this.getEthType(intent.selector()));
                /**
                 * We add to the treatment the actions necessary for the
                 * transition, potentially overriding the treatment of the
                 * Intent. The Intent treatment has always a low priority
                 * in respect of the FEP.
                 */
                forwardingTreatment.allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
            } else {
                /**
                 * Wrong scenario, we cannot handle this.
                 */
                throw new IntentCompilationException("Can't find filtered connection point");
            }
        } else {
            /**
             * We are in the core or in the egress switch.
             * The packets are in their final state. We need
             * to match against this final state.
             *
             * we derive the final state defined by the intent
             * treatment.
             */
            updateBuilder(selectorBuilder, intent.treatment());
            /**
             * We derive the final state defined by the unique
             * FEP. We merge the two states.
             */
            if (filteredEgressPoint.isPresent()) {
                filteredEgressPoint.get().trafficSelector().criteria().forEach(selectorBuilder::add);
            } else {
                /**
                 * Wrong scenario, we cannot handle this.
                 */
                throw new IntentCompilationException("Can't find filtered connection point");
            }
        }
        /**
         * Finally we set the output action.
         */
        outPorts.forEach(treatmentBuilder::setOutput);
    } else {
        /**
         * We assume this set of instructions is called by
         * sp2mp or p2p intents.
         */
        if (intent.filteredIngressPoints().size() != 1) {
            throw new IntentCompilationException("Ingress points not equal to 1 " + "and apply treatment at egress, " + "how can I match in the core ???");
        }
        /**
         * For the p2p and sp2mp the transition initial state
         * to final state is performed at the egress.
         */
        Optional<FilteredConnectPoint> filteredIngressPoint = intent.filteredIngressPoints().stream().findFirst();
        /**
         * We build the final selector, adding the selector
         * of the FIP to the Intent selector and potentially
         * overriding its matches.
         */
        if (filteredIngressPoint.isPresent()) {
            filteredIngressPoint.get().trafficSelector().criteria().forEach(selectorBuilder::add);
        } else {
            /**
             * Wrong scenario, we cannot handle this.
             */
            throw new IntentCompilationException("Filtered connection point for ingress" + "point does not exist");
        }
        /**
         * In this scenario, potentially we can have several output
         * ports.
         */
        for (PortNumber outPort : outPorts) {
            Optional<FilteredConnectPoint> filteredEgressPoint = getFilteredConnectPointFromIntent(deviceId, outPort, intent);
            /**
             * If we are at the egress, we have to transit to the final
             * state.
             */
            if (filteredEgressPoint.isPresent()) {
                /**
                 * We add the Intent treatment.
                 */
                intent.treatment().allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
                /**
                 * We generate the transition FIP->FEP.
                 */
                TrafficTreatment forwardingTreatment = forwardingTreatment(filteredIngressPoint.get().trafficSelector(), filteredEgressPoint.get().trafficSelector(), this.getEthType(intent.selector()));
                /**
                 * We add the instruction necessary to the transition.
                 * Potentially we override the intent treatment.
                 */
                forwardingTreatment.allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
            }
            /**
             * Finally we set the output action.
             */
            treatmentBuilder.setOutput(outPort);
        }
    }
    /**
     * We return selector and treatment necessary to build the flow rule
     * or the flow objective.
     */
    return new ForwardingInstructions(treatmentBuilder.build(), selectorBuilder.build());
}
#method_after
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, DeviceId deviceId, Set<PortNumber> outPorts) {
    /*
         * We build an empty treatment and we initialize the selector with
         * the intent selector.
         */
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder(intent.selector()).matchInPort(inPort);
    if (!intent.applyTreatmentOnEgress()) {
        manageMpIntent(selectorBuilder, treatmentBuilder, intent, inPort, deviceId, outPorts);
    } else {
        manageSpIntent(selectorBuilder, treatmentBuilder, intent, deviceId, outPorts);
    }
    /*
         * We return selector and treatment necessary to build the flow rule
         * or the flow objective.
         */
    return new ForwardingInstructions(treatmentBuilder.build(), selectorBuilder.build());
}
#end_block

#method_before
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, Identifier<?> inLabel, DeviceId deviceId, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> outLabels, EncapsulationType type) {
    /**
     * We build an empty treatment and an empty selector.
     */
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchInPort(inPort);
    Optional<FilteredConnectPoint> filteredIngressPoint = getFilteredConnectPointFromIntent(deviceId, inPort, intent);
    /**
     * Ingress
     */
    if (filteredIngressPoint.isPresent()) {
        /**
         * We fill the selector builder with the intent selector.
         */
        intent.selector().criteria().forEach(selectorBuilder::add);
        /**
         * We build the final selector, adding the selector
         * of the FIP to the Intent selector and potentially
         * overriding its matches.
         */
        filteredIngressPoint.get().trafficSelector().criteria().forEach(selectorBuilder::add);
        /**
         * In this scenario, we can have several output ports.
         */
        outPorts.forEach(outPort -> {
            Optional<FilteredConnectPoint> filteredEgressPoint = getFilteredConnectPointFromIntent(deviceId, outPort, intent);
            /**
             * If we are at the egress, we don't handle
             * with encapsulation. Error scenario
             */
            if (filteredEgressPoint.isPresent()) {
                throw new IntentCompilationException("Wrong scenario - 1 hop with " + "encapsualtion");
            /**
             * Transit/core, we have to transit to the intermediate
             * state.
             */
            } else {
                /**
                 * We build a temporary selector for the encapsulation.
                 */
                TrafficSelector.Builder encapBuilder = DefaultTrafficSelector.builder();
                /**
                 * We retrieve the associated label to the output port.
                 */
                ConnectPoint cp = new ConnectPoint(deviceId, outPort);
                Identifier<?> outLabel = outLabels.get(cp);
                /**
                 * If there aren't labels, we cannot handle.
                 */
                if (outLabel == null) {
                    throw new IntentCompilationException("No available label for " + cp);
                }
                /**
                 * In the core we match using encapsulation.
                 */
                this.createSelectorFromEncapsulation(encapBuilder, type, outLabel);
                /**
                 * We generate the transition.
                 */
                TrafficTreatment forwardingTreatment = forwardingTreatment(filteredIngressPoint.get().trafficSelector(), encapBuilder.build(), this.getEthType(intent.selector()));
                /**
                 * We add the instruction necessary to the transition.
                 */
                forwardingTreatment.allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
            }
            /**
             * Finally we set the output action.
             */
            treatmentBuilder.setOutput(outPort);
        });
    /**
     * Core or Egress
     */
    } else {
        /**
         * If there are not labels, we cannot handle.
         */
        ConnectPoint inCp = new ConnectPoint(deviceId, inPort);
        if (inLabel == null) {
            throw new IntentCompilationException("No available label for " + inCp);
        }
        /**
         * In the core and at egress we match using encapsulation.
         */
        this.createSelectorFromEncapsulation(selectorBuilder, type, inLabel);
        /**
         * We need to order the actions. First the actions
         * related to the not-egress points.
         */
        outPorts.forEach(outPort -> {
            Optional<FilteredConnectPoint> filteredEgressPoint = getFilteredConnectPointFromIntent(deviceId, outPort, intent);
            if (!filteredEgressPoint.isPresent()) {
                /**
                 * We build a temporary selector for the encapsulation.
                 */
                TrafficSelector.Builder encapBuilder = DefaultTrafficSelector.builder();
                /**
                 * We retrieve the associated label to the output port.
                 */
                ConnectPoint cp = new ConnectPoint(deviceId, outPort);
                Identifier<?> outLabel = outLabels.get(cp);
                /**
                 * If there are not labels, we cannot handle.
                 */
                if (outLabel == null) {
                    throw new IntentCompilationException("No available label for " + cp);
                }
                /**
                 * In the core we match using encapsulation.
                 */
                this.createSelectorFromEncapsulation(encapBuilder, type, outLabel);
                /**
                 * We generate the transition.
                 */
                TrafficTreatment forwardingTreatment = forwardingTreatment(selectorBuilder.build(), encapBuilder.build(), this.getEthType(intent.selector()));
                /**
                 * We add the instruction necessary to the transition.
                 */
                forwardingTreatment.allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
                /**
                 * Finally we set the output action.
                 */
                treatmentBuilder.setOutput(outPort);
            }
        });
        /**
         * In this case, we have to transit to the final
         * state.
         */
        outPorts.forEach(outPort -> {
            Optional<FilteredConnectPoint> filteredEgressPoint = getFilteredConnectPointFromIntent(deviceId, outPort, intent);
            if (filteredEgressPoint.isPresent()) {
                /**
                 * We add the Intent treatment to the final
                 * treatment.
                 */
                intent.treatment().allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
                /**
                 * We generate the transition FIP->FEP.
                 */
                TrafficTreatment forwardingTreatment = forwardingTreatment(selectorBuilder.build(), filteredEgressPoint.get().trafficSelector(), this.getEthType(intent.selector()));
                /**
                 * We add the instruction necessary to the transition.
                 * Potentially we override the intent treatment.
                 */
                forwardingTreatment.allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
                /**
                 * Finally we set the output action.
                 */
                treatmentBuilder.setOutput(outPort);
            }
        });
    }
    /**
     * We return selector and treatment necessary to build the flow rule
     * or the flow objective.
     */
    return new ForwardingInstructions(treatmentBuilder.build(), selectorBuilder.build());
}
#method_after
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, Identifier<?> inLabel, DeviceId deviceId, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> outLabels, EncapsulationType type) {
    /*
         * We build an empty treatment and an empty selector.
         */
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchInPort(inPort);
    Optional<FilteredConnectPoint> filteredIngressPoint = getFilteredConnectPointFromIntent(deviceId, inPort, intent);
    if (filteredIngressPoint.isPresent()) {
        manageEncapAtIngress(selectorBuilder, treatmentBuilder, intent, inPort, deviceId, outPorts, outLabels, type);
    } else {
        manageEncapAtCoreAndEgress(selectorBuilder, treatmentBuilder, intent, inPort, inLabel, deviceId, outPorts, outLabels, type);
    }
    /*
         * We return selector and treatment necessary to build the flow rule
         * or the flow objective.
         */
    return new ForwardingInstructions(treatmentBuilder.build(), selectorBuilder.build());
}
#end_block

#method_before
private void updateBuilder(TrafficSelector.Builder builder, L0ModificationInstruction l0instruction) {
    throw new IntentCompilationException("L0 not supported");
}
#method_after
private void updateBuilder(TrafficSelector.Builder builder, L0ModificationInstruction l0instruction) {
    throw new IntentCompilationException(UNSUPPORTED_L0);
}
#end_block

#method_before
private void updateBuilder(TrafficSelector.Builder builder, L1ModificationInstruction l1instruction) {
    throw new IntentCompilationException("L1 not supported");
}
#method_after
private void updateBuilder(TrafficSelector.Builder builder, L1ModificationInstruction l1instruction) {
    throw new IntentCompilationException(UNSUPPORTED_L1);
}
#end_block

#method_before
private void updateBuilder(TrafficSelector.Builder builder, L2ModificationInstruction l2instruction) {
    switch(l2instruction.subtype()) {
        case ETH_SRC:
        case ETH_DST:
            ModEtherInstruction ethInstr = (ModEtherInstruction) l2instruction;
            switch(ethInstr.subtype()) {
                case ETH_SRC:
                    builder.matchEthSrc(ethInstr.mac());
                    break;
                case ETH_DST:
                    builder.matchEthDst(ethInstr.mac());
                    break;
                default:
                    throw new IntentCompilationException("Bad eth subtype");
            }
            break;
        case VLAN_ID:
            ModVlanIdInstruction vlanIdInstr = (ModVlanIdInstruction) l2instruction;
            builder.matchVlanId(vlanIdInstr.vlanId());
            break;
        case VLAN_PUSH:
            // FIXME
            break;
        case VLAN_POP:
            // TODO how do we handle dropped label? remove the selector?
            throw new IntentCompilationException("Can't handle pop label");
        case VLAN_PCP:
            ModVlanPcpInstruction vlanPcpInstruction = (ModVlanPcpInstruction) l2instruction;
            builder.matchVlanPcp(vlanPcpInstruction.vlanPcp());
            break;
        case MPLS_LABEL:
        case MPLS_PUSH:
            // FIXME
            ModMplsLabelInstruction mplsInstr = (ModMplsLabelInstruction) l2instruction;
            builder.matchMplsLabel(mplsInstr.label());
            break;
        case MPLS_POP:
            // TODO how do we handle dropped label? remove the selector?
            throw new IntentCompilationException("Can't handle pop label");
        case DEC_MPLS_TTL:
            // no-op
            break;
        case MPLS_BOS:
            ModMplsBosInstruction mplsBosInstr = (ModMplsBosInstruction) l2instruction;
            builder.matchMplsBos(mplsBosInstr.mplsBos());
            break;
        case TUNNEL_ID:
            ModTunnelIdInstruction tunInstr = (ModTunnelIdInstruction) l2instruction;
            builder.matchTunnelId(tunInstr.tunnelId());
            break;
        default:
            throw new IntentCompilationException("Unknown L2 Modification instruction");
    }
}
#method_after
private void updateBuilder(TrafficSelector.Builder builder, L2ModificationInstruction l2instruction) {
    switch(l2instruction.subtype()) {
        case ETH_SRC:
        case ETH_DST:
            ModEtherInstruction ethInstr = (ModEtherInstruction) l2instruction;
            switch(ethInstr.subtype()) {
                case ETH_SRC:
                    builder.matchEthSrc(ethInstr.mac());
                    break;
                case ETH_DST:
                    builder.matchEthDst(ethInstr.mac());
                    break;
                default:
                    throw new IntentCompilationException(UNSUPPORTED_ETH_SUBTYPE);
            }
            break;
        case VLAN_ID:
            ModVlanIdInstruction vlanIdInstr = (ModVlanIdInstruction) l2instruction;
            builder.matchVlanId(vlanIdInstr.vlanId());
            break;
        case VLAN_PUSH:
            // FIXME
            break;
        case VLAN_POP:
            // TODO how do we handle dropped label? remove the selector?
            throw new IntentCompilationException(UNSUPPORTED_POP_ACTION);
        case VLAN_PCP:
            ModVlanPcpInstruction vlanPcpInstruction = (ModVlanPcpInstruction) l2instruction;
            builder.matchVlanPcp(vlanPcpInstruction.vlanPcp());
            break;
        case MPLS_LABEL:
        case MPLS_PUSH:
            // FIXME
            ModMplsLabelInstruction mplsInstr = (ModMplsLabelInstruction) l2instruction;
            builder.matchMplsLabel(mplsInstr.label());
            break;
        case MPLS_POP:
            // TODO how do we handle dropped label? remove the selector?
            throw new IntentCompilationException(UNSUPPORTED_POP_ACTION);
        case DEC_MPLS_TTL:
            // no-op
            break;
        case MPLS_BOS:
            ModMplsBosInstruction mplsBosInstr = (ModMplsBosInstruction) l2instruction;
            builder.matchMplsBos(mplsBosInstr.mplsBos());
            break;
        case TUNNEL_ID:
            ModTunnelIdInstruction tunInstr = (ModTunnelIdInstruction) l2instruction;
            builder.matchTunnelId(tunInstr.tunnelId());
            break;
        default:
            throw new IntentCompilationException(UNSUPPORTED_L2);
    }
}
#end_block

#method_before
private void updateBuilder(TrafficSelector.Builder builder, L3ModificationInstruction l3instruction) {
    // TODO check ethernet proto
    switch(l3instruction.subtype()) {
        case IPV4_SRC:
        case IPV4_DST:
        case IPV6_SRC:
        case IPV6_DST:
            ModIPInstruction ipInstr = (ModIPInstruction) l3instruction;
            // TODO check if ip falls in original prefix
            IpPrefix prefix = ipInstr.ip().toIpPrefix();
            switch(ipInstr.subtype()) {
                case IPV4_SRC:
                    builder.matchIPSrc(prefix);
                    break;
                case IPV4_DST:
                    builder.matchIPSrc(prefix);
                    break;
                case IPV6_SRC:
                    builder.matchIPv6Src(prefix);
                    break;
                case IPV6_DST:
                    builder.matchIPv6Dst(prefix);
                    break;
                default:
                    throw new IntentCompilationException("Bad type for IP instruction");
            }
            break;
        case IPV6_FLABEL:
            ModIPv6FlowLabelInstruction ipFlowInstr = (ModIPv6FlowLabelInstruction) l3instruction;
            builder.matchIPv6FlowLabel(ipFlowInstr.flowLabel());
            break;
        case DEC_TTL:
            // no-op
            break;
        case TTL_OUT:
            // no-op
            break;
        case TTL_IN:
            // no-op
            break;
        case ARP_SPA:
            ModArpIPInstruction arpIpInstr = (ModArpIPInstruction) l3instruction;
            if (arpIpInstr.ip().isIp4()) {
                builder.matchArpSpa((Ip4Address) arpIpInstr.ip());
            } else {
                throw new IntentCompilationException("IPv6 not supported for ARP");
            }
            break;
        case ARP_SHA:
            ModArpEthInstruction arpEthInstr = (ModArpEthInstruction) l3instruction;
            builder.matchArpSha(arpEthInstr.mac());
            break;
        case ARP_OP:
            ModArpOpInstruction arpOpInstr = (ModArpOpInstruction) l3instruction;
            // FIXME is the long to int cast safe?
            builder.matchArpOp((int) arpOpInstr.op());
            break;
        default:
            throw new IntentCompilationException("Unknown L3 Modification instruction");
    }
}
#method_after
private void updateBuilder(TrafficSelector.Builder builder, L3ModificationInstruction l3instruction) {
    // TODO check ethernet proto
    switch(l3instruction.subtype()) {
        case IPV4_SRC:
        case IPV4_DST:
        case IPV6_SRC:
        case IPV6_DST:
            ModIPInstruction ipInstr = (ModIPInstruction) l3instruction;
            // TODO check if ip falls in original prefix
            IpPrefix prefix = ipInstr.ip().toIpPrefix();
            switch(ipInstr.subtype()) {
                case IPV4_SRC:
                    builder.matchIPSrc(prefix);
                    break;
                case IPV4_DST:
                    builder.matchIPSrc(prefix);
                    break;
                case IPV6_SRC:
                    builder.matchIPv6Src(prefix);
                    break;
                case IPV6_DST:
                    builder.matchIPv6Dst(prefix);
                    break;
                default:
                    throw new IntentCompilationException(UNSUPPORTED_IP_SUBTYPE);
            }
            break;
        case IPV6_FLABEL:
            ModIPv6FlowLabelInstruction ipFlowInstr = (ModIPv6FlowLabelInstruction) l3instruction;
            builder.matchIPv6FlowLabel(ipFlowInstr.flowLabel());
            break;
        case DEC_TTL:
            // no-op
            break;
        case TTL_OUT:
            // no-op
            break;
        case TTL_IN:
            // no-op
            break;
        case ARP_SPA:
            ModArpIPInstruction arpIpInstr = (ModArpIPInstruction) l3instruction;
            if (arpIpInstr.ip().isIp4()) {
                builder.matchArpSpa((Ip4Address) arpIpInstr.ip());
            } else {
                throw new IntentCompilationException(UNSUPPORTED_ARP);
            }
            break;
        case ARP_SHA:
            ModArpEthInstruction arpEthInstr = (ModArpEthInstruction) l3instruction;
            builder.matchArpSha(arpEthInstr.mac());
            break;
        case ARP_OP:
            ModArpOpInstruction arpOpInstr = (ModArpOpInstruction) l3instruction;
            // FIXME is the long to int cast safe?
            builder.matchArpOp((int) arpOpInstr.op());
            break;
        default:
            throw new IntentCompilationException(UNSUPPORTED_L3);
    }
}
#end_block

#method_before
private void updateBuilder(TrafficSelector.Builder builder, L4ModificationInstruction l4instruction) {
    if (l4instruction instanceof ModTransportPortInstruction) {
        // TODO check IP proto
        ModTransportPortInstruction l4mod = (ModTransportPortInstruction) l4instruction;
        switch(l4mod.subtype()) {
            case TCP_SRC:
                builder.matchTcpSrc(l4mod.port());
                break;
            case TCP_DST:
                builder.matchTcpDst(l4mod.port());
                break;
            case UDP_SRC:
                builder.matchUdpSrc(l4mod.port());
                break;
            case UDP_DST:
                builder.matchUdpDst(l4mod.port());
                break;
            default:
                throw new IntentCompilationException("Unknown L4 Modification instruction");
        }
    } else {
        throw new IntentCompilationException("Unknown L4 Modification instruction");
    }
}
#method_after
private void updateBuilder(TrafficSelector.Builder builder, L4ModificationInstruction l4instruction) {
    if (l4instruction instanceof ModTransportPortInstruction) {
        // TODO check IP proto
        ModTransportPortInstruction l4mod = (ModTransportPortInstruction) l4instruction;
        switch(l4mod.subtype()) {
            case TCP_SRC:
                builder.matchTcpSrc(l4mod.port());
                break;
            case TCP_DST:
                builder.matchTcpDst(l4mod.port());
                break;
            case UDP_SRC:
                builder.matchUdpSrc(l4mod.port());
                break;
            case UDP_DST:
                builder.matchUdpDst(l4mod.port());
                break;
            default:
                throw new IntentCompilationException(UNSUPPORTED_L4_SUBTYPE);
        }
    } else {
        throw new IntentCompilationException(UNSUPPORTED_L4);
    }
}
#end_block

#method_before
private void updateBuilder(TrafficSelector.Builder builder, TrafficTreatment treatment) {
    treatment.allInstructions().forEach(instruction -> {
        switch(instruction.type()) {
            case L0MODIFICATION:
                updateBuilder(builder, (L0ModificationInstruction) instruction);
                break;
            case L1MODIFICATION:
                updateBuilder(builder, (L1ModificationInstruction) instruction);
                break;
            case L2MODIFICATION:
                updateBuilder(builder, (L2ModificationInstruction) instruction);
                break;
            case L3MODIFICATION:
                updateBuilder(builder, (L3ModificationInstruction) instruction);
                break;
            case L4MODIFICATION:
                updateBuilder(builder, (L4ModificationInstruction) instruction);
                break;
            case NOACTION:
            case OUTPUT:
            case GROUP:
            case QUEUE:
            case TABLE:
            case METER:
            case METADATA:
            case // TODO is extension no-op or unsupported?
            EXTENSION:
                // Nothing to do
                break;
            default:
                throw new IntentCompilationException("Unknown instruction type");
        }
    });
}
#method_after
private void updateBuilder(TrafficSelector.Builder builder, TrafficTreatment treatment) {
    treatment.allInstructions().forEach(instruction -> {
        switch(instruction.type()) {
            case L0MODIFICATION:
                updateBuilder(builder, (L0ModificationInstruction) instruction);
                break;
            case L1MODIFICATION:
                updateBuilder(builder, (L1ModificationInstruction) instruction);
                break;
            case L2MODIFICATION:
                updateBuilder(builder, (L2ModificationInstruction) instruction);
                break;
            case L3MODIFICATION:
                updateBuilder(builder, (L3ModificationInstruction) instruction);
                break;
            case L4MODIFICATION:
                updateBuilder(builder, (L4ModificationInstruction) instruction);
                break;
            case NOACTION:
            case OUTPUT:
            case GROUP:
            case QUEUE:
            case TABLE:
            case METER:
            case METADATA:
            case // TODO is extension no-op or unsupported?
            EXTENSION:
                // Nothing to do
                break;
            default:
                throw new IntentCompilationException(UNSUPPORTED_INSTRUCTION);
        }
    });
}
#end_block

#method_before
private EthType getEthType(TrafficSelector selector) {
    Criterion c = selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (c != null && c instanceof EthTypeCriterion) {
        EthTypeCriterion ethertype = (EthTypeCriterion) c;
        return ethertype.ethType();
    } else {
        return EthType.EtherType.IPV4.ethType();
    }
}
#method_after
private EthType getEthType(TrafficSelector selector) {
    Criterion c = selector.getCriterion(Criterion.Type.ETH_TYPE);
    if (c != null && c instanceof EthTypeCriterion) {
        EthTypeCriterion ethertype = (EthTypeCriterion) c;
        return ethertype.ethType();
    }
    return EthType.EtherType.IPV4.ethType();
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.net.intent");
    registrator.registerCompiler(LinkCollectionIntent.class, this, true);
    labelAllocator = new LabelAllocator(resourceService);
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.net.intent");
    registrator.registerCompiler(LinkCollectionIntent.class, this, true);
    if (labelAllocator == null) {
        labelAllocator = new LabelAllocator(resourceService);
    }
}
#end_block

#method_before
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint) x).findAny();
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    List<Objective> objectives = new ArrayList<>();
    List<DeviceId> devices = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keys()) {
        List<Objective> deviceObjectives = createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels);
        deviceObjectives.forEach(objective -> {
            objectives.add(objective);
            devices.add(deviceId);
        });
    }
    return Collections.singletonList(new FlowObjectiveIntent(appId, devices, objectives, intent.resources()));
}
#method_after
@Override
public List<Intent> compile(LinkCollectionIntent intent, List<Intent> installable) {
    SetMultimap<DeviceId, PortNumber> inputPorts = HashMultimap.create();
    SetMultimap<DeviceId, PortNumber> outputPorts = HashMultimap.create();
    Map<ConnectPoint, Identifier<?>> labels = ImmutableMap.of();
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    computePorts(intent, inputPorts, outputPorts);
    if (encapConstraint.isPresent()) {
        labels = labelAllocator.assignLabelToPorts(intent.links(), intent.id(), encapConstraint.get().encapType());
    }
    List<Objective> objectives = new ArrayList<>();
    List<DeviceId> devices = new ArrayList<>();
    for (DeviceId deviceId : outputPorts.keys()) {
        List<Objective> deviceObjectives = createRules(intent, deviceId, inputPorts.get(deviceId), outputPorts.get(deviceId), labels);
        deviceObjectives.forEach(objective -> {
            objectives.add(objective);
            devices.add(deviceId);
        });
    }
    return Collections.singletonList(new FlowObjectiveIntent(appId, devices, objectives, intent.resources()));
}
#end_block

#method_before
@Override
protected List<Objective> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> labels) {
    List<Objective> objectives = new ArrayList<>(inPorts.size());
    /**
     * Looking for the encapsulation constraint
     */
    Optional<EncapsulationConstraint> encapConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint) x).findAny();
    inPorts.forEach(inport -> {
        ForwardingInstructions instructions = null;
        if (!encapConstraint.isPresent() || intent.links().isEmpty()) {
            instructions = this.createForwardingInstructions(intent, inport, deviceId, outPorts);
        } else {
            /**
             * We retrieve the labels for this iteration;
             */
            Identifier<?> inLabel = labels.get(new ConnectPoint(deviceId, inport));
            Map<ConnectPoint, Identifier<?>> outLabels = Maps.newHashMap();
            outPorts.forEach(outPort -> {
                ConnectPoint key = new ConnectPoint(deviceId, outPort);
                outLabels.put(key, labels.get(key));
            });
            instructions = this.createForwardingInstructions(intent, inport, inLabel, deviceId, outPorts, outLabels, encapConstraint.get().encapType());
        }
        NextObjective nextObjective = DefaultNextObjective.builder().withId(flowObjectiveService.allocateNextId()).addTreatment(instructions.treatment()).withType(NextObjective.Type.SIMPLE).fromApp(appId).makePermanent().add();
        objectives.add(nextObjective);
        objectives.add(DefaultForwardingObjective.builder().withSelector(instructions.selector()).nextStep(nextObjective.id()).withPriority(intent.priority()).fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.SPECIFIC).add());
    });
    return objectives;
}
#method_after
@Override
protected List<Objective> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts, Map<ConnectPoint, Identifier<?>> labels) {
    List<Objective> objectives = new ArrayList<>(inPorts.size());
    /*
         * Looking for the encapsulation constraint
         */
    Optional<EncapsulationConstraint> encapConstraint = this.getIntentEncapConstraint(intent);
    inPorts.forEach(inport -> {
        ForwardingInstructions instructions = this.createForwardingInstruction(encapConstraint, intent, inport, outPorts, deviceId, labels);
        NextObjective nextObjective = DefaultNextObjective.builder().withId(flowObjectiveService.allocateNextId()).addTreatment(instructions.treatment()).withType(NextObjective.Type.SIMPLE).fromApp(appId).makePermanent().add();
        objectives.add(nextObjective);
        objectives.add(DefaultForwardingObjective.builder().withSelector(instructions.selector()).nextStep(nextObjective.id()).withPriority(intent.priority()).fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.SPECIFIC).add());
    });
    return objectives;
}
#end_block

#method_before
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    // first we need to check whether this is an ECM
    if (msg instanceof LispEncapsulatedControl) {
        LispMessage innerMsg = extractLispMessage((LispEncapsulatedControl) msg);
        if (innerMsg instanceof LispMapRequest) {
            LispMapResolver mapResolver = new LispMapResolver();
            LispMessage lispMessage = mapResolver.processMapRequest((LispEncapsulatedControl) msg);
            // try to remove the received map-request message from buffer
            ReferenceCountUtil.release(msg);
            if (lispMessage != null) {
                ctx.writeAndFlush(lispMessage);
            }
        }
    }
    if (msg instanceof LispMapRegister) {
        LispMapServer mapServer = new LispMapServer();
        LispMapNotify mapNotify = mapServer.processMapRegister((LispMapRegister) msg);
        // try to remove the received map-register message from buffer
        ReferenceCountUtil.release(msg);
        if (mapNotify != null) {
            ctx.writeAndFlush(mapNotify);
        }
    }
}
#method_after
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    try {
        // first we need to check whether this is an ECM
        if (msg instanceof LispEncapsulatedControl) {
            LispMessage innerMsg = extractLispMessage((LispEncapsulatedControl) msg);
            if (innerMsg instanceof LispMapRequest) {
                LispMapResolver mapResolver = new LispMapResolver();
                LispMessage lispMessage = mapResolver.processMapRequest((LispEncapsulatedControl) msg);
                ctx.writeAndFlush(lispMessage);
            }
        }
        if (msg instanceof LispMapRegister) {
            LispMapServer mapServer = new LispMapServer();
            LispMapNotify mapNotify = mapServer.processMapRegister((LispMapRegister) msg);
            ctx.writeAndFlush(mapNotify);
        }
    } finally {
        ReferenceCountUtil.release(msg);
    }
}
#end_block

#method_before
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    log.warn(cause.getMessage());
    ctx.close();
}
#method_after
@Override
public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
    log.warn(cause.getMessage());
// TODO: add error handle mechanisms for each cases
}
#end_block

#method_before
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    contentFilter = new StringFilter(filter, StringFilter.STRATEGY_AND);
    compilePredicate();
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service, coreService);
    if (outputJson()) {
        print("%s", json(flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#method_after
@Override
protected void execute() {
    CoreService coreService = get(CoreService.class);
    DeviceService deviceService = get(DeviceService.class);
    FlowRuleService service = get(FlowRuleService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    compilePredicate();
    SortedMap<Device, List<FlowEntry>> flows = getSortedFlows(deviceService, service, coreService);
    if (outputJson()) {
        print("%s", json(flows.keySet(), flows));
    } else {
        flows.forEach((device, flow) -> printFlows(device, flow, coreService));
    }
}
#end_block

#method_before
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    contentFilter = new StringFilter(filter, StringFilter.STRATEGY_AND);
    if (intentsSummary) {
        IntentSummaries intentSummaries = new IntentSummaries();
        intentSummaries.collectIntentSummary(service, service.getIntents());
        if (outputJson()) {
            print("%s", intentSummaries.json());
        } else {
            intentSummaries.printSummary();
        }
        return;
    } else if (pending) {
        if (outputJson()) {
            print("%s", json(service, service.getPending()));
        } else {
            StreamSupport.stream(service.getPending().spliterator(), false).filter(intent -> contentFilter.filter(intent)).forEach(intent -> print(fullFormat(intent)));
        }
        return;
    }
    if (outputJson()) {
        print("%s", json(service, service.getIntents()));
    } else {
        printIntents(service);
    }
}
#method_after
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    contentFilter = new StringFilter(filter, StringFilter.Strategy.AND);
    if (intentsSummary) {
        IntentSummaries intentSummaries = new IntentSummaries();
        intentSummaries.collectIntentSummary(service, service.getIntents());
        if (outputJson()) {
            print("%s", intentSummaries.json());
        } else {
            intentSummaries.printSummary();
        }
        return;
    } else if (pending) {
        if (outputJson()) {
            print("%s", json(service, service.getPending()));
        } else {
            StreamSupport.stream(service.getPending().spliterator(), false).filter(intent -> contentFilter.filter(intent)).forEach(intent -> print(fullFormat(intent)));
        }
        return;
    }
    if (outputJson()) {
        print("%s", json(service, service.getIntents()));
    } else {
        printIntents(service);
    }
}
#end_block

#method_before
public boolean filter(Object data) {
    switch(strategy) {
        case STRATEGY_OR:
            return filterOr(data);
        case STRATEGY_AND:
        default:
            return filterAnd(data);
    }
}
#method_after
public boolean filter(Object data) {
    if (strategy == Strategy.OR) {
        return filterOr(data);
    } else {
        return filterAnd(data);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return Long.toHexString(this.identifier);
}
#method_after
@Override
public String toString() {
    return Long.toHexString(identifier);
}
#end_block

#method_before
public static MeterId meterId(long id) {
    return new MeterId(id);
}
#method_after
public static MeterId meterId(long id) {
    checkArgument(id > 0, "id cannot be negative nor 0");
    checkArgument(id <= MAX, "id cannot be larger than {}", MAX);
    return new MeterId(id);
}
#end_block

#method_before
public static LispMessageReader getReader(ByteBuf buffer) {
    LispMessageReader reader;
    LispType type = LispType.valueOf((short) (buffer.getUnsignedByte(0) >> TYPE_SHIFT_BIT));
    switch(type) {
        case LISP_MAP_REQUEST:
            reader = new RequestReader();
            break;
        case LISP_MAP_REPLY:
            reader = new ReplyReader();
            break;
        case LISP_MAP_REGISTER:
            reader = new RegisterReader();
            break;
        case LISP_MAP_NOTIFY:
            reader = new NotifyReader();
            break;
        case LISP_INFO:
            if ((buffer.getByte(0) & INFO_REPLY_MASK) == INFO_REPLY_MASK) {
                reader = new InfoReplyReader();
            } else {
                reader = new InfoRequestReader();
            }
            break;
        case LISP_ENCAPSULATED_CONTROL:
            reader = new EcmReader();
            break;
        case UNKNOWN:
            throw new IllegalArgumentException("Unknown message type: " + type);
        default:
            throw new IllegalArgumentException("Undefined message type: " + type);
    }
    return reader;
}
#method_after
public static LispMessageReader getReader(ByteBuf buffer) {
    LispMessageReader reader;
    LispType type = LispType.valueOf((short) (buffer.getUnsignedByte(0) >> TYPE_SHIFT_BIT));
    switch(type) {
        case LISP_MAP_REQUEST:
            reader = new RequestReader();
            break;
        case LISP_MAP_REPLY:
            reader = new ReplyReader();
            break;
        case LISP_MAP_REGISTER:
            reader = new RegisterReader();
            break;
        case LISP_MAP_NOTIFY:
            reader = new NotifyReader();
            break;
        case LISP_INFO:
            boolean isInfoReply = ByteOperator.getBit((byte) buffer.getUnsignedByte(0), INFO_REPLY_INDEX);
            if (isInfoReply) {
                reader = new InfoReplyReader();
            } else {
                reader = new InfoRequestReader();
            }
            break;
        case LISP_ENCAPSULATED_CONTROL:
            reader = new EcmReader();
            break;
        case UNKNOWN:
            throw new IllegalArgumentException("Unknown message type: " + type);
        default:
            throw new IllegalArgumentException("Undefined message type: " + type);
    }
    return reader;
}
#end_block

#method_before
private static PacketContext context(Ethernet packet, ConnectPoint inPort) {
    InboundPacket inboundPacket = new DefaultInboundPacket(inPort, packet, null);
    OutboundPacket outboundPacket = new DefaultOutboundPacket(null, null, null);
    return new MockPacketContext(0, inboundPacket, outboundPacket, false);
}
#method_after
private static PacketContext context(Ethernet packet, ConnectPoint inPort) {
    InboundPacket inboundPacket = new DefaultInboundPacket(inPort, packet, null);
    OutboundPacket outboundPacket = new DefaultOutboundPacket(null, null, null);
    return new PacketContextAdapter(0, inboundPacket, outboundPacket, false);
}
#end_block

#method_before
default Port getPort(ConnectPoint port) {
    return getPort(port.deviceId(), port.port());
}
#method_after
default Port getPort(ConnectPoint cp) {
    return getPort(cp.deviceId(), cp.port());
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    disConnectInitialDevices();
    controller.removeListener(listener);
    providerRegistry.unregister(this);
    providerService = null;
    // stops listening all OpenFlow control message events
    controller.removeMessageListener(messageListener);
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    disconnectDevices();
    controller.removeListener(listener);
    providerRegistry.unregister(this);
    providerService = null;
    // stops listening all OpenFlow control message events
    controller.removeMessageListener(messageListener);
    log.info("Stopped");
}
#end_block

#method_before
@Activate
public void activate() {
    log.info("RESTCONF SBI Started");
    ymsService.registerDefaultCodec(new JsonYdtCodec(ymsService), YangProtocolEncodingFormat.JSON);
}
#method_after
@Activate
public void activate() {
    log.info("RESTCONF SBI Started");
    if (ymsService != null) {
        ymsService.registerDefaultCodec(new JsonYdtCodec(ymsService), YangProtocolEncodingFormat.JSON_ENCODING);
    }
}
#end_block

#method_before
@Override
public String encodeYdtToProtocolFormat(YdtBuilder builder) {
    String json = ParserUtils.convertYdtToJson(builder.getRootNode().getName(), builder.getRootNode(), ymsService.getYdtWalker()).textValue();
    return json;
}
#method_after
@Override
public String encodeYdtToProtocolFormat(YdtBuilder builder, YmsOperationType protocolOperation) {
    String json = ParserUtils.convertYdtToJson(builder.getRootNode().getName(), builder.getRootNode(), ymsService.getYdtWalker()).textValue();
    return json;
}
#end_block

#method_before
@Override
public YangCompositeEncoding encodeYdtToCompositeProtocolFormat(YdtBuilder builder) {
    return null;
}
#method_after
@Override
public YangCompositeEncoding encodeYdtToCompositeProtocolFormat(YdtBuilder builder, YmsOperationType protocolOperation) {
    return null;
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            DeviceDescription updatedDeviceDescription = null;
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
            if (updatedDeviceDescription == null) {
                updatedDeviceDescription = deviceDescription;
            }
            providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                    if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    } else if (updatedDeviceDescription == null) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
                    }
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {} " + "using DefaultDeviceDescription", deviceId);
                providerService.deviceConnected(deviceId, new DefaultDeviceDescription(deviceDescription, true, deviceDescription.annotations()));
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#end_block

#method_before
@Test
public void deactivate() throws Exception {
    provider.deactivate();
    assertEquals("Device listener should be removed", 0, deviceListeners.size());
    assertFalse("Provider should not be registered", deviceRegistry.getProviders().contains(provider));
    assertTrue("Thread to connect device should be shutdown", provider.executor.isShutdown());
    assertTrue("Scheduled task to update device should be shutdown", provider.scheduledTask.isCancelled());
    assertNull("Provider service should be null", provider.providerService);
    assertNull("Controller listener should be removed", controllerListener);
}
#method_after
@Test
public void deactivate() throws Exception {
    provider.deactivate();
    assertEquals("Device listener should be removed", 0, deviceListeners.size());
    assertFalse("Provider should not be registered", deviceRegistry.getProviders().contains(provider));
    assertTrue("Thread to connect device should be shutdown", provider.executor.isShutdown());
    assertTrue("Scheduled task to update device should be shutdown", provider.scheduledTask.isCancelled());
    assertNull("Provider service should be null", provider.providerService);
    assertEquals("Controller listener should be removed", 0, netconfDeviceListeners.size());
}
#end_block

#method_before
@Test
public void addDevice() {
    assertNotNull(providerService);
    assertTrue("Event should be relevant", provider.cfgListener.isRelevant(deviceAddedEvent));
    provider.cfgListener.event(deviceAddedEvent);
    assertAfter(500, () -> assertEquals("Device should be added", 1, deviceStore.getDeviceCount()));
    devices.clear();
}
#method_after
@Test
public void addDevice() {
    assertNotNull(providerService);
    assertTrue("Event should be relevant", provider.cfgListener.isRelevant(deviceAddedEvent));
    provider.cfgListener.event(deviceAddedEvent);
    assertAfter(DELAY_DISCOVERY, () -> assertEquals("Device should be added", 1, deviceStore.getDeviceCount()));
    devices.clear();
}
#end_block

#method_before
@Override
protected void processTopoShape(String shape) {
    super.processTopoShape(shape);
    int k = (topoShape.length == 1) ? 4 : Integer.parseInt(topoShape[1]);
    // A fat-tree is parametrized by the total number of ports per switch.
    // check top of page 4 of http://web.eecs.umich.edu/~mosharaf/Readings/Fat-Tree.pdf
    kPorts = k;
    numberOfPods = k;
    numberOfCoreLayerSwitches = (k / 2) * (k / 2);
    numberOfAggLayerSwitches = k * k / 2;
    numberOfEdgeLayerSwitches = k * k / 2;
    // need to also change hostCount variable of TopologySimulator
    hostCount = kPorts / 2;
}
#method_after
@Override
protected void processTopoShape(String shape) {
    super.processTopoShape(shape);
    // If switch ports are not provided use a default value
    int k = (topoShape.length == 1) ? DEFAULT_NUMBER_OF_PORTS_PER_SWITCH : Integer.parseInt(topoShape[1]);
    // A fat-tree is parametrized by the total number of ports per switch.
    // check top of page 4 of http://web.eecs.umich.edu/~mosharaf/Readings/Fat-Tree.pdf
    kPorts = k;
    numberOfPods = k;
    numberOfCoreLayerSwitches = (k / 2) * (k / 2);
    numberOfAggLayerSwitches = k * k / 2;
    numberOfEdgeLayerSwitches = k * k / 2;
    // need to also change hostCount variable of TopologySimulator
    hostCount = kPorts / 2;
}
#end_block

#method_before
@Override
public void setUpTopology() {
    checkArgument(kPorts > 1, "Fat Tree switches must have at **least** 2 ports each!");
    // this is the total number of **Switches**
    // in a fat-tree topology
    deviceCount = numberOfAggLayerSwitches + numberOfCoreLayerSwitches + numberOfEdgeLayerSwitches;
    log.info(String.format("Booting a %s with %s-k ports " + ",%s switches in total" + ", %s pods.", topoShape[0], kPorts, deviceCount, numberOfPods));
    prepareForDeviceEvents(deviceCount);
    createDevices();
    waitForDeviceEvents();
    createLinks();
    createHosts();
}
#method_after
@Override
public void setUpTopology() {
    checkArgument(kPorts > 1, "Fat Tree switches must " + "have at **least** 2 ports each!");
    // this is the total number of **Switches**
    // in a fat-tree topology
    deviceCount = numberOfAggLayerSwitches + numberOfCoreLayerSwitches + numberOfEdgeLayerSwitches;
    log.info("Booting a {} with {}-ports, {} switches in total {} pods", topoShape[0], kPorts, deviceCount, numberOfPods);
    prepareForDeviceEvents(deviceCount);
    createDevices();
    waitForDeviceEvents();
    createLinks();
    createHosts();
}
#end_block

#method_before
@Override
protected void createLinks() {
    // For each switch keep a count of used ports
    int[] portList = new int[deviceCount];
    for (int i = 0; i < deviceCount; i++) {
        portList[i] = 1;
    }
    // we assume that deviceIds stores all the fat tree switches in a flat list
    int end = numberOfPods / 2;
    // from [ 0, (k/2)^2 - 1] we store (k/2)^2 core switces
    int startOfCore = 0;
    // from [ (k/2)^2, (k/2)^2 + (k^2)/2 - 1] we store (k^2)/2 aggregation switches
    int startOfAgg = (numberOfPods / 2) * (numberOfPods / 2);
    // from [ (k/2)^2 + (k^2)/2, (k/2)^2 + (k^2)/2 + (k^2)/2 -] we store (k^2)/2 edge switches
    int startOfEdge = startOfAgg + (numberOfPods * numberOfPods) / 2;
    log.info(String.format("startCore = %s, " + "startofAgg = %s, startOfEdge = %s", startOfCore, startOfAgg, startOfEdge));
    // Create links between core and aggregation switches
    for (int x = 0; x < numberOfAggLayerSwitches; x += end) {
        // each agg.switch will handle a group of k/2 core consecutive switches
        for (int i = 0; i < end; i += 1) {
            for (int j = 0; j < end; j += 1) {
                int coreSwitch = i * end + j;
                int aggSwitch = startOfAgg + x + i;
                createLink(coreSwitch, aggSwitch, portList[coreSwitch]++, portList[aggSwitch]++);
            }
        }
    }
    // Create links between aggregation and edge switches
    for (int x = 0; x < numberOfAggLayerSwitches; x += end) {
        for (int i = 0; i < end; i += 1) {
            for (int j = 0; j < end; j += 1) {
                int aggSwitch = startOfAgg + x + i;
                int edgeSwitch = startOfEdge + x + j;
                createLink(aggSwitch, edgeSwitch, portList[aggSwitch]++, portList[edgeSwitch]++);
            }
        }
    }
}
#method_after
@Override
protected void createLinks() {
    // For each switch keep a count of used ports
    int[] portList = new int[deviceCount];
    Arrays.fill(portList, 0);
    // we assume that deviceIds stores all the fat tree switches in a flat list
    int end = numberOfPods / 2;
    // from [ 0, (k/2)^2 - 1] we store (k/2)^2 core switces
    int startOfCore = 0;
    // from [ (k/2)^2, (k/2)^2 + (k^2)/2 - 1] we store (k^2)/2 aggregation switches
    int startOfAgg = (numberOfPods / 2) * (numberOfPods / 2);
    // from [ (k/2)^2 + (k^2)/2, (k/2)^2 + (k^2)/2 + (k^2)/2 -1] we store (k^2)/2 edge switches
    int startOfEdge = startOfAgg + (numberOfPods * numberOfPods) / 2;
    log.debug("startOfCore = {}, startOfAgg = {}, startOfEdge = {}", startOfCore, startOfAgg, startOfEdge);
    // Create links between core and aggregation switches
    for (int x = 0; x < numberOfAggLayerSwitches; x += end) {
        // each agg.switch will handle a group of k/2 core consecutive switches
        for (int i = 0; i < end; i += 1) {
            for (int j = 0; j < end; j += 1) {
                int coreSwitch = i * end + j;
                int aggSwitch = startOfAgg + x + i;
                createLink(coreSwitch, aggSwitch, portList[coreSwitch]++, portList[aggSwitch]++);
            }
        }
    }
    // Create links between aggregation and edge switches
    for (int x = 0; x < numberOfAggLayerSwitches; x += end) {
        for (int i = 0; i < end; i += 1) {
            for (int j = 0; j < end; j += 1) {
                int aggSwitch = startOfAgg + x + i;
                int edgeSwitch = startOfEdge + x + j;
                createLink(aggSwitch, edgeSwitch, portList[aggSwitch]++, portList[edgeSwitch]++);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void createHosts() {
    int firstEdgeSwitch = (numberOfPods / 2) * (numberOfPods / 2) + (numberOfPods * numberOfPods) / 2;
    // hosts connect **only** to edge switches, each edge switch has k/2 ports free for hosts
    for (int edgeSwitch = firstEdgeSwitch; edgeSwitch < deviceCount; edgeSwitch++) {
        createHosts(deviceIds.get(edgeSwitch), kPorts / 2 + 1);
    }
}
#method_after
@Override
protected void createHosts() {
    int firstEdgeSwitch = (numberOfPods / 2) * (numberOfPods / 2) + (numberOfPods * numberOfPods) / 2;
    // hosts connect **only** to edge switches, each edge switch has k/2 ports free for hosts
    for (int edgeSwitch = firstEdgeSwitch; edgeSwitch < deviceCount; edgeSwitch++) {
        createHosts(deviceIds.get(edgeSwitch), kPorts / 2);
    }
}
#end_block

#method_before
@Override
public Result<V, E> search(Graph<V, E> graph, V src, V dst, EdgeWeight<V, E> weight, int maxPaths) {
    checkNotNull(src);
    checkNotNull(dst);
    // The modified edge weight removes any need to modify the original graph
    InnerEdgeWeighter modifiedWeighter = new InnerEdgeWeighter(checkNotNull(weight));
    checkArgument(maxPaths != ALL_PATHS, "KShortestPath search cannot" + "be used with ALL_PATHS.");
    checkArgument(maxPaths > 0, "The max number of paths must be greater" + " than 0");
    Graph<V, E> originalGraph = checkNotNull(graph);
    // the result contains the set of eventual results
    InnerOrderedResult result = new InnerOrderedResult(src, dst, maxPaths);
    ArrayList<Path<V, E>> resultPaths = new ArrayList<>(maxPaths);
    ArrayList<Path<V, E>> potentialPaths = Lists.newArrayList();
    DijkstraGraphSearch<V, E> dijkstraSearch = new DijkstraGraphSearch<>();
    Set<Path<V, E>> dijkstraResults = dijkstraSearch.search(originalGraph, src, dst, modifiedWeighter, 1).paths();
    // Checks if the dst was reachable
    if (dijkstraResults.size() == 0) {
        log.warn("No path was found.");
        return result;
    }
    // If it was reachable adds the first shortest path to the set of results
    resultPaths.add(dijkstraResults.iterator().next());
    for (int k = 1; k < maxPaths; k++) {
        for (int i = 0; i < (resultPaths.get(k - 1).edges().size() - 1); i++) {
            V spurNode = resultPaths.get(k - 1).edges().get(i).src();
            List<E> rootPathEdgeList = resultPaths.get(k - 1).edges().subList(0, i);
            for (Path<V, E> path : resultPaths) {
                if (edgeListsAreEqual(rootPathEdgeList, path.edges().subList(0, i))) {
                    modifiedWeighter.removedEdges.add(path.edges().get(i));
                }
            }
            // Effectively remove all nodes from the source path
            for (E edge : rootPathEdgeList) {
                originalGraph.getEdgesFrom(edge.src()).forEach(e -> modifiedWeighter.removedEdges.add(e));
                originalGraph.getEdgesTo(edge.src()).forEach(e -> modifiedWeighter.removedEdges.add(e));
            }
            dijkstraResults = dijkstraSearch.search(originalGraph, spurNode, dst, modifiedWeighter, 1).paths();
            if (dijkstraResults.size() != 0) {
                Path<V, E> spurPath = dijkstraResults.iterator().next();
                List<E> totalPath = new ArrayList<>(rootPathEdgeList);
                spurPath.edges().forEach(e -> totalPath.add(e));
                // The following line must use the original weighter not the modified weighter because the modified
                // weighter will count -1 values used for modifying the graph and return an inaccurate cost.
                potentialPaths.add(new DefaultPath<V, E>(totalPath, calculatePathCost(weight, totalPath)));
            }
            // Restore all removed paths and nodes
            modifiedWeighter.removedEdges.clear();
        }
        if (potentialPaths.isEmpty()) {
            break;
        }
        potentialPaths.sort(new InnerPathComparator());
        resultPaths.add(potentialPaths.get(0));
        potentialPaths.remove(0);
    }
    result.pathSet.addAll(resultPaths);
    return result;
}
#method_after
@Override
public Result<V, E> search(Graph<V, E> graph, V src, V dst, EdgeWeight<V, E> weight, int maxPaths) {
    checkNotNull(src);
    checkNotNull(dst);
    // The modified edge weight removes any need to modify the original graph
    InnerEdgeWeighter modifiedWeighter = new InnerEdgeWeighter(checkNotNull(weight));
    checkArgument(maxPaths != ALL_PATHS, "KShortestPath search cannot" + "be used with ALL_PATHS.");
    checkArgument(maxPaths > 0, "The max number of paths must be greater" + " than 0");
    Graph<V, E> originalGraph = checkNotNull(graph);
    // the result contains the set of eventual results
    InnerOrderedResult result = new InnerOrderedResult(src, dst, maxPaths);
    ArrayList<Path<V, E>> resultPaths = new ArrayList<>(maxPaths);
    ArrayList<Path<V, E>> potentialPaths = Lists.newArrayList();
    DijkstraGraphSearch<V, E> dijkstraSearch = new DijkstraGraphSearch<>();
    Set<Path<V, E>> dijkstraResults = dijkstraSearch.search(originalGraph, src, dst, modifiedWeighter, 1).paths();
    // Checks if the dst was reachable
    if (dijkstraResults.size() == 0) {
        log.warn("No path was found.");
        return result;
    }
    // If it was reachable adds the first shortest path to the set of results
    resultPaths.add(dijkstraResults.iterator().next());
    for (int k = 1; k < maxPaths; k++) {
        for (int i = 0; i < (resultPaths.get(k - 1).edges().size() - 1); i++) {
            V spurNode = resultPaths.get(k - 1).edges().get(i).src();
            List<E> rootPathEdgeList = resultPaths.get(k - 1).edges().subList(0, i);
            for (Path<V, E> path : resultPaths) {
                if (path.edges().size() >= i && edgeListsAreEqual(rootPathEdgeList, path.edges().subList(0, i))) {
                    modifiedWeighter.removedEdges.add(path.edges().get(i));
                }
            }
            // Effectively remove all nodes from the source path
            for (E edge : rootPathEdgeList) {
                originalGraph.getEdgesFrom(edge.src()).forEach(e -> modifiedWeighter.removedEdges.add(e));
                originalGraph.getEdgesTo(edge.src()).forEach(e -> modifiedWeighter.removedEdges.add(e));
            }
            dijkstraResults = dijkstraSearch.search(originalGraph, spurNode, dst, modifiedWeighter, 1).paths();
            if (dijkstraResults.size() != 0) {
                Path<V, E> spurPath = dijkstraResults.iterator().next();
                List<E> totalPath = new ArrayList<>(rootPathEdgeList);
                spurPath.edges().forEach(e -> totalPath.add(e));
                // The following line must use the original weighter not the modified weighter because the modified
                // weighter will count -1 values used for modifying the graph and return an inaccurate cost.
                potentialPaths.add(new DefaultPath<V, E>(totalPath, calculatePathCost(weight, totalPath)));
            }
            // Restore all removed paths and nodes
            modifiedWeighter.removedEdges.clear();
        }
        if (potentialPaths.isEmpty()) {
            break;
        }
        potentialPaths.sort(new InnerPathComparator());
        resultPaths.add(potentialPaths.get(0));
        potentialPaths.remove(0);
    }
    result.pathSet.addAll(resultPaths);
    return result;
}
#end_block

#method_before
public LispMapNotify processMapRegister(LispMessage message) {
    LispMapRegister register = (LispMapRegister) message;
    if (!checkAuthData(register)) {
        log.warn("Unmatched authentication data of Map-Register");
        return null;
    }
    // build temp notify message
    NotifyBuilder authNotifyBuilder = new DefaultNotifyBuilder();
    authNotifyBuilder.withKeyId(AUTH_METHOD);
    authNotifyBuilder.withAuthDataLength(AUTH_DATA_LENGTH);
    authNotifyBuilder.withNonce(register.getNonce());
    authNotifyBuilder.withMapRecords(register.getMapRecords());
    byte[] authData = new byte[AUTH_DATA_LENGTH];
    Arrays.fill(authData, (byte) 0);
    authNotifyBuilder.withAuthenticationData(authData);
    ByteBuf byteBuf = Unpooled.buffer();
    try {
        authNotifyBuilder.build().writeTo(byteBuf);
    } catch (LispWriterException e) {
        e.printStackTrace();
    }
    byte[] bytes = new byte[byteBuf.readableBytes()];
    byteBuf.readBytes(bytes);
    byte[] sha1AuthData = factory.createAuthenticationData(SHA1, AUTH_KEY, bytes);
    NotifyBuilder notifyBuilder = new DefaultNotifyBuilder();
    notifyBuilder.withKeyId(AUTH_METHOD);
    notifyBuilder.withAuthDataLength((short) sha1AuthData.length);
    notifyBuilder.withAuthenticationData(sha1AuthData);
    notifyBuilder.withNonce(register.getNonce());
    notifyBuilder.withMapRecords(register.getMapRecords());
    LispMapNotify notify = notifyBuilder.build();
    InetSocketAddress address = new InetSocketAddress(register.getSender().getAddress(), NOTIFY_PORT);
    notify.configSender(address);
    register.getMapRecords().forEach(record -> {
        LispEidRecord eidRecord = new LispEidRecord(record.getMaskLength(), record.getEidPrefixAfi());
        mapInfo.insertMapRecord(eidRecord, record);
    });
    return notify;
}
#method_after
public LispMapNotify processMapRegister(LispMessage message) {
    LispMapRegister register = (LispMapRegister) message;
    if (!checkAuthData(register)) {
        log.warn("Unmatched authentication data of Map-Register");
        return null;
    }
    // build temp notify message
    NotifyBuilder authNotifyBuilder = new DefaultNotifyBuilder();
    authNotifyBuilder.withKeyId(AUTH_METHOD);
    authNotifyBuilder.withAuthDataLength(AUTH_DATA_LENGTH);
    authNotifyBuilder.withNonce(register.getNonce());
    authNotifyBuilder.withMapRecords(register.getMapRecords());
    byte[] authData = new byte[AUTH_DATA_LENGTH];
    Arrays.fill(authData, (byte) 0);
    authNotifyBuilder.withAuthenticationData(authData);
    ByteBuf byteBuf = Unpooled.buffer();
    try {
        authNotifyBuilder.build().writeTo(byteBuf);
    } catch (LispWriterException e) {
        e.printStackTrace();
    }
    byte[] bytes = new byte[byteBuf.readableBytes()];
    byteBuf.readBytes(bytes);
    byte[] sha1AuthData = factory.createAuthenticationData(valueOf(register.getKeyId()), AUTH_KEY, bytes);
    NotifyBuilder notifyBuilder = new DefaultNotifyBuilder();
    notifyBuilder.withKeyId(AUTH_METHOD);
    notifyBuilder.withAuthDataLength((short) sha1AuthData.length);
    notifyBuilder.withAuthenticationData(sha1AuthData);
    notifyBuilder.withNonce(register.getNonce());
    notifyBuilder.withMapRecords(register.getMapRecords());
    LispMapNotify notify = notifyBuilder.build();
    InetSocketAddress address = new InetSocketAddress(register.getSender().getAddress(), NOTIFY_PORT);
    notify.configSender(address);
    register.getMapRecords().forEach(record -> {
        LispEidRecord eidRecord = new LispEidRecord(record.getMaskLength(), record.getEidPrefixAfi());
        mapInfo.insertMapRecord(eidRecord, record);
    });
    return notify;
}
#end_block

#method_before
private boolean checkAuthData(LispMapRegister register) {
    ByteBuf byteBuf = Unpooled.buffer();
    RegisterBuilder registerBuilder = new DefaultRegisterBuilder();
    registerBuilder.withKeyId(register.getKeyId());
    registerBuilder.withAuthDataLength(register.getAuthDataLength());
    registerBuilder.withNonce(register.getNonce());
    registerBuilder.withIsProxyMapReply(register.isProxyMapReply());
    registerBuilder.withIsWantMapNotify(register.isWantMapNotify());
    registerBuilder.withMapRecords(register.getMapRecords());
    byte[] authData = register.getAuthenticationData();
    if (authData != null) {
        authData = authData.clone();
        Arrays.fill(authData, (byte) 0);
    }
    registerBuilder.withAuthenticationData(authData);
    try {
        registerBuilder.build().writeTo(byteBuf);
    } catch (LispWriterException e) {
        e.printStackTrace();
    }
    byte[] bytes = new byte[byteBuf.readableBytes()];
    byteBuf.readBytes(bytes);
    byte[] sha1AuthData = factory.createAuthenticationData(SHA1, AUTH_KEY, bytes);
    return Arrays.equals(sha1AuthData, register.getAuthenticationData());
}
#method_after
private boolean checkAuthData(LispMapRegister register) {
    ByteBuf byteBuf = Unpooled.buffer();
    RegisterBuilder registerBuilder = new DefaultRegisterBuilder();
    registerBuilder.withKeyId(register.getKeyId());
    registerBuilder.withAuthDataLength(register.getAuthDataLength());
    registerBuilder.withNonce(register.getNonce());
    registerBuilder.withIsProxyMapReply(register.isProxyMapReply());
    registerBuilder.withIsWantMapNotify(register.isWantMapNotify());
    registerBuilder.withMapRecords(register.getMapRecords());
    byte[] authData = register.getAuthenticationData();
    if (authData != null) {
        authData = authData.clone();
        Arrays.fill(authData, (byte) 0);
    }
    registerBuilder.withAuthenticationData(authData);
    try {
        registerBuilder.build().writeTo(byteBuf);
    } catch (LispWriterException e) {
        e.printStackTrace();
    }
    byte[] bytes = new byte[byteBuf.readableBytes()];
    byteBuf.readBytes(bytes);
    byte[] calculatedAuthData = factory.createAuthenticationData(valueOf(register.getKeyId()), AUTH_KEY, bytes);
    return Arrays.equals(calculatedAuthData, register.getAuthenticationData());
}
#end_block

#method_before
@Test
public void testVariableLenPathsWithConstantLinkWeight() {
    // Test graph:
    // +-+-+  +---+ +---+  +-+-+
    // +--+ B +--+ C +-+ D +--+ E |
    // |  +-+-+  +---+ +---+  +-+-+
    // |    |                   |
    // +-+-+  |    +---+ +---+  +-+-+
    // | A |  +----+ F +-+ G +--+ H |
    // +---+       +---+ +---+  +---+
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G, H), of(new TestEdge(A, B, 1), new TestEdge(B, A, 1), new TestEdge(B, C, 1), new TestEdge(C, B, 1), new TestEdge(C, D, 1), new TestEdge(D, C, 1), new TestEdge(D, E, 1), new TestEdge(E, D, 1), new TestEdge(E, H, 1), new TestEdge(H, E, 1), new TestEdge(H, G, 1), new TestEdge(G, H, 1), new TestEdge(G, F, 1), new TestEdge(F, G, 1), new TestEdge(F, B, 1), new TestEdge(B, F, 1)));
    weight = edge -> 1.0;
    // Tests that there are only two paths between A and E and that they are returned in the correct order
    result = kShortestPathsSearch.search(graph, A, G, weight, 5);
    assertEquals("There are an unexpected number of paths.", 2, result.paths().size());
    Iterator<Path<TestVertex, TestEdge>> edgeListIterator = result.paths().iterator();
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, 1));
    correctEdgeList.add(new TestEdge(B, F, 1));
    correctEdgeList.add(new TestEdge(F, G, 1));
    assertTrue("The first path from A to G was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
    correctEdgeList.clear();
    correctEdgeList.add(new TestEdge(A, B, 1));
    correctEdgeList.add(new TestEdge(B, C, 1));
    correctEdgeList.add(new TestEdge(C, D, 1));
    correctEdgeList.add(new TestEdge(D, E, 1));
    correctEdgeList.add(new TestEdge(E, H, 1));
    correctEdgeList.add(new TestEdge(H, G, 1));
    assertTrue("The second path from A to G was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
}
#method_after
@Test
public void testVariableLenPathsWithConstantLinkWeight() {
    /*
         * Test graph:
         *
         *      +-+-+  +---+ +---+  +-+-+
         *   +--+ B +--+ C +-+ D +--+ E |
         *   |  +-+-+  +---+ +---+  +-+-+
         *   |    |                   |
         * +-+-+  |    +---+ +---+  +-+-+
         * | A |  +----+ F +-+ G +--+ H |
         * +---+       +---+ +---+  +---+
         */
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G, H), of(new TestEdge(A, B, 1), new TestEdge(B, A, 1), new TestEdge(B, C, 1), new TestEdge(C, B, 1), new TestEdge(C, D, 1), new TestEdge(D, C, 1), new TestEdge(D, E, 1), new TestEdge(E, D, 1), new TestEdge(E, H, 1), new TestEdge(H, E, 1), new TestEdge(H, G, 1), new TestEdge(G, H, 1), new TestEdge(G, F, 1), new TestEdge(F, G, 1), new TestEdge(F, B, 1), new TestEdge(B, F, 1)));
    weight = edge -> 1.0;
    // Tests that there are only two paths between A and G and that they are returned in the correct order
    result = kShortestPathsSearch.search(graph, A, G, weight, 5);
    assertEquals("There are an unexpected number of paths.", 2, result.paths().size());
    Iterator<Path<TestVertex, TestEdge>> edgeListIterator = result.paths().iterator();
    List<TestEdge> correctEdgeList = Lists.newArrayList();
    correctEdgeList.add(new TestEdge(A, B, 1));
    correctEdgeList.add(new TestEdge(B, F, 1));
    correctEdgeList.add(new TestEdge(F, G, 1));
    assertTrue("The first path from A to G was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
    correctEdgeList.clear();
    correctEdgeList.add(new TestEdge(A, B, 1));
    correctEdgeList.add(new TestEdge(B, C, 1));
    correctEdgeList.add(new TestEdge(C, D, 1));
    correctEdgeList.add(new TestEdge(D, E, 1));
    correctEdgeList.add(new TestEdge(E, H, 1));
    correctEdgeList.add(new TestEdge(H, G, 1));
    assertTrue("The second path from A to G was incorrect.", edgeListsAreEqual(edgeListIterator.next().edges(), correctEdgeList));
}
#end_block

#method_before
@Before
public void setup() throws Exception {
    builder = new YdtBuilderAdapter(RESTCONF_ROOT, null, QUERY_REQUEST);
    listener = new JsonToYdtListener(builder);
    jsonWalker = new DefaultJsonWalker();
}
#method_after
@Before
public void setup() throws Exception {
    builder = new TestYdtBuilder(RESTCONF_ROOT, null, QUERY_REQUEST);
    listener = new JsonToYdtListener(builder);
    jsonWalker = new DefaultJsonWalker();
}
#end_block

#method_before
@Test
public void testArrayNodeTransfer() throws Exception {
    ObjectNode arrayNode = loadJsonFile("/arrayNode.json");
    jsonWalker.walk(listener, null, arrayNode);
    YdtContext rootNode = builder.getRootNode();
    YdtContext firstChild = rootNode.getFirstChild();
    YdtContext nextSibling = firstChild.getNextSibling();
    assertTrue(WRONG_TYPE, firstChild.getYdtType() == SINGLE_INSTANCE_LEAF_VALUE_NODE);
    assertTrue(WRONG_STRUCTURE, firstChild.getName().equals("surname"));
    assertTrue(WRONG_TYPE, nextSibling.getYdtType() == MULTI_INSTANCE_NODE);
    assertTrue(WRONG_STRUCTURE, nextSibling.getName().equals("networklist"));
    assertTrue(WRONG_STRUCTURE, nextSibling.getNextSibling().getName().equals("networklist"));
    assertTrue(WRONG_STRUCTURE, rootNode.getLastChild().getName().equals("networklist"));
}
#method_after
@Test
public void testArrayNodeTransfer() throws Exception {
    ObjectNode arrayNode = loadJsonFile("/arrayNode.json");
    jsonWalker.walk(listener, null, arrayNode);
    YdtContext rootNode = builder.getRootNode();
    YdtContext firstChild = rootNode.getFirstChild();
    YdtContext nextSibling = firstChild.getNextSibling();
    assertEquals(WRONG_TYPE, SINGLE_INSTANCE_LEAF_VALUE_NODE, firstChild.getYdtType());
    assertEquals(WRONG_STRUCTURE, "surname", firstChild.getName());
    assertEquals(WRONG_TYPE, MULTI_INSTANCE_NODE, nextSibling.getYdtType());
    assertEquals(WRONG_STRUCTURE, "networklist", nextSibling.getName());
    assertEquals(WRONG_STRUCTURE, "networklist", nextSibling.getNextSibling().getName());
    assertEquals(WRONG_STRUCTURE, "networklist", rootNode.getLastChild().getName());
}
#end_block

#method_before
@Test
public void testListInListNodeTransfer() throws Exception {
    ObjectNode arrayNode = loadJsonFile("/listInList.json");
    jsonWalker.walk(listener, null, arrayNode);
    YdtContext rootNode = builder.getRootNode();
    YdtContext firstChild = rootNode.getFirstChild();
    YdtContext levelOneArray = firstChild.getFirstChild();
    assertTrue(WRONG_STRUCTURE, firstChild.getName().equals("container-identifier1"));
    assertTrue(WRONG_STRUCTURE, levelOneArray.getName().equals("list-identifier2"));
    assertTrue(WRONG_STRUCTURE, levelOneArray.getNextSibling().getName().equals("list-identifier2"));
    YdtContext identifier3Node = levelOneArray.getLastChild();
    assertTrue(WRONG_STRUCTURE, identifier3Node.getName().equals("container-identifier3"));
    YdtContext identifier4Node = identifier3Node.getLastChild();
    assertTrue(WRONG_STRUCTURE, identifier4Node.getName().equals("list-identifier4"));
    YdtContext identifier5ListNode = identifier4Node.getLastChild();
    assertTrue(WRONG_STRUCTURE, identifier5ListNode.getName().equals("leaf-list-identifier5"));
    assertTrue(WRONG_TYPE, identifier5ListNode.getYdtType() == MULTI_INSTANCE_LEAF_VALUE_NODE);
}
#method_after
@Test
public void testListInListNodeTransfer() throws Exception {
    ObjectNode arrayNode = loadJsonFile("/listInList.json");
    jsonWalker.walk(listener, null, arrayNode);
    YdtContext rootNode = builder.getRootNode();
    YdtContext firstChild = rootNode.getFirstChild();
    YdtContext levelOneArray = firstChild.getFirstChild();
    assertEquals(WRONG_STRUCTURE, "container-identifier1", firstChild.getName());
    assertEquals(WRONG_STRUCTURE, "list-identifier2", levelOneArray.getName());
    assertEquals(WRONG_STRUCTURE, "list-identifier2", levelOneArray.getNextSibling().getName());
    YdtContext identifier3Node = levelOneArray.getLastChild();
    assertEquals(WRONG_STRUCTURE, "container-identifier3", identifier3Node.getName());
    YdtContext identifier4Node = identifier3Node.getLastChild();
    assertEquals(WRONG_STRUCTURE, "list-identifier4", identifier4Node.getName());
    YdtContext identifier5ListNode = identifier4Node.getLastChild();
    assertEquals(WRONG_STRUCTURE, "leaf-list-identifier5", identifier5ListNode.getName());
    assertEquals(WRONG_TYPE, MULTI_INSTANCE_LEAF_VALUE_NODE, identifier5ListNode.getYdtType());
}
#end_block

#method_before
@Override
public void enterYdtNode(YdtContext ydtContext) {
    String name = ParserUtils.getJsonNameFromYdtNode(ydtContext);
    if (!isBegin && name != null && name.equals(rootName)) {
        isBegin = true;
    }
    if (!isBegin) {
        return;
    }
    switch(ydtContext.getYdtType()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeTopHalf(name, JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            YdtContext preNode = ydtContext.getPreviousSibling();
            if (preNode == null || !ParserUtils.getJsonNameFromYdtNode(preNode).equals(name)) {
                jsonBuilder.addNodeTopHalf(name, JsonNodeType.ARRAY);
            }
            jsonBuilder.addNodeTopHalf(EMPTY, JsonNodeType.OBJECT);
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithValueTopHalf(name, ydtContext.getValue());
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithSetTopHalf(name, ydtContext.getValueSet());
            break;
        default:
            throw new YdtParseException("unknown Ydt type " + ydtContext.getYdtType());
    }
}
#method_after
@Override
public void enterYdtNode(YdtContext ydtContext) {
    String name = getJsonNameFromYdtNode(ydtContext);
    if (!isBegin && name != null && name.equals(rootName)) {
        isBegin = true;
    }
    if (!isBegin) {
        return;
    }
    switch(ydtContext.getYdtType()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeTopHalf(name, JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            YdtContext preNode = ydtContext.getPreviousSibling();
            if (preNode == null || !getJsonNameFromYdtNode(preNode).equals(name)) {
                jsonBuilder.addNodeTopHalf(name, JsonNodeType.ARRAY);
            }
            jsonBuilder.addNodeTopHalf(EMPTY, JsonNodeType.OBJECT);
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithValueTopHalf(name, ydtContext.getValue());
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeWithSetTopHalf(name, ydtContext.getValueSet());
            break;
        default:
            throw new YdtParseException("unknown Ydt type " + ydtContext.getYdtType());
    }
}
#end_block

#method_before
@Override
public void exitYdtNode(YdtContext ydtContext) {
    if (!isBegin) {
        return;
    }
    String curName = ParserUtils.getJsonNameFromYdtNode(ydtContext);
    YdtContext nextNode = ydtContext.getNextSibling();
    switch(ydtContext.getYdtType()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            if (nextNode == null || !ParserUtils.getJsonNameFromYdtNode(nextNode).equals(curName)) {
                jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
                jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            } else {
                jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            }
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.STRING);
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            break;
        default:
            throw new YdtParseException("Unknown Ydt type " + ydtContext.getYdtType());
    }
    if (curName.equals(rootName) && (nextNode == null || !ParserUtils.getJsonNameFromYdtNode(nextNode).equals(rootName))) {
        isBegin = false;
    }
}
#method_after
@Override
public void exitYdtNode(YdtContext ydtContext) {
    if (!isBegin) {
        return;
    }
    String curName = getJsonNameFromYdtNode(ydtContext);
    YdtContext nextNode = ydtContext.getNextSibling();
    switch(ydtContext.getYdtType()) {
        case SINGLE_INSTANCE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            break;
        case MULTI_INSTANCE_NODE:
            if (nextNode == null || !getJsonNameFromYdtNode(nextNode).equals(curName)) {
                jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
                jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            } else {
                jsonBuilder.addNodeBottomHalf(JsonNodeType.OBJECT);
            }
            break;
        case SINGLE_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.STRING);
            break;
        case MULTI_INSTANCE_LEAF_VALUE_NODE:
            jsonBuilder.addNodeBottomHalf(JsonNodeType.ARRAY);
            break;
        default:
            throw new YdtParseException("Unknown Ydt type " + ydtContext.getYdtType());
    }
    if (curName.equals(rootName) && (nextNode == null || !getJsonNameFromYdtNode(nextNode).equals(rootName))) {
        isBegin = false;
    }
}
#end_block

#method_before
public static String getJsonNameFromYdtNode(YdtContext ydtContext) {
    if (ydtContext == null) {
        return null;
    }
    String nodeName = ydtContext.getName();
    if (nodeName == null) {
        return null;
    }
    /*
         * The namespace field in YDT node is a string which contains a list
         * of identifiers separated by colon (:). e.g.,
         *
         * {identifier ":" identifier}+
         *
         * The last identifier in the string is the YANG module name.
         */
    String moduleName = getModuleNameFromNamespace(ydtContext.getNamespace());
    if (moduleName == null) {
        return nodeName;
    } else {
        return moduleName + ":" + nodeName;
    }
}
#method_after
public static String getJsonNameFromYdtNode(YdtContext ydtContext) {
    if (ydtContext == null) {
        return null;
    }
    String nodeName = ydtContext.getName();
    if (nodeName == null) {
        return null;
    }
    /*
         * The namespace field in YDT node is a string which contains a list
         * of identifiers separated by colon (:). e.g.,
         *
         * {identifier ":" identifier}+
         *
         * The last identifier in the string is the YANG module name.
         */
    String moduleName = getModuleNameFromNamespace(ydtContext.getNamespace());
    if (moduleName == null) {
        return nodeName;
    } else {
        return moduleName + COLON + nodeName;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    workerThreadPool = Executors.newFixedThreadPool(maxNumOfWorkerThreads, new ThreadFactoryBuilder().setNameFormat("restconf-worker").build());
    ymsNotificationService = ymsService.getYangNotificationService();
    // ymsNotificationService.addListener(new InternalYangNotificationListener());
    listeners = new ListenerTracker();
    listeners.addListener(ymsNotificationService, new InternalYangNotificationListener());
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    workerThreadPool = Executors.newFixedThreadPool(maxNumOfWorkerThreads, new ThreadFactoryBuilder().setNameFormat("restconf-worker").build());
    ymsNotificationService = ymsService.getYangNotificationService();
    listeners = new ListenerTracker();
    listeners.addListener(ymsNotificationService, new InternalYangNotificationListener());
    log.info("Started");
}
#end_block

#method_before
@Override
public ObjectNode runGetOperationOnDataResource(String uri) throws RestconfException {
    YdtBuilder ydtBuilder = getYdtBuilder(QUERY_REQUEST);
    // Convert the URI to ydtBuilder
    convertUriToYdt(uri, ydtBuilder, NONE);
    YdtResponse ydtResponse = ymsService.executeOperation(ydtBuilder);
    YmsOperationExecutionStatus status = ydtResponse.getYmsOperationResult();
    if (status != EXECUTION_SUCCESS) {
        throw new RestconfException("YMS GET operation failed", INTERNAL_SERVER_ERROR);
    }
    YdtContext rootNode = ydtResponse.getRootNode();
    YdtContext curNode = ydtBuilder.getCurNode();
    ObjectNode result = convertYdtToJson(ParserUtils.getJsonNameFromYdtNode(curNode), rootNode, ymsService.getYdtWalker());
    // if the query URI contain a key, something like list=key
    // here should only get get child with the specific key
    YdtContext child = curNode.getFirstChild();
    if (child != null && child.getYdtType() == SINGLE_INSTANCE_LEAF_VALUE_NODE) {
        ArrayNode jsonNode = (ArrayNode) result.get(ParserUtils.getJsonNameFromYdtNode(curNode));
        for (JsonNode next : jsonNode) {
            if (next.findValue(ParserUtils.getJsonNameFromYdtNode(child)).asText().equals(child.getValue())) {
                return (ObjectNode) next;
            }
        }
        throw new RestconfException(String.format("No content for %s = %s", ParserUtils.getJsonNameFromYdtNode(child), child.getValue()), INTERNAL_SERVER_ERROR);
    }
    return result;
}
#method_after
@Override
public ObjectNode runGetOperationOnDataResource(String uri) throws RestconfException {
    YdtBuilder ydtBuilder = getYdtBuilder(QUERY_REQUEST);
    // Convert the URI to ydtBuilder
    convertUriToYdt(uri, ydtBuilder, NONE);
    YdtResponse ydtResponse = ymsService.executeOperation(ydtBuilder);
    YmsOperationExecutionStatus status = ydtResponse.getYmsOperationResult();
    if (status != EXECUTION_SUCCESS) {
        throw new RestconfException("YMS GET operation failed", INTERNAL_SERVER_ERROR);
    }
    YdtContext rootNode = ydtResponse.getRootNode();
    YdtContext curNode = ydtBuilder.getCurNode();
    ObjectNode result = convertYdtToJson(getJsonNameFromYdtNode(curNode), rootNode, ymsService.getYdtWalker());
    // if the query URI contain a key, something like list=key
    // here should only get get child with the specific key
    YdtContext child = curNode.getFirstChild();
    if (child != null && child.getYdtType() == SINGLE_INSTANCE_LEAF_VALUE_NODE) {
        ArrayNode jsonNode = (ArrayNode) result.get(getJsonNameFromYdtNode(curNode));
        for (JsonNode next : jsonNode) {
            if (next.findValue(getJsonNameFromYdtNode(child)).asText().equals(child.getValue())) {
                return (ObjectNode) next;
            }
        }
        throw new RestconfException(String.format("No content for %s = %s", getJsonNameFromYdtNode(child), child.getValue()), INTERNAL_SERVER_ERROR);
    }
    return result;
}
#end_block

#method_before
private YmsOperationExecutionStatus invokeYmsOp(String uri, ObjectNode rootNode, YdtContextOperationType opType) {
    YdtBuilder ydtBuilder = getYdtBuilder(EDIT_CONFIG_REQUEST);
    // Convert the URI to ydtBuilder
    convertUriToYdt(uri, ydtBuilder, opType);
    // set default operation type for the payload node
    ydtBuilder.setDefaultEditOperationType(opType);
    // convert the payload json body to ydt
    convertJsonToYdt(rootNode, ydtBuilder);
    return ymsService.executeOperation(ydtBuilder).getYmsOperationResult();
}
#method_after
private YmsOperationExecutionStatus invokeYmsOp(String uri, ObjectNode rootNode, YdtContextOperationType opType) {
    YdtBuilder ydtBuilder = getYdtBuilder(EDIT_CONFIG_REQUEST);
    // Convert the URI to ydtBuilder
    convertUriToYdt(uri, ydtBuilder, opType);
    // set default operation type for the payload node
    ydtBuilder.setDefaultEditOperationType(opType);
    // convert the payload json body to ydt
    convertJsonToYdt(rootNode, ydtBuilder);
    YmsOperationExecutionStatus status = EXECUTION_EXCEPTION;
    try {
        status = ymsService.executeOperation(ydtBuilder).getYmsOperationResult();
    } catch (Exception e) {
        log.error("YMS operation failed: {}", e.getMessage());
        log.debug("Exception in invokeYmsOp: ", e);
    }
    return status;
}
#end_block

#method_before
@Override
public void event(YangNotificationEvent event) {
    if (event.type() != YangNotificationEvent.Type.YANG_NOTIFICATION) {
        // For now, we only handle YANG notification events.
        return;
    }
    if (eventQueueList.isEmpty()) {
        /*
                 * There is no consumer waiting to consume, so don't have to
                 * produce this event.
                 */
        return;
    }
    try {
        /*
                 * Put the event to every queue out there. Each queue is
                 * corresponding to an event stream session. The queue is
                 * removed when the session terminates.
                 */
        for (Entry<String, BlockingQueue<ObjectNode>> entry : eventQueueList.entrySet()) {
            YdtContext ydtNode = event.subject().getNotificationRootContext();
            ObjectNode jsonNode = convertYdtToJson(ParserUtils.getJsonNameFromYdtNode(ydtNode), ydtNode, ymsService.getYdtWalker());
            entry.getValue().put(jsonNode);
        }
    } catch (InterruptedException e) {
        log.error("ERROR", e);
        throw new RestconfException("queue", Status.INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
public void event(YangNotificationEvent event) {
    if (event.type() != YangNotificationEvent.Type.YANG_NOTIFICATION) {
        // For now, we only handle YANG notification events.
        return;
    }
    if (eventQueueList.isEmpty()) {
        /*
                 * There is no consumer waiting to consume, so don't have to
                 * produce this event.
                 */
        return;
    }
    try {
        /*
                 * Put the event to every queue out there. Each queue is
                 * corresponding to an event stream session. The queue is
                 * removed when the session terminates.
                 */
        for (Entry<String, BlockingQueue<ObjectNode>> entry : eventQueueList.entrySet()) {
            YdtContext ydtNode = event.subject().getNotificationRootContext();
            ObjectNode jsonNode = convertYdtToJson(getJsonNameFromYdtNode(ydtNode), ydtNode, ymsService.getYdtWalker());
            entry.getValue().put(jsonNode);
        }
    } catch (InterruptedException e) {
        log.error("Failed to put event in queue: {}", e.getMessage());
        log.debug("Exception trace in InternalYangNotificationListener: ", e);
        throw new RestconfException("Failed to put event in queue", INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private InputStream includeViewIds(UiExtensionService service) {
    StringBuilder sb = new StringBuilder("\n");
    for (UiExtension extension : service.getExtensions()) {
        for (UiView view : extension.views()) {
            sb.append(PREFIX).append(view.id()).append(MIDFIX).append(view.helpPage()).append(SUFFIX);
        }
    }
    return new ByteArrayInputStream(sb.toString().getBytes());
}
#method_after
private InputStream includeViewIds(UiExtensionService service) {
    StringBuilder sb = new StringBuilder("\n");
    for (UiExtension extension : service.getExtensions()) {
        for (UiView view : extension.views()) {
            sb.append(PREFIX).append(view.id()).append(MIDFIX).append(sanitizeUrl(view.helpPageUrl())).append(SUFFIX);
        }
    }
    return new ByteArrayInputStream(sb.toString().getBytes());
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlows(@QueryParam("appId") String appId, InputStream stream) {
    try {
        final ApplicationService appService = get(ApplicationService.class);
        final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        ArrayNode flowsArray = nullIsIllegal((ArrayNode) jsonTree.get(FLOWS), FLOW_ARRAY_REQUIRED);
        if (appId != null) {
            flowsArray.forEach(flowJson -> ((ObjectNode) flowJson).put("appId", idInstant.name()));
        }
        List<FlowRule> rules = codec(FlowRule.class).decode(flowsArray, this);
        service.applyFlowRules(rules.toArray(new FlowRule[rules.size()]));
        rules.forEach(flowRule -> {
            ObjectNode flowNode = mapper().createObjectNode();
            flowNode.put(DEVICE_ID, flowRule.deviceId().toString()).put(FLOW_ID, Long.toString(flowRule.id().value()));
            flowsNode.add(flowNode);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.ok(root).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlows(@QueryParam("appId") String appId, InputStream stream) {
    try {
        final ApplicationService appService = get(ApplicationService.class);
        final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        ArrayNode flowsArray = nullIsIllegal((ArrayNode) jsonTree.get(FLOWS), FLOW_ARRAY_REQUIRED);
        flowsArray.forEach(flowJson -> ((ObjectNode) flowJson).put("appId", idInstant.name()));
        List<FlowRule> rules = codec(FlowRule.class).decode(flowsArray, this);
        service.applyFlowRules(rules.toArray(new FlowRule[rules.size()]));
        rules.forEach(flowRule -> {
            ObjectNode flowNode = mapper().createObjectNode();
            flowNode.put(DEVICE_ID, flowRule.deviceId().toString()).put(FLOW_ID, Long.toString(flowRule.id().value()));
            flowsNode.add(flowNode);
        });
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
    return Response.ok(root).build();
}
#end_block

#method_before
@POST
@Path("{deviceId}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlow(@PathParam("deviceId") String deviceId, @QueryParam("appId") String appId, InputStream stream) {
    try {
        final ApplicationService appService = get(ApplicationService.class);
        final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode specifiedDeviceId = jsonTree.get("deviceId");
        if (specifiedDeviceId != null && !specifiedDeviceId.asText().equals(deviceId)) {
            throw new IllegalArgumentException("Invalid deviceId in flow creation request");
        }
        jsonTree.put("deviceId", deviceId);
        if (appId != null) {
            jsonTree.put("appId", idInstant.name());
        }
        FlowRule rule = codec(FlowRule.class).decode(jsonTree, this);
        service.applyFlowRules(rule);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("flows").path(deviceId).path(Long.toString(rule.id().value()));
        return Response.created(locationBuilder.build()).build();
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
}
#method_after
@POST
@Path("{deviceId}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createFlow(@PathParam("deviceId") String deviceId, @QueryParam("appId") String appId, InputStream stream) {
    try {
        final ApplicationService appService = get(ApplicationService.class);
        final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode specifiedDeviceId = jsonTree.get("deviceId");
        if (specifiedDeviceId != null && !specifiedDeviceId.asText().equals(deviceId)) {
            throw new IllegalArgumentException("Invalid deviceId in flow creation request");
        }
        jsonTree.put("deviceId", deviceId);
        jsonTree.put("appId", idInstant.name());
        FlowRule rule = codec(FlowRule.class).decode(jsonTree, this);
        service.applyFlowRules(rule);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("flows").path(deviceId).path(Long.toString(rule.id().value()));
        return Response.created(locationBuilder.build()).build();
    } catch (IOException ex) {
        throw new IllegalArgumentException(ex);
    }
}
#end_block

#method_before
@Override
public List<Alarm> consumeAlarms() {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return null;
    }
    dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    List<Alarm> alarms = new ArrayList<>();
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN + VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT + NEW_LINE);
        request.append(buildStartTag(VOLT_ALERTS)).append(buildEmptyTag(OLT_ACTIVE_ALERTS)).append(buildEndTag(VOLT_ALERTS)).append(VOLT_NE_CLOSE);
        String reply = controller.getDevicesMap().get(ncDeviceId).getSession().get(request.toString(), null);
        if (reply != null) {
            alarms = parseVoltActiveAlerts(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
        }
    } catch (IOException e) {
        log.error("Error reading alarms for device {} exception {}", ncDeviceId, e);
    }
    return ImmutableList.copyOf(alarms);
}
#method_after
@Override
public List<Alarm> consumeAlarms() {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return null;
    }
    dateFormat.setTimeZone(ZONE);
    List<Alarm> alarms = new ArrayList<>();
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN + VOLT_NE_NAMESPACE).append(ANGLE_RIGHT + NEW_LINE).append(buildStartTag(VOLT_ALERTS)).append(buildEmptyTag(OLT_ACTIVE_ALERTS)).append(buildEndTag(VOLT_ALERTS)).append(VOLT_NE_CLOSE);
        String reply = controller.getDevicesMap().get(ncDeviceId).getSession().get(request.toString(), null);
        if (reply != null) {
            alarms = parseVoltActiveAlerts(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
        }
    } catch (IOException e) {
        log.error("Error reading alarms for device {} exception {}", ncDeviceId, e);
    }
    return ImmutableList.copyOf(alarms);
}
#end_block

#method_before
private List<Alarm> parseVoltActiveAlerts(HierarchicalConfiguration cfg) {
    List<Alarm> alarms = new ArrayList<>();
    List<HierarchicalConfiguration> fields = cfg.configurationsAt(OLT_ACTIVE_ALERTS_KEY);
    for (HierarchicalConfiguration sub : fields) {
        List<HierarchicalConfiguration> childFields = sub.configurationsAt(ALERT_INFO);
        for (HierarchicalConfiguration child : childFields) {
            try {
                int seqNum = Integer.parseInt(child.getString(ALERT_SEQNUM));
                boolean cleared = Boolean.parseBoolean(child.getString(ALERT_CLEAR));
                String alertType = child.getString(ALERT_TYPE);
                String severity = child.getString(SEVERITY);
                List<HierarchicalConfiguration> idFields = child.configurationsAt(RESOURCE_ID);
                if (idFields.isEmpty()) {
                    log.error("{} does not exsit: SQ={}, TYPE={}, SEV={}, CLEARED={}", RESOURCE_ID, seqNum, alertType, severity, cleared);
                    continue;
                }
                String alarmSrc = formAlarmSource(idFields);
                if (alarmSrc == null) {
                    log.error("Cannot build description: SQ={}, TYPE={}, SEV={}, CLEARED={}", seqNum, alertType, severity, cleared);
                    continue;
                }
                long timeRaised = getTimeRaised(child);
                log.debug("VOLT: ACTIVE ALERT: SQ={}, TYPE={}, SEV={}, CLEARED={}, TIME={}", seqNum, alertType, severity, cleared, timeRaised);
                Alarm.SeverityLevel alarmLevel = AlertSeverity.convertToAlarmSeverityLevel(severity);
                if (alarmLevel.equals(Alarm.SeverityLevel.INDETERMINATE)) {
                    log.warn("Unknown severity: {}", severity);
                }
                DefaultAlarm.Builder alarmBuilder = new DefaultAlarm.Builder(ncDeviceId, alertType.toUpperCase(), alarmLevel, timeRaised).forSource(AlarmEntityId.alarmEntityId(alarmSrc));
                alarms.add(alarmBuilder.build());
            } catch (NumberFormatException e) {
                log.error("Non-number exception {}", e);
            } catch (Exception e) {
                log.error("Exception {}", e);
            }
        }
    }
    return alarms;
}
#method_after
private List<Alarm> parseVoltActiveAlerts(HierarchicalConfiguration cfg) {
    List<Alarm> alarms = new ArrayList<>();
    List<HierarchicalConfiguration> fields = cfg.configurationsAt(OLT_ACTIVE_ALERTS_KEY);
    for (HierarchicalConfiguration sub : fields) {
        List<HierarchicalConfiguration> childFields = sub.configurationsAt(ALERT_INFO);
        for (HierarchicalConfiguration child : childFields) {
            try {
                int seqNum = Integer.parseInt(child.getString(ALERT_SEQNUM));
                boolean cleared = Boolean.parseBoolean(child.getString(ALERT_CLEAR));
                String alertType = child.getString(ALERT_TYPE);
                String severity = child.getString(SEVERITY);
                List<HierarchicalConfiguration> idFields = child.configurationsAt(RESOURCE_ID);
                if (idFields.isEmpty()) {
                    log.error("{} does not exsit: SQ={}, TYPE={}, SEV={}, CLEARED={}", RESOURCE_ID, seqNum, alertType, severity, cleared);
                    continue;
                }
                String alarmSrc = formAlarmSource(idFields);
                if (alarmSrc == null) {
                    log.error("Cannot build description: SQ={}, TYPE={}, SEV={}, CLEARED={}", seqNum, alertType, severity, cleared);
                    continue;
                }
                long timeRaised = getTimeRaised(child);
                log.debug("VOLT: ACTIVE ALERT: SQ={}, TYPE={}, SEV={}, CLEARED={}, TIME={}", seqNum, alertType, severity, cleared, timeRaised);
                SeverityLevel alarmLevel = AlertSeverity.convertToAlarmSeverityLevel(severity);
                if (alarmLevel.equals(SeverityLevel.INDETERMINATE)) {
                    log.warn("Unknown severity: {}", severity);
                }
                DefaultAlarm.Builder alarmBuilder = new DefaultAlarm.Builder(ncDeviceId, alertType.toUpperCase(), alarmLevel, timeRaised).forSource(AlarmEntityId.alarmEntityId(alarmSrc));
                alarms.add(alarmBuilder.build());
            } catch (NumberFormatException e) {
                log.error("Non-number exception {}", e);
            } catch (Exception e) {
                log.error("Exception {}", e);
            }
        }
    }
    return alarms;
}
#end_block

#method_before
private long getTimeRaised(HierarchicalConfiguration cfg) {
    String strDate;
    String strTime;
    long timeRaised;
    List<HierarchicalConfiguration> timeFields = cfg.configurationsAt(ALERT_TIME);
    if (timeFields.isEmpty()) {
        log.error("{} does not exsit", ALERT_TIME);
    } else {
        for (HierarchicalConfiguration child : timeFields) {
            strDate = child.getString(DATE);
            strTime = child.getString(TIME);
            if ((strDate != null) && (strTime != null)) {
                try {
                    Date date = dateFormat.parse(strDate + SPACE + strTime);
                    timeRaised = date.getTime();
                    log.debug("{} {} coverted to {}", strDate, strTime, timeRaised);
                    return timeRaised;
                } catch (ParseException e) {
                    log.error("Cannot parse exception {} {} {}", strDate, strTime, e);
                }
            } else {
                log.error("{} or {} does not exsit", DATE, TIME);
            }
        }
    }
    // Use the system's time instead.
    return System.currentTimeMillis();
}
#method_after
private long getTimeRaised(HierarchicalConfiguration cfg) {
    String strDate;
    String strTime;
    long timeRaised;
    List<HierarchicalConfiguration> timeFields = cfg.configurationsAt(ALERT_TIME);
    if (timeFields.isEmpty()) {
        log.debug("{} does not exsit", ALERT_TIME);
    } else {
        for (HierarchicalConfiguration child : timeFields) {
            strDate = child.getString(DATE);
            strTime = child.getString(TIME);
            if ((strDate != null) && (strTime != null)) {
                try {
                    Date date = dateFormat.parse(strDate + SPACE + strTime);
                    timeRaised = date.getTime();
                    log.debug("{} {} coverted to {}", strDate, strTime, timeRaised);
                    return timeRaised;
                } catch (ParseException e) {
                    log.error("Cannot parse exception {} {} {}", strDate, strTime, e);
                }
            } else {
                log.error("{} or {} does not exsit", DATE, TIME);
            }
        }
    }
    // Use the system's time instead.
    return System.currentTimeMillis();
}
#end_block

#method_before
public void run() {
    BufferedReader bufferReader = new BufferedReader(new InputStreamReader(in));
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
                NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                socketClosed = true;
                log.info("Netconf device {} ERROR cInt == -1 socketClosed = true", netconfDeviceInfo);
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    log.info("Netconf device {} socketClosed = true DEVICE_UNREGISTERED {}", netconfDeviceInfo, deviceReply);
                    NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                    netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    this.interrupt();
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    if (deviceReply.contains(RPC_REPLY) || deviceReply.contains(RPC_ERROR) || deviceReply.contains(HELLO)) {
                        log.info("Netconf device {} sessionDelegate.notify() DEVICE_REPLY {} {}", netconfDeviceInfo, getMsgId(deviceReply), deviceReply);
                        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_REPLY, null, deviceReply, getMsgId(deviceReply), netconfDeviceInfo);
                        sessionDelegate.notify(event);
                        netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    } else if (deviceReply.contains(NOTIFICATION_LABEL)) {
                        log.info("Netconf device {} DEVICE_NOTIFICATION {} {} {}", netconfDeviceInfo, enableNotifications, getMsgId(deviceReply), deviceReply);
                        if (enableNotifications) {
                            final String finalDeviceReply = deviceReply;
                            netconfDeviceEventListeners.forEach(listener -> listener.event(new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, finalDeviceReply, getMsgId(finalDeviceReply), netconfDeviceInfo)));
                        }
                    } else {
                        log.info("Error on reply from device {} {}", netconfDeviceInfo, deviceReply);
                    }
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#method_after
public void run() {
    BufferedReader bufferReader = new BufferedReader(new InputStreamReader(in));
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
                NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                socketClosed = true;
                log.debug("Netconf device {} ERROR cInt == -1 socketClosed = true", netconfDeviceInfo);
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    log.debug("Netconf device {} socketClosed = true DEVICE_UNREGISTERED {}", netconfDeviceInfo, deviceReply);
                    NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                    netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    this.interrupt();
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    if (deviceReply.contains(RPC_REPLY) || deviceReply.contains(RPC_ERROR) || deviceReply.contains(HELLO)) {
                        log.debug("Netconf device {} sessionDelegate.notify() DEVICE_REPLY {} {}", netconfDeviceInfo, getMsgId(deviceReply), deviceReply);
                        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_REPLY, null, deviceReply, getMsgId(deviceReply), netconfDeviceInfo);
                        sessionDelegate.notify(event);
                        netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    } else if (deviceReply.contains(NOTIFICATION_LABEL)) {
                        log.debug("Netconf device {} DEVICE_NOTIFICATION {} {} {}", netconfDeviceInfo, enableNotifications, getMsgId(deviceReply), deviceReply);
                        if (enableNotifications) {
                            final String finalDeviceReply = deviceReply;
                            netconfDeviceEventListeners.forEach(listener -> listener.event(new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, finalDeviceReply, getMsgId(finalDeviceReply), netconfDeviceInfo)));
                        }
                    } else {
                        log.debug("Error on reply from device {} {}", netconfDeviceInfo, deviceReply);
                    }
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#end_block

#method_before
private void encodeL2(ObjectNode result) {
    L2ModificationInstruction l2Instruction = (L2ModificationInstruction) instruction;
    result.put(InstructionCodec.SUBTYPE, l2Instruction.subtype().name());
    switch(l2Instruction.subtype()) {
        case ETH_SRC:
        case ETH_DST:
            final L2ModificationInstruction.ModEtherInstruction modEtherInstruction = (L2ModificationInstruction.ModEtherInstruction) l2Instruction;
            result.put(InstructionCodec.MAC, modEtherInstruction.mac().toString());
            break;
        case VLAN_ID:
            final L2ModificationInstruction.ModVlanIdInstruction modVlanIdInstruction = (L2ModificationInstruction.ModVlanIdInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_ID, modVlanIdInstruction.vlanId().toShort());
            break;
        case VLAN_PCP:
            final L2ModificationInstruction.ModVlanPcpInstruction modVlanPcpInstruction = (L2ModificationInstruction.ModVlanPcpInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_PCP, modVlanPcpInstruction.vlanPcp());
            break;
        case VLAN_PUSH:
            final L2ModificationInstruction.ModVlanHeaderInstruction pushVlanInstruction = (L2ModificationInstruction.ModVlanHeaderInstruction) l2Instruction;
            result.put(InstructionCodec.ETHERNET_TYPE, pushVlanInstruction.ethernetType().toShort());
            break;
        case MPLS_LABEL:
            final L2ModificationInstruction.ModMplsLabelInstruction modMplsLabelInstruction = (L2ModificationInstruction.ModMplsLabelInstruction) l2Instruction;
            result.put(InstructionCodec.MPLS_LABEL, modMplsLabelInstruction.label().toInt());
            break;
        case MPLS_PUSH:
            final L2ModificationInstruction.ModMplsHeaderInstruction pushHeaderInstructions = (L2ModificationInstruction.ModMplsHeaderInstruction) l2Instruction;
            result.put(InstructionCodec.ETHERNET_TYPE, pushHeaderInstructions.ethernetType().toShort());
            break;
        case TUNNEL_ID:
            final L2ModificationInstruction.ModTunnelIdInstruction modTunnelIdInstruction = (L2ModificationInstruction.ModTunnelIdInstruction) l2Instruction;
            result.put(InstructionCodec.TUNNEL_ID, modTunnelIdInstruction.tunnelId());
            break;
        case MPLS_BOS:
            final L2ModificationInstruction.ModMplsBosInstruction modMplsBosInstruction = (L2ModificationInstruction.ModMplsBosInstruction) l2Instruction;
            result.put(InstructionCodec.MPLS_BOS, modMplsBosInstruction.mplsBos());
        case MPLS_POP:
        case DEC_MPLS_TTL:
            break;
        default:
            log.info("Cannot convert L2 subtype of {}", l2Instruction.subtype());
            break;
    }
}
#method_after
private void encodeL2(ObjectNode result) {
    L2ModificationInstruction l2Instruction = (L2ModificationInstruction) instruction;
    result.put(InstructionCodec.SUBTYPE, l2Instruction.subtype().name());
    switch(l2Instruction.subtype()) {
        case ETH_SRC:
        case ETH_DST:
            final L2ModificationInstruction.ModEtherInstruction modEtherInstruction = (L2ModificationInstruction.ModEtherInstruction) l2Instruction;
            result.put(InstructionCodec.MAC, modEtherInstruction.mac().toString());
            break;
        case VLAN_ID:
            final L2ModificationInstruction.ModVlanIdInstruction modVlanIdInstruction = (L2ModificationInstruction.ModVlanIdInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_ID, modVlanIdInstruction.vlanId().toShort());
            break;
        case VLAN_PCP:
            final L2ModificationInstruction.ModVlanPcpInstruction modVlanPcpInstruction = (L2ModificationInstruction.ModVlanPcpInstruction) l2Instruction;
            result.put(InstructionCodec.VLAN_PCP, modVlanPcpInstruction.vlanPcp());
            break;
        case VLAN_PUSH:
            final L2ModificationInstruction.ModVlanHeaderInstruction pushVlanInstruction = (L2ModificationInstruction.ModVlanHeaderInstruction) l2Instruction;
            result.put(InstructionCodec.ETHERNET_TYPE, pushVlanInstruction.ethernetType().toString());
            break;
        case MPLS_LABEL:
            final L2ModificationInstruction.ModMplsLabelInstruction modMplsLabelInstruction = (L2ModificationInstruction.ModMplsLabelInstruction) l2Instruction;
            result.put(InstructionCodec.MPLS_LABEL, modMplsLabelInstruction.label().toInt());
            break;
        case MPLS_PUSH:
            final L2ModificationInstruction.ModMplsHeaderInstruction pushHeaderInstructions = (L2ModificationInstruction.ModMplsHeaderInstruction) l2Instruction;
            result.put(InstructionCodec.ETHERNET_TYPE, pushHeaderInstructions.ethernetType().toShort());
            break;
        case TUNNEL_ID:
            final L2ModificationInstruction.ModTunnelIdInstruction modTunnelIdInstruction = (L2ModificationInstruction.ModTunnelIdInstruction) l2Instruction;
            result.put(InstructionCodec.TUNNEL_ID, modTunnelIdInstruction.tunnelId());
            break;
        case MPLS_BOS:
            final L2ModificationInstruction.ModMplsBosInstruction modMplsBosInstruction = (L2ModificationInstruction.ModMplsBosInstruction) l2Instruction;
            result.put(InstructionCodec.MPLS_BOS, modMplsBosInstruction.mplsBos());
        case MPLS_POP:
        case DEC_MPLS_TTL:
            break;
        default:
            log.info("Cannot convert L2 subtype of {}", l2Instruction.subtype());
            break;
    }
}
#end_block

#method_before
private EthType getEthType() {
    String ethTypeStr = nullIsIllegal(json.get(InstructionCodec.ETHERNET_TYPE), InstructionCodec.ETHERNET_TYPE + InstructionCodec.MISSING_MEMBER_MESSAGE).asText();
    Pattern pattern = Pattern.compile("0x([0-9a-fA-F]+)");
    Matcher matcher = pattern.matcher(ethTypeStr);
    if (!matcher.find()) {
        throw new IllegalArgumentException("ETHERNET_TYPE must be a hex string starting with 0x");
    }
    short ethernetType = (short) Integer.parseInt(matcher.group(1), 16);
    return new EthType(ethernetType);
}
#method_after
private EthType getEthType() {
    String ethTypeStr = nullIsIllegal(json.get(InstructionCodec.ETHERNET_TYPE), InstructionCodec.ETHERNET_TYPE + InstructionCodec.MISSING_MEMBER_MESSAGE).asText();
    Matcher matcher = ETHTYPE_PATTERN.matcher(ethTypeStr);
    if (!matcher.matches()) {
        throw new IllegalArgumentException("ETHERNET_TYPE must be a four digit hex string starting with 0x");
    }
    short ethernetType = (short) Integer.parseInt(matcher.group(1), 16);
    return new EthType(ethernetType);
}
#end_block

#method_before
@Override
public boolean copyConfig(String targetConfiguration, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    if (!newConfiguration.startsWith("<configuration>")) {
        newConfiguration = "<configuration>" + newConfiguration + "</configuration>";
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\" ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append("<copy-config>");
    rpc.append("<target>");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</target>");
    rpc.append("<source>");
    rpc.append("<").append(newConfiguration).append("/>");
    rpc.append("</source>");
    rpc.append("</copy-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean copyConfig(String targetConfiguration, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    if (!newConfiguration.startsWith("<config>")) {
        newConfiguration = "<config>" + newConfiguration + "</config>";
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append("<copy-config>");
    rpc.append("<target>");
    rpc.append("<").append(targetConfiguration).append("/>");
    rpc.append("</target>");
    rpc.append("<source>");
    rpc.append(newConfiguration);
    rpc.append("</source>");
    rpc.append("</copy-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#end_block

#method_before
private FlowRule findFlowById(String appIdText, String flowId) {
    flowId = flowId.replaceAll("0x", "");
    FlowRuleService fs = get(FlowRuleService.class);
    int appIdInt = Integer.parseInt(appIdText);
    ApplicationId appId = new DefaultApplicationId(appIdInt, "details");
    Iterable<FlowRule> flows = fs.getFlowRulesById(appId);
    for (FlowRule flow : flows) {
        if (flow.id().toString().equals(flowId)) {
            return flow;
        }
    }
    return null;
}
#method_after
private FlowRule findFlowById(String appIdText, String flowId) {
    String strippedFlowId = flowId.replaceAll(OX, EMPTY);
    FlowRuleService fs = get(FlowRuleService.class);
    int appIdInt = Integer.parseInt(appIdText);
    ApplicationId appId = new DefaultApplicationId(appIdInt, DETAILS);
    Iterable<FlowRule> flows = fs.getFlowRulesById(appId);
    for (FlowRule flow : flows) {
        if (flow.id().toString().equals(strippedFlowId)) {
            return flow;
        }
    }
    return null;
}
#end_block

#method_before
private String decorateFlowId(FlowRule flow) {
    String flowId = "0x" + flow.id().toString();
    return flowId;
}
#method_after
private String decorateFlowId(FlowRule flow) {
    return OX + flow.id();
}
#end_block

#method_before
public static <K1, V1, K2, V2> AsyncConsistentMultimap<K1, V1> newTranscodingMultimap(AsyncConsistentMultimap<K2, V2> multimap, Function<K1, K2> keyEncoder, Function<K2, K1> keyDecoder, Function<V1, V2> valueEncoder, Function<V2, V1> valueDecoder) {
    return new TranscodingAsyncConsistentMultimap<K1, V1, K2, V2>(multimap, keyEncoder, keyDecoder, valueDecoder, valueEncoder);
}
#method_after
public static <K1, V1, K2, V2> AsyncConsistentMultimap<K1, V1> newTranscodingMultimap(AsyncConsistentMultimap<K2, V2> multimap, Function<K1, K2> keyEncoder, Function<K2, K1> keyDecoder, Function<V1, V2> valueEncoder, Function<V2, V1> valueDecoder) {
    return new TranscodingAsyncConsistentMultimap<>(multimap, keyEncoder, keyDecoder, valueDecoder, valueEncoder);
}
#end_block

#method_before
@Override
public <K, V> ConsistentMultimapBuilder<K, V> consistentMultimapBuilder() {
    return null;
}
#method_after
public <K, V> ConsistentMultimapBuilder<K, V> consistentMultimapBuilder() {
    return null;
}
#end_block

#method_before
@Override
public LispType getType() {
    return LispType.LISP_ENCAPSULATED_CONTROL;
}
#method_after
@Override
public LispType getType() {
    return LISP_ENCAPSULATED_CONTROL;
}
#end_block

#method_before
@Override
public void writeTo(ByteBuf byteBuf) {
// TODO: serialize LispECM message
}
#method_after
@Override
public void writeTo(ByteBuf byteBuf) throws LispWriterException {
    WRITER.writeTo(byteBuf, this);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("type", getType()).add("isSecurity", isSecurity).add("inner UDP header", innerUdp).add("inner lisp Message", innerMessage).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("type", getType()).add("isSecurity", isSecurity).add("inner IP header", innerIpHeader).add("inner UDP header", innerUdp).add("inner lisp Message", innerMessage).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    DefaultLispEncapsulatedControl that = (DefaultLispEncapsulatedControl) o;
    return Objects.equal(isSecurity, that.isSecurity) && Objects.equal(innerUdp, that.innerUdp) && Objects.equal(innerMessage, that.innerMessage);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    DefaultLispEncapsulatedControl that = (DefaultLispEncapsulatedControl) o;
    return Objects.equal(isSecurity, that.isSecurity) && Objects.equal(innerIpHeader, that.innerIpHeader) && Objects.equal(innerUdp, that.innerUdp) && Objects.equal(innerMessage, that.innerMessage);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(isSecurity, innerUdp, innerMessage);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(isSecurity, innerIpHeader, innerUdp, innerMessage);
}
#end_block

#method_before
@Override
public LispEncapsulatedControl build() {
    return new DefaultLispEncapsulatedControl(isSecurity, innerUdp, innerMessage);
}
#method_after
@Override
public LispEncapsulatedControl build() {
    return new DefaultLispEncapsulatedControl(isSecurity, innerIpHeader, innerUdpHeader, innerMessage);
}
#end_block

#method_before
@Override
public LispEncapsulatedControl readFrom(ByteBuf byteBuf) throws LispParseError, LispReaderException, DeserializationException {
    if (byteBuf.readerIndex() != 0) {
        return null;
    }
    boolean securityFlag = ByteOperator.getBit(byteBuf.readByte(), SECURITY_INDEX);
    // let's skip the reserved field
    byteBuf.skipBytes(RESERVED_SKIP_LENGTH);
    byte[] udpHeader = new byte[UDP_HEADER_LENGTH];
    byteBuf.getBytes(byteBuf.readerIndex(), udpHeader, 0, UDP_HEADER_LENGTH);
    UDP innerUdp = UDP.deserializer().deserialize(udpHeader, 0, UDP_HEADER_LENGTH);
    innerUdp.setPayload(null);
    byteBuf.skipBytes(UDP_HEADER_LENGTH);
    LispMessageReader reader = LispMessageReaderFactory.getReader(byteBuf);
    LispMessage innerMessage = (LispMessage) reader.readFrom(byteBuf);
    return new DefaultLispEncapsulatedControl(securityFlag, innerUdp, innerMessage);
}
#method_after
@Override
public LispEncapsulatedControl readFrom(ByteBuf byteBuf) throws LispParseError, LispReaderException, DeserializationException {
    if (byteBuf.readerIndex() != 0) {
        return null;
    }
    boolean securityFlag = ByteOperator.getBit(byteBuf.readByte(), SECURITY_INDEX);
    // let's skip the reserved field
    byteBuf.skipBytes(RESERVED_SKIP_LENGTH);
    short totalLength = byteBuf.getShort(byteBuf.readerIndex() + 2);
    byte[] ipHeaderByte = new byte[totalLength];
    byteBuf.getBytes(byteBuf.readerIndex(), ipHeaderByte, 0, totalLength);
    IP innerIpHeader = IP.deserializer().deserialize(ipHeaderByte, 0, totalLength);
    UDP innerUdp = (UDP) innerIpHeader.getPayload();
    Data data = (Data) innerUdp.getPayload();
    ByteBuf msgBuffer = Unpooled.buffer();
    msgBuffer.writeBytes(data.getData());
    LispMessageReader reader = LispMessageReaderFactory.getReader(msgBuffer);
    LispMessage innerMessage = (LispMessage) reader.readFrom(msgBuffer);
    return new DefaultLispEncapsulatedControl(securityFlag, innerIpHeader, innerUdp, innerMessage);
}
#end_block

#method_before
@Override
public void writeTo(ByteBuf byteBuf, LispEncapsulatedControl message) throws LispWriterException {
    // specify LISP message type
    byte msgType = (byte) (ECM_MSG_TYPE << ECM_SHIFT_BIT);
    byte security = DISABLE_BIT;
    if (message.isSecurity()) {
        security = (byte) (ENABLE_BIT << SECURITY_SHIFT_BIT);
    }
    byteBuf.writeByte(msgType + security);
    // fill zero into reserved field
    byteBuf.writeByte((byte) UNUSED_ZERO);
    byteBuf.writeByte((byte) UNUSED_ZERO);
    byteBuf.writeByte((byte) UNUSED_ZERO);
    byteBuf.writeBytes(message.getInnerUdp().serialize());
    message.getControlMessage().writeTo(byteBuf);
}
#method_after
@Override
public void writeTo(ByteBuf byteBuf, LispEncapsulatedControl message) throws LispWriterException {
    // specify LISP message type
    byte msgType = (byte) (ECM_MSG_CODE << TYPE_SHIFT_BIT);
    byte security = DISABLE_BIT;
    if (message.isSecurity()) {
        security = (byte) (ENABLE_BIT << SECURITY_SHIFT_BIT);
    }
    byteBuf.writeByte(msgType + security);
    // fill zero into reserved field
    byteBuf.writeByte((byte) UNUSED_ZERO);
    byteBuf.writeByte((byte) UNUSED_ZERO);
    byteBuf.writeByte((byte) UNUSED_ZERO);
    ByteBuf buffer = Unpooled.buffer();
    message.getControlMessage().writeTo(buffer);
    byte[] dataBytes = new byte[buffer.writerIndex()];
    buffer.getBytes(0, dataBytes, 0, buffer.writerIndex());
    message.innerUdp().setPayload(new Data(dataBytes));
    message.innerIpHeader().setPayload(message.innerUdp());
    byteBuf.writeBytes(message.innerIpHeader().serialize());
}
#end_block

#method_before
public static LispMessageReader getReader(ByteBuf buffer) {
    LispMessageReader reader;
    int type = buffer.getByte(0) >> TYPE_SHIFT_BIT;
    switch(type) {
        case 1:
            reader = new RequestReader();
            break;
        case 2:
            reader = new ReplyReader();
            break;
        case 3:
            reader = new RegisterReader();
            break;
        case 4:
            reader = new NotifyReader();
            break;
        case 8:
            reader = new EcmReader();
            break;
        default:
            throw new IllegalArgumentException("Unknown LISP message type: " + type);
    }
    return reader;
}
#method_after
public static LispMessageReader getReader(ByteBuf buffer) {
    LispMessageReader reader;
    LispType type = LispType.valueOf((short) (buffer.getByte(0) >> TYPE_SHIFT_BIT));
    switch(type) {
        case LISP_MAP_REQUEST:
            reader = new RequestReader();
            break;
        case LISP_MAP_REPLY:
            reader = new ReplyReader();
            break;
        case LISP_MAP_REGISTER:
            reader = new RegisterReader();
            break;
        case LISP_MAP_NOTIFY:
            reader = new NotifyReader();
            break;
        case LISP_ENCAPSULATED_CONTROL:
            reader = new EcmReader();
            break;
        case UNKNOWN:
            throw new IllegalArgumentException("Unknown message type: " + type);
        default:
            throw new IllegalArgumentException("Undefined message type: " + type);
    }
    return reader;
}
#end_block

#method_before
protected GroupInfo createL2L3ChainInternal(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta, boolean useSetVlanExtension) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    MacAddress srcMac = MacAddress.ZERO;
    MacAddress dstMac = MacAddress.ZERO;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    if (useSetVlanExtension) {
                        OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(vlanid);
                        outerTtb.extension(ofdpaSetVlanVid, deviceId);
                    } else {
                        outerTtb.setVlanId(vlanid);
                    }
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            if (useSetVlanExtension) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(vlanid);
                outerTtb.extension(ofdpaSetVlanVid, deviceId);
            } else {
                outerTtb.setVlanId(vlanid);
            }
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same device,
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        int mplsInterfaceIndex = getNextAvailableIndex();
        int mplsgroupId = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & mplsInterfaceIndex);
        final GroupKey mplsgroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(mplsInterfaceIndex));
        outerTtb.group(new GroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        int l3unicastIndex = getNextAvailableIndex();
        int l3groupId = L3_UNICAST_TYPE | (TYPE_MASK & l3unicastIndex);
        final GroupKey l3groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3unicastIndex));
        outerTtb.group(new GroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2InterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2InterfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#method_after
protected GroupInfo createL2L3ChainInternal(TrafficTreatment treatment, int nextId, ApplicationId appId, boolean mpls, TrafficSelector meta, boolean useSetVlanExtension) {
    // for the l2interface group, get vlan and port info
    // for the outer group, get the src/dst mac, and vlan info
    TrafficTreatment.Builder outerTtb = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder innerTtb = DefaultTrafficTreatment.builder();
    VlanId vlanid = null;
    long portNum = 0;
    boolean setVlan = false, popVlan = false;
    MacAddress srcMac = MacAddress.ZERO;
    MacAddress dstMac = MacAddress.ZERO;
    for (Instruction ins : treatment.allInstructions()) {
        if (ins.type() == Instruction.Type.L2MODIFICATION) {
            L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
            switch(l2ins.subtype()) {
                case ETH_DST:
                    dstMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthDst(dstMac);
                    break;
                case ETH_SRC:
                    srcMac = ((L2ModificationInstruction.ModEtherInstruction) l2ins).mac();
                    outerTtb.setEthSrc(srcMac);
                    break;
                case VLAN_ID:
                    vlanid = ((L2ModificationInstruction.ModVlanIdInstruction) l2ins).vlanId();
                    if (useSetVlanExtension) {
                        OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(vlanid);
                        outerTtb.extension(ofdpaSetVlanVid, deviceId);
                    } else {
                        outerTtb.setVlanId(vlanid);
                    }
                    setVlan = true;
                    break;
                case VLAN_POP:
                    innerTtb.popVlan();
                    popVlan = true;
                    break;
                case DEC_MPLS_TTL:
                case MPLS_LABEL:
                case MPLS_POP:
                case MPLS_PUSH:
                case VLAN_PCP:
                case VLAN_PUSH:
                default:
                    break;
            }
        } else if (ins.type() == Instruction.Type.OUTPUT) {
            portNum = ((Instructions.OutputInstruction) ins).port().toLong();
            innerTtb.add(ins);
        } else {
            log.warn("Driver does not handle this type of TrafficTreatment" + " instruction in nextObjectives:  {}", ins.type());
        }
    }
    if (vlanid == null && meta != null) {
        // use metadata if available
        Criterion vidCriterion = meta.getCriterion(Criterion.Type.VLAN_VID);
        if (vidCriterion != null) {
            vlanid = ((VlanIdCriterion) vidCriterion).vlanId();
        }
        // if vlan is not set, use the vlan in metadata for outerTtb
        if (vlanid != null && !setVlan) {
            if (useSetVlanExtension) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(vlanid);
                outerTtb.extension(ofdpaSetVlanVid, deviceId);
            } else {
                outerTtb.setVlanId(vlanid);
            }
        }
    }
    if (vlanid == null) {
        log.error("Driver cannot process an L2/L3 group chain without " + "egress vlan information for dev: {} port:{}", deviceId, portNum);
        return null;
    }
    if (!setVlan && !popVlan) {
        // untagged outgoing port
        TrafficTreatment.Builder temp = DefaultTrafficTreatment.builder();
        temp.popVlan();
        innerTtb.build().allInstructions().forEach(i -> temp.add(i));
        innerTtb = temp;
    }
    // assemble information for ofdpa l2interface group
    int l2groupId = L2_INTERFACE_TYPE | (vlanid.toShort() << 16) | (int) portNum;
    // a globally unique groupkey that is different for ports in the same device,
    // but different for the same portnumber on different devices. Also different
    // for the various group-types created out of the same next objective.
    int l2gk = l2InterfaceGroupKey(deviceId, vlanid, portNum);
    final GroupKey l2groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2gk));
    // assemble information for outer group
    GroupDescription outerGrpDesc = null;
    if (mpls) {
        // outer group is MPLSInteface
        int mplsInterfaceIndex = getNextAvailableIndex();
        int mplsgroupId = MPLS_INTERFACE_TYPE | (SUBTYPE_MASK & mplsInterfaceIndex);
        final GroupKey mplsgroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(mplsInterfaceIndex));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the mpls-interface group description to wait for the
        // l2 interface group to be processed
        GroupBucket mplsinterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(mplsinterfaceGroupBucket)), mplsgroupkey, mplsgroupId, appId);
        log.debug("Trying MPLS-Interface: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(mplsgroupId), mplsgroupkey, nextId);
    } else {
        // outer group is L3Unicast
        int l3unicastIndex = getNextAvailableIndex();
        int l3groupId = L3_UNICAST_TYPE | (TYPE_MASK & l3unicastIndex);
        final GroupKey l3groupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3unicastIndex));
        outerTtb.group(new DefaultGroupId(l2groupId));
        // create the l3unicast group description to wait for the
        // l2 interface group to be processed
        GroupBucket l3unicastGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(outerTtb.build());
        outerGrpDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3unicastGroupBucket)), l3groupkey, l3groupId, appId);
        log.debug("Trying L3Unicast: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l3groupId), l3groupkey, nextId);
    }
    // store l2groupkey with the groupChainElem for the outer-group that depends on it
    GroupChainElem gce = new GroupChainElem(outerGrpDesc, 1, false);
    updatePendingGroups(l2groupkey, gce);
    // create group description for the inner l2interfacegroup
    GroupBucket l2InterfaceGroupBucket = DefaultGroupBucket.createIndirectGroupBucket(innerTtb.build());
    GroupDescription l2groupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l2InterfaceGroupBucket)), l2groupkey, l2groupId, appId);
    log.debug("Trying L2Interface: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l2groupId), l2groupkey, nextId);
    return new GroupInfo(l2groupDescription, outerGrpDesc);
}
#end_block

#method_before
private void createL2FloodGroup(NextObjective nextObj, VlanId vlanId, List<GroupInfo> groupInfos) {
    // assemble info for l2 flood group. Since there can be only one flood
    // group for a vlan, its index is always the same - 0
    Integer l2floodgroupId = L2_FLOOD_TYPE | (vlanId.toShort() << 16);
    int l2floodgk = getNextAvailableIndex();
    final GroupKey l2floodgroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        GroupDescription l2intGrpDesc = groupInfo.nextGroupDesc;
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new GroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    });
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // Put all dependency information into allGroupKeys
    List<Deque<GroupKey>> allGroupKeys = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // In this case we should have L2 interface group only
        gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
        gkeyChain.addFirst(l2floodgroupkey);
        allGroupKeys.add(gkeyChain);
    });
    // Point the next objective to this group
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, groupInfos.size(), false);
    groupInfos.forEach(groupInfo -> {
        // Point this group to the next group
        updatePendingGroups(groupInfo.nextGroupDesc.appCookie(), gce);
        // Start installing the inner-most group
        groupService.addGroup(groupInfo.innerMostGroupDesc);
    });
}
#method_after
private void createL2FloodGroup(NextObjective nextObj, VlanId vlanId, List<GroupInfo> groupInfos) {
    // assemble info for l2 flood group. Since there can be only one flood
    // group for a vlan, its index is always the same - 0
    Integer l2floodgroupId = L2_FLOOD_TYPE | (vlanId.toShort() << 16);
    int l2floodgk = getNextAvailableIndex();
    final GroupKey l2floodgroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l2floodgk));
    // collection of group buckets pointing to all the l2 interface groups
    List<GroupBucket> l2floodBuckets = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        GroupDescription l2intGrpDesc = groupInfo.nextGroupDesc;
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(l2intGrpDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l2floodBuckets.add(abucket);
    });
    // create the l2flood group-description to wait for all the
    // l2interface groups to be processed
    GroupDescription l2floodGroupDescription = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l2floodBuckets), l2floodgroupkey, l2floodgroupId, nextObj.appId());
    log.debug("Trying L2-Flood: device:{} gid:{} gkey:{} nextid:{}", deviceId, Integer.toHexString(l2floodgroupId), l2floodgroupkey, nextObj.id());
    // Put all dependency information into allGroupKeys
    List<Deque<GroupKey>> allGroupKeys = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // In this case we should have L2 interface group only
        gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
        gkeyChain.addFirst(l2floodgroupkey);
        allGroupKeys.add(gkeyChain);
    });
    // Point the next objective to this group
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    updatePendingNextObjective(l2floodgroupkey, ofdpaGrp);
    GroupChainElem gce = new GroupChainElem(l2floodGroupDescription, groupInfos.size(), false);
    groupInfos.forEach(groupInfo -> {
        // Point this group to the next group
        updatePendingGroups(groupInfo.nextGroupDesc.appCookie(), gce);
        // Start installing the inner-most group
        groupService.addGroup(groupInfo.innerMostGroupDesc);
    });
}
#end_block

#method_before
private void createL3MulticastGroup(NextObjective nextObj, VlanId vlanId, List<GroupInfo> groupInfos) {
    List<GroupBucket> l3McastBuckets = new ArrayList<>();
    groupInfos.forEach(groupInfo -> {
        // Points to L3 interface group if there is one.
        // Otherwise points to L2 interface group directly.
        GroupDescription nextGroupDesc = (groupInfo.nextGroupDesc != null) ? groupInfo.nextGroupDesc : groupInfo.innerMostGroupDesc;
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new GroupId(nextGroupDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l3McastBuckets.add(abucket);
    });
    int l3MulticastIndex = getNextAvailableIndex();
    int l3MulticastGroupId = L3_MULTICAST_TYPE | vlanId.toShort() << 16 | (TYPE_VLAN_MASK & l3MulticastIndex);
    final GroupKey l3MulticastGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3MulticastIndex));
    GroupDescription l3MulticastGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l3McastBuckets), l3MulticastGroupKey, l3MulticastGroupId, nextObj.appId());
    // Put all dependency information into allGroupKeys
    List<Deque<GroupKey>> allGroupKeys = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc.appCookie());
        // Add L3 interface group to the chain if there is one.
        if (!groupInfo.nextGroupDesc.equals(groupInfo.innerMostGroupDesc)) {
            gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
        }
        gkeyChain.addFirst(l3MulticastGroupKey);
        allGroupKeys.add(gkeyChain);
    });
    // Point the next objective to this group
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    updatePendingNextObjective(l3MulticastGroupKey, ofdpaGrp);
    GroupChainElem outerGce = new GroupChainElem(l3MulticastGroupDesc, groupInfos.size(), false);
    groupInfos.forEach(groupInfo -> {
        // Point this group (L3 multicast) to the next group
        updatePendingGroups(groupInfo.nextGroupDesc.appCookie(), outerGce);
        // Point next group to inner-most group, if any
        if (!groupInfo.nextGroupDesc.equals(groupInfo.innerMostGroupDesc)) {
            GroupChainElem innerGce = new GroupChainElem(groupInfo.nextGroupDesc, 1, false);
            updatePendingGroups(groupInfo.innerMostGroupDesc.appCookie(), innerGce);
        }
        // Start installing the inner-most group
        groupService.addGroup(groupInfo.innerMostGroupDesc);
    });
}
#method_after
private void createL3MulticastGroup(NextObjective nextObj, VlanId vlanId, List<GroupInfo> groupInfos) {
    List<GroupBucket> l3McastBuckets = new ArrayList<>();
    groupInfos.forEach(groupInfo -> {
        // Points to L3 interface group if there is one.
        // Otherwise points to L2 interface group directly.
        GroupDescription nextGroupDesc = (groupInfo.nextGroupDesc != null) ? groupInfo.nextGroupDesc : groupInfo.innerMostGroupDesc;
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(nextGroupDesc.givenGroupId()));
        GroupBucket abucket = DefaultGroupBucket.createAllGroupBucket(ttb.build());
        l3McastBuckets.add(abucket);
    });
    int l3MulticastIndex = getNextAvailableIndex();
    int l3MulticastGroupId = L3_MULTICAST_TYPE | vlanId.toShort() << 16 | (TYPE_VLAN_MASK & l3MulticastIndex);
    final GroupKey l3MulticastGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3MulticastIndex));
    GroupDescription l3MulticastGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.ALL, new GroupBuckets(l3McastBuckets), l3MulticastGroupKey, l3MulticastGroupId, nextObj.appId());
    // Put all dependency information into allGroupKeys
    List<Deque<GroupKey>> allGroupKeys = Lists.newArrayList();
    groupInfos.forEach(groupInfo -> {
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        gkeyChain.addFirst(groupInfo.innerMostGroupDesc.appCookie());
        // Add L3 interface group to the chain if there is one.
        if (!groupInfo.nextGroupDesc.equals(groupInfo.innerMostGroupDesc)) {
            gkeyChain.addFirst(groupInfo.nextGroupDesc.appCookie());
        }
        gkeyChain.addFirst(l3MulticastGroupKey);
        allGroupKeys.add(gkeyChain);
    });
    // Point the next objective to this group
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    updatePendingNextObjective(l3MulticastGroupKey, ofdpaGrp);
    GroupChainElem outerGce = new GroupChainElem(l3MulticastGroupDesc, groupInfos.size(), false);
    groupInfos.forEach(groupInfo -> {
        // Point this group (L3 multicast) to the next group
        updatePendingGroups(groupInfo.nextGroupDesc.appCookie(), outerGce);
        // Point next group to inner-most group, if any
        if (!groupInfo.nextGroupDesc.equals(groupInfo.innerMostGroupDesc)) {
            GroupChainElem innerGce = new GroupChainElem(groupInfo.nextGroupDesc, 1, false);
            updatePendingGroups(groupInfo.innerMostGroupDesc.appCookie(), innerGce);
        }
        // Start installing the inner-most group
        groupService.addGroup(groupInfo.innerMostGroupDesc);
    });
}
#end_block

#method_before
private void processHashedNextObjective(NextObjective nextObj) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObj, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group
    List<GroupBucket> l3ecmpGroupBuckets = new ArrayList<>();
    for (GroupInfo gi : unsentGroups) {
        // create ECMP bucket to point to the outer group
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new GroupId(gi.nextGroupDesc.givenGroupId()));
        GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
        l3ecmpGroupBuckets.add(sbucket);
    }
    int l3ecmpIndex = getNextAvailableIndex();
    int l3ecmpGroupId = L3_ECMP_TYPE | (TYPE_MASK & l3ecmpIndex);
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3ecmpIndex));
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(l3ecmpGroupBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObj.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, l3ecmpGroupBuckets.size(), false);
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l3ecmpGroupKey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l3ecmpGroupKey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l3ecmpGroupKey, ofdpaGrp);
    log.debug("Trying L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObj.id());
    // finally we are ready to send the innermost groups
    for (GroupInfo gi : unsentGroups) {
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerMostGroupDesc.givenGroupId()), deviceId);
        updatePendingGroups(gi.nextGroupDesc.appCookie(), l3ecmpGce);
        groupService.addGroup(gi.innerMostGroupDesc);
    }
}
#method_after
private void processHashedNextObjective(NextObjective nextObj) {
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObj, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group
    List<GroupBucket> l3ecmpGroupBuckets = new ArrayList<>();
    for (GroupInfo gi : unsentGroups) {
        // create ECMP bucket to point to the outer group
        TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
        ttb.group(new DefaultGroupId(gi.nextGroupDesc.givenGroupId()));
        GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
        l3ecmpGroupBuckets.add(sbucket);
    }
    int l3ecmpIndex = getNextAvailableIndex();
    int l3ecmpGroupId = L3_ECMP_TYPE | (TYPE_MASK & l3ecmpIndex);
    GroupKey l3ecmpGroupKey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3ecmpIndex));
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(l3ecmpGroupBuckets), l3ecmpGroupKey, l3ecmpGroupId, nextObj.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, l3ecmpGroupBuckets.size(), false);
    // create objects for local and distributed storage
    allGroupKeys.forEach(gkeyChain -> gkeyChain.addFirst(l3ecmpGroupKey));
    OfdpaNextGroup ofdpaGrp = new OfdpaNextGroup(allGroupKeys, nextObj);
    // store l3ecmpGroupKey with the ofdpaGroupChain for the nextObjective
    // that depends on it
    updatePendingNextObjective(l3ecmpGroupKey, ofdpaGrp);
    log.debug("Trying L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObj.id());
    // finally we are ready to send the innermost groups
    for (GroupInfo gi : unsentGroups) {
        log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerMostGroupDesc.givenGroupId()), deviceId);
        updatePendingGroups(gi.nextGroupDesc.appCookie(), l3ecmpGce);
        groupService.addGroup(gi.innerMostGroupDesc);
    }
}
#end_block

#method_before
private void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.nextGroupDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new GroupId(onelabelGroupInfo.nextGroupDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.nextGroupDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.nextGroupDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.nextGroupDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#method_after
private void createHashBucketChains(NextObjective nextObj, List<Deque<GroupKey>> allGroupKeys, List<GroupInfo> unsentGroups) {
    // break up hashed next objective to multiple groups
    Collection<TrafficTreatment> buckets = nextObj.next();
    for (TrafficTreatment bucket : buckets) {
        // figure out how many labels are pushed in each bucket
        int labelsPushed = 0;
        MplsLabel innermostLabel = null;
        for (Instruction ins : bucket.allInstructions()) {
            if (ins.type() == Instruction.Type.L2MODIFICATION) {
                L2ModificationInstruction l2ins = (L2ModificationInstruction) ins;
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_PUSH) {
                    labelsPushed++;
                }
                if (l2ins.subtype() == L2ModificationInstruction.L2SubType.MPLS_LABEL) {
                    if (innermostLabel == null) {
                        innermostLabel = ((L2ModificationInstruction.ModMplsLabelInstruction) l2ins).label();
                    }
                }
            }
        }
        Deque<GroupKey> gkeyChain = new ArrayDeque<>();
        // XXX we only deal with 0 and 1 label push right now
        if (labelsPushed == 0) {
            GroupInfo nolabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), false, nextObj.meta());
            if (nolabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            gkeyChain.addFirst(nolabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(nolabelGroupInfo.nextGroupDesc.appCookie());
            // we can't send the inner group description yet, as we have to
            // create the dependent ECMP group first. So we store..
            unsentGroups.add(nolabelGroupInfo);
        } else if (labelsPushed == 1) {
            GroupInfo onelabelGroupInfo = createL2L3Chain(bucket, nextObj.id(), nextObj.appId(), true, nextObj.meta());
            if (onelabelGroupInfo == null) {
                log.error("Could not process nextObj={} in dev:{}", nextObj.id(), deviceId);
                return;
            }
            // we need to add another group to this chain - the L3VPN group
            TrafficTreatment.Builder l3vpnTtb = DefaultTrafficTreatment.builder();
            l3vpnTtb.pushMpls().setMpls(innermostLabel).setMplsBos(true).copyTtlOut().group(new DefaultGroupId(onelabelGroupInfo.nextGroupDesc.givenGroupId()));
            GroupBucket l3vpnGrpBkt = DefaultGroupBucket.createIndirectGroupBucket(l3vpnTtb.build());
            int l3vpnIndex = getNextAvailableIndex();
            int l3vpngroupId = MPLS_L3VPN_SUBTYPE | (SUBTYPE_MASK & l3vpnIndex);
            GroupKey l3vpngroupkey = new DefaultGroupKey(Ofdpa2Pipeline.appKryo.serialize(l3vpnIndex));
            GroupDescription l3vpnGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.INDIRECT, new GroupBuckets(Collections.singletonList(l3vpnGrpBkt)), l3vpngroupkey, l3vpngroupId, nextObj.appId());
            GroupChainElem l3vpnGce = new GroupChainElem(l3vpnGroupDesc, 1, false);
            updatePendingGroups(onelabelGroupInfo.nextGroupDesc.appCookie(), l3vpnGce);
            gkeyChain.addFirst(onelabelGroupInfo.innerMostGroupDesc.appCookie());
            gkeyChain.addFirst(onelabelGroupInfo.nextGroupDesc.appCookie());
            gkeyChain.addFirst(l3vpngroupkey);
            // now we can replace the outerGrpDesc with the one we just created
            onelabelGroupInfo.nextGroupDesc = l3vpnGroupDesc;
            // we can't send the innermost group yet, as we have to create
            // the dependent ECMP group first. So we store ...
            unsentGroups.add(onelabelGroupInfo);
            log.debug("Trying L3VPN: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3vpngroupId), l3vpngroupkey, nextObj.id());
        } else {
            log.warn("Driver currently does not handle more than 1 MPLS " + "labels. Not processing nextObjective {}", nextObj.id());
            return;
        }
        // all groups in this chain
        allGroupKeys.add(gkeyChain);
    }
}
#end_block

#method_before
// ////////////////////////////////////
// Group Editing
// ////////////////////////////////////
protected void addBucketToGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("AddBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        return;
    }
    if (nextObjective.next().size() > 1) {
        log.warn("Only one bucket can be added at a time");
        return;
    }
    // first check to see if bucket being added is not a duplicate of an
    // existing bucket. If it is for an existing outport, then its a duplicate.
    Set<PortNumber> existingOutPorts = new HashSet<>();
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // get the last group for the outport
        Group glast = groupService.getGroup(deviceId, gkeys.peekLast());
        if (glast != null && !glast.buckets().buckets().isEmpty()) {
            PortNumber op = getOutPortFromTreatment(glast.buckets().buckets().get(0).treatment());
            if (op != null) {
                existingOutPorts.add(op);
            }
        }
    }
    // only a single bucket being added
    TrafficTreatment tt = nextObjective.next().iterator().next();
    PortNumber newport = getOutPortFromTreatment(tt);
    if (existingOutPorts.contains(newport)) {
        log.warn("Attempt to add bucket for existing outport:{} in dev:{} for next:{}", newport, deviceId, nextObjective.id());
        return;
    }
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group bucket to add
    // only one bucket, so only one group-chain
    GroupInfo gi = unsentGroups.get(0);
    TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
    ttb.group(new GroupId(gi.nextGroupDesc.givenGroupId()));
    GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
    // retrieve the original L3 ECMP group id and description from the first
    // element in any deque.
    GroupKey l3ecmpGroupKey = null;
    if (!allActiveKeys.isEmpty()) {
        l3ecmpGroupKey = allActiveKeys.get(0).peekFirst();
    } else {
        log.warn("Could not determine top level group while trying to" + "add bucket for port:{} in dev:{} for next:{}", deviceId, nextObjective.id(), newport);
        return;
    }
    Group l3ecmpGroup = groupService.getGroup(deviceId, l3ecmpGroupKey);
    if (l3ecmpGroup == null) {
        log.warn("Could not find l3 ecmp group while trying to add bucket" + "for port:{} in dev:{} for next:{}", deviceId, nextObjective.id(), newport);
        return;
    }
    int l3ecmpGroupId = l3ecmpGroup.id().id();
    // Although GroupDescriptions are not necessary for adding buckets to
    // existing groups, we still use one in the GroupChainElem. When the latter is
    // processed, the info will be extracted for the bucketAdd call to groupService
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(Collections.singletonList(sbucket)), l3ecmpGroupKey, l3ecmpGroupId, nextObjective.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, 1, true);
    // update original NextGroup with new bucket-chain
    // If active keys shows only the top-level group without a chain of groups,
    // then it represents an empty group. Update by replacing empty chain.
    Deque<GroupKey> newBucketChain = allGroupKeys.get(0);
    newBucketChain.addFirst(l3ecmpGroupKey);
    if (allActiveKeys.size() == 1 && allActiveKeys.get(0).size() == 1) {
        allActiveKeys.clear();
    }
    allActiveKeys.add(newBucketChain);
    updatePendingNextObjective(l3ecmpGroupKey, new OfdpaNextGroup(allActiveKeys, nextObjective));
    log.debug("Adding to L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObjective.id());
    // send the innermost group
    log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerMostGroupDesc.givenGroupId()), deviceId);
    updatePendingGroups(gi.nextGroupDesc.appCookie(), l3ecmpGce);
    groupService.addGroup(gi.innerMostGroupDesc);
}
#method_after
// ////////////////////////////////////
// Group Editing
// ////////////////////////////////////
protected void addBucketToGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("AddBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        return;
    }
    if (nextObjective.next().size() > 1) {
        log.warn("Only one bucket can be added at a time");
        return;
    }
    // first check to see if bucket being added is not a duplicate of an
    // existing bucket. If it is for an existing outport, then its a duplicate.
    Set<PortNumber> existingOutPorts = new HashSet<>();
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // get the last group for the outport
        Group glast = groupService.getGroup(deviceId, gkeys.peekLast());
        if (glast != null && !glast.buckets().buckets().isEmpty()) {
            PortNumber op = readOutPortFromTreatment(glast.buckets().buckets().get(0).treatment());
            if (op != null) {
                existingOutPorts.add(op);
            }
        }
    }
    // only a single bucket being added
    TrafficTreatment tt = nextObjective.next().iterator().next();
    PortNumber newport = readOutPortFromTreatment(tt);
    if (existingOutPorts.contains(newport)) {
        log.warn("Attempt to add bucket for existing outport:{} in dev:{} for next:{}", newport, deviceId, nextObjective.id());
        return;
    }
    // storage for all group keys in the chain of groups created
    List<Deque<GroupKey>> allGroupKeys = new ArrayList<>();
    List<GroupInfo> unsentGroups = new ArrayList<>();
    createHashBucketChains(nextObjective, allGroupKeys, unsentGroups);
    // now we can create the outermost L3 ECMP group bucket to add
    // only one bucket, so only one group-chain
    GroupInfo gi = unsentGroups.get(0);
    TrafficTreatment.Builder ttb = DefaultTrafficTreatment.builder();
    ttb.group(new DefaultGroupId(gi.nextGroupDesc.givenGroupId()));
    GroupBucket sbucket = DefaultGroupBucket.createSelectGroupBucket(ttb.build());
    // retrieve the original L3 ECMP group id and description from the first
    // element in any deque.
    GroupKey l3ecmpGroupKey = null;
    if (!allActiveKeys.isEmpty()) {
        l3ecmpGroupKey = allActiveKeys.get(0).peekFirst();
    } else {
        log.warn("Could not determine top level group while trying to" + "add bucket for port:{} in dev:{} for next:{}", deviceId, nextObjective.id(), newport);
        return;
    }
    Group l3ecmpGroup = groupService.getGroup(deviceId, l3ecmpGroupKey);
    if (l3ecmpGroup == null) {
        log.warn("Could not find l3 ecmp group while trying to add bucket" + "for port:{} in dev:{} for next:{}", deviceId, nextObjective.id(), newport);
        return;
    }
    int l3ecmpGroupId = l3ecmpGroup.id().id();
    // Although GroupDescriptions are not necessary for adding buckets to
    // existing groups, we still use one in the GroupChainElem. When the latter is
    // processed, the info will be extracted for the bucketAdd call to groupService
    GroupDescription l3ecmpGroupDesc = new DefaultGroupDescription(deviceId, GroupDescription.Type.SELECT, new GroupBuckets(Collections.singletonList(sbucket)), l3ecmpGroupKey, l3ecmpGroupId, nextObjective.appId());
    GroupChainElem l3ecmpGce = new GroupChainElem(l3ecmpGroupDesc, 1, true);
    // update original NextGroup with new bucket-chain
    // If active keys shows only the top-level group without a chain of groups,
    // then it represents an empty group. Update by replacing empty chain.
    Deque<GroupKey> newBucketChain = allGroupKeys.get(0);
    newBucketChain.addFirst(l3ecmpGroupKey);
    if (allActiveKeys.size() == 1 && allActiveKeys.get(0).size() == 1) {
        allActiveKeys.clear();
    }
    allActiveKeys.add(newBucketChain);
    updatePendingNextObjective(l3ecmpGroupKey, new OfdpaNextGroup(allActiveKeys, nextObjective));
    log.debug("Adding to L3ECMP: device:{} gid:{} gkey:{} nextId:{}", deviceId, Integer.toHexString(l3ecmpGroupId), l3ecmpGroupKey, nextObjective.id());
    // send the innermost group
    log.debug("Sending innermost group {} in group chain on device {} ", Integer.toHexString(gi.innerMostGroupDesc.givenGroupId()), deviceId);
    updatePendingGroups(gi.nextGroupDesc.appCookie(), l3ecmpGce);
    groupService.addGroup(gi.innerMostGroupDesc);
}
#end_block

#method_before
protected void removeBucketFromGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("RemoveBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        return;
    }
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    // find the bucket to remove by noting the outport, and figuring out the
    // top-level group in the group-chain that indirectly references the port
    PortNumber portToRemove = getOutPortFromTreatment(treatment);
    if (portToRemove == null) {
        log.warn("next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", nextObjective.id(), deviceId);
        return;
    }
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    Deque<GroupKey> foundChain = null;
    int index = 0;
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // last group in group chain should have a single bucket pointing to port
        GroupKey groupWithPort = gkeys.peekLast();
        Group group = groupService.getGroup(deviceId, groupWithPort);
        if (group == null) {
            log.warn("Inconsistent group chain found when removing bucket" + "for next:{} in dev:{}", nextObjective.id(), deviceId);
            continue;
        }
        PortNumber pout = getOutPortFromTreatment(group.buckets().buckets().get(0).treatment());
        if (pout.equals(portToRemove)) {
            foundChain = gkeys;
            break;
        }
        index++;
    }
    if (foundChain != null) {
        // first groupkey is the one we want to modify
        GroupKey modGroupKey = foundChain.peekFirst();
        Group modGroup = groupService.getGroup(deviceId, modGroupKey);
        // second groupkey is the one we wish to remove the reference to
        GroupKey pointedGroupKey = null;
        int i = 0;
        for (GroupKey gk : foundChain) {
            if (i++ == 1) {
                pointedGroupKey = gk;
                break;
            }
        }
        Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
        GroupBucket bucket = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
        log.debug("Removing buckets from group id 0x{} pointing to group id 0x{}" + "for next id {} in device {}", Integer.toHexString(modGroup.id().id()), Integer.toHexString(pointedGroup.id().id()), nextObjective.id(), deviceId);
        groupService.removeBucketsFromGroup(deviceId, modGroupKey, removeBuckets, modGroupKey, nextObjective.appId());
        // retain an entry for the top level group which still exists.
        if (allActiveKeys.size() == 1) {
            ArrayDeque<GroupKey> top = new ArrayDeque<>();
            top.add(modGroupKey);
            allActiveKeys.add(top);
        }
        allActiveKeys.remove(index);
        flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allActiveKeys, nextObjective));
    } else {
        log.warn("Could not find appropriate group-chain for removing bucket" + " for next id {} in dev:{}", nextObjective.id(), deviceId);
    }
}
#method_after
protected void removeBucketFromGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("RemoveBuckets not applied to nextType:{} in dev:{} for next:{}", nextObjective.type(), deviceId, nextObjective.id());
        return;
    }
    Collection<TrafficTreatment> treatments = nextObjective.next();
    TrafficTreatment treatment = treatments.iterator().next();
    // find the bucket to remove by noting the outport, and figuring out the
    // top-level group in the group-chain that indirectly references the port
    PortNumber portToRemove = readOutPortFromTreatment(treatment);
    if (portToRemove == null) {
        log.warn("next objective {} has no outport.. cannot remove bucket" + "from group in dev: {}", nextObjective.id(), deviceId);
        return;
    }
    List<Deque<GroupKey>> allActiveKeys = Ofdpa2Pipeline.appKryo.deserialize(next.data());
    Deque<GroupKey> foundChain = null;
    int index = 0;
    for (Deque<GroupKey> gkeys : allActiveKeys) {
        // last group in group chain should have a single bucket pointing to port
        GroupKey groupWithPort = gkeys.peekLast();
        Group group = groupService.getGroup(deviceId, groupWithPort);
        if (group == null) {
            log.warn("Inconsistent group chain found when removing bucket" + "for next:{} in dev:{}", nextObjective.id(), deviceId);
            continue;
        }
        PortNumber pout = readOutPortFromTreatment(group.buckets().buckets().get(0).treatment());
        if (pout.equals(portToRemove)) {
            foundChain = gkeys;
            break;
        }
        index++;
    }
    if (foundChain != null) {
        // first groupkey is the one we want to modify
        GroupKey modGroupKey = foundChain.peekFirst();
        Group modGroup = groupService.getGroup(deviceId, modGroupKey);
        // second groupkey is the one we wish to remove the reference to
        GroupKey pointedGroupKey = null;
        int i = 0;
        for (GroupKey gk : foundChain) {
            if (i++ == 1) {
                pointedGroupKey = gk;
                break;
            }
        }
        Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
        GroupBucket bucket = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.builder().group(pointedGroup.id()).build());
        GroupBuckets removeBuckets = new GroupBuckets(Collections.singletonList(bucket));
        log.debug("Removing buckets from group id 0x{} pointing to group id 0x{}" + "for next id {} in device {}", Integer.toHexString(modGroup.id().id()), Integer.toHexString(pointedGroup.id().id()), nextObjective.id(), deviceId);
        groupService.removeBucketsFromGroup(deviceId, modGroupKey, removeBuckets, modGroupKey, nextObjective.appId());
        // retain an entry for the top level group which still exists.
        if (allActiveKeys.size() == 1) {
            ArrayDeque<GroupKey> top = new ArrayDeque<>();
            top.add(modGroupKey);
            allActiveKeys.add(top);
        }
        allActiveKeys.remove(index);
        flowObjectiveStore.putNextGroup(nextObjective.id(), new OfdpaNextGroup(allActiveKeys, nextObjective));
    } else {
        log.warn("Could not find appropriate group-chain for removing bucket" + " for next id {} in dev:{}", nextObjective.id(), deviceId);
    }
}
#end_block

#method_before
public void portDown(PortNumber port, boolean isMaster) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    MacAddress dstMac;
    try {
        dstMac = deviceConfig.getDeviceMac(portDeviceMap.get(port));
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting portDown.");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    /*Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap
                                                                                .get(port),
                                                                        devicePortMap
                                                                                .keySet());*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(portDeviceMap.get(port)))).collect(Collectors.toSet());
    log.debug("portDown: nsNextObjStore contents for device {}:{}", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        NeighborSetNextObjectiveStoreKey nsStoreKey = new NeighborSetNextObjectiveStoreKey(deviceId, ns);
        Integer nextId = nsNextObjStore.get(nsStoreKey);
        if (nextId != null && isMaster) {
            log.info("**portDown in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
            // Create the bucket to be removed
            TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
            tBuilder.setOutput(port).setEthDst(dstMac).setEthSrc(nodeMacAddr);
            if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
            }
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(// same as original
            NextObjective.Type.HASHED).withId(nextId).fromApp(appId).addTreatment(tBuilder.build());
            ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("portDown removedFrom NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("LinkUp failed to removeFrom NextObj {} on {}: {}", nextId, deviceId, error));
            NextObjective nextObjective = nextObjBuilder.removeFromExisting(context);
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#method_after
public void portDown(PortNumber port, boolean isMaster) {
    if (portDeviceMap.get(port) == null) {
        log.warn("portDown: unknown port");
        return;
    }
    MacAddress dstMac;
    try {
        dstMac = deviceConfig.getDeviceMac(portDeviceMap.get(port));
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting portDown.");
        return;
    }
    log.debug("Device {} portDown {} to neighbor {}", deviceId, port, portDeviceMap.get(port));
    /*Set<NeighborSet> nsSet = computeImpactedNeighborsetForPortEvent(portDeviceMap
                                                                                .get(port),
                                                                        devicePortMap
                                                                                .keySet());*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(portDeviceMap.get(port)))).collect(Collectors.toSet());
    log.debug("portDown: nsNextObjStore contents for device {}:{}", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        NeighborSetNextObjectiveStoreKey nsStoreKey = new NeighborSetNextObjectiveStoreKey(deviceId, ns);
        Integer nextId = nsNextObjStore.get(nsStoreKey);
        if (nextId != null && isMaster) {
            log.info("**portDown in device {}: Removing Bucket " + "with Port {} to next object id {}", deviceId, port, nextId);
            // Create the bucket to be removed
            TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
            tBuilder.setOutput(port).setEthDst(dstMac).setEthSrc(nodeMacAddr);
            if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
            }
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withType(// same as original
            NextObjective.Type.HASHED).withId(nextId).fromApp(appId).addTreatment(tBuilder.build());
            ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("portDown removedFrom NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("portDown failed to removeFrom NextObj {} on {}: {}", nextId, deviceId, error));
            NextObjective nextObjective = nextObjBuilder.removeFromExisting(context);
            flowObjectiveService.next(deviceId, nextObjective);
        }
    }
    devicePortMap.get(portDeviceMap.get(port)).remove(port);
    portDeviceMap.remove(port);
}
#end_block

#method_before
@Override
protected void execute() {
}
#method_after
@Override
protected void execute() {
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(APP_ID);
    VplsConfig config = configService.getConfig(appId, VplsConfig.class);
    if (config == null) {
        print("No VPLS configured");
        return;
    }
    List<VplsConfig.VplsNetworkConfig> vplsNetworks = Lists.newArrayList(config.vplsNetworks());
    if (config.vplsNetworks().isEmpty()) {
        print("No VPLS configured");
    } else {
        if (vplsName != null) {
            vplsNetworks.forEach(s -> {
                if (s.name().get().equals(vplsName)) {
                    print(NAME_FORMAT, s.name().get(), s.vInterfaces());
                }
            });
        } else {
            vplsNetworks.forEach(s -> {
                if (s.name().isPresent()) {
                    print(NAME_FORMAT, s.name().get(), s.vInterfaces());
                } else {
                    print(FORMAT, s.vInterfaces());
                }
            });
        }
    }
}
#end_block

#method_before
@Override
protected void execute() {
}
#method_after
@Override
protected void execute() {
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(APP_ID);
    VplsConfig config = configService.addConfig(appId, VplsConfig.class);
    if (vplsName != null) {
        VplsConfig.VplsNetworkConfig vplsConfig = config.getNetworkWithName(vplsName);
        if (vplsConfig != null) {
            log.info("VPLS already exists: {}", vplsName);
            return;
        }
    }
    addVplsToConf(config);
    configService.applyConfig(appId, VplsConfig.class, config.node());
    print(VPLS_ADD_SUCCESS);
}
#end_block

#method_before
@Override
protected void execute() {
}
#method_after
@Override
protected void execute() {
    NetworkConfigService configService = get(NetworkConfigService.class);
    CoreService coreService = get(CoreService.class);
    ApplicationId appId = coreService.getAppId(APP_ID);
    VplsConfig config = configService.getConfig(appId, VplsConfig.class);
    if (config == null) {
        print("No VPLS configured");
        return;
    }
    List<VplsConfig.VplsNetworkConfig> vplsNetworks = Lists.newArrayList(config.vplsNetworks());
    if (config.vplsNetworks().isEmpty()) {
        print("No VPLS configured");
    } else {
        vplsNetworks.forEach(s -> {
            if (s.name().isPresent()) {
                print("%s", s.name().get());
            } else {
                print("not defined networks yet");
            }
        });
    }
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String id = string(payload, ID);
    int intId = Integer.parseInt(id);
    FlowRuleService fs = get(FlowRuleService.class);
    Iterable<FlowRule> flows;
    flows = fs.getFlowRulesById(new DefaultApplicationId(intId, "details"));
    ObjectNode data = objectNode();
    for (FlowRule flow : flows) {
        data.put("id", flow.id().toString());
        data.put("priority", flow.priority());
    // TODO put more detail info to data
    }
    ObjectNode rootNode = objectNode();
    rootNode.set(DETAILS, data);
    sendMessage(FLOW_DETAILS_RESP, 0, rootNode);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String flowId = string(payload, FLOW_ID);
    String appId = string(payload, APP_ID);
    FlowRule flow = findFlowById(appId, flowId);
    ObjectNode data = objectNode();
    data.put(FLOW_ID, flow.id().toString());
    data.put(FLOW_PRIORITY, flow.priority());
    // TODO put more detail info to data
    ObjectNode rootNode = objectNode();
    rootNode.set(DETAILS, data);
    sendMessage(FLOW_DETAILS_RESP, rootNode);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(Vpls.VPLS_APP);
    interfaceService.addListener(interfaceListener);
    configService.addListener(configListener);
    interfaceService.getInterfaces().forEach(intf -> {
        neighbourHandlers.put(intf, neighbourHandler);
        neighbourService.registerNeighbourHandler(intf, neighbourHandler, appId);
    });
    log.debug("Activated");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(Vpls.VPLS_APP);
    interfaceService.addListener(interfaceListener);
    configService.addListener(configListener);
    configNeighbourHandler();
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    interfaceService.removeListener(interfaceListener);
    configService.removeListener(configListener);
    neighbourHandlers.entrySet().forEach(e -> {
        neighbourService.unregisterNeighbourHandler(e.getKey(), e.getValue(), appId);
    });
    log.debug("Deactivated");
}
#method_after
@Deactivate
protected void deactivate() {
    interfaceService.removeListener(interfaceListener);
    configService.removeListener(configListener);
    neighbourService.unregisterNeighbourHandlers(appId);
}
#end_block

#method_before
private void configNeighbourHandler(Interface intf, NeighbourMessageHandler handler, InterfaceEvent.Type eventType) {
    switch(eventType) {
        case INTERFACE_ADDED:
            neighbourHandlers.put(intf, handler);
            neighbourService.registerNeighbourHandler(intf, handler, appId);
            break;
        case INTERFACE_REMOVED:
            neighbourHandlers.remove(intf, handler);
            neighbourService.unregisterNeighbourHandler(intf, handler, appId);
            break;
        case INTERFACE_UPDATED:
            break;
        default:
            break;
    }
}
#method_after
private void configNeighbourHandler() {
    neighbourService.unregisterNeighbourHandlers(appId);
    Set<Interface> interfaces = vplsConfigService.getAllInterfaces();
    interfaceService.getInterfaces().stream().filter(interfaces::contains).forEach(intf -> {
        neighbourService.registerNeighbourHandler(intf, neighbourHandler, appId);
    });
}
#end_block

#method_before
@Override
public void handleMessage(NeighbourMessageContext context, HostService hostService) {
    switch(context.type()) {
        case REQUEST:
            handleRequest(context, vplsConfig);
            break;
        case REPLY:
            handleReply(context, vplsConfig, hostService);
            break;
        default:
            log.warn("Unknown context type: {}", context.type());
            break;
    }
}
#method_after
@Override
public void handleMessage(NeighbourMessageContext context, HostService hostService) {
    switch(context.type()) {
        case REQUEST:
            handleRequest(context);
            break;
        case REPLY:
            handleReply(context, hostService);
            break;
        default:
            log.warn(UNKNOWN_CONTEXT, context.type());
            break;
    }
}
#end_block

#method_before
protected void handleRequest(NeighbourMessageContext context, VplsConfig vplsConfig) {
    Optional<VplsConfig.VplsNetworkConfig> vplsNetwork = getVplsNetwork(context.vlan(), context.inPort(), vplsConfig);
    if (vplsNetwork.isPresent()) {
        Set<Interface> vplsNetworkInfaces = vplsNetwork.get().ifaces();
        // FIXME: proxy doesn't convert it's vlanId for interface
        vplsNetworkInfaces.forEach(context::proxy);
    } else {
        log.debug("Can't find VPLS network");
    }
}
#method_after
protected void handleRequest(NeighbourMessageContext context) {
    SetMultimap<String, Interface> vplsNetwork = vplsConfigService.getVplsNetwork(context.vlan(), context.inPort());
    if (vplsNetwork != null) {
        Collection<Interface> vplsInterfaces = vplsNetwork.values();
        vplsInterfaces.stream().filter(intf -> !context.inPort().equals(intf.connectPoint())).forEach(context::forward);
    } else {
        log.debug(CAN_NOT_FIND_NETWORK, context.inPort(), context.vlan());
    }
}
#end_block

#method_before
protected void handleReply(NeighbourMessageContext context, VplsConfig vplsConfig, HostService hostService) {
    Optional<VplsConfig.VplsNetworkConfig> vplsNetwork = getVplsNetwork(context.vlan(), context.inPort(), vplsConfig);
    Set<Host> hosts = hostService.getHostsByMac(context.dstMac());
    if (vplsNetwork.isPresent()) {
        vplsNetwork.get().ifaces().forEach(iface -> {
            hosts.stream().filter(host -> host.vlan().equals(iface.vlan())).map(Host::location).forEach(context::proxy);
        // FIXME: proxy doesn't convert it's vlanId for interface
        });
    } else {
        log.debug("Can't find VPLS network");
    }
}
#method_after
protected void handleReply(NeighbourMessageContext context, HostService hostService) {
    SetMultimap<String, Interface> vplsNetwork = vplsConfigService.getVplsNetwork(context.vlan(), context.inPort());
    Set<Host> hosts = hostService.getHostsByMac(context.dstMac());
    if (vplsNetwork != null) {
        Collection<Interface> vplsInterfaces = vplsNetwork.values();
        hosts.forEach(host -> vplsInterfaces.stream().filter(intf -> intf.connectPoint().equals(host.location())).filter(intf -> intf.vlan().equals(host.vlan())).forEach(context::forward));
    } else {
        log.debug(CAN_NOT_FIND_NETWORK, context.inPort(), context.vlan());
    }
}
#end_block

#method_before
@Override
public void event(InterfaceEvent event) {
    configNeighbourHandler(event.subject(), neighbourHandler, event.type());
}
#method_after
@Override
public void event(InterfaceEvent event) {
    configNeighbourHandler();
}
#end_block

#method_before
public Set<VplsNetworkConfig> vplsNetworks() {
    Set<VplsNetworkConfig> networks = Sets.newHashSet();
    JsonNode networksNode = object.get(NETWORKS);
    if (networksNode == null) {
        return networks;
    }
    networksNode.forEach(jsonNode -> {
        Set<String> vInterfaces = Sets.newHashSet();
        jsonNode.path(INTERFACE).forEach(vInterfacesNode -> vInterfaces.add(vInterfacesNode.asText()));
        Optional<String> name;
        if (jsonNode.get(NAME) == null) {
            name = Optional.empty();
        } else {
            name = Optional.of(jsonNode.get(NAME).asText());
        }
        networks.add(new VplsNetworkConfig(name, vInterfaces));
    });
    return networks;
}
#method_after
public Set<VplsNetworkConfig> vplsNetworks() {
    Set<VplsNetworkConfig> vpls = Sets.newHashSet();
    JsonNode vplsNode = object.get(VPLS);
    if (vplsNode == null) {
        return vpls;
    }
    vplsNode.forEach(jsonNode -> {
        Set<String> ifaces = Sets.newHashSet();
        jsonNode.path(INTERFACE).forEach(ifacesNode -> ifaces.add(ifacesNode.asText()));
        String name = jsonNode.get(NAME).asText();
        vpls.add(new VplsNetworkConfig(name, ifaces));
    });
    return vpls;
}
#end_block

#method_before
private ArrayNode initVplsConfiguration() {
    return object.putArray(NETWORKS);
}
#method_after
private ArrayNode initVplsConfiguration() {
    return object.putArray(VPLS);
}
#end_block

#method_before
public Optional<String> name() {
    return name;
}
#method_after
public String name() {
    return name;
}
#end_block

#method_before
public boolean isAttached(String vInterface) {
    for (final String entry : vInterfaces()) {
        if (entry.equals(vInterface)) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean isAttached(String iface) {
    for (final String entry : ifaces()) {
        if (entry.equals(iface)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof VplsConfig.VplsNetworkConfig) {
        final VplsConfig.VplsNetworkConfig that = (VplsConfig.VplsNetworkConfig) obj;
        return Objects.equals(this.name, that.name) && Objects.equals(this.vInterfaces, that.vInterfaces);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof VplsConfig.VplsNetworkConfig) {
        final VplsConfig.VplsNetworkConfig that = (VplsConfig.VplsNetworkConfig) obj;
        return Objects.equals(this.name, that.name) && Objects.equals(this.ifaces, that.ifaces);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(name, vInterfaces);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(name, ifaces);
}
#end_block

#method_before
@Test
public void testVplsNetworks() throws Exception {
    assertEquals(networks, vplsConfig.vplsNetworks());
}
#method_after
@Test
public void testVplsNetworks() {
    assertEquals(networks, vplsConfig.vplsNetworks());
}
#end_block

#method_before
@Test
public void testEmptyVplsNetworks() throws Exception {
    assertTrue(emptyVplsConfig.vplsNetworks().isEmpty());
}
#method_after
@Test
public void testEmptyVplsNetworks() {
    assertTrue(emptyVplsConfig.vplsNetworks().isEmpty());
}
#end_block

#method_before
@Test
public void testAddNetwork() throws Exception {
    int initialSize = vplsConfig.vplsNetworks().size();
    VplsConfig.VplsNetworkConfig newNetwork = createNewNetwork();
    vplsConfig.addNetwork(newNetwork);
    assertEquals(initialSize + 1, vplsConfig.vplsNetworks().size());
    networks.add(newNetwork);
    assertEquals(networks, vplsConfig.vplsNetworks());
}
#method_after
@Test
public void testAddNetwork() {
    int initialSize = vplsConfig.vplsNetworks().size();
    VplsConfig.VplsNetworkConfig newNetwork = createNewNetwork();
    vplsConfig.addVpls(newNetwork);
    assertEquals(initialSize + 1, vplsConfig.vplsNetworks().size());
    networks.add(newNetwork);
    assertEquals(networks, vplsConfig.vplsNetworks());
}
#end_block

#method_before
@Test
public void testAddNetworkToEmpty() throws Exception {
    VplsConfig.VplsNetworkConfig newNetwork = createNewNetwork();
    emptyVplsConfig.addNetwork(newNetwork);
    assertFalse(emptyVplsConfig.vplsNetworks().isEmpty());
}
#method_after
@Test
public void testAddNetworkToEmpty() {
    VplsConfig.VplsNetworkConfig newNetwork = createNewNetwork();
    emptyVplsConfig.addVpls(newNetwork);
    assertFalse(emptyVplsConfig.vplsNetworks().isEmpty());
}
#end_block

#method_before
@Test
public void testRemoveExistingNetwork() throws Exception {
    int initialSize = vplsConfig.vplsNetworks().size();
    vplsConfig.removeNetwork("net1");
    assertEquals(initialSize - 1, vplsConfig.vplsNetworks().size());
}
#method_after
@Test
public void testRemoveExistingNetwork() {
    int initialSize = vplsConfig.vplsNetworks().size();
    vplsConfig.removeVpls("net1");
    assertEquals(initialSize - 1, vplsConfig.vplsNetworks().size());
}
#end_block

#method_before
@Test
public void testRemoveInexistingNetwork() throws Exception {
    int initialSize = vplsConfig.vplsNetworks().size();
    vplsConfig.removeNetwork("net2");
    assertEquals(initialSize, vplsConfig.vplsNetworks().size());
}
#method_after
@Test
public void testRemoveInexistingNetwork() {
    int initialSize = vplsConfig.vplsNetworks().size();
    vplsConfig.removeVpls("net2");
    assertEquals(initialSize, vplsConfig.vplsNetworks().size());
}
#end_block

#method_before
@Test
public void testAddInterfaceToNetwork() throws Exception {
    int initialSize = vplsConfig.getNetworkWithName("net1").vInterfaces().size();
    vplsConfig.addInterfaceToNetwork("net1", IF4);
    assertEquals(initialSize + 1, vplsConfig.getNetworkWithName("net1").vInterfaces().size());
}
#method_after
@Test
public void testAddInterfaceToNetwork() {
    int initialSize = vplsConfig.getVplsWithName("net1").ifaces().size();
    vplsConfig.addInterfaceToVpls("net1", IF4);
    assertEquals(initialSize + 1, vplsConfig.getVplsWithName("net1").ifaces().size());
}
#end_block

#method_before
@Test
public void testAddExistingInterfaceToNetwork() throws Exception {
    int initialSize = vplsConfig.getNetworkWithName("net1").vInterfaces().size();
    vplsConfig.addInterfaceToNetwork("net1", IF1);
    assertEquals(initialSize, vplsConfig.getNetworkWithName("net1").vInterfaces().size());
}
#method_after
@Test
public void testAddExistingInterfaceToNetwork() {
    int initialSize = vplsConfig.getVplsWithName("net1").ifaces().size();
    vplsConfig.addInterfaceToVpls("net1", IF1);
    assertEquals(initialSize, vplsConfig.getVplsWithName("net1").ifaces().size());
}
#end_block

#method_before
@Test
public void testgetNetworkFromInterface() throws Exception {
    assertNotNull(vplsConfig.getNetworkFromInterface(IF1));
    assertNull(vplsConfig.getNetworkFromInterface(IF_NON_EXIST));
}
#method_after
@Test
public void testgetNetworkFromInterface() {
    assertNotNull(vplsConfig.getVplsFromInterface(IF1));
    assertNull(vplsConfig.getVplsFromInterface(IF_NON_EXIST));
}
#end_block

#method_before
@Test
public void testRemoveExistingInterfaceFromNetwork() throws Exception {
    int initialSize = vplsConfig.getNetworkWithName("net1").vInterfaces().size();
    vplsConfig.removevInterfaceFromNetwork(initialNetwork, IF1);
    assertEquals(initialSize - 1, vplsConfig.getNetworkWithName("net1").vInterfaces().size());
}
#method_after
@Test
public void testRemoveExistingInterfaceFromNetwork() {
    int initialSize = vplsConfig.getVplsWithName("net1").ifaces().size();
    vplsConfig.removeInterfaceFromVpls(initialNetwork, IF1);
    assertEquals(initialSize - 1, vplsConfig.getVplsWithName("net1").ifaces().size());
}
#end_block

#method_before
@Test
public void testRemoveNonExistingInterfaceFromNetwork() throws Exception {
    int initialSize = vplsConfig.getNetworkWithName("net1").vInterfaces().size();
    vplsConfig.removevInterfaceFromNetwork(initialNetwork, IF_NON_EXIST);
    assertEquals(initialSize, vplsConfig.getNetworkWithName("net1").vInterfaces().size());
}
#method_after
@Test
public void testRemoveNonExistingInterfaceFromNetwork() {
    int initialSize = vplsConfig.getVplsWithName("net1").ifaces().size();
    vplsConfig.removeInterfaceFromVpls(initialNetwork, IF_NON_EXIST);
    assertEquals(initialSize, vplsConfig.getVplsWithName("net1").ifaces().size());
}
#end_block

#method_before
private VplsConfig.VplsNetworkConfig createInitialNetwork() {
    Optional<String> networkName = Optional.of("net1");
    Set<String> vInterfaces = new HashSet<>(Arrays.asList(IF1, IF2, IF3));
    return new VplsConfig.VplsNetworkConfig(networkName, vInterfaces);
}
#method_after
private VplsConfig.VplsNetworkConfig createInitialNetwork() {
    String networkName = "net1";
    Set<String> ifaces = new HashSet<>(Arrays.asList(IF1, IF2, IF3));
    return new VplsConfig.VplsNetworkConfig(networkName, ifaces);
}
#end_block

#method_before
private VplsConfig.VplsNetworkConfig createNewNetwork() {
    Optional<String> networkName = Optional.of("newnet");
    Set<String> vInterfaces = new HashSet<>(Arrays.asList(IF4, IF5));
    return new VplsConfig.VplsNetworkConfig(networkName, vInterfaces);
}
#method_after
private VplsConfig.VplsNetworkConfig createNewNetwork() {
    String networkName = "newnet";
    Set<String> ifaces = new HashSet<>(Arrays.asList(IF4, IF5));
    return new VplsConfig.VplsNetworkConfig(networkName, ifaces);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + Objects.hashCode(value);
    return result;
}
#method_after
@Override
public int hashCode() {
    return value.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Name other = (Name) obj;
    if (!Objects.equals(value, other.value)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Name other = (Name) obj;
    return Objects.equals(value, other.value);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + Objects.hashCode(value);
    return result;
}
#method_after
@Override
public int hashCode() {
    return value.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Uuid other = (Uuid) obj;
    if (!Objects.equals(value, other.value)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Uuid other = (Uuid) obj;
    return Objects.equals(value, other.value);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + Objects.hashCode(value);
    return result;
}
#method_after
@Override
public int hashCode() {
    return value.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Description other = (Description) obj;
    if (!Objects.equals(value, other.value)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Description other = (Description) obj;
    return Objects.equals(value, other.value);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder(Description.class.getSimpleName()).append(" [");
    boolean first = true;
    if (value != null) {
        if (first) {
            first = false;
        } else {
            builder.append(", ");
        }
        builder.append("value=");
        builder.append(value);
    }
    return builder.append(']').toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("value", value).toString();
}
#end_block

#method_before
private static void checkvalueLength(final String value) {
    final int length = value.length();
    if (length >= 1 && length <= 4096) {
        return;
    }
    throw new IllegalArgumentException(String.format("Invalid length: %s, expected: [[1‥4096]].", value));
}
#method_after
private static void checkvalueLength(String value) {
    int length = value.length();
    if (length < MIN_LENGTH || length > MAX_LENGTH) {
        throw new IllegalArgumentException(String.format(E_BAD_LENGTH, length));
    }
}
#end_block

#method_before
@Override
public void run() {
    long elapsedTimeMillis = stopwatch.elapsed(TimeUnit.MILLISECONDS);
    if (elapsedTimeMillis > maxProcessMillis) {
        stopwatch.reset();
        log.warn("Event sink {} exceeded execution time limit: {} ms; spawning new dispatch loop", lastSink.getClass().getName(), elapsedTimeMillis);
        // Notify the sink that it has exceeded its time limit.
        lastSink.onProcessLimit();
        // Cancel the old dispatch loop and submit a new one.
        stop();
        dispatchFuture.cancel(true);
        dispatchFuture = executor.submit(this);
    }
}
#method_after
@Override
public void run() {
    long elapsedTimeMillis = stopwatch.elapsed(TimeUnit.MILLISECONDS);
    if (elapsedTimeMillis > maxProcessMillis) {
        stopwatch.reset();
        log.warn("Event sink {} exceeded execution time limit: {} ms; " + "spawning new dispatch loop", lastSink.getClass().getName(), elapsedTimeMillis);
        // Notify the sink that it has exceeded its time limit.
        lastSink.onProcessLimit();
        // Cancel the old dispatch loop and submit a new one.
        stop();
        dispatchFuture.cancel(true);
        dispatchFuture = executor.submit(this);
    }
}
#end_block

#method_before
private void startWatchdog() {
    log.info("Starting watchdog task");
    watchdog = new Watchdog();
    SharedExecutors.getTimer().schedule(watchdog, WATCHDOG_MS, WATCHDOG_MS);
}
#method_after
private void startWatchdog() {
    log.info("Starting watchdog task for dispatcher {}", name);
    watchdog = new Watchdog();
    SharedExecutors.getTimer().schedule(watchdog, WATCHDOG_MS, WATCHDOG_MS);
}
#end_block

#method_before
private void stopWatchdog() {
    log.info("Stopping watchdog task");
    if (watchdog != null) {
        watchdog.cancel();
    }
}
#method_after
private void stopWatchdog() {
    log.info("Stopping watchdog task for dispatcher {}", name);
    if (watchdog != null) {
        watchdog.cancel();
    }
}
#end_block

#method_before
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode refNode = entityToResolveInfo.getHolderOfEntityToResolve();
    YangDerivedInfo info = getValidResolvableType();
    if (info == null) {
        return;
    }
    YangType<T> type = (YangType<T>) entityToResolveInfo.getEntityToResolve();
    T extType = (T) info.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extType instanceof YangDerivedInfo) {
        info = (YangDerivedInfo) extType;
        extType = (T) info.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /**
     * Backup the leaf-ref info from derived type and deletes the derived
     * type info. Copies the backed up leaf-ref data to the actual type in
     * replacement of derived type. Adds to the resolution list in this
     * context.
     */
    addRefTypeInfo(extType, type, refNode);
}
#method_after
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode refNode = entityToResolveInfo.getHolderOfEntityToResolve();
    YangDerivedInfo info = getValidResolvableType();
    if (info == null) {
        return;
    }
    YangType<T> type = (YangType<T>) entityToResolveInfo.getEntityToResolve();
    T extType = (T) info.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extType instanceof YangDerivedInfo) {
        info = (YangDerivedInfo) extType;
        extType = (T) info.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /*
         * Backup the leaf-ref info from derived type and deletes the derived
         * type info. Copies the backed up leaf-ref data to the actual type in
         * replacement of derived type. Adds to the resolution list in this
         * context.
         */
    addRefTypeInfo(extType, type, refNode);
}
#end_block

#method_before
private void addRefTypeInfo(T extType, YangType<T> type, YangNode holder) throws DataModelException {
    type.resetYangType();
    type.setResolvableStatus(RESOLVED);
    type.setDataType(YangDataTypes.LEAFREF);
    type.setDataTypeName(LEAFREF);
    type.setDataTypeExtendedInfo(extType);
    YangLeafRef leafRef = (YangLeafRef) extType;
    (leafRef).setResolvableStatus(UNRESOLVED);
    leafRef.setParentNodeOfLeafref(holder);
    YangResolutionInfoImpl info = new YangResolutionInfoImpl<>(leafRef, holder, getLineNumber(), getCharPosition());
    curRefResolver.addToResolutionList(info, YANG_LEAFREF);
    curRefResolver.resolveSelfFileLinking(YANG_LEAFREF);
}
#method_after
private void addRefTypeInfo(T extType, YangType<T> type, YangNode holder) throws DataModelException {
    type.resetYangType();
    type.setResolvableStatus(RESOLVED);
    type.setDataType(YangDataTypes.LEAFREF);
    type.setDataTypeName(LEAFREF);
    type.setDataTypeExtendedInfo(extType);
    YangLeafRef leafRef = (YangLeafRef) extType;
    (leafRef).setResolvableStatus(UNRESOLVED);
    leafRef.setParentNode(holder);
    YangResolutionInfoImpl info = new YangResolutionInfoImpl<>(leafRef, holder, getLineNumber(), getCharPosition());
    curRefResolver.addToResolutionList(info, YANG_LEAFREF);
    curRefResolver.resolveSelfFileLinking(YANG_LEAFREF);
}
#end_block

#method_before
private void addUnresolvedEntitiesToResolutionList(T entityToResolve) throws DataModelException {
    if (entityToResolve instanceof YangEntityToResolveInfoImpl) {
        YangEntityToResolveInfoImpl entityToResolveInfo = (YangEntityToResolveInfoImpl) entityToResolve;
        if (entityToResolveInfo.getEntityToResolve() instanceof YangLeafRef) {
            YangLeafRef leafref = (YangLeafRef) entityToResolveInfo.getEntityToResolve();
            YangNode parentNodeOfLeafref = entityToResolveInfo.getHolderOfEntityToResolve();
            leafref.setParentNodeOfLeafref(parentNodeOfLeafref);
            if (leafref.getResolvableStatus() == UNRESOLVED) {
                leafref.setResolvableStatus(INTRA_FILE_RESOLVED);
            }
        }
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(entityToResolveInfo.getEntityToResolve(), entityToResolveInfo.getHolderOfEntityToResolve(), entityToResolveInfo.getLineNumber(), entityToResolveInfo.getCharPosition());
        addResolutionInfo(resolutionInfoImpl);
    }
}
#method_after
private void addUnresolvedEntitiesToResolutionList(T entityToResolve) throws DataModelException {
    if (entityToResolve instanceof YangEntityToResolveInfoImpl) {
        YangEntityToResolveInfoImpl entityToResolveInfo = (YangEntityToResolveInfoImpl) entityToResolve;
        if (entityToResolveInfo.getEntityToResolve() instanceof YangLeafRef) {
            YangLeafRef leafref = (YangLeafRef) entityToResolveInfo.getEntityToResolve();
            YangNode parentNodeOfLeafref = entityToResolveInfo.getHolderOfEntityToResolve();
            leafref.setParentNode(parentNodeOfLeafref);
            if (leafref.getResolvableStatus() == UNRESOLVED) {
                leafref.setResolvableStatus(INTRA_FILE_RESOLVED);
            }
        }
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(entityToResolveInfo.getEntityToResolve(), entityToResolveInfo.getHolderOfEntityToResolve(), entityToResolveInfo.getLineNumber(), entityToResolveInfo.getCharPosition());
        addResolutionInfo(resolutionInfoImpl);
    }
}
#end_block

#method_before
private void setAbsolutePathFromRelativePathInLeafref(T resolutionInfo) throws DataModelException {
    if (resolutionInfo instanceof YangLeafRef) {
        YangNode leafParent = ((YangLeafRef) resolutionInfo).getParentNodeOfLeafref();
        YangLeafRef leafref = (YangLeafRef) resolutionInfo;
        // Checks if the leafref has relative path in it.
        if (leafref.getPathType() == RELATIVE_PATH) {
            YangRelativePath relativePath = leafref.getRelativePath();
            List<YangAtomicPath> absoluteInRelative = relativePath.getAtomicPathList();
            int ancestorCount = relativePath.getAncestorNodeCount();
            // Gets the root node from the ancestor count.
            T nodeOrAugmentList = getRootNodeWithAncestorCountForLeafref(ancestorCount, leafParent, leafref);
            if (nodeOrAugmentList instanceof YangNode) {
                StringBuilder name = new StringBuilder();
                StringBuilder prefix = new StringBuilder();
                YangNode rootNode = (YangNode) nodeOrAugmentList;
                // Forms a new absolute path from the relative path
                while (!(rootNode instanceof YangReferenceResolver)) {
                    name.append(rootNode.getName());
                    prefix.append(SLASH_FOR_STRING).append(name.reverse());
                    name.delete(0, name.length());
                    rootNode = rootNode.getParent();
                    if (rootNode == null) {
                        throw new DataModelException(INVALID_TREE);
                    }
                }
                prefix.reverse();
                fillAbsolutePathValuesInLeafref(leafref, prefix.toString(), absoluteInRelative);
            } else {
                List<String> listOfAugment = (List<String>) nodeOrAugmentList;
                Iterator<String> listOfAugmentIterator = listOfAugment.listIterator();
                StringBuilder augment = new StringBuilder(EMPTY_STRING);
                while (listOfAugmentIterator.hasNext()) {
                    augment.append(SLASH_FOR_STRING).append(listOfAugmentIterator.next());
                }
                fillAbsolutePathValuesInLeafref(leafref, augment.toString(), absoluteInRelative);
            }
        }
    }
}
#method_after
private void setAbsolutePathFromRelativePathInLeafref(T resolutionInfo) throws DataModelException {
    if (resolutionInfo instanceof YangLeafRef) {
        YangNode leafParent = ((YangLeafRef) resolutionInfo).getParentNode();
        YangLeafRef leafref = (YangLeafRef) resolutionInfo;
        // Checks if the leafref has relative path in it.
        if (leafref.getPathType() == RELATIVE_PATH) {
            YangRelativePath relativePath = leafref.getRelativePath();
            List<YangAtomicPath> absoluteInRelative = relativePath.getAtomicPathList();
            int ancestorCount = relativePath.getAncestorNodeCount();
            // Gets the root node from the ancestor count.
            T nodeOrAugmentList = getRootNodeWithAncestorCountForLeafref(ancestorCount, leafParent, leafref);
            if (nodeOrAugmentList instanceof YangNode) {
                StringBuilder name = new StringBuilder();
                StringBuilder prefix = new StringBuilder();
                YangNode rootNode = (YangNode) nodeOrAugmentList;
                // Forms a new absolute path from the relative path
                while (!(rootNode instanceof YangReferenceResolver)) {
                    name.append(rootNode.getName());
                    prefix.append(SLASH_FOR_STRING).append(name.reverse());
                    name.delete(0, name.length());
                    rootNode = rootNode.getParent();
                    if (rootNode == null) {
                        throw new DataModelException(INVALID_TREE);
                    }
                }
                prefix.reverse();
                fillAbsolutePathValuesInLeafref(leafref, prefix.toString(), absoluteInRelative);
            } else {
                List<String> listOfAugment = (List<String>) nodeOrAugmentList;
                Iterator<String> listOfAugmentIterator = listOfAugment.listIterator();
                StringBuilder augment = new StringBuilder(EMPTY_STRING);
                while (listOfAugmentIterator.hasNext()) {
                    augment.append(SLASH_FOR_STRING).append(listOfAugmentIterator.next());
                }
                fillAbsolutePathValuesInLeafref(leafref, augment.toString(), absoluteInRelative);
            }
        }
    }
}
#end_block

#method_before
public static void cloneListOfLeaf(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeaf> leaves = clonedNode.getListOfLeaf();
    if (isListPresent(leaves)) {
        List<YangLeaf> clonedLeaves = new LinkedList<>();
        for (YangLeaf leaf : leaves) {
            YangLeaf clonedLeaf = leaf.clone();
            clonedLeaf.setReferredLeaf(leaf);
            addUnresolvedType(yangUses, clonedLeaf, (YangNode) clonedNode);
            clonedLeaf.setContainedIn(clonedNode);
            clonedLeaves.add(clonedLeaf);
        }
        clonedNode.setListOfLeaf(clonedLeaves);
    }
}
#method_after
public static void cloneListOfLeaf(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeaf> leaves = clonedNode.getListOfLeaf();
    if (nonEmpty(leaves)) {
        List<YangLeaf> clonedLeaves = new LinkedList<>();
        for (YangLeaf leaf : leaves) {
            YangLeaf clonedLeaf = leaf.clone();
            clonedLeaf.setReferredLeaf(leaf);
            addUnresolvedType(yangUses, clonedLeaf, (YangNode) clonedNode);
            clonedLeaf.setContainedIn(clonedNode);
            clonedLeaves.add(clonedLeaf);
        }
        clonedNode.setListOfLeaf(clonedLeaves);
    }
}
#end_block

#method_before
public static void addUnresolvedType(YangUses yangUses, Object clonedObj, YangNode clonedNode) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList;
    if (yangUses != null && yangUses.getCurrentGroupingDepth() == 0) {
        infoList = getTypesToBeResolved(clonedObj, clonedNode, yangUses);
        if (isListPresent(infoList)) {
            yangUses.addEntityToResolve(infoList);
        }
    }
}
#method_after
public static void addUnresolvedType(YangUses yangUses, Object clonedObj, YangNode clonedNode) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList;
    if (yangUses != null && yangUses.getCurrentGroupingDepth() == 0) {
        infoList = getTypesToBeResolved(clonedObj, clonedNode, yangUses);
        if (nonEmpty(infoList)) {
            yangUses.addEntityToResolve(infoList);
        }
    }
}
#end_block

#method_before
public static void cloneListOfLeafList(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeafList> listOfLeafList = clonedNode.getListOfLeafList();
    if (isListPresent(listOfLeafList)) {
        List<YangLeafList> clonedList = new LinkedList<>();
        for (YangLeafList leafList : listOfLeafList) {
            YangLeafList clonedLeafList = leafList.clone();
            clonedLeafList.setReferredSchemaLeafList(leafList);
            addUnresolvedType(yangUses, clonedLeafList, (YangNode) clonedNode);
            clonedLeafList.setContainedIn(clonedNode);
            clonedList.add(clonedLeafList);
        }
        clonedNode.setListOfLeafList(clonedList);
    }
}
#method_after
public static void cloneListOfLeafList(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeafList> listOfLeafList = clonedNode.getListOfLeafList();
    if (nonEmpty(listOfLeafList)) {
        List<YangLeafList> clonedList = new LinkedList<>();
        for (YangLeafList leafList : listOfLeafList) {
            YangLeafList clonedLeafList = leafList.clone();
            clonedLeafList.setReferredSchemaLeafList(leafList);
            addUnresolvedType(yangUses, clonedLeafList, (YangNode) clonedNode);
            clonedLeafList.setContainedIn(clonedNode);
            clonedList.add(clonedLeafList);
        }
        clonedNode.setListOfLeafList(clonedList);
    }
}
#end_block

#method_before
private static List<YangEntityToResolveInfoImpl> getUnresolvedTypeList(YangDataTypes dataTypes, YangType type, YangNode holder, YangUses yangUses, boolean isLeaf) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList = new ArrayList<>();
    YangEntityToResolveInfoImpl entity = null;
    List<YangEntityToResolveInfoImpl> entityList = null;
    switch(dataTypes) {
        case LEAFREF:
            entity = getLeafRefResolvableEntity(type, yangUses, holder);
            break;
        case DERIVED:
            entity = getDerivedResolvableEntity(type, holder, isLeaf);
            break;
        case UNION:
            entityList = getUnionResolvableEntity(type, isLeaf);
            break;
        default:
            return null;
    }
    infoList.add(entity);
    if (isListPresent(entityList)) {
        infoList.addAll(entityList);
    }
    return infoList;
}
#method_after
private static List<YangEntityToResolveInfoImpl> getUnresolvedTypeList(YangDataTypes dataTypes, YangType type, YangNode holder, YangUses yangUses, boolean isLeaf) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList = new ArrayList<>();
    YangEntityToResolveInfoImpl entity = null;
    List<YangEntityToResolveInfoImpl> entityList = null;
    switch(dataTypes) {
        case LEAFREF:
            entity = getLeafRefResolvableEntity(type, yangUses, holder);
            break;
        case DERIVED:
            entity = getDerivedResolvableEntity(type, holder, isLeaf);
            break;
        case UNION:
            entityList = getUnionResolvableEntity(type, isLeaf);
            break;
        default:
            return null;
    }
    infoList.add(entity);
    if (nonEmpty(entityList)) {
        infoList.addAll(entityList);
    }
    return infoList;
}
#end_block

#method_before
private static YangEntityToResolveInfoImpl getLeafRefResolvableEntity(YangType type, YangUses yangUses, YangNode holder) throws DataModelException {
    YangEntityToResolveInfoImpl<YangLeafRef> leafRefInfo = new YangEntityToResolveInfoImpl<>();
    YangLeafRef leafRef = (YangLeafRef) type.getDataTypeExtendedInfo();
    // Conversion of prefixes in absolute path while cloning them.
    convertThePrefixesDuringChange(leafRef, yangUses);
    leafRef.setParentNodeOfLeafref(holder);
    leafRefInfo.setEntityToResolve(leafRef);
    return setInformationInEntity(leafRefInfo, holder, leafRef.getCharPosition(), leafRef.getLineNumber());
}
#method_after
private static YangEntityToResolveInfoImpl getLeafRefResolvableEntity(YangType type, YangUses yangUses, YangNode holder) throws DataModelException {
    YangEntityToResolveInfoImpl<YangLeafRef> leafRefInfo = new YangEntityToResolveInfoImpl<>();
    YangLeafRef leafRef = (YangLeafRef) type.getDataTypeExtendedInfo();
    // Conversion of prefixes in absolute path while cloning them.
    convertThePrefixesDuringChange(leafRef, yangUses);
    leafRef.setParentNode(holder);
    leafRefInfo.setEntityToResolve(leafRef);
    return setInformationInEntity(leafRefInfo, holder, leafRef.getCharPosition(), leafRef.getLineNumber());
}
#end_block

#method_before
private static List<YangEntityToResolveInfoImpl> getUnionResolvableEntity(YangType type, boolean isLeaf) throws DataModelException {
    YangUnion union = (YangUnion) type.getDataTypeExtendedInfo();
    List<YangType<?>> typeList = union.getTypeList();
    List<YangEntityToResolveInfoImpl> unionList = new ArrayList<>();
    List<YangEntityToResolveInfoImpl> entity;
    for (YangType unionType : typeList) {
        entity = getUnresolvedTypeList(unionType.getDataType(), unionType, union, null, isLeaf);
        if (isListPresent(entity)) {
            unionList.addAll(entity);
        }
    }
    return unionList;
}
#method_after
private static List<YangEntityToResolveInfoImpl> getUnionResolvableEntity(YangType type, boolean isLeaf) throws DataModelException {
    YangUnion union = (YangUnion) type.getDataTypeExtendedInfo();
    List<YangType<?>> typeList = union.getTypeList();
    List<YangEntityToResolveInfoImpl> unionList = new ArrayList<>();
    List<YangEntityToResolveInfoImpl> entity;
    for (YangType unionType : typeList) {
        entity = getUnresolvedTypeList(unionType.getDataType(), unionType, union, null, isLeaf);
        if (nonEmpty(entity)) {
            unionList.addAll(entity);
        }
    }
    return unionList;
}
#end_block

#method_before
private static void convertThePrefixesDuringChange(YangLeafRef leafrefForCloning, YangUses yangUses) throws DataModelException {
    List<YangAtomicPath> atomicPathList = leafrefForCloning.getAtomicPath();
    if (atomicPathList != null && !atomicPathList.isEmpty()) {
        Iterator<YangAtomicPath> atomicPathIterator = atomicPathList.listIterator();
        while (atomicPathIterator.hasNext()) {
            YangAtomicPath atomicPath = atomicPathIterator.next();
            Map<String, String> prefixesAndItsImportNameNode = leafrefForCloning.getPrefixWithNode();
            String prefixInPath = atomicPath.getNodeIdentifier().getPrefix();
            String importedNodeName = prefixesAndItsImportNameNode.get(prefixInPath);
            assignCurrentLeafedWithNewPrefixes(importedNodeName, atomicPath, yangUses);
        }
    }
}
#method_after
private static void convertThePrefixesDuringChange(YangLeafRef leafrefForCloning, YangUses yangUses) throws DataModelException {
    List<YangAtomicPath> atomicPathList = leafrefForCloning.getAtomicPath();
    if (atomicPathList != null && !atomicPathList.isEmpty()) {
        Iterator<YangAtomicPath> atomicPathIterator = atomicPathList.listIterator();
        while (atomicPathIterator.hasNext()) {
            YangAtomicPath atomicPath = atomicPathIterator.next();
            Map<String, String> prefixesAndItsImportNameNode = leafrefForCloning.getPrefixAndNode();
            String prefixInPath = atomicPath.getNodeIdentifier().getPrefix();
            String importedNodeName = prefixesAndItsImportNameNode.get(prefixInPath);
            assignCurrentLeafedWithNewPrefixes(importedNodeName, atomicPath, yangUses);
        }
    }
}
#end_block

#method_before
public static void processIdentityRefEntry(TreeWalkListener listener, IdentityrefSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, IDENTITYREF_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangIdentityRef idRef = new YangIdentityRef();
        Parsable typeData = listener.getParsedDataStack().pop();
        YangResolutionInfoImpl<YangIdentityRef> resolutionInfo;
        // Validate node identifier.
        YangNodeIdentifier nodeId = getValidNodeIdentifier(ctx.baseStatement().string().getText(), BASE_DATA, ctx);
        idRef.setBaseIdentity(nodeId);
        ((YangType) typeData).setDataTypeExtendedInfo(idRef);
        int errLine = ctx.getStart().getLine();
        int errPos = ctx.getStart().getCharPositionInLine();
        idRef.setLineNumber(errLine);
        idRef.setCharPosition(errPos);
        idRef.setFileName(listener.getFileName());
        Parsable tmpData = listener.getParsedDataStack().peek();
        Parsable parentNode;
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                Parsable leaf = listener.getParsedDataStack().pop();
                parentNode = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leaf);
                break;
            case LEAF_LIST_DATA:
                Parsable leafList = listener.getParsedDataStack().pop();
                parentNode = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafList);
                break;
            case UNION_DATA:
                parentNode = listener.getParsedDataStack().peek();
                break;
            case TYPEDEF_DATA:
                parentNode = listener.getParsedDataStack().peek();
                break;
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
        }
        if (!(parentNode instanceof YangNode)) {
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
        }
        idRef.setResolvableStatus(UNRESOLVED);
        // Adds resolution information to the list
        resolutionInfo = new YangResolutionInfoImpl<>(idRef, (YangNode) parentNode, errLine, errPos);
        addToResolution(resolutionInfo, ctx);
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(idRef);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, "", ENTRY));
    }
}
#method_after
public static void processIdentityRefEntry(TreeWalkListener listener, IdentityrefSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, IDENTITYREF_DATA, EMPTY_STRING, ENTRY);
    if (!(listener.getParsedDataStack().peek() instanceof YangType)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, EMPTY_STRING, ENTRY));
    }
    YangIdentityRef idRef = new YangIdentityRef();
    Parsable typeData = listener.getParsedDataStack().pop();
    YangResolutionInfoImpl<YangIdentityRef> resolutionInfo;
    // Validate node identifier.
    YangNodeIdentifier nodeId = getValidNodeIdentifier(ctx.baseStatement().string().getText(), BASE_DATA, ctx);
    idRef.setBaseIdentity(nodeId);
    ((YangType) typeData).setDataTypeExtendedInfo(idRef);
    int errLine = ctx.getStart().getLine();
    int errPos = ctx.getStart().getCharPositionInLine();
    idRef.setLineNumber(errLine);
    idRef.setCharPosition(errPos);
    idRef.setFileName(listener.getFileName());
    Parsable tmpData = listener.getParsedDataStack().peek();
    Parsable parentNode;
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            Parsable leaf = listener.getParsedDataStack().pop();
            parentNode = listener.getParsedDataStack().peek();
            listener.getParsedDataStack().push(leaf);
            break;
        case LEAF_LIST_DATA:
            Parsable leafList = listener.getParsedDataStack().pop();
            parentNode = listener.getParsedDataStack().peek();
            listener.getParsedDataStack().push(leafList);
            break;
        case UNION_DATA:
            parentNode = listener.getParsedDataStack().peek();
            break;
        case TYPEDEF_DATA:
            parentNode = listener.getParsedDataStack().peek();
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
    }
    if (!(parentNode instanceof YangNode)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
    }
    idRef.setResolvableStatus(UNRESOLVED);
    // Adds resolution information to the list
    resolutionInfo = new YangResolutionInfoImpl<>(idRef, (YangNode) parentNode, errLine, errPos);
    addToResolution(resolutionInfo, ctx);
    listener.getParsedDataStack().push(typeData);
    listener.getParsedDataStack().push(idRef);
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    // Generate ENUM interface
    if (curNode instanceof RpcNotificationContainer) {
        insertDataIntoJavaFile(file, getOperationTypeEnum());
    }
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (leavesPresent) {
                insertDataIntoJavaFile(file, getInterfaceLeafIdEnumSignature(className) + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, getBeanFiles(curNode), path), COMMA, SEMI_COLON), NEW_LINE) + getInterfaceLeafIdEnumMethods());
            }
            insertDataIntoJavaFile(file, NEW_LINE);
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, INTERFACE));
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
    }
    if (curNode.isOpTypeReq()) {
        if (curNode instanceof YangCase) {
            YangNode caseParent = curNode.getParent();
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, fileInfo.getPluginConfig());
            methods.add(processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
        } else {
            methods.add(processSubtreeFilteringInterface(className));
        }
    }
    if (leavesPresent) {
        methods.add(isLeafValueSetInterface());
        if (curNode.isOpTypeReq()) {
            methods.add(isSelectLeafSetInterface());
        }
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    // Generate ENUM interface
    if (curNode instanceof RpcNotificationContainer) {
        insertDataIntoJavaFile(file, getOperationTypeEnum());
    }
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (leavesPresent) {
                insertDataIntoJavaFile(file, getInterfaceLeafIdEnumSignature(className) + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, getBeanFiles(curNode), path), COMMA, SEMI_COLON), NEW_LINE) + getInterfaceLeafIdEnumMethods());
            }
            insertDataIntoJavaFile(file, NEW_LINE);
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, INTERFACE));
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
    }
    if (leavesPresent) {
        methods.add(isLeafValueSetInterface());
        if (curNode.isOpTypeReq()) {
            methods.add(isSelectLeafSetInterface());
        }
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateBuilderClassFile(File file, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ATTRIBUTES_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, getBeanFiles(curNode), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            // Add operation attribute methods.
            if (leavesPresent && curNode.isOpTypeReq()) {
                insertDataIntoJavaFile(file, NEW_LINE);
                methods.add(getSetterForSelectLeaf(className));
            }
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl(className + BUILDER));
        methods.add(getYangAugmentInfoImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    methods.add(addDefaultConstructor(curNode, PUBLIC, BUILDER));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#method_after
public static File generateBuilderClassFile(File file, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ATTRIBUTES_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, getBeanFiles(curNode), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            // Add operation attribute methods.
            if (leavesPresent && curNode.isOpTypeReq()) {
                insertDataIntoJavaFile(file, NEW_LINE);
                methods.add(getSetterForSelectLeaf(className));
            }
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl(className + BUILDER));
        methods.add(getYangAugmentInfoImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    if (curNode instanceof YangAugment) {
        methods.add(generateBuildMethodInAugmentClass(className));
    }
    methods.add(addDefaultConstructor(curNode, PUBLIC, BUILDER));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#end_block

#method_before
public static File generateDefaultClassFile(File file, YangNode curNode, boolean attrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    boolean rootNode = false;
    String className = getCapitalCase(fileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        opParamClassName = className + OP_PARAM;
        rootNode = true;
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        addDefaultClassAttributeInfo(file, curNode, className, opParamClassName, path, methods, rootNode);
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, rootNode) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, getBeanFiles(curNode), path) + methodClose(FOUR_SPACE);
        methods.add(constructor);
        if (curNode.isOpTypeReq()) {
            String augmentableSubTreeFiltering = EMPTY_STRING;
            if (curNode instanceof YangAugmentableNode) {
                // add is filter content match.
                augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
            }
            methods.add(getProcessSubtreeFilteringStart(curNode, config) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd());
            if (curNode instanceof YangLeavesHolder) {
                if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                    methods.add(getProcessLeafSubtreeFiltering(curNode, config, path));
                }
                if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                    methods.add(getProcessLeafListSubtreeFiltering(curNode, config, path));
                }
            }
            if (curNode.getChild() != null) {
                methods.add(getProcessChildNodeSubtreeFiltering(curNode, config, path));
            }
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, IMPL_CLASS));
    }
    methods.add(addDefaultConstructor(curNode, PROTECTED, DEFAULT));
    methods.add(builderMethod(className));
    if (leavesPresent) {
        methods.add(getIsValueLeafSet());
        if (curNode.isOpTypeReq()) {
            methods.add(getIsSelectLeafSet());
        }
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateDefaultClassFile(File file, YangNode curNode, boolean attrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    boolean rootNode = false;
    String className = getCapitalCase(fileInfo.getJavaName());
    String opParamClassName = className;
    String name = DEFAULT_CAPS + className;
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        opParamClassName = className + OP_PARAM;
        name = opParamClassName;
        rootNode = true;
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        addDefaultClassAttributeInfo(file, curNode, className, opParamClassName, path, methods, rootNode);
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, rootNode) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, getBeanFiles(curNode), path) + methodClose(FOUR_SPACE);
        methods.add(constructor);
        if (curNode.isOpTypeReq()) {
            String augmentableSubTreeFiltering = EMPTY_STRING;
            if (curNode instanceof YangAugmentableNode) {
                // add is filter content match.
                augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
            }
            methods.add(getProcessSubtreeFilteringStart(curNode) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd(name, curNode));
            if (curNode instanceof YangLeavesHolder) {
                if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                    methods.add(getProcessLeafSubtreeFiltering(curNode, config, path));
                }
                if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                    methods.add(getProcessLeafListSubtreeFiltering(curNode, config, path));
                }
            }
            if (curNode.getChild() != null) {
                methods.add(getProcessChildNodeSubtreeFiltering(curNode, config, path));
            }
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, IMPL_CLASS));
    }
    methods.add(addDefaultConstructor(curNode, PROTECTED, DEFAULT));
    methods.add(builderMethod(className));
    if (leavesPresent) {
        methods.add(getIsValueLeafSet());
        if (curNode.isOpTypeReq()) {
            methods.add(getIsSelectLeafSet());
        }
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public ResolvableStatus resolve() throws DataModelException {
    YangType<?> baseType = getReferredTypeDef().getTypeDefBaseType();
    YangDataTypes type = baseType.getDataType();
    T extended = (T) baseType.getDataTypeExtendedInfo();
    /*
         * Checks the data type of the referred typedef, if it's derived, obtain
         * effective built-in type and restrictions from it's derived info,
         * otherwise take from the base type of type itself.
         */
    if (type == DERIVED) {
        ResolvableStatus resolvableStatus = resolveTypeDerivedInfo(baseType);
        if (resolvableStatus != null) {
            return resolvableStatus;
        }
    } else if (type == LEAFREF || type == IDENTITYREF) {
        effectiveBuiltInType = type;
        return RESOLVED;
    } else {
        effectiveBuiltInType = type;
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(effectiveBuiltInType)) {
            if (extended == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(extended instanceof YangRangeRestriction)) {
                    throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info is " + "of invalid ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
                }
                resolveRangeRestriction((YangRangeRestriction) extended);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls for
                 * string resolution.
                 */
        } else if (effectiveBuiltInType == STRING) {
            if (extended == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(extended instanceof YangStringRestriction)) {
                    throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info is " + "of invalid ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
                }
                resolveStringRestriction((YangStringRestriction) extended);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        } else if (effectiveBuiltInType == BINARY) {
            if (extended == null) {
                resolveBinaryRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(extended instanceof YangRangeRestriction)) {
                    throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info is " + "of invalid ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
                }
                resolveBinaryRestriction((YangRangeRestriction) extended);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        } else if (effectiveBuiltInType == DECIMAL64) {
            if (extended != null) {
                if (((YangDecimal64) extended).getRangeRestrictedExtendedInfo() == null) {
                    resolveRangeRestriction(null);
                    /*
                         * Return the resolution status as resolved, if it's not;
                         * resolve range restriction will throw exception in
                         * previous function.
                         */
                    return RESOLVED;
                } else {
                    if (!(((YangDecimal64) extended).getRangeRestrictedExtendedInfo() instanceof YangRangeRestriction)) {
                        throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info is " + "of invalid ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
                    }
                    resolveRangeRestriction((YangRangeRestriction) ((YangDecimal64) extended).getRangeRestrictedExtendedInfo());
                    /*
                         * Return the resolution status as resolved, if it's not
                         * resolve range/string restriction will throw exception in
                         * previous function.
                         */
                    return RESOLVED;
                }
            } else {
                throw new DataModelException(getErrorMsg("Linker error: Unable to find type extended info " + "for decimal64.", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
            }
        }
    }
    /*
         * Check if the data type is the one which can't be restricted, in this
         * case check whether no self restrictions should be present.
         */
    if (isOfValidNonRestrictedType(effectiveBuiltInType)) {
        if (isNullOrEmpty(getLengthRestrictionString()) && isNullOrEmpty(getRangeRestrictionString()) && getPatternRestriction() == null) {
            return RESOLVED;
        } else {
            throw new DataModelException(getErrorMsg("YANG file error: Restrictions can't be applied to a " + "given type ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
        }
    }
    // Throw exception for unsupported types
    throw new DataModelException(getErrorMsg("Linker error: Unable to process the derived type. ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
}
#method_after
public ResolvableStatus resolve() throws DataModelException {
    YangType<?> baseType = getReferredTypeDef().getTypeDefBaseType();
    YangDataTypes type = baseType.getDataType();
    T extended = (T) baseType.getDataTypeExtendedInfo();
    /*
         * Checks the data type of the referred typedef, if it's derived, obtain
         * effective built-in type and restrictions from it's derived info,
         * otherwise take from the base type of type itself.
         */
    if (type == DERIVED) {
        ResolvableStatus resolvableStatus = resolveTypeDerivedInfo(baseType);
        if (resolvableStatus != null) {
            return resolvableStatus;
        }
    } else if (type == LEAFREF || type == IDENTITYREF) {
        effectiveBuiltInType = type;
        return RESOLVED;
    } else {
        effectiveBuiltInType = type;
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(effectiveBuiltInType)) {
            return getResolveStatusForRangeRestrictionType(extended);
        } else if (effectiveBuiltInType == STRING) {
            return getResolveStatusForString(extended);
        } else if (effectiveBuiltInType == BINARY) {
            return getResolveStatusForBinary(extended);
        } else if (effectiveBuiltInType == DECIMAL64) {
            return getResolveStatusForDecimal64(extended);
        }
    }
    /*
         * Check if the data type is the one which can't be restricted, in this
         * case check whether no self restrictions should be present.
         */
    if (effectiveBuiltInType.isNonRestrictedType()) {
        if (isNullOrEmpty(getLengthRestrictionString()) && isNullOrEmpty(getRangeRestrictionString()) && getPatternRestriction() == null) {
            return RESOLVED;
        } else {
            throw new DataModelException(getErrorMsg("YANG file error: Restrictions can't be applied to a " + "given type ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
        }
    }
    // Throw exception for unsupported types
    throw new DataModelException(getErrorMsg("Linker error: Unable to process the derived type. ", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
}
#end_block

#method_before
private ResolvableStatus resolveTypeDerivedInfo(YangType<?> baseType) throws DataModelException {
    // Check whether the referred typedef is resolved.
    if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
        throw new DataModelException(getErrorMsg("Linker Error: Referred typedef is not resolved for type.", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
    }
    /*
         * Check if the referred typedef is intra file resolved, if yes sets
         * current status also to intra file resolved .
         */
    if (getReferredTypeDef().getTypeDefBaseType().getResolvableStatus() == INTRA_FILE_RESOLVED) {
        return INTRA_FILE_RESOLVED;
    }
    effectiveBuiltInType = ((YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo()).getEffectiveBuiltInType();
    YangDerivedInfo refDerivedInfo = (YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo();
    Object extendedInfo = refDerivedInfo.getResolvedExtendedInfo();
    /*
         * Check whether the effective built-in type can have range
         * restrictions, if yes call resolution of range.
         */
    if (isOfRangeRestrictedType(effectiveBuiltInType)) {
        if (extendedInfo == null) {
            resolveRangeRestriction(null);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve range/string restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        } else {
            if (!(extendedInfo instanceof YangRangeRestriction)) {
                throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info " + "is of invalid type", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
            }
            resolveRangeRestriction((YangRangeRestriction) extendedInfo);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve range/string restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        }
    /*
             * If the effective built-in type is of type string calls for
             * string resolution.
             */
    } else if (effectiveBuiltInType == STRING) {
        if (extendedInfo == null) {
            resolveStringRestriction(null);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve range/string restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        } else {
            if (!(extendedInfo instanceof YangStringRestriction)) {
                throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info " + "is of invalid type", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
            }
            resolveStringRestriction((YangStringRestriction) extendedInfo);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve range/string restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        }
    } else if (effectiveBuiltInType == BINARY) {
        if (extendedInfo == null) {
            resolveBinaryRestriction(null);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve length restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        } else {
            if (!(extendedInfo instanceof YangRangeRestriction)) {
                throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info " + "is of invalid type", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
            }
            resolveBinaryRestriction((YangRangeRestriction) extendedInfo);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve length restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        }
    } else if (effectiveBuiltInType == DECIMAL64) {
        if (extendedInfo == null) {
            resolveRangeRestriction(null);
            /*
                  * Return the resolution status as resolved, if it's not;
                  * resolve range restriction will throw exception in
                  * previous function.
                  */
            return RESOLVED;
        } else {
            if (!(extendedInfo instanceof YangRangeRestriction)) {
                throw new DataModelException(getErrorMsg("Linker error: Referred typedef restriction info " + "is of invalid type", "type.", getLineNumber(), getCharPosition(), getFileName() + "\""));
            }
            resolveRangeRestriction((YangRangeRestriction) extendedInfo);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve range/string restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        }
    }
    return null;
}
#method_after
private ResolvableStatus resolveTypeDerivedInfo(YangType<?> baseType) throws DataModelException {
    // Check whether the referred typedef is resolved.
    if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
        throwError();
    }
    /*
         * Check if the referred typedef is intra file resolved, if yes sets
         * current status also to intra file resolved .
         */
    if (getReferredTypeDef().getTypeDefBaseType().getResolvableStatus() == INTRA_FILE_RESOLVED) {
        return INTRA_FILE_RESOLVED;
    }
    effectiveBuiltInType = ((YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo()).getEffectiveBuiltInType();
    YangDerivedInfo refDerivedInfo = (YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo();
    T extendedInfo = (T) refDerivedInfo.getResolvedExtendedInfo();
    /*
         * Check whether the effective built-in type can have range
         * restrictions, if yes call resolution of range.
         */
    if (isOfRangeRestrictedType(effectiveBuiltInType)) {
        return getResolveStatusForRangeRestrictionType(extendedInfo);
    } else if (effectiveBuiltInType == STRING) {
        return getResolveStatusForString(extendedInfo);
    } else if (effectiveBuiltInType == BINARY) {
        return getResolveStatusForBinary(extendedInfo);
    } else if (effectiveBuiltInType == DECIMAL64) {
        if (extendedInfo == null) {
            resolveRangeRestriction(null);
            /*
                  * Return the resolution status as resolved, if it's not;
                  * resolve range restriction will throw exception in
                  * previous function.
                  */
            return RESOLVED;
        } else {
            if (!(extendedInfo instanceof YangRangeRestriction)) {
                throwError();
            }
            resolveRangeRestriction((YangRangeRestriction) extendedInfo);
            /*
                 * Return the resolution status as resolved, if it's not
                 * resolve range/string restriction will throw exception in
                 * previous function.
                 */
            return RESOLVED;
        }
    }
    return null;
}
#end_block

#method_before
private void resolveStringRestriction(YangStringRestriction refStrRestriction) throws DataModelException {
    YangStringRestriction curStringRestriction = null;
    YangRangeRestriction refRangeRestriction = null;
    YangPatternRestriction refPatternRestriction = null;
    /*
         * Check that range restriction should be null when built-in type is
         * string.
         */
    if (!isNullOrEmpty(getRangeRestrictionString())) {
        throw new DataModelException(getErrorMsg("YANG file error: Range restriction " + "should't be present for string data type.", "type.", getLineNumber(), getCharPosition(), getFileName()));
    }
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refStrRestriction == null && isNullOrEmpty(getLengthRestrictionString()) && getPatternRestriction() == null) {
        return;
    }
    /*
         * If referred string restriction is not null, take value of length and
         * pattern restriction and assign.
         */
    if (refStrRestriction != null) {
        refRangeRestriction = refStrRestriction.getLengthRestriction();
        refPatternRestriction = refStrRestriction.getPatternRestriction();
    }
    YangRangeRestriction lengthRestriction = resolveLengthRestriction(refRangeRestriction);
    YangPatternRestriction patternRestriction = resolvePatternRestriction(refPatternRestriction);
    /*
         * Check if either of length or pattern restriction is present, if yes
         * create string restriction and assign value.
         */
    if (lengthRestriction != null || patternRestriction != null) {
        curStringRestriction = new YangStringRestriction();
        curStringRestriction.setCharPosition(getCharPosition());
        curStringRestriction.setFileName(getFileName());
        curStringRestriction.setLineNumber(getLineNumber());
        curStringRestriction.setLengthRestriction(lengthRestriction);
        curStringRestriction.setPatternRestriction(patternRestriction);
    }
    resolvedExtendedInfo = (T) curStringRestriction;
}
#method_after
private void resolveStringRestriction(YangStringRestriction refSr) throws DataModelException {
    YangStringRestriction curSr = null;
    YangRangeRestriction refRr = null;
    YangPatternRestriction refPr = null;
    /*
         * Check that range restriction should be null when built-in type is
         * string.
         */
    if (!isNullOrEmpty(getRangeRestrictionString())) {
        throw new DataModelException(getErrorMsg("YANG file error: Range restriction should't be present for" + " string data type.", ".", getLineNumber(), getCharPosition(), getFileName()));
    }
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refSr == null && isNullOrEmpty(getLengthRestrictionString()) && getPatternRestriction() == null) {
        return;
    }
    /*
         * If referred string restriction is not null, take value of length and
         * pattern restriction and assign.
         */
    if (refSr != null) {
        refRr = refSr.getLengthRestriction();
        refPr = refSr.getPatternRestriction();
    }
    YangRangeRestriction lr = resolveLengthRestriction(refRr);
    YangPatternRestriction pr = resolvePatternRestriction(refPr);
    /*
         * Check if either of length or pattern restriction is present, if yes
         * create string restriction and assign value.
         */
    if (lr != null || pr != null) {
        curSr = new YangStringRestriction();
        curSr.setCharPosition(getCharPosition());
        curSr.setFileName(getFileName());
        curSr.setLineNumber(getLineNumber());
        curSr.setLengthRestriction(lr);
        curSr.setPatternRestriction(pr);
    }
    resolvedExtendedInfo = (T) curSr;
}
#end_block

#method_before
private void resolveBinaryRestriction(YangRangeRestriction refLengthRestriction) throws DataModelException {
    if (rangeRestrictionString != null || patternRestriction != null) {
        throw new DataModelException(getErrorMsg("YANG file error: for binary range restriction or pattern " + "restriction is not allowed.", "type.", getLineNumber(), getCharPosition(), getFileName()));
    }
    // Get the final resolved length restriction
    YangRangeRestriction lengthRestriction = resolveLengthRestriction(refLengthRestriction);
    // Set the length restriction.
    resolvedExtendedInfo = (T) lengthRestriction;
}
#method_after
private void resolveBinaryRestriction(YangRangeRestriction refLr) throws DataModelException {
    if (rangeRestrictionString != null || patternRestriction != null) {
        throw new DataModelException(getErrorMsg("YANG file error: for binary range restriction or pattern " + "restriction is not allowed.", "type.", getLineNumber(), getCharPosition(), getFileName()));
    }
    // Get the final resolved length restriction
    YangRangeRestriction lr = resolveLengthRestriction(refLr);
    // Set the length restriction.
    resolvedExtendedInfo = (T) lr;
}
#end_block

#method_before
private YangPatternRestriction resolvePatternRestriction(YangPatternRestriction refPatternRestriction) {
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refPatternRestriction == null && getPatternRestriction() == null) {
        return null;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (getPatternRestriction() == null) {
        return refPatternRestriction;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refPatternRestriction == null) {
        return getPatternRestriction();
    }
    /*
         * Get patterns of referred type and add it to current pattern
         * restrictions.
         */
    for (String pattern : refPatternRestriction.getPatternList()) {
        getPatternRestriction().addPattern(pattern);
    }
    return getPatternRestriction();
}
#method_after
private YangPatternRestriction resolvePatternRestriction(YangPatternRestriction refPr) {
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refPr == null && getPatternRestriction() == null) {
        return null;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (getPatternRestriction() == null) {
        return refPr;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refPr == null) {
        return getPatternRestriction();
    }
    /*
         * Get patterns of referred type and add it to current pattern
         * restrictions.
         */
    for (String pattern : refPr.getPatternList()) {
        getPatternRestriction().addPattern(pattern);
    }
    return getPatternRestriction();
}
#end_block

#method_before
public static String getSubtreeFilteringForLeaf(JavaAttributeInfo javaAttributeInfo, YangType<?> type) {
    String attrQualifiedType;
    String attributeName = javaAttributeInfo.getAttributeName();
    attrQualifiedType = getIfFilterContentMatchMethodImpl(attributeName, type);
    return EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + VALUE_LEAF + PERIOD + GET_METHOD_PREFIX + OPEN_PARENTHESIS + LEAF_IDENTIFIER + PERIOD + attributeName.toUpperCase() + PERIOD + GET_LEAF_INDEX + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + attrQualifiedType + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLON + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + attributeName + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + IF + SPACE + OPEN_PARENTHESIS + SELECT_LEAF + PERIOD + GET_METHOD_PREFIX + OPEN_PARENTHESIS + LEAF_IDENTIFIER + PERIOD + attributeName.toUpperCase() + PERIOD + GET_LEAF_INDEX + CLOSE_PARENTHESIS + SPACE + OR_OPERATION + SPACE + IS_SELECT_ALL_SCHEMA_CHILD_FLAG + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE + TWELVE_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + attributeName + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + attributeName + OPEN_CLOSE_BRACKET_STRING + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
public static String getSubtreeFilteringForLeaf(JavaAttributeInfo javaAttributeInfo, YangType<?> type) {
    String attrQualifiedType;
    String attributeName = javaAttributeInfo.getAttributeName();
    attrQualifiedType = getIfFilterContentMatchMethodImpl(attributeName, type);
    /* if (valueLeafFlags.get(LeafIdentifier.LEAF.getLeafIndex())) {
         * if (appInstance.leaf() != leaf()) {
         * return false;
         * } else {
         * subTreeFilteringResultBuilder.leaf(appInstance.leaf());
         * }
         * } else if (selectLeafFlags.get(LeafIdentifier.LEAF.getLeafIndex()) ||
         * isSelectAllSchemaChild) {
         * isAnySelectOrContainmentNode = true;
         * subTreeFilteringResultBuilder.leaf(appInstance.leaf());
         * }*/
    return getIfConditionBegin(EIGHT_SPACE_INDENTATION, getLeafFlagSetString(attributeName, VALUE_LEAF, EMPTY_STRING, GET)) + getIfConditionBegin(TWELVE_SPACE_INDENTATION, attrQualifiedType) + getReturnString(FALSE, SIXTEEN_SPACE_INDENTATION) + signatureClose() + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + getSubTreeBuilderCallString(SIXTEEN_SPACE_INDENTATION, attributeName, TWELVE_SPACE) + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + getIfConditionBegin(SPACE, getLeafFlagSetString(attributeName, SELECT_LEAF, EMPTY_STRING, GET) + SPACE + OR_OPERATION + SPACE + IS_SELECT_ALL_SCHEMA_CHILD_FLAG) + valueAssign(IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG, TRUE, TWELVE_SPACE_INDENTATION) + getSubTreeBuilderCallString(TWELVE_SPACE_INDENTATION, attributeName, EIGHT_SPACE);
}
#end_block

#method_before
private static String getIfFilterContentMatchMethodImpl(String attributeName, YangType dataType) {
    String attrQualifiedType;
    if (StringGenerator.isPrimitiveDataType(dataType.getDataType())) {
        attrQualifiedType = getAttrTypeForFilterContentMatchWhenPrimitiveDataType(attributeName);
    } else if (dataType.getDataType() == LEAFREF) {
        // When leafref in grouping.
        if (((YangLeafRef) dataType.getDataTypeExtendedInfo()).isInGrouping()) {
            attrQualifiedType = getAttrTypeForFilterContentMatchWhenNonPrimitiveDataTypes(attributeName);
        } else {
            YangType type = ((YangLeafRef) dataType.getDataTypeExtendedInfo()).getEffectiveDataType();
            if (StringGenerator.isPrimitiveDataType(type.getDataType())) {
                attrQualifiedType = getAttrTypeForFilterContentMatchWhenPrimitiveDataType(attributeName);
            } else {
                attrQualifiedType = getAttrTypeForFilterContentMatchWhenNonPrimitiveDataTypes(attributeName);
            }
        }
    } else {
        attrQualifiedType = getAttrTypeForFilterContentMatchWhenNonPrimitiveDataTypes(attributeName);
    }
    return attrQualifiedType;
}
#method_after
private static String getIfFilterContentMatchMethodImpl(String name, YangType dataType) {
    String attrQualifiedType;
    if (dataType.getDataType().isPrimitiveDataType()) {
        attrQualifiedType = getAttrTypeForFcmWhenPrimitiveDataType(name);
    } else if (dataType.getDataType() == LEAFREF) {
        // When leafref in grouping.
        if (((YangLeafRef) dataType.getDataTypeExtendedInfo()).isInGrouping()) {
            attrQualifiedType = attrTypeForFcmWhenNonPrimitiveDataTypes(name);
        } else {
            YangType type = ((YangLeafRef) dataType.getDataTypeExtendedInfo()).getEffectiveDataType();
            if (type.getDataType().isPrimitiveDataType()) {
                attrQualifiedType = getAttrTypeForFcmWhenPrimitiveDataType(name);
            } else {
                attrQualifiedType = attrTypeForFcmWhenNonPrimitiveDataTypes(name);
            }
        }
    } else {
        attrQualifiedType = attrTypeForFcmWhenNonPrimitiveDataTypes(name);
    }
    return attrQualifiedType;
}
#end_block

#method_before
public static String getSubtreeFilteringForLeafList(JavaAttributeInfo javaAttributeInfo) {
    return getSubtreeFilteringForList(javaAttributeInfo, true);
}
#method_after
public static String getSubtreeFilteringForLeafList(JavaAttributeInfo javaAttributeInfo) {
    return getSubtreeFilteringForList(javaAttributeInfo, true, null);
}
#end_block

#method_before
static String getProcessChildNodeSubtreeFiltering(YangNode curNode, YangPluginConfig pluginConfig, String path) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    JavaFileInfoTranslator parentInfo;
    String instance = APP_INSTANCE;
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    if (curNode instanceof YangCase) {
        instance = INSTANCE;
        YangNode parent = curNode.getParent();
        if (parent instanceof YangChoice) {
            parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
            name = getCapitalCase(parentInfo.getJavaName());
        } else if (parent instanceof YangAugment) {
            parentInfo = ((JavaFileInfoContainer) ((YangAugment) parent).getAugmentedNode()).getJavaFileInfo();
            if (parentInfo != null) {
                name = getCapitalCase(parentInfo.getJavaName());
            } else {
                name = getCapitalCase(getCamelCase(((YangAugment) parent).getAugmentedNode().getName(), pluginConfig.getConflictResolver()));
            }
        }
    }
    String processSubtreeFilteringMethod = FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BOOLEAN_DATA_TYPE + SPACE + "processChildNodesSubTreeFiltering" + OPEN_PARENTHESIS + name + SPACE + instance + COMMA + SPACE + builderNamePrefix + BUILDER + SPACE + "subTreeFilteringResultBuilder" + COMMA + NEW_LINE + TWELVE_SPACE_INDENTATION + "Boolean " + "isAnySelectOrContainmentNode, " + "boolean " + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    if (curNode instanceof YangCase) {
        String caseName = getCapitalCase(javaFileInfo.getJavaName());
        processSubtreeFilteringMethod = processSubtreeFilteringMethod + EIGHT_SPACE_INDENTATION + caseName + SPACE + APP_INSTANCE + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + caseName + CLOSE_PARENTHESIS + SPACE + instance + SEMI_COLON + NEW_LINE;
    }
    processSubtreeFilteringMethod += getDataFromTempFileHandle(FILTER_CONTENT_MATCH_FOR_NODES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
    processSubtreeFilteringMethod += EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + NEW_LINE;
    return processSubtreeFilteringMethod;
}
#method_after
static String getProcessChildNodeSubtreeFiltering(YangNode curNode, YangPluginConfig pluginConfig, String path) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String instance = APP_INSTANCE;
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    Map<String, String> param = new HashMap<>();
    param.put(PROCESS_CHILD_NODE_STF_PARAM, BOOLEAN_DATA_TYPE);
    param.put(instance, name);
    param.put(STF_BUILDER_PARAM, builderNamePrefix + BUILDER);
    param.put(SELECT_OR_CONTAINMENT_NODE_PARAM, BOOLEAN_WRAPPER);
    param.put(SELECT_ALL_CHILD_SCHEMA_PARAM, BOOLEAN_WRAPPER);
    String method = FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BOOLEAN_DATA_TYPE + SPACE + PROCESS_CHILD_NODE_STF_PARAM + OPEN_PARENTHESIS + name + SPACE + instance + COMMA + SPACE + builderNamePrefix + BUILDER + SPACE + STF_BUILDER_PARAM + COMMA + " Boolean " + "isAnySelectOrContainmentNode, " + "boolean " + SELECT_ALL_CHILD_SCHEMA_PARAM + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    method += getDataFromTempFileHandle(FILTER_CONTENT_MATCH_FOR_NODES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
    method += EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + NEW_LINE;
    YangNode child = curNode.getChild();
    while (child != null) {
        if (child instanceof YangChoice) {
            method += getChoiceInstanceForPstMethod(child, name);
        }
        child = child.getNextSibling();
    }
    return method;
}
#end_block

#method_before
static String getProcessLeafListSubtreeFiltering(YangNode curNode, YangPluginConfig pluginConfig, String path) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    JavaFileInfoTranslator parentInfo;
    String instance = APP_INSTANCE;
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    if (curNode instanceof YangCase) {
        instance = INSTANCE;
        YangNode parent = curNode.getParent();
        if (parent instanceof YangChoice) {
            parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
            name = getCapitalCase(parentInfo.getJavaName());
        } else if (parent instanceof YangAugment) {
            parentInfo = ((JavaFileInfoContainer) ((YangAugment) parent).getAugmentedNode()).getJavaFileInfo();
            if (parentInfo != null) {
                name = getCapitalCase(parentInfo.getJavaName());
            } else {
                name = getCapitalCase(getCamelCase(((YangAugment) parent).getAugmentedNode().getName(), pluginConfig.getConflictResolver()));
            }
        }
    }
    String processSubtreeFilteringMethod = FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BOOLEAN_DATA_TYPE + SPACE + "processLeafListSubTreeFiltering" + OPEN_PARENTHESIS + name + SPACE + instance + COMMA + SPACE + builderNamePrefix + BUILDER + SPACE + "subTreeFilteringResultBuilder" + COMMA + NEW_LINE + TWELVE_SPACE_INDENTATION + "Boolean " + "isAnySelectOrContainmentNode, " + "boolean " + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    if (curNode instanceof YangCase) {
        String caseName = getCapitalCase(javaFileInfo.getJavaName());
        processSubtreeFilteringMethod = processSubtreeFilteringMethod + EIGHT_SPACE_INDENTATION + caseName + SPACE + APP_INSTANCE + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + caseName + CLOSE_PARENTHESIS + SPACE + instance + SEMI_COLON + NEW_LINE;
    }
    processSubtreeFilteringMethod += getDataFromTempFileHandle(FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
    processSubtreeFilteringMethod += EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + NEW_LINE;
    return processSubtreeFilteringMethod;
}
#method_after
static String getProcessLeafListSubtreeFiltering(YangNode curNode, YangPluginConfig pluginConfig, String path) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    String processSubtreeFilteringMethod = FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BOOLEAN_DATA_TYPE + SPACE + "processLeafListSubTreeFiltering" + OPEN_PARENTHESIS + name + SPACE + APP_INSTANCE + COMMA + SPACE + builderNamePrefix + BUILDER + SPACE + "subTreeFilteringResultBuilder" + COMMA + " Boolean " + "isAnySelectOrContainmentNode, " + "boolean " + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    processSubtreeFilteringMethod += getDataFromTempFileHandle(FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
    processSubtreeFilteringMethod += EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + NEW_LINE;
    return processSubtreeFilteringMethod;
}
#end_block

#method_before
static String getProcessLeafSubtreeFiltering(YangNode curNode, YangPluginConfig pluginConfig, String path) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    JavaFileInfoTranslator parentInfo;
    String instance = APP_INSTANCE;
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    if (curNode instanceof YangCase) {
        instance = INSTANCE;
        YangNode parent = curNode.getParent();
        if (parent instanceof YangChoice) {
            parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
            name = getCapitalCase(parentInfo.getJavaName());
        } else if (parent instanceof YangAugment) {
            parentInfo = ((JavaFileInfoContainer) ((YangAugment) parent).getAugmentedNode()).getJavaFileInfo();
            if (parentInfo != null) {
                name = getCapitalCase(parentInfo.getJavaName());
            } else {
                name = getCapitalCase(getCamelCase(((YangAugment) parent).getAugmentedNode().getName(), pluginConfig.getConflictResolver()));
            }
        }
    }
    String processSubtreeFilteringMethod = FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BOOLEAN_DATA_TYPE + SPACE + "processLeafSubtreeFiltering" + OPEN_PARENTHESIS + name + SPACE + instance + COMMA + SPACE + builderNamePrefix + BUILDER + SPACE + "subTreeFilteringResultBuilder" + COMMA + NEW_LINE + TWELVE_SPACE_INDENTATION + "Boolean " + "isAnySelectOrContainmentNode, " + "boolean " + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    if (curNode instanceof YangCase) {
        String caseName = getCapitalCase(javaFileInfo.getJavaName());
        processSubtreeFilteringMethod = processSubtreeFilteringMethod + EIGHT_SPACE_INDENTATION + caseName + SPACE + APP_INSTANCE + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + caseName + CLOSE_PARENTHESIS + SPACE + instance + SEMI_COLON + NEW_LINE;
    }
    processSubtreeFilteringMethod += getDataFromTempFileHandle(FILTER_CONTENT_MATCH_FOR_LEAF_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
    processSubtreeFilteringMethod += EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + NEW_LINE;
    return processSubtreeFilteringMethod;
}
#method_after
static String getProcessLeafSubtreeFiltering(YangNode curNode, YangPluginConfig pluginConfig, String path) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    String processSubtreeFilteringMethod = FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BOOLEAN_DATA_TYPE + SPACE + "processLeafSubtreeFiltering" + OPEN_PARENTHESIS + name + SPACE + APP_INSTANCE + COMMA + SPACE + builderNamePrefix + BUILDER + SPACE + "subTreeFilteringResultBuilder" + COMMA + " Boolean " + "isAnySelectOrContainmentNode, " + "boolean " + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    processSubtreeFilteringMethod += getDataFromTempFileHandle(FILTER_CONTENT_MATCH_FOR_LEAF_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
    processSubtreeFilteringMethod += EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + NEW_LINE;
    return processSubtreeFilteringMethod;
}
#end_block

#method_before
static String getProcessSubtreeFilteringStart(YangNode curNode, YangPluginConfig pluginConfig) {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    JavaFileInfoTranslator parentInfo;
    String instance = APP_INSTANCE;
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    if (curNode instanceof YangCase) {
        instance = INSTANCE;
        YangNode parent = curNode.getParent();
        if (parent instanceof YangChoice) {
            parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
            name = getCapitalCase(parentInfo.getJavaName());
        } else if (parent instanceof YangAugment) {
            parentInfo = ((JavaFileInfoContainer) ((YangAugment) parent).getAugmentedNode()).getJavaFileInfo();
            if (parentInfo != null) {
                name = getCapitalCase(parentInfo.getJavaName());
            } else {
                name = getCapitalCase(getCamelCase(((YangAugment) parent).getAugmentedNode().getName(), pluginConfig.getConflictResolver()));
            }
        }
    }
    String processSubtreeFilteringMethod = StringGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + name + SPACE + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + name + SPACE + instance + COMMA + SPACE + BOOLEAN_DATA_TYPE + SPACE + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + builderNamePrefix + BUILDER + SPACE + SUBTREE_FILTERING_RESULT_BUILDER + SPACE + EQUAL + SPACE + NEW + SPACE + builderNamePrefix + BUILDER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + EIGHT_SPACE_INDENTATION + "Boolean" + SPACE + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + FALSE + SEMI_COLON + NEW_LINE;
    if (curNode instanceof YangCase) {
        String caseName = getCapitalCase(javaFileInfo.getJavaName());
        processSubtreeFilteringMethod = processSubtreeFilteringMethod + EIGHT_SPACE_INDENTATION + caseName + SPACE + APP_INSTANCE + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + caseName + CLOSE_PARENTHESIS + SPACE + instance + SEMI_COLON + NEW_LINE;
    }
    return processSubtreeFilteringMethod;
}
#method_after
static String getProcessSubtreeFilteringStart(YangNode curNode) {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String instance = APP_INSTANCE;
    String name = getCapitalCase(javaFileInfo.getJavaName());
    String builderNamePrefix = getCapitalCase(javaFileInfo.getJavaName());
    if (curNode instanceof RpcNotificationContainer) {
        name = getCapitalCase(javaFileInfo.getJavaName()) + OP_PARAM;
    } else {
        name = DEFAULT_CAPS + name;
    }
    String javadoc = "   /**\n" + "     * Checks if the passed " + name + " maps the content match query condition.\n" + "     *\n" + "     * @param " + instance + SPACE + instance + SPACE + "being passed to check" + " for" + " content match\n" + "     * @param isSelectAllSchemaChild is select all schema child\n" + "     * @return match result\n" + "     */\n";
    String processSubtreeFilteringMethod = javadoc + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + name + SPACE + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + name + SPACE + instance + COMMA + SPACE + BOOLEAN_DATA_TYPE + SPACE + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + builderNamePrefix + BUILDER + SPACE + SUBTREE_FILTERING_RESULT_BUILDER + SPACE + EQUAL + SPACE + NEW + SPACE + builderNamePrefix + BUILDER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + EIGHT_SPACE_INDENTATION + "Boolean" + SPACE + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + FALSE + SEMI_COLON + NEW_LINE;
    return processSubtreeFilteringMethod;
}
#end_block

#method_before
static String getProcessSubtreeFunctionBody(YangNode curNode) {
    String method = "";
    if (curNode instanceof YangLeavesHolder) {
        if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
            method += StringGenerator.getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + "processLeafSubtreeFiltering(appInstance, " + "subTreeFilteringResultBuilder," + NEW_LINE + TWELVE_SPACE_INDENTATION + "isAnySelectOrContainmentNode, " + "isSelectAllSchemaChild)");
            method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLON + NEW_LINE;
            method += methodClose(EIGHT_SPACE);
        }
    }
    if (curNode instanceof YangLeavesHolder) {
        if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
            method += StringGenerator.getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + "processLeafListSubTreeFiltering(appInstance," + " subTreeFilteringResultBuilder," + NEW_LINE + TWELVE_SPACE_INDENTATION + "isAnySelectOrContainmentNode, " + "isSelectAllSchemaChild)");
            method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLON + NEW_LINE;
            method += methodClose(EIGHT_SPACE);
        }
    }
    if (curNode.getChild() != null) {
        method += StringGenerator.getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + "processChildNodesSubTreeFiltering(appInstance, " + "subTreeFilteringResultBuilder," + NEW_LINE + TWELVE_SPACE_INDENTATION + "isAnySelectOrContainmentNode, " + "isSelectAllSchemaChild)");
        method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLON + NEW_LINE;
        method += methodClose(EIGHT_SPACE);
    }
    return method;
}
#method_after
static String getProcessSubtreeFunctionBody(YangNode curNode) {
    String method = "";
    if (curNode instanceof YangLeavesHolder) {
        if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
            method += getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + "processLeafSubtreeFiltering(appInstance, " + "subTreeFilteringResultBuilder, " + "isAnySelectOrContainmentNode, " + "isSelectAllSchemaChild)");
            method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLON + NEW_LINE;
            method += methodClose(EIGHT_SPACE);
        }
    }
    if (curNode instanceof YangLeavesHolder) {
        if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
            method += getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + "processLeafListSubTreeFiltering(appInstance," + " subTreeFilteringResultBuilder, " + "isAnySelectOrContainmentNode, " + "isSelectAllSchemaChild)");
            method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLON + NEW_LINE;
            method += methodClose(EIGHT_SPACE);
        }
    }
    if (curNode.getChild() != null) {
        method += getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + "processChildNodesSubTreeFiltering(appInstance, " + "subTreeFilteringResultBuilder, " + "isAnySelectOrContainmentNode, " + "isSelectAllSchemaChild)");
        method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLON + NEW_LINE;
        method += methodClose(EIGHT_SPACE);
    }
    return method;
}
#end_block

#method_before
public static String getSubtreeFilteringForNode(JavaAttributeInfo attr) {
    boolean isList = attr.isListAttr();
    if (isList) {
        return getSubtreeFilteringForList(attr, false);
    } else {
        return getSubtreeFilteringForChildNode(attr);
    }
}
#method_after
public static String getSubtreeFilteringForNode(JavaAttributeInfo attr, YangNode node) {
    boolean isList = attr.isListAttr();
    if (isList) {
        return getSubtreeFilteringForList(attr, false, node);
    } else {
        return getSubtreeFilteringForChildNode(attr, node);
    }
}
#end_block

#method_before
static String getProcessSubTreeFilteringEnd() {
    String method = StringGenerator.getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + IS_SELECT_ALL_SCHEMA_CHILD_FLAG + SPACE + AND_OPERATION + SPACE + NOT + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG);
    method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + APP_INSTANCE + COMMA + SPACE + TRUE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    method += methodClose(EIGHT_SPACE);
    method += EIGHT_SPACE_INDENTATION + RETURN + SPACE + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + BUILD + OPEN_CLOSE_BRACKET_STRING + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
    return method;
}
#method_after
static String getProcessSubTreeFilteringEnd(String name, YangNode curNode) {
    String method = getIfConditionBegin(EIGHT_SPACE_INDENTATION, NOT + IS_SELECT_ALL_SCHEMA_CHILD_FLAG + SPACE + AND_OPERATION + SPACE + NOT + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG);
    method += TWELVE_SPACE_INDENTATION + RETURN + SPACE + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + APP_INSTANCE + COMMA + SPACE + TRUE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    method += methodClose(EIGHT_SPACE);
    String build = BUILD;
    if (curNode instanceof YangAugment) {
        build = BUILD_FOR_FILTER;
    }
    method += EIGHT_SPACE_INDENTATION + RETURN + SPACE + getOpenCloseParaWithValue(name) + SPACE + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + build + OPEN_CLOSE_BRACKET_STRING + SEMI_COLON + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
    return method;
}
#end_block

#method_before
private static String getSubtreeFilteringForChildNode(JavaAttributeInfo javaAttributeInfo) {
    String name = javaAttributeInfo.getAttributeName();
    name = getSmallCase(name);
    String type = javaAttributeInfo.getImportInfo().getClassInfo();
    if (javaAttributeInfo.isQualifiedName()) {
        type = javaAttributeInfo.getImportInfo().getPkgInfo() + PERIOD + type;
    }
    String method = StringGenerator.getIfConditionBegin(EIGHT_SPACE_INDENTATION, name + "() != " + "null  || isSelectAllSchemaChild");
    method += TWELVE_SPACE_INDENTATION + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
    method += TWELVE_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + NOT + EQUAL + SPACE + NULL + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    method += SIXTEEN_SPACE_INDENTATION + type + SPACE + "result" + SEMI_COLON + NEW_LINE;
    method += StringGenerator.getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, "isSelectAllSchemaChild");
    method += TWENTY_SPACE_INDENTATION + "result" + SPACE + EQUAL + SPACE + APP_INSTANCE + PERIOD + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    method += SIXTEEN_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    method += TWENTY_SPACE_INDENTATION + "result = " + name + PERIOD + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + COMMA + SPACE + FALSE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    method += SIXTEEN_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
    method += SIXTEEN_SPACE_INDENTATION + "if (result != null) {" + NEW_LINE;
    method += TWENTY_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + name + OPEN_PARENTHESIS + "result" + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
    // if app instance is not null
    method += methodClose(TWELVE_SPACE);
    // if query instance is not null
    method += methodClose(TWELVE_SPACE);
    return method;
}
#method_after
private static String getSubtreeFilteringForChildNode(JavaAttributeInfo javaAttributeInfo, YangNode node) {
    String name = javaAttributeInfo.getAttributeName();
    String clsInfo = javaAttributeInfo.getImportInfo().getClassInfo();
    String type = DEFAULT_CAPS + javaAttributeInfo.getImportInfo().getClassInfo();
    if (javaAttributeInfo.isQualifiedName()) {
        type = javaAttributeInfo.getImportInfo().getPkgInfo() + PERIOD + type;
        clsInfo = javaAttributeInfo.getImportInfo().getPkgInfo() + PERIOD + clsInfo;
    }
    String classCast = getOpenCloseParaWithValue(type) + SPACE;
    String cast = getOpenCloseParaWithValue(classCast + name);
    String resultString = cast + PERIOD + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + classCast + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + COMMA + SPACE + FALSE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    if (node != null && node instanceof YangChoice) {
        resultString = getReturnStringInCaseOfChoice(node);
    }
    String method = getIfConditionBegin(EIGHT_SPACE_INDENTATION, name + "() != " + "null  || isSelectAllSchemaChild");
    method += TWELVE_SPACE_INDENTATION + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
    method += TWELVE_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + NOT + EQUAL + SPACE + NULL + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    method += SIXTEEN_SPACE_INDENTATION + clsInfo + SPACE + "result" + SEMI_COLON + NEW_LINE;
    method += getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, "isSelectAllSchemaChild");
    method += TWENTY_SPACE_INDENTATION + "result" + SPACE + EQUAL + SPACE + APP_INSTANCE + PERIOD + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    method += SIXTEEN_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    method += TWENTY_SPACE_INDENTATION + "result = " + resultString;
    method += SIXTEEN_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
    method += SIXTEEN_SPACE_INDENTATION + "if (result != null) {" + NEW_LINE;
    method += TWENTY_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + name + OPEN_PARENTHESIS + "result" + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
    // if app instance is not null
    method += methodClose(TWELVE_SPACE);
    // if query instance is not null
    method += methodClose(TWELVE_SPACE);
    return method;
}
#end_block

#method_before
private static String getSubtreeFilteringForList(JavaAttributeInfo javaAttributeInfo, boolean isLeafList) {
    String capitalCaseName = getCapitalCase(javaAttributeInfo.getAttributeName());
    String name = javaAttributeInfo.getAttributeName();
    String type = javaAttributeInfo.getImportInfo().getClassInfo();
    if (javaAttributeInfo.isQualifiedName()) {
        type = javaAttributeInfo.getImportInfo().getPkgInfo() + PERIOD + type;
    }
    /*
         * If select all schema child
         */
    String method = StringGenerator.getIfConditionBegin(EIGHT_SPACE_INDENTATION, IS_SELECT_ALL_SCHEMA_CHILD_FLAG);
    method = method + StringGenerator.getCollectionIteratorForLoopBegin(TWELVE_SPACE_INDENTATION, type + SPACE + name, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
    method = method + SIXTEEN_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + name + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    // Close collection Iteration loop
    method += methodClose(TWELVE_SPACE);
    // If need to explicitly participate in query
    method += StringGenerator.getElseIfConditionBegin(EIGHT_SPACE_INDENTATION, name + OPEN_CLOSE_BRACKET_STRING + SPACE + NOT + EQUAL + SPACE + NULL);
    if (!isLeafList) {
        method += TWELVE_SPACE_INDENTATION + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
    }
    // If there is any parameter in the query condition
    method += StringGenerator.getIfConditionBegin(TWELVE_SPACE_INDENTATION, NOT + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
    if (isLeafList) {
        /*
             * If there is no app instance to perform content match
             */
        method += StringGenerator.getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + SPACE + EQUAL + EQUAL + SPACE + NULL + SPACE + OR_OPERATION + SPACE + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
        method += TWENTY_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLON + NEW_LINE;
        method += methodClose(SIXTEEN_SPACE);
        // for instance iterator
        method += StringGenerator.getCollectionIteratorForLoopBegin(SIXTEEN_SPACE_INDENTATION, type + SPACE + name, name + OPEN_CLOSE_BRACKET_STRING);
        method += TWENTY_SPACE_INDENTATION + BOOLEAN_DATA_TYPE + SPACE + "flag" + SPACE + EQUAL + SPACE + FALSE + SEMI_COLON + NEW_LINE;
        // for app instance iterator
        method += StringGenerator.getCollectionIteratorForLoopBegin(TWENTY_SPACE_INDENTATION, type + SPACE + name + "2", APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
        // the content match leaf list attribute value matches
        method += StringGenerator.getIfConditionBegin(TWENTY_FOUR_SPACE_INDENTATION, name + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + name + "2" + CLOSE_PARENTHESIS);
        method += TWENTY_EIGHT_SPACE_INDENTATION + "flag" + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
        method += TWENTY_EIGHT_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + name + "2" + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + TWENTY_EIGHT_SPACE_INDENTATION + BREAK + SEMI_COLON + NEW_LINE;
        // the content match leaf list attribute value matches
        method += methodClose(TWENTY_FOUR_SPACE);
        // for app instance iterator
        method += methodClose(TWENTY_SPACE);
        // if the content match failed
        method += StringGenerator.getIfConditionBegin(TWENTY_SPACE_INDENTATION, "!flag");
        method += TWENTY_FOUR_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLON + NEW_LINE;
        method += // if flag == false
        methodClose(TWENTY_SPACE);
        // for instance iterator
        method += methodClose(SIXTEEN_SPACE);
    } else {
        /*if there is any app instance entry*/
        method += StringGenerator.getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + SPACE + NOT + EQUAL + SPACE + NULL + SPACE + AND_OPERATION + SPACE + NOT + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
        /*
             * loop all the query condition instance(s)
             */
        method += StringGenerator.getCollectionIteratorForLoopBegin(TWENTY_SPACE_INDENTATION, type + SPACE + name, name + OPEN_CLOSE_BRACKET_STRING);
        // loop all the app instance(s)
        method += StringGenerator.getCollectionIteratorForLoopBegin(TWENTY_FOUR_SPACE_INDENTATION, type + SPACE + name + "2", APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
        method += TWENTY_EIGHT_SPACE_INDENTATION + type + SPACE + "result = " + name + PERIOD + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + name + "2" + COMMA + SPACE + FALSE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
        method += TWENTY_EIGHT_SPACE_INDENTATION + "if (result != null) {" + NEW_LINE;
        method += THIRTY_TWO_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + "result" + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + TWENTY_EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
        // loop all the app instance(s)
        method += methodClose(TWENTY_FOUR_SPACE);
        // loop all the query condition instance(s)
        method += methodClose(TWENTY_SPACE);
        // if there is any app instance entry
        method += methodClose(SIXTEEN_SPACE);
    }
    method += TWELVE_SPACE_INDENTATION + "} else {" + NEW_LINE;
    if (isLeafList) {
        method += SIXTEEN_SPACE_INDENTATION + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
    }
    method += StringGenerator.getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + SPACE + NOT + EQUAL + SPACE + NULL + SPACE + AND_OPERATION + SPACE + NOT + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
    method = method + StringGenerator.getCollectionIteratorForLoopBegin(TWENTY_SPACE_INDENTATION, type + SPACE + name, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
    method = method + TWENTY_FOUR_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + name + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    // Close collection Iteration loop
    method += methodClose(TWENTY_SPACE);
    method += // close  if condition
    methodClose(SIXTEEN_SPACE);
    method += // close  else condition
    methodClose(TWELVE_SPACE);
    // close  else if condition
    method += methodClose(EIGHT_SPACE);
    return method;
}
#method_after
private static String getSubtreeFilteringForList(JavaAttributeInfo javaAttributeInfo, boolean isLeafList, YangNode node) {
    String capitalCaseName = getCapitalCase(javaAttributeInfo.getAttributeName());
    String name = javaAttributeInfo.getAttributeName();
    String type = javaAttributeInfo.getImportInfo().getClassInfo();
    String clsInfo = DEFAULT_CAPS + type;
    if (javaAttributeInfo.isQualifiedName()) {
        type = javaAttributeInfo.getImportInfo().getPkgInfo() + PERIOD + type;
        clsInfo = javaAttributeInfo.getImportInfo().getPkgInfo() + PERIOD + clsInfo;
    }
    String classCast = getOpenCloseParaWithValue(clsInfo) + SPACE;
    String cast = getOpenCloseParaWithValue(classCast + name);
    String resultString = cast + PERIOD + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + classCast + name + "2" + COMMA + SPACE + FALSE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    if (node != null && node instanceof YangChoice) {
        resultString = getReturnStringInCaseOfChoice(node);
    }
    /*
         * If select all schema child
         */
    String method = getIfConditionBegin(EIGHT_SPACE_INDENTATION, IS_SELECT_ALL_SCHEMA_CHILD_FLAG);
    method = method + getCollectionIteratorForLoopBegin(TWELVE_SPACE_INDENTATION, type + SPACE + name, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
    method = method + SIXTEEN_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + name + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    // Close collection Iteration loop
    method += methodClose(TWELVE_SPACE);
    // If need to explicitly participate in query
    method += getElseIfConditionBegin(EIGHT_SPACE_INDENTATION, name + OPEN_CLOSE_BRACKET_STRING + SPACE + NOT + EQUAL + SPACE + NULL);
    if (!isLeafList) {
        method += TWELVE_SPACE_INDENTATION + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
    }
    // If there is any parameter in the query condition
    method += getIfConditionBegin(TWELVE_SPACE_INDENTATION, NOT + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
    if (isLeafList) {
        /*
             * If there is no app instance to perform content match
             */
        method += getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + SPACE + EQUAL + EQUAL + SPACE + NULL + SPACE + OR_OPERATION + SPACE + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
        method += TWENTY_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLON + NEW_LINE;
        method += methodClose(SIXTEEN_SPACE);
        // for instance iterator
        method += getCollectionIteratorForLoopBegin(SIXTEEN_SPACE_INDENTATION, type + SPACE + name, name + OPEN_CLOSE_BRACKET_STRING);
        method += TWENTY_SPACE_INDENTATION + BOOLEAN_DATA_TYPE + SPACE + "flag" + SPACE + EQUAL + SPACE + FALSE + SEMI_COLON + NEW_LINE;
        // for app instance iterator
        method += getCollectionIteratorForLoopBegin(TWENTY_SPACE_INDENTATION, type + SPACE + name + "2", APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
        // the content match leaf list attribute value matches
        method += getIfConditionBegin(TWENTY_FOUR_SPACE_INDENTATION, name + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + name + "2" + CLOSE_PARENTHESIS);
        method += TWENTY_EIGHT_SPACE_INDENTATION + "flag" + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
        method += TWENTY_EIGHT_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + name + "2" + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + TWENTY_EIGHT_SPACE_INDENTATION + BREAK + SEMI_COLON + NEW_LINE;
        // the content match leaf list attribute value matches
        method += methodClose(TWENTY_FOUR_SPACE);
        // for app instance iterator
        method += methodClose(TWENTY_SPACE);
        // if the content match failed
        method += getIfConditionBegin(TWENTY_SPACE_INDENTATION, "!flag");
        method += TWENTY_FOUR_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLON + NEW_LINE;
        method += // if flag == false
        methodClose(TWENTY_SPACE);
        // for instance iterator
        method += methodClose(SIXTEEN_SPACE);
    } else {
        /*if there is any app instance entry*/
        method += getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + SPACE + NOT + EQUAL + SPACE + NULL + SPACE + AND_OPERATION + SPACE + NOT + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
        /*
             * loop all the query condition instance(s)
             */
        method += getCollectionIteratorForLoopBegin(TWENTY_SPACE_INDENTATION, type + SPACE + name, name + OPEN_CLOSE_BRACKET_STRING);
        // loop all the app instance(s)
        method += getCollectionIteratorForLoopBegin(TWENTY_FOUR_SPACE_INDENTATION, type + SPACE + name + "2", APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
        method += TWENTY_EIGHT_SPACE_INDENTATION + type + SPACE + "result = " + resultString;
        method += TWENTY_EIGHT_SPACE_INDENTATION + "if (result != null) {" + NEW_LINE;
        method += THIRTY_TWO_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + "result" + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + TWENTY_EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
        // loop all the app instance(s)
        method += methodClose(TWENTY_FOUR_SPACE);
        // loop all the query condition instance(s)
        method += methodClose(TWENTY_SPACE);
        // if there is any app instance entry
        method += methodClose(SIXTEEN_SPACE);
    }
    method += TWELVE_SPACE_INDENTATION + "} else {" + NEW_LINE;
    if (isLeafList) {
        method += SIXTEEN_SPACE_INDENTATION + IS_ANY_SELECT_OR_CONTAINMENT_NODE_FLAG + SPACE + EQUAL + SPACE + TRUE + SEMI_COLON + NEW_LINE;
    }
    method += getIfConditionBegin(SIXTEEN_SPACE_INDENTATION, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + SPACE + NOT + EQUAL + SPACE + NULL + SPACE + AND_OPERATION + SPACE + NOT + APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING + PERIOD + IS_EMPTY);
    method = method + getCollectionIteratorForLoopBegin(TWENTY_SPACE_INDENTATION, type + SPACE + name, APP_INSTANCE + PERIOD + name + OPEN_CLOSE_BRACKET_STRING);
    method = method + TWENTY_FOUR_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + ADD_STRING + getCapitalCase(TO) + capitalCaseName + OPEN_PARENTHESIS + name + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    // Close collection Iteration loop
    method += methodClose(TWENTY_SPACE);
    method += // close  if condition
    methodClose(SIXTEEN_SPACE);
    method += // close  else condition
    methodClose(TWELVE_SPACE);
    // close  else if condition
    method += methodClose(EIGHT_SPACE);
    return method;
}
#end_block

#method_before
static String getAugmentableSubTreeFiltering() {
    return EIGHT_SPACE_INDENTATION + FOR + SPACE + OPEN_PARENTHESIS + OBJECT_STRING + SPACE + YANG_AUGMENTED_INFO_LOWER_CASE + SPACE + COLON + SPACE + THIS + PERIOD + YANG_AUGMENTED_INFO_MAP + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + VALUE + "s" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + OBJECT_STRING + SPACE + getSmallCase(YANG_AUGMENTED_OP_PARAM_INFO) + SPACE + EQUAL + SPACE + APP_INSTANCE + PERIOD + YANG_AUGMENTED_INFO_LOWER_CASE + OPEN_PARENTHESIS + YANG_AUGMENTED_INFO_LOWER_CASE + PERIOD + GET_CLASS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + TWELVE_SPACE_INDENTATION + OBJECT + SPACE + PROCESS_SUBTREE_FILTERING + SEMI_COLON + NEW_LINE + TWELVE_SPACE_INDENTATION + TRY + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + "Class<?>[] interfaces = " + YANG_AUGMENTED_INFO_LOWER_CASE + ".getClass().getInterfaces();" + NEW_LINE + SIXTEEN_SPACE_INDENTATION + PROCESS_SUBTREE_FILTERING + SPACE + EQUAL + SPACE + YANG_AUGMENTED_INFO_LOWER_CASE + PERIOD + GET_CLASS + NEW_LINE + TWENTY_SPACE_INDENTATION + PERIOD + GET_METHOD + OPEN_PARENTHESIS + QUOTES + PROCESS_SUBTREE_FILTERING + QUOTES + COMMA + SPACE + "interfaces[0]" + CLOSE_PARENTHESIS + PERIOD + INVOKE + OPEN_PARENTHESIS + YANG_AUGMENTED_INFO_LOWER_CASE + COMMA + NEW_LINE + TWENTY_FOUR_SPACE_INDENTATION + getSmallCase(YANG_AUGMENTED_OP_PARAM_INFO) + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + PROCESS_SUBTREE_FILTERING + SPACE + NOT + EQUAL + SPACE + NULL + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWENTY_SPACE_INDENTATION + SUBTREE_FILTERING_RESULT_BUILDER + PERIOD + "add" + YANG_AUGMENTED_INFO + OPEN_PARENTHESIS + PROCESS_SUBTREE_FILTERING + COMMA + SPACE + PROCESS_SUBTREE_FILTERING + PERIOD + GET_CLASS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + CATCH + SPACE + OPEN_PARENTHESIS + NO_SUCH_METHOD_EXCEPTION + " | " + INVOCATION_TARGET_EXCEPTION + " | " + ILLEGAL_ACCESS_EXCEPTION + SPACE + EXCEPTION_VAR + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + CONTINUE + SEMI_COLON + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getAugmentableSubTreeFiltering() {
    return "        for (Object augmentInfo : this.yangAugmentedInfoMap()" + ".values()) {\n" + "            Object appInstanceInfo = appInstance.yangAugmentedInfo(" + "augmentInfo.getClass());\n" + "            if (appInstanceInfo == null) {\n" + "                subTreeFilteringResultBuilder.addYangAugmentedInfo(" + "augmentInfo, augmentInfo.getClass());\n" + "            } else {\n" + "                Object processSubtreeFiltering;\n" + "                try {\n" + "                    Class<?> augmentedClass = augmentInfo" + ".getClass();\n" + "                    processSubtreeFiltering = augmentInfo.getClass()" + ".getMethod(\"processSubtreeFiltering\", augmentedClass).invoke(" + "augmentInfo, appInstanceInfo);\n" + "                    if (processSubtreeFiltering != null) {\n" + "                        subTreeFilteringResultBuilder" + ".addYangAugmentedInfo(processSubtreeFiltering, processSubtreeFiltering.getClass());\n" + "                    }\n" + "                } catch (NoSuchMethodException |" + " InvocationTargetException | IllegalAccessException e) {\n" + "                    continue;\n" + "                }\n" + "            }\n" + "        }\n";
}
#end_block

#method_before
@Test
public void interFileIetf() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileietf";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/interfileietf/");
    utilManager.translateToJava(yangPluginConfig);
    deleteDirectory("target/interfileietf/");
}
#method_after
@Test
public void interFileIetf() throws IOException, ParserException, MojoExecutionException {
    deleteDirectory("target/interfileietf/");
    String searchDir = "src/test/resources/interfileietf";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/interfileietf/");
    utilManager.translateToJava(yangPluginConfig);
    deleteDirectory("target/interfileietf/");
}
#end_block

#method_before
public static String generateEnumAttributeString(String name, int value) {
    String enumName = getEnumJavaAttribute(name);
    return enumJavaDocForInnerClass(name) + EIGHT_SPACE_INDENTATION + enumName.toUpperCase() + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, value + EMPTY_STRING, null) + COMMA + NEW_LINE;
}
#method_after
public static String generateEnumAttributeString(String name, int value) {
    String enumName = getEnumJavaAttribute(name);
    return enumJavaDocForInnerClass(name) + EIGHT_SPACE_INDENTATION + enumName.toUpperCase() + getOpenCloseParaWithValue(value + EMPTY_STRING) + COMMA + NEW_LINE;
}
#end_block

#method_before
public static String generateEnumAttributeStringWithSchemaName(String name, int value) {
    String enumName = getEnumJavaAttribute(name);
    String str = value + COMMA + SPACE + QUOTES + name + QUOTES;
    return getJavaDoc(ENUM_ATTRIBUTE, name, false, null) + FOUR_SPACE_INDENTATION + enumName.toUpperCase() + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, str, null) + COMMA + NEW_LINE;
}
#method_after
public static String generateEnumAttributeStringWithSchemaName(String name, int value) {
    String enumName = getEnumJavaAttribute(name);
    String str = value + COMMA + SPACE + QUOTES + name + QUOTES;
    return getJavaDoc(ENUM_ATTRIBUTE, name, false, null) + FOUR_SPACE_INDENTATION + enumName.toUpperCase() + getOpenCloseParaWithValue(str) + COMMA + NEW_LINE;
}
#end_block

#method_before
static String getNewInstance(String returnType, String varName, String space, String value) {
    return space + returnType + SPACE + varName + SPACE + EQUAL + SPACE + NEW + SPACE + returnType + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, value, null) + signatureClose();
}
#method_after
static String getNewInstance(String returnType, String varName, String space, String value) {
    return space + returnType + SPACE + varName + SPACE + EQUAL + SPACE + NEW + SPACE + returnType + getOpenCloseParaWithValue(value) + signatureClose();
}
#end_block

#method_before
static String methodBody(MethodBodyTypes type, String paraName, String methodName, String space, String prefix, String paramType, boolean isBuilderSetter, String setterVal) {
    StringBuilder builder = new StringBuilder();
    String body;
    String cond;
    switch(type) {
        case GETTER:
            return getReturnString(paraName, space);
        case SETTER:
            if (setterVal == null) {
                setterVal = paraName;
            }
            body = space + THIS + PERIOD + paraName + SPACE + EQUAL + SPACE + setterVal + signatureClose();
            builder.append(body);
            if (isBuilderSetter) {
                body = getReturnString(THIS + signatureClose(), space);
                builder.append(body);
            }
            return builder.toString();
        case BUILD:
            return getReturnString(NEW + SPACE + paraName + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, THIS, null) + signatureClose(), space);
        case CONSTRUCTOR:
            return space + THIS + PERIOD + paraName + SPACE + EQUAL + SPACE + BUILDER_LOWER_CASE + OBJECT + PERIOD + prefix + methodName + brackets(OPEN_CLOSE_BRACKET, null, null) + signatureClose();
        case DEFAULT_CONSTRUCTOR:
            return EMPTY_STRING;
        case ADD_TO_LIST:
            return space + getIfConditionForAddToListMethod(paraName) + space + paraName + brackets(OPEN_CLOSE_BRACKET, null, null) + PERIOD + ADD_STRING + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, VALUE, null) + signatureClose() + getReturnString(THIS + signatureClose(), space);
        case AUGMENTED_MAP_ADD:
            return space + YANG_AUGMENTED_INFO_MAP + PERIOD + PUT + OPEN_PARENTHESIS + CLASS + OBJECT_STRING + COMMA + SPACE + VALUE + CLOSE_PARENTHESIS + signatureClose();
        case AUGMENTED_MAP_GET_VALUE:
            return getReturnString(YANG_AUGMENTED_INFO_MAP + PERIOD + GET + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, CLASS + OBJECT_STRING, null) + signatureClose(), space);
        case AUGMENTED_MAP_GETTER:
            return getReturnString(YANG_AUGMENTED_INFO_MAP + signatureClose(), space);
        case MANAGER_METHODS:
            body = space + YANG_UTILS_TODO + NEW_LINE;
            builder.append(body);
            if (paramType != null) {
                body = getReturnString(parseTypeForReturnValue(paramType), space);
                builder.append(body).append(signatureClose());
            }
            return builder.toString();
        case OF_METHOD:
            return getReturnString(NEW + SPACE + paraName + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, VALUE, null) + signatureClose(), space);
        case TO_STRING:
            return getToStringMethodsAddString(space, paraName) + paraName + CLOSE_PARENTHESIS;
        case EQUALS_METHOD:
        default:
            return null;
    }
}
#method_after
static String methodBody(MethodBodyTypes type, String paraName, String methodName, String space, String prefix, String paramType, boolean isBuilderSetter, String setterVal) {
    StringBuilder builder = new StringBuilder();
    String body;
    String cond;
    switch(type) {
        case GETTER:
            return getReturnString(paraName, space);
        case SETTER:
            if (setterVal == null) {
                setterVal = paraName;
            }
            body = space + THIS + PERIOD + paraName + SPACE + EQUAL + SPACE + setterVal + signatureClose();
            builder.append(body);
            if (isBuilderSetter) {
                body = getReturnString(THIS + signatureClose(), space);
                builder.append(body);
            }
            return builder.toString();
        case BUILD:
            return getReturnString(NEW + SPACE + paraName + getOpenCloseParaWithValue(THIS) + signatureClose(), space);
        case CONSTRUCTOR:
            return space + THIS + PERIOD + paraName + SPACE + EQUAL + SPACE + BUILDER_LOWER_CASE + OBJECT + PERIOD + prefix + methodName + brackets(OPEN_CLOSE_BRACKET, null, null) + signatureClose();
        case DEFAULT_CONSTRUCTOR:
            return EMPTY_STRING;
        case ADD_TO_LIST:
            return space + getIfConditionForAddToListMethod(paraName) + space + paraName + brackets(OPEN_CLOSE_BRACKET, null, null) + PERIOD + ADD_STRING + getOpenCloseParaWithValue(VALUE) + signatureClose() + getReturnString(THIS + signatureClose(), space);
        case AUGMENTED_MAP_ADD:
            return space + YANG_AUGMENTED_INFO_MAP + PERIOD + PUT + OPEN_PARENTHESIS + CLASS + OBJECT_STRING + COMMA + SPACE + VALUE + CLOSE_PARENTHESIS + signatureClose();
        case AUGMENTED_MAP_GET_VALUE:
            return getReturnString(YANG_AUGMENTED_INFO_MAP + PERIOD + GET + getOpenCloseParaWithValue(CLASS + OBJECT_STRING) + signatureClose(), space);
        case AUGMENTED_MAP_GETTER:
            return getReturnString(YANG_AUGMENTED_INFO_MAP + signatureClose(), space);
        case MANAGER_METHODS:
            body = space + YANG_UTILS_TODO + NEW_LINE;
            builder.append(body);
            if (paramType != null) {
                body = getReturnString(parseTypeForReturnValue(paramType), space);
                builder.append(body).append(signatureClose());
            }
            return builder.toString();
        case OF_METHOD:
            return getReturnString(NEW + SPACE + paraName + getOpenCloseParaWithValue(VALUE) + signatureClose(), space);
        case TO_STRING:
            return getToStringMethodsAddString(space, paraName) + paraName + CLOSE_PARENTHESIS;
        case EQUALS_METHOD:
        default:
            return null;
    }
}
#end_block

#method_before
static String getReturnOfSubString() {
    return getReturnString(OF, TWELVE_SPACE_INDENTATION) + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, TMP_VAL, null) + signatureClose();
}
#method_after
static String getReturnOfSubString() {
    return getReturnString(OF, TWELVE_SPACE_INDENTATION) + getOpenCloseParaWithValue(TMP_VAL) + signatureClose();
}
#end_block

#method_before
static String getIfConditionBegin(String indentation, String condition) {
    return indentation + IF + SPACE + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, condition, EMPTY_STRING) + methodSignatureClose(CLASS_TYPE);
}
#method_after
static String getIfConditionBegin(String indentation, String condition) {
    return indentation + IF + SPACE + getOpenCloseParaWithValue(condition) + methodSignatureClose(CLASS_TYPE);
}
#end_block

#method_before
static String getStringBuilderAttr(String init, String space) {
    StringBuilder builder = new StringBuilder(space);
    builder.append(STRING_BUILDER).append(SPACE).append(STRING_BUILDER_VAR).append(SPACE).append(EQUAL).append(SPACE).append(NEW).append(SPACE).append(STRING_BUILDER).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, getQuotedString(init), null)).append(signatureClose());
    return builder.toString();
}
#method_after
static String getStringBuilderAttr(String init, String space) {
    StringBuilder builder = new StringBuilder(space);
    builder.append(STRING_BUILDER).append(SPACE).append(STRING_BUILDER_VAR).append(SPACE).append(EQUAL).append(SPACE).append(NEW).append(SPACE).append(STRING_BUILDER).append(getOpenCloseParaWithValue(getQuotedString(init))).append(signatureClose());
    return builder.toString();
}
#end_block

#method_before
static String getPatternQuoteString(String type) {
    return PATTERN + PERIOD + QUOTE_STRING + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, getQuotedString(type), null);
}
#method_after
static String getPatternQuoteString(String type) {
    return PATTERN + PERIOD + QUOTE_STRING + getOpenCloseParaWithValue(getQuotedString(type));
}
#end_block

#method_before
static String getSetValueParaCondition(int count) {
    return SET_VALUE_PARA + PERIOD + GET + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, count + EMPTY_STRING, null);
}
#method_after
static String getSetValueParaCondition(int count) {
    return SET_VALUE_PARA + PERIOD + GET + getOpenCloseParaWithValue(count + EMPTY_STRING);
}
#end_block

#method_before
static String getMoreObjectAttr(String name) {
    String cls = name + PERIOD + CLASS;
    StringBuilder attr = new StringBuilder(EIGHT_SPACE_INDENTATION);
    String[] array = { NEW_LINE };
    attr.append(MORE_OBJ_ATTR).append(GOOGLE_MORE_OBJECT_METHOD_STATIC_STRING).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, cls, null)).append(NEW_LINE).append(FOUR_SPACE_INDENTATION).append(trimAtLast(getOmitNullValueString(), array)).append(signatureClose());
    return attr.toString();
}
#method_after
static String getMoreObjectAttr(String name) {
    String cls = name + PERIOD + CLASS;
    StringBuilder attr = new StringBuilder(EIGHT_SPACE_INDENTATION);
    String[] array = { NEW_LINE };
    attr.append(MORE_OBJ_ATTR).append(GOOGLE_MORE_OBJECT_METHOD_STATIC_STRING).append(getOpenCloseParaWithValue(cls)).append(NEW_LINE).append(FOUR_SPACE_INDENTATION).append(trimAtLast(getOmitNullValueString(), array)).append(signatureClose());
    return attr.toString();
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        yangPlugin.setCodeGenerateForSbi(generateJavaFileForSbi.toLowerCase());
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (yangFileInfoSet == null || yangFileInfoSet.isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJarDependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(yangPlugin);
        // Serialize data model.
        serializeDataModel(outputDir, yangFileInfoSet, project, true);
        addToCompilationRoot(codeGenDir, project, context);
        copyYangFilesToTarget(yangFileInfoSet, outputDir, project);
    } catch (IOException | ParserException e) {
        String fileName = EMPTY_STRING;
        if (curYangFileInfo != null) {
            fileName = curYangFileInfo.getYangFileName();
        }
        try {
            translatorErrorHandler(rootNode, yangPlugin);
            deleteDirectory(codeGenDir + DEFAULT_PKG);
        } catch (IOException ex) {
            e.printStackTrace();
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e);
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        validateMavenVersion();
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        yangPlugin.setCodeGenerateForSbi(generateJavaFileForSbi.toLowerCase());
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (yangFileInfoSet == null || yangFileInfoSet.isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJarDependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(yangPlugin);
        // Serialize data model.
        serializeDataModel(outputDir, yangFileInfoSet, project, true);
        addToCompilationRoot(codeGenDir, project, context);
        copyYangFilesToTarget(yangFileInfoSet, outputDir, project);
    } catch (IOException | ParserException e) {
        String fileName = EMPTY_STRING;
        if (curYangFileInfo != null) {
            fileName = curYangFileInfo.getYangFileName();
        }
        try {
            translatorErrorHandler(rootNode, yangPlugin);
            deleteDirectory(codeGenDir + DEFAULT_PKG);
        } catch (IOException ex) {
            e.printStackTrace();
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e);
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    }
}
#end_block

#method_before
public static YangRangeRestriction processRangeRestriction(YangRangeRestriction refRangeRestriction, int lineNumber, int charPositionInLine, boolean hasReferredRestriction, String curRangeString, YangDataTypes effectiveType, String fileName) throws DataModelException {
    YangBuiltInDataTypeInfo<?> startValue;
    YangBuiltInDataTypeInfo<?> endValue;
    YangRangeRestriction rangeRestriction = new YangRangeRestriction();
    String rangeArgument = removeQuotesAndHandleConcat(curRangeString);
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String startInterval;
        String endInterval;
        YangRangeInterval rangeInterval = new YangRangeInterval();
        rangeInterval.setCharPosition(charPositionInLine);
        rangeInterval.setLineNumber(lineNumber);
        rangeInterval.setFileName(fileName);
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(INTERVAL));
        if (rangeBoundary.length > MAX_RANGE_BOUNDARY) {
            DataModelException dataModelException = new DataModelException("YANG file error : " + YangConstructType.getYangConstructType(RANGE_DATA) + " " + rangeArgument + " is not valid.");
            dataModelException.setLine(lineNumber);
            dataModelException.setCharPosition(charPositionInLine);
            throw dataModelException;
        }
        if (rangeBoundary.length == MIN_RANGE_BOUNDARY) {
            startInterval = rangeBoundary[0].trim();
            endInterval = rangeBoundary[0].trim();
        } else {
            startInterval = rangeBoundary[0].trim();
            endInterval = rangeBoundary[1].trim();
        }
        try {
            if (hasReferredRestriction && startInterval.equals(MIN_KEYWORD) && refRangeRestriction.getMinRestrictedValue() != null) {
                startValue = refRangeRestriction.getMinRestrictedValue();
            } else if (hasReferredRestriction && startInterval.equals(MAX_KEYWORD) && refRangeRestriction.getMaxRestrictedValue() != null) {
                startValue = refRangeRestriction.getMaxRestrictedValue();
            } else {
                startValue = getDataObjectFromString(startInterval, effectiveType);
            }
            if (hasReferredRestriction && endInterval.equals(MIN_KEYWORD) && refRangeRestriction.getMinRestrictedValue() != null) {
                endValue = refRangeRestriction.getMinRestrictedValue();
            } else if (hasReferredRestriction && endInterval.equals(MAX_KEYWORD) && refRangeRestriction.getMaxRestrictedValue() != null) {
                endValue = refRangeRestriction.getMaxRestrictedValue();
            } else {
                endValue = getDataObjectFromString(endInterval, effectiveType);
            }
        } catch (Exception e) {
            DataModelException dataModelException = new DataModelException(e.getMessage());
            dataModelException.setLine(lineNumber);
            dataModelException.setCharPosition(charPositionInLine);
            throw dataModelException;
        }
        rangeInterval.setStartValue(startValue);
        rangeInterval.setEndValue(endValue);
        try {
            rangeRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException dataModelException) {
            dataModelException.setLine(lineNumber);
            dataModelException.setCharPosition(charPositionInLine);
            throw dataModelException;
        }
    }
    return rangeRestriction;
}
#method_after
public static YangRangeRestriction processRangeRestriction(YangRangeRestriction refRr, int line, int position, boolean hasRefR, String curRange, YangDataTypes type, String fileName) throws DataModelException {
    return getRestriction(refRr, line, position, hasRefR, curRange, fileName, type, RANGE_DATA);
}
#end_block

#method_before
public static YangRangeRestriction processLengthRestriction(YangRangeRestriction refLengthRestriction, int lineNumber, int charPositionInLine, boolean hasReferredRestriction, String curLengthString, String fileName) throws DataModelException {
    YangBuiltInDataTypeInfo<?> startValue;
    YangBuiltInDataTypeInfo<?> endValue;
    YangRangeRestriction lengthRestriction = new YangRangeRestriction<>();
    String rangeArgument = removeQuotesAndHandleConcat(curLengthString);
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String startInterval;
        String endInterval;
        YangRangeInterval rangeInterval = new YangRangeInterval<>();
        rangeInterval.setCharPosition(charPositionInLine);
        rangeInterval.setLineNumber(lineNumber);
        rangeInterval.setFileName(fileName);
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(INTERVAL));
        if (rangeBoundary.length > MAX_RANGE_BOUNDARY) {
            DataModelException dataModelException = new DataModelException("YANG file error : " + YangConstructType.getYangConstructType(LENGTH_DATA) + " " + rangeArgument + " is not valid.");
            dataModelException.setLine(lineNumber);
            dataModelException.setCharPosition(charPositionInLine);
            throw dataModelException;
        }
        if (rangeBoundary.length == MIN_RANGE_BOUNDARY) {
            startInterval = rangeBoundary[0].trim();
            endInterval = rangeBoundary[0].trim();
        } else {
            startInterval = rangeBoundary[0].trim();
            endInterval = rangeBoundary[1].trim();
        }
        try {
            if (hasReferredRestriction && startInterval.equals(MIN_KEYWORD) && refLengthRestriction.getMinRestrictedValue() != null) {
                startValue = refLengthRestriction.getMinRestrictedValue();
            } else if (hasReferredRestriction && startInterval.equals(MAX_KEYWORD) && refLengthRestriction.getMaxRestrictedValue() != null) {
                startValue = refLengthRestriction.getMaxRestrictedValue();
            } else {
                startValue = getDataObjectFromString(startInterval, YangDataTypes.UINT64);
            }
            if (hasReferredRestriction && endInterval.equals(MIN_KEYWORD) && refLengthRestriction.getMinRestrictedValue() != null) {
                endValue = refLengthRestriction.getMinRestrictedValue();
            } else if (hasReferredRestriction && endInterval.equals(MAX_KEYWORD) && refLengthRestriction.getMaxRestrictedValue() != null) {
                endValue = refLengthRestriction.getMaxRestrictedValue();
            } else {
                endValue = getDataObjectFromString(endInterval, YangDataTypes.UINT64);
            }
        } catch (Exception e) {
            DataModelException dataModelException = new DataModelException(e.getMessage());
            dataModelException.setLine(lineNumber);
            dataModelException.setCharPosition(charPositionInLine);
            throw dataModelException;
        }
        rangeInterval.setStartValue(startValue);
        rangeInterval.setEndValue(endValue);
        try {
            lengthRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException dataModelException) {
            dataModelException.setLine(lineNumber);
            dataModelException.setCharPosition(charPositionInLine);
            throw dataModelException;
        }
    }
    return lengthRestriction;
}
#method_after
public static YangRangeRestriction processLengthRestriction(YangRangeRestriction refLr, int line, int position, boolean hasRefR, String curLenStr, String fileName) throws DataModelException {
    return getRestriction(refLr, line, position, hasRefR, curLenStr, fileName, UINT64, LENGTH_DATA);
}
#end_block

#method_before
private static String removeQuotesAndHandleConcat(String yangStringData) {
    yangStringData = yangStringData.replace("\"", EMPTY_STRING);
    String[] tmpData = yangStringData.split(Pattern.quote(ADD));
    StringBuilder builder = new StringBuilder();
    for (String yangString : tmpData) {
        builder.append(yangString);
    }
    return builder.toString();
}
#method_after
private static String removeQuotesAndHandleConcat(String yangStringData) {
    yangStringData = yangStringData.replace(QUOTE, EMPTY_STRING);
    String[] tmpData = yangStringData.split(quote(ADD));
    StringBuilder builder = new StringBuilder();
    for (String yangString : tmpData) {
        builder.append(yangString);
    }
    return builder.toString();
}
#end_block

#method_before
private static String getValidPattern(GeneratedYangParser.PatternStatementContext ctx) {
    String userInputPattern = ctx.string().getText().replace("\"", EMPTY_STRING);
    try {
        Pattern.compile(userInputPattern);
    } catch (PatternSyntaxException exception) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(PATTERN_DATA) + " name " + ctx.string().getText() + " is not a valid regular expression");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    return userInputPattern;
}
#method_after
private static String getValidPattern(GeneratedYangParser.PatternStatementContext ctx) {
    String userInputPattern = removeQuotesAndHandleConcat(ctx.string().getText());
    userInputPattern = userInputPattern.replaceAll("[\'\"]", EMPTY_STRING);
    try {
        Pattern.compile(userInputPattern);
    } catch (PatternSyntaxException exception) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(PATTERN_DATA) + " name " + ctx.string().getText() + " is not a valid regular expression");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    return userInputPattern;
}
#end_block

#method_before
private static String getSetter(String className, String name, String type, int genType, boolean isTypeNull, boolean isList) {
    StringBuilder builder = new StringBuilder();
    if (genType == GENERATE_SERVICE_AND_MANAGER) {
        // Append method signature.
        builder.append(methodSignature(getCapitalCase(name), SET_METHOD_PREFIX, PUBLIC, name, VOID, type, CLASS_TYPE)).append(methodBody(MANAGER_METHODS, null, null, EIGHT_SPACE_INDENTATION, null, null, false, null)).append(methodClose(FOUR_SPACE));
        return builder.toString();
    }
    if (genType == GENERATE_EVENT_SUBJECT_CLASS) {
        builder.append(methodSignature(name, EMPTY_STRING, PUBLIC, name, VOID, type, CLASS_TYPE)).append(methodBody(SETTER, name, name, EIGHT_SPACE_INDENTATION, null, null, false, null)).append(methodClose(FOUR_SPACE));
        return builder.toString();
    }
    builder.append(methodSignature(name, EMPTY_STRING, PUBLIC, name, getCapitalCase(className) + BUILDER, type, CLASS_TYPE));
    if (!isTypeNull && !isList) {
        builder.append(getValueLeafSetString(name));
    } else {
        builder.append(EMPTY_STRING);
    }
    // Append method body.
    builder.append(methodBody(SETTER, name, name, EIGHT_SPACE_INDENTATION, null, null, true, null)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#method_after
private static String getSetter(String className, String name, String type, int genType, boolean isTypeNull, boolean isList) {
    StringBuilder builder = new StringBuilder();
    if (genType == GENERATE_SERVICE_AND_MANAGER) {
        // Append method signature.
        builder.append(methodSignature(getCapitalCase(name), SET_METHOD_PREFIX, PUBLIC, name, VOID, type, CLASS_TYPE)).append(methodBody(MANAGER_METHODS, null, null, EIGHT_SPACE_INDENTATION, null, null, false, null)).append(methodClose(FOUR_SPACE));
        return builder.toString();
    }
    if (genType == GENERATE_EVENT_SUBJECT_CLASS) {
        builder.append(methodSignature(name, EMPTY_STRING, PUBLIC, name, VOID, type, CLASS_TYPE)).append(methodBody(SETTER, name, name, EIGHT_SPACE_INDENTATION, null, null, false, null)).append(methodClose(FOUR_SPACE));
        return builder.toString();
    }
    builder.append(methodSignature(name, EMPTY_STRING, PUBLIC, name, getCapitalCase(className) + BUILDER, type, CLASS_TYPE));
    if (!isTypeNull && !isList) {
        builder.append(getLeafFlagSetString(name, VALUE_LEAF, EIGHT_SPACE_INDENTATION, SET_METHOD_PREFIX)).append(signatureClose());
    } else {
        builder.append(EMPTY_STRING);
    }
    // Append method body.
    builder.append(methodBody(SETTER, name, name, EIGHT_SPACE_INDENTATION, null, null, true, null)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
private static String getParsedSubString(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttr) {
    String targetDataType = getReturnType(attr);
    YangDataTypes types = fromStringAttr.getAttributeType().getDataType();
    StringBuilder method = new StringBuilder();
    switch(types) {
        case BITS:
            return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + getCapitalCase(attr.getAttributeName()) + PERIOD + FROM_STRING_METHOD_NAME + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, FROM_STRING_PARAM_NAME, null) + signatureClose();
        case BINARY:
            return method.append(targetDataType).append(SPACE).append(TMP_VAL).append(SPACE).append(EQUAL).append(SPACE).append(geStringConverterForBinary(FROM_STRING_PARAM_NAME)).append(signatureClose()).toString();
        default:
            return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + getParseFromStringMethod(targetDataType, fromStringAttr.getAttributeType()) + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, FROM_STRING_PARAM_NAME, null) + signatureClose();
    }
}
#method_after
private static String getParsedSubString(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttr) {
    String targetDataType = getReturnType(attr);
    YangDataTypes types = fromStringAttr.getAttributeType().getDataType();
    StringBuilder method = new StringBuilder();
    switch(types) {
        case BITS:
            return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + getCapitalCase(attr.getAttributeName()) + PERIOD + FROM_STRING_METHOD_NAME + getOpenCloseParaWithValue(FROM_STRING_PARAM_NAME) + signatureClose();
        case BINARY:
            return method.append(targetDataType).append(SPACE).append(TMP_VAL).append(SPACE).append(EQUAL).append(SPACE).append(geStringConverterForBinary(FROM_STRING_PARAM_NAME)).append(signatureClose()).toString();
        default:
            return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + getParseFromStringMethod(targetDataType, fromStringAttr.getAttributeType()) + getOpenCloseParaWithValue(FROM_STRING_PARAM_NAME) + signatureClose();
    }
}
#end_block

#method_before
private static String geStringConverterForBinary(String var) {
    StringBuilder builder = new StringBuilder();
    return builder.append(BASE64).append(PERIOD).append(GET_DECODER).append(OPEN_CLOSE_BRACKET_STRING).append(PERIOD).append(DECODE).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, var, null)).toString();
}
#method_after
private static String geStringConverterForBinary(String var) {
    StringBuilder builder = new StringBuilder();
    return builder.append(BASE64).append(PERIOD).append(GET_DECODER).append(OPEN_CLOSE_BRACKET_STRING).append(PERIOD).append(DECODE).append(getOpenCloseParaWithValue(var)).toString();
}
#end_block

#method_before
private static String getToStringForBinary(String var) {
    StringBuilder builder = new StringBuilder();
    return builder.append(BASE64).append(PERIOD).append(GET_ENCODER).append(OPEN_CLOSE_BRACKET_STRING).append(PERIOD).append(ENCODE_TO_STRING).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, var, null)).toString();
}
#method_after
private static String getToStringForBinary(String var) {
    StringBuilder builder = new StringBuilder();
    return builder.append(BASE64).append(PERIOD).append(GET_ENCODER).append(OPEN_CLOSE_BRACKET_STRING).append(PERIOD).append(ENCODE_TO_STRING).append(getOpenCloseParaWithValue(var)).toString();
}
#end_block

#method_before
private static String getTypeConstructorString(String type, String name, String className, int genType, int count) {
    StringBuilder builder = new StringBuilder();
    builder.append(methodSignature(className, EMPTY_STRING, PUBLIC, name, null, type, CLASS_TYPE));
    if (genType == GENERATE_UNION_CLASS) {
        builder.append(EIGHT_SPACE_INDENTATION).append(SET_VALUE_PARA).append(PERIOD).append(SET_METHOD_PREFIX).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, count + EMPTY_STRING, null)).append(signatureClose());
    }
    builder.append(methodBody(SETTER, name, null, EIGHT_SPACE_INDENTATION, EMPTY_STRING, null, false, null)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#method_after
private static String getTypeConstructorString(String type, String name, String className, int genType, int count) {
    StringBuilder builder = new StringBuilder();
    builder.append(methodSignature(className, EMPTY_STRING, PUBLIC, name, null, type, CLASS_TYPE));
    if (genType == GENERATE_UNION_CLASS) {
        builder.append(EIGHT_SPACE_INDENTATION).append(SET_VALUE_PARA).append(PERIOD).append(SET_METHOD_PREFIX).append(getOpenCloseParaWithValue(count + EMPTY_STRING)).append(signatureClose());
    }
    builder.append(methodBody(SETTER, name, null, EIGHT_SPACE_INDENTATION, EMPTY_STRING, null, false, null)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
private static String getTypeConstructorString(String type, String attr1, String attr2, String className, ValidatorTypeForUnionTypes validatorType, boolean addInt, int count) {
    StringBuilder constructor = new StringBuilder(methodSignature(className, EMPTY_STRING, PUBLIC, attr1, null, type, CLASS_TYPE)).append(EIGHT_SPACE_INDENTATION).append(SET_VALUE_PARA).append(PERIOD).append(SET_METHOD_PREFIX).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, count + EMPTY_STRING, null)).append(signatureClose()).append(ifConditionForIntInTypeDefConstructor(validatorType, addInt, attr1)).append(methodBody(SETTER, attr1, null, TWELVE_SPACE_INDENTATION, EMPTY_STRING, null, false, attr1));
    String str = EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    constructor.append(str).append(methodBody(SETTER, attr2, null, TWELVE_SPACE_INDENTATION, EMPTY_STRING, null, false, attr1)).append(methodClose(FOUR_SPACE)).append(methodClose(EIGHT_SPACE));
    return constructor.toString();
}
#method_after
private static String getTypeConstructorString(String type, String attr1, String attr2, String className, ValidatorTypeForUnionTypes validatorType, boolean addInt, int count) {
    StringBuilder constructor = new StringBuilder(methodSignature(className, EMPTY_STRING, PUBLIC, attr1, null, type, CLASS_TYPE)).append(EIGHT_SPACE_INDENTATION).append(SET_VALUE_PARA).append(PERIOD).append(SET_METHOD_PREFIX).append(getOpenCloseParaWithValue(count + EMPTY_STRING)).append(signatureClose()).append(ifConditionForIntInTypeDefConstructor(validatorType, addInt, attr1)).append(methodBody(SETTER, attr1, null, TWELVE_SPACE_INDENTATION, EMPTY_STRING, null, false, attr1));
    String str = EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    constructor.append(str).append(methodBody(SETTER, attr2, null, TWELVE_SPACE_INDENTATION, EMPTY_STRING, null, false, attr1)).append(methodClose(FOUR_SPACE)).append(methodClose(EIGHT_SPACE));
    return constructor.toString();
}
#end_block

#method_before
static String getEnumsOfValueMethod(String className, YangEnumeration enumeration, MethodBodyTypes type) {
    String name = getCapitalCase(className);
    StringBuilder builder = new StringBuilder(getJavaDoc(OF_METHOD, name + SPACE + FOR, false, null));
    // Switch statement.
    String sw = EIGHT_SPACE_INDENTATION + SWITCH + SPACE + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, VALUE, null) + methodSignatureClose(CLASS_TYPE);
    String str;
    switch(type) {
        case ENUM_METHOD_INT_VALUE:
            builder.append(getEnumValueMethodSignature(name, INT)).append(sw);
            for (YangEnum yangEnum : enumeration.getEnumSet()) {
                str = getEnumJavaAttribute(yangEnum.getNamedValue()).toUpperCase();
                builder.append(getEnumValueMethodCases(EMPTY_STRING + yangEnum.getValue(), str, name));
            }
            break;
        case ENUM_METHOD_STRING_VALUE:
            builder.append(getEnumValueMethodSignature(name, STRING_DATA_TYPE)).append(sw);
            for (YangEnum yangEnum : enumeration.getEnumSet()) {
                str = getEnumJavaAttribute(yangEnum.getNamedValue()).toUpperCase();
                builder.append(getEnumValueMethodCases(QUOTES + yangEnum.getNamedValue() + QUOTES, str, name));
            }
            break;
        default:
            return null;
    }
    String method = TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE;
    builder.append(method).append(getReturnString(NULL, SIXTEEN_SPACE_INDENTATION)).append(signatureClose()).append(methodClose(EIGHT_SPACE)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#method_after
static String getEnumsOfValueMethod(String className, YangEnumeration enumeration, MethodBodyTypes type) {
    String name = getCapitalCase(className);
    StringBuilder builder = new StringBuilder(getJavaDoc(OF_METHOD, name + SPACE + FOR, false, null));
    // Switch statement.
    String sw = EIGHT_SPACE_INDENTATION + SWITCH + SPACE + getOpenCloseParaWithValue(VALUE) + methodSignatureClose(CLASS_TYPE);
    String str;
    switch(type) {
        case ENUM_METHOD_INT_VALUE:
            builder.append(getEnumValueMethodSignature(name, INT)).append(sw);
            for (YangEnum yangEnum : enumeration.getEnumSet()) {
                str = getEnumJavaAttribute(yangEnum.getNamedValue()).toUpperCase();
                builder.append(getEnumValueMethodCases(EMPTY_STRING + yangEnum.getValue(), str, name));
            }
            break;
        case ENUM_METHOD_STRING_VALUE:
            builder.append(getEnumValueMethodSignature(name, STRING_DATA_TYPE)).append(sw);
            for (YangEnum yangEnum : enumeration.getEnumSet()) {
                str = getEnumJavaAttribute(yangEnum.getNamedValue()).toUpperCase();
                builder.append(getEnumValueMethodCases(QUOTES + yangEnum.getNamedValue() + QUOTES, str, name));
            }
            break;
        default:
            return null;
    }
    String method = TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE;
    builder.append(method).append(getReturnString(NULL, SIXTEEN_SPACE_INDENTATION)).append(signatureClose()).append(methodClose(EIGHT_SPACE)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
static String getRangeValidatorMethodForUnion(String type) {
    String newType;
    if (type.contentEquals(BIG_INTEGER)) {
        newType = LONG;
    } else {
        newType = INT;
    }
    StringBuilder builder = new StringBuilder(generateForValidatorMethod());
    String var = getSmallCase(BIG_INTEGER);
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put(MIN_RANGE, type);
    map.put(MAX_RANGE, type);
    map.put(VALUE, newType);
    builder.append(multiAttrMethodSignature(VALIDATE_RANGE, EMPTY_STRING, PRIVATE, BOOLEAN_DATA_TYPE, map, CLASS_TYPE));
    if (type.contentEquals(BIG_INTEGER)) {
        // Create new instance of big integer.
        builder.append(getNewInstance(BIG_INTEGER, var, EIGHT_SPACE_INDENTATION, QUOTES + SPACE + QUOTES + SPACE + ADD + SPACE + VALUE)).append(getReturnString(var, EIGHT_SPACE_INDENTATION)).append(getCompareToString()).append(ifAndAndCondition(// Add == condition
        ifEqualEqualCondition(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, MIN_RANGE, null), ONE), var)).append(getCompareToString()).append(ifEqualEqualCondition(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, MAX_RANGE, null), ONE)).append(signatureClose());
    } else {
        builder.append(getReturnString(VALUE, EIGHT_SPACE_INDENTATION)).append(getGreaterThanCondition()).append(ifAndAndCondition(MIN_RANGE, VALUE)).append(getLesserThanCondition()).append(MAX_RANGE).append(signatureClose());
    }
    builder.append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#method_after
static String getRangeValidatorMethodForUnion(String type) {
    String newType;
    if (type.contentEquals(BIG_INTEGER)) {
        newType = LONG;
    } else {
        newType = INT;
    }
    StringBuilder builder = new StringBuilder(generateForValidatorMethod());
    String var = getSmallCase(BIG_INTEGER);
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put(MIN_RANGE, type);
    map.put(MAX_RANGE, type);
    map.put(VALUE, newType);
    builder.append(multiAttrMethodSignature(VALIDATE_RANGE, EMPTY_STRING, PRIVATE, BOOLEAN_DATA_TYPE, map, CLASS_TYPE));
    if (type.contentEquals(BIG_INTEGER)) {
        // Create new instance of big integer.
        builder.append(getNewInstance(BIG_INTEGER, var, EIGHT_SPACE_INDENTATION, QUOTES + SPACE + QUOTES + SPACE + ADD + SPACE + VALUE)).append(getReturnString(var, EIGHT_SPACE_INDENTATION)).append(getCompareToString()).append(ifAndAndCondition(// Add == condition
        ifEqualEqualCondition(getOpenCloseParaWithValue(MIN_RANGE), ONE), var)).append(getCompareToString()).append(ifEqualEqualCondition(getOpenCloseParaWithValue(MAX_RANGE), ONE)).append(signatureClose());
    } else {
        builder.append(getReturnString(VALUE, EIGHT_SPACE_INDENTATION)).append(getGreaterThanCondition()).append(ifAndAndCondition(MIN_RANGE, VALUE)).append(getLesserThanCondition()).append(MAX_RANGE).append(signatureClose());
    }
    builder.append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
private static String getFromStringForBits(String bitClassName) {
    StringBuilder sBuild = new StringBuilder();
    sBuild.append(methodSignature(FROM_STRING_METHOD_NAME, null, PUBLIC + SPACE + STATIC, FROM_STRING_PARAM_NAME, BIT_SET, STRING_DATA_TYPE, CLASS_TYPE)).append(EIGHT_SPACE_INDENTATION).append(getBitSetAttr(EMPTY_STRING));
    // Split the input string and check each bit name falls in configured yang file
    sBuild.append(EIGHT_SPACE_INDENTATION).append(STRING_DATA_TYPE).append(SQUARE_BRACKETS).append(SPACE).append(BIT_NAMES_VAR).append(SPACE).append(EQUAL).append(SPACE).append(FROM_STRING_PARAM_NAME).append(PERIOD).append(TRIM_STRING).append(OPEN_CLOSE_BRACKET_STRING).append(PERIOD).append(SPLIT_STRING).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, getPatternQuoteString(SPACE), null)).append(signatureClose()).append(getForLoopString(EIGHT_SPACE_INDENTATION, STRING_DATA_TYPE, BIT_NAME_VAR, BIT_NAMES_VAR));
    String small = getSmallCase(bitClassName);
    sBuild.append(TWELVE_SPACE_INDENTATION).append(bitClassName).append(SPACE).append(small).append(SPACE).append(EQUAL).append(SPACE).append(bitClassName).append(PERIOD).append(OF).append(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, BIT_NAME_VAR, null)).append(signatureClose());
    String condition = small + SPACE + NOT + EQUAL + SPACE + NULL;
    sBuild.append(getIfConditionBegin(TWELVE_SPACE_INDENTATION, condition)).append(TWELVE_SPACE_INDENTATION).append(TMP_VAL).append(PERIOD).append(SET_METHOD_PREFIX).append(OPEN_PARENTHESIS).append(small).append(PERIOD).append(small).append(OPEN_CLOSE_BRACKET_STRING).append(CLOSE_PARENTHESIS).append(signatureClose()).append(methodClose(TWELVE_SPACE)).append(methodClose(EIGHT_SPACE));
    sBuild.append(getReturnString(TMP_VAL, EIGHT_SPACE_INDENTATION)).append(signatureClose()).append(methodClose(FOUR_SPACE));
    return sBuild.toString();
}
#method_after
private static String getFromStringForBits(String bitClassName) {
    StringBuilder sBuild = new StringBuilder();
    sBuild.append(methodSignature(FROM_STRING_METHOD_NAME, null, PUBLIC + SPACE + STATIC, FROM_STRING_PARAM_NAME, BIT_SET, STRING_DATA_TYPE, CLASS_TYPE)).append(EIGHT_SPACE_INDENTATION).append(getBitSetAttr(EMPTY_STRING));
    // Split the input string and check each bit name falls in configured yang file
    sBuild.append(EIGHT_SPACE_INDENTATION).append(STRING_DATA_TYPE).append(SQUARE_BRACKETS).append(SPACE).append(BIT_NAMES_VAR).append(SPACE).append(EQUAL).append(SPACE).append(FROM_STRING_PARAM_NAME).append(PERIOD).append(TRIM_STRING).append(OPEN_CLOSE_BRACKET_STRING).append(PERIOD).append(SPLIT_STRING).append(getOpenCloseParaWithValue(getPatternQuoteString(SPACE))).append(signatureClose()).append(getForLoopString(EIGHT_SPACE_INDENTATION, STRING_DATA_TYPE, BIT_NAME_VAR, BIT_NAMES_VAR));
    String small = getSmallCase(bitClassName);
    sBuild.append(TWELVE_SPACE_INDENTATION).append(bitClassName).append(SPACE).append(small).append(SPACE).append(EQUAL).append(SPACE).append(bitClassName).append(PERIOD).append(OF).append(getOpenCloseParaWithValue(BIT_NAME_VAR)).append(signatureClose());
    String condition = small + SPACE + NOT + EQUAL + SPACE + NULL;
    sBuild.append(getIfConditionBegin(TWELVE_SPACE_INDENTATION, condition)).append(TWELVE_SPACE_INDENTATION).append(TMP_VAL).append(PERIOD).append(SET_METHOD_PREFIX).append(OPEN_PARENTHESIS).append(small).append(PERIOD).append(small).append(OPEN_CLOSE_BRACKET_STRING).append(CLOSE_PARENTHESIS).append(signatureClose()).append(methodClose(TWELVE_SPACE)).append(methodClose(EIGHT_SPACE));
    sBuild.append(getReturnString(TMP_VAL, EIGHT_SPACE_INDENTATION)).append(signatureClose()).append(methodClose(FOUR_SPACE));
    return sBuild.toString();
}
#end_block

#method_before
private static String getToStringForSpecialType(YangType type, String name) {
    switch(type.getDataType()) {
        case INT8:
        case INT16:
        case INT32:
        case INT64:
        case UINT8:
        case UINT16:
        case UINT32:
            return STRING_DATA_TYPE + PERIOD + VALUE + OF_CAPS + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, name, null);
        case BINARY:
            return getToStringCall(getToStringForBinary(name));
        case BITS:
            return getCapitalCase(name) + PERIOD + TO_STRING_METHOD + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, name, null);
        case BOOLEAN:
        case EMPTY:
            return name + SPACE + QUESTION_MARK + SPACE + getQuotedString(TRUE) + SPACE + COLON + SPACE + getQuotedString(FALSE);
        case LEAFREF:
            YangLeafRef<?> lri = (YangLeafRef<?>) type.getDataTypeExtendedInfo();
            YangType<?> rt = lri.isInGrouping() ? null : lri.getEffectiveDataType();
            return rt == null ? getToStringCall(name) : getToStringForSpecialType(rt, name);
        case ENUMERATION:
        case INSTANCE_IDENTIFIER:
        case UINT64:
        case DECIMAL64:
        case DERIVED:
        case IDENTITYREF:
        case UNION:
            return getToStringCall(name);
        default:
            return name;
    }
}
#method_after
private static String getToStringForSpecialType(YangType type, String name) {
    switch(type.getDataType()) {
        case INT8:
        case INT16:
        case INT32:
        case INT64:
        case UINT8:
        case UINT16:
        case UINT32:
            return STRING_DATA_TYPE + PERIOD + VALUE + OF_CAPS + getOpenCloseParaWithValue(name);
        case BINARY:
            return getToStringCall(getToStringForBinary(name));
        case BITS:
            return getCapitalCase(name) + PERIOD + TO_STRING_METHOD + getOpenCloseParaWithValue(name);
        case BOOLEAN:
        case EMPTY:
            return name + SPACE + QUESTION_MARK + SPACE + getQuotedString(TRUE) + SPACE + COLON + SPACE + getQuotedString(FALSE);
        case LEAFREF:
            YangLeafRef<?> lri = (YangLeafRef<?>) type.getDataTypeExtendedInfo();
            YangType<?> rt = lri.isInGrouping() ? null : lri.getEffectiveDataType();
            return rt == null ? getToStringCall(name) : getToStringForSpecialType(rt, name);
        case ENUMERATION:
        case INSTANCE_IDENTIFIER:
        case UINT64:
        case DECIMAL64:
        case DERIVED:
        case IDENTITYREF:
        case UNION:
            return getToStringCall(name);
        default:
            return name;
    }
}
#end_block

#method_before
public boolean isValidFractionDigit() {
    return fractionDigit >= 1 && fractionDigit <= 18;
}
#method_after
public boolean isValidFractionDigit() {
    return fractionDigit >= MIN_FRACTION_DIGIT_RANGE && fractionDigit <= MAX_FRACTION_DIGIT_RANGE;
}
#end_block

#method_before
public void validateDecimal64() throws DataModelException {
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) getRangeRestrictedExtendedInfo();
    if (rangeRestriction != null) {
        // Check whether value is within provided range value
        ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
        boolean isMatched = false;
        while (rangeListIterator.hasNext()) {
            YangRangeInterval rangeInterval = rangeListIterator.next();
            rangeInterval.setCharPosition(getCharPosition());
            rangeInterval.setLineNumber(getLineNumber());
            rangeInterval.setFileName(getFileName());
            BigDecimal startValue = ((YangDecimal64) rangeInterval.getStartValue()).getValue();
            BigDecimal endValue = ((YangDecimal64) rangeInterval.getEndValue()).getValue();
            if (value.doubleValue() >= startValue.doubleValue() && value.doubleValue() <= endValue.doubleValue()) {
                isMatched = true;
                break;
            }
        }
        // If range is not matched then throw error
        if (!isMatched) {
            throw new DataModelException(getErrorMsg("YANG file error : decimal64 validation failed.", "decimal64", getLineNumber(), getCharPosition(), getFileName() + "\""));
        }
    } else {
        // Check value is in fraction-digits decimal64 value range
        if (!FractionDigits.isValueInDecimal64Range(value, getFractionDigit())) {
            throw new DataModelException(getErrorMsg("YANG file error : decimal64 validation failed.", "decimal64", getLineNumber(), getCharPosition(), getFileName() + "\""));
        }
    }
}
#method_after
public void validateDecimal64() throws DataModelException {
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) getRangeRestrictedExtendedInfo();
    if (rangeRestriction != null) {
        // Check whether value is within provided range value
        ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
        boolean isMatched = false;
        while (rangeListIterator.hasNext()) {
            YangRangeInterval rangeInterval = rangeListIterator.next();
            rangeInterval.setCharPosition(getCharPosition());
            rangeInterval.setLineNumber(getLineNumber());
            rangeInterval.setFileName(getFileName());
            BigDecimal startValue = ((YangDecimal64) rangeInterval.getStartValue()).getValue();
            BigDecimal endValue = ((YangDecimal64) rangeInterval.getEndValue()).getValue();
            if (value.compareTo(startValue) >= ZERO && value.compareTo(endValue) <= ZERO) {
                isMatched = true;
                break;
            }
        }
        // If range is not matched then throw error
        if (!isMatched) {
            throw new DataModelException(getErrorMsg("YANG file error : decimal64 validation failed.", "decimal64", getLineNumber(), getCharPosition(), getFileName() + "\""));
        }
    } else {
        // Check value is in fraction-digits decimal64 value range
        if (!FractionDigits.isValueInDecimal64Range(value, getFractionDigit())) {
            throw new DataModelException(getErrorMsg("YANG file error : decimal64 validation failed.", "decimal64", getLineNumber(), getCharPosition(), getFileName() + "\""));
        }
    }
}
#end_block

#method_before
protected static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList, YangPluginConfig config, YangNode parent) throws IOException {
    TempJavaBeanFragmentFiles tempFiles = getBeanFiles((JavaCodeGeneratorInfo) parent);
    JavaAttributeInfo attr = getCurNodeAsAttributeInTarget(curNode, parent, isList, tempFiles);
    tempFiles.addJavaSnippetInfoToApplicableTempFiles(attr, config);
}
#method_after
protected static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList, YangPluginConfig config, YangNode parent) throws IOException {
    TempJavaBeanFragmentFiles tempFiles = getBeanFiles((JavaCodeGeneratorInfo) parent);
    if (curNode instanceof YangChoice) {
        tempFiles.setAttrNode(curNode);
        for (JavaQualifiedTypeInfoTranslator info : getNodesImports(getChoiceChildNodes((YangChoice) curNode), config)) tempFiles.addToSubTreeImports(info);
    } else {
        tempFiles.setAttrNode(null);
    }
    JavaAttributeInfo attr = getCurNodeAsAttributeInTarget(curNode, parent, isList, tempFiles);
    tempFiles.addJavaSnippetInfoToApplicableTempFiles(attr, config);
}
#end_block

#method_before
public static JavaAttributeInfo getCurNodeAsAttributeInTarget(YangNode curNode, YangNode targetNode, boolean listNode, TempJavaFragmentFiles tempFiles) {
    JavaFileInfoTranslator translator = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String curNodeName = translator.getJavaName();
    if (curNodeName == null) {
        updateJavaFileInfo(curNode, null);
        curNodeName = translator.getJavaName();
    }
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access.
         */
    JavaQualifiedTypeInfoTranslator typeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase(curNodeName));
    if (!(targetNode instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException(getErrorMsg(INVALID_PARENT_NODE, curNode));
    }
    JavaImportData parentImportData = tempFiles.getJavaImportData();
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) targetNode).getJavaFileInfo();
    boolean qualified;
    if (tempFiles instanceof TempJavaServiceFragmentFiles && typeInfo.getClassInfo().contentEquals(SERVICE) || typeInfo.getClassInfo().contentEquals(getCapitalCase(fileInfo.getJavaName() + SERVICE))) {
        qualified = true;
    } else {
        String className;
        if (tempFiles instanceof TempJavaServiceFragmentFiles) {
            className = getCapitalCase(fileInfo.getJavaName()) + SERVICE;
        } else {
            className = getCapitalCase(fileInfo.getJavaName());
        }
        qualified = parentImportData.addImportInfo(typeInfo, className, fileInfo.getPackage());
    }
    boolean collectionSet = false;
    if (curNode instanceof YangList) {
        YangList yangList = (YangList) curNode;
        if (yangList.getCompilerAnnotation() != null && yangList.getCompilerAnnotation().getYangAppDataStructure() != null) {
            switch(yangList.getCompilerAnnotation().getYangAppDataStructure().getDataStructure()) {
                case QUEUE:
                    {
                        parentImportData.setQueueToImport(true);
                        collectionSet = true;
                        break;
                    }
                case SET:
                    {
                        parentImportData.setSetToImport(true);
                        collectionSet = true;
                        break;
                    }
                default:
                    {
                    // TODO : to be implemented
                    }
            }
        }
    }
    if (listNode && !collectionSet) {
        parentImportData.setIfListImported(true);
    }
    if (curNode instanceof YangList) {
        return getAttributeInfoForTheData(typeInfo, curNodeName, null, qualified, listNode, ((YangList) curNode).getCompilerAnnotation());
    }
    return getAttributeInfoForTheData(typeInfo, curNodeName, null, qualified, listNode);
}
#method_after
public static JavaAttributeInfo getCurNodeAsAttributeInTarget(YangNode curNode, YangNode targetNode, boolean listNode, TempJavaFragmentFiles tempFiles) {
    JavaFileInfoTranslator translator = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String curNodeName = translator.getJavaName();
    if (curNodeName == null) {
        updateJavaFileInfo(curNode, null);
        curNodeName = translator.getJavaName();
    }
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access.
         */
    JavaQualifiedTypeInfoTranslator typeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase(curNodeName));
    if (!(targetNode instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException(getErrorMsg(INVALID_PARENT_NODE, curNode));
    }
    JavaImportData parentImportData = tempFiles.getJavaImportData();
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) targetNode).getJavaFileInfo();
    boolean qualified;
    if (tempFiles instanceof TempJavaServiceFragmentFiles && typeInfo.getClassInfo().contentEquals(SERVICE) || typeInfo.getClassInfo().contentEquals(getCapitalCase(fileInfo.getJavaName() + SERVICE))) {
        qualified = true;
    } else {
        String className;
        if (tempFiles instanceof TempJavaServiceFragmentFiles) {
            className = getCapitalCase(fileInfo.getJavaName()) + SERVICE;
        } else {
            className = getCapitalCase(fileInfo.getJavaName());
        }
        qualified = parentImportData.addImportInfo(typeInfo, className, fileInfo.getPackage());
        if (!qualified && !(curNode instanceof YangChoice)) {
            addChildDefaultClassImportForSubTreeFilter(typeInfo.getPkgInfo(), typeInfo.getClassInfo(), tempFiles);
        }
    }
    boolean collectionSet = false;
    if (curNode instanceof YangList) {
        YangList yangList = (YangList) curNode;
        if (yangList.getCompilerAnnotation() != null && yangList.getCompilerAnnotation().getYangAppDataStructure() != null) {
            switch(yangList.getCompilerAnnotation().getYangAppDataStructure().getDataStructure()) {
                case QUEUE:
                    {
                        parentImportData.setQueueToImport(true);
                        collectionSet = true;
                        break;
                    }
                case SET:
                    {
                        parentImportData.setSetToImport(true);
                        collectionSet = true;
                        break;
                    }
                default:
                    {
                    // TODO : to be implemented
                    }
            }
        }
    }
    if (listNode && !collectionSet) {
        parentImportData.setIfListImported(true);
    }
    if (curNode instanceof YangList) {
        return getAttributeInfoForTheData(typeInfo, curNodeName, null, qualified, listNode, ((YangList) curNode).getCompilerAnnotation());
    }
    return getAttributeInfoForTheData(typeInfo, curNodeName, null, qualified, listNode);
}
#end_block

#method_before
private void addSubtreeFilteringForChildNode(JavaAttributeInfo attr) throws IOException {
    appendToFile(getSubtreeFilteringForChildNodeTempFileHandle, getSubtreeFilteringForNode(attr) + NEW_LINE);
}
#method_after
private void addSubtreeFilteringForChildNode(JavaAttributeInfo attr) throws IOException {
    appendToFile(getSubtreeFilteringForChildNodeTempFileHandle, getSubtreeFilteringForNode(attr, attrNode) + NEW_LINE);
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo, YangPluginConfig pluginConfig) throws IOException {
    isAttributePresent = true;
    String attrName = newAttrInfo.getAttributeName();
    boolean required = !attrName.equals(VALUE_LEAF) && !attrName.equals(SELECT_LEAF) && !attrName.equals(YANG_AUGMENTED_INFO_MAP);
    if (tempFlagSet(ATTRIBUTES_MASK)) {
        addAttribute(newAttrInfo);
    }
    if (tempFlagSet(GETTER_FOR_INTERFACE_MASK)) {
        addGetterForInterface(newAttrInfo);
    }
    if (tempFlagSet(SETTER_FOR_INTERFACE_MASK) && required) {
        addSetterForInterface(newAttrInfo);
    }
    if (tempFlagSet(SETTER_FOR_CLASS_MASK) && required) {
        addSetterImpl(newAttrInfo);
    }
    if (tempFlagSet(HASH_CODE_IMPL_MASK)) {
        addHashCodeMethod(newAttrInfo);
    }
    if (tempFlagSet(EQUALS_IMPL_MASK)) {
        addEqualsMethod(newAttrInfo);
    }
    if (tempFlagSet(TO_STRING_IMPL_MASK)) {
        addToStringMethod(newAttrInfo);
    }
    if (tempFlagSet(EDIT_CONTENT_MASK)) {
    // TODO: add implementation for edit content match.
    }
    boolean listAttr = newAttrInfo.isListAttr();
    if (tempFlagSet(ADD_TO_LIST_IMPL_MASK) && listAttr) {
        addAddToListImpl(newAttrInfo);
    }
    if (tempFlagSet(ADD_TO_LIST_INTERFACE_MASK) && listAttr) {
        addAddToListInterface(newAttrInfo);
    }
    YangType attrType = newAttrInfo.getAttributeType();
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_NODES_MASK) && attrType == null && !attrName.contains(OPERATION_TYPE_ATTRIBUTE) && required) {
        addSubtreeFilteringForChildNode(newAttrInfo);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_MASK) && !listAttr && attrType != null) {
        addSubTreeFilteringForLeaf(newAttrInfo);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK) && listAttr && attrType != null) {
        addSubtreeFilteringForLeafList(newAttrInfo);
    }
    if (tempFlagSet(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK) && !listAttr && attrType != null) {
        leafCount++;
        addLeafIdAttributes(newAttrInfo, leafCount);
    }
    if (!newAttrInfo.isIntConflict() && !newAttrInfo.isLongConflict() && !newAttrInfo.isShortConflict()) {
        if (tempFlagSet(GETTER_FOR_CLASS_MASK)) {
            addGetterImpl(newAttrInfo);
        }
        if (tempFlagSet(FROM_STRING_IMPL_MASK)) {
            JavaQualifiedTypeInfoTranslator typeInfo = getQualifiedInfoOfFromString(newAttrInfo, pluginConfig.getConflictResolver());
            /*
             * Create a new java attribute info with qualified information of
             * wrapper classes.
             */
            JavaAttributeInfo fromStringAttributeInfo = getAttributeInfoForTheData(typeInfo, newAttrInfo.getAttributeName(), attrType, getIsQualifiedAccessOrAddToImportList(typeInfo), false);
            addFromStringMethod(newAttrInfo, fromStringAttributeInfo);
        }
    }
}
#method_after
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo, YangPluginConfig pluginConfig) throws IOException {
    isAttributePresent = true;
    String attrName = newAttrInfo.getAttributeName();
    // Boolean flag for operation type attr info generation control.
    boolean required = !attrName.equals(VALUE_LEAF) && !attrName.equals(SELECT_LEAF) && !attrName.equals(YANG_AUGMENTED_INFO_MAP);
    // Boolean flag for subtree for nodes info generation control.
    boolean subTreeForChild = tempFlagSet(FILTER_CONTENT_MATCH_FOR_NODES_MASK) && newAttrInfo.getAttributeType() == null && !attrName.contains(OPERATION_TYPE_ATTRIBUTE) && required && !attrName.equals(SUBTREE_FILTERED);
    ;
    if (tempFlagSet(ATTRIBUTES_MASK)) {
        addAttribute(newAttrInfo);
    }
    if (tempFlagSet(GETTER_FOR_INTERFACE_MASK)) {
        addGetterForInterface(newAttrInfo);
    }
    if (tempFlagSet(SETTER_FOR_INTERFACE_MASK) && required) {
        addSetterForInterface(newAttrInfo);
    }
    if (tempFlagSet(SETTER_FOR_CLASS_MASK) && required) {
        addSetterImpl(newAttrInfo);
    }
    if (tempFlagSet(HASH_CODE_IMPL_MASK)) {
        addHashCodeMethod(newAttrInfo);
    }
    if (tempFlagSet(EQUALS_IMPL_MASK)) {
        addEqualsMethod(newAttrInfo);
    }
    if (tempFlagSet(TO_STRING_IMPL_MASK)) {
        addToStringMethod(newAttrInfo);
    }
    if (tempFlagSet(EDIT_CONTENT_MASK)) {
    // TODO: add implementation for edit content match.
    }
    boolean listAttr = newAttrInfo.isListAttr();
    if (tempFlagSet(ADD_TO_LIST_IMPL_MASK) && listAttr) {
        addAddToListImpl(newAttrInfo);
    }
    if (tempFlagSet(ADD_TO_LIST_INTERFACE_MASK) && listAttr) {
        addAddToListInterface(newAttrInfo);
    }
    YangType attrType = newAttrInfo.getAttributeType();
    if (subTreeForChild) {
        addSubtreeFilteringForChildNode(newAttrInfo);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_MASK) && !listAttr && attrType != null) {
        addSubTreeFilteringForLeaf(newAttrInfo);
    }
    if (tempFlagSet(FILTER_CONTENT_MATCH_FOR_LEAF_LIST_MASK) && listAttr && attrType != null) {
        addSubtreeFilteringForLeafList(newAttrInfo);
    }
    if (tempFlagSet(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK) && !listAttr && attrType != null) {
        leafCount++;
        addLeafIdAttributes(newAttrInfo, leafCount);
    }
    if (!newAttrInfo.isIntConflict() && !newAttrInfo.isLongConflict() && !newAttrInfo.isShortConflict()) {
        if (tempFlagSet(GETTER_FOR_CLASS_MASK)) {
            addGetterImpl(newAttrInfo);
        }
        if (tempFlagSet(FROM_STRING_IMPL_MASK)) {
            JavaQualifiedTypeInfoTranslator typeInfo = getQualifiedInfoOfFromString(newAttrInfo, pluginConfig.getConflictResolver());
            /*
             * Create a new java attribute info with qualified information of
             * wrapper classes.
             */
            JavaAttributeInfo fromStringAttributeInfo = getAttributeInfoForTheData(typeInfo, newAttrInfo.getAttributeName(), attrType, getIsQualifiedAccessOrAddToImportList(typeInfo), false);
            addFromStringMethod(newAttrInfo, fromStringAttributeInfo);
        }
    }
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = getBeanFiles(curNode).getJavaImportData().getImports();
    if (curNode instanceof YangAugmentableNode) {
        addImportsForAugmentableClass(imports, true, true, curNode);
    }
    createPackage(curNode);
    // Generate java code.
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        // Create interface file.
        interfaceJavaFileHandle = getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX));
        interfaceJavaFileHandle = generateInterfaceFile(interfaceJavaFileHandle, imports, curNode, isAttributePresent);
        // Create builder interface file.
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            builderInterfaceJavaFileHandle = getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX));
            builderInterfaceJavaFileHandle = generateBuilderInterfaceFile(builderInterfaceJavaFileHandle, curNode, isAttributePresent);
            /*
                     * Append builder interface file to interface file and
                     * close it.
                     */
            mergeJavaFiles(builderInterfaceJavaFileHandle, interfaceJavaFileHandle);
        }
        insertDataIntoJavaFile(interfaceJavaFileHandle, CLOSE_CURLY_BRACKET);
        validateLineLength(interfaceJavaFileHandle);
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, false, true, curNode);
        }
    }
    if (!curNode.isOpTypeReq() && curNode instanceof YangCase) {
        removeCaseParentImport(curNode, imports);
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & DEFAULT_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(imports, true);
            addArrayListImport(imports);
        }
        addBitsAndBase64Imports(curNode, imports);
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, true, false, curNode);
            if (curNode.isOpTypeReq()) {
                addInvocationExceptionImport(imports);
            }
        }
        sortImports(imports);
        // Create impl class file.
        implClassJavaFileHandle = getJavaFileHandle(getImplClassName(curNode));
        implClassJavaFileHandle = generateDefaultClassFile(implClassJavaFileHandle, curNode, isAttributePresent, imports);
        // Create builder class file.
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            builderClassJavaFileHandle = getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX));
            builderClassJavaFileHandle = generateBuilderClassFile(builderClassJavaFileHandle, curNode, isAttributePresent);
            // Append impl class to builder class and close it.
            mergeJavaFiles(builderClassJavaFileHandle, implClassJavaFileHandle);
        }
        insertDataIntoJavaFile(implClassJavaFileHandle, CLOSE_CURLY_BRACKET);
        validateLineLength(implClassJavaFileHandle);
    }
    // Close all the file handles.
    freeTemporaryResources(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = getBeanFiles(curNode).getJavaImportData().getImports();
    if (curNode instanceof YangAugmentableNode) {
        addImportsForAugmentableClass(imports, true, true, curNode);
    }
    createPackage(curNode);
    // Generate java code.
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        // Create interface file.
        interfaceJavaFileHandle = getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX));
        interfaceJavaFileHandle = generateInterfaceFile(interfaceJavaFileHandle, imports, curNode, isAttributePresent);
        // Create builder interface file.
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            builderInterfaceJavaFileHandle = getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX));
            builderInterfaceJavaFileHandle = generateBuilderInterfaceFile(builderInterfaceJavaFileHandle, curNode, isAttributePresent);
            /*
                     * Append builder interface file to interface file and
                     * close it.
                     */
            mergeJavaFiles(builderInterfaceJavaFileHandle, interfaceJavaFileHandle);
        }
        insertDataIntoJavaFile(interfaceJavaFileHandle, CLOSE_CURLY_BRACKET);
        validateLineLength(interfaceJavaFileHandle);
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, false, true, curNode);
        }
    }
    if (curNode.isOpTypeReq()) {
        addSubTreeImportStrings(imports);
    }
    if (curNode instanceof YangCase) {
        removeCaseParentImport(curNode, imports);
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & DEFAULT_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(imports, true);
            addArrayListImport(imports);
        }
        addBitsAndBase64Imports(curNode, imports);
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, true, false, curNode);
            if (curNode.isOpTypeReq()) {
                addInvocationExceptionImport(imports);
            }
        }
        sortImports(imports);
        // Create impl class file.
        implClassJavaFileHandle = getJavaFileHandle(getImplClassName(curNode));
        implClassJavaFileHandle = generateDefaultClassFile(implClassJavaFileHandle, curNode, isAttributePresent, imports);
        // Create builder class file.
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            builderClassJavaFileHandle = getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX));
            builderClassJavaFileHandle = generateBuilderClassFile(builderClassJavaFileHandle, curNode, isAttributePresent);
            // Append impl class to builder class and close it.
            mergeJavaFiles(builderClassJavaFileHandle, implClassJavaFileHandle);
        }
        insertDataIntoJavaFile(implClassJavaFileHandle, CLOSE_CURLY_BRACKET);
        validateLineLength(implClassJavaFileHandle);
    }
    // Close all the file handles.
    freeTemporaryResources(false);
}
#end_block

#method_before
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles translator = info.getTempJavaCodeFragmentFiles();
    if (info instanceof RpcNotificationContainer) {
        getBeanFiles(info).setRootNode(true);
        /*
             * Module / sub module node code generation.
             */
        if (info instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) info).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(info, config);
            }
        } else if (info instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) info).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(info, config);
            }
        }
    }
    if (info instanceof YangLeavesHolder) {
        YangLeavesHolder holder = (YangLeavesHolder) info;
        boolean isLeafPresent = holder.getListOfLeaf() != null && !holder.getListOfLeaf().isEmpty();
        boolean isLeafListPresent = holder.getListOfLeafList() != null && !holder.getListOfLeafList().isEmpty();
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        if (isLeafPresent || isLeafListPresent) {
            getBeanFiles(info).addCurNodeLeavesInfoToTempFiles((YangNode) info, config);
        }
        // Add value leaf flag attribute to temp file.
        if (isLeafPresent) {
            getBeanFiles(info).addValueLeafFlag(config, (YangNode) info);
        }
        if (((YangNode) info).isOpTypeReq()) {
            // Add operation type as an attribute.
            getBeanFiles(info).addOperationTypeToTempFiles((YangNode) info, config);
            if (isLeafPresent) {
                // Add select leaf flag attribute to temp file.
                getBeanFiles(info).addSelectLeafFlag(config);
            }
        }
    } else if (info instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        translator.addTypeInfoToTempFiles((YangTypeHolder) info, config);
    } else if (info instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        translator.getEnumTempFiles().addEnumAttributeToTempFiles((YangNode) info, config);
    } else if (!(info instanceof YangChoice)) {
        /*Do nothing, only the interface needs to be generated for choice*/
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
}
#method_after
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles translator = info.getTempJavaCodeFragmentFiles();
    if (info instanceof RpcNotificationContainer) {
        getBeanFiles(info).setRootNode(true);
        /*
             * event classes code generation.
             */
        updateNotificationNodeInfo(info, config);
    }
    if (info instanceof YangLeavesHolder) {
        if (info instanceof YangAugment) {
            getBeanFiles(info).addIsSubTreeFilteredFlag(config);
        }
        YangLeavesHolder holder = (YangLeavesHolder) info;
        boolean isLeafPresent = holder.getListOfLeaf() != null && !holder.getListOfLeaf().isEmpty();
        boolean isLeafListPresent = holder.getListOfLeafList() != null && !holder.getListOfLeafList().isEmpty();
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        if (isLeafPresent || isLeafListPresent) {
            getBeanFiles(info).addCurNodeLeavesInfoToTempFiles((YangNode) info, config);
        }
        // Add value leaf flag attribute to temp file.
        if (isLeafPresent) {
            getBeanFiles(info).addValueLeafFlag(config, (YangNode) info);
        }
        if (((YangNode) info).isOpTypeReq()) {
            // Add operation type as an attribute.
            getBeanFiles(info).addOperationTypeToTempFiles((YangNode) info, config);
            if (isLeafPresent) {
                // Add select leaf flag attribute to temp file.
                getBeanFiles(info).addSelectLeafFlag(config);
            }
        }
    } else if (info instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        translator.addTypeInfoToTempFiles((YangTypeHolder) info, config);
    } else if (info instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        translator.getEnumTempFiles().addEnumAttributeToTempFiles((YangNode) info, config);
    } else if (!(info instanceof YangChoice)) {
        /*Do nothing, only the interface needs to be generated for choice*/
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
}
#end_block

#method_before
private static void updateNotificationNodeInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles translator = info.getTempJavaCodeFragmentFiles();
    if (info instanceof YangJavaModuleTranslator) {
        for (YangNode notification : ((YangJavaModuleTranslator) info).getNotificationNodes()) {
            translator.getEventFragmentFiles().addJavaSnippetOfEvent(notification, config);
        }
    }
    if (info instanceof YangJavaSubModuleTranslator) {
        for (YangNode notification : ((YangJavaSubModuleTranslator) info).getNotificationNodes()) {
            translator.getEventFragmentFiles().addJavaSnippetOfEvent(notification, config);
        }
    }
}
#method_after
private static void updateNotificationNodeInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles tempFile = info.getTempJavaCodeFragmentFiles();
    for (YangNode notification : ((RpcNotificationContainer) info).getNotificationNodes()) {
        tempFile.getEventFragmentFiles().addJavaSnippetOfEvent(notification, config);
    }
}
#end_block

#method_before
public static JavaQualifiedTypeInfoTranslator getQualifierInfoForCasesParent(YangNode parent, YangPluginConfig config) {
    String parentName;
    String parentPkg;
    JavaFileInfoTranslator parentInfo;
    if (parent instanceof YangChoice) {
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    } else {
        parent = ((YangAugment) parent).getAugmentedNode();
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    }
    if (parentInfo.getPackage() != null) {
        parentName = getCapitalCase(parentInfo.getJavaName());
        parentPkg = parentInfo.getPackage();
    } else {
        parentName = getCapitalCase(getCamelCase(parent.getName(), config.getConflictResolver()));
        parentPkg = getNodesPackage(parent, config);
    }
    JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = new JavaQualifiedTypeInfoTranslator();
    qualifiedTypeInfo.setClassInfo(parentName);
    qualifiedTypeInfo.setPkgInfo(parentPkg);
    return qualifiedTypeInfo;
}
#method_after
private static JavaQualifiedTypeInfoTranslator getQualifierInfoForCasesParent(YangNode parent, YangPluginConfig config) {
    String parentName;
    String parentPkg;
    JavaFileInfoTranslator parentInfo;
    if (parent instanceof YangChoice) {
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    } else {
        parent = ((YangAugment) parent).getAugmentedNode();
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    }
    if (parentInfo.getPackage() != null) {
        parentName = getCapitalCase(parentInfo.getJavaName());
        parentPkg = parentInfo.getPackage();
    } else {
        parentName = getCapitalCase(getCamelCase(parent.getName(), config.getConflictResolver()));
        parentPkg = getNodesPackage(parent, config);
    }
    JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = new JavaQualifiedTypeInfoTranslator();
    qualifiedTypeInfo.setClassInfo(parentName);
    qualifiedTypeInfo.setPkgInfo(parentPkg);
    return qualifiedTypeInfo;
}
#end_block

#method_before
public static String getNodesPackage(YangNode node, YangPluginConfig config) {
    List<String> clsInfo = new ArrayList<>();
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, config));
        } else {
            clsInfo.add(getCamelCase(node.getName(), config.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getModuleNamespace(), module.getRevision(), config.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), config.getConflictResolver()));
    }
    pkg.append(EMPTY_STRING);
    int size = clsInfo.size();
    for (int i = size - 1; i >= 0; i--) {
        pkg.append(PERIOD).append(clsInfo.get(i));
    }
    return pkg.toString().toLowerCase();
}
#method_after
public static String getNodesPackage(YangNode node, YangPluginConfig config) {
    List<String> clsInfo = new ArrayList<>();
    String add = null;
    if (node instanceof YangCase) {
        YangNode parent = node.getParent();
        if (parent instanceof YangAugment) {
            add = getCamelCase(((YangAugment) parent).getAugmentedNode().getName(), null);
        }
    }
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, config));
        } else {
            clsInfo.add(getCamelCase(node.getName(), config.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getModuleNamespace(), module.getRevision(), config.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), config.getConflictResolver()));
    }
    if (add != null) {
        clsInfo.add(add);
    }
    clsInfo.add(getCamelCase(node.getName(), config.getConflictResolver()));
    int size = clsInfo.size();
    for (int i = size - 1; i > 0; i--) {
        pkg.append(PERIOD).append(clsInfo.get(i));
    }
    return pkg.toString().toLowerCase();
}
#end_block

#method_before
private static String getAugmentClassName(YangAugment augment, YangPluginConfig config) {
    YangNodeIdentifier identifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String name = getCapitalCase(getCamelCase(identifier.getName(), config.getConflictResolver()));
    if (identifier.getPrefix() != null) {
        return getCapitalCase(getCamelCase(AUGMENTED + HYPHEN + identifier.getPrefix(), config.getConflictResolver())) + name;
    }
    return AUGMENTED + name;
}
#method_after
private static String getAugmentClassName(YangAugment augment, YangPluginConfig config) {
    YangNodeIdentifier identifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String prefix = identifier.getPrefix();
    String idName = identifier.getName();
    StringBuilder name = new StringBuilder(AUGMENTED).append(HYPHEN);
    if (identifier.getPrefix() != null) {
        name.append(prefix).append(HYPHEN);
    }
    name.append(idName);
    return getCapitalCase(getCamelCase(name.toString(), config.getConflictResolver()));
}
#end_block

#method_before
private static void createAndAddEnum(String name, int value, YangEnumeration enumeration) {
    YangEnum yangEnum = new YangEnum();
    yangEnum.setNamedValue(name);
    yangEnum.setValue(value);
    try {
        enumeration.addEnumInfo(yangEnum);
    } catch (DataModelException e) {
        e.printStackTrace();
    }
}
#method_after
private static void createAndAddEnum(String name, int value, YangEnumeration enumeration) {
    YangEnum yangEnum = new YangEnum();
    yangEnum.setNamedValue(name);
    yangEnum.setValue(value);
    try {
        enumeration.addEnumInfo(yangEnum);
    } catch (DataModelException e) {
        LOG.error("failed to add enum in bits enum class " + e);
    }
}
#end_block

#method_before
public static void processPathEntry(TreeWalkListener listener, GeneratedYangParser.PathStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    // Checks the holder of path as leaf-ref, else throws error.
    if (curData instanceof YangLeafRef) {
        // Parsing the path and updating in leaf-ref path.
        validatePath(ctx.path().getText(), PATH_DATA, ctx, (YangLeafRef) curData);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY));
    }
}
#method_after
public static void processPathEntry(TreeWalkListener listener, PathStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    // Checks the holder of path as leaf-ref, else throws error.
    if (curData instanceof YangLeafRef) {
        // Parsing the path and updating in leaf-ref path.
        validatePath(ctx.path().getText(), PATH_DATA, ctx, (YangLeafRef) curData);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY));
    }
}
#end_block

#method_before
@Test
public void processSimplePathPredicate() throws IOException {
    String searchDir = "src/test/resources/pathpredicate/simple";
    utilMgr.createYangFileInfoSet(getYangFiles(searchDir));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    YangNode selfNode;
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
    Iterator<YangNode> nodeItr = utilMgr.getYangNodeSet().iterator();
    selfNode = nodeItr.next();
    // Gets the list node.
    YangList yangList = (YangList) selfNode.getChild();
    // Gets the container node.
    YangContainer container = (YangContainer) yangList.getNextSibling();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf ifName;
    YangLeaf address;
    YangLeaf name;
    Iterator<YangAtomicPath> pathItr;
    YangAtomicPath atomicPath;
    Iterator<YangPathPredicate> predicateItr;
    YangPathPredicate predicate;
    leafIterator = container.getListOfLeaf().listIterator();
    ifName = leafIterator.next();
    address = leafIterator.next();
    // Gets the address leaf's leaf-ref type.
    YangLeafRef<?> leafRef2 = (YangLeafRef) address.getDataType().getDataTypeExtendedInfo();
    pathItr = leafRef2.getAtomicPath().listIterator();
    atomicPath = pathItr.next();
    // Gets the path-predicate.
    predicateItr = atomicPath.getPathPredicatesList().listIterator();
    predicate = predicateItr.next();
    // Gets the left and right axis node in path-predicate.
    YangLeaf yangLeftLeaf = (YangLeaf) predicate.getLeftAxisNode();
    YangLeaf yangRightLeaf = (YangLeaf) predicate.getRightAxisNode();
    leafIterator = yangList.getListOfLeaf().listIterator();
    name = leafIterator.next();
    // Checks that right and left path-predicates are correct.
    assertThat(yangLeftLeaf, is(name));
    assertThat(yangRightLeaf, is(ifName));
}
#method_after
@Test
public void processSimplePathPredicate() throws IOException {
    utilMgr.createYangFileInfoSet(getYangFiles(DIR + "simple"));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    YangNode selfNode;
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
    Iterator<YangNode> nodeItr = utilMgr.getYangNodeSet().iterator();
    selfNode = nodeItr.next();
    // Gets the list node.
    YangList yangList = (YangList) selfNode.getChild();
    // Gets the container node.
    YangContainer container = (YangContainer) yangList.getNextSibling();
    leafItr = container.getListOfLeaf().listIterator();
    ifName = leafItr.next();
    address = leafItr.next();
    // Gets the address leaf's leaf-ref type.
    YangLeafRef<?> leafRef2 = (YangLeafRef) address.getDataType().getDataTypeExtendedInfo();
    pathItr = leafRef2.getAtomicPath().listIterator();
    atomicPath = pathItr.next();
    // Gets the path-predicate.
    predicateItr = atomicPath.getPathPredicatesList().listIterator();
    predicate = predicateItr.next();
    // Gets the left and right axis node in path-predicate.
    YangLeaf yangLeftLeaf = (YangLeaf) predicate.getLeftAxisNode();
    YangLeaf yangRightLeaf = (YangLeaf) predicate.getRightAxisNode();
    leafItr = yangList.getListOfLeaf().listIterator();
    name = leafItr.next();
    // Checks that right and left path-predicates are correct.
    assertThat(yangLeftLeaf, is(name));
    assertThat(yangRightLeaf, is(ifName));
}
#end_block

#method_before
@Test
public void processSimpleInterFilePathPredicate() throws IOException {
    String searchDir = "src/test/resources/pathpredicate/simpleinterfile";
    utilMgr.createYangFileInfoSet(getYangFiles(searchDir));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    YangModule selfNode;
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
    Iterator<YangNode> nodeItr = utilMgr.getYangNodeSet().iterator();
    YangNode rootNode = nodeItr.next();
    YangModule refNode;
    if (rootNode.getName().equals("ietf-network")) {
        selfNode = (YangModule) rootNode;
        refNode = (YangModule) nodeItr.next();
    } else {
        refNode = (YangModule) rootNode;
        selfNode = (YangModule) nodeItr.next();
    }
    // Gets the container node.
    YangContainer container = (YangContainer) selfNode.getChild();
    // Gets the list node.
    YangList yangList = (YangList) refNode.getChild();
    ListIterator<YangLeaf> leafItr;
    YangLeaf ifName;
    YangLeaf address;
    YangLeaf name;
    Iterator<YangAtomicPath> pathItr;
    YangAtomicPath atomicPath;
    Iterator<YangPathPredicate> predicateItr;
    YangPathPredicate predicate;
    leafItr = container.getListOfLeaf().listIterator();
    ifName = leafItr.next();
    address = leafItr.next();
    // Gets the address leaf's leaf-ref type.
    YangLeafRef<?> leafRef2 = (YangLeafRef) address.getDataType().getDataTypeExtendedInfo();
    pathItr = leafRef2.getAtomicPath().listIterator();
    atomicPath = pathItr.next();
    // Gets the path-predicate.
    predicateItr = atomicPath.getPathPredicatesList().listIterator();
    predicate = predicateItr.next();
    // Gets the left and right axis node in path-predicate.
    YangLeaf yangLeftLeaf = (YangLeaf) predicate.getLeftAxisNode();
    YangLeaf yangRightLeaf = (YangLeaf) predicate.getRightAxisNode();
    leafItr = yangList.getListOfLeaf().listIterator();
    name = leafItr.next();
    // Checks that right and left path-predicates are correct.
    assertThat(yangLeftLeaf, is(name));
    assertThat(yangRightLeaf, is(ifName));
}
#method_after
@Test
public void processSimpleInterFilePathPredicate() throws IOException {
    utilMgr.createYangFileInfoSet(getYangFiles(DIR + "simpleinterfile"));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    YangModule selfNode;
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
    Iterator<YangNode> nodeItr = utilMgr.getYangNodeSet().iterator();
    YangNode rootNode = nodeItr.next();
    YangModule refNode;
    if (rootNode.getName().equals("ietf-network")) {
        selfNode = (YangModule) rootNode;
        refNode = (YangModule) nodeItr.next();
    } else {
        refNode = (YangModule) rootNode;
        selfNode = (YangModule) nodeItr.next();
    }
    // Gets the container node.
    YangContainer container = (YangContainer) selfNode.getChild();
    // Gets the list node.
    YangList yangList = (YangList) refNode.getChild();
    leafItr = container.getListOfLeaf().listIterator();
    ifName = leafItr.next();
    address = leafItr.next();
    // Gets the address leaf's leaf-ref type.
    YangLeafRef<?> leafRef2 = (YangLeafRef) address.getDataType().getDataTypeExtendedInfo();
    pathItr = leafRef2.getAtomicPath().listIterator();
    atomicPath = pathItr.next();
    // Gets the path-predicate.
    predicateItr = atomicPath.getPathPredicatesList().listIterator();
    predicate = predicateItr.next();
    // Gets the left and right axis node in path-predicate.
    YangLeaf yangLeftLeaf = (YangLeaf) predicate.getLeftAxisNode();
    YangLeaf yangRightLeaf = (YangLeaf) predicate.getRightAxisNode();
    leafItr = yangList.getListOfLeaf().listIterator();
    name = leafItr.next();
    // Checks that right and left path-predicates are correct.
    assertThat(yangLeftLeaf, is(name));
    assertThat(yangRightLeaf, is(ifName));
}
#end_block

#method_before
@Test
public void processInterFilePathPredicateFromAugment() throws IOException {
    String searchDir = "src/test/resources/pathpredicate/interfileaugment";
    utilMgr.createYangFileInfoSet(getYangFiles(searchDir));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    YangModule selfNode;
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
    Iterator<YangNode> nodeItr = utilMgr.getYangNodeSet().iterator();
    YangNode rootNode = nodeItr.next();
    YangModule refNode;
    if (rootNode.getName().equals("ietf-network")) {
        selfNode = (YangModule) rootNode;
        refNode = (YangModule) nodeItr.next();
    } else {
        refNode = (YangModule) rootNode;
        selfNode = (YangModule) nodeItr.next();
    }
    // Gets the augment node.
    YangList list = (YangList) selfNode.getChild().getChild();
    // Gets the augment node.
    YangAugment augment = (YangAugment) refNode.getChild();
    ListIterator<YangLeaf> leafItr;
    YangLeaf test;
    YangLeaf networkId;
    YangLeaf networkRef;
    Iterator<YangAtomicPath> pathItr;
    YangAtomicPath atomicPath;
    Iterator<YangPathPredicate> predicateItr;
    YangPathPredicate predicate;
    leafItr = augment.getListOfLeaf().listIterator();
    test = leafItr.next();
    YangLeafRef<?> leafRef = (YangLeafRef) test.getDataType().getDataTypeExtendedInfo();
    pathItr = leafRef.getAtomicPath().listIterator();
    pathItr.next();
    atomicPath = pathItr.next();
    // Gets the path-predicate.
    predicateItr = atomicPath.getPathPredicatesList().listIterator();
    predicate = predicateItr.next();
    // Gets the left and right axis node in path-predicate.
    YangLeaf yangLeftLeaf = (YangLeaf) predicate.getLeftAxisNode();
    YangLeaf yangRightLeaf = (YangLeaf) predicate.getRightAxisNode();
    leafItr = list.getListOfLeaf().listIterator();
    networkId = leafItr.next();
    YangContainer reference = (YangContainer) list.getChild();
    leafItr = reference.getListOfLeaf().listIterator();
    networkRef = leafItr.next();
    // Checks that right and left path-predicates are correct.
    assertThat(yangLeftLeaf, is(networkId));
    assertThat(yangRightLeaf, is(networkRef));
}
#method_after
@Test
public void processInterFilePathPredicateFromAugment() throws IOException {
    utilMgr.createYangFileInfoSet(getYangFiles(DIR + "interfileaugment"));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    YangModule selfNode;
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
    Iterator<YangNode> nodeItr = utilMgr.getYangNodeSet().iterator();
    YangNode rootNode = nodeItr.next();
    YangModule refNode;
    if (rootNode.getName().equals("ietf-network")) {
        selfNode = (YangModule) rootNode;
        refNode = (YangModule) nodeItr.next();
    } else {
        refNode = (YangModule) rootNode;
        selfNode = (YangModule) nodeItr.next();
    }
    // Gets the augment node.
    YangList list = (YangList) selfNode.getChild().getChild();
    // Gets the augment node.
    YangAugment augment = (YangAugment) refNode.getChild();
    YangLeaf test;
    YangLeaf networkId;
    YangLeaf networkRef;
    leafItr = augment.getListOfLeaf().listIterator();
    test = leafItr.next();
    YangLeafRef<?> leafRef = (YangLeafRef) test.getDataType().getDataTypeExtendedInfo();
    pathItr = leafRef.getAtomicPath().listIterator();
    pathItr.next();
    atomicPath = pathItr.next();
    // Gets the path-predicate.
    predicateItr = atomicPath.getPathPredicatesList().listIterator();
    predicate = predicateItr.next();
    // Gets the left and right axis node in path-predicate.
    YangLeaf yangLeftLeaf = (YangLeaf) predicate.getLeftAxisNode();
    YangLeaf yangRightLeaf = (YangLeaf) predicate.getRightAxisNode();
    leafItr = list.getListOfLeaf().listIterator();
    networkId = leafItr.next();
    YangContainer reference = (YangContainer) list.getChild();
    leafItr = reference.getListOfLeaf().listIterator();
    networkRef = leafItr.next();
    // Checks that right and left path-predicates are correct.
    assertThat(yangLeftLeaf, is(networkId));
    assertThat(yangRightLeaf, is(networkRef));
}
#end_block

#method_before
@Test
public void processInvalidPathLink() throws IOException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: There is no leaf/leaf-list in YANG node as " + "mentioned in the path predicate of the leafref path " + "../../interface[ifname = current()/../../ifname]" + "/address/ip");
    String searchDir = "src/test/resources/pathpredicate/invalidlinking";
    utilMgr.createYangFileInfoSet(getYangFiles(searchDir));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
}
#method_after
@Test
public void processInvalidPathLink() throws IOException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: There is no leaf/leaf-list in YANG node as " + "mentioned in the path predicate of the leafref path " + "../../interface[ifname = current()/../../ifname]" + "/address/ip");
    utilMgr.createYangFileInfoSet(getYangFiles(DIR + "invalidlinking"));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
}
#end_block

#method_before
@Test
public void processInvalidPathLinkForList() throws IOException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: Path predicates are only applicable for " + "YANG list. The leafref path has path predicate for" + " non-list node in the path ../../default-address" + "[ifname = current()/../ifname]/ifname");
    String searchDir = "src/test/resources/pathpredicate/invalidlinking2";
    utilMgr.createYangFileInfoSet(getYangFiles(searchDir));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    YangNode selfNode;
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
}
#method_after
@Test
public void processInvalidPathLinkForList() throws IOException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: Path predicates are only applicable for " + "YANG list. The leafref path has path predicate for" + " non-list node in the path ../../default-address" + "[ifname = current()/../ifname]/ifname");
    utilMgr.createYangFileInfoSet(getYangFiles(DIR + "invalidlinking2"));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
}
#end_block

#method_before
@Test
public void processInvalidPathLinkForInvalidNode() throws IOException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: The path predicate of the leafref has an " + "invalid path in ../../interface[name = current()/" + "../../address/ifname]/address/ip");
    String searchDir = "src/test/resources/pathpredicate/invalidlinking3";
    utilMgr.createYangFileInfoSet(getYangFiles(searchDir));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
}
#method_after
@Test
public void processInvalidPathLinkForInvalidNode() throws IOException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: The path predicate of the leafref has an " + "invalid path in ../../interface[name = current()/" + "../../address/ifname]/address/ip");
    utilMgr.createYangFileInfoSet(getYangFiles(DIR + "invalidlinking3"));
    utilMgr.parseYangFileInfoSet();
    utilMgr.createYangNodeSet();
    linkerMgr.createYangNodeSet(utilMgr.getYangNodeSet());
    linkerMgr.addRefToYangFilesImportList(utilMgr.getYangNodeSet());
    updateFilePriority(utilMgr.getYangNodeSet());
    linkerMgr.processInterFileLinking(utilMgr.getYangNodeSet());
}
#end_block

#method_before
public static YangNode skipInvalidDataNodes(YangNode curParent, YangLeafRef leafRef) throws LinkerException {
    while (curParent instanceof YangChoice || curParent instanceof YangCase) {
        if (curParent.getParent() == null) {
            throw new LinkerException(getLeafRefErrorInfo(leafRef));
        }
        curParent = curParent.getParent();
    }
    return curParent;
}
#method_after
public static YangNode skipInvalidDataNodes(YangNode curParent, YangLeafRef leafRef) throws LinkerException {
    YangNode node = curParent;
    while (node instanceof YangChoice || node instanceof YangCase) {
        if (node.getParent() == null) {
            throw new LinkerException(getLeafRefErrorInfo(leafRef));
        }
        node = node.getParent();
    }
    return node;
}
#end_block

#method_before
public static void fillPathPredicates(YangLeafRef<?> leafRef) throws DataModelException {
    List<YangAtomicPath> atomicList = leafRef.getAtomicPath();
    if (atomicList != null) {
        for (YangAtomicPath atomicPath : atomicList) {
            List<YangPathPredicate> predicates = atomicPath.getPathPredicatesList();
            if (predicates != null) {
                for (YangPathPredicate predicate : predicates) {
                    setLeftAxisNode(leafRef, atomicPath, predicate);
                    setRightAxisNode(leafRef, predicate);
                }
            }
        }
    }
}
#method_after
public static void fillPathPredicates(YangLeafRef<?> leafRef) throws DataModelException {
    List<YangAtomicPath> atomics = leafRef.getAtomicPath();
    if (atomics != null) {
        for (YangAtomicPath atom : atomics) {
            List<YangPathPredicate> predicates = atom.getPathPredicatesList();
            if (predicates != null) {
                for (YangPathPredicate predicate : predicates) {
                    setLeftAxisNode(leafRef, atom, predicate);
                    setRightAxisNode(leafRef, predicate);
                }
            }
        }
    }
}
#end_block

#method_before
private static void setLeftAxisNode(YangLeafRef<?> leafRef, YangAtomicPath atomicPath, YangPathPredicate predicate) throws DataModelException {
    YangNode resolvedNode = atomicPath.getResolvedNode();
    if (!(resolvedNode instanceof YangList)) {
        throw getDataModelErrMsg(LEAF_REF_LIST_ERR, leafRef);
    }
    YangNodeIdentifier leftAxisName = predicate.getNodeIdentifier();
    Object target = getTarget(leftAxisName, resolvedNode, leafRef);
    predicate.setLeftAxisNode(target);
}
#method_after
private static void setLeftAxisNode(YangLeafRef<?> leafRef, YangAtomicPath atom, YangPathPredicate predicate) throws DataModelException {
    YangNode resolvedNode = atom.getResolvedNode();
    if (!(resolvedNode instanceof YangList)) {
        throw getDataModelExc(LEAF_REF_LIST_ERR, leafRef);
    }
    YangNodeIdentifier leftAxisName = predicate.getNodeId();
    Object target = getTarget(leftAxisName, resolvedNode, leafRef);
    predicate.setLeftAxisNode(target);
}
#end_block

#method_before
private static Object getTarget(YangNodeIdentifier leftAxisName, YangNode node, YangLeafRef leafRef) throws DataModelException {
    YangLeaf leaf = getLeaf(leftAxisName, (YangLeavesHolder) node);
    if (leaf != null) {
        return leaf;
    }
    YangLeafList leafList = getLeafList(leftAxisName, (YangLeavesHolder) node);
    if (leafList == null) {
        throw getDataModelErrMsg(TGT_LEAF_ERR, leafRef);
    }
    return leafList;
}
#method_after
private static Object getTarget(YangNodeIdentifier leftAxisName, YangNode node, YangLeafRef leafRef) throws DataModelException {
    YangLeaf leaf = getLeaf(leftAxisName, (YangLeavesHolder) node);
    if (leaf != null) {
        return leaf;
    }
    YangLeafList leafList = getLeafList(leftAxisName, (YangLeavesHolder) node);
    if (leafList == null) {
        throw getDataModelExc(TGT_LEAF_ERR, leafRef);
    }
    return leafList;
}
#end_block

#method_before
private static YangNode getRootNode(int count, YangNode curParent, YangLeafRef leafRef) throws DataModelException {
    int curCount = 0;
    while (curCount < count) {
        curCount = curCount + 1;
        if (curCount != 1) {
            if (curParent.getParent() == null) {
                throw getDataModelErrMsg(INVALID_TREE, leafRef);
            }
            curParent = curParent.getParent();
        }
        curParent = skipInvalidDataNodes(curParent, leafRef);
        if (curParent instanceof YangAugment) {
            YangAugment augment = (YangAugment) curParent;
            curParent = augment.getAugmentedNode();
            curCount = curCount + 1;
        }
    }
    return curParent;
}
#method_after
private static YangNode getRootNode(int count, YangNode node, YangLeafRef leafRef) throws DataModelException {
    YangNode curParent = node;
    int curCount = 0;
    while (curCount < count) {
        curCount = curCount + 1;
        if (curCount != 1) {
            if (curParent.getParent() == null) {
                throw getDataModelExc(INVALID_TREE, leafRef);
            }
            curParent = curParent.getParent();
        }
        curParent = skipInvalidDataNodes(curParent, leafRef);
        if (curParent instanceof YangAugment) {
            YangAugment augment = (YangAugment) curParent;
            curParent = augment.getAugmentedNode();
            curCount = curCount + 1;
        }
    }
    return curParent;
}
#end_block

#method_before
private static Object getLastNode(YangNode curNode, YangRelativePath relPath, YangLeafRef leafRef) throws DataModelException {
    List<YangAtomicPath> atomicPaths = new ArrayList<>();
    atomicPaths.addAll(relPath.getAtomicPathList());
    if (atomicPaths.isEmpty()) {
        throw getDataModelErrMsg(EMPTY_PATH_LIST_ERR, leafRef);
    }
    YangAtomicPath pathTgt = atomicPaths.get(atomicPaths.size() - 1);
    if (atomicPaths.size() == 1) {
        return getTarget(pathTgt.getNodeIdentifier(), curNode, leafRef);
    }
    atomicPaths.remove(atomicPaths.size() - 1);
    for (YangAtomicPath atomicPath : atomicPaths) {
        curNode = getNode(curNode.getChild(), atomicPath.getNodeIdentifier());
        if (curNode == null) {
            throw getDataModelErrMsg(INVALID_PATH_PRE, leafRef);
        }
    }
    return getTarget(pathTgt.getNodeIdentifier(), curNode, leafRef);
}
#method_after
private static Object getLastNode(YangNode curNode, YangRelativePath relPath, YangLeafRef leafRef) throws DataModelException {
    YangNode node = curNode;
    List<YangAtomicPath> atomics = new ArrayList<>();
    atomics.addAll(relPath.getAtomicPathList());
    if (atomics.isEmpty()) {
        throw getDataModelExc(EMPTY_PATH_LIST_ERR, leafRef);
    }
    YangAtomicPath pathTgt = atomics.get(atomics.size() - 1);
    if (atomics.size() == 1) {
        return getTarget(pathTgt.getNodeIdentifier(), node, leafRef);
    }
    atomics.remove(atomics.size() - 1);
    for (YangAtomicPath atomicPath : atomics) {
        node = getNode(node.getChild(), atomicPath.getNodeIdentifier());
        if (node == null) {
            throw getDataModelExc(INVALID_PATH_PRE, leafRef);
        }
    }
    return getTarget(pathTgt.getNodeIdentifier(), node, leafRef);
}
#end_block

#method_before
private static YangNode getNode(YangNode curNode, YangNodeIdentifier identifier) {
    while (curNode != null) {
        if (curNode.getName().equals(identifier.getName())) {
            return curNode;
        }
        curNode = curNode.getNextSibling();
    }
    return null;
}
#method_after
private static YangNode getNode(YangNode curNode, YangNodeIdentifier identifier) {
    YangNode node = curNode;
    while (node != null) {
        if (node.getName().equals(identifier.getName())) {
            return node;
        }
        node = node.getNextSibling();
    }
    return null;
}
#end_block

#method_before
private static void setRightAxisNode(YangLeafRef leafRef, YangPathPredicate predicate) throws DataModelException {
    YangNode parentNode = leafRef.getParentNodeOfLeafref();
    YangRelativePath relPath = predicate.getRightRelativePath();
    int ancestor = relPath.getAncestorNodeCount();
    YangNode rootNode = getRootNode(ancestor, parentNode, leafRef);
    Object target = getLastNode(rootNode, relPath, leafRef);
    if (target == null) {
        throw getDataModelErrMsg(INVALID_PATH_PRE, leafRef);
    }
    predicate.setRightAxisNode(target);
}
#method_after
private static void setRightAxisNode(YangLeafRef leafRef, YangPathPredicate predicate) throws DataModelException {
    YangNode parentNode = leafRef.getParentNode();
    YangRelativePath relPath = predicate.getRelPath();
    int ancestor = relPath.getAncestorNodeCount();
    YangNode rootNode = getRootNode(ancestor, parentNode, leafRef);
    Object target = getLastNode(rootNode, relPath, leafRef);
    if (target == null) {
        throw getDataModelExc(INVALID_PATH_PRE, leafRef);
    }
    predicate.setRightAxisNode(target);
}
#end_block

#method_before
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode refNode = entityToResolveInfo.getHolderOfEntityToResolve();
    YangType yangType = getValidateResolvableType();
    if (yangType == null) {
        return;
    }
    YangDerivedInfo derivedInfo = (YangDerivedInfo) yangType.getDataTypeExtendedInfo();
    YangDataTypes dataType = derivedInfo.getEffectiveBuiltInType();
    // If the derived types referred type is not leafref/identityref return
    if (dataType != YangDataTypes.LEAFREF && dataType != YangDataTypes.IDENTITYREF) {
        return;
    }
    T extendedInfo = (T) derivedInfo.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extendedInfo instanceof YangDerivedInfo) {
        YangDerivedInfo derivedInfoFromTypedef = (YangDerivedInfo) extendedInfo;
        extendedInfo = (T) derivedInfoFromTypedef.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /*
         * Backup the derived types leafref/identityref info, delete all the info in current type,
         * but for resolution status as resolved. Copy the backed up leafref/identityref to types extended info,
         * create a leafref/identityref resolution info using the current resolution info and
         * add to leafref/identityref resolution list.
         */
    if (dataType == YangDataTypes.LEAFREF) {
        YangLeafRef leafRefInTypeDef = (YangLeafRef) extendedInfo;
        addRefTypeInfo(YangDataTypes.LEAFREF, LEAFREF, extendedInfo, yangType, refNode, YANG_LEAFREF);
        leafRefInTypeDef.setParentNodeOfLeafref(refNode);
    } else {
        addRefTypeInfo(YangDataTypes.IDENTITYREF, IDENTITYREF, extendedInfo, yangType, refNode, YANG_IDENTITYREF);
    }
}
#method_after
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode refNode = entityToResolveInfo.getHolderOfEntityToResolve();
    YangType yangType = getValidateResolvableType();
    if (yangType == null) {
        return;
    }
    YangDerivedInfo derivedInfo = (YangDerivedInfo) yangType.getDataTypeExtendedInfo();
    YangDataTypes dataType = derivedInfo.getEffectiveBuiltInType();
    // If the derived types referred type is not leafref/identityref return
    if (dataType != YangDataTypes.LEAFREF && dataType != YangDataTypes.IDENTITYREF) {
        return;
    }
    T extendedInfo = (T) derivedInfo.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extendedInfo instanceof YangDerivedInfo) {
        YangDerivedInfo derivedInfoFromTypedef = (YangDerivedInfo) extendedInfo;
        extendedInfo = (T) derivedInfoFromTypedef.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /*
         * Backup the derived types leafref/identityref info, delete all the info in current type,
         * but for resolution status as resolved. Copy the backed up leafref/identityref to types extended info,
         * create a leafref/identityref resolution info using the current resolution info and
         * add to leafref/identityref resolution list.
         */
    if (dataType == YangDataTypes.LEAFREF) {
        YangLeafRef leafRefInTypeDef = (YangLeafRef) extendedInfo;
        addRefTypeInfo(YangDataTypes.LEAFREF, LEAFREF, extendedInfo, yangType, refNode, YANG_LEAFREF);
        leafRefInTypeDef.setParentNode(refNode);
    } else {
        addRefTypeInfo(YangDataTypes.IDENTITYREF, IDENTITYREF, extendedInfo, yangType, refNode, YANG_IDENTITYREF);
    }
}
#end_block

#method_before
private void addUnresolvedEntitiesToResolutionList(T entityToResolve) throws DataModelException {
    if (entityToResolve instanceof YangEntityToResolveInfoImpl) {
        YangEntityToResolveInfoImpl entityToResolveInfo = (YangEntityToResolveInfoImpl) entityToResolve;
        if (entityToResolveInfo.getEntityToResolve() instanceof YangLeafRef) {
            YangLeafRef leafref = (YangLeafRef) entityToResolveInfo.getEntityToResolve();
            YangNode parentNodeOfLeafref = entityToResolveInfo.getHolderOfEntityToResolve();
            leafref.setParentNodeOfLeafref(parentNodeOfLeafref);
            if (leafref.getResolvableStatus() == UNRESOLVED) {
                leafref.setResolvableStatus(INTRA_FILE_RESOLVED);
            }
        }
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(entityToResolveInfo.getEntityToResolve(), entityToResolveInfo.getHolderOfEntityToResolve(), entityToResolveInfo.getLineNumber(), entityToResolveInfo.getCharPosition());
        addResolutionInfo(resolutionInfoImpl);
    }
}
#method_after
private void addUnresolvedEntitiesToResolutionList(T entityToResolve) throws DataModelException {
    if (entityToResolve instanceof YangEntityToResolveInfoImpl) {
        YangEntityToResolveInfoImpl entityToResolveInfo = (YangEntityToResolveInfoImpl) entityToResolve;
        if (entityToResolveInfo.getEntityToResolve() instanceof YangLeafRef) {
            YangLeafRef leafref = (YangLeafRef) entityToResolveInfo.getEntityToResolve();
            YangNode parentNodeOfLeafref = entityToResolveInfo.getHolderOfEntityToResolve();
            leafref.setParentNode(parentNodeOfLeafref);
            if (leafref.getResolvableStatus() == UNRESOLVED) {
                leafref.setResolvableStatus(INTRA_FILE_RESOLVED);
            }
        }
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(entityToResolveInfo.getEntityToResolve(), entityToResolveInfo.getHolderOfEntityToResolve(), entityToResolveInfo.getLineNumber(), entityToResolveInfo.getCharPosition());
        addResolutionInfo(resolutionInfoImpl);
    }
}
#end_block

#method_before
private void setAbsolutePathFromRelativePathInLeafref(T resolutionInfo) throws DataModelException {
    if (resolutionInfo instanceof YangLeafRef) {
        YangNode leafParent = ((YangLeafRef) resolutionInfo).getParentNodeOfLeafref();
        YangLeafRef leafref = (YangLeafRef) resolutionInfo;
        // Checks if the leafref has relative path in it.
        if (leafref.getPathType() == RELATIVE_PATH) {
            YangRelativePath relativePath = leafref.getRelativePath();
            List<YangAtomicPath> absoluteInRelative = relativePath.getAtomicPathList();
            int ancestorCount = relativePath.getAncestorNodeCount();
            // Gets the root node from the ancestor count.
            T nodeOrAugmentList = getRootNodeWithAncestorCountForLeafref(ancestorCount, leafParent, leafref);
            if (nodeOrAugmentList instanceof YangNode) {
                StringBuilder name = new StringBuilder();
                StringBuilder prefix = new StringBuilder();
                YangNode rootNode = (YangNode) nodeOrAugmentList;
                // Forms a new absolute path from the relative path
                while (!(rootNode instanceof YangReferenceResolver)) {
                    name.append(rootNode.getName());
                    prefix.append(SLASH_FOR_STRING).append(name.reverse());
                    name.delete(0, name.length());
                    rootNode = rootNode.getParent();
                    if (rootNode == null) {
                        throw new DataModelException(INVALID_TREE);
                    }
                }
                prefix.reverse();
                fillAbsolutePathValuesInLeafref(leafref, prefix.toString(), absoluteInRelative);
            } else {
                List<String> listOfAugment = (List<String>) nodeOrAugmentList;
                Iterator<String> listOfAugmentIterator = listOfAugment.listIterator();
                StringBuilder augment = new StringBuilder(EMPTY_STRING);
                while (listOfAugmentIterator.hasNext()) {
                    augment.append(SLASH_FOR_STRING).append(listOfAugmentIterator.next());
                }
                fillAbsolutePathValuesInLeafref(leafref, augment.toString(), absoluteInRelative);
            }
        }
    }
}
#method_after
private void setAbsolutePathFromRelativePathInLeafref(T resolutionInfo) throws DataModelException {
    if (resolutionInfo instanceof YangLeafRef) {
        YangNode leafParent = ((YangLeafRef) resolutionInfo).getParentNode();
        YangLeafRef leafref = (YangLeafRef) resolutionInfo;
        // Checks if the leafref has relative path in it.
        if (leafref.getPathType() == RELATIVE_PATH) {
            YangRelativePath relativePath = leafref.getRelativePath();
            List<YangAtomicPath> absoluteInRelative = relativePath.getAtomicPathList();
            int ancestorCount = relativePath.getAncestorNodeCount();
            // Gets the root node from the ancestor count.
            T nodeOrAugmentList = getRootNodeWithAncestorCountForLeafref(ancestorCount, leafParent, leafref);
            if (nodeOrAugmentList instanceof YangNode) {
                StringBuilder name = new StringBuilder();
                StringBuilder prefix = new StringBuilder();
                YangNode rootNode = (YangNode) nodeOrAugmentList;
                // Forms a new absolute path from the relative path
                while (!(rootNode instanceof YangReferenceResolver)) {
                    name.append(rootNode.getName());
                    prefix.append(SLASH_FOR_STRING).append(name.reverse());
                    name.delete(0, name.length());
                    rootNode = rootNode.getParent();
                    if (rootNode == null) {
                        throw new DataModelException(INVALID_TREE);
                    }
                }
                prefix.reverse();
                fillAbsolutePathValuesInLeafref(leafref, prefix.toString(), absoluteInRelative);
            } else {
                List<String> listOfAugment = (List<String>) nodeOrAugmentList;
                Iterator<String> listOfAugmentIterator = listOfAugment.listIterator();
                StringBuilder augment = new StringBuilder(EMPTY_STRING);
                while (listOfAugmentIterator.hasNext()) {
                    augment.append(SLASH_FOR_STRING).append(listOfAugmentIterator.next());
                }
                fillAbsolutePathValuesInLeafref(leafref, augment.toString(), absoluteInRelative);
            }
        }
    }
}
#end_block

#method_before
private static void valPrefix(List<YangAtomicPath> atomicList, YangLeafRef leafRef) {
    for (YangAtomicPath atomicPath : atomicList) {
        String prefix = atomicPath.getNodeIdentifier().getPrefix();
        YangNode parent = leafRef.getParentNodeOfLeafref();
        YangNode rootNode = getRootNode(parent);
        List<YangImport> imports;
        if (rootNode instanceof YangModule) {
            imports = ((YangModule) rootNode).getImportList();
        } else {
            imports = ((YangSubModule) rootNode).getImportList();
        }
        updatePrefixWithNode(rootNode, imports, prefix, leafRef);
    }
}
#method_after
private static void valPrefix(List<YangAtomicPath> atomicList, YangLeafRef leafRef) {
    for (YangAtomicPath atomicPath : atomicList) {
        String prefix = atomicPath.getNodeIdentifier().getPrefix();
        YangNode parent = leafRef.getParentNode();
        YangNode rootNode = getRootNode(parent);
        List<YangImport> imports;
        if (rootNode instanceof YangModule) {
            imports = ((YangModule) rootNode).getImportList();
        } else {
            imports = ((YangSubModule) rootNode).getImportList();
        }
        updatePrefixWithNode(rootNode, imports, prefix, leafRef);
    }
}
#end_block

#method_before
private static void updatePrefixWithNode(YangNode root, List<YangImport> imports, String prefix, YangLeafRef<?> leafRef) {
    Map<String, String> prefixMap = leafRef.getPrefixWithNode();
    if (prefixMap == null) {
        prefixMap = new HashMap<>();
        leafRef.setPrefixWithNode(prefixMap);
    }
    if (prefix == null || prefix.equals(((YangReferenceResolver) root).getPrefix())) {
        prefixMap.put(prefix, root.getName());
        return;
    }
    if (imports != null) {
        for (YangImport yangImp : imports) {
            if (yangImp.getPrefixId().equals(prefix)) {
                prefixMap.put(prefix, yangImp.getModuleName());
            }
        }
    }
}
#method_after
private static void updatePrefixWithNode(YangNode root, List<YangImport> imports, String prefix, YangLeafRef<?> leafRef) {
    Map<String, String> prefixMap = leafRef.getPrefixAndNode();
    if (prefixMap == null) {
        prefixMap = new HashMap<>();
        leafRef.setPrefixAndNode(prefixMap);
    }
    if (prefix == null || prefix.equals(((YangReferenceResolver) root).getPrefix())) {
        prefixMap.put(prefix, root.getName());
        return;
    }
    if (imports != null) {
        for (YangImport yangImp : imports) {
            if (yangImp.getPrefixId().equals(prefix)) {
                prefixMap.put(prefix, yangImp.getModuleName());
            }
        }
    }
}
#end_block

#method_before
private static YangNode getRootNode(YangNode node) {
    while (!(node instanceof YangModule) && !(node instanceof YangSubModule)) {
        if (node == null) {
            throw new ParserException(INVALID_TREE);
        }
        node = node.getParent();
    }
    return node;
}
#method_after
private static YangNode getRootNode(YangNode node) {
    YangNode curNode = node;
    while (!(curNode instanceof YangModule) && !(curNode instanceof YangSubModule)) {
        if (curNode == null) {
            throw new ParserException(INVALID_TREE);
        }
        curNode = curNode.getParent();
    }
    return curNode;
}
#end_block

#method_before
public static void handleUnsupportedYangConstruct(YangConstructType yangConstructType, ParserRuleContext ctx, String errorInfo, String fileName) {
    ParserException parserException = new ParserException(YANG_FILE_ERROR + QUOTES + getYangConstructType(yangConstructType) + QUOTES + errorInfo);
    parserException.setLine(ctx.getStart().getLine());
    parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
// FIXME this exception should probably be thrown rather than just logged
// throw parserException;
}
#method_after
public static void handleUnsupportedYangConstruct(YangConstructType type, ParserRuleContext ctx, String errorInfo, String fileName) {
    ParserException parserException = new ParserException(YANG_FILE_ERROR + QUOTES + getYangConstructType(type) + QUOTES + errorInfo);
    parserException.setLine(ctx.getStart().getLine());
    parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
// FIXME this exception should probably be thrown rather than just logged
// throw parserException;
}
#end_block

#method_before
public static void validatePath(String path, YangConstructType type, PathStatementContext ctx, YangLeafRef leafRef) {
    String concatPath = removeQuotesAndHandleConcat(path);
    leafRef.setPath(concatPath);
    pathType = type;
    pathCtx = ctx;
    yangLeafRef = leafRef;
    if (!concatPath.startsWith(SLASH_FOR_STRING) && !concatPath.startsWith(ANCESTOR)) {
        throw getPathErrorMsg();
    }
    if (concatPath.startsWith(SLASH_FOR_STRING)) {
        List<YangAtomicPath> atomicList = new LinkedList<>();
        valAbsPath(concatPath, atomicList);
        leafRef.setPathType(ABSOLUTE_PATH);
        valPrefix(atomicList, leafRef);
        leafRef.setAtomicPath(atomicList);
        return;
    }
    leafRef.setPathType(RELATIVE_PATH);
    valRelPath(concatPath, leafRef);
}
#method_after
public static void validatePath(String path, YangConstructType type, PathStatementContext ctx, YangLeafRef leafRef) {
    String concatPath = removeQuotesAndHandleConcat(path);
    pathType = type;
    pathCtx = ctx;
    yangLeafRef = leafRef;
    if (!concatPath.startsWith(SLASH_FOR_STRING) && !concatPath.startsWith(ANCESTOR)) {
        throw getPathException();
    }
    leafRef.setPath(concatPath);
    if (concatPath.startsWith(SLASH_FOR_STRING)) {
        List<YangAtomicPath> atomicList = new LinkedList<>();
        valAbsPath(concatPath, atomicList);
        leafRef.setPathType(ABSOLUTE_PATH);
        valPrefix(atomicList, leafRef);
        leafRef.setAtomicPath(atomicList);
        return;
    }
    leafRef.setPathType(RELATIVE_PATH);
    valRelPath(concatPath, leafRef);
}
#end_block

#method_before
private static void valRelPath(String path, YangLeafRef leafRef) {
    YangRelativePath relPath = new YangRelativePath();
    int count = 0;
    while (path.startsWith(SLASH_ANCESTOR)) {
        path = path.replaceFirst(SLASH_ANCESTOR, EMPTY_STRING);
        count = count + 1;
    }
    if (path.isEmpty()) {
        throw getPathErrorMsg();
    }
    List<YangAtomicPath> atomicList = new ArrayList<>();
    relPath.setAncestorNodeCount(count);
    valAbsPath(SLASH_FOR_STRING + path, atomicList);
    valPrefix(atomicList, leafRef);
    relPath.setAtomicPathList(atomicList);
    leafRef.setRelativePath(relPath);
}
#method_after
private static void valRelPath(String path, YangLeafRef leafRef) {
    YangRelativePath relPath = new YangRelativePath();
    int count = 0;
    while (path.startsWith(SLASH_ANCESTOR)) {
        path = path.replaceFirst(SLASH_ANCESTOR, EMPTY_STRING);
        count = count + 1;
    }
    if (path.isEmpty()) {
        throw getPathException();
    }
    List<YangAtomicPath> atomicList = new ArrayList<>();
    relPath.setAncestorNodeCount(count);
    valAbsPath(SLASH_FOR_STRING + path, atomicList);
    valPrefix(atomicList, leafRef);
    relPath.setAtomicPathList(atomicList);
    leafRef.setRelativePath(relPath);
}
#end_block

#method_before
private static void valAbsPath(String path, List<YangAtomicPath> atomicList) {
    while (path != null) {
        path = path.substring(1);
        if (path.isEmpty()) {
            throw getPathErrorMsg();
        }
        int nodeId = path.indexOf(CHAR_OF_SLASH);
        int predicate = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        if (predicate < nodeId && predicate != -1) {
            path = getPathWithPredicate(path, atomicList);
        } else {
            path = getPath(path, atomicList);
        }
    }
}
#method_after
private static void valAbsPath(String path, List<YangAtomicPath> atomics) {
    String comPath = path;
    while (comPath != null) {
        comPath = comPath.substring(1);
        if (comPath.isEmpty()) {
            throw getPathException();
        }
        int nodeId = comPath.indexOf(CHAR_OF_SLASH);
        int predicate = comPath.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        if (predicate < nodeId && predicate != -1) {
            comPath = getPathWithPredicate(comPath, atomics);
        } else {
            comPath = getPath(comPath, atomics);
        }
    }
}
#end_block

#method_before
private static String getPathWithPredicate(String path, List<YangAtomicPath> atomicList) {
    String[] node = new String[2];
    int bracket = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
    node[0] = path.substring(0, bracket);
    node[1] = path.substring(bracket);
    return processParsablePredicates(node[0], node[1], atomicList);
}
#method_after
private static String getPathWithPredicate(String path, List<YangAtomicPath> atomics) {
    String[] node = new String[2];
    int bracket = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
    node[0] = path.substring(0, bracket);
    node[1] = path.substring(bracket);
    return getParsedPath(node[0], node[1], atomics);
}
#end_block

#method_before
private static YangPathPredicate valPathEqualityExp(String predicate) {
    String[] exp = predicate.split(REGEX_EQUAL);
    YangNodeIdentifier nodeId = getValidNodeIdentifier(exp[0].trim(), pathType, pathCtx);
    YangRelativePath relPath = valPathKeyExp(exp[1].trim());
    YangPathPredicate pathPredicate = new YangPathPredicate();
    pathPredicate.setNodeIdentifier(nodeId);
    pathPredicate.setPathOperator(EQUALTO);
    pathPredicate.setRightRelativePath(relPath);
    return pathPredicate;
}
#method_after
private static YangPathPredicate valPathEqualityExp(String predicate) {
    String[] exp = predicate.split(REGEX_EQUAL);
    YangNodeIdentifier nodeId = getValidNodeIdentifier(exp[0].trim(), pathType, pathCtx);
    YangRelativePath relPath = valPathKeyExp(exp[1].trim());
    YangPathPredicate pathPredicate = new YangPathPredicate();
    pathPredicate.setNodeId(nodeId);
    pathPredicate.setPathOp(EQUALTO);
    pathPredicate.setRelPath(relPath);
    return pathPredicate;
}
#end_block

#method_before
private static List<YangAtomicPath> valRelPathKeyExp(List<String> atomicContent) {
    String current = atomicContent.get(0);
    String[] curStr = (current.trim()).split(REGEX_OPEN_BRACE);
    if (!(curStr[0].trim().equals(CURRENT)) || !(curStr[1].trim().equals(CLOSE_PARENTHESIS))) {
        throw getPathErrorMsg();
    }
    atomicContent.remove(0);
    List<YangAtomicPath> atomicList = new ArrayList<>();
    for (String relPath : atomicContent) {
        YangNodeIdentifier nodeId = getValidNodeIdentifier(relPath, pathType, pathCtx);
        YangAtomicPath atomicPath = new YangAtomicPath();
        atomicPath.setNodeIdentifier(nodeId);
        atomicList.add(atomicPath);
    }
    return atomicList;
}
#method_after
private static List<YangAtomicPath> valRelPathKeyExp(List<String> content) {
    String current = content.get(0);
    String[] curStr = (current.trim()).split(REGEX_OPEN_BRACE);
    if (!(curStr[0].trim().equals(CURRENT)) || !(curStr[1].trim().equals(CLOSE_PARENTHESIS))) {
        throw getPathException();
    }
    content.remove(0);
    List<YangAtomicPath> atomicList = new ArrayList<>();
    for (String relPath : content) {
        YangNodeIdentifier nodeId = getValidNodeIdentifier(relPath, pathType, pathCtx);
        YangAtomicPath atomicPath = new YangAtomicPath();
        atomicPath.setNodeIdentifier(nodeId);
        atomicList.add(atomicPath);
    }
    return atomicList;
}
#end_block

#method_before
public static String getPath(String path, List<YangAtomicPath> atomicList) {
    String nodeId;
    if (path.contains(SLASH_FOR_STRING)) {
        nodeId = path.substring(0, path.indexOf(CHAR_OF_SLASH));
        path = path.substring(path.indexOf(CHAR_OF_SLASH));
    } else {
        nodeId = path;
        path = null;
    }
    YangNodeIdentifier validNodeId = getValidNodeIdentifier(nodeId, pathType, pathCtx);
    YangAtomicPath atomicPath = new YangAtomicPath();
    atomicPath.setNodeIdentifier(validNodeId);
    atomicList.add(atomicPath);
    return path;
}
#method_after
public static String getPath(String path, List<YangAtomicPath> atomicList) {
    String comPath = path;
    String nodeId;
    if (comPath.contains(SLASH_FOR_STRING)) {
        nodeId = comPath.substring(0, comPath.indexOf(CHAR_OF_SLASH));
        comPath = comPath.substring(comPath.indexOf(CHAR_OF_SLASH));
    } else {
        nodeId = comPath;
        comPath = null;
    }
    YangNodeIdentifier validNodeId = getValidNodeIdentifier(nodeId, pathType, pathCtx);
    YangAtomicPath atomicPath = new YangAtomicPath();
    atomicPath.setNodeIdentifier(validNodeId);
    atomicList.add(atomicPath);
    return comPath;
}
#end_block

#method_before
public static void cloneListOfLeaf(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeaf> leaves = clonedNode.getListOfLeaf();
    if (isListPresent(leaves)) {
        List<YangLeaf> clonedLeaves = new LinkedList<>();
        for (YangLeaf leaf : leaves) {
            YangLeaf clonedLeaf = leaf.clone();
            clonedLeaf.setReferredLeaf(leaf);
            addUnresolvedType(yangUses, clonedLeaf, (YangNode) clonedNode);
            clonedLeaf.setContainedIn(clonedNode);
            clonedLeaves.add(clonedLeaf);
        }
        clonedNode.setListOfLeaf(clonedLeaves);
    }
}
#method_after
public static void cloneListOfLeaf(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeaf> leaves = clonedNode.getListOfLeaf();
    if (nonEmpty(leaves)) {
        List<YangLeaf> clonedLeaves = new LinkedList<>();
        for (YangLeaf leaf : leaves) {
            YangLeaf clonedLeaf = leaf.clone();
            clonedLeaf.setReferredLeaf(leaf);
            addUnresolvedType(yangUses, clonedLeaf, (YangNode) clonedNode);
            clonedLeaf.setContainedIn(clonedNode);
            clonedLeaves.add(clonedLeaf);
        }
        clonedNode.setListOfLeaf(clonedLeaves);
    }
}
#end_block

#method_before
public static void addUnresolvedType(YangUses yangUses, Object clonedObj, YangNode clonedNode) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList;
    if (yangUses != null && yangUses.getCurrentGroupingDepth() == 0) {
        infoList = getTypesToBeResolved(clonedObj, clonedNode, yangUses);
        if (isListPresent(infoList)) {
            yangUses.addEntityToResolve(infoList);
        }
    }
}
#method_after
public static void addUnresolvedType(YangUses yangUses, Object clonedObj, YangNode clonedNode) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList;
    if (yangUses != null && yangUses.getCurrentGroupingDepth() == 0) {
        infoList = getTypesToBeResolved(clonedObj, clonedNode, yangUses);
        if (nonEmpty(infoList)) {
            yangUses.addEntityToResolve(infoList);
        }
    }
}
#end_block

#method_before
public static void cloneListOfLeafList(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeafList> listOfLeafList = clonedNode.getListOfLeafList();
    if (isListPresent(listOfLeafList)) {
        List<YangLeafList> clonedList = new LinkedList<>();
        for (YangLeafList leafList : listOfLeafList) {
            YangLeafList clonedLeafList = leafList.clone();
            clonedLeafList.setReferredSchemaLeafList(leafList);
            addUnresolvedType(yangUses, clonedLeafList, (YangNode) clonedNode);
            clonedLeafList.setContainedIn(clonedNode);
            clonedList.add(clonedLeafList);
        }
        clonedNode.setListOfLeafList(clonedList);
    }
}
#method_after
public static void cloneListOfLeafList(YangLeavesHolder clonedNode, YangUses yangUses) throws CloneNotSupportedException, DataModelException {
    List<YangLeafList> listOfLeafList = clonedNode.getListOfLeafList();
    if (nonEmpty(listOfLeafList)) {
        List<YangLeafList> clonedList = new LinkedList<>();
        for (YangLeafList leafList : listOfLeafList) {
            YangLeafList clonedLeafList = leafList.clone();
            clonedLeafList.setReferredSchemaLeafList(leafList);
            addUnresolvedType(yangUses, clonedLeafList, (YangNode) clonedNode);
            clonedLeafList.setContainedIn(clonedNode);
            clonedList.add(clonedLeafList);
        }
        clonedNode.setListOfLeafList(clonedList);
    }
}
#end_block

#method_before
private static List<YangEntityToResolveInfoImpl> getUnresolvedTypeList(YangDataTypes dataTypes, YangType type, YangNode holder, YangUses yangUses, boolean isLeaf) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList = new ArrayList<>();
    YangEntityToResolveInfoImpl entity = null;
    List<YangEntityToResolveInfoImpl> entityList = null;
    switch(dataTypes) {
        case LEAFREF:
            entity = getLeafRefResolvableEntity(type, yangUses, holder);
            break;
        case IDENTITYREF:
            entity = getIdentityRefResolvableEntity(type, holder);
            break;
        case DERIVED:
            entity = getDerivedResolvableEntity(type, holder, isLeaf);
            break;
        case UNION:
            entityList = getUnionResolvableEntity(type, isLeaf);
            break;
        default:
            return null;
    }
    infoList.add(entity);
    if (isListPresent(entityList)) {
        infoList.addAll(entityList);
    }
    return infoList;
}
#method_after
private static List<YangEntityToResolveInfoImpl> getUnresolvedTypeList(YangDataTypes dataTypes, YangType type, YangNode holder, YangUses yangUses, boolean isLeaf) throws DataModelException {
    List<YangEntityToResolveInfoImpl> infoList = new ArrayList<>();
    YangEntityToResolveInfoImpl entity = null;
    List<YangEntityToResolveInfoImpl> entityList = null;
    switch(dataTypes) {
        case LEAFREF:
            entity = getLeafRefResolvableEntity(type, yangUses, holder);
            break;
        case IDENTITYREF:
            entity = getIdentityRefResolvableEntity(type, holder);
            break;
        case DERIVED:
            entity = getDerivedResolvableEntity(type, holder, isLeaf);
            break;
        case UNION:
            entityList = getUnionResolvableEntity(type, isLeaf);
            break;
        default:
            return null;
    }
    infoList.add(entity);
    if (nonEmpty(entityList)) {
        infoList.addAll(entityList);
    }
    return infoList;
}
#end_block

#method_before
private static YangEntityToResolveInfoImpl getLeafRefResolvableEntity(YangType type, YangUses yangUses, YangNode holder) throws DataModelException {
    YangEntityToResolveInfoImpl<YangLeafRef> leafRefInfo = new YangEntityToResolveInfoImpl<>();
    YangLeafRef leafRef = (YangLeafRef) type.getDataTypeExtendedInfo();
    // Conversion of prefixes in absolute path while cloning them.
    convertThePrefixesDuringChange(leafRef, yangUses);
    leafRef.setParentNodeOfLeafref(holder);
    leafRefInfo.setEntityToResolve(leafRef);
    return setInformationInEntity(leafRefInfo, holder, leafRef.getCharPosition(), leafRef.getLineNumber());
}
#method_after
private static YangEntityToResolveInfoImpl getLeafRefResolvableEntity(YangType type, YangUses yangUses, YangNode holder) throws DataModelException {
    YangEntityToResolveInfoImpl<YangLeafRef> leafRefInfo = new YangEntityToResolveInfoImpl<>();
    YangLeafRef leafRef = (YangLeafRef) type.getDataTypeExtendedInfo();
    // Conversion of prefixes in absolute path while cloning them.
    convertThePrefixesDuringChange(leafRef, yangUses);
    leafRef.setParentNode(holder);
    leafRefInfo.setEntityToResolve(leafRef);
    return setInformationInEntity(leafRefInfo, holder, leafRef.getCharPosition(), leafRef.getLineNumber());
}
#end_block

#method_before
private static List<YangEntityToResolveInfoImpl> getUnionResolvableEntity(YangType type, boolean isLeaf) throws DataModelException {
    YangUnion union = (YangUnion) type.getDataTypeExtendedInfo();
    List<YangType<?>> typeList = union.getTypeList();
    List<YangEntityToResolveInfoImpl> unionList = new ArrayList<>();
    List<YangEntityToResolveInfoImpl> entity;
    for (YangType unionType : typeList) {
        entity = getUnresolvedTypeList(unionType.getDataType(), unionType, union, null, isLeaf);
        if (isListPresent(entity)) {
            unionList.addAll(entity);
        }
    }
    return unionList;
}
#method_after
private static List<YangEntityToResolveInfoImpl> getUnionResolvableEntity(YangType type, boolean isLeaf) throws DataModelException {
    YangUnion union = (YangUnion) type.getDataTypeExtendedInfo();
    List<YangType<?>> typeList = union.getTypeList();
    List<YangEntityToResolveInfoImpl> unionList = new ArrayList<>();
    List<YangEntityToResolveInfoImpl> entity;
    for (YangType unionType : typeList) {
        entity = getUnresolvedTypeList(unionType.getDataType(), unionType, union, null, isLeaf);
        if (nonEmpty(entity)) {
            unionList.addAll(entity);
        }
    }
    return unionList;
}
#end_block

#method_before
private static void convertThePrefixesDuringChange(YangLeafRef leafrefForCloning, YangUses yangUses) throws DataModelException {
    List<YangAtomicPath> atomicPathList = leafrefForCloning.getAtomicPath();
    if (atomicPathList != null && !atomicPathList.isEmpty()) {
        Iterator<YangAtomicPath> atomicPathIterator = atomicPathList.listIterator();
        while (atomicPathIterator.hasNext()) {
            YangAtomicPath atomicPath = atomicPathIterator.next();
            Map<String, String> prefixesAndItsImportNameNode = leafrefForCloning.getPrefixWithNode();
            String prefixInPath = atomicPath.getNodeIdentifier().getPrefix();
            String importedNodeName = prefixesAndItsImportNameNode.get(prefixInPath);
            assignCurrentLeafedWithNewPrefixes(importedNodeName, atomicPath, yangUses);
        }
    }
}
#method_after
private static void convertThePrefixesDuringChange(YangLeafRef leafrefForCloning, YangUses yangUses) throws DataModelException {
    List<YangAtomicPath> atomicPathList = leafrefForCloning.getAtomicPath();
    if (atomicPathList != null && !atomicPathList.isEmpty()) {
        Iterator<YangAtomicPath> atomicPathIterator = atomicPathList.listIterator();
        while (atomicPathIterator.hasNext()) {
            YangAtomicPath atomicPath = atomicPathIterator.next();
            Map<String, String> prefixesAndItsImportNameNode = leafrefForCloning.getPrefixAndNode();
            String prefixInPath = atomicPath.getNodeIdentifier().getPrefix();
            String importedNodeName = prefixesAndItsImportNameNode.get(prefixInPath);
            assignCurrentLeafedWithNewPrefixes(importedNodeName, atomicPath, yangUses);
        }
    }
}
#end_block

#method_before
public static String getRpcServiceMethod(String rpcName, String input, String output) {
    String inputVal = null;
    if (input != null) {
        inputVal = RPC_INPUT_VAR_NAME;
    }
    return methodSignature(rpcName, EMPTY_STRING, null, inputVal, output, input, INTERFACE_TYPE) + NEW_LINE;
}
#method_after
public static String getRpcServiceMethod(String rpcName, String input, String output) {
    String inputVal = input == null ? null : RPC_INPUT_VAR_NAME;
    return methodSignature(rpcName, EMPTY_STRING, null, inputVal, output, input, INTERFACE_TYPE) + NEW_LINE;
}
#end_block

#method_before
private void addRpcString(JavaAttributeInfo inAttr, JavaAttributeInfo outAttr, String rpcName) throws IOException {
    String rpcInput = null;
    String rpcOutput = VOID;
    String rpcIn = EMPTY_STRING;
    if (inAttr != null) {
        rpcInput = getCapitalCase(inAttr.getAttributeName());
    }
    if (outAttr != null) {
        rpcOutput = getCapitalCase(outAttr.getAttributeName());
    }
    if (rpcInput != null) {
        rpcIn = RPC_INPUT_VAR_NAME;
    }
    appendToFile(rpcInterfaceTempFileHandle, generateJavaDocForRpc(rpcName, rpcIn, rpcOutput) + getRpcServiceMethod(rpcName, rpcInput, rpcOutput));
}
#method_after
private void addRpcString(JavaAttributeInfo inAttr, JavaAttributeInfo outAttr, String rpcName) throws IOException {
    String rpcInput = inAttr == null ? null : getCapitalCase(inAttr.getAttributeName());
    String rpcOutput = outAttr == null ? VOID : getCapitalCase(outAttr.getAttributeName());
    String rpcIn = rpcInput == null ? EMPTY_STRING : RPC_INPUT_VAR_NAME;
    appendToFile(rpcInterfaceTempFileHandle, generateJavaDocForRpc(rpcName, rpcIn, rpcOutput) + getRpcServiceMethod(rpcName, rpcInput, rpcOutput));
}
#end_block

#method_before
public byte[] createAuthenticationData(LispAuthenticationKeyEnum authType, String authKey) {
    LispMacAuthentication macAuth;
    int authLength;
    byte[] authData;
    switch(authType) {
        case SHA1:
        case SHA256:
            macAuth = new LispMacAuthentication(authType.getName());
            authLength = macAuth.getAuthenticationLength();
            authData = macAuth.getAuthenticationData(authKey, new byte[authLength]);
            break;
        case NONE:
        case UNKNOWN:
        default:
            macAuth = new LispMacAuthentication();
            authData = macAuth.getAuthenticationData();
            break;
    }
    return authData;
}
#method_after
public byte[] createAuthenticationData(LispAuthenticationKeyEnum authType, String authKey) {
    LispMacAuthentication macAuth = new LispMacAuthentication(authType);
    int authLength;
    byte[] authData;
    switch(authType) {
        case SHA1:
        case SHA256:
            authLength = macAuth.getAuthenticationLength();
            authData = macAuth.getAuthenticationData(authKey, new byte[authLength]);
            break;
        case NONE:
        case UNKNOWN:
        default:
            authData = macAuth.getAuthenticationData();
            break;
    }
    return authData;
}
#end_block

#method_before
@Override
protected void initChannel(Channel channel) throws Exception {
    ChannelPipeline pipeline = channel.pipeline();
    LispChannelHandler handler = new LispChannelHandler();
    idleHandler = new IdleStateHandler(20, 25, 0);
    readTimeoutHandler = new ReadTimeoutHandler(30);
    pipeline.addLast("lispmessagedecoder", new LispMessageDecoder());
    pipeline.addLast("lispmessageencoder", new LispMessageEncoder());
    pipeline.addLast("idle", idleHandler);
    pipeline.addLast("readTimeout", readTimeoutHandler);
    pipeline.addLast("handler", handler);
}
#method_after
@Override
protected void initChannel(Channel channel) throws Exception {
    ChannelPipeline pipeline = channel.pipeline();
    LispChannelHandler handler = new LispChannelHandler();
    idleHandler = new IdleStateHandler(READER_IDLE_TIME_SECOND, WRITER_IDLE_TIME_SECOND, ALL_IDLE_TIME_SECOND);
    readTimeoutHandler = new ReadTimeoutHandler(READ_TIMEOUT_SECOND);
    pipeline.addLast("lispmessagedecoder", new LispMessageDecoder());
    pipeline.addLast("lispmessageencoder", new LispMessageEncoder());
    pipeline.addLast("idle", idleHandler);
    pipeline.addLast("readTimeout", readTimeoutHandler);
    pipeline.addLast("handler", handler);
}
#end_block

#method_before
@Override
public ObjectNode encode(TrafficStatInfo tsi, CodecContext context) {
    checkNotNull(tsi, "TrafficStatInfo cannot be null");
    return context.mapper().createObjectNode().put("ethernetBytes", tsi.getEthernetBytes()).put("discardedBytes", tsi.getDiscardedBytes()).put("ipPackets", tsi.getIpPackets()).put("totalPackets", tsi.getTotalPackets()).put("ipBytes", tsi.getIpBytes()).put("avgPktSize", tsi.getAvgPktSize()).put("uniqueFlows", tsi.getUniqueFlows()).put("tcpPackets", tsi.getTcpPackets()).put("udpPackets", tsi.getUdpPackets()).put("dpiThroughputPps", tsi.getDpiThroughputPps()).put("dpiThroughputBps", tsi.getDpiThroughputBps()).put("trafficThroughputPps", tsi.getTrafficThroughputPps()).put("trafficThroughputBps", tsi.getTrafficThroughputBps()).put("trafficDurationSec", tsi.getTrafficDurationSec()).put("guessedFlowProtos", tsi.getGuessedFlowProtos());
}
#method_after
@Override
public ObjectNode encode(TrafficStatInfo tsi, CodecContext context) {
    checkNotNull(tsi, "TrafficStatInfo cannot be null");
    return context.mapper().createObjectNode().put("ethernetBytes", tsi.ethernetBytes()).put("discardedBytes", tsi.discardedBytes()).put("ipPackets", tsi.ipPackets()).put("totalPackets", tsi.totalPackets()).put("ipBytes", tsi.ipBytes()).put("avgPktSize", tsi.avgPktSize()).put("uniqueFlows", tsi.uniqueFlows()).put("tcpPackets", tsi.tcpPackets()).put("udpPackets", tsi.udpPackets()).put("dpiThroughputPps", tsi.dpiThroughputPps()).put("dpiThroughputBps", tsi.dpiThroughputBps()).put("trafficThroughputPps", tsi.trafficThroughputPps()).put("trafficThroughputBps", tsi.trafficThroughputBps()).put("trafficDurationSec", tsi.trafficDurationSec()).put("guessedFlowProtos", tsi.guessedFlowProtos());
}
#end_block

#method_before
@Override
public ObjectNode encode(ProtocolStatInfo psi, CodecContext context) {
    checkNotNull(psi, "ProtocolStatInfo cannot be null");
    return context.mapper().createObjectNode().put("name", psi.getName()).put("breed", psi.getBreed()).put("packets", psi.getPackets()).put("bytes", psi.getBytes()).put("flows", psi.getFlows());
}
#method_after
@Override
public ObjectNode encode(ProtocolStatInfo psi, CodecContext context) {
    checkNotNull(psi, "ProtocolStatInfo cannot be null");
    return context.mapper().createObjectNode().put("name", psi.name()).put("breed", psi.breed()).put("packets", psi.packets()).put("bytes", psi.bytes()).put("flows", psi.flows());
}
#end_block

#method_before
@Override
public ObjectNode encode(FlowStatInfo fsi, CodecContext context) {
    checkNotNull(fsi, "FlowStatInfo cannot be null");
    return context.mapper().createObjectNode().put("protocol", fsi.getProtocol()).put("hostAName", fsi.getHostAName()).put("hostAPort", fsi.getHostAPort()).put("hostBName", fsi.getHostBName()).put("hostBPort", fsi.getHostBPort()).put("detectedProtocol", fsi.getDetectedProtocol()).put("detectedProtocolName", fsi.getDetectedProtocolName()).put("packets", fsi.getPackets()).put("bytes", fsi.getBytes()).put("hostServerName", fsi.getHostServerName());
}
#method_after
@Override
public ObjectNode encode(FlowStatInfo fsi, CodecContext context) {
    checkNotNull(fsi, "FlowStatInfo cannot be null");
    return context.mapper().createObjectNode().put("protocol", fsi.protocol()).put("hostAName", fsi.hostAName()).put("hostAPort", fsi.hostAPort()).put("hostBName", fsi.hostBName()).put("hostBPort", fsi.hostBPort()).put("detectedProtocol", fsi.detectedProtocol()).put("detectedProtocolName", fsi.detectedProtocolName()).put("packets", fsi.packets()).put("bytes", fsi.bytes()).put("hostServerName", fsi.hostServerName());
}
#end_block

#method_before
@Override
public ObjectNode encode(DpiStatistics ds, CodecContext context) {
    checkNotNull(ds, "DpiStatistics cannot be null");
    final ObjectNode result = context.mapper().createObjectNode();
    result.put(RECEIVED_TIME, ds.getReceivedTime());
    final JsonCodec<DpiStatInfo> dpiStatInfoCodec = context.codec(DpiStatInfo.class);
    final ObjectNode jsonDpiStatInfo = dpiStatInfoCodec.encode(ds.getDpiStatInfo(), context);
    result.set(DPI_STATISTICS, jsonDpiStatInfo);
    return result;
}
#method_after
@Override
public ObjectNode encode(DpiStatistics ds, CodecContext context) {
    checkNotNull(ds, "DpiStatistics cannot be null");
    final ObjectNode result = context.mapper().createObjectNode();
    result.put(RECEIVED_TIME, ds.receivedTime());
    final JsonCodec<DpiStatInfo> dpiStatInfoCodec = context.codec(DpiStatInfo.class);
    final ObjectNode jsonDpiStatInfo = dpiStatInfoCodec.encode(ds.dpiStatInfo(), context);
    result.set(DPI_STATISTICS, jsonDpiStatInfo);
    return result;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getDpisLatest(@QueryParam("topn") int topn) {
    log.debug("getDpisLatest request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics retDs;
    if (ds == null) {
        retDs = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        retDs = ds;
    } else {
        if (topn > MAX_TOPN) {
            topn = MAX_TOPN;
        }
        retDs = new DpiStatistics(ds.getReceivedTime(), new DpiStatInfo(ds.getDpiStatInfo().getTrafficStatistics()));
        List<ProtocolStatInfo> psiList = ds.getDpiStatInfo().getDetectedProtos();
        if (psiList != null) {
            // sorts protocol list with descending order based on bytes within topn
            List<ProtocolStatInfo> psiListSorted = psiList.stream().sorted(PROTOCOL_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            retDs.getDpiStatInfo().setDetectedProtos(psiListSorted);
        }
        List<FlowStatInfo> fsiList = ds.getDpiStatInfo().getKnownFlows();
        if (fsiList != null) {
            // sorts known flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            retDs.getDpiStatInfo().setKnownFlows(fsiListSorted);
        }
        fsiList = ds.getDpiStatInfo().getUnknownFlows();
        if (fsiList != null) {
            // sorts unknown flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            retDs.getDpiStatInfo().setUnknownFlows(fsiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(retDs, this);
    return ok(result).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
public Response getDpisLatest(@QueryParam("topn") int topn) {
    log.debug("getDpisLatest request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics retDs;
    if (ds == null) {
        retDs = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        retDs = ds;
    } else {
        if (topn > MAX_TOPN) {
            topn = MAX_TOPN;
        }
        retDs = new DpiStatistics(ds.receivedTime(), new DpiStatInfo(ds.dpiStatInfo().trafficStatistics()));
        List<ProtocolStatInfo> psiList = ds.dpiStatInfo().detectedProtos();
        if (psiList != null) {
            // sorts protocol list with descending order based on bytes within topn
            List<ProtocolStatInfo> psiListSorted = psiList.stream().sorted(PROTOCOL_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            retDs.dpiStatInfo().setDetectedProtos(psiListSorted);
        }
        List<FlowStatInfo> fsiList = ds.dpiStatInfo().knownFlows();
        if (fsiList != null) {
            // sorts known flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            retDs.dpiStatInfo().setKnownFlows(fsiListSorted);
        }
        fsiList = ds.dpiStatInfo().unknownFlows();
        if (fsiList != null) {
            // sorts unknown flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            retDs.dpiStatInfo().setUnknownFlows(fsiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(retDs, this);
    return ok(result).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("traffic")
public Response getTrafficStatistics() {
    log.debug("getTrafficStatistics request");
    DpiStatistics ds = service.getDpiStatisticsLatest();
    if (ds == null) {
        ds = new DpiStatistics("", new DpiStatInfo());
    }
    DpiStatInfo dsi = new DpiStatInfo();
    dsi.setTrafficStatistics(ds.getDpiStatInfo().getTrafficStatistics());
    DpiStatistics dsTraffic = new DpiStatistics(ds.getReceivedTime(), dsi);
    ObjectNode result = codec(DpiStatistics.class).encode(dsTraffic, this);
    return ok(result).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("traffic")
public Response getTrafficStatistics() {
    log.debug("getTrafficStatistics request");
    DpiStatistics ds = service.getDpiStatisticsLatest();
    if (ds == null) {
        ds = new DpiStatistics("", new DpiStatInfo());
    }
    DpiStatInfo dsi = new DpiStatInfo();
    dsi.setTrafficStatistics(ds.dpiStatInfo().trafficStatistics());
    DpiStatistics dsTraffic = new DpiStatistics(ds.receivedTime(), dsi);
    ObjectNode result = codec(DpiStatistics.class).encode(dsTraffic, this);
    return ok(result).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("protocols")
public Response getDetectedProtocols(@QueryParam("topn") int topn) {
    log.debug("getDetectedProtocols request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics dsProtocol;
    if (ds == null) {
        dsProtocol = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        DpiStatInfo dsi = new DpiStatInfo();
        dsi.setDetectedProtos(ds.getDpiStatInfo().getDetectedProtos());
        dsProtocol = new DpiStatistics(ds.getReceivedTime(), dsi);
    } else {
        if (topn > MAX_TOPN) {
            topn = MAX_TOPN;
        }
        dsProtocol = new DpiStatistics(ds.getReceivedTime(), new DpiStatInfo());
        List<ProtocolStatInfo> psiList = ds.getDpiStatInfo().getDetectedProtos();
        if (psiList != null) {
            // sorts protocol list with descending order based on bytes within topn
            List<ProtocolStatInfo> psiListSorted = psiList.stream().sorted(PROTOCOL_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            dsProtocol.getDpiStatInfo().setDetectedProtos(psiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(dsProtocol, this);
    return ok(result).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("protocols")
public Response getDetectedProtocols(@QueryParam("topn") int topn) {
    log.debug("getDetectedProtocols request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics dsProtocol;
    if (ds == null) {
        dsProtocol = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        DpiStatInfo dsi = new DpiStatInfo();
        dsi.setDetectedProtos(ds.dpiStatInfo().detectedProtos());
        dsProtocol = new DpiStatistics(ds.receivedTime(), dsi);
    } else {
        if (topn > MAX_TOPN) {
            topn = MAX_TOPN;
        }
        dsProtocol = new DpiStatistics(ds.receivedTime(), new DpiStatInfo());
        List<ProtocolStatInfo> psiList = ds.dpiStatInfo().detectedProtos();
        if (psiList != null) {
            // sorts protocol list with descending order based on bytes within topn
            List<ProtocolStatInfo> psiListSorted = psiList.stream().sorted(PROTOCOL_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            dsProtocol.dpiStatInfo().setDetectedProtos(psiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(dsProtocol, this);
    return ok(result).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("knownFlows")
public Response getKnownFlows(@QueryParam("topn") int topn) {
    log.debug("getKnownFlows request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics dsKnownFlows;
    if (ds == null) {
        dsKnownFlows = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        DpiStatInfo dsi = new DpiStatInfo();
        dsi.setKnownFlows(ds.getDpiStatInfo().getKnownFlows());
        dsKnownFlows = new DpiStatistics(ds.getReceivedTime(), dsi);
    } else {
        if (topn > MAX_TOPN) {
            topn = MAX_TOPN;
        }
        dsKnownFlows = new DpiStatistics(ds.getReceivedTime(), new DpiStatInfo());
        List<FlowStatInfo> fsiList = ds.getDpiStatInfo().getKnownFlows();
        if (fsiList != null) {
            // sorts known flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            dsKnownFlows.getDpiStatInfo().setKnownFlows(fsiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(dsKnownFlows, this);
    return ok(result).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("knownFlows")
public Response getKnownFlows(@QueryParam("topn") int topn) {
    log.debug("getKnownFlows request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics dsKnownFlows;
    if (ds == null) {
        dsKnownFlows = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        DpiStatInfo dsi = new DpiStatInfo();
        dsi.setKnownFlows(ds.dpiStatInfo().knownFlows());
        dsKnownFlows = new DpiStatistics(ds.receivedTime(), dsi);
    } else {
        if (topn > MAX_TOPN) {
            topn = MAX_TOPN;
        }
        dsKnownFlows = new DpiStatistics(ds.receivedTime(), new DpiStatInfo());
        List<FlowStatInfo> fsiList = ds.dpiStatInfo().knownFlows();
        if (fsiList != null) {
            // sorts known flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            dsKnownFlows.dpiStatInfo().setKnownFlows(fsiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(dsKnownFlows, this);
    return ok(result).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("unknownFlows")
public Response getUnknownFlows(@QueryParam("topn") int topn) {
    log.debug("getUnknownFlows request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics dsUnknownFlows;
    if (ds == null) {
        dsUnknownFlows = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        DpiStatInfo dsi = new DpiStatInfo();
        dsi.setUnknownFlows(ds.getDpiStatInfo().getUnknownFlows());
        dsUnknownFlows = new DpiStatistics(ds.getReceivedTime(), dsi);
    } else {
        if (topn > 100) {
            topn = 100;
        }
        dsUnknownFlows = new DpiStatistics(ds.getReceivedTime(), new DpiStatInfo());
        List<FlowStatInfo> fsiList = ds.getDpiStatInfo().getUnknownFlows();
        if (fsiList != null) {
            // sorts unknown flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            dsUnknownFlows.getDpiStatInfo().setUnknownFlows(fsiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(dsUnknownFlows, this);
    return ok(result).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("unknownFlows")
public Response getUnknownFlows(@QueryParam("topn") int topn) {
    log.debug("getUnknownFlows request with topn={}", topn);
    DpiStatistics ds = service.getDpiStatisticsLatest();
    DpiStatistics dsUnknownFlows;
    if (ds == null) {
        dsUnknownFlows = new DpiStatistics("", new DpiStatInfo());
    } else if (topn <= 0) {
        DpiStatInfo dsi = new DpiStatInfo();
        dsi.setUnknownFlows(ds.dpiStatInfo().unknownFlows());
        dsUnknownFlows = new DpiStatistics(ds.receivedTime(), dsi);
    } else {
        if (topn > 100) {
            topn = 100;
        }
        dsUnknownFlows = new DpiStatistics(ds.receivedTime(), new DpiStatInfo());
        List<FlowStatInfo> fsiList = ds.dpiStatInfo().unknownFlows();
        if (fsiList != null) {
            // sorts unknown flow list with descending order based on bytes within topn
            List<FlowStatInfo> fsiListSorted = fsiList.stream().sorted(FLOW_STAT_INFO_COMPARATOR).limit(topn).collect(Collectors.toList());
            dsUnknownFlows.dpiStatInfo().setUnknownFlows(fsiListSorted);
        }
    }
    ObjectNode result = codec(DpiStatistics.class).encode(dsUnknownFlows, this);
    return ok(result).build();
}
#end_block

#method_before
@Activate
public void activate() {
    codecs.clear();
    registerCodec(Application.class, new ApplicationCodec());
    registerCodec(ApplicationId.class, new ApplicationIdCodec());
    registerCodec(ControllerNode.class, new ControllerNodeCodec());
    registerCodec(Annotations.class, new AnnotationsCodec());
    registerCodec(Device.class, new DeviceCodec());
    registerCodec(Port.class, new PortCodec());
    registerCodec(ConnectPoint.class, new ConnectPointCodec());
    registerCodec(Link.class, new LinkCodec());
    registerCodec(Host.class, new HostCodec());
    registerCodec(HostLocation.class, new HostLocationCodec());
    registerCodec(HostToHostIntent.class, new HostToHostIntentCodec());
    registerCodec(PointToPointIntent.class, new PointToPointIntentCodec());
    registerCodec(SinglePointToMultiPointIntent.class, new SinglePointToMultiPointIntentCodec());
    registerCodec(Intent.class, new IntentCodec());
    registerCodec(ConnectivityIntent.class, new ConnectivityIntentCodec());
    registerCodec(FlowEntry.class, new FlowEntryCodec());
    registerCodec(FlowRule.class, new FlowRuleCodec());
    registerCodec(TrafficTreatment.class, new TrafficTreatmentCodec());
    registerCodec(TrafficSelector.class, new TrafficSelectorCodec());
    registerCodec(Instruction.class, new InstructionCodec());
    registerCodec(Criterion.class, new CriterionCodec());
    registerCodec(Ethernet.class, new EthernetCodec());
    registerCodec(Constraint.class, new ConstraintCodec());
    registerCodec(Topology.class, new TopologyCodec());
    registerCodec(TopologyCluster.class, new TopologyClusterCodec());
    registerCodec(Path.class, new PathCodec());
    registerCodec(Group.class, new GroupCodec());
    registerCodec(Driver.class, new DriverCodec());
    registerCodec(GroupBucket.class, new GroupBucketCodec());
    registerCodec(Load.class, new LoadCodec());
    registerCodec(MeterRequest.class, new MeterRequestCodec());
    registerCodec(Meter.class, new MeterCodec());
    registerCodec(Band.class, new MeterBandCodec());
    registerCodec(TableStatisticsEntry.class, new TableStatisticsEntryCodec());
    registerCodec(PortStatistics.class, new PortStatisticsCodec());
    registerCodec(Metric.class, new MetricCodec());
    registerCodec(FilteringObjective.class, new FilteringObjectiveCodec());
    registerCodec(ForwardingObjective.class, new ForwardingObjectiveCodec());
    registerCodec(NextObjective.class, new NextObjectiveCodec());
    registerCodec(McastRoute.class, new McastRouteCodec());
    registerCodec(DeviceKey.class, new DeviceKeyCodec());
    registerCodec(Region.class, new RegionCodec());
    registerCodec(TenantId.class, new TenantIdCodec());
    registerCodec(VirtualNetwork.class, new VirtualNetworkCodec());
    registerCodec(VirtualDevice.class, new VirtualDeviceCodec());
    registerCodec(VirtualPort.class, new VirtualPortCodec());
    registerCodec(VirtualLink.class, new VirtualLinkCodec());
    registerCodec(VirtualHost.class, new VirtualHostCodec());
    registerCodec(MastershipTerm.class, new MastershipTermCodec());
    registerCodec(MastershipRole.class, new MastershipRoleCodec());
    registerCodec(RoleInfo.class, new RoleInfoCodec());
    registerCodec(DpiStatistics.class, new DpiStatisticsCodec());
    registerCodec(DpiStatInfo.class, new DpiStatInfoCodec());
    registerCodec(TrafficStatInfo.class, new TrafficStatInfoCodec());
    registerCodec(ProtocolStatInfo.class, new ProtocolStatInfoCodec());
    registerCodec(FlowStatInfo.class, new FlowStatInfoCodec());
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    codecs.clear();
    registerCodec(Application.class, new ApplicationCodec());
    registerCodec(ApplicationId.class, new ApplicationIdCodec());
    registerCodec(ControllerNode.class, new ControllerNodeCodec());
    registerCodec(Annotations.class, new AnnotationsCodec());
    registerCodec(Device.class, new DeviceCodec());
    registerCodec(Port.class, new PortCodec());
    registerCodec(ConnectPoint.class, new ConnectPointCodec());
    registerCodec(Link.class, new LinkCodec());
    registerCodec(Host.class, new HostCodec());
    registerCodec(HostLocation.class, new HostLocationCodec());
    registerCodec(HostToHostIntent.class, new HostToHostIntentCodec());
    registerCodec(PointToPointIntent.class, new PointToPointIntentCodec());
    registerCodec(SinglePointToMultiPointIntent.class, new SinglePointToMultiPointIntentCodec());
    registerCodec(Intent.class, new IntentCodec());
    registerCodec(ConnectivityIntent.class, new ConnectivityIntentCodec());
    registerCodec(FlowEntry.class, new FlowEntryCodec());
    registerCodec(FlowRule.class, new FlowRuleCodec());
    registerCodec(TrafficTreatment.class, new TrafficTreatmentCodec());
    registerCodec(TrafficSelector.class, new TrafficSelectorCodec());
    registerCodec(Instruction.class, new InstructionCodec());
    registerCodec(Criterion.class, new CriterionCodec());
    registerCodec(Ethernet.class, new EthernetCodec());
    registerCodec(Constraint.class, new ConstraintCodec());
    registerCodec(Topology.class, new TopologyCodec());
    registerCodec(TopologyCluster.class, new TopologyClusterCodec());
    registerCodec(Path.class, new PathCodec());
    registerCodec(DisjointPath.class, new DisjointPathCodec());
    registerCodec(Group.class, new GroupCodec());
    registerCodec(Driver.class, new DriverCodec());
    registerCodec(GroupBucket.class, new GroupBucketCodec());
    registerCodec(Load.class, new LoadCodec());
    registerCodec(MeterRequest.class, new MeterRequestCodec());
    registerCodec(Meter.class, new MeterCodec());
    registerCodec(Band.class, new MeterBandCodec());
    registerCodec(TableStatisticsEntry.class, new TableStatisticsEntryCodec());
    registerCodec(PortStatistics.class, new PortStatisticsCodec());
    registerCodec(Metric.class, new MetricCodec());
    registerCodec(FilteringObjective.class, new FilteringObjectiveCodec());
    registerCodec(ForwardingObjective.class, new ForwardingObjectiveCodec());
    registerCodec(NextObjective.class, new NextObjectiveCodec());
    registerCodec(McastRoute.class, new McastRouteCodec());
    registerCodec(DeviceKey.class, new DeviceKeyCodec());
    registerCodec(Region.class, new RegionCodec());
    registerCodec(TenantId.class, new TenantIdCodec());
    registerCodec(VirtualNetwork.class, new VirtualNetworkCodec());
    registerCodec(VirtualDevice.class, new VirtualDeviceCodec());
    registerCodec(VirtualPort.class, new VirtualPortCodec());
    registerCodec(VirtualLink.class, new VirtualLinkCodec());
    registerCodec(VirtualHost.class, new VirtualHostCodec());
    registerCodec(MastershipTerm.class, new MastershipTermCodec());
    registerCodec(MastershipRole.class, new MastershipRoleCodec());
    registerCodec(RoleInfo.class, new RoleInfoCodec());
    registerCodec(DpiStatistics.class, new DpiStatisticsCodec());
    registerCodec(DpiStatInfo.class, new DpiStatInfoCodec());
    registerCodec(TrafficStatInfo.class, new TrafficStatInfoCodec());
    registerCodec(ProtocolStatInfo.class, new ProtocolStatInfoCodec());
    registerCodec(FlowStatInfo.class, new FlowStatInfoCodec());
    log.info("Started");
}
#end_block

#method_before
@Override
protected void execute() {
    DpiStatisticsManagerService dsms = get(DpiStatisticsManagerService.class);
    DpiStatisticsJson dsj;
    DpiStatistics ds;
    if (lastn != null) {
        int lastN = parseIntWithDefault(lastn, DEFAULT_LASTN);
        if (outputJson()) {
            List<DpiStatisticsJson> dpiStatisticsJsons = dsms.getDpiStatisticsJson(lastN);
            printDpiResultListJson(dpiStatisticsJsons);
        } else {
            List<DpiStatistics> dpiStatistics = dsms.getDpiStatistics(lastN);
            printDpiResultListClass(dpiStatistics);
        }
    } else if (permanent) {
        int i = 0;
        while (true) {
            try {
                if (outputJson()) {
                    dsj = dsms.getDpiStatisticsJsonLatest();
                    if (dsj == null) {
                        return;
                    }
                    printDpiStatisticsJson(i++, dsj);
                } else {
                    ds = dsms.getDpiStatisticsLatest();
                    if (ds == null) {
                        return;
                    }
                    printDpiStatisticsClass(i++, ds);
                }
                sleep(5000);
            } catch (Exception e) {
                return;
            }
        }
    } else {
        // latest == true
        if (outputJson()) {
            dsj = dsms.getDpiStatisticsJsonLatest();
            if (dsj == null) {
                return;
            }
            printDpiStatisticsJson(0, dsj);
        } else {
            ds = dsms.getDpiStatisticsLatest();
            if (ds == null) {
                return;
            }
            printDpiStatisticsClass(0, ds);
        }
    }
}
#method_after
@Override
protected void execute() {
    DpiStatisticsManagerService dsms = get(DpiStatisticsManagerService.class);
    DpiStatistics ds;
    int topnP = DEFAULT_TOPNP;
    int topnF = DEFAULT_TOPNF;
    if (topnProtocols != null) {
        topnP = parseIntWithDefault(topnProtocols, DEFAULT_TOPNP);
        if (topnP <= 0) {
            print("Invalid detected protocol topn number: 0 < valid number <= 100");
            return;
        }
    }
    if (topnFlows != null) {
        topnF = parseIntWithDefault(topnFlows, DEFAULT_TOPNF);
        if (topnF <= 0) {
            print("Invalid known or unknown flows topn number: 0 < valid number <= 100");
            return;
        }
    }
    boolean isTopn = (topnP > 0 || topnF > 0);
    if (all) {
        dProtocols = true;
        kFlows = true;
        uFlows = true;
    }
    if (receivedTime != null) {
        if (isTopn) {
            ds = dsms.getDpiStatistics(receivedTime, topnP, topnF);
        } else {
            ds = dsms.getDpiStatistics(receivedTime);
        }
        if (ds == null) {
            print(RECEIVED_TIME_ERROR_MSG);
            return;
        }
        printDpiStatistics(0, ds);
    } else if (lastn != null) {
        int lastN = parseIntWithDefault(lastn, DEFAULT_LASTN);
        List<DpiStatistics> dsList;
        if (isTopn) {
            dsList = dsms.getDpiStatistics(lastN, topnP, topnF);
        } else {
            dsList = dsms.getDpiStatistics(lastN);
        }
        printDpiStatisticsList(dsList);
    } else if (permanent) {
        int i = 0;
        while (true) {
            try {
                if (isTopn) {
                    ds = dsms.getDpiStatisticsLatest(topnP, topnF);
                } else {
                    ds = dsms.getDpiStatisticsLatest();
                }
                if (ds == null) {
                    print(NO_DPI_ENTRY_ERROR_MSG);
                    return;
                }
                printDpiStatistics(i++, ds);
                sleep(5000);
            } catch (Exception e) {
                return;
            }
        }
    } else {
        // latest == true
        if (isTopn) {
            ds = dsms.getDpiStatisticsLatest(topnP, topnF);
        } else {
            ds = dsms.getDpiStatisticsLatest();
        }
        if (ds == null) {
            print(NO_DPI_ENTRY_ERROR_MSG);
            return;
        }
        printDpiStatistics(0, ds);
    }
}
#end_block

#method_before
private int parseIntWithDefault(String lastn, int defaultn) {
    try {
        lastn = lastn.trim();
        return Integer.parseUnsignedInt(lastn);
    } catch (NumberFormatException e) {
        return defaultn;
    }
}
#method_after
private int parseIntWithDefault(String lastN, int defaultN) {
    try {
        lastN = lastN.trim();
        return Integer.parseUnsignedInt(lastN);
    } catch (NumberFormatException e) {
        return defaultN;
    }
}
#end_block

#method_before
private void printDpiStatisticsJson(int number, DpiStatisticsJson dsj) {
    String index = number < 0 ? String.format("  -  ") : String.format("%5d", number);
    if (dsj.receivedTime().equals("")) {
        print("RecievedTime is null, No valid Dpis Statistics!");
        return;
    }
    print("<----- (%s) DPI Statistics Time [%s] ----->", index, dsj.receivedTime());
    print("      %s", dsj.resultJson());
    print("<--------------------------------------------------------->");
}
#method_after
private void printDpiStatisticsJson(int number, DpiStatistics ds) {
    String index = number < 0 ? String.format("  -  ") : String.format("%5d", number);
    if (ds.receivedTime().equals("")) {
        print("ReceivedTime is null, No valid DPI Statistics!");
        return;
    }
    print("<--- (%s) DPI Statistics Time [%s] --->", index, ds.receivedTime());
    print("      %s", ds.toString());
    print("<--------------------------------------------------------->");
}
#end_block

#method_before
private void printDpiStatisticsClass(int number, DpiStatistics ds) {
    String printLine = "";
    String index = number < 0 ? String.format("  -  ") : String.format("%5d", number);
    DpiStatInfo dsi = ds.getDpiStatInfo();
    if (dsi == null) {
        return;
    }
    if (ds.getReceivedTime().equals("")) {
        print("RecievedTime is null, No valid Dpis Statistics!");
        return;
    }
    print("<----- (%s) DPI Statistics Time [%s] ----->", index, ds.getReceivedTime());
    print("Traffic Statistics:");
    TrafficStatInfo tsi = dsi.getTrafficStatistics();
    printLine = String.format("        %-30s %-30s", "ethernet.bytes:" + ":", tsi.getEthernetBytes());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "discarded.bytes" + ":", tsi.getDiscardedBytes());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "ip.packets" + ":", tsi.getIpPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "total.packets" + ":", tsi.getTotalPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "ip.bytes" + ":", tsi.getIpBytes());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "avg.pkt.size" + ":", tsi.getAvgPktSize());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "unique.flows" + ":", tsi.getUniqueFlows());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "tcp.packets" + ":", tsi.getTcpPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "udp.packets" + ":", tsi.getTcpPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "dpi.throughput.pps" + ":", tsi.getDpiThroughputPps() + " pps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "dpi.throughput.bps" + ":", tsi.getDpiThroughputBps() + " bps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "traffic.throughput.pps" + ":", tsi.getTrafficThroughputPps() + " pps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "traffic.throughput.bps" + ":", tsi.getTrafficThroughputBps() + " bps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "traffic.duration.sec" + ":", tsi.getTrafficDurationSec() + " sec");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "guessed.flow.protos" + ":", tsi.getGuessedFlowProtos());
    print("%s", printLine);
    print("");
    print("Detected Protocols:");
    List<ProtocolStatInfo> psiList = dsi.getDetectedProtos();
    if (psiList != null) {
        psiList.forEach(psi -> print(makeProtocolString(psi)));
    }
    print("");
    print("Known Flows:");
    List<FlowStatInfo> fsiList = dsi.getKnownFlows();
    if (fsiList != null) {
        for (int i = 0; i < fsiList.size(); i++) {
            print(makeFlowString(fsiList.get(i), i));
        }
    }
    print("");
    print("Unknown Flows:");
    fsiList = dsi.getUnknownFlows();
    if (fsiList != null) {
        for (int i = 0; i < fsiList.size(); i++) {
            print(makeFlowString(fsiList.get(i), i));
        }
    }
    print("<--------------------------------------------------------->");
}
#method_after
private void printDpiStatisticsClass(int number, DpiStatistics ds) {
    String printLine = "";
    String index = number < 0 ? String.format("  -  ") : String.format("%5d", number);
    DpiStatInfo dsi = ds.dpiStatInfo();
    if (dsi == null) {
        return;
    }
    if (ds.receivedTime().equals("")) {
        print("ReceivedTime is null, No valid DPI Statistics!");
        return;
    }
    print("<--- (%s) DPI Statistics Time [%s] --->", index, ds.receivedTime());
    print("Traffic Statistics:");
    TrafficStatInfo tsi = dsi.trafficStatistics();
    printLine = String.format("        %-30s %-30s", "ethernet.bytes:" + ":", tsi.ethernetBytes());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "discarded.bytes" + ":", tsi.discardedBytes());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "ip.packets" + ":", tsi.ipPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "total.packets" + ":", tsi.totalPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "ip.bytes" + ":", tsi.ipBytes());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "avg.pkt.size" + ":", tsi.avgPktSize());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "unique.flows" + ":", tsi.uniqueFlows());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "tcp.packets" + ":", tsi.tcpPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "udp.packets" + ":", tsi.tcpPackets());
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "dpi.throughput.pps" + ":", tsi.dpiThroughputPps() + " pps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "dpi.throughput.bps" + ":", tsi.dpiThroughputBps() + " bps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "traffic.throughput.pps" + ":", tsi.trafficThroughputPps() + " pps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "traffic.throughput.bps" + ":", tsi.trafficThroughputBps() + " bps");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "traffic.duration.sec" + ":", tsi.trafficDurationSec() + " sec");
    print("%s", printLine);
    printLine = String.format("        %-30s %-30s", "guessed.flow.protos" + ":", tsi.guessedFlowProtos());
    print("%s", printLine);
    if (dProtocols || topnProtocols != null) {
        print("");
        print("Detected Protocols:");
        List<ProtocolStatInfo> psiList = dsi.detectedProtos();
        if (psiList != null) {
            psiList.forEach(psi -> print(makeProtocolString(psi)));
        }
    }
    List<FlowStatInfo> fsiList;
    if (kFlows || topnFlows != null) {
        print("");
        print("Known Flows:");
        fsiList = dsi.knownFlows();
        if (fsiList != null) {
            for (int i = 0; i < fsiList.size(); i++) {
                print(makeFlowString(fsiList.get(i), i));
            }
        }
    }
    if (uFlows || topnFlows != null) {
        print("");
        print("Unknown Flows:");
        fsiList = dsi.unknownFlows();
        if (fsiList != null) {
            for (int i = 0; i < fsiList.size(); i++) {
                print(makeFlowString(fsiList.get(i), i));
            }
        }
    }
    print("<--------------------------------------------------------->");
}
#end_block

#method_before
private String makeProtocolString(ProtocolStatInfo psi) {
    StringBuffer sb = new StringBuffer("        ");
    sb.append(String.format("%-20s", psi.getName()));
    sb.append(String.format(" %s: %-20s", "packets", psi.getPackets()));
    sb.append(String.format(" %s: %-20s", "bytes", psi.getBytes()));
    sb.append(String.format(" %s: %-20s", "flows", psi.getFlows()));
    return sb.toString();
}
#method_after
private String makeProtocolString(ProtocolStatInfo psi) {
    StringBuffer sb = new StringBuffer("        ");
    sb.append(String.format("%-20s", psi.name()));
    sb.append(String.format(" %s: %-20s", "packets", psi.packets()));
    sb.append(String.format(" %s: %-20s", "bytes", psi.bytes()));
    sb.append(String.format(" %s: %-20s", "flows", psi.flows()));
    return sb.toString();
}
#end_block

#method_before
private String makeFlowString(FlowStatInfo fsi, int index) {
    StringBuffer sb = new StringBuffer("        ");
    sb.append(String.format("%-8d ", index));
    sb.append(String.format("%s ", fsi.getProtocol()));
    sb.append(String.format("%s", fsi.getHostAName()));
    sb.append(String.format(":%s", fsi.getHostAPort()));
    sb.append(String.format(" <-> %s", fsi.getHostBName()));
    sb.append(String.format(":%s", fsi.getHostBPort()));
    sb.append(String.format(" [proto: %s", fsi.getProtocol()));
    sb.append(String.format("/%s]", fsi.getDetectedProtocolName()));
    sb.append(String.format(" [%s pkts/", fsi.getPackets()));
    sb.append(String.format("%s bytes]", fsi.getBytes()));
    String serverHostName = fsi.getHostServerName();
    if (serverHostName != null && !serverHostName.equals("")) {
        sb.append(String.format("[Host: %s]", serverHostName));
    }
    return sb.toString();
}
#method_after
private String makeFlowString(FlowStatInfo fsi, int index) {
    StringBuffer sb = new StringBuffer("        ");
    sb.append(String.format("%-8d ", index));
    sb.append(String.format("%s ", fsi.protocol()));
    sb.append(String.format("%s", fsi.hostAName()));
    sb.append(String.format(":%s", fsi.hostAPort()));
    sb.append(String.format(" <-> %s", fsi.hostBName()));
    sb.append(String.format(":%s", fsi.hostBPort()));
    sb.append(String.format(" [proto: %d", fsi.detectedProtocol()));
    sb.append(String.format("/%s]", fsi.detectedProtocolName()));
    sb.append(String.format(" [%s pkts/", fsi.packets()));
    sb.append(String.format("%s bytes]", fsi.bytes()));
    String serverHostName = fsi.hostServerName();
    if (serverHostName != null && !serverHostName.equals("")) {
        sb.append(String.format("[Host: %s]", serverHostName));
    }
    return sb.toString();
}
#end_block

#method_before
@Override
public ObjectNode encode(DpiStatInfo dsi, CodecContext context) {
    checkNotNull(dsi, "DpiStatInfo cannot be null");
    final ObjectNode result = context.mapper().createObjectNode();
    final JsonCodec<TrafficStatInfo> trafficStatInfoCodec = context.codec(TrafficStatInfo.class);
    final TrafficStatInfo tsi = dsi.getTrafficStatistics();
    if (tsi != null) {
        final ObjectNode jsonTrafficStatistics = trafficStatInfoCodec.encode(tsi, context);
        result.set(TRAFFIC_STATISTICS, jsonTrafficStatistics);
    }
    final List<ProtocolStatInfo> psi = dsi.getDetectedProtos();
    if (psi != null) {
        final ArrayNode jsonDetectedProtos = result.putArray(DETECTED_PROTOS);
        final JsonCodec<ProtocolStatInfo> protocolStatInfoCodec = context.codec(ProtocolStatInfo.class);
        for (final ProtocolStatInfo protocolStatInfo : psi) {
            jsonDetectedProtos.add(protocolStatInfoCodec.encode(protocolStatInfo, context));
        }
    }
    List<FlowStatInfo> fsi = dsi.getKnownFlows();
    if (fsi != null) {
        final ArrayNode jsonKnownFlows = result.putArray(KNOWN_FLOWS);
        final JsonCodec<FlowStatInfo> flowStatInfoCodec = context.codec(FlowStatInfo.class);
        for (final FlowStatInfo flowStatInfo : fsi) {
            jsonKnownFlows.add(flowStatInfoCodec.encode(flowStatInfo, context));
        }
    }
    fsi = dsi.getUnknownFlows();
    if (fsi != null) {
        final ArrayNode jsonUnknownFlows = result.putArray(UNKNOWN_FLOWS);
        final JsonCodec<FlowStatInfo> flowStatInfoCodec = context.codec(FlowStatInfo.class);
        for (final FlowStatInfo flowStatInfo : fsi) {
            jsonUnknownFlows.add(flowStatInfoCodec.encode(flowStatInfo, context));
        }
    }
    return result;
}
#method_after
@Override
public ObjectNode encode(DpiStatInfo dsi, CodecContext context) {
    checkNotNull(dsi, "DpiStatInfo cannot be null");
    final ObjectNode result = context.mapper().createObjectNode();
    final JsonCodec<TrafficStatInfo> trafficStatInfoCodec = context.codec(TrafficStatInfo.class);
    final TrafficStatInfo tsi = dsi.trafficStatistics();
    if (tsi != null) {
        final ObjectNode jsonTrafficStatistics = trafficStatInfoCodec.encode(tsi, context);
        result.set(TRAFFIC_STATISTICS, jsonTrafficStatistics);
    }
    final List<ProtocolStatInfo> psi = dsi.detectedProtos();
    if (psi != null) {
        final ArrayNode jsonDetectedProtos = result.putArray(DETECTED_PROTOS);
        final JsonCodec<ProtocolStatInfo> protocolStatInfoCodec = context.codec(ProtocolStatInfo.class);
        for (final ProtocolStatInfo protocolStatInfo : psi) {
            jsonDetectedProtos.add(protocolStatInfoCodec.encode(protocolStatInfo, context));
        }
    }
    List<FlowStatInfo> fsi = dsi.knownFlows();
    if (fsi != null) {
        final ArrayNode jsonKnownFlows = result.putArray(KNOWN_FLOWS);
        final JsonCodec<FlowStatInfo> flowStatInfoCodec = context.codec(FlowStatInfo.class);
        for (final FlowStatInfo flowStatInfo : fsi) {
            jsonKnownFlows.add(flowStatInfoCodec.encode(flowStatInfo, context));
        }
    }
    fsi = dsi.unknownFlows();
    if (fsi != null) {
        final ArrayNode jsonUnknownFlows = result.putArray(UNKNOWN_FLOWS);
        final JsonCodec<FlowStatInfo> flowStatInfoCodec = context.codec(FlowStatInfo.class);
        for (final FlowStatInfo flowStatInfo : fsi) {
            jsonUnknownFlows.add(flowStatInfoCodec.encode(flowStatInfo, context));
        }
    }
    return result;
}
#end_block

#method_before
@Override
public DpiStatistics getDpiStatisticsLatest() {
    DpiStatistics dpiStatistics;
    if (dpiStatisticsList.size() > 0) {
        DpiStatistics ds = dpiStatisticsList.get(0);
        dpiStatistics = new DpiStatistics(ds.getReceivedTime(), ds.getDpiStatInfo());
    } else {
        dpiStatistics = null;
    }
    return dpiStatistics;
}
#method_after
@Override
public DpiStatistics getDpiStatisticsLatest() {
    if (dpiStatisticsMap.size() > 0) {
        return dpiStatisticsMap.get(dpiStatisticsMap.firstKey());
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public DpiStatistics getDpiStatisticsLatest() {
    DpiStatistics dpiStatistics;
    if (dpiStatisticsList.size() > 0) {
        DpiStatistics ds = dpiStatisticsList.get(0);
        dpiStatistics = new DpiStatistics(ds.getReceivedTime(), ds.getDpiStatInfo());
    } else {
        dpiStatistics = null;
    }
    return dpiStatistics;
}
#method_after
@Override
public DpiStatistics getDpiStatisticsLatest(int topnProtocols, int topnFlows) {
    DpiStatistics ds, topnDs;
    ds = getDpiStatisticsLatest();
    topnDs = processTopn(ds, topnProtocols, topnFlows);
    return topnDs;
}
#end_block

#method_before
@Override
public List<DpiStatistics> getDpiStatistics(int lastN) {
    List<DpiStatistics> dpiStatistics = new ArrayList<>();
    DpiStatistics ds = null;
    if (lastN > MAX_DPI_STATISTICS_REQUEST) {
        lastN = MAX_DPI_STATISTICS_REQUEST;
    }
    for (int i = 0; i < lastN && i < dpiStatisticsList.size(); i++) {
        ds = dpiStatisticsList.get(i);
        dpiStatistics.add(i, new DpiStatistics(ds.getReceivedTime(), ds.getDpiStatInfo()));
    }
    return dpiStatistics;
}
#method_after
@Override
public List<DpiStatistics> getDpiStatistics(int lastN) {
    List<DpiStatistics> dsList = new ArrayList<>();
    DpiStatistics ds;
    if (lastN > MAX_DPI_STATISTICS_REQUEST) {
        lastN = MAX_DPI_STATISTICS_REQUEST;
    }
    SortedMap tempMap = new TreeMap(new MapComparator());
    tempMap.putAll(dpiStatisticsMap);
    for (int i = 0; i < lastN && i < tempMap.size(); i++) {
        ds = (DpiStatistics) tempMap.get(tempMap.firstKey());
        dsList.add(i, new DpiStatistics(ds.receivedTime(), ds.dpiStatInfo()));
        tempMap.remove(tempMap.firstKey());
    }
    return dsList;
}
#end_block

#method_before
@Override
public List<DpiStatistics> getDpiStatistics(int lastN) {
    List<DpiStatistics> dpiStatistics = new ArrayList<>();
    DpiStatistics ds = null;
    if (lastN > MAX_DPI_STATISTICS_REQUEST) {
        lastN = MAX_DPI_STATISTICS_REQUEST;
    }
    for (int i = 0; i < lastN && i < dpiStatisticsList.size(); i++) {
        ds = dpiStatisticsList.get(i);
        dpiStatistics.add(i, new DpiStatistics(ds.getReceivedTime(), ds.getDpiStatInfo()));
    }
    return dpiStatistics;
}
#method_after
@Override
public List<DpiStatistics> getDpiStatistics(int lastN, int topnProtocols, int topnFlows) {
    List<DpiStatistics> dsList;
    List<DpiStatistics> topnDsList = new ArrayList<>();
    DpiStatistics ds, topnDs;
    dsList = getDpiStatistics(lastN);
    for (int i = 0; i < dsList.size(); i++) {
        ds = dsList.get(i);
        topnDs = processTopn(ds, topnProtocols, topnFlows);
        topnDsList.add(i, topnDs);
    }
    return topnDsList;
}
#end_block

#method_before
@Override
public DpiStatistics addDpiStatistics(DpiStatistics ds) {
    if (ds == null) {
        return ds;
    }
    // check the time.
    if (dpiStatisticsJsonList.size() > 0) {
        String lastTime = dpiStatisticsList.get(0).getReceivedTime();
        String inputTime = ds.getReceivedTime();
        try {
            SimpleDateFormat df = new SimpleDateFormat(DATE_FMT, Locale.KOREA);
            df.setTimeZone(TimeZone.getTimeZone(TIME_ZONE));
            long lastTimeLong = df.parse(lastTime).getTime();
            long inputTimeLong = df.parse(inputTime).getTime();
            if (lastTimeLong >= inputTimeLong) {
                return null;
            }
        } catch (ParseException e) {
            log.error("Time parse error! Exception={}", e.toString());
        }
    }
    // add it at the head of list, dpiStatisticsJsonList and dpiStatisticsList
    if (dpiStatisticsJsonList.size() >= MAX_DPI_STATISTICS_ENTRY) {
        // remove the last entry
        dpiStatisticsJsonList.remove(dpiStatisticsJsonList.size() - 1);
        dpiStatisticsList.remove(dpiStatisticsList.size() - 1);
    }
    // ObjectNode dsiJsonNode = codec(DpiStatInfo.class).encode(ds.getDpiStatInfo(), this);
    log.info("addDpiStatistics receivedTime={}, dpiStatisticsJson={}", ds.getReceivedTime(), ds.getDpiStatInfo().toString());
    DpiStatisticsJson dsJson = new DpiStatisticsJson(ds.getReceivedTime(), ds.getDpiStatInfo().toString());
    dpiStatisticsJsonList.add(0, dsJson);
    dpiStatisticsList.add(0, ds);
    log.debug("addDpiStatistics: dpiResultJson data[time={}] is added " + "into DpiStatisticsJsonList size={}, and DpiStatisticsList size={}.", ds.getReceivedTime(), dpiStatisticsJsonList.size(), dpiStatisticsList.size());
    return ds;
}
#method_after
@Override
public DpiStatistics addDpiStatistics(DpiStatistics ds) {
    if (ds == null) {
        return ds;
    }
    // check the time. The firstKey is lastTime because of descending sorted order
    if (dpiStatisticsMap.size() > 0) {
        String lastTime = dpiStatisticsMap.get(dpiStatisticsMap.firstKey()).receivedTime();
        String inputTime = ds.receivedTime();
        long lastTimeLong = convertTimeToLong(lastTime);
        long inputTimeLong = convertTimeToLong(inputTime);
        if (lastTimeLong >= inputTimeLong) {
            return null;
        }
    }
    if (dpiStatisticsMap.size() >= MAX_DPI_STATISTICS_ENTRY) {
        // remove the last (oldest) entry
        dpiStatisticsMap.remove(dpiStatisticsMap.lastKey());
    }
    if (dpiStatisticsMap.containsKey(ds.receivedTime())) {
        log.warn("addDpiStatistics(), {} dpiStatistics is already existing!", ds.receivedTime());
        return null;
    }
    dpiStatisticsMap.put(ds.receivedTime(), ds);
    log.debug("addDpiStatistics: dpiResultJson data[time={}] is added " + "into DpiStatisticsMap size={}.", ds.receivedTime(), dpiStatisticsMap.size());
    return ds;
}
#end_block

#method_before
private void receiveDpiResult() {
    try {
        serverSocket = new ServerSocket(port);
    } catch (Exception e) {
        log.error("DpiStatisticsListener: ServerSocket listening error from port={} in localhost, exception={}", port, e.toString());
        return;
    }
    try {
        while (true) {
            if (clientSocket == null) {
                log.info("DpiStatisticsListener: Waiting for accepting from dpi client...");
                clientSocket = serverSocket.accept();
                log.info("DpiStatisticsListener: Accepted from dpi client={}", clientSocket.getRemoteSocketAddress().toString());
                in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                // For disconnecting check!
                out = new PrintWriter(clientSocket.getOutputStream(), true);
                resultJsonString = null;
            }
            sleepCount = 0;
            while (!in.ready()) {
                // sleep one second.
                sleep(1000);
                if (out.checkError() || ++sleepCount >= MAX_SLEEP_COUNT) {
                    log.debug("DpiStatisticsListener: server and socket connect is lost...");
                    in.close();
                    in = null;
                    out.close();
                    out = null;
                    clientSocket.close();
                    clientSocket = null;
                    break;
                }
            }
            if (in != null) {
                resultJsonString = in.readLine();
                // process the result
                log.debug("DpiStatisticsListener: resultJsonString={}", resultJsonString);
                processResultJson(resultJsonString);
            }
        }
    } catch (Exception e) {
        log.error("DpiStatisticsListener: Exception = {}", e.toString());
        return;
    }
}
#method_after
private void receiveDpiResult() {
    try {
        serverSocket = new ServerSocket(port);
    } catch (Exception e) {
        log.error("DpiStatisticsListener: ServerSocket listening error from port={} in localhost, exception={}", port, e.toString());
        return;
    }
    try {
        while (true) {
            if (clientSocket == null) {
                log.info("DpiStatisticsListener: Waiting for accepting from dpi client...");
                clientSocket = serverSocket.accept();
                log.info("DpiStatisticsListener: Accepted from dpi client={}", clientSocket.getRemoteSocketAddress().toString());
                in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                // For disconnecting check!
                out = new PrintWriter(clientSocket.getOutputStream(), true);
                resultJsonString = null;
            }
            sleepCount = 0;
            while (!in.ready()) {
                // sleep one second.
                sleep(1000);
                if (out.checkError() || ++sleepCount >= MAX_SLEEP_COUNT) {
                    log.debug("DpiStatisticsListener: server and socket connect is lost...");
                    in.close();
                    in = null;
                    out.close();
                    out = null;
                    clientSocket.close();
                    clientSocket = null;
                    break;
                }
            }
            if (in != null) {
                resultJsonString = in.readLine();
                // process the result
                log.trace("DpiStatisticsListener: resultJsonString={}", resultJsonString);
                processResultJson(resultJsonString);
            }
        }
    } catch (Exception e) {
        log.error("DpiStatisticsListener: Exception = {}", e.toString());
        return;
    }
}
#end_block

#method_before
private void processResultJson(String resultJsonString) {
    Date tr = new Date(System.currentTimeMillis());
    SimpleDateFormat df = new SimpleDateFormat(DATE_FMT, Locale.KOREA);
    df.setTimeZone(TimeZone.getTimeZone(TIME_ZONE));
    String curReceivedTime = new String(df.format(tr));
    String curResultJson = new String(resultJsonString);
    DpiStatisticsJson dpiStatisticsJson = new DpiStatisticsJson(curReceivedTime, curResultJson);
    DpiStatInfo dpiStatInfo;
    ObjectMapper mapper = new ObjectMapper();
    try {
        dpiStatInfo = mapper.readValue(curResultJson, DpiStatInfo.class);
    } catch (IOException e) {
        log.error("DpiStatisticsListener: ObjectMapper Exception = {}", e.toString());
        return;
    }
    DpiStatistics dpiStatistics = new DpiStatistics(curReceivedTime, dpiStatInfo);
    // add it at the head of list, dpiStatisticsJsonList and dpiStatisticsList
    if (dpiStatisticsJsonList.size() >= MAX_DPI_STATISTICS_ENTRY) {
        // remove the last entry
        dpiStatisticsJsonList.remove(dpiStatisticsJsonList.size() - 1);
        dpiStatisticsList.remove(dpiStatisticsList.size() - 1);
    }
    dpiStatisticsJsonList.add(0, dpiStatisticsJson);
    dpiStatisticsList.add(0, dpiStatistics);
    log.debug("DpiStatisticsListener: dpiResultJson data[time={}] is added " + "into DpiStatisticsJsonList size={}, and DpiStatisticsList size={}.", curReceivedTime, dpiStatisticsJsonList.size(), dpiStatisticsList.size());
}
#method_after
private void processResultJson(String resultJsonString) {
    Date tr = new Date(System.currentTimeMillis());
    SimpleDateFormat df = new SimpleDateFormat(DATE_FMT, Locale.KOREA);
    df.setTimeZone(TimeZone.getTimeZone(TIME_ZONE));
    String curReceivedTime = new String(df.format(tr));
    String curResultJson = new String(resultJsonString);
    DpiStatInfo dpiStatInfo;
    ObjectMapper mapper = new ObjectMapper();
    try {
        dpiStatInfo = mapper.readValue(curResultJson, DpiStatInfo.class);
    } catch (IOException e) {
        log.error("DpiStatisticsListener: ObjectMapper Exception = {}", e.toString());
        return;
    }
    DpiStatistics dpiStatistics = new DpiStatistics(curReceivedTime, dpiStatInfo);
    addDpiStatistics(dpiStatistics);
}
#end_block

#method_before
private void advertiseDevice(DeviceId deviceId, DomainId domainId) {
    ChassisId chassisId = new ChassisId();
    log.info("advertiseDevice");
    // disable lldp for this virtual device...
    SparseAnnotations annotations = DefaultAnnotations.builder().set(NO_LLDP, "any").set(DOMAIN_ID, domainId.id()).set(DRIVER, "create-net-1.0.0-1.0.0").build();
    DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, "create-net", "1.0.0", "1.0.0", UNKNOWN, chassisId, annotations);
    deviceProviderService.deviceConnected(deviceId, deviceDescription);
    mastershipAdminService.setRole(clusterService.getLocalNode().id(), deviceId, MastershipRole.MASTER);
}
#method_after
private void advertiseDevice(DeviceId deviceId, DomainId domainId) {
    ChassisId chassisId = new ChassisId();
    log.info("advertiseDevice");
    // disable lldp for this virtual device and annotate it with the proper driver
    String driverKey = driverConfig.manufacturer() + "-" + driverConfig.hwVersion() + "-" + driverConfig.swVersion();
    SparseAnnotations annotations = DefaultAnnotations.builder().set(NO_LLDP, "any").set(DOMAIN_ID, domainId.id()).set(DRIVER, driverKey).build();
    DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, driverConfig.manufacturer(), driverConfig.hwVersion(), driverConfig.swVersion(), UNKNOWN, chassisId, annotations);
    deviceProviderService.deviceConnected(deviceId, deviceDescription);
    mastershipAdminService.setRole(clusterService.getLocalNode().id(), deviceId, MastershipRole.MASTER);
}
#end_block

#method_before
private void readConfig() {
    IconaConfig iconaConfig = configRegistry.getConfig(appId, IconaConfig.class);
    domainConfigs.addAll(iconaConfig.getPeersConfig());
}
#method_after
private void readConfig() {
    IconaConfig iconaConfig = configRegistry.getConfig(appId, IconaConfig.class);
    driverConfig = iconaConfig.getDriverConfig();
}
#end_block

#method_before
@Override
public void addListener(IconaSBListener sbListener) {
    log.info("listener added");
    sbListeners.add(sbListener);
}
#method_after
@Override
public void addListener(IconaSBListener sbListener) {
    log.debug("listener added");
    sbListeners.add(sbListener);
}
#end_block

#method_before
private void buildBigSwitch(String bigSwitchPrefixId) {
    Map<DomainId, DomainTopology> topologyMap = Maps.newHashMap();
    domainConfigs.forEach(domainConfig -> {
        log.info("Building big switch topology for domain {}", domainConfig.domainId().id());
        DomainId localDomainId = domainConfigService.localDomainId();
        DeviceId bigSwitchId = DeviceId.deviceId(bigSwitchPrefixId + localDomainId + "-" + domainConfig.domainId().id());
        AtomicLong portCounter = new AtomicLong(0);
        List<PortDescription> allPorts = new ArrayList<>();
        Map<PortNumber, ConnectPoint> virtualPortToPortMapping = new HashMap<>();
        domainConfigService.interlinkConnectPointMap().forEach((interlinkId, pair) -> {
            SparseAnnotations annotations = DefaultAnnotations.builder().set(DEVICE_ID, bigSwitchId.toString()).set(DOMAIN_ID, localDomainId.id()).set(INTER_LINK_ID, interlinkId.id()).build();
            allPorts.add(new DefaultPortDescription(PortNumber.portNumber(portCounter.get()), true, VIRTUAL, // port speed is to be configured
            100, annotations));
            virtualPortToPortMapping.put(PortNumber.portNumber(portCounter.get()), pair.getRight());
            portCounter.getAndIncrement();
        });
        final Set<DomainHostDescription> domainHostDescriptions = new HashSet<>();
        hostService.getHosts().forEach(host -> domainConfig.topologyConfig().endPointIds().forEach(mac -> {
            if (host.mac().equals(MacAddress.valueOf(mac))) {
                PortNumber virtualPort = PortNumber.portNumber(portCounter.get());
                DefaultDomainHostDescription domainHost = new DefaultDomainHostDescription(localDomainId, MacAddress.valueOf(mac), VlanId.NONE, new HostLocation(bigSwitchId, virtualPort, 0), host.ipAddresses(), // TODO: ip4/6prefixes from config
                new HashSet<Ip4Prefix>());
                virtualPortToPortMapping.put(virtualPort, new ConnectPoint(host.location().deviceId(), host.location().port()));
                domainHostDescriptions.add(domainHost);
                portCounter.getAndIncrement();
                log.info("host {} added", host.id());
            }
        }));
        domainService.setVirtualPortToPortMapping(bigSwitchId, virtualPortToPortMapping);
        domainHostDescriptions.forEach(domainHost -> allPorts.add(new DefaultPortDescription(domainHost.location().port(), true, VIRTUAL, 100)));
        final DomainDevice bigSwitch = new DefaultDomainDevice(bigSwitchId, localDomainId, allPorts);
        final Set<DomainDevice> domainDevices = Sets.newHashSet();
        domainDevices.add(bigSwitch);
        final Set<IntraLinkDescription> interLinks = Sets.newHashSet();
        final DomainTopology domainTopology = new DefaultDomainTopology(localDomainId, domainDevices, interLinks, domainHostDescriptions);
        topologyMap.put(domainConfig.domainId(), domainTopology);
    });
    log.info("Calling southbound listeners to expose the local topology");
    sbListeners.forEach(listener -> listener.configTopology(topologyMap));
}
#method_after
private void buildBigSwitch(String bigSwitchPrefixId, int portSpeed) {
    Map<DomainId, DomainTopology> topologyMap = Maps.newHashMap();
    domainConfigs.forEach(domainConfig -> {
        log.info("Building big switch topology for domain {}", domainConfig.domainId().id());
        DomainId localDomainId = domainConfigService.localDomainId();
        DeviceId bigSwitchId = DeviceId.deviceId(bigSwitchPrefixId + localDomainId + "-" + domainConfig.domainId().id());
        AtomicLong portCounter = new AtomicLong(0);
        List<PortDescription> allPorts = new ArrayList<>();
        Map<PortNumber, ConnectPoint> virtualPortToPortMapping = new HashMap<>();
        domainConfigService.interlinkConnectPointMap().forEach((interlinkId, pair) -> {
            SparseAnnotations annotations = DefaultAnnotations.builder().set(DEVICE_ID, bigSwitchId.toString()).set(DOMAIN_ID, localDomainId.id()).set(INTER_LINK_ID, interlinkId.id()).build();
            allPorts.add(new DefaultPortDescription(PortNumber.portNumber(portCounter.get()), true, VIRTUAL, // port speed is to be configured
            portSpeed, annotations));
            virtualPortToPortMapping.put(PortNumber.portNumber(portCounter.get()), pair.getRight());
            portCounter.getAndIncrement();
        });
        final Set<DomainHostDescription> domainHostDescriptions = new HashSet<>();
        hostService.getHosts().forEach(host -> domainConfig.topologyConfig().endPointIds().forEach(mac -> {
            if (host.mac().equals(MacAddress.valueOf(mac))) {
                PortNumber virtualPort = PortNumber.portNumber(portCounter.get());
                DefaultDomainHostDescription domainHost = new DefaultDomainHostDescription(localDomainId, MacAddress.valueOf(mac), VlanId.NONE, new HostLocation(bigSwitchId, virtualPort, 0), host.ipAddresses(), // TODO: ip4/6prefixes from config
                new HashSet<Ip4Prefix>());
                virtualPortToPortMapping.put(virtualPort, new ConnectPoint(host.location().deviceId(), host.location().port()));
                domainHostDescriptions.add(domainHost);
                portCounter.getAndIncrement();
                log.info("host {} added", host.id());
            }
        }));
        domainService.setVirtualPortToPortMapping(bigSwitchId, virtualPortToPortMapping);
        domainHostDescriptions.forEach(domainHost -> allPorts.add(new DefaultPortDescription(domainHost.location().port(), true, VIRTUAL, portSpeed)));
        final DomainDevice bigSwitch = new DefaultDomainDevice(bigSwitchId, localDomainId, allPorts);
        final Set<DomainDevice> domainDevices = Sets.newHashSet();
        domainDevices.add(bigSwitch);
        final Set<IntraLinkDescription> interLinks = Sets.newHashSet();
        final DomainTopology domainTopology = new DefaultDomainTopology(localDomainId, domainDevices, interLinks, domainHostDescriptions);
        topologyMap.put(domainConfig.domainId(), domainTopology);
    });
    log.debug("Calling southbound listeners to expose the local topology");
    sbListeners.forEach(listener -> listener.configTopology(topologyMap));
}
#end_block

#method_before
private void readConfig() {
    log.info("Config received");
    IconaConfig iconaConfig = configRegistry.getConfig(appId, IconaConfig.class);
    domainConfigs.addAll(iconaConfig.getPeersConfig());
    // TODO: different topology for different TopologyConfig.Type values
    buildBigSwitch(iconaConfig.getBigSwitchPrefixId());
}
#method_after
private void readConfig() {
    log.info("Config received");
    IconaConfig iconaConfig = configRegistry.getConfig(appId, IconaConfig.class);
    domainConfigs.addAll(iconaConfig.getPeersConfig());
    // TODO: different topology for different TopologyConfig.Type values
    buildBigSwitch(iconaConfig.getBigSwitchPrefixId(), iconaConfig.portSpeed());
}
#end_block

#method_before
private void readConfig() {
    log.info("Config received");
    DomainConfig config = configRegistry.getConfig(appId, DomainConfig.class);
    localDomainId = config.getLocalId();
    domainService.registerDomainId(localDomainId);
    remoteDomainIds.addAll(config.remoteDomainIds());
    interlinkConnectPointMap = config.interlinkMap();
    remoteDomainIds.forEach(domainId -> domainService.registerDomainId(domainId));
}
#method_after
private void readConfig() {
    log.debug("Config received");
    DomainConfig config = configRegistry.getConfig(appId, DomainConfig.class);
    localDomainId = config.getLocalId();
    domainService.registerDomainId(localDomainId);
    remoteDomainIds.addAll(config.remoteDomainIds());
    interlinkConnectPointMap = config.interlinkMap();
    remoteDomainIds.forEach(domainId -> domainService.registerDomainId(domainId));
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (!event.configClass().equals(DomainConfig.class)) {
        return;
    }
    log.info("Listener called: {}", event.type());
    switch(event.type()) {
        case CONFIG_ADDED:
            log.info("Network configuration added");
            eventExecutor.execute(DomainConfigManager.this::readConfig);
            break;
        case CONFIG_UPDATED:
            log.info("Network configuration updated");
            eventExecutor.execute(DomainConfigManager.this::readConfig);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (!event.configClass().equals(DomainConfig.class)) {
        return;
    }
    log.debug("Listener called: {}", event.type());
    switch(event.type()) {
        case CONFIG_ADDED:
            log.info("Network configuration added");
            eventExecutor.execute(DomainConfigManager.this::readConfig);
            break;
        case CONFIG_UPDATED:
            log.info("Network configuration updated");
            eventExecutor.execute(DomainConfigManager.this::readConfig);
            break;
        default:
            break;
    }
}
#end_block

#method_before
public Set<DomainId> remoteDomainIds() {
    Set<DomainId> remoteDomainIds = Sets.newConcurrentHashSet();
    object.path(REMOTE_DOMAINS).forEach(domainElem -> remoteDomainIds.add(new DomainId(domainElem.path(DOMAIN_ID).asText())));
    return remoteDomainIds;
}
#method_after
public Set<DomainId> remoteDomainIds() {
    Set<DomainId> remoteDomainIds = Sets.newConcurrentHashSet();
    object.path(REMOTE_DOMAINS).forEach(domainElem -> remoteDomainIds.add(new DomainId(domainElem.path(DOMAIN_ID).asText())));
    return ImmutableSet.copyOf(remoteDomainIds);
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            DeviceDescription updatedDeviceDescription = null;
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    try {
                        updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                    } catch (RuntimeException e) {
                        log.warn("Error in device discovery for device {}. Retrying in few seconds...", deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
            if (updatedDeviceDescription == null) {
                updatedDeviceDescription = deviceDescription;
            }
            providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
            // if ports are not discovered, retry the discovery
            if (deviceService.getPorts(deviceId).isEmpty()) {
                discoverPorts(deviceId);
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId, DeviceDescription deviceDescription) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && !deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            if (device.is(DeviceDescriptionDiscovery.class)) {
                if (mastershipService.isLocalMaster(deviceId)) {
                    DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                    DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                    if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                        providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    }
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#end_block

#method_before
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else if (device.is(DeviceDescriptionDiscovery.class)) {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        try {
            providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
        } catch (RuntimeException e) {
            log.warn("Error in port discovery for device {}. Retrying in few seconds...", deviceId);
        }
    } else {
        log.warn("No portGetter behaviour for device {}", deviceId);
    }
}
#method_after
private void discoverPorts(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    // TODO remove when PortDiscovery is removed from master
    if (device.is(PortDiscovery.class)) {
        PortDiscovery portConfig = device.as(PortDiscovery.class);
        providerService.updatePorts(deviceId, portConfig.getPorts());
    } else if (device.is(DeviceDescriptionDiscovery.class)) {
        DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
        providerService.updatePorts(deviceId, deviceDescriptionDiscovery.discoverPortDetails());
    } else {
        log.warn("No portGetter behaviour for device {}", deviceId);
    }
}
#end_block

#method_before
private void printVirtualPort(VirtualPort virtualPort) {
    if (virtualPort.realizedBy() == null) {
        print(FMT_VIRTUAL_PORT, virtualPort.number(), "None", "None");
    } else {
        print(FMT_VIRTUAL_PORT, virtualPort.number(), virtualPort.realizedBy().element().id(), virtualPort.realizedBy().number());
    }
}
#method_after
private void printVirtualPort(VirtualPort virtualPort) {
    if (virtualPort.realizedBy() == null) {
        print(FMT_VIRTUAL_PORT, virtualPort.number(), "None", "None");
    } else {
        print(FMT_VIRTUAL_PORT, virtualPort.number(), virtualPort.realizedBy().deviceId(), virtualPort.realizedBy().port());
    }
}
#end_block

#method_before
@Test
public void testEquality() {
    DefaultVirtualDevice device1 = new DefaultVirtualDevice(NetworkId.networkId(0), DID1);
    DefaultVirtualDevice device2 = new DefaultVirtualDevice(NetworkId.networkId(0), DID2);
    Port portA = new DefaultPort(device1, PortNumber.portNumber(1), true);
    Port portB = new DefaultPort(device1, PortNumber.portNumber(2), true);
    Port portC = new DefaultPort(device2, PortNumber.portNumber(2), true);
    DefaultVirtualPort port1 = new DefaultVirtualPort(NetworkId.networkId(0), device1, PortNumber.portNumber(1), portA);
    DefaultVirtualPort port2 = new DefaultVirtualPort(NetworkId.networkId(0), device1, PortNumber.portNumber(1), portA);
    DefaultVirtualPort port3 = new DefaultVirtualPort(NetworkId.networkId(0), device1, PortNumber.portNumber(2), portB);
    DefaultVirtualPort port4 = new DefaultVirtualPort(NetworkId.networkId(1), device2, PortNumber.portNumber(2), portC);
    new EqualsTester().addEqualityGroup(port1, port2).addEqualityGroup(port3).addEqualityGroup(port4).testEquals();
}
#method_after
@Test
public void testEquality() {
    DefaultVirtualDevice device1 = new DefaultVirtualDevice(NetworkId.networkId(0), DID1);
    DefaultVirtualDevice device2 = new DefaultVirtualDevice(NetworkId.networkId(0), DID2);
    ConnectPoint cpA = new ConnectPoint(device1.id(), PortNumber.portNumber(1));
    ConnectPoint cpB = new ConnectPoint(device1.id(), PortNumber.portNumber(2));
    ConnectPoint cpC = new ConnectPoint(device2.id(), PortNumber.portNumber(2));
    DefaultVirtualPort port1 = new DefaultVirtualPort(NetworkId.networkId(0), device1, PortNumber.portNumber(1), cpA);
    DefaultVirtualPort port2 = new DefaultVirtualPort(NetworkId.networkId(0), device1, PortNumber.portNumber(1), cpA);
    DefaultVirtualPort port3 = new DefaultVirtualPort(NetworkId.networkId(0), device1, PortNumber.portNumber(2), cpB);
    DefaultVirtualPort port4 = new DefaultVirtualPort(NetworkId.networkId(1), device2, PortNumber.portNumber(2), cpC);
    new EqualsTester().addEqualityGroup(port1, port2).addEqualityGroup(port3).addEqualityGroup(port4).testEquals();
}
#end_block

#method_before
@Override
public Port realizedBy() {
    return realizedBy;
}
#method_after
@Override
public ConnectPoint realizedBy() {
    return realizedBy;
}
#end_block

#method_before
private ConnectPoint mapVirtualToPhysicalPort(NetworkId networkId, ConnectPoint virtualCp) {
    Set<VirtualPort> ports = store.getPorts(networkId, virtualCp.deviceId());
    for (VirtualPort port : ports) {
        if (port.number().equals(virtualCp.port())) {
            return new ConnectPoint(port.realizedBy().element().id(), port.realizedBy().number());
        }
    }
    return null;
}
#method_after
private ConnectPoint mapVirtualToPhysicalPort(NetworkId networkId, ConnectPoint virtualCp) {
    Set<VirtualPort> ports = store.getPorts(networkId, virtualCp.deviceId());
    for (VirtualPort port : ports) {
        if (port.number().equals(virtualCp.port())) {
            return new ConnectPoint(port.realizedBy().deviceId(), port.realizedBy().port());
        }
    }
    return null;
}
#end_block

#method_before
private ConnectPoint mapPhysicalToVirtualToPort(NetworkId networkId, ConnectPoint physicalCp) {
    Set<VirtualPort> ports = store.getPorts(networkId, null);
    for (VirtualPort port : ports) {
        if (port.realizedBy().element().id().equals(physicalCp.elementId()) && port.realizedBy().number().equals(physicalCp.port())) {
            return new ConnectPoint(port.element().id(), port.number());
        }
    }
    return null;
}
#method_after
private ConnectPoint mapPhysicalToVirtualToPort(NetworkId networkId, ConnectPoint physicalCp) {
    Set<VirtualPort> ports = store.getPorts(networkId, null);
    for (VirtualPort port : ports) {
        if (port.realizedBy().deviceId().equals(physicalCp.elementId()) && port.realizedBy().port().equals(physicalCp.port())) {
            return new ConnectPoint(port.element().id(), port.number());
        }
    }
    return null;
}
#end_block

#method_before
@Override
public VirtualPort createVirtualPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, Port realizedBy) {
    checkNotNull(networkId, NETWORK_NULL);
    checkNotNull(deviceId, DEVICE_NULL);
    checkNotNull(portNumber, "Port description cannot be null");
    return store.addPort(networkId, deviceId, portNumber, realizedBy);
}
#method_after
@Override
public VirtualPort createVirtualPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    checkNotNull(networkId, NETWORK_NULL);
    checkNotNull(deviceId, DEVICE_NULL);
    checkNotNull(portNumber, "Port description cannot be null");
    return store.addPort(networkId, deviceId, portNumber, realizedBy);
}
#end_block

#method_before
@Override
public void bindVirtualPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, Port realizedBy) {
    checkNotNull(networkId, NETWORK_NULL);
    checkNotNull(deviceId, DEVICE_NULL);
    checkNotNull(portNumber, "Port description cannot be null");
    checkNotNull(realizedBy, "Physical port description cannot be null");
    store.bindPort(networkId, deviceId, portNumber, realizedBy);
}
#method_after
@Override
public void bindVirtualPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    checkNotNull(networkId, NETWORK_NULL);
    checkNotNull(deviceId, DEVICE_NULL);
    checkNotNull(portNumber, "Port description cannot be null");
    checkNotNull(realizedBy, "Physical port description cannot be null");
    store.bindPort(networkId, deviceId, portNumber, realizedBy);
}
#end_block

#method_before
@Override
public VirtualPort addPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, Port realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet == null) {
        virtualPortSet = new HashSet<>();
    }
    Device device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    boolean exist = virtualPortSet.stream().anyMatch(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber));
    checkState(!exist, "The requested Port Number is already in use");
    VirtualPort virtualPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(virtualPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    return virtualPort;
}
#method_after
@Override
public VirtualPort addPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    if (virtualPortSet == null) {
        virtualPortSet = new HashSet<>();
    }
    Device device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    boolean exist = virtualPortSet.stream().anyMatch(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber));
    checkState(!exist, "The requested Port Number is already in use");
    VirtualPort virtualPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(virtualPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
    return virtualPort;
}
#end_block

#method_before
@Override
public void bindPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, Port realizedBy) {
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    VirtualPort vPort = virtualPortSet.stream().filter(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber)).findFirst().get();
    checkNotNull(vPort, "The virtual port has not been added.");
    vPort.realized(realizedBy);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
}
#method_after
@Override
public void bindPort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber, ConnectPoint realizedBy) {
    Set<VirtualPort> virtualPortSet = networkIdVirtualPortSetMap.get(networkId);
    VirtualPort vPort = virtualPortSet.stream().filter(p -> p.element().id().equals(deviceId) && p.number().equals(portNumber)).findFirst().get();
    checkNotNull(vPort, "The virtual port has not been added.");
    Device device = deviceIdVirtualDeviceMap.get(deviceId);
    checkNotNull(device, "The device has not been created for deviceId: " + deviceId);
    virtualPortSet.remove(vPort);
    vPort = new DefaultVirtualPort(networkId, device, portNumber, realizedBy);
    virtualPortSet.add(vPort);
    networkIdVirtualPortSetMap.put(networkId, virtualPortSet);
}
#end_block

#method_before
@Override
protected void execute() {
    VirtualNetworkAdminService service = get(VirtualNetworkAdminService.class);
    DeviceService deviceService = get(DeviceService.class);
    VirtualDevice virtualDevice = getVirtualDevice(DeviceId.deviceId(deviceId));
    checkNotNull(virtualDevice, "The virtual device does not exist.");
    Port realizedBy = null;
    if (physDeviceId != null && physPortNum != null) {
        checkNotNull(physPortNum, "The physical port does not specified.");
        // FIXME: realizedBy should refer actual Port of physical Switch.
        // But, to do that, we need to add all related instances with the port
        // using kryo.register() in DistributedVirtualNetworkStore class.
        DefaultAnnotations annotations = DefaultAnnotations.builder().build();
        Device physDevice = new DefaultDevice(null, DeviceId.deviceId(physDeviceId), null, null, null, null, null, null, annotations);
        realizedBy = new DefaultPort(physDevice, PortNumber.portNumber(physPortNum), true);
        checkNotNull(realizedBy, "The physical port does not exist.");
    }
    service.createVirtualPort(NetworkId.networkId(networkId), DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum), realizedBy);
    print("Virtual port successfully created.");
}
#method_after
@Override
protected void execute() {
    VirtualNetworkAdminService service = get(VirtualNetworkAdminService.class);
    DeviceService deviceService = get(DeviceService.class);
    VirtualDevice virtualDevice = getVirtualDevice(DeviceId.deviceId(deviceId));
    checkNotNull(virtualDevice, "The virtual device does not exist.");
    ConnectPoint realizedBy = null;
    if (physDeviceId != null && physPortNum != null) {
        checkNotNull(physPortNum, "The physical port does not specified.");
        realizedBy = new ConnectPoint(DeviceId.deviceId(physDeviceId), PortNumber.portNumber(physPortNum));
        checkNotNull(realizedBy, "The physical port does not exist.");
    }
    service.createVirtualPort(NetworkId.networkId(networkId), DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum), realizedBy);
    print("Virtual port successfully created.");
}
#end_block

#method_before
@Test
public void testNonTrivialSelectorsIntent() {
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of1", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of2", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector selectorVlan = DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("11")).build();
    FilteredConnectPoint egress = new FilteredConnectPoint(connectPoint("of4", 1));
    MultiPointToSinglePointIntent intent = makeFilteredConnectPointIntent(ingress, egress, selectorVlan);
    String[] hops = { "of3" };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of3", "of4"));
        assertThat(linkIntent.selector(), is(selectorVlan));
    }
}
#method_after
@Test
public void testNonTrivialSelectorsIntent() {
    Set<FilteredConnectPoint> ingress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of1", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of2", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    FilteredConnectPoint egress = new FilteredConnectPoint(connectPoint("of4", 1));
    MultiPointToSinglePointIntent intent = makeFilteredConnectPointIntent(ingress, egress, ipPrefixSelector);
    String[] hops = { "of3" };
    MultiPointToSinglePointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of3", "of4"));
        assertThat(linkIntent.selector(), is(ipPrefixSelector));
    }
}
#end_block

#method_before
@Test
public void testNonTrivialSelectorsIntent() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(connectPoint("of1", 1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of3", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of4", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector selectorVlan = DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("23")).build();
    SinglePointToMultiPointIntent intent = makeFilteredConnectPointIntent(ingress, egress, selectorVlan);
    String[] hops = { "of2" };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of2"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of4"));
        Set<FilteredConnectPoint> ingressPoints = linkIntent.filteredIngressPoints();
        assertThat("Link collection ingress points do not match base intent", ingressPoints.size() == 1 && ingressPoints.contains(intent.filteredIngressPoint()));
        assertThat("Link collection egress points do not match base intent", linkIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()));
        assertThat(linkIntent.selector(), is(selectorVlan));
    }
}
#method_after
@Test
public void testNonTrivialSelectorsIntent() {
    FilteredConnectPoint ingress = new FilteredConnectPoint(connectPoint("of1", 1));
    Set<FilteredConnectPoint> egress = ImmutableSet.of(new FilteredConnectPoint(connectPoint("of3", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("100")).build()), new FilteredConnectPoint(connectPoint("of4", 1), DefaultTrafficSelector.builder().matchVlanId(VlanId.vlanId("200")).build()));
    TrafficSelector ipPrefixSelector = DefaultTrafficSelector.builder().matchIPDst(IpPrefix.valueOf("192.168.100.0/24")).build();
    SinglePointToMultiPointIntent intent = makeFilteredConnectPointIntent(ingress, egress, ipPrefixSelector);
    String[] hops = { "of2" };
    SinglePointToMultiPointIntentCompiler compiler = makeCompiler(hops);
    assertThat(compiler, is(notNullValue()));
    List<Intent> result = compiler.compile(intent, null);
    assertThat(result, is(notNullValue()));
    assertThat(result, hasSize(1));
    Intent resultIntent = result.get(0);
    assertThat(resultIntent, instanceOf(LinkCollectionIntent.class));
    if (resultIntent instanceof LinkCollectionIntent) {
        LinkCollectionIntent linkIntent = (LinkCollectionIntent) resultIntent;
        assertThat(linkIntent.links(), hasSize(3));
        assertThat(linkIntent.links(), linksHasPath("of1", "of2"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of3"));
        assertThat(linkIntent.links(), linksHasPath("of2", "of4"));
        Set<FilteredConnectPoint> ingressPoints = linkIntent.filteredIngressPoints();
        assertThat("Link collection ingress points do not match base intent", ingressPoints.size() == 1 && ingressPoints.contains(intent.filteredIngressPoint()));
        assertThat("Link collection egress points do not match base intent", linkIntent.filteredEgressPoints().equals(intent.filteredEgressPoints()));
        assertThat(linkIntent.selector(), is(ipPrefixSelector));
    }
}
#end_block

#method_before
@Activate
public void activate() {
    // Get the codec handler.
    codecHandler = ymsService.getYangCodecHandler();
    // Register all three IETF Topology YANG model schema with YMS.
    codecHandler.addDeviceSchema(IetfNetwork.class);
    codecHandler.addDeviceSchema(IetfNetworkTopology.class);
    codecHandler.addDeviceSchema(IetfTeTopology.class);
    // Register JSON CODEC functions
    codecHandler.registerOverriddenCodec(new JsonYdtCodec(), YangProtocolEncodingFormat.JSON_ENCODING);
    appId = coreService.registerApplication(APP_NAME);
    topologyProviderService = topologyProviderRegistry.register(this);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgLister);
    executor.execute(TeTopologyRestconfProvider.this::connectDevices);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    // Get the codec handler.
    codecHandler = ymsService.getYangCodecHandler();
    // Register all three IETF Topology YANG model schema with YMS.
    codecHandler.addDeviceSchema(IetfNetwork.class);
    codecHandler.addDeviceSchema(IetfNetworkTopology.class);
    codecHandler.addDeviceSchema(IetfTeTopology.class);
    // Register JSON CODEC functions
    codecHandler.registerOverriddenCodec(new JsonYdtCodec(ymsService), YangProtocolEncodingFormat.JSON_ENCODING);
    appId = coreService.registerApplication(APP_NAME);
    topologyProviderService = topologyProviderRegistry.register(this);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgLister);
    executor.execute(TeTopologyRestconfProvider.this::connectDevices);
    log.info("Started");
}
#end_block

#method_before
private void deviceAdded(RestSBDevice nodeId) {
    Preconditions.checkNotNull(nodeId, ISNOTNULL);
    DeviceId deviceId = nodeId.deviceId();
    nodeId.setActive(true);
    addedDevices.add(deviceId);
}
#method_after
private void deviceAdded(RestSBDevice nodeId) {
    Preconditions.checkNotNull(nodeId, E_DEVICE_NULL);
    nodeId.setActive(true);
    addedDevices.add(nodeId.deviceId());
}
#end_block

#method_before
private void deviceRemoved(DeviceId deviceId) {
    Preconditions.checkNotNull(deviceId, ISNOTNULL);
    restconfClient.removeDevice(deviceId);
}
#method_after
private void deviceRemoved(DeviceId deviceId) {
    Preconditions.checkNotNull(deviceId, E_DEVICE_NULL);
    restconfClient.removeDevice(deviceId);
}
#end_block

#method_before
private void connectDevices() {
    RestconfServerConfig cfg = cfgService.getConfig(appId, RestconfServerConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            // Precomputing the devices to be removed
            Set<RestSBDevice> toBeRemoved = new HashSet<>(restconfClient.getDevices().values());
            toBeRemoved.removeAll(cfg.getDevicesAddresses());
            // Adding new devices
            for (RestSBDevice device : cfg.getDevicesAddresses()) {
                device.setActive(false);
                restconfClient.addDevice(device);
                deviceAdded(device);
            }
            // Removing devices not wanted anymore
            toBeRemoved.stream().forEach(device -> deviceRemoved(device.deviceId()));
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    // Discover the topology from RESTCONF server
    for (DeviceId deviceId : addedDevices) {
        retrieveTopology(deviceId);
    }
    addedDevices.clear();
}
#method_after
private void connectDevices() {
    RestconfServerConfig cfg = cfgService.getConfig(appId, RestconfServerConfig.class);
    try {
        if (cfg != null && cfg.getDevicesAddresses() != null) {
            // Precomputing the devices to be removed
            Set<RestSBDevice> toBeRemoved = new HashSet<>(restconfClient.getDevices().values());
            toBeRemoved.removeAll(cfg.getDevicesAddresses());
            // Adding new devices
            for (RestSBDevice device : cfg.getDevicesAddresses()) {
                device.setActive(false);
                restconfClient.addDevice(device);
                deviceAdded(device);
            }
            // Removing devices not wanted anymore
            toBeRemoved.forEach(device -> deviceRemoved(device.deviceId()));
        }
    } catch (ConfigException e) {
        log.error("Configuration error {}", e);
    }
    // Discover the topology from RESTCONF server
    addedDevices.forEach(this::retrieveTopology);
    addedDevices.clear();
}
#end_block

#method_before
private void retrieveTopology(DeviceId deviceId) {
    // Retrieve IETF Network at top level.
    InputStream jsonStream = restconfClient.get(deviceId, "/onos/restconf/data/ietf-network", "json");
    if (jsonStream == null) {
        log.warn("Unable to retrieve network Topology from restconf server {}", deviceId);
        return;
    }
    // Need to convert Input stream to String.
    StringWriter writer = new StringWriter();
    try {
        IOUtils.copy(jsonStream, writer, StandardCharsets.UTF_8);
    } catch (IOException e) {
        log.warn("There is an exception for copy jsonStream to stringWriter for restconf {}", deviceId);
        return;
    }
    String jsonString = writer.toString();
    // Decode a single JSON string to a YO.
    List<Object> yos = codecHandler.decode(jsonString, YangProtocolEncodingFormat.JSON_ENCODING, YmsOperationType.QUERY_REPLY);
    // Single object is expected.
    if ((yos == null) || (yos.size() != 1)) {
        log.error("YMS decoder returns {} for restconf {}", yos, deviceId);
        return;
    }
    IetfNetwork ietfNetwork = (IetfNetwork) yos.get(0);
    // Convert the YO to TE Core data and update TE Core.
    org.onosproject.tetopology.management.api.Networks networks = NetworkConverter.yang2TeSubsystemNetworks(ietfNetwork.networks(), ietfNetwork.networksState());
    if ((networks == null) || (networks.networks() == null)) {
        log.error("Yang2Te returns null for restconf {}", deviceId);
        return;
    }
    for (org.onosproject.tetopology.management.api.Network network : networks.networks()) {
        topologyProviderService.networkUpdated(network);
    }
// TODO: After initial retrieval, register RESTCONF stream notifications for changes
// once restconf client is available.
}
#method_after
private void retrieveTopology(DeviceId deviceId) {
    // Retrieve IETF Network at top level.
    InputStream jsonStream = restconfClient.get(deviceId, IETF_NETWORK_URI, JSON);
    if (jsonStream == null) {
        log.warn("Unable to retrieve network Topology from restconf server {}", deviceId);
        return;
    }
    // Need to convert Input stream to String.
    StringWriter writer = new StringWriter();
    try {
        IOUtils.copy(jsonStream, writer, StandardCharsets.UTF_8);
    } catch (IOException e) {
        log.warn("There is an exception {} for copy jsonStream to stringWriter for restconf {}", e.getMessage(), deviceId);
        return;
    }
    String jsonString = writer.toString();
    String networkLevelJsonString = getNetworkLevelJsonResponse(jsonString);
    YangCompositeEncodingImpl yce = new YangCompositeEncodingImpl(YangResourceIdentifierType.URI, IETF_NETWORK_URI, networkLevelJsonString);
    Object yo = codecHandler.decode(yce, YangProtocolEncodingFormat.JSON_ENCODING, YmsOperationType.QUERY_REPLY);
    if ((yo == null)) {
        log.error("YMS decoder returns {} for restconf {}", yo, deviceId);
        return;
    }
    // YMS returns an ArrayList in a single Object (i.e. yo in this case)
    // this means yo is actually an ArrayList of size 1
    IetfNetwork ietfNetwork = ((List<IetfNetwork>) yo).get(0);
    if (ietfNetwork.networks() != null && ietfNetwork.networks().network() != null) {
        // Convert the YO to TE Core data and update TE Core.
        for (Network nw : ietfNetwork.networks().network()) {
            topologyProviderService.networkUpdated(NetworkConverter.yang2TeSubsystemNetwork(nw));
        }
    }
// TODO: Uncomment when YMS fixes the issue in NetworkState translation (network-ref)
// org.onosproject.tetopology.management.api.Networks networks =
// NetworkConverter.yang2TeSubsystemNetworks(ietfNetwork.networks(),
// ietfNetwork.networksState());
// if (networks == null || networks.networks() == null) {
// log.error("Yang2Te returns null for restconf {}", deviceId);
// return;
// }
// for (org.onosproject.tetopology.management.api.Network network : networks.networks()) {
// topologyProviderService.networkUpdated(network);
// }
// TODO: Uncomment when the RESTCONF server and the RESTCONF client
// both fully support notifications in Ibis Release
// RestConfNotificationEventListener callBackListener = new RestConfNotificationEventListenerImpl();
// restconfClient.enableNotifications(deviceId, IETF_NOTIFICATION_URI, JSON, callBackListener);
}
#end_block

#method_before
@Override
public String encodeYdtToProtocolFormat(YdtBuilder ydtBuilder, YmsOperationType protocolOperation) {
    return null;
}
#method_after
@Override
public String encodeYdtToProtocolFormat(YdtBuilder builder, YmsOperationType opType) {
    String json = ParserUtils.convertYdtToJson(builder.getRootNode().getName(), builder.getRootNode(), ymsService.getYdtWalker()).textValue();
    return json;
}
#end_block

#method_before
@Override
public YangCompositeEncoding encodeYdtToCompositeProtocolFormat(YdtBuilder ydtBuilder, YmsOperationType protocolOperation) {
    // TODO once RESTCONF Utility is merged.
    return null;
}
#method_after
@Override
public YangCompositeEncoding encodeYdtToCompositeProtocolFormat(YdtBuilder builder, YmsOperationType opType) {
    return null;
}
#end_block

#method_before
@Override
public YdtBuilder decodeProtocolDataToYdt(String protocolData, Object schemaRegistryForYdt, YmsOperationType protocolOperation) {
    InputStream stream = IOUtils.toInputStream(protocolData);
    ObjectNode rootNode;
    ObjectMapper mapper = new ObjectMapper();
    try {
        rootNode = (ObjectNode) mapper.readTree(stream);
    } catch (IOException e) {
        log.error("Can't read stream as a JSON ObjectNode: {}", e);
        return null;
    }
    // Release the mapper object.
    mapper = null;
    // Get a new ydtBuilder, it is up to the caller to release the object.
    YdtBuilder ydtBuilder = ymsService.getYdtBuilder(RESTCONF_ROOT, null, protocolOperation, schemaRegistryForYdt);
    // ParserUtils.convertJsonToYdt(rootNode, ydtBuilder);
    return ydtBuilder;
}
#method_after
@Override
public YdtBuilder decodeProtocolDataToYdt(String protocolData, Object schemaRegistryForYdt, YmsOperationType opType) {
    // Get a new builder
    YdtBuilder builder = ymsService.getYdtBuilder(RESTCONF_ROOT, null, opType, schemaRegistryForYdt);
    ParserUtils.convertJsonToYdt(getObjectNode(protocolData), builder);
    return builder;
}
#end_block

#method_before
@Override
public YdtBuilder decodeCompositeProtocolDataToYdt(YangCompositeEncoding protocolData, Object schemaRegistryForYdt, YmsOperationType protocolOperation) {
    // TODO once RESTCONF Utility is merged.
    return null;
}
#method_after
@Override
public YdtBuilder decodeCompositeProtocolDataToYdt(YangCompositeEncoding protocolData, Object schemaRegistryForYdt, YmsOperationType opType) {
    // opType should be QUERY_REPLY
    // Get a new builder
    YdtBuilder builder = ymsService.getYdtBuilder(RESTCONF_ROOT, null, opType, schemaRegistryForYdt);
    // Convert the URI to ydtBuilder
    // YdtContextOperationType should be NONE for URI in QUERY_RESPONSE.
    ParserUtils.convertUriToYdt(protocolData.getResourceIdentifier(), builder, NONE);
    // Set default operation type for the payload node, is this for resource data?
    // NULL/EMPTY for Resource data
    builder.setDefaultEditOperationType(null);
    // Convert the payload json body to ydt
    ParserUtils.convertJsonToYdt(getObjectNode(protocolData.getResourceInformation()), builder);
    return builder;
}
#end_block

#method_before
public static Network sampleTeSubsystemNetworkBuilder() {
    DefaultNetwork huaweiNetworkNew = new DefaultNetwork(KeyId.keyId("HUAWEI_NETWORK_NEW"));
    huaweiNetworkNew.setServerProvided(true);
    List<NetworkNode> nodes = Lists.newArrayList();
    DefaultNetworkNode node1 = new DefaultNetworkNode(KeyId.keyId("HUAWEI_ROADM_1"));
    DefaultTerminationPoint tp11 = new DefaultTerminationPoint(KeyId.keyId("CLIENT1_node1"));
    DefaultTerminationPoint tp12 = new DefaultTerminationPoint(KeyId.keyId("LINE1_node1"));
    List<TerminationPoint> tps1 = Lists.newArrayList();
    tps1.add(tp11);
    tps1.add(tp12);
    node1.setTerminationPoints(tps1);
    TeNode teNode1 = new TeNode("10.11.12.33");
    teNode1.setAdminStatus(TeStatus.UP);
    teNode1.setAbstract(false);
    ConnectivityMatrix cMatrix1 = new ConnectivityMatrix(Long.valueOf(1), new TerminationPointKey(huaweiNetworkNew.networkId(), node1.nodeId(), tp11.id()), new TerminationPointKey(huaweiNetworkNew.networkId(), node1.nodeId(), tp12.id()), true);
    // teNode1.setConnectivityMatrix(cMatrix1);
    node1.setTe(teNode1);
    DefaultNetworkNode node2 = new DefaultNetworkNode(KeyId.keyId("HUAWEI_ROADM_2"));
    DefaultTerminationPoint tp21 = new DefaultTerminationPoint(KeyId.keyId("CLIENT1_node2"));
    DefaultTerminationPoint tp22 = new DefaultTerminationPoint(KeyId.keyId("LINE1_node2"));
    List<TerminationPoint> tps2 = Lists.newArrayList();
    tps2.add(tp21);
    tps2.add(tp22);
    node2.setTerminationPoints(tps2);
    TeNode teNode2 = new TeNode("10.11.12.34");
    teNode1.setAdminStatus(TeStatus.UP);
    teNode1.setAbstract(false);
    ConnectivityMatrix cMatrix2 = new ConnectivityMatrix(Long.valueOf(1), new TerminationPointKey(huaweiNetworkNew.networkId(), node2.nodeId(), tp21.id()), new TerminationPointKey(huaweiNetworkNew.networkId(), node2.nodeId(), tp22.id()), true);
    // teNode2.setConnectivityMatrix(cMatrix2);
    node2.setTe(teNode2);
    nodes.add(node1);
    nodes.add(node2);
    huaweiNetworkNew.setNodes(nodes);
    List<NetworkLink> links = Lists.newArrayList();
    DefaultNetworkLink link1 = new DefaultNetworkLink(KeyId.keyId("LINK1FORNETWORK1"));
    link1.setSource(new TerminationPointKey(huaweiNetworkNew.networkId(), node1.nodeId(), tp11.id()));
    link1.setDestination(new TerminationPointKey(huaweiNetworkNew.networkId(), node2.nodeId(), tp21.id()));
    TeLink teLink1 = new TeLink(BigInteger.valueOf(1));
    teLink1.setIsAbstract(false);
    teLink1.setAdminStatus(TeStatus.UP);
    teLink1.setAccessType(TeLinkAccessType.POINT_TO_POINT);
    teLink1.setLinkProtectionType(LinkProtectionType.UNPROTECTED);
    List<Long> teSrlgs = Lists.newArrayList();
    teSrlgs.add(Long.valueOf(1000));
    teSrlgs.add(Long.valueOf(2000));
    teLink1.setTeSrlgs(teSrlgs);
    link1.setTe(teLink1);
    links.add(link1);
    huaweiNetworkNew.setLinks(links);
    TeNetworkTopologyId teNetwork = new TeNetworkTopologyId(new TeTopologyId(Long.valueOf(22222), Long.valueOf(44444), "HUAWEI_TE_TOPOLOGY_NEW"));
    huaweiNetworkNew.setTeTopologyId(teNetwork.getTopologyId());
    return huaweiNetworkNew;
}
#method_after
public static Network sampleTeSubsystemNetworkBuilder() {
    DefaultNetwork huaweiNetworkNew = new DefaultNetwork(KeyId.keyId(HUAWEI_NETWORK_NEW));
    huaweiNetworkNew.setServerProvided(true);
    List<NetworkNode> nodes = Lists.newArrayList();
    DefaultNetworkNode node1 = new DefaultNetworkNode(KeyId.keyId(HUAWEI_ROADM_1));
    DefaultTerminationPoint tp11 = new DefaultTerminationPoint(KeyId.keyId(CLIENT1_NODE1));
    DefaultTerminationPoint tp12 = new DefaultTerminationPoint(KeyId.keyId(LINE1_NODE1));
    List<TerminationPoint> tps1 = Lists.newArrayList();
    tps1.add(tp11);
    tps1.add(tp12);
    node1.setTerminationPoints(tps1);
    TeNode teNode1 = new TeNode(NODE1_IP);
    teNode1.setAdminStatus(TeStatus.UP);
    teNode1.setAbstract(false);
    ConnectivityMatrix cMatrix1 = new ConnectivityMatrix(1, new TerminationPointKey(huaweiNetworkNew.networkId(), node1.nodeId(), tp11.id()), new TerminationPointKey(huaweiNetworkNew.networkId(), node1.nodeId(), tp12.id()), true);
    List<ConnectivityMatrix> connMatrices = Lists.newArrayList();
    connMatrices.add(cMatrix1);
    teNode1.setConnectivityMatrices(connMatrices);
    node1.setTe(teNode1);
    DefaultNetworkNode node2 = new DefaultNetworkNode(KeyId.keyId(HUAWEI_ROADM_2));
    DefaultTerminationPoint tp21 = new DefaultTerminationPoint(KeyId.keyId(CLIENT1_NODE2));
    DefaultTerminationPoint tp22 = new DefaultTerminationPoint(KeyId.keyId(LINE1_NODE2));
    List<TerminationPoint> tps2 = Lists.newArrayList();
    tps2.add(tp21);
    tps2.add(tp22);
    node2.setTerminationPoints(tps2);
    TeNode teNode2 = new TeNode(NODE2_IP);
    teNode1.setAdminStatus(TeStatus.UP);
    teNode1.setAbstract(false);
    ConnectivityMatrix cMatrix2 = new ConnectivityMatrix(1, new TerminationPointKey(huaweiNetworkNew.networkId(), node2.nodeId(), tp21.id()), new TerminationPointKey(huaweiNetworkNew.networkId(), node2.nodeId(), tp22.id()), true);
    List<ConnectivityMatrix> connMatrices2 = Lists.newArrayList();
    connMatrices.add(cMatrix2);
    teNode1.setConnectivityMatrices(connMatrices2);
    node2.setTe(teNode2);
    nodes.add(node1);
    nodes.add(node2);
    huaweiNetworkNew.setNodes(nodes);
    List<NetworkLink> links = Lists.newArrayList();
    DefaultNetworkLink link1 = new DefaultNetworkLink(KeyId.keyId(LINK1FORNETWORK1));
    link1.setSource(new TerminationPointKey(huaweiNetworkNew.networkId(), node1.nodeId(), tp11.id()));
    link1.setDestination(new TerminationPointKey(huaweiNetworkNew.networkId(), node2.nodeId(), tp21.id()));
    TeLink teLink1 = new TeLink(BigInteger.valueOf(1));
    teLink1.setIsAbstract(false);
    teLink1.setAdminStatus(TeStatus.UP);
    teLink1.setAccessType(TeLinkAccessType.POINT_TO_POINT);
    teLink1.setLinkProtectionType(LinkProtectionType.UNPROTECTED);
    List<Long> teSrlgs = Lists.newArrayList();
    teSrlgs.add(1000L);
    teSrlgs.add(2000L);
    teLink1.setTeSrlgs(teSrlgs);
    link1.setTe(teLink1);
    links.add(link1);
    huaweiNetworkNew.setLinks(links);
    TeNetworkTopologyId teNetwork = new TeNetworkTopologyId(new TeTopologyId(22222L, 44444L, HUAWEI_TE_TOPOLOGY_NEW));
    huaweiNetworkNew.setTeTopologyId(teNetwork.getTopologyId());
    return huaweiNetworkNew;
}
#end_block

#method_before
@Test
public void basics() {
    assertEquals("NetworkId of the converted YANG object is not what it should be.", output.networkId().uri().string().toString(), "HUAWEI_NETWORK_NEW");
    assertEquals("The First NodeId of the converted YANG object is not what it should be.", output.node().get(0).nodeId().uri().string().toString(), "HUAWEI_ROADM_1");
    assertEquals("The second NodeId of the converted YANG object is not what it should be.", output.node().get(1).nodeId().uri().string().toString(), "HUAWEI_ROADM_2");
// AugmentedNwNode augmentedNode = (AugmentedNwNode) output.node().get(0)
// .yangAugmentedInfo(AugmentedNwNode.class);
// assertEquals("The admin status of the augmented Node of the converted YANG object
// is not what it should be.",
// augmentedNode.te().config().teNodeAttributes()
// .adminStatus(),
// TeAdminStatus.of(TeAdminStatusEnum.UP));
}
#method_after
@Test
public void basics() {
    assertEquals("Wrong networkId", output.networkId().uri().string(), "HUAWEI_NETWORK_NEW");
    assertEquals("Wrong 1st nodeId", output.node().get(0).nodeId().uri().string(), "HUAWEI_ROADM_1");
    assertEquals("Wrong 2dn nodeId", output.node().get(1).nodeId().uri().string(), "HUAWEI_ROADM_2");
    AugmentedNwNode augmentedNode = (AugmentedNwNode) output.node().get(0).yangAugmentedInfo(AugmentedNwNode.class);
    assertEquals("Wrong adminStatus", augmentedNode.te().config().teNodeAttributes().adminStatus(), TeAdminStatus.of(TeAdminStatusEnum.UP));
}
#end_block

#method_before
private static Underlay teSubsystem2YangConfigUnderlayPath(UnderlayPath teSubsystem) {
    checkNotNull(teSubsystem, "TeSubsystem link underlayPath object cannot be null");
    Underlay.UnderlayBuilder yangUnderLayBuilder = DefaultUnderlay.builder();
    yangUnderLayBuilder = yangUnderLayBuilder.underlayProtectionType(teSubsystem.protectionType());
    if (teSubsystem.primaryPath() != null) {
        UnderlayPrimaryPath.UnderlayPrimaryPathBuilder underlayPrimaryPathBuilder = DefaultUnderlayPrimaryPath.builder();
        if (teSubsystem.primaryPath().pathElements() != null) {
            for (PathElement pathElementTe : teSubsystem.primaryPath().pathElements()) {
                org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.underlay.underlayprimarypath.PathElement.PathElementBuilder pathElementYangBuilder = DefaultPathElement.builder();
                // FIXME: pathElementTe does not have any getter or
                // setter at the moment --> pathElementYangBuilder =
                // pathElementYangBuilder.pathElementId(pathElementTe.getPathElementId());
                underlayPrimaryPathBuilder = underlayPrimaryPathBuilder.addToPathElement(pathElementYangBuilder.build());
            }
        }
        underlayPrimaryPathBuilder = underlayPrimaryPathBuilder.networkIdRef(NetworkId.fromString(teSubsystem.primaryPath().ref().getNetworkId().toString()));
        underlayPrimaryPathBuilder = underlayPrimaryPathBuilder.teTopologyIdRef(TeTopologyId.fromString(teSubsystem.primaryPath().ref().getTopologyId().topologyId()));
        yangUnderLayBuilder = yangUnderLayBuilder.underlayPrimaryPath(underlayPrimaryPathBuilder.build());
    }
    if (teSubsystem.trailSrc() != null) {
        yangUnderLayBuilder = yangUnderLayBuilder.underlayTrailSrc(new DefaultUnderlayTrailSrc.UnderlayTrailSrcBuilder().networkRef(NetworkId.fromString(teSubsystem.trailSrc().networkId().toString())).nodeRef(NodeId.fromString(teSubsystem.trailSrc().nodeId().toString())).tpRef(TpId.fromString(teSubsystem.trailSrc().tpId().toString())).build());
    }
    if (teSubsystem.trailDes() != null) {
        yangUnderLayBuilder = yangUnderLayBuilder.underlayTrailDes(new DefaultUnderlayTrailDes.UnderlayTrailDesBuilder().networkRef(NetworkId.fromString(teSubsystem.trailDes().networkId().toString())).nodeRef(NodeId.fromString(teSubsystem.trailDes().nodeId().toString())).tpRef(TpId.fromString(teSubsystem.trailDes().tpId().toString())).build());
    }
    if (teSubsystem.backupPaths() != null) {
        for (UnderlayBackupPath underlayBackupTePath : teSubsystem.backupPaths()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.underlay.UnderlayBackupPath.UnderlayBackupPathBuilder underlayBackupPathYangBuilder = DefaultUnderlayBackupPath.builder();
            underlayBackupPathYangBuilder = underlayBackupPathYangBuilder.index(underlayBackupTePath.index());
            underlayBackupPathYangBuilder = underlayBackupPathYangBuilder.networkIdRef(NetworkId.fromString(underlayBackupTePath.ref().getNetworkId().toString()));
            underlayBackupPathYangBuilder = underlayBackupPathYangBuilder.teTopologyIdRef(TeTopologyId.fromString(underlayBackupTePath.ref().getTopologyId().topologyId()));
            for (PathElement backupPathElementTe : underlayBackupTePath.pathElements()) {
                org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.underlay.underlaybackuppath.PathElement.PathElementBuilder backupPathElementYangBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.underlay.underlaybackuppath.DefaultPathElement.builder();
                // FIXME: backupPathElementTe does not have any
                // getter or setter at the moment -->
                // backupPathElementYangBuilder =
                // backupPathElementYangBuilder.pathElementId(backupPathElementTe.getPathElementId());
                underlayBackupPathYangBuilder = underlayBackupPathYangBuilder.addToPathElement(backupPathElementYangBuilder.build());
            }
            yangUnderLayBuilder = yangUnderLayBuilder.addToUnderlayBackupPath(underlayBackupPathYangBuilder.build());
        }
    }
    return yangUnderLayBuilder.build();
}
#method_after
private static Underlay teSubsystem2YangConfigUnderlayPath(UnderlayPath tePath) {
    checkNotNull(tePath, E_NULL_TELINK_UNDERLAY_PATH);
    UnderlayBuilder builder = DefaultUnderlay.builder().underlayProtectionType(tePath.protectionType());
    if (tePath.primaryPath() != null) {
        builder = te2YangConfigUnderlayPrimaryPath(builder, tePath.primaryPath());
    }
    if (tePath.trailSrc() != null) {
        builder = builder.underlayTrailSrc(new UnderlayTrailSrcBuilder().networkRef(NetworkId.fromString(tePath.trailSrc().networkId().toString())).nodeRef(NodeId.fromString(tePath.trailSrc().nodeId().toString())).tpRef(TpId.fromString(tePath.trailSrc().tpId().toString())).build());
    }
    if (tePath.trailDes() != null) {
        builder = builder.underlayTrailDes(new UnderlayTrailDesBuilder().networkRef(NetworkId.fromString(tePath.trailDes().networkId().toString())).nodeRef(NodeId.fromString(tePath.trailDes().nodeId().toString())).tpRef(TpId.fromString(tePath.trailDes().tpId().toString())).build());
    }
    if (tePath.backupPaths() != null) {
        builder = te2YangConfigUnderlayBackupPaths(builder, tePath.backupPaths());
    }
    return builder.build();
}
#end_block

#method_before
private static org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.Underlay teSubsystem2YangStateUnderlayPath(UnderlayPath teSubsystem) {
    checkNotNull(teSubsystem, "TeSubsystem link underlayPath object cannot be null");
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.Underlay.UnderlayBuilder yangUnderLayStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultUnderlay.builder();
    yangUnderLayStateBuilder = yangUnderLayStateBuilder.underlayProtectionType(teSubsystem.protectionType());
    if (teSubsystem.primaryPath() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.UnderlayPrimaryPath.UnderlayPrimaryPathBuilder underlayPrimaryPathStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.DefaultUnderlayPrimaryPath.builder();
        if (teSubsystem.primaryPath().pathElements() != null) {
            for (PathElement pathElementTe : teSubsystem.primaryPath().pathElements()) {
                org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.underlayprimarypath.PathElement.PathElementBuilder pathElementStateYangBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.underlayprimarypath.DefaultPathElement.builder();
                // FIXME: pathElementTe does not have any getter or
                // setter at the moment --> pathElementYangBuilder =
                // pathElementYangBuilder.pathElementId(pathElementTe.getPathElementId());
                underlayPrimaryPathStateBuilder = underlayPrimaryPathStateBuilder.addToPathElement(pathElementStateYangBuilder.build());
            }
        }
        underlayPrimaryPathStateBuilder = underlayPrimaryPathStateBuilder.networkIdRef(NetworkId.fromString(teSubsystem.primaryPath().ref().getNetworkId().toString()));
        underlayPrimaryPathStateBuilder = underlayPrimaryPathStateBuilder.teTopologyIdRef(TeTopologyId.fromString(teSubsystem.primaryPath().ref().getTopologyId().topologyId()));
        yangUnderLayStateBuilder = yangUnderLayStateBuilder.underlayPrimaryPath(underlayPrimaryPathStateBuilder.build());
    }
    if (teSubsystem.trailSrc() != null) {
        yangUnderLayStateBuilder = yangUnderLayStateBuilder.underlayTrailSrc(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.DefaultUnderlayTrailSrc.UnderlayTrailSrcBuilder().networkRef(NetworkId.fromString(teSubsystem.trailSrc().networkId().toString())).nodeRef(NodeId.fromString(teSubsystem.trailSrc().nodeId().toString())).tpRef(TpId.fromString(teSubsystem.trailSrc().tpId().toString())).build());
    }
    if (teSubsystem.trailDes() != null) {
        yangUnderLayStateBuilder = yangUnderLayStateBuilder.underlayTrailDes(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.DefaultUnderlayTrailDes.UnderlayTrailDesBuilder().networkRef(NetworkId.fromString(teSubsystem.trailDes().networkId().toString())).nodeRef(NodeId.fromString(teSubsystem.trailDes().nodeId().toString())).tpRef(TpId.fromString(teSubsystem.trailDes().tpId().toString())).build());
    }
    if (teSubsystem.backupPaths() != null) {
        for (UnderlayBackupPath underlayBackupTePath : teSubsystem.backupPaths()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.UnderlayBackupPath.UnderlayBackupPathBuilder underlayBackupPathStateYangBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.DefaultUnderlayBackupPath.builder();
            underlayBackupPathStateYangBuilder = underlayBackupPathStateYangBuilder.index(underlayBackupTePath.index());
            underlayBackupPathStateYangBuilder = underlayBackupPathStateYangBuilder.networkIdRef(NetworkId.fromString(underlayBackupTePath.ref().getNetworkId().toString()));
            underlayBackupPathStateYangBuilder = underlayBackupPathStateYangBuilder.teTopologyIdRef(TeTopologyId.fromString(underlayBackupTePath.ref().getTopologyId().topologyId()));
            for (PathElement backupPathElementTe : underlayBackupTePath.pathElements()) {
                org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.underlaybackuppath.PathElement.PathElementBuilder backupPathElementStateYangBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.underlaybackuppath.DefaultPathElement.builder();
                // FIXME: backupPathElementTe does not have any
                // getter or setter at the moment -->
                // backupPathElementYangBuilder =
                // backupPathElementYangBuilder.pathElementId(backupPathElementTe.getPathElementId());
                underlayBackupPathStateYangBuilder = underlayBackupPathStateYangBuilder.addToPathElement(backupPathElementStateYangBuilder.build());
            }
            yangUnderLayStateBuilder = yangUnderLayStateBuilder.addToUnderlayBackupPath(underlayBackupPathStateYangBuilder.build());
        }
    }
    return yangUnderLayStateBuilder.build();
}
#method_after
private static org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.Underlay teSubsystem2YangStateUnderlayPath(UnderlayPath tePath) {
    checkNotNull(tePath, E_NULL_TELINK_UNDERLAY_PATH);
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.Underlay.UnderlayBuilder builder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultUnderlay.builder().underlayProtectionType(tePath.protectionType());
    if (tePath.primaryPath() != null) {
        builder = te2YangStateUnderlayPrimaryPath(builder, tePath.primaryPath());
    }
    if (tePath.trailSrc() != null) {
        builder = builder.underlayTrailSrc(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.DefaultUnderlayTrailSrc.UnderlayTrailSrcBuilder().networkRef(NetworkId.fromString(tePath.trailSrc().networkId().toString())).nodeRef(NodeId.fromString(tePath.trailSrc().nodeId().toString())).tpRef(TpId.fromString(tePath.trailSrc().tpId().toString())).build());
    }
    if (tePath.trailDes() != null) {
        builder = builder.underlayTrailDes(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.underlay.DefaultUnderlayTrailDes.UnderlayTrailDesBuilder().networkRef(NetworkId.fromString(tePath.trailDes().networkId().toString())).nodeRef(NodeId.fromString(tePath.trailDes().nodeId().toString())).tpRef(TpId.fromString(tePath.trailDes().tpId().toString())).build());
    }
    if (tePath.backupPaths() != null) {
        builder = te2YangStateUnderlayBackupPaths(builder, tePath.backupPaths());
    }
    return builder.build();
}
#end_block

#method_before
private static Config teLink2YangConfig(TeLink teSubsystemTe) {
    checkNotNull(teSubsystemTe, "TeSubsystem teLink object cannot be null");
    TeBuilder yangTeBuilder = DefaultTe.builder();
    // *******
    Config.ConfigBuilder yangConfigBuilder = DefaultConfig.builder();
    TeLinkAttributes.TeLinkAttributesBuilder yangTeLinkAttributesBuilder = DefaultTeLinkAttributes.builder();
    if (teSubsystemTe.linkIndex() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.linkIndex(teSubsystemTe.linkIndex());
    }
    if (teSubsystemTe.name() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.name(teSubsystemTe.name());
    }
    if (teSubsystemTe.adminStatus() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.adminStatus(TeAdminStatus.fromString(teSubsystemTe.adminStatus().toString()));
    }
    if (teSubsystemTe.accessType() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.accessType(TeLinkAccessType.fromString(teSubsystemTe.accessType().toString()));
    }
    if (teSubsystemTe.linkProtectionType() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.linkProtectionType(LinkProtectionTypeEnum.fromString(teSubsystemTe.linkProtectionType().toString()));
    }
    if (teSubsystemTe.maxLinkBandwidth() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.maxLinkBandwidth(teSubsystemTe.maxLinkBandwidth());
    }
    if (teSubsystemTe.maxResvLinkBandwidth() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.maxResvLinkBandwidth(teSubsystemTe.maxResvLinkBandwidth());
    }
    yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.teDefaultMetric(teSubsystemTe.teDefaultMetric());
    if (teSubsystemTe.teSrlgs() != null) {
        TeSrlgs.TeSrlgsBuilder teSrlgsBuilder = DefaultTeSrlgs.builder();
        for (Long srlgLongVal : teSubsystemTe.teSrlgs()) {
            teSrlgsBuilder = teSrlgsBuilder.addToValue(new Srlg(srlgLongVal));
        }
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.teSrlgs(teSrlgsBuilder.build());
    }
    yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.isAbstract(teSubsystemTe.isAbstract());
    if (teSubsystemTe.underlayPath() != null) {
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.underlay(teSubsystem2YangConfigUnderlayPath(teSubsystemTe.underlayPath()));
    }
    if (teSubsystemTe.externalDomain() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.ExternalDomain.ExternalDomainBuilder externalDomainConfigYangBuilder = DefaultExternalDomain.builder();
        externalDomainConfigYangBuilder = externalDomainConfigYangBuilder.plugId(teSubsystemTe.externalDomain().plugId());
        externalDomainConfigYangBuilder = externalDomainConfigYangBuilder.remoteTeLinkTpId(TeTpId.fromString(teSubsystemTe.externalDomain().remoteTeLinkTpId().toString()));
        externalDomainConfigYangBuilder = externalDomainConfigYangBuilder.remoteTeNodeId(TeNodeId.fromString(teSubsystemTe.externalDomain().remoteTeNodeId().toString()));
        yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.externalDomain(externalDomainConfigYangBuilder.build());
    }
    if (teSubsystemTe.unreservedBandwidths() != null) {
        for (org.onosproject.tetopology.management.api.link.UnreservedBandwidth unResBwTe : teSubsystemTe.unreservedBandwidths()) {
            UnreservedBandwidth.UnreservedBandwidthBuilder unResBwYangBuilder = DefaultUnreservedBandwidth.builder();
            unResBwYangBuilder = unResBwYangBuilder.bandwidth(unResBwTe.bandwidth());
            unResBwYangBuilder = unResBwYangBuilder.priority(unResBwTe.priority());
            yangTeLinkAttributesBuilder = yangTeLinkAttributesBuilder.addToUnreservedBandwidth(unResBwYangBuilder.build());
        }
    }
    yangConfigBuilder = yangConfigBuilder.teLinkAttributes(yangTeLinkAttributesBuilder.build());
    return yangConfigBuilder.build();
}
#method_after
private static Config teLink2YangConfig(TeLink teLink) {
    checkNotNull(teLink, E_NULL_TELINK_DATA);
    TeLinkAttributesBuilder attrBuilder = DefaultTeLinkAttributes.builder();
    if (teLink.linkIndex() != null) {
        attrBuilder = attrBuilder.linkIndex(teLink.linkIndex());
    }
    if (teLink.name() != null) {
        attrBuilder = attrBuilder.name(teLink.name());
    }
    if (teLink.adminStatus() != null) {
        attrBuilder = attrBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teLink.adminStatus()));
    }
    if (teLink.accessType() != null) {
        attrBuilder = attrBuilder.accessType(teSubsystem2YangTeLinkAccess(teLink.accessType()));
    }
    if (teLink.linkProtectionType() != null) {
        attrBuilder = attrBuilder.linkProtectionType(teSubsystem2YangLinkProtectionType(teLink.linkProtectionType()));
    }
    if (teLink.maxLinkBandwidth() != null) {
        attrBuilder = attrBuilder.maxLinkBandwidth(teLink.maxLinkBandwidth());
    }
    if (teLink.maxResvLinkBandwidth() != null) {
        attrBuilder = attrBuilder.maxResvLinkBandwidth(teLink.maxResvLinkBandwidth());
    }
    attrBuilder = attrBuilder.teDefaultMetric(teLink.teDefaultMetric());
    if (teLink.teSrlgs() != null) {
        TeSrlgsBuilder teSrlgsBuilder = DefaultTeSrlgs.builder();
        for (Long srlgLongVal : teLink.teSrlgs()) {
            teSrlgsBuilder = teSrlgsBuilder.addToValue(new Srlg(srlgLongVal));
        }
        attrBuilder = attrBuilder.teSrlgs(teSrlgsBuilder.build());
    }
    attrBuilder = attrBuilder.isAbstract(teLink.isAbstract());
    if (teLink.underlayPath() != null) {
        attrBuilder = attrBuilder.underlay(teSubsystem2YangConfigUnderlayPath(teLink.underlayPath()));
    }
    if (teLink.externalDomain() != null) {
        ExternalDomainBuilder edBuilder = DefaultExternalDomain.builder().plugId(teLink.externalDomain().plugId()).remoteTeLinkTpId(TeTpId.fromString(teLink.externalDomain().remoteTeLinkTpId().toString())).remoteTeNodeId(TeNodeId.fromString(teLink.externalDomain().remoteTeNodeId().toString()));
        attrBuilder = attrBuilder.externalDomain(edBuilder.build());
    }
    if (teLink.unreservedBandwidths() != null) {
        for (org.onosproject.tetopology.management.api.link.UnreservedBandwidth unResBwTe : teLink.unreservedBandwidths()) {
            UnreservedBandwidthBuilder urBuilder = DefaultUnreservedBandwidth.builder().bandwidth(unResBwTe.bandwidth()).priority(unResBwTe.priority());
            attrBuilder = attrBuilder.addToUnreservedBandwidth(urBuilder.build());
        }
    }
    ConfigBuilder yangConfigBuilder = DefaultConfig.builder().teLinkAttributes(attrBuilder.build());
    return yangConfigBuilder.build();
}
#end_block

#method_before
private static State teLink2YangState(TeLink teSubsystemTe) {
    State.StateBuilder yangStateBuilder = DefaultState.builder();
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.TeLinkAttributes.TeLinkAttributesBuilder yangTeLinkAttributesStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.DefaultTeLinkAttributes.builder();
    if (teSubsystemTe.linkIndex() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.linkIndex(teSubsystemTe.linkIndex());
    }
    if (teSubsystemTe.name() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.name(teSubsystemTe.name());
    }
    if (teSubsystemTe.adminStatus() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.adminStatus(TeAdminStatus.fromString(teSubsystemTe.adminStatus().toString()));
    }
    if (teSubsystemTe.opStatus() != null) {
        yangStateBuilder = yangStateBuilder.operStatus(TeOperStatus.fromString(teSubsystemTe.opStatus().toString()));
    }
    if (teSubsystemTe.accessType() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.accessType(TeLinkAccessType.fromString(teSubsystemTe.accessType().toString()));
    }
    if (teSubsystemTe.linkProtectionType() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.linkProtectionType(org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.informationsourceentry.LinkProtectionTypeEnum.fromString(teSubsystemTe.linkProtectionType().toString()));
    }
    if (teSubsystemTe.maxLinkBandwidth() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.maxLinkBandwidth(teSubsystemTe.maxLinkBandwidth());
    }
    if (teSubsystemTe.maxResvLinkBandwidth() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.maxResvLinkBandwidth(teSubsystemTe.maxResvLinkBandwidth());
    }
    yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.teDefaultMetric(teSubsystemTe.teDefaultMetric());
    if (teSubsystemTe.teSrlgs() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.TeSrlgs.TeSrlgsBuilder teSrlgsStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultTeSrlgs.builder();
        for (Long srlgLongVal : teSubsystemTe.teSrlgs()) {
            teSrlgsStateBuilder = teSrlgsStateBuilder.addToValue(new Srlg(srlgLongVal));
        }
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.teSrlgs(teSrlgsStateBuilder.build());
    }
    yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.isAbstract(teSubsystemTe.isAbstract());
    if (teSubsystemTe.underlayPath() != null) {
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.underlay(teSubsystem2YangStateUnderlayPath(teSubsystemTe.underlayPath()));
    }
    if (teSubsystemTe.externalDomain() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.ExternalDomain.ExternalDomainBuilder externalDomainStateYangBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultExternalDomain.builder();
        externalDomainStateYangBuilder = externalDomainStateYangBuilder.plugId(teSubsystemTe.externalDomain().plugId());
        externalDomainStateYangBuilder = externalDomainStateYangBuilder.remoteTeLinkTpId(TeTpId.fromString(teSubsystemTe.externalDomain().remoteTeLinkTpId().toString()));
        externalDomainStateYangBuilder = externalDomainStateYangBuilder.remoteTeNodeId(TeNodeId.fromString(teSubsystemTe.externalDomain().remoteTeNodeId().toString()));
        yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.externalDomain(externalDomainStateYangBuilder.build());
    }
    if (teSubsystemTe.unreservedBandwidths() != null) {
        for (org.onosproject.tetopology.management.api.link.UnreservedBandwidth unResBwTe : teSubsystemTe.unreservedBandwidths()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.UnreservedBandwidth.UnreservedBandwidthBuilder unResBwStateYangBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultUnreservedBandwidth.builder();
            unResBwStateYangBuilder = unResBwStateYangBuilder.bandwidth(unResBwTe.bandwidth());
            unResBwStateYangBuilder = unResBwStateYangBuilder.priority(unResBwTe.priority());
            yangTeLinkAttributesStateBuilder = yangTeLinkAttributesStateBuilder.addToUnreservedBandwidth(unResBwStateYangBuilder.build());
        }
    }
    return yangStateBuilder.build();
}
#method_after
private static State teLink2YangState(TeLink teLink) {
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.TeLinkAttributes.TeLinkAttributesBuilder attrBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.DefaultTeLinkAttributes.builder().teDefaultMetric(teLink.teDefaultMetric()).isAbstract(teLink.isAbstract());
    if (teLink.linkIndex() != null) {
        attrBuilder = attrBuilder.linkIndex(teLink.linkIndex());
    }
    if (teLink.name() != null) {
        attrBuilder = attrBuilder.name(teLink.name());
    }
    if (teLink.adminStatus() != null) {
        attrBuilder = attrBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teLink.adminStatus()));
    }
    if (teLink.accessType() != null) {
        attrBuilder = attrBuilder.accessType(teSubsystem2YangTeLinkAccess(teLink.accessType()));
    }
    if (teLink.linkProtectionType() != null) {
        attrBuilder = attrBuilder.linkProtectionType(teSubsystem2YangStateLinkProtectionType(teLink.linkProtectionType()));
    }
    if (teLink.maxLinkBandwidth() != null) {
        attrBuilder = attrBuilder.maxLinkBandwidth(teLink.maxLinkBandwidth());
    }
    if (teLink.maxResvLinkBandwidth() != null) {
        attrBuilder = attrBuilder.maxResvLinkBandwidth(teLink.maxResvLinkBandwidth());
    }
    if (teLink.teSrlgs() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.TeSrlgs.TeSrlgsBuilder srlgsBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultTeSrlgs.builder();
        for (Long srlgLongVal : teLink.teSrlgs()) {
            srlgsBuilder = srlgsBuilder.addToValue(new Srlg(srlgLongVal));
        }
        attrBuilder = attrBuilder.teSrlgs(srlgsBuilder.build());
    }
    if (teLink.underlayPath() != null) {
        attrBuilder = attrBuilder.underlay(teSubsystem2YangStateUnderlayPath(teLink.underlayPath()));
    }
    if (teLink.externalDomain() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.ExternalDomain.ExternalDomainBuilder edBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultExternalDomain.builder().plugId(teLink.externalDomain().plugId()).remoteTeLinkTpId(TeTpId.fromString(teLink.externalDomain().remoteTeLinkTpId().toString())).remoteTeNodeId(TeNodeId.fromString(teLink.externalDomain().remoteTeNodeId().toString()));
        attrBuilder = attrBuilder.externalDomain(edBuilder.build());
    }
    if (teLink.unreservedBandwidths() != null) {
        for (org.onosproject.tetopology.management.api.link.UnreservedBandwidth unResBwTe : teLink.unreservedBandwidths()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.UnreservedBandwidth.UnreservedBandwidthBuilder urBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.state.telinkattributes.DefaultUnreservedBandwidth.builder().bandwidth(unResBwTe.bandwidth()).priority(unResBwTe.priority());
            attrBuilder = attrBuilder.addToUnreservedBandwidth(urBuilder.build());
        }
    }
    StateBuilder yangStateBuilder = DefaultState.builder().teLinkAttributes(attrBuilder.build());
    if (teLink.opStatus() != null) {
        yangStateBuilder = yangStateBuilder.operStatus(EnumConverter.teSubsystem2YangOperStatus(teLink.opStatus()));
    }
    return yangStateBuilder.build();
}
#end_block

#method_before
public static Link teSubsystem2YangLink(org.onosproject.tetopology.management.api.link.NetworkLink teSubsystem) {
    checkNotNull(teSubsystem, "TeSubsystem link object cannot be null");
    LinkId linkId = LinkId.fromString(teSubsystem.linkId().toString());
    Link.LinkBuilder builder = DefaultLink.builder().linkId(linkId);
    if (teSubsystem.getSupportingLinkIds() != null) {
        List<SupportingLink> slinks = Lists.newArrayList();
        SupportingLink.SupportingLinkBuilder spLinkBuilder = DefaultSupportingLink.builder();
        for (NetworkLinkKey linkKey : teSubsystem.getSupportingLinkIds()) {
            slinks.add(spLinkBuilder.networkRef(NetworkId.fromString(linkKey.networkId().toString())).linkRef(LinkId.fromString(linkKey.linkId().toString())).build());
        }
        builder = builder.supportingLink(slinks);
    }
    if (teSubsystem.getSource() != null) {
        Source.SourceBuilder sourceBuilder = DefaultSource.builder();
        sourceBuilder = sourceBuilder.sourceNode(NodeId.fromString(teSubsystem.getSource().nodeId().toString())).sourceTp(TpId.fromString(teSubsystem.getSource().tpId().toString()));
        builder = builder.source(sourceBuilder.build());
    }
    if (teSubsystem.getDestination() != null) {
        Destination.DestinationBuilder destinationBuilder = DefaultDestination.builder();
        destinationBuilder = destinationBuilder.destNode(NodeId.fromString(teSubsystem.getDestination().nodeId().toString())).destTp(TpId.fromString(teSubsystem.getDestination().tpId().toString()));
        builder = builder.destination(destinationBuilder.build());
    }
    if (teSubsystem.getTe() != null) {
        AugmentedNtLink.AugmentedNtLinkBuilder linkAugmentBuilder = DefaultAugmentedNtLink.builder();
        TeLink teSubsystemTe = teSubsystem.getTe();
        TeBuilder yangTeBuilder = DefaultTe.builder();
        // Set Config data
        yangTeBuilder = yangTeBuilder.config(teLink2YangConfig(teSubsystemTe));
        // Set State data
        yangTeBuilder = yangTeBuilder.state(teLink2YangState(teSubsystemTe));
        linkAugmentBuilder = linkAugmentBuilder.te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(linkAugmentBuilder.build(), AugmentedNtLink.class);
    }
    return builder.build();
}
#method_after
public static Link teSubsystem2YangLink(org.onosproject.tetopology.management.api.link.NetworkLink teLink) {
    checkNotNull(teLink, E_NULL_TELINK);
    LinkId linkId = LinkId.fromString(teLink.linkId().toString());
    LinkBuilder builder = DefaultLink.builder().linkId(linkId);
    if (teLink.getSupportingLinkIds() != null) {
        List<SupportingLink> slinks = Lists.newArrayList();
        SupportingLinkBuilder spLinkBuilder = DefaultSupportingLink.builder();
        for (NetworkLinkKey linkKey : teLink.getSupportingLinkIds()) {
            slinks.add(spLinkBuilder.networkRef(NetworkId.fromString(linkKey.networkId().toString())).linkRef(LinkId.fromString(linkKey.linkId().toString())).build());
        }
        builder = builder.supportingLink(slinks);
    }
    if (teLink.getSource() != null) {
        SourceBuilder sourceBuilder = DefaultSource.builder().sourceNode(NodeId.fromString(teLink.getSource().nodeId().toString())).sourceTp(TpId.fromString(teLink.getSource().tpId().toString()));
        builder = builder.source(sourceBuilder.build());
    }
    if (teLink.getDestination() != null) {
        DestinationBuilder destBuilder = DefaultDestination.builder().destNode(NodeId.fromString(teLink.getDestination().nodeId().toString())).destTp(TpId.fromString(teLink.getDestination().tpId().toString()));
        builder = builder.destination(destBuilder.build());
    }
    if (teLink.getTe() != null) {
        TeLink teData = teLink.getTe();
        TeBuilder yangTeBuilder = DefaultTe.builder().config(teLink2YangConfig(teData)).state(teLink2YangState(teData));
        AugmentedNtLinkBuilder linkAugmentBuilder = DefaultAugmentedNtLink.builder().te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(linkAugmentBuilder.build(), AugmentedNtLink.class);
    }
    return builder.build();
}
#end_block

#method_before
private static org.onosproject.tetopology.management.api.link.UnderlayPath yang2TeSubsystemUnderlayPath(TeLinkAttributes yangLinkAugmentConfigLinkAttr) {
    checkNotNull(yangLinkAugmentConfigLinkAttr, "YANG telink config object cannot be null");
    org.onosproject.tetopology.management.api.link.UnderlayPath teUnderlay = new org.onosproject.tetopology.management.api.link.UnderlayPath();
    teUnderlay.setProtectionType(yangLinkAugmentConfigLinkAttr.underlay().underlayProtectionType());
    if (yangLinkAugmentConfigLinkAttr.underlay().underlayPrimaryPath() != null) {
        org.onosproject.tetopology.management.api.link.UnderlayPrimaryPath teUnderlayPrimaryPath = new org.onosproject.tetopology.management.api.link.UnderlayPrimaryPath();
        teUnderlayPrimaryPath.setRef(new TeNetworkTopologyId(KeyId.keyId(yangLinkAugmentConfigLinkAttr.underlay().underlayPrimaryPath().networkIdRef().toString()), new org.onosproject.tetopology.management.api.TeTopologyId(yangLinkAugmentConfigLinkAttr.underlay().underlayPrimaryPath().providerIdRef().uint32(), yangLinkAugmentConfigLinkAttr.underlay().underlayPrimaryPath().clientIdRef().uint32(), yangLinkAugmentConfigLinkAttr.underlay().underlayPrimaryPath().teTopologyIdRef().toString())));
        List<PathElement> pathElementList = Lists.newArrayList();
        for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.underlay.underlayprimarypath.PathElement pathElementConfigYang : yangLinkAugmentConfigLinkAttr.underlay().underlayPrimaryPath().pathElement()) {
        // PathElement tePathElement = new PathElement();
        // FIXME: tePathElement does not have any getter
        // or setter at the moment -->
        // tePathElement.set...
        // TODO: construct the tePathElement object
        // properly using pathElementConfigYang
        // pathElementList.add(tePathElement);
        }
        teUnderlayPrimaryPath.setPathElement(pathElementList);
        teUnderlay.setPrimaryPath(teUnderlayPrimaryPath);
    }
    if (yangLinkAugmentConfigLinkAttr.underlay().underlayBackupPath() != null) {
        List<UnderlayBackupPath> underlayBackupPathsList = Lists.newArrayList();
        for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.underlay.UnderlayBackupPath underlayBackupPathConfigYang : yangLinkAugmentConfigLinkAttr.underlay().underlayBackupPath()) {
            UnderlayBackupPath ubp = new UnderlayBackupPath();
            ubp.setIndex(underlayBackupPathConfigYang.index());
            ubp.setRef(new TeNetworkTopologyId(KeyId.keyId(underlayBackupPathConfigYang.networkIdRef().toString()), new org.onosproject.tetopology.management.api.TeTopologyId(underlayBackupPathConfigYang.providerIdRef().uint32(), underlayBackupPathConfigYang.clientIdRef().uint32(), underlayBackupPathConfigYang.teTopologyIdRef().toString())));
            List<PathElement> backupPathElementList = Lists.newArrayList();
            for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.link.augmentedntlink.te.config.telinkattributes.underlay.underlaybackuppath.PathElement pathElementBackupYang : underlayBackupPathConfigYang.pathElement()) {
            // PathElement tePathElementBackup = new PathElement();
            // FIXME: tePathElement does not have any
            // getter or setter at the moment -->
            // tePathElement.set...
            // TODO: construct the tePathElement object
            // properly using pathElementBackupYang
            // backupPathElementList.add(tePathElementBackup);
            }
            ubp.setPathElement(backupPathElementList);
        }
        teUnderlay.setBackupPath(underlayBackupPathsList);
    }
    if (yangLinkAugmentConfigLinkAttr.underlay().underlayTrailSrc() != null) {
        teUnderlay.setTrailSrc(new TerminationPointKey(KeyId.keyId(yangLinkAugmentConfigLinkAttr.underlay().underlayTrailSrc().networkRef().uri().toString()), KeyId.keyId(yangLinkAugmentConfigLinkAttr.underlay().underlayTrailSrc().nodeRef().uri().toString()), KeyId.keyId(yangLinkAugmentConfigLinkAttr.underlay().underlayTrailSrc().tpRef().uri().toString())));
    }
    if (yangLinkAugmentConfigLinkAttr.underlay().underlayTrailDes() != null) {
        teUnderlay.setTrailDes(new TerminationPointKey(KeyId.keyId(yangLinkAugmentConfigLinkAttr.underlay().underlayTrailDes().networkRef().uri().toString()), KeyId.keyId(yangLinkAugmentConfigLinkAttr.underlay().underlayTrailDes().nodeRef().uri().toString()), KeyId.keyId(yangLinkAugmentConfigLinkAttr.underlay().underlayTrailDes().tpRef().uri().toString())));
    }
    return teUnderlay;
}
#method_after
private static org.onosproject.tetopology.management.api.link.UnderlayPath yang2TeSubsystemUnderlayPath(TeLinkAttributes yangLinkAtrr) {
    checkNotNull(yangLinkAtrr, E_NULL_YANG_TELINK_CONFIG);
    org.onosproject.tetopology.management.api.link.UnderlayPath teUnderlay = new org.onosproject.tetopology.management.api.link.UnderlayPath();
    teUnderlay.setProtectionType(yangLinkAtrr.underlay().underlayProtectionType());
    if (yangLinkAtrr.underlay().underlayPrimaryPath() != null) {
        teUnderlay = yang2TeSubsystemUnderlayPrimaryPath(teUnderlay, yangLinkAtrr.underlay().underlayPrimaryPath());
    }
    if (yangLinkAtrr.underlay().underlayBackupPath() != null) {
        teUnderlay = yang2TeSubsystemUnderlayBackupPaths(teUnderlay, yangLinkAtrr.underlay().underlayBackupPath());
    }
    if (yangLinkAtrr.underlay().underlayTrailSrc() != null) {
        teUnderlay.setTrailSrc(new TerminationPointKey(KeyId.keyId(yangLinkAtrr.underlay().underlayTrailSrc().networkRef().uri().toString()), KeyId.keyId(yangLinkAtrr.underlay().underlayTrailSrc().nodeRef().uri().toString()), KeyId.keyId(yangLinkAtrr.underlay().underlayTrailSrc().tpRef().uri().toString())));
    }
    if (yangLinkAtrr.underlay().underlayTrailDes() != null) {
        teUnderlay.setTrailDes(new TerminationPointKey(KeyId.keyId(yangLinkAtrr.underlay().underlayTrailDes().networkRef().uri().toString()), KeyId.keyId(yangLinkAtrr.underlay().underlayTrailDes().nodeRef().uri().toString()), KeyId.keyId(yangLinkAtrr.underlay().underlayTrailDes().tpRef().uri().toString())));
    }
    return teUnderlay;
}
#end_block

#method_before
public static org.onosproject.tetopology.management.api.link.NetworkLink yang2TeSubsystemLink(Link yangLink, NetworkId networkId) {
    checkNotNull(yangLink, "YANG Link object cannot be null");
    org.onosproject.tetopology.management.api.link.DefaultNetworkLink link = new org.onosproject.tetopology.management.api.link.DefaultNetworkLink(KeyId.keyId(yangLink.linkId().uri().toString()));
    if (yangLink.supportingLink() != null) {
        List<NetworkLinkKey> spLinkIds = Lists.newArrayList();
        for (SupportingLink yangSpLink : yangLink.supportingLink()) {
            NetworkLinkKey linkKey = new NetworkLinkKey(KeyId.keyId(networkId.uri().toString()), KeyId.keyId(yangLink.linkId().uri().toString()));
            spLinkIds.add(linkKey);
        }
        link.setSupportingLinkIds(spLinkIds);
    }
    if (yangLink.source() != null) {
        TerminationPointKey source = new TerminationPointKey(KeyId.keyId(networkId.uri().toString()), KeyId.keyId(yangLink.source().sourceNode().uri().toString()), KeyId.keyId(yangLink.source().sourceTp().uri().toString()));
        link.setSource(source);
    }
    if (yangLink.destination() != null) {
        TerminationPointKey destination = new TerminationPointKey(KeyId.keyId(networkId.uri().toString()), KeyId.keyId(yangLink.destination().destNode().uri().toString()), KeyId.keyId(yangLink.destination().destTp().uri().toString()));
        link.setDestination(destination);
    }
    if (yangLink.yangAugmentedInfoMap() != null && !yangLink.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNtLink yangLinkAugment = (AugmentedNtLink) yangLink.yangAugmentedInfo(AugmentedNtLink.class);
        if (yangLinkAugment != null && yangLinkAugment.te() != null && yangLinkAugment.te().config() != null) {
            TeLinkAttributes yangLinkAugmentConfigLinkAttr = yangLinkAugment.te().config().teLinkAttributes();
            if (yangLinkAugmentConfigLinkAttr != null && yangLinkAugmentConfigLinkAttr.linkIndex() != null) {
                TeLink teSubsystemTeLink = new TeLink(yangLinkAugmentConfigLinkAttr.linkIndex());
                if (yangLinkAugmentConfigLinkAttr.name() != null) {
                    teSubsystemTeLink.setName(yangLinkAugmentConfigLinkAttr.name());
                }
                if (yangLinkAugmentConfigLinkAttr.adminStatus() != null) {
                    teSubsystemTeLink.setAdminStatus(TeStatus.fromString(yangLinkAugmentConfigLinkAttr.adminStatus().toString()));
                }
                if (yangLinkAugment.te().state() != null) {
                    if (yangLinkAugment.te().state().operStatus() != null) {
                        teSubsystemTeLink.setOpStatus(TeStatus.fromString(yangLinkAugment.te().state().operStatus().toString()));
                    }
                }
                if (yangLinkAugmentConfigLinkAttr.accessType() != null) {
                    teSubsystemTeLink.setAccessType(org.onosproject.tetopology.management.api.link.TeLinkAccessType.fromString(yangLinkAugmentConfigLinkAttr.accessType().toString()));
                }
                if (yangLinkAugmentConfigLinkAttr.linkProtectionType() != null) {
                    teSubsystemTeLink.setLinkProtectionType(LinkProtectionType.fromString(yangLinkAugmentConfigLinkAttr.linkProtectionType().toString()));
                }
                if (yangLinkAugmentConfigLinkAttr.maxLinkBandwidth() != null) {
                    teSubsystemTeLink.setMaxLinkBandwidth(yangLinkAugmentConfigLinkAttr.maxLinkBandwidth());
                }
                if (yangLinkAugmentConfigLinkAttr.maxResvLinkBandwidth() != null) {
                    teSubsystemTeLink.setMaxResvLinkBandwidth(yangLinkAugmentConfigLinkAttr.maxResvLinkBandwidth());
                }
                teSubsystemTeLink.setTeDefaultMetric(yangLinkAugmentConfigLinkAttr.teDefaultMetric());
                teSubsystemTeLink.setIsAbstract(yangLinkAugmentConfigLinkAttr.isAbstract());
                if (yangLinkAugmentConfigLinkAttr.teSrlgs() != null) {
                    List<Long> srlgs = Lists.newArrayList();
                    for (Srlg srlgConfigYang : yangLinkAugmentConfigLinkAttr.teSrlgs().value()) {
                        srlgs.add(srlgConfigYang.uint32());
                    }
                    teSubsystemTeLink.setTeSrlgs(srlgs);
                }
                if (yangLinkAugmentConfigLinkAttr.externalDomain() != null) {
                    teSubsystemTeLink.setExternalDomain(new ExternalDomain(KeyId.keyId(yangLinkAugmentConfigLinkAttr.externalDomain().remoteTeNodeId().toString()), KeyId.keyId(yangLinkAugmentConfigLinkAttr.externalDomain().remoteTeLinkTpId().toString()), yangLinkAugmentConfigLinkAttr.externalDomain().plugId()));
                }
                if (yangLinkAugmentConfigLinkAttr.underlay() != null) {
                    org.onosproject.tetopology.management.api.link.UnderlayPath teUnderlay = yang2TeSubsystemUnderlayPath(yangLinkAugmentConfigLinkAttr);
                    teSubsystemTeLink.setUnderlayPath(teUnderlay);
                }
                if (yangLinkAugmentConfigLinkAttr.unreservedBandwidth() != null) {
                    List<org.onosproject.tetopology.management.api.link.UnreservedBandwidth> unreservedBandwidths = Lists.newArrayList();
                    for (UnreservedBandwidth unreservedBandwidthConfigYang : yangLinkAugmentConfigLinkAttr.unreservedBandwidth()) {
                        org.onosproject.tetopology.management.api.link.UnreservedBandwidth unResBw = new org.onosproject.tetopology.management.api.link.UnreservedBandwidth(unreservedBandwidthConfigYang.priority(), unreservedBandwidthConfigYang.bandwidth());
                        unreservedBandwidths.add(unResBw);
                    }
                    teSubsystemTeLink.setUnreservedBandwidths(unreservedBandwidths);
                }
                link.setTe(teSubsystemTeLink);
            }
        }
    }
    return link;
}
#method_after
public static org.onosproject.tetopology.management.api.link.NetworkLink yang2TeSubsystemLink(Link yangLink, NetworkId networkId) {
    checkNotNull(yangLink, E_NULL_YANG_TELINK);
    org.onosproject.tetopology.management.api.link.DefaultNetworkLink link = new org.onosproject.tetopology.management.api.link.DefaultNetworkLink(KeyId.keyId(yangLink.linkId().uri().toString()));
    if (yangLink.supportingLink() != null) {
        List<NetworkLinkKey> spLinkIds = Lists.newArrayList();
        for (SupportingLink yangSpLink : yangLink.supportingLink()) {
            NetworkLinkKey linkKey = new NetworkLinkKey(KeyId.keyId(yangSpLink.networkRef().uri().toString()), KeyId.keyId(yangSpLink.linkRef().uri().toString()));
            spLinkIds.add(linkKey);
        }
        link.setSupportingLinkIds(spLinkIds);
    }
    if (yangLink.source() != null) {
        TerminationPointKey source = new TerminationPointKey(KeyId.keyId(networkId.uri().toString()), KeyId.keyId(yangLink.source().sourceNode().uri().toString()), KeyId.keyId(yangLink.source().sourceTp().uri().toString()));
        link.setSource(source);
    }
    if (yangLink.destination() != null) {
        TerminationPointKey destination = new TerminationPointKey(KeyId.keyId(networkId.uri().toString()), KeyId.keyId(yangLink.destination().destNode().uri().toString()), KeyId.keyId(yangLink.destination().destTp().uri().toString()));
        link.setDestination(destination);
    }
    if (yangLink.yangAugmentedInfoMap() != null && !yangLink.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNtLink yangLinkAugment = (AugmentedNtLink) yangLink.yangAugmentedInfo(AugmentedNtLink.class);
        if (yangLinkAugment != null && yangLinkAugment.te() != null && yangLinkAugment.te().config() != null) {
            TeLinkAttributes yangLinkAtrr = yangLinkAugment.te().config().teLinkAttributes();
            if (yangLinkAtrr != null && yangLinkAtrr.linkIndex() != null) {
                TeLink te = yang2TeLinkAttributes(yangLinkAtrr, yangLinkAugment.te().state());
                link.setTe(te);
            }
        }
    }
    return link;
}
#end_block

#method_before
public static TerminationPoint teSubsystem2YangTerminationPoint(org.onosproject.tetopology.management.api.node.TerminationPoint teSubsystem) {
    checkNotNull(teSubsystem, "TeSubsystem terminationPoint object cannot be null");
    TpId tpId = TpId.fromString(teSubsystem.id().toString());
    TerminationPoint.TerminationPointBuilder builder = new DefaultTerminationPoint.TerminationPointBuilder().tpId(tpId);
    if (teSubsystem.getSupportingTpIds() != null) {
        List<SupportingTerminationPoint> tps = Lists.newArrayList();
        SupportingTerminationPoint.SupportingTerminationPointBuilder spTpBuilder = DefaultSupportingTerminationPoint.builder();
        for (TerminationPointKey tpKey : teSubsystem.getSupportingTpIds()) {
            tps.add(spTpBuilder.networkRef(NetworkId.fromString(tpKey.networkId().toString())).nodeRef(NodeId.fromString(tpKey.nodeId().toString())).tpRef(TpId.fromString(tpKey.tpId().toString())).build());
        }
        builder = builder.supportingTerminationPoint(tps);
    }
    if (teSubsystem.getTe() != null) {
        AugmentedNtTerminationPoint.AugmentedNtTerminationPointBuilder tpAugmentBuilder = DefaultAugmentedNtTerminationPoint.builder();
        TeTerminationPoint teSubsystemTe = teSubsystem.getTe();
        TeBuilder yangTeBuilder = DefaultTe.builder();
        if (teSubsystemTe.teTpId() != null) {
            yangTeBuilder = yangTeBuilder.teTpId(TeTpId.fromString(teSubsystemTe.teTpId().toString()));
        }
        Config.ConfigBuilder yangConfigBuilder = DefaultConfig.builder();
        // if (teSubsystemTe.getInterLayerLockId() != null) {
        // yangConfigBuilder = yangConfigBuilder.interLayerLockId(teSubsystemTe
        // .getInterLayerLockId().longValue());
        // }
        yangConfigBuilder = yangConfigBuilder.interLayerLockId(teSubsystemTe.getInterLayerLockId());
        if (teSubsystemTe.interfaceSwitchingCapabilities() != null) {
            // List<InterfaceSwitchingCapability> yangIscList = Lists.newArrayList();
            for (org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability teIsc : teSubsystemTe.interfaceSwitchingCapabilities()) {
                InterfaceSwitchingCapability.InterfaceSwitchingCapabilityBuilder isc = DefaultInterfaceSwitchingCapability.builder();
                // FIXME: teIsc at this moment is empty, therefore we cannot
                // really add its attributes to isc
                yangConfigBuilder = yangConfigBuilder.addToInterfaceSwitchingCapability(isc.build());
            // yangIscList.add(isc.build());
            }
        // yangConfigBuilder.interfaceSwitchingCapability(yangIscList);
        }
        yangTeBuilder = yangTeBuilder.config(yangConfigBuilder.build());
        State.StateBuilder yangStateBuilder = DefaultState.builder();
        // if (teSubsystemTe.getInterLayerLockId() != null) {
        // yangStateBuilder.interLayerLockId(teSubsystemTe.getInterLayerLockId().longValue());
        // }
        yangStateBuilder.interLayerLockId(teSubsystemTe.getInterLayerLockId());
        if (teSubsystemTe.interfaceSwitchingCapabilities() != null) {
            for (org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability teIsc : teSubsystemTe.interfaceSwitchingCapabilities()) {
                org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.terminationpoint.augmentedntterminationpoint.te.state.InterfaceSwitchingCapability.InterfaceSwitchingCapabilityBuilder isc = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.terminationpoint.augmentedntterminationpoint.te.state.DefaultInterfaceSwitchingCapability.builder();
                // FIXME: teIsc at this moment is empty, therefore we cannot
                // really add its attributes to isc
                yangStateBuilder.addToInterfaceSwitchingCapability(isc.build());
            }
        }
        yangTeBuilder = yangTeBuilder.state(yangStateBuilder.build());
        tpAugmentBuilder = tpAugmentBuilder.te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(tpAugmentBuilder.build(), AugmentedNtTerminationPoint.class);
    }
    return builder.build();
}
#method_after
public static TerminationPoint teSubsystem2YangTerminationPoint(org.onosproject.tetopology.management.api.node.TerminationPoint teSubsystem) {
    checkNotNull(teSubsystem, E_NULL_TE_SUBSYSTEM_TP);
    TpId tpId = TpId.fromString(teSubsystem.id().toString());
    TerminationPoint.TerminationPointBuilder builder = new DefaultTerminationPoint.TerminationPointBuilder().tpId(tpId);
    if (teSubsystem.getSupportingTpIds() != null) {
        List<SupportingTerminationPoint> tps = Lists.newArrayList();
        SupportingTerminationPoint.SupportingTerminationPointBuilder spTpBuilder = DefaultSupportingTerminationPoint.builder();
        for (TerminationPointKey tpKey : teSubsystem.getSupportingTpIds()) {
            tps.add(spTpBuilder.networkRef(NetworkId.fromString(tpKey.networkId().toString())).nodeRef(NodeId.fromString(tpKey.nodeId().toString())).tpRef(TpId.fromString(tpKey.tpId().toString())).build());
        }
        builder = builder.supportingTerminationPoint(tps);
    }
    if (teSubsystem.getTe() != null) {
        AugmentedNtTerminationPoint.AugmentedNtTerminationPointBuilder tpAugmentBuilder = DefaultAugmentedNtTerminationPoint.builder();
        TeTerminationPoint teSubsystemTe = teSubsystem.getTe();
        TeBuilder yangTeBuilder = DefaultTe.builder();
        if (teSubsystemTe.teTpId() != null) {
            yangTeBuilder = yangTeBuilder.teTpId(TeTpId.fromString(teSubsystemTe.teTpId().toString()));
        }
        Config yConfig = teSubsystem2YangTeAugConfig(teSubsystemTe);
        yangTeBuilder = yangTeBuilder.config(yConfig);
        State yState = teSubsystem2YangTeAugState(teSubsystemTe);
        yangTeBuilder = yangTeBuilder.state(yState);
        tpAugmentBuilder = tpAugmentBuilder.te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(tpAugmentBuilder.build(), AugmentedNtTerminationPoint.class);
    }
    return builder.build();
}
#end_block

#method_before
public static org.onosproject.tetopology.management.api.node.TerminationPoint yang2teSubsystemTerminationPoint(TerminationPoint yangTp) {
    checkNotNull(yangTp, "YANG terminationPoint object cannot be null");
    org.onosproject.tetopology.management.api.node.DefaultTerminationPoint tp = new org.onosproject.tetopology.management.api.node.DefaultTerminationPoint(KeyId.keyId(yangTp.tpId().uri().string()));
    if (yangTp.supportingTerminationPoint() != null) {
        List<org.onosproject.tetopology.management.api.node.TerminationPointKey> spTps = Lists.newArrayList();
        for (SupportingTerminationPoint yangSptp : yangTp.supportingTerminationPoint()) {
            org.onosproject.tetopology.management.api.node.TerminationPointKey tpKey = new org.onosproject.tetopology.management.api.node.TerminationPointKey(KeyId.keyId(yangSptp.networkRef().uri().string()), KeyId.keyId(yangSptp.nodeRef().uri().string()), KeyId.keyId(yangSptp.tpRef().uri().string()));
            spTps.add(tpKey);
        }
        tp.setSupportingTpIds(spTps);
    }
    if (yangTp.yangAugmentedInfoMap() != null && !yangTp.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNtTerminationPoint yangTpAugment = (AugmentedNtTerminationPoint) yangTp.yangAugmentedInfo(AugmentedNtTerminationPoint.class);
        if (yangTpAugment.te() != null && yangTpAugment.te().teTpId() != null) {
            KeyId teTpId = KeyId.keyId(yangTpAugment.te().teTpId().toString());
            if (yangTpAugment.te().config() != null) {
                long interLayerLockId = yangTpAugment.te().config().interLayerLockId();
                List<org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability> teIscList = Lists.newArrayList();
                // between the two
                if (yangTpAugment.te().config().interfaceSwitchingCapability() != null) {
                    for (InterfaceSwitchingCapability iscConfigYang : yangTpAugment.te().config().interfaceSwitchingCapability()) {
                        org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability iscTe = new org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability();
                        // FIXME: at this moment, iscTe does not have any
                        // attributes. Therefore, I cannot feed it with
                        // attributes of iscConfigYang
                        teIscList.add(iscTe);
                    }
                }
                TeTerminationPoint teSubsystemTp = new TeTerminationPoint(teTpId, teIscList, interLayerLockId);
                tp.setTe(teSubsystemTp);
            }
        }
    }
    return tp;
}
#method_after
public static org.onosproject.tetopology.management.api.node.TerminationPoint yang2teSubsystemTerminationPoint(TerminationPoint yangTp) {
    checkNotNull(yangTp, E_NULL_YANG_TP);
    org.onosproject.tetopology.management.api.node.DefaultTerminationPoint tp = new org.onosproject.tetopology.management.api.node.DefaultTerminationPoint(KeyId.keyId(yangTp.tpId().uri().string()));
    if (yangTp.supportingTerminationPoint() != null) {
        List<org.onosproject.tetopology.management.api.node.TerminationPointKey> spTps = Lists.newArrayList();
        for (SupportingTerminationPoint yangSptp : yangTp.supportingTerminationPoint()) {
            org.onosproject.tetopology.management.api.node.TerminationPointKey tpKey = new org.onosproject.tetopology.management.api.node.TerminationPointKey(KeyId.keyId(yangSptp.networkRef().uri().string()), KeyId.keyId(yangSptp.nodeRef().uri().string()), KeyId.keyId(yangSptp.tpRef().uri().string()));
            spTps.add(tpKey);
        }
        tp.setSupportingTpIds(spTps);
    }
    if (yangTp.yangAugmentedInfoMap() != null && !yangTp.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNtTerminationPoint yangTpAugment = (AugmentedNtTerminationPoint) yangTp.yangAugmentedInfo(AugmentedNtTerminationPoint.class);
        if (yangTpAugment.te() != null && yangTpAugment.te().teTpId() != null) {
            KeyId teTpId = KeyId.keyId(yangTpAugment.te().teTpId().toString());
            if (yangTpAugment.te().config() != null) {
                long interLayerLockId = yangTpAugment.te().config().interLayerLockId();
                List<org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability> teIscList = Lists.newArrayList();
                // between the two
                if (yangTpAugment.te().config().interfaceSwitchingCapability() != null) {
                    for (InterfaceSwitchingCapability iscConfigYang : yangTpAugment.te().config().interfaceSwitchingCapability()) {
                        org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability iscTe = new org.onosproject.tetopology.management.api.node.InterfaceSwitchingCapability();
                        // FIXME: at this moment, iscTe does not have any
                        // attributes. Therefore, I cannot feed it with
                        // attributes of iscConfigYang
                        teIscList.add(iscTe);
                    }
                }
                TeTerminationPoint teSubsystemTp = new TeTerminationPoint(teTpId, teIscList, interLayerLockId);
                tp.setTe(teSubsystemTp);
            }
        }
    }
    return tp;
}
#end_block

#method_before
private static Config teNode2YangConfig(TeNode teSubsystemTeNode) {
    checkNotNull(teSubsystemTeNode, "TeSubsystem teNode object cannot be null");
    TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesConfigBuilder = DefaultTeNodeAttributes.builder();
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.adminStatus(TeAdminStatus.fromString(teSubsystemTeNode.adminStatus().toString()));
    }
    teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.isAbstract(teSubsystemTeNode.isAbstract());
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTopology() != null) {
        UnderlayTopology.UnderlayTopologyBuilder underlayConfigBuilder = DefaultUnderlayTopology.builder();
        underlayConfigBuilder = underlayConfigBuilder.networkIdRef(NetworkId.fromString(teSubsystemTeNode.underlayTopology().getNetworkId().toString()));
        underlayConfigBuilder = underlayConfigBuilder.teTopologyIdRef(TeTopologyId.fromString(teSubsystemTeNode.underlayTopology().getTopologyId().topologyId()));
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.underlayTopology(underlayConfigBuilder.build());
    }
    // Once the TE subsystem connectivityMatrices is fixed, uncomment out the following code
    // if (teSubsystemTeNode.connectivityMatrices() != null) {
    // ConnectivityMatrix.ConnectivityMatrixBuilder connectivityMatrixConfigBuilder =
    // DefaultConnectivityMatrix.builder();
    // connectivityMatrixConfigBuilder = connectivityMatrixConfigBuilder
    // .id(teSubsystemTeNode.connectivityMatrices().id());
    // connectivityMatrixConfigBuilder = connectivityMatrixConfigBuilder
    // .isAllowed(teSubsystemTeNode.connectivityMatrices()
    // .isAllowed());
    // connectivityMatrixConfigBuilder = connectivityMatrixConfigBuilder
    // .from(new DefaultFrom.FromBuilder()
    // .tpRef(TpId.fromString(teSubsystemTeNode
    // .connectivityMatrices().from().tpId()
    // .toString()))
    // .build());
    // connectivityMatrixConfigBuilder = connectivityMatrixConfigBuilder
    // .to(new DefaultTo.ToBuilder()
    // .tpRef(TpId.fromString(teSubsystemTeNode
    // .connectivityMatrices().to().tpId()
    // .toString()))
    // .build());
    // teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder
    // .addToConnectivityMatrix(connectivityMatrixConfigBuilder
    // .build());
    // }
    Config.ConfigBuilder yangConfigBuilder = DefaultConfig.builder();
    yangConfigBuilder = yangConfigBuilder.teNodeAttributes(teNodeAttributesConfigBuilder.build());
    return yangConfigBuilder.build();
}
#method_after
private static Config teNode2YangConfig(TeNode teSubsystemTeNode) {
    checkNotNull(teSubsystemTeNode, E_NULL_TE_SUBSYSTEM_TE_NODE);
    TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesConfigBuilder = DefaultTeNodeAttributes.builder().isAbstract(teSubsystemTeNode.isAbstract());
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teSubsystemTeNode.adminStatus()));
    }
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTopology() != null) {
        teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.underlayTopology(teNode2YangUnderlayConfig(teSubsystemTeNode.underlayTopology()));
    }
    if (teSubsystemTeNode.connectivityMatrices() != null) {
        ConnectivityMatrix.ConnectivityMatrixBuilder connectivityMatrixConfigBuilder = DefaultConnectivityMatrix.builder();
        for (org.onosproject.tetopology.management.api.node.ConnectivityMatrix teCm : teSubsystemTeNode.connectivityMatrices()) {
            connectivityMatrixConfigBuilder = connectivityMatrixConfigBuilder.id(teCm.id()).isAllowed(teCm.isAllowed()).from(new DefaultFrom.FromBuilder().tpRef(TpId.fromString(teCm.from().tpId().toString())).build()).to(new DefaultTo.ToBuilder().tpRef(TpId.fromString(teCm.to().tpId().toString())).build());
            teNodeAttributesConfigBuilder = teNodeAttributesConfigBuilder.addToConnectivityMatrix(connectivityMatrixConfigBuilder.build());
        }
    }
    Config.ConfigBuilder yangConfigBuilder = DefaultConfig.builder();
    yangConfigBuilder = yangConfigBuilder.teNodeAttributes(teNodeAttributesConfigBuilder.build());
    return yangConfigBuilder.build();
}
#end_block

#method_before
private static State teNode2YangState(TeNode teSubsystemTeNode) {
    checkNotNull(teSubsystemTeNode, "TeSubsystem teNode object cannot be null");
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.DefaultTeNodeAttributes.builder();
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.adminStatus(TeAdminStatus.fromString(teSubsystemTeNode.adminStatus().toString()));
    }
    teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.isAbstract(teSubsystemTeNode.isAbstract());
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTopology() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.UnderlayTopology.UnderlayTopologyBuilder underlayStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.DefaultUnderlayTopology.builder();
        underlayStateBuilder = underlayStateBuilder.networkIdRef(NetworkId.fromString(teSubsystemTeNode.underlayTopology().getNetworkId().toString()));
        underlayStateBuilder = underlayStateBuilder.teTopologyIdRef(TeTopologyId.fromString(teSubsystemTeNode.underlayTopology().getTopologyId().topologyId()));
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.underlayTopology(underlayStateBuilder.build());
    }
    // Once the TE subsystem connectivityMatrices is fixed, uncomment out the following code
    // if (teSubsystemTeNode.connectivityMatrices() != null) {
    // org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology
    // .networks.network.node.augmentednwnode.te.state.tenodeattributes.ConnectivityMatrix
    // .ConnectivityMatrixBuilder
    // connectivityMatrixStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf
    // .te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode
    // .te.state.tenodeattributes.DefaultConnectivityMatrix
    // .builder();
    // connectivityMatrixStateBuilder = connectivityMatrixStateBuilder
    // .id(teSubsystemTeNode.connectivityMatrices().id());
    // connectivityMatrixStateBuilder = connectivityMatrixStateBuilder
    // .isAllowed(teSubsystemTeNode.connectivityMatrices()
    // .isAllowed());
    // connectivityMatrixStateBuilder = connectivityMatrixStateBuilder
    // .from(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology
    // .rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state
    // .tenodeattributes.connectivitymatrix.DefaultFrom.FromBuilder()
    // .tpRef(TpId.fromString(teSubsystemTeNode
    // .connectivityMatrices().from().tpId()
    // .toString()))
    // .build());
    // connectivityMatrixStateBuilder = connectivityMatrixStateBuilder
    // .to(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology
    // .rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state
    // .tenodeattributes.connectivitymatrix.DefaultTo.ToBuilder()
    // .tpRef(TpId.fromString(teSubsystemTeNode
    // .connectivityMatrices().to().tpId()
    // .toString()))
    // .build());
    // teNodeAttributesStateBuilder = teNodeAttributesStateBuilder
    // .addToConnectivityMatrix(connectivityMatrixStateBuilder
    // .build());
    // }
    State.StateBuilder yangStateBuilder = DefaultState.builder();
    yangStateBuilder = yangStateBuilder.teNodeAttributes(teNodeAttributesStateBuilder.build());
    if (teSubsystemTeNode.opStatus() != null) {
        yangStateBuilder = yangStateBuilder.operStatus(TeOperStatus.fromString(teSubsystemTeNode.opStatus().toString()));
    }
    return yangStateBuilder.build();
}
#method_after
private static State teNode2YangState(TeNode teSubsystemTeNode) {
    checkNotNull(teSubsystemTeNode, E_NULL_TE_SUBSYSTEM_TE_NODE);
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.TeNodeAttributes.TeNodeAttributesBuilder teNodeAttributesStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.DefaultTeNodeAttributes.builder().isAbstract(teSubsystemTeNode.isAbstract());
    if (teSubsystemTeNode.adminStatus() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.adminStatus(EnumConverter.teSubsystem2YangAdminStatus(teSubsystemTeNode.adminStatus()));
    }
    if (teSubsystemTeNode.name() != null) {
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.name(DomainName.fromString(teSubsystemTeNode.name()));
    }
    if (teSubsystemTeNode.underlayTopology() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.UnderlayTopology.UnderlayTopologyBuilder underlayStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.DefaultUnderlayTopology.builder();
        underlayStateBuilder = underlayStateBuilder.networkIdRef(NetworkId.fromString(teSubsystemTeNode.underlayTopology().getNetworkId().toString())).teTopologyIdRef(TeTopologyId.fromString(teSubsystemTeNode.underlayTopology().getTopologyId().topologyId()));
        teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.underlayTopology(underlayStateBuilder.build());
    }
    if (teSubsystemTeNode.connectivityMatrices() != null) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.ConnectivityMatrix.ConnectivityMatrixBuilder connectivityMatrixStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.DefaultConnectivityMatrix.builder();
        for (org.onosproject.tetopology.management.api.node.ConnectivityMatrix teCm : teSubsystemTeNode.connectivityMatrices()) {
            connectivityMatrixStateBuilder = connectivityMatrixStateBuilder.id(teCm.id()).isAllowed(teCm.isAllowed()).from(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.connectivitymatrix.DefaultFrom.FromBuilder().tpRef(TpId.fromString(teCm.from().tpId().toString())).build()).to(new org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.state.tenodeattributes.connectivitymatrix.DefaultTo.ToBuilder().tpRef(TpId.fromString(teCm.to().tpId().toString())).build());
            teNodeAttributesStateBuilder = teNodeAttributesStateBuilder.addToConnectivityMatrix(connectivityMatrixStateBuilder.build());
        }
    }
    State.StateBuilder yangStateBuilder = DefaultState.builder();
    yangStateBuilder = yangStateBuilder.teNodeAttributes(teNodeAttributesStateBuilder.build());
    if (teSubsystemTeNode.opStatus() != null) {
        yangStateBuilder = yangStateBuilder.operStatus(EnumConverter.teSubsystem2YangOperStatus(teSubsystemTeNode.opStatus()));
    }
    return yangStateBuilder.build();
}
#end_block

#method_before
private static TunnelTerminationPoint teSubsystem2YangTtp(org.onosproject.tetopology.management.api.node.TunnelTerminationPoint teTunnelTp) {
    checkNotNull(teTunnelTp, "TeSubsystem teTunnelTp object cannot be null");
    TunnelTerminationPoint.TunnelTerminationPointBuilder tunnelTpBuilder = DefaultTunnelTerminationPoint.builder().tunnelTpId(teTunnelTp.getTunnelTpId());
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.Config.ConfigBuilder ttpConfigBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.DefaultConfig.builder();
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.State.StateBuilder ttpStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.DefaultState.builder();
    // if (teTunnelTp.getInterLayerLockId() != null) {
    // ttpConfigBuilder = ttpConfigBuilder.interLayerLockId(teTunnelTp.getInterLayerLockId());
    // ttpStateBuilder  = ttpStateBuilder.interLayerLockId(teTunnelTp.getInterLayerLockId());
    // }
    ttpConfigBuilder = ttpConfigBuilder.interLayerLockId(teTunnelTp.getInterLayerLockId());
    ttpStateBuilder = ttpStateBuilder.interLayerLockId(teTunnelTp.getInterLayerLockId());
    if (teTunnelTp.getSwitchingCapabilities() != null) {
        // this?
        for (InterfaceSwitchingCapability iscTe : teTunnelTp.getSwitchingCapabilities()) {
        // ttpConfigBuilder =
        // ttpConfigBuilder.switchingCapability(switchingCapability)
        // ttpStateBuilder =
        // ttpStateBuilder.switchingCapability(switchingCapability)
        }
    }
    if (teTunnelTp.getTerminationCapability() != null) {
        for (TerminationCapability tcap : teTunnelTp.getTerminationCapability()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.config.TerminationCapability.TerminationCapabilityBuilder tcapConfigBuilder = DefaultTerminationCapability.builder();
            // FIXME: at this moment, tcap does not have any getter or setter.
            // add the following getLinkTpId possibly other attributes to Core data structure
            // tcapConfigBuilder =
            // tcapConfigBuilder.linkTp(TpId.fromString(tcap.getLinkTpId.toString()));
            ttpConfigBuilder = ttpConfigBuilder.addToTerminationCapability(tcapConfigBuilder.build());
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.state.TerminationCapability.TerminationCapabilityBuilder tcapStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.state.DefaultTerminationCapability.builder();
            // FIXME: at this moment, tcap does not have any getter or setter.
            // add the following getLinkTpId possibly other attributes to Core data structure
            // tcapConfigBuilder =
            // tcapConfigBuilder.linkTp(TpId.fromString(tcap.getLinkTpId.toString()));
            ttpStateBuilder = ttpStateBuilder.addToTerminationCapability(tcapStateBuilder.build());
        }
    }
    tunnelTpBuilder = tunnelTpBuilder.config(ttpConfigBuilder.build());
    tunnelTpBuilder = tunnelTpBuilder.state(ttpStateBuilder.build());
    return tunnelTpBuilder.build();
}
#method_after
private static TunnelTerminationPoint teSubsystem2YangTtp(org.onosproject.tetopology.management.api.node.TunnelTerminationPoint teTunnelTp) {
    checkNotNull(teTunnelTp, E_NULL_TE_SUBSYSTEM_TE_TUNNEL_TP);
    TunnelTerminationPoint.TunnelTerminationPointBuilder tunnelTpBuilder = DefaultTunnelTerminationPoint.builder().tunnelTpId(teTunnelTp.getTunnelTpId());
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.Config.ConfigBuilder ttpConfigBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.DefaultConfig.builder();
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.State.StateBuilder ttpStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.DefaultState.builder();
    if (Long.valueOf(teTunnelTp.getInterLayerLockId()) != null) {
        ttpConfigBuilder = ttpConfigBuilder.interLayerLockId(teTunnelTp.getInterLayerLockId());
        ttpStateBuilder = ttpStateBuilder.interLayerLockId(teTunnelTp.getInterLayerLockId());
    }
    if (teTunnelTp.getSwitchingCapabilities() != null) {
        // this?
        for (InterfaceSwitchingCapability iscTe : teTunnelTp.getSwitchingCapabilities()) {
        // ttpConfigBuilder =
        // ttpConfigBuilder.switchingCapability(switchingCapability)
        // ttpStateBuilder =
        // ttpStateBuilder.switchingCapability(switchingCapability)
        }
    }
    if (teTunnelTp.getTerminationCapabilities() != null) {
        for (TerminationCapability tcap : teTunnelTp.getTerminationCapabilities()) {
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.config.TerminationCapability.TerminationCapabilityBuilder tcapConfigBuilder = DefaultTerminationCapability.builder();
            // FIXME: at this moment, tcap does not have any getter or setter.
            // add the following getLinkTpId possibly other attributes to Core data structure
            // tcapConfigBuilder =
            // tcapConfigBuilder.linkTp(TpId.fromString(tcap.getLinkTpId.toString()));
            ttpConfigBuilder = ttpConfigBuilder.addToTerminationCapability(tcapConfigBuilder.build());
            org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.state.TerminationCapability.TerminationCapabilityBuilder tcapStateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.te.topology.rev20160708.ietftetopology.networks.network.node.augmentednwnode.te.tunnelterminationpoint.state.DefaultTerminationCapability.builder();
            // FIXME: at this moment, tcap does not have any getter or setter.
            // add the following getLinkTpId possibly other attributes to Core data structure
            // tcapConfigBuilder =
            // tcapConfigBuilder.linkTp(TpId.fromString(tcap.getLinkTpId.toString()));
            ttpStateBuilder = ttpStateBuilder.addToTerminationCapability(tcapStateBuilder.build());
        }
    }
    tunnelTpBuilder = tunnelTpBuilder.config(ttpConfigBuilder.build()).state(ttpStateBuilder.build());
    return tunnelTpBuilder.build();
}
#end_block

#method_before
public static Node teSubsystem2YangNode(org.onosproject.tetopology.management.api.node.NetworkNode teSubsystem) {
    checkNotNull(teSubsystem, "TeSubsystem ndoe object cannot be null");
    NodeId nodeId = NodeId.fromString(teSubsystem.nodeId().toString());
    Node.NodeBuilder builder = DefaultNode.builder().nodeId(nodeId);
    if (teSubsystem.getSupportingNodeIds() != null) {
        List<SupportingNode> sNodes = Lists.newArrayList();
        SupportingNode.SupportingNodeBuilder spNodeBuilder = DefaultSupportingNode.builder();
        for (NetworkNodeKey nodeKey : teSubsystem.getSupportingNodeIds()) {
            sNodes.add(spNodeBuilder.networkRef(NetworkId.fromString(nodeKey.networkId().toString())).nodeRef(NodeId.fromString(nodeKey.nodeId().toString())).build());
        }
        builder = builder.supportingNode(sNodes);
    }
    if (teSubsystem.getTerminationPoints() != null) {
        AugmentedNdNode.AugmentedNdNodeBuilder tpAugmentBuilder = DefaultAugmentedNdNode.builder();
        List<TerminationPoint> teSubsystemTeTp = teSubsystem.getTerminationPoints();
        for (TerminationPoint teTp : teSubsystemTeTp) {
            tpAugmentBuilder.addToTerminationPoint(TerminationPointConverter.teSubsystem2YangTerminationPoint(teTp));
        }
        builder.addYangAugmentedInfo(tpAugmentBuilder.build(), AugmentedNdNode.class);
    }
    if (teSubsystem.getTe() != null) {
        AugmentedNwNode.AugmentedNwNodeBuilder nodeAugmentBuilder = DefaultAugmentedNwNode.builder();
        TeNode teSubsystemTeNode = teSubsystem.getTe();
        TeBuilder yangTeBuilder = DefaultTe.builder();
        if (teSubsystemTeNode.teNodeId() != null) {
            yangTeBuilder = yangTeBuilder.teNodeId(TeNodeId.fromString(teSubsystemTeNode.teNodeId().toString()));
        }
        // Set configuration data
        yangTeBuilder = yangTeBuilder.config(teNode2YangConfig(teSubsystemTeNode));
        // Set state data
        yangTeBuilder = yangTeBuilder.state(teNode2YangState(teSubsystemTeNode));
        if (teSubsystemTeNode.tunnelTerminationPoints() != null) {
        // Once the "Map" is fixed in TE Topology APP, uncomment out the following code.
        // for (org.onosproject.tetopology.management.api.node.TunnelTerminationPoint
        // teTunnelTp : teSubsystemTeNode.tunnelTerminationPoints()) {
        // yangTeBuilder = yangTeBuilder.addToTunnelTerminationPoint(teSubsystem2YangTtp(teTunnelTp));
        // }
        }
        nodeAugmentBuilder = nodeAugmentBuilder.te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(nodeAugmentBuilder.build(), AugmentedNwNode.class);
    }
    return builder.build();
}
#method_after
public static Node teSubsystem2YangNode(org.onosproject.tetopology.management.api.node.NetworkNode teSubsystem) {
    checkNotNull(teSubsystem, E_NULL_TE_SUBSYSTEM_NODE);
    NodeId nodeId = NodeId.fromString(teSubsystem.nodeId().toString());
    Node.NodeBuilder builder = DefaultNode.builder().nodeId(nodeId);
    if (teSubsystem.getSupportingNodeIds() != null) {
        List<SupportingNode> sNodes = Lists.newArrayList();
        SupportingNode.SupportingNodeBuilder spNodeBuilder = DefaultSupportingNode.builder();
        for (NetworkNodeKey nodeKey : teSubsystem.getSupportingNodeIds()) {
            sNodes.add(spNodeBuilder.networkRef(NetworkId.fromString(nodeKey.networkId().toString())).nodeRef(NodeId.fromString(nodeKey.nodeId().toString())).build());
        }
        builder = builder.supportingNode(sNodes);
    }
    if (teSubsystem.getTerminationPoints() != null) {
        AugmentedNdNode.AugmentedNdNodeBuilder tpAugmentBuilder = DefaultAugmentedNdNode.builder();
        List<TerminationPoint> teSubsystemTeTp = teSubsystem.getTerminationPoints();
        for (TerminationPoint teTp : teSubsystemTeTp) {
            tpAugmentBuilder.addToTerminationPoint(TerminationPointConverter.teSubsystem2YangTerminationPoint(teTp));
        }
        builder.addYangAugmentedInfo(tpAugmentBuilder.build(), AugmentedNdNode.class);
    }
    if (teSubsystem.getTe() != null) {
        AugmentedNwNode.AugmentedNwNodeBuilder nodeAugmentBuilder = DefaultAugmentedNwNode.builder();
        TeNode teSubsystemTeNode = teSubsystem.getTe();
        TeBuilder yangTeBuilder = DefaultTe.builder();
        if (teSubsystemTeNode.teNodeId() != null) {
            yangTeBuilder = yangTeBuilder.teNodeId(TeNodeId.fromString(teSubsystemTeNode.teNodeId().toString()));
        }
        // Set configuration data
        // Set state data
        yangTeBuilder = yangTeBuilder.config(teNode2YangConfig(teSubsystemTeNode)).state(teNode2YangState(teSubsystemTeNode));
        if (teSubsystemTeNode.tunnelTerminationPoints() != null) {
            for (org.onosproject.tetopology.management.api.node.TunnelTerminationPoint teTunnelTp : teSubsystemTeNode.tunnelTerminationPoints()) {
                yangTeBuilder = yangTeBuilder.addToTunnelTerminationPoint(teSubsystem2YangTtp(teTunnelTp));
            }
        }
        nodeAugmentBuilder = nodeAugmentBuilder.te(yangTeBuilder.build());
        builder.addYangAugmentedInfo(nodeAugmentBuilder.build(), AugmentedNwNode.class);
    }
    return builder.build();
}
#end_block

#method_before
public static org.onosproject.tetopology.management.api.node.NetworkNode yang2TeSubsystemNode(Node yangNode, NetworkId yangNetworkId) {
    checkNotNull(yangNode, "Yang node object cannot be null");
    org.onosproject.tetopology.management.api.node.DefaultNetworkNode node = new org.onosproject.tetopology.management.api.node.DefaultNetworkNode(KeyId.keyId(yangNode.nodeId().uri().string()));
    if (yangNode.supportingNode() != null) {
        List<NetworkNodeKey> spNodes = Lists.newArrayList();
        for (SupportingNode yangSpNode : yangNode.supportingNode()) {
            NetworkNodeKey nodeKey = new NetworkNodeKey(KeyId.keyId(yangSpNode.nodeRef().uri().toString()), KeyId.keyId(yangSpNode.networkRef().uri().toString()));
            spNodes.add(nodeKey);
        }
        node.setSupportingNodeIds(spNodes);
    }
    if (yangNode.yangAugmentedInfoMap() != null && !yangNode.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNdNode yangTpNodeAugment = (AugmentedNdNode) yangNode.yangAugmentedInfo(AugmentedNdNode.class);
        if (yangTpNodeAugment.terminationPoint() != null) {
            List<TerminationPoint> teTpList = Lists.newArrayList();
            for (org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.topology.rev20151208.ietfnetworktopology.networks.network.node.augmentedndnode.TerminationPoint yangTpnode : yangTpNodeAugment.terminationPoint()) {
                teTpList.add(TerminationPointConverter.yang2teSubsystemTerminationPoint(yangTpnode));
            }
            node.setTerminationPoints(teTpList);
        }
        AugmentedNwNode yangNodeAugment = (AugmentedNwNode) yangNode.yangAugmentedInfo(AugmentedNwNode.class);
        if (yangNodeAugment != null && yangNodeAugment.te() != null && yangNodeAugment.te().teNodeId() != null) {
            TeNode teNode = new TeNode(yangNodeAugment.te().teNodeId().toString());
            if (yangNodeAugment.te().config() != null && yangNodeAugment.te().config().teNodeAttributes() != null) {
                if (yangNodeAugment.te().config().teNodeAttributes().adminStatus() != null) {
                    teNode.setAdminStatus(TeStatus.fromString(yangNodeAugment.te().config().teNodeAttributes().adminStatus().toString()));
                }
                if (yangNodeAugment.te().state() != null && yangNodeAugment.te().state().operStatus() != null) {
                    teNode.setOpStatus(TeStatus.fromString(yangNodeAugment.te().state().operStatus().toString()));
                }
                teNode.setAbstract(yangNodeAugment.te().config().teNodeAttributes().isAbstract());
                if (yangNodeAugment.te().config().teNodeAttributes().connectivityMatrix() != null) {
                    // is not a list in teSubsystem
                    for (ConnectivityMatrix cmYang : yangNodeAugment.te().config().teNodeAttributes().connectivityMatrix()) {
                        Long id = cmYang.id();
                        TerminationPointKey from = new TerminationPointKey(KeyId.keyId(yangNetworkId.uri().toString()), KeyId.keyId(yangNodeAugment.te().teNodeId().toString()), KeyId.keyId(cmYang.from().tpRef().uri().toString()));
                        TerminationPointKey to = new TerminationPointKey(KeyId.keyId(yangNetworkId.uri().toString()), KeyId.keyId(yangNodeAugment.te().teNodeId().toString()), KeyId.keyId(cmYang.to().tpRef().uri().toString()));
                        boolean isAllowed = cmYang.isAllowed();
                        org.onosproject.tetopology.management.api.node.ConnectivityMatrix cmTe = new org.onosproject.tetopology.management.api.node.ConnectivityMatrix(id, from, to, isAllowed);
                    // teNode.setConnectivityMatrices(cmTe);
                    }
                }
                if (yangNodeAugment.te().config().teNodeAttributes().underlayTopology() != null) {
                    org.onosproject.tetopology.management.api.TeTopologyId teTopologyId = new org.onosproject.tetopology.management.api.TeTopologyId(yangNodeAugment.te().config().teNodeAttributes().underlayTopology().providerIdRef().uint32(), yangNodeAugment.te().config().teNodeAttributes().underlayTopology().clientIdRef().uint32(), yangNodeAugment.te().config().teNodeAttributes().underlayTopology().teTopologyIdRef().toString());
                    TeNetworkTopologyId underlayTopology = new TeNetworkTopologyId(KeyId.keyId(yangNodeAugment.te().config().teNodeAttributes().underlayTopology().networkIdRef().uri().toString()), teTopologyId);
                    teNode.setUnderlayTopology(underlayTopology);
                }
            }
            if (yangNodeAugment.te().tunnelTerminationPoint() != null) {
                List<org.onosproject.tetopology.management.api.node.TunnelTerminationPoint> ttpTeList = Lists.newArrayList();
                for (TunnelTerminationPoint ttpYang : yangNodeAugment.te().tunnelTerminationPoint()) {
                    org.onosproject.tetopology.management.api.node.TunnelTerminationPoint ttpTe = new org.onosproject.tetopology.management.api.node.TunnelTerminationPoint(ttpYang.tunnelTpId());
                    ttpTe.setInterLayerLockId(ttpYang.config().interLayerLockId());
                    // FIXME: go through
                    // ttpYang.config().switchingCapability() and populate
                    // ttpTe.setSwitchingCapabilities(switchingCapabilities);
                    // FIXME: go through
                    // ttpYang.config().terminationCapability() and populate
                    // ttpTe.setTerminationCapability(terminationCapability);
                    ttpTeList.add(ttpTe);
                }
            // teNode.setTunnelTerminationPoints(ttpTeList);
            }
            node.setTe(teNode);
        }
    }
    return node;
}
#method_after
public static org.onosproject.tetopology.management.api.node.NetworkNode yang2TeSubsystemNode(Node yangNode, NetworkId yangNetworkId) {
    checkNotNull(yangNode, E_NULL_YANG_NODE);
    org.onosproject.tetopology.management.api.node.DefaultNetworkNode node = new org.onosproject.tetopology.management.api.node.DefaultNetworkNode(KeyId.keyId(yangNode.nodeId().uri().string()));
    if (yangNode.supportingNode() != null) {
        List<NetworkNodeKey> spNodes = Lists.newArrayList();
        for (SupportingNode yangSpNode : yangNode.supportingNode()) {
            NetworkNodeKey nodeKey = new NetworkNodeKey(KeyId.keyId(yangSpNode.nodeRef().uri().toString()), KeyId.keyId(yangSpNode.networkRef().uri().toString()));
            spNodes.add(nodeKey);
        }
        node.setSupportingNodeIds(spNodes);
    }
    if (yangNode.yangAugmentedInfoMap() != null && !yangNode.yangAugmentedInfoMap().isEmpty()) {
        AugmentedNdNode yangTpNodeAugment = (AugmentedNdNode) yangNode.yangAugmentedInfo(AugmentedNdNode.class);
        if (yang2TeSubsystemTpNodeAugment(yangTpNodeAugment) != null) {
            node.setTerminationPoints(yang2TeSubsystemTpNodeAugment(yangTpNodeAugment));
        }
        AugmentedNwNode yangNodeAugment = (AugmentedNwNode) yangNode.yangAugmentedInfo(AugmentedNwNode.class);
        if (yangNodeAugment != null && yangNodeAugment.te() != null && yangNodeAugment.te().teNodeId() != null) {
            Te yangNodeAugTe = yangNodeAugment.te();
            TeNode teNode = yang2TeSubsystemNodeAugment(yangNodeAugTe, yangNetworkId, yangNode.nodeId());
            node.setTe(teNode);
        }
    }
    return node;
}
#end_block

#method_before
private static DefaultNetworks.OnosYangNodeOperationType toNetworksOperationType(OperationType operation) {
    switch(operation) {
        case CREATE:
            return DefaultNetworks.OnosYangNodeOperationType.CREATE;
        case DELETE:
            return DefaultNetworks.OnosYangNodeOperationType.DELETE;
        case REMOVE:
            return DefaultNetworks.OnosYangNodeOperationType.REMOVE;
        case MERGE:
            return DefaultNetworks.OnosYangNodeOperationType.MERGE;
        case REPLACE:
            return DefaultNetworks.OnosYangNodeOperationType.REPLACE;
        default:
            return DefaultNetworks.OnosYangNodeOperationType.NONE;
    }
}
#method_after
private static OnosYangNodeOperationType toNetworksOperationType(OperationType operation) {
    switch(operation) {
        case CREATE:
            return OnosYangNodeOperationType.CREATE;
        case DELETE:
            return OnosYangNodeOperationType.DELETE;
        case REMOVE:
            return OnosYangNodeOperationType.REMOVE;
        case MERGE:
            return OnosYangNodeOperationType.MERGE;
        case REPLACE:
            return OnosYangNodeOperationType.REPLACE;
        default:
            return OnosYangNodeOperationType.NONE;
    }
}
#end_block

#method_before
public static Networks teSubsystem2YangNetworks(org.onosproject.tetopology.management.api.Networks teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, "teSubsystem object cannot be null");
    checkNotNull(teSubsystem.networks(), "TeSubsystem Networks object cannot be null");
    Networks.NetworksBuilder builder = DefaultNetworks.builder().onosYangNodeOperationType(toNetworksOperationType(operation));
    List<Network> networks = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.Network teNetwork : teSubsystem.networks()) {
        networks.add(teSubsystem2YangNetwork(teNetwork, operation));
    }
    builder.network(networks);
    return builder.build();
}
#method_after
public static Networks teSubsystem2YangNetworks(org.onosproject.tetopology.management.api.Networks teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, E_NULL_TE_NETWORKS);
    checkNotNull(teSubsystem.networks(), E_NULL_TE_NETWORK_LIST);
    Networks.NetworksBuilder builder = DefaultNetworks.builder().onosYangNodeOperationType(toNetworksOperationType(operation));
    List<Network> networks = Lists.newArrayList();
    for (org.onosproject.tetopology.management.api.Network teNetwork : teSubsystem.networks()) {
        networks.add(teSubsystem2YangNetwork(teNetwork, operation));
    }
    builder.network(networks);
    return builder.build();
}
#end_block

#method_before
public static org.onosproject.tetopology.management.api.Networks yang2TeSubsystemNetworks(Networks yangNetworks, NetworksState yangNetworkStates) {
    checkNotNull(yangNetworks, "YANG Networks object cannot be null");
    checkNotNull(yangNetworks.network(), "YANG list of networks cannot be null");
    checkNotNull(yangNetworkStates, "YANG NetworksState object cannot be null");
    org.onosproject.tetopology.management.api.DefaultNetworks defaultNetworks = new org.onosproject.tetopology.management.api.DefaultNetworks();
    List<org.onosproject.tetopology.management.api.Network> networks = Lists.newArrayList();
    for (Network network : yangNetworks.network()) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network stateNetwork = networkStateNetwork(network, yangNetworkStates);
        org.onosproject.tetopology.management.api.Network teNetwork;
        if (stateNetwork == null) {
            log.info("networkId {} can't be found in yangNetworkStates", network.networkId().toString());
            teNetwork = yang2TeSubsystemNetwork(network);
        } else {
            teNetwork = yang2TeSubsystemNetwork(network, stateNetwork);
        }
        networks.add(teNetwork);
    }
    defaultNetworks.setNetworks(networks);
    return defaultNetworks;
}
#method_after
public static org.onosproject.tetopology.management.api.Networks yang2TeSubsystemNetworks(Networks yangNetworks, NetworksState yangNetworkStates) {
    checkNotNull(yangNetworks, E_NULL_YANG_NETWORKS);
    checkNotNull(yangNetworks.network(), E_NULL_YANG_NETWORK_LIST);
    checkNotNull(yangNetworkStates, E_NULL_YANG_NETWORKSSTATE);
    org.onosproject.tetopology.management.api.DefaultNetworks defaultNetworks = new org.onosproject.tetopology.management.api.DefaultNetworks();
    List<org.onosproject.tetopology.management.api.Network> networks = Lists.newArrayList();
    for (Network network : yangNetworks.network()) {
        org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network stateNetwork = networkStateNetwork(network, yangNetworkStates);
        org.onosproject.tetopology.management.api.Network teNetwork;
        if (stateNetwork == null) {
            log.info("networkId {} can't be found in yangNetworkStates", network.networkId());
            teNetwork = yang2TeSubsystemNetwork(network);
        } else {
            teNetwork = yang2TeSubsystemNetwork(network, stateNetwork);
        }
        networks.add(teNetwork);
    }
    defaultNetworks.setNetworks(networks);
    return defaultNetworks;
}
#end_block

#method_before
public static Network teSubsystem2YangNetwork(org.onosproject.tetopology.management.api.Network teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, "TeSubsystem Network object cannot be null");
    checkNotNull(teSubsystem.networkId(), "TeSubsystem networkId cannot be null");
    // Generate a network builder with the specific networkId.
    NetworkId networkId = NetworkId.fromString(teSubsystem.networkId().toString());
    Network.NetworkBuilder builder = DefaultNetwork.builder().onosYangNodeOperationType(toNetworkOperationType(operation)).networkId(networkId);
    // Supporting networks
    if (teSubsystem.getSupportingNetworkIds() != null) {
        List<SupportingNetwork> snws = Lists.newArrayList();
        SupportingNetwork.SupportingNetworkBuilder spNetworkBuilder = DefaultSupportingNetwork.builder();
        for (KeyId teSpNwKey : teSubsystem.getSupportingNetworkIds()) {
            snws.add(spNetworkBuilder.networkRef(NetworkId.fromString(teSpNwKey.toString())).build());
        }
        builder = builder.supportingNetwork(snws);
    }
    // Nodes
    if (teSubsystem.getNodes() != null) {
        List<Node> nodeList = Lists.newArrayList();
        // Add each node
        for (org.onosproject.tetopology.management.api.node.NetworkNode node : teSubsystem.getNodes()) {
            // Convert the te node to a YO.
            nodeList.add(NodeConverter.teSubsystem2YangNode(node));
        }
        builder = builder.node(nodeList);
    }
    // Network types
    NetworkTypes.NetworkTypesBuilder nwType = DefaultNetworkTypes.builder();
    if (teSubsystem.getTeTopologyId() != null) {
        // Set "te-topology" network type.
        TeTopology.TeTopologyBuilder teTopology = DefaultTeTopology.builder();
        AugmentedNwNetworkTypes.AugmentedNwNetworkTypesBuilder teNwType = DefaultAugmentedNwNetworkTypes.builder();
        teNwType.teTopology(teTopology.build());
        nwType.addYangAugmentedInfo(teNwType.build(), AugmentedNwNetworkTypes.class);
    }
    builder.networkTypes(nwType.build());
    // Add links - link is the augmentation
    if (teSubsystem.getLinks() != null) {
        List<Link> linkList = Lists.newArrayList();
        // Add each link
        for (org.onosproject.tetopology.management.api.link.NetworkLink link : teSubsystem.getLinks()) {
            // Convert the te link to a YO
            linkList.add(LinkConverter.teSubsystem2YangLink(link));
        }
        AugmentedNdNetwork.AugmentedNdNetworkBuilder ndAugment = DefaultAugmentedNdNetwork.builder();
        ndAugment.link(linkList);
        builder.addYangAugmentedInfo(ndAugment.build(), AugmentedNdNetwork.class);
    }
    // TE Topology IDs
    if (teSubsystem.getTeTopologyId() != null) {
        Te.TeBuilder teBuilder = DefaultTe.builder();
        teBuilder.clientId(new TeGlobalId(teSubsystem.getTeTopologyId().clientId()));
        teBuilder.providerId(new TeGlobalId(teSubsystem.getTeTopologyId().providerId()));
        if (teSubsystem.getTeTopologyId().topologyId() != null) {
            teBuilder.teTopologyId(new TeTopologyId(teSubsystem.getTeTopologyId().topologyId()));
        }
        AugmentedNwNetwork.AugmentedNwNetworkBuilder nwAugment = DefaultAugmentedNwNetwork.builder();
        nwAugment.te(teBuilder.build());
        builder.addYangAugmentedInfo(nwAugment.build(), AugmentedNwNetwork.class);
    }
    return builder.build();
}
#method_after
public static Network teSubsystem2YangNetwork(org.onosproject.tetopology.management.api.Network teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, E_NULL_TE_NETWORK);
    checkNotNull(teSubsystem.networkId(), E_NULL_TE_NETWORKID);
    // Generate a network builder with the specific networkId.
    NetworkId networkId = NetworkId.fromString(teSubsystem.networkId().toString());
    NetworkBuilder builder = DefaultNetwork.builder().onosYangNodeOperationType(toNetworkOperationType(operation)).networkId(networkId);
    // Supporting networks
    if (teSubsystem.getSupportingNetworkIds() != null) {
        builder = te2YangSupportingNetwork(builder, teSubsystem.getSupportingNetworkIds());
    }
    // Nodes
    if (teSubsystem.getNodes() != null) {
        builder = te2YangNodes(builder, teSubsystem.getNodes());
    }
    // Network types
    builder = te2YangNetworkType(builder, teSubsystem.getTeTopologyId());
    // Add links - link is the augmentation
    if (teSubsystem.getLinks() != null) {
        builder = te2YangLinks(builder, teSubsystem.getLinks());
    }
    // TE Topology IDs
    if (teSubsystem.getTeTopologyId() != null) {
        builder = te2YangTopologyIds(builder, teSubsystem.getTeTopologyId());
    }
    return builder.build();
}
#end_block

#method_before
public static org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network teSubsystem2YangNetworkState(org.onosproject.tetopology.management.api.Network teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, "TeSubsystem Network object cannot be null");
    checkNotNull(teSubsystem.networkId(), "TeSubsystem networkId cannot be null");
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network.NetworkBuilder stateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.DefaultNetwork.builder();
    if (teSubsystem.networkId() != null) {
        stateBuilder.networkRef(NetworkId.fromString(teSubsystem.networkId().toString()));
    }
    stateBuilder.serverProvided(teSubsystem.isServerProvided());
    // Operation type may be required.
    return stateBuilder.build();
}
#method_after
public static org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network teSubsystem2YangNetworkState(org.onosproject.tetopology.management.api.Network teSubsystem, OperationType operation) {
    checkNotNull(teSubsystem, E_NULL_TE_NETWORK);
    checkNotNull(teSubsystem.networkId(), E_NULL_TE_NETWORKID);
    org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network.NetworkBuilder stateBuilder = org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.DefaultNetwork.builder();
    if (teSubsystem.networkId() != null) {
        stateBuilder.networkRef(NetworkId.fromString(teSubsystem.networkId().toString()));
    }
    stateBuilder.serverProvided(teSubsystem.isServerProvided());
    // Operation type may be required.
    return stateBuilder.build();
}
#end_block

#method_before
private static org.onosproject.tetopology.management.api.DefaultNetwork yang2TeDefaultNetwork(Network yangNetwork) {
    checkNotNull(yangNetwork, "YANG Network object cannot be null");
    checkNotNull(yangNetwork.networkId(), "YANG networkId cannot be null");
    String networkId = yangNetwork.networkId().uri().string();
    org.onosproject.tetopology.management.api.DefaultNetwork teNetwork = new org.onosproject.tetopology.management.api.DefaultNetwork(KeyId.keyId(networkId));
    // Supporting networks
    if (yangNetwork.supportingNetwork() != null) {
        List<KeyId> supportingNetworkIds = Lists.newArrayList();
        for (SupportingNetwork supportNw : yangNetwork.supportingNetwork()) {
            supportingNetworkIds.add(KeyId.keyId(supportNw.networkRef().uri().string()));
        }
        teNetwork.setSupportingNetworkIds(supportingNetworkIds);
    }
    // Nodes
    if (yangNetwork.node() != null) {
        List<org.onosproject.tetopology.management.api.node.NetworkNode> teNodes = Lists.newArrayList();
        for (Node node : yangNetwork.node()) {
            // Convert the Yang Node to a TE node.
            teNodes.add(NodeConverter.yang2TeSubsystemNode(node, yangNetwork.networkId()));
        }
        teNetwork.setNodes(teNodes);
    }
    // Links
    if (yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class) != null) {
        AugmentedNdNetwork augmentLink = (AugmentedNdNetwork) yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class);
        List<org.onosproject.tetopology.management.api.link.NetworkLink> teLinks = Lists.newArrayList();
        for (Link link : augmentLink.link()) {
            // Convert the Yang Link to a TE link.
            teLinks.add(LinkConverter.yang2TeSubsystemLink(link, yangNetwork.networkId()));
        }
        teNetwork.setLinks(teLinks);
    }
    // TE Topology Ids
    if (yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class) != null) {
        AugmentedNwNetwork augmentTeIds = (AugmentedNwNetwork) yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class);
        org.onosproject.tetopology.management.api.TeTopologyId teTopologyId = new org.onosproject.tetopology.management.api.TeTopologyId(augmentTeIds.te().clientId().uint32(), augmentTeIds.te().providerId().uint32(), augmentTeIds.te().teTopologyId().string());
        teNetwork.setTeTopologyId(teTopologyId);
    }
    return teNetwork;
}
#method_after
private static org.onosproject.tetopology.management.api.DefaultNetwork yang2TeDefaultNetwork(Network yangNetwork) {
    checkNotNull(yangNetwork, E_NULL_YANG_NETWORK);
    checkNotNull(yangNetwork.networkId(), E_NULL_YANG_NETWORKID);
    String networkId = yangNetwork.networkId().uri().string();
    org.onosproject.tetopology.management.api.DefaultNetwork teNetwork = new org.onosproject.tetopology.management.api.DefaultNetwork(KeyId.keyId(networkId));
    // Supporting networks
    if (yangNetwork.supportingNetwork() != null) {
        List<KeyId> supportingNetworkIds = Lists.newArrayList();
        for (SupportingNetwork supportNw : yangNetwork.supportingNetwork()) {
            supportingNetworkIds.add(KeyId.keyId(supportNw.networkRef().uri().string()));
        }
        teNetwork.setSupportingNetworkIds(supportingNetworkIds);
    }
    // Nodes
    if (yangNetwork.node() != null) {
        List<org.onosproject.tetopology.management.api.node.NetworkNode> teNodes = Lists.newArrayList();
        for (Node node : yangNetwork.node()) {
            // Convert the Yang Node to a TE node.
            teNodes.add(NodeConverter.yang2TeSubsystemNode(node, yangNetwork.networkId()));
        }
        teNetwork.setNodes(teNodes);
    }
    // Links
    if (yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class) != null) {
        AugmentedNdNetwork augmentLink = (AugmentedNdNetwork) yangNetwork.yangAugmentedInfo(AugmentedNdNetwork.class);
        List<org.onosproject.tetopology.management.api.link.NetworkLink> teLinks = Lists.newArrayList();
        for (Link link : augmentLink.link()) {
            // Convert the Yang Link to a TE link.
            teLinks.add(LinkConverter.yang2TeSubsystemLink(link, yangNetwork.networkId()));
        }
        teNetwork.setLinks(teLinks);
    }
    // TE Topology Ids
    if (yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class) != null) {
        AugmentedNwNetwork augmentTeIds = (AugmentedNwNetwork) yangNetwork.yangAugmentedInfo(AugmentedNwNetwork.class);
        org.onosproject.tetopology.management.api.TeTopologyId teTopologyId = new org.onosproject.tetopology.management.api.TeTopologyId(augmentTeIds.te().clientId().uint32(), augmentTeIds.te().providerId().uint32(), augmentTeIds.te().teTopologyId().string());
        teNetwork.setTeTopologyId(teTopologyId);
    }
    return teNetwork;
}
#end_block

#method_before
public static org.onosproject.tetopology.management.api.Network yang2TeSubsystemNetwork(Network yangNetwork, org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network yangNetworkState) {
    org.onosproject.tetopology.management.api.DefaultNetwork teNetwork = yang2TeDefaultNetwork(yangNetwork);
    checkNotNull(yangNetworkState, "YANG NetworkState object cannot be null");
    checkNotNull(yangNetworkState.networkRef(), "YANG Networkref cannot be null");
    String networkref = yangNetworkState.networkRef().uri().string();
    checkState(teNetwork.networkId().toString().equals(networkref), "YANG networkId must be same in Network and NetworkState");
    teNetwork.setServerProvided(yangNetworkState.serverProvided());
    return teNetwork;
}
#method_after
public static org.onosproject.tetopology.management.api.Network yang2TeSubsystemNetwork(Network yangNetwork, org.onosproject.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.network.rev20151208.ietfnetwork.networksstate.Network yangNetworkState) {
    org.onosproject.tetopology.management.api.DefaultNetwork teNetwork = yang2TeDefaultNetwork(yangNetwork);
    checkNotNull(yangNetworkState, E_NULL_YANG_NETWORKSSTATE_NETWORK);
    checkNotNull(yangNetworkState.networkRef(), E_NULL_YANG_NETWORKSSTATE_NETWORKREF);
    String networkref = yangNetworkState.networkRef().uri().string();
    checkState(teNetwork.networkId().toString().equals(networkref), E_DIFF_YANG_NETWORKID);
    teNetwork.setServerProvided(yangNetworkState.serverProvided());
    return teNetwork;
}
#end_block

#method_before
private int getPriorityFromPrefix(IpPrefix prefix) {
    return (prefix.isIp4()) ? 2000 * prefix.prefixLength() + MIN_IP_PRIORITY : 500 * prefix.prefixLength() + MIN_IP_PRIORITY;
}
#method_after
private int getPriorityFromPrefix(IpPrefix prefix) {
    return (prefix.isIp4()) ? IPV4_PRIORITY * prefix.prefixLength() + MIN_IP_PRIORITY : IPV6_PRIORITY * prefix.prefixLength() + MIN_IP_PRIORITY;
}
#end_block

#method_before
private void updateConfig(NetworkConfigEvent event) {
    RouterConfig prevRouterConfig = (RouterConfig) event.prevConfig().get();
    List<String> prevInterfaces = prevRouterConfig.getInterfaces();
    Set<Interface> previntfs = filterInterfaces(prevInterfaces);
    if (previntfs.isEmpty() && !interfaces.isEmpty()) {
        interfaceService.getInterfaces().stream().filter(intf -> !interfaces.contains(intf)).forEach(intf -> processIntfFilter(false, intf));
        return;
    }
    // remove the filtering objective for the interfaces which are not
    // part of updated interfaces list.
    previntfs.stream().filter(intf -> !interfaces.contains(intf.name())).forEach(intf -> processIntfFilter(false, intf));
}
#method_after
private void updateConfig(NetworkConfigEvent event) {
    RouterConfig prevRouterConfig = (RouterConfig) event.prevConfig().get();
    List<String> prevInterfaces = prevRouterConfig.getInterfaces();
    Set<Interface> previntfs = filterInterfaces(prevInterfaces);
    if (previntfs.isEmpty() && !interfaces.isEmpty()) {
        interfaceService.getInterfaces().stream().filter(intf -> !interfaces.contains(intf.name())).forEach(intf -> processIntfFilter(false, intf));
        return;
    }
    // remove the filtering objective for the interfaces which are not
    // part of updated interfaces list.
    previntfs.stream().filter(intf -> !interfaces.contains(intf.name())).forEach(intf -> processIntfFilter(false, intf));
}
#end_block

#method_before
private void removeConfig() {
    Set<Interface> intfs = getInterfaces();
    if (!intfs.isEmpty()) {
        // processIntfFilters(false, intfs);
        intfs.stream().forEach(intf -> processIntfFilter(false, intf));
    }
    networkConfigService.removeConfig();
// networkConfigService.addListener(networkConfigListener);
}
#method_after
private void removeConfig() {
    Set<Interface> intfs = getInterfaces();
    if (!intfs.isEmpty()) {
        intfs.forEach(intf -> processIntfFilter(false, intf));
    }
    networkConfigService.removeConfig();
}
#end_block

#method_before
private Set<Interface> getInterfaces() {
    Set<Interface> intfs;
    if (interfaces.isEmpty()) {
        intfs = interfaceService.getInterfaces();
    } else {
        intfs = filterInterfaces(interfaces);
    }
    return intfs;
}
#method_after
private Set<Interface> getInterfaces() {
    return interfaces.isEmpty() ? interfaceService.getInterfaces() : filterInterfaces(interfaces);
}
#end_block

#method_before
@Override
public void event(InterfaceEvent event) {
    if (controlPlaneConnectPoint == null) {
        log.info("Control plane connect point is not configured. Abort InterfaceEvent.");
        return;
    }
    Interface intf = event.subject();
    Interface prevIntf = event.prevSubject();
    switch(event.type()) {
        case INTERFACE_ADDED:
            processIntfFilter(true, intf);
            // }
            break;
        case INTERFACE_UPDATED:
            if (intf != null && !intf.connectPoint().equals(controlPlaneConnectPoint)) {
                updateInterface(prevIntf, intf);
            }
            break;
        case INTERFACE_REMOVED:
            processIntfFilter(false, intf);
            // }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(InterfaceEvent event) {
    if (controlPlaneConnectPoint == null) {
        log.warn("Control plane connect point is not configured. Abort InterfaceEvent.");
        return;
    }
    Interface intf = event.subject();
    Interface prevIntf = event.prevSubject();
    switch(event.type()) {
        case INTERFACE_ADDED:
            processIntfFilter(true, intf);
            break;
        case INTERFACE_UPDATED:
            updateInterface(prevIntf, intf);
            break;
        case INTERFACE_REMOVED:
            processIntfFilter(false, intf);
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Activate
public void activate() {
    log.info("TE topology store is activated");
    networkIdNetworkConsistentMap = storageService.<KeyId, InternalTeNetwork>consistentMapBuilder().withSerializer(NETWORK_SERIALIZER).withName("networkId-network").withRelaxedReadConsistency().build();
    networkIdNetworkConsistentMap.addListener(networkMapListener);
    networkIdNetworkMap = networkIdNetworkConsistentMap.asJavaMap();
    /*
        DefaultNetwork network = NetworkUtils.buildNetwork(NetworkUtils.DEFAULT_NETWORK_ID,
                                                           NetworkUtils.DEFAULT_NODE1_ID,
                                                           NetworkUtils.DEFAULT_NODE2_ID,
                                                           NetworkUtils.DEFAULT_LINK_ID);
        updateNetwork(network);
*/
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    log.info("TE topology store is activated");
    networkIdNetworkConsistentMap = storageService.<KeyId, InternalTeNetwork>consistentMapBuilder().withSerializer(NETWORK_SERIALIZER).withName("networkId-network").withRelaxedReadConsistency().build();
    networkIdNetworkConsistentMap.addListener(networkMapListener);
    networkIdNetworkMap = networkIdNetworkConsistentMap.asJavaMap();
    log.info("Started");
}
#end_block

#method_before
@Override
public List<InternalTeNetwork> getNetworks(TeTopologyType type) {
    List<InternalTeNetwork> networks = new ArrayList<>();
    for (Map.Entry<KeyId, InternalTeNetwork> entry : networkIdNetworkMap.entrySet()) {
        KeyId networkId = entry.getKey();
        InternalTeNetwork network = entry.getValue();
        // if (network.getTeTopologyType() == type) {
        // networks.add(network);
        // }
        // return all networks for now.
        networks.add(network);
    }
    return networks;
}
#method_after
@Override
public List<InternalTeNetwork> getNetworks(TeTopologyType type) {
    List<InternalTeNetwork> networks = new ArrayList<>();
    for (Map.Entry<KeyId, InternalTeNetwork> entry : networkIdNetworkMap.entrySet()) {
        KeyId networkId = entry.getKey();
        InternalTeNetwork network = entry.getValue();
        if (network.getTeTopologyType() == type || type == TeTopologyType.ANY) {
            networks.add(network);
        }
    }
    return networks;
}
#end_block

#method_before
@Override
public void event(MapEvent<KeyId, InternalTeNetwork> event) {
    // KeyId networkId = checkNotNull(event.key());
    TeTopologyEvent.Type type = null;
    TeTopologyEvent topologyEvent = null;
    switch(event.type()) {
        case INSERT:
            type = TeTopologyEvent.Type.NETWORK_ADDED;
            // Need to check if nodes/links are already in, otherwise errors
            topologyEvent = new TeTopologyEvent(type, event.newValue().value());
            break;
        case UPDATE:
            // Need to check what attributes change, and coordinate with other Node/Link events.
            if ((event.oldValue().value() != null) && (event.newValue().value() == null)) {
                type = TeTopologyEvent.Type.NETWORK_REMOVED;
                topologyEvent = new TeTopologyEvent(type, event.oldValue().value());
            } else {
                type = TeTopologyEvent.Type.NETWORK_UPDATED;
                topologyEvent = new TeTopologyEvent(type, event.newValue().value());
            }
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.NETWORK_REMOVED;
            topologyEvent = new TeTopologyEvent(type, event.oldValue().value());
            break;
        default:
            log.error("Unsupported event type: " + event.type());
    }
    log.info("Event type {}, Event {}", type.toString(), topologyEvent);
    if (topologyEvent != null) {
        notifyDelegate(topologyEvent);
    }
}
#method_after
@Override
public void event(MapEvent<KeyId, InternalTeNetwork> event) {
    TeTopologyEvent.Type type = null;
    TeTopologyEvent topologyEvent = null;
    switch(event.type()) {
        case INSERT:
            type = TeTopologyEvent.Type.NETWORK_ADDED;
            // Need to check if nodes/links are already in, otherwise errors
            topologyEvent = new TeTopologyEvent(type, event.newValue().value());
            break;
        case UPDATE:
            // Need to check what attributes change, and coordinate with other Node/Link events.
            if ((event.oldValue().value() != null) && (event.newValue().value() == null)) {
                type = TeTopologyEvent.Type.NETWORK_REMOVED;
                topologyEvent = new TeTopologyEvent(type, event.oldValue().value());
            } else {
                type = TeTopologyEvent.Type.NETWORK_UPDATED;
                topologyEvent = new TeTopologyEvent(type, event.newValue().value());
            }
            break;
        case REMOVE:
            type = TeTopologyEvent.Type.NETWORK_REMOVED;
            topologyEvent = new TeTopologyEvent(type, event.oldValue().value());
            break;
        default:
            log.error("Unsupported event type: {}", event.type());
    }
    log.info("Event type {}, Event {}", type, topologyEvent);
    if (topologyEvent != null) {
        notifyDelegate(topologyEvent);
    }
}
#end_block

#method_before
@Activate
public void activate() {
    activateBasics();
    deviceProviderService = deviceProviderRegistry.register(this);
    linkProviderService = linkProviderRegistry.register(this);
    // TODO: Needs to add the event listener into LINK and Device subsystem
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    activateBasics();
    appId = coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgLister);
    deviceProviderService = deviceProviderRegistry.register(this);
    linkProviderService = linkProviderRegistry.register(this);
    // TODO: Needs to add the event listener into LINK and Device subsystem
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    deactivateBasics();
    deviceProviderRegistry.unregister(this);
    linkProviderRegistry.unregister(this);
    // TODO: Needs to remove the event listener from LINK and Device subsystem
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    deactivateBasics();
    cfgService.removeListener(cfgLister);
    cfgService.unregisterConfigFactory(factory);
    deviceProviderRegistry.unregister(this);
    linkProviderRegistry.unregister(this);
    // TODO: Needs to remove the event listener from LINK and Device subsystem
    log.info("Stopped");
}
#end_block

#method_before
@Override
public Network getNetwork(KeyId networkId) {
    return store.getNetwork(networkId);
}
#method_after
@Override
public Network getNetwork(KeyId networkId) {
    return new DefaultNetwork(store.getNetwork(networkId));
}
#end_block

#method_before
@Override
public void updateNetwork(Network network) {
    store.updateNetwork(new InternalTeNetwork(TeTopologyType.CONFIGURED, network));
// TODO: Need to update nodes and links to Device/Link subsystems.
}
#method_after
@Override
public void updateNetwork(Network network) {
    store.updateNetwork(new InternalTeNetwork(TeTopologyType.CONFIGURED, new DefaultNetwork(network)));
// TODO: Need to update nodes and links to Device/Link subsystems.
}
#end_block

#method_before
@Override
public void linkRemoved(NetworkLinkKey linkKey) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void linkRemoved(NetworkLinkKey linkKey) {
// No action is required (TODO: Auto-generated method stub)
}
#end_block

#method_before
@Override
public void nodeUpdated(NetworkNodeKey nodeKey, NetworkNode node) {
// Need to check if this is a new node
// TODO Auto-generated method stub
}
#method_after
@Override
public void nodeUpdated(NetworkNodeKey nodeKey, NetworkNode node) {
// Need to check if this is a new node
// No action is required (TODO: Auto-generated method stub)
}
#end_block

#method_before
@Override
public void nodeRemoved(NetworkNodeKey nodeKey) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void nodeRemoved(NetworkNodeKey nodeKey) {
// No action is required (TODO: Auto-generated method stub)
}
#end_block

#method_before
@Override
public void terminationPointUpdated(TerminationPointKey terminationPointKey, TerminationPoint terminationPoint) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void terminationPointUpdated(TerminationPointKey terminationPointKey, TerminationPoint terminationPoint) {
// No action is required (TODO: Auto-generated method stub)
}
#end_block

#method_before
@Override
public void terminationPointRemoved(TerminationPointKey terminationPointKey) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void terminationPointRemoved(TerminationPointKey terminationPointKey) {
// No action is required (TODO: Auto-generated method stub)
}
#end_block

#method_before
private void processEvent(TeTopologyEvent event) {
    log.info("ProcessEvent {}", event.type().toString());
    // TODO - partial merge when network is updated
    if (event.type() == TeTopologyEvent.Type.NETWORK_ADDED) {
    // mergeNetworks();
    }
    // TODO: Merge node and links from Device/Links subsytems if required.
    post(event);
}
#method_after
private void processEvent(TeTopologyEvent event) {
    log.info("ProcessEvent {}", event.type().toString());
    // TODO - partial merge when network is updated
    if (event.type() == TeTopologyEvent.Type.NETWORK_ADDED) {
    // move network merging to networkUpdated()
    // mergeNetworks();
    }
    // TODO: Merge node and links from Device/Links subsytems if required.
    post(event);
}
#end_block

#method_before
private void mergeNetworks() {
    /*
           * Merge all subordinate TE topologies, create a simple merged native topology
           * and store it in the topology store.
           */
    /* TODO - generate new id based on its provider id + network id */
    KeyId newNetworkId = KeyId.keyId(Long.toString(MY_PROVIDER_ID) + "-" + MY_TOPOLOGY_ID);
    store.removeNetwork(newNetworkId);
    /* create list of links, nodes and termination points */
    List<NetworkLink> allLinks = new ArrayList<>();
    List<NetworkNode> allNodes = new ArrayList<>();
    List<KeyId> allSupportingNetworkIds = new ArrayList<>();
    /* translate keys for links/nodes/tps */
    List<InternalTeNetwork> subordNetworks = store.getNetworks(TeTopologyType.SUBORDINATE);
    for (InternalTeNetwork network : subordNetworks) {
        allSupportingNetworkIds.add(network.networkId());
        /* create and add new nodes */
        List<NetworkNode> nodes = network.getNodes();
        for (NetworkNode node : nodes) {
            KeyId newNodeId = KeyId.keyId(MDSC_URI_PREFIX + node.nodeId().toString());
            TeNode newTeNode = null;
            if (node.getTe() != null) {
                newTeNode = new TeNode(node.getTe().teNodeId());
                newTeNode.setName(node.getTe().name());
                newTeNode.setAdminStatus(node.getTe().adminStatus());
                newTeNode.setOpStatus(node.getTe().opStatus());
                newTeNode.setAbstract(node.getTe().isAbstract());
                List<ConnectivityMatrix> newConnMatrices = new ArrayList<>();
                for (ConnectivityMatrix conn : node.getTe().connectivityMatrices()) {
                    KeyId tpId = conn.from().tpId();
                    KeyId newFromTpId = KeyId.keyId(MDSC_URI_PREFIX + tpId.toString());
                    TerminationPointKey newFrom = new TerminationPointKey(newNetworkId, newNodeId, newFromTpId);
                    tpId = conn.to().tpId();
                    KeyId newToTpId = KeyId.keyId(MDSC_URI_PREFIX + tpId.toString());
                    TerminationPointKey newTo = new TerminationPointKey(newNetworkId, newNodeId, newToTpId);
                    ConnectivityMatrix newConnMatrix = new ConnectivityMatrix(conn.id(), newFrom, newTo, conn.isAllowed());
                    newConnMatrices.add(newConnMatrix);
                }
                newTeNode.setConnectivityMatrices(newConnMatrices);
                newTeNode.setUnderlayTopology(node.getTe().underlayTopology());
                newTeNode.setTunnelTerminationPoints(node.getTe().tunnelTerminationPoints());
            }
            List<NetworkNodeKey> supportingNodes = Lists.newArrayList();
            supportingNodes.add(new NetworkNodeKey(network.networkId(), node.nodeId()));
            DefaultNetworkNode newNode = new DefaultNetworkNode(newNodeId, supportingNodes, newTeNode);
            List<TerminationPoint> newTps = Lists.newArrayList();
            for (TerminationPoint tp : node.getTerminationPoints()) {
                DefaultTerminationPoint newTp = new DefaultTerminationPoint(KeyId.keyId(MDSC_URI_PREFIX + tp.id().toString()));
                List<TerminationPointKey> supportTps = Lists.newArrayList();
                supportTps.add(new TerminationPointKey(network.networkId(), node.nodeId(), tp.id()));
                newTp.setSupportingTpIds(supportTps);
                newTps.add(newTp);
            }
            newNode.setTerminationPoints(newTps);
            allNodes.add(newNode);
        }
        /* create and add new links */
        List<NetworkLink> links = network.getLinks();
        for (NetworkLink link : links) {
            KeyId newLinkId = KeyId.keyId(MDSC_URI_PREFIX + link.linkId().toString());
            KeyId k = link.getSource().nodeId();
            KeyId newSourceNodeId = KeyId.keyId(MDSC_URI_PREFIX + k.toString());
            k = link.getSource().tpId();
            KeyId newSourceNodeTpId = KeyId.keyId(MDSC_URI_PREFIX + k.toString());
            k = link.getDestination().nodeId();
            KeyId newDestNodeId = KeyId.keyId(MDSC_URI_PREFIX + k.toString());
            k = link.getDestination().tpId();
            KeyId newDestNodeTpId = KeyId.keyId(MDSC_URI_PREFIX + k.toString());
            TerminationPointKey newSourceNodeTp = new TerminationPointKey(newNetworkId, newSourceNodeId, newSourceNodeTpId);
            TerminationPointKey newDestNodeTp = new TerminationPointKey(newNetworkId, newDestNodeId, newDestNodeTpId);
            DefaultNetworkLink newLink = new DefaultNetworkLink(newLinkId);
            newLink.setSource(newSourceNodeTp);
            newLink.setDestination(newDestNodeTp);
            List<NetworkLinkKey> supportLinks = Lists.newArrayList();
            supportLinks.add(new NetworkLinkKey(network.networkId(), link.linkId()));
            newLink.setSupportingLinkIds(supportLinks);
            newLink.setTe(link.getTe());
            allLinks.add(newLink);
        }
    }
    /* save generated native TE network into the store */
    if (allNodes.size() > 0) {
        TeTopologyId newTopoId = new TeTopologyId(MY_PROVIDER_ID, 0L, MY_TOPOLOGY_ID);
        DefaultNetwork nativeDefaultNetwork = new DefaultNetwork(newNetworkId, allSupportingNetworkIds, allNodes, allLinks, newTopoId, true);
        InternalTeNetwork newTeNetwork = new InternalTeNetwork(TeTopologyType.NATIVE, nativeDefaultNetwork);
        store.updateNetwork(newTeNetwork);
    }
// if (networks.size() < 2) {
// No need to merge if there is less than two networks
// return;
// }
// DefaultNetwork nativeNetwork;
// if (store.nativeNetwork() == null) {
// // Never merged before
// nativeNetwork = new DefaultNetwork(KeyId.keyId(MDSC_NATIVE_NETWORK_ID));
// }
// else {
// nativeNetwork = (DefaultNetwork)store.nativeNetwork();
// }
// 
// List<KeyId> nativeNodeIds = Lists.newArrayList();
// List<KeyId> nativeLinkIds = Lists.newArrayList();
// List<KeyId> supportingNetworkIds = Lists.newArrayList();
// 
// for (Network network:networks) {
// //Build list of nodes
// for (KeyId nodeId:network.nodeIds()) {
// KeyId newNodeId = KeyId.keyId(nodeId.toString().replace(PNC_4MERGE, MDSC_NATIVE));
// nativeNodeIds.add(newNodeId);
// //Construct a new node instance and update them in the Device subsystem
// }
// //Build list of links
// for (KeyId linkId:network.linkIds()) {
// KeyId newLinkId = KeyId.keyId(linkId.toString().replace(PNC_4MERGE, MDSC_NATIVE));
// nativeLinkIds.add(newLinkId);
// //Construct a new link instance and update them in the Link subsystem
// }
// supportingNetworkIds.add(network.networkId());
// }
// nativeNetwork.setNodeIds(nativeNodeIds);
// nativeNetwork.setLinkIds(nativeLinkIds);
// nativeNetwork.setSupportingNetworkIds(supportingNetworkIds);
// nativeNetwork.setServerProvided(true);
// nativeNetwork.setTeTopologyId(MDSC_NATIVE_NETWORK_ID);
// 
// //Update the native network in Store
// store.updateNetwork(nativeNetwork);
}
#method_after
private void mergeNetworks() {
    /*
           * Merge all subordinate TE topologies, create a simple merged native topology
           * and store it in the topology store.
           */
    /* TODO - generate new id based on its provider id + network id */
    KeyId newNetworkId = KeyId.keyId(Long.toString(teTopologyId.providerId()) + "-" + teTopologyId.topologyId());
    store.removeNetwork(newNetworkId);
    /* create list of links, nodes and termination points */
    List<NetworkLink> allLinks = new ArrayList<>();
    List<NetworkNode> allNodes = new ArrayList<>();
    List<KeyId> allSupportingNetworkIds = new ArrayList<>();
    /* translate keys for links/nodes/tps */
    List<InternalTeNetwork> subordNetworks = store.getNetworks(TeTopologyType.SUBORDINATE);
    for (InternalTeNetwork network : subordNetworks) {
        allSupportingNetworkIds.add(network.networkId());
        /* create and add new nodes */
        List<NetworkNode> nodes = network.getNodes();
        for (NetworkNode node : nodes) {
            KeyId newNodeId = KeyId.keyId(MDSC_URI_PREFIX + node.nodeId());
            TeNode newTeNode = null;
            TeNode origTeNode = node.getTe();
            if (origTeNode != null) {
                newTeNode = new TeNode(origTeNode.teNodeId());
                newTeNode.setName(origTeNode.name());
                newTeNode.setAdminStatus(origTeNode.adminStatus());
                newTeNode.setOpStatus(origTeNode.opStatus());
                newTeNode.setAbstract(origTeNode.isAbstract());
                List<ConnectivityMatrix> newConnMatrices = new ArrayList<>();
                for (ConnectivityMatrix conn : origTeNode.connectivityMatrices()) {
                    KeyId tpId = conn.from().tpId();
                    KeyId newFromTpId = KeyId.keyId(MDSC_URI_PREFIX + tpId);
                    TerminationPointKey newFrom = new TerminationPointKey(newNetworkId, newNodeId, newFromTpId);
                    tpId = conn.to().tpId();
                    KeyId newToTpId = KeyId.keyId(MDSC_URI_PREFIX + tpId);
                    TerminationPointKey newTo = new TerminationPointKey(newNetworkId, newNodeId, newToTpId);
                    ConnectivityMatrix newConnMatrix = new ConnectivityMatrix(conn.id(), newFrom, newTo, conn.isAllowed());
                    newConnMatrices.add(newConnMatrix);
                }
                newTeNode.setConnectivityMatrices(newConnMatrices);
                newTeNode.setUnderlayTopology(origTeNode.underlayTopology());
                newTeNode.setTunnelTerminationPoints(origTeNode.tunnelTerminationPoints());
            }
            List<NetworkNodeKey> supportingNodes = Lists.newArrayList();
            supportingNodes.add(new NetworkNodeKey(network.networkId(), node.nodeId()));
            DefaultNetworkNode newNode = new DefaultNetworkNode(newNodeId, supportingNodes, newTeNode);
            List<TerminationPoint> newTps = Lists.newArrayList();
            List<TerminationPoint> origTps = node.getTerminationPoints();
            if (nonEmpty(origTps)) {
                for (TerminationPoint tp : origTps) {
                    DefaultTerminationPoint newTp = new DefaultTerminationPoint(KeyId.keyId(MDSC_URI_PREFIX + tp.id()));
                    List<TerminationPointKey> supportTps = Lists.newArrayList();
                    supportTps.add(new TerminationPointKey(network.networkId(), node.nodeId(), tp.id()));
                    newTp.setSupportingTpIds(supportTps);
                    newTps.add(newTp);
                }
            }
            newNode.setTerminationPoints(newTps);
            allNodes.add(newNode);
        }
        /* create and add new links */
        List<NetworkLink> links = network.getLinks();
        if (nonEmpty(links)) {
            for (NetworkLink link : links) {
                KeyId newLinkId = KeyId.keyId(MDSC_URI_PREFIX + link.linkId());
                KeyId k = link.getSource().nodeId();
                KeyId newSourceNodeId = KeyId.keyId(MDSC_URI_PREFIX + k);
                k = link.getSource().tpId();
                KeyId newSourceNodeTpId = KeyId.keyId(MDSC_URI_PREFIX + k);
                k = link.getDestination().nodeId();
                KeyId newDestNodeId = KeyId.keyId(MDSC_URI_PREFIX + k);
                k = link.getDestination().tpId();
                KeyId newDestNodeTpId = KeyId.keyId(MDSC_URI_PREFIX + k);
                TerminationPointKey newSourceNodeTp = new TerminationPointKey(newNetworkId, newSourceNodeId, newSourceNodeTpId);
                TerminationPointKey newDestNodeTp = new TerminationPointKey(newNetworkId, newDestNodeId, newDestNodeTpId);
                DefaultNetworkLink newLink = new DefaultNetworkLink(newLinkId);
                newLink.setSource(newSourceNodeTp);
                newLink.setDestination(newDestNodeTp);
                List<NetworkLinkKey> supportLinks = Lists.newArrayList();
                supportLinks.add(new NetworkLinkKey(network.networkId(), link.linkId()));
                newLink.setSupportingLinkIds(supportLinks);
                newLink.setTe(link.getTe());
                allLinks.add(newLink);
            }
        }
    }
    /* save generated native TE network into the store */
    if (allNodes.size() > 0) {
        // TeTopologyId newTopoId = new TeTopologyId(MY_PROVIDER_ID, 0L, NATIVE_TOPOLOGY_ID);
        DefaultNetwork nativeDefaultNetwork = new DefaultNetwork(newNetworkId, allSupportingNetworkIds, allNodes, allLinks, teTopologyId, true);
        InternalTeNetwork newTeNetwork = new InternalTeNetwork(TeTopologyType.NATIVE, nativeDefaultNetwork);
        store.updateNetwork(newTeNetwork);
    }
}
#end_block

#method_before
public Integer getAsNumber() {
    return asNumber;
}
#method_after
public int getAsNumber() {
    return asNumber;
}
#end_block

#method_before
public Long id() {
    return id;
}
#method_after
public long id() {
    return id;
}
#end_block

#method_before
public Boolean isAllowed() {
    return isAllowed;
}
#method_after
public boolean isAllowed() {
    return isAllowed;
}
#end_block

#method_before
public void setIsAllowed(Boolean isAllowed) {
    this.isAllowed = isAllowed;
}
#method_after
public void setIsAllowed(boolean isAllowed) {
    this.isAllowed = isAllowed;
}
#end_block

#method_before
public void setAbstract(Boolean isAbstract) {
    this.isAbstract = isAbstract;
}
#method_after
public void setAbstract(boolean isAbstract) {
    this.isAbstract = isAbstract;
}
#end_block

#method_before
public void setUnderlayTopology(TeNetworkTopologyId underlayTopology) {
    this.underlayTopology = underlayTopology;
}
#method_after
public void setUnderlayTopology(TeNetworkTopologyId topo) {
    this.underlayTopology = topo;
}
#end_block

#method_before
public void setTunnelTerminationPoints(List<TunnelTerminationPoint> tunnelTerminationPoints) {
    this.tunnelTerminationPoints = tunnelTerminationPoints;
}
#method_after
public void setTunnelTerminationPoints(List<TunnelTerminationPoint> ttps) {
    this.tunnelTerminationPoints = ttps;
}
#end_block

#method_before
public Boolean isAbstract() {
    return isAbstract;
}
#method_after
public boolean isAbstract() {
    return isAbstract;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(teNodeId, name, adminStatus, opStatus, isAbstract, matrix, underlayTopology, tunnelTerminationPoints);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(teNodeId, name, adminStatus, opStatus, isAbstract, connMatrices, underlayTopology, tunnelTerminationPoints);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeNode) {
        TeNode that = (TeNode) object;
        return Objects.equal(this.teNodeId, that.teNodeId) && Objects.equal(this.name, that.name) && Objects.equal(this.adminStatus, that.adminStatus) && Objects.equal(this.opStatus, that.opStatus) && Objects.equal(this.isAbstract, that.isAbstract) && Objects.equal(this.matrix, that.matrix) && Objects.equal(this.underlayTopology, that.underlayTopology) && Objects.equal(this.tunnelTerminationPoints, that.tunnelTerminationPoints);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeNode) {
        TeNode that = (TeNode) object;
        return Objects.equal(this.teNodeId, that.teNodeId) && Objects.equal(this.name, that.name) && Objects.equal(this.adminStatus, that.adminStatus) && Objects.equal(this.opStatus, that.opStatus) && Objects.equal(this.isAbstract, that.isAbstract) && Objects.equal(this.connMatrices, that.connMatrices) && Objects.equal(this.underlayTopology, that.underlayTopology) && Objects.equal(this.tunnelTerminationPoints, that.tunnelTerminationPoints);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("teNodeId", teNodeId).add("name", name).add("adminStatus", adminStatus).add("opStatus", opStatus).add("isAbstract", isAbstract).add("matrix", matrix).add("underlayTopology", underlayTopology).add("tunnelTerminationPoints", tunnelTerminationPoints).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("teNodeId", teNodeId).add("name", name).add("adminStatus", adminStatus).add("opStatus", opStatus).add("isAbstract", isAbstract).add("connMatrices", connMatrices).add("underlayTopology", underlayTopology).add("tunnelTerminationPoints", tunnelTerminationPoints).toString();
}
#end_block

#method_before
public void setIndex(Long index) {
    this.index = index;
}
#method_after
public void setIndex(long index) {
    this.index = index;
}
#end_block

#method_before
public Long index() {
    return index;
}
#method_after
public long index() {
    return index;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(index, ref, pathElements);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(super.hashCode(), index);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof UnderlayBackupPath) {
        UnderlayBackupPath other = (UnderlayBackupPath) obj;
        return Objects.equals(index, other.index) && Objects.equals(ref, other.ref) && Objects.equals(pathElements, other.pathElements);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof UnderlayBackupPath) {
        if (!super.equals(obj)) {
            return false;
        }
        UnderlayBackupPath that = (UnderlayBackupPath) obj;
        return this.index == that.index;
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("index", index).add("ref", ref).add("pathElements", pathElements).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("index", index).add("ref", ref()).add("pathElements", pathElements()).toString();
}
#end_block

#method_before
public void setSwitchingCapabilities(List<InterfaceSwitchingCapability> switchingCapabilities) {
    this.switchingCapabilities = switchingCapabilities;
}
#method_after
public void setSwitchingCapabilities(List<InterfaceSwitchingCapability> swcaps) {
    this.switchingCapabilities = swcaps;
}
#end_block

#method_before
public void setInterLayerLockId(Long interLayerLockId) {
    this.interLayerLockId = interLayerLockId;
}
#method_after
public void setInterLayerLockId(long id) {
    this.interLayerLockId = id;
}
#end_block

#method_before
public Long getInterLayerLockId() {
    return interLayerLockId;
}
#method_after
public long getInterLayerLockId() {
    return interLayerLockId;
}
#end_block

#method_before
public void setLinkProtectionType(LinkProtectionType linkProtectionType) {
    this.linkProtectionType = linkProtectionType;
}
#method_after
public void setLinkProtectionType(LinkProtectionType type) {
    this.linkProtectionType = type;
}
#end_block

#method_before
public void setMaxLinkBandwidth(BigDecimal maxLinkBandwidth) {
    this.maxLinkBandwidth = maxLinkBandwidth;
}
#method_after
public void setMaxLinkBandwidth(BigDecimal bw) {
    this.maxLinkBandwidth = bw;
}
#end_block

#method_before
public void setMaxResvLinkBandwidth(BigDecimal maxResvLinkBandwidth) {
    this.maxResvLinkBandwidth = maxResvLinkBandwidth;
}
#method_after
public void setMaxResvLinkBandwidth(BigDecimal bw) {
    this.maxResvLinkBandwidth = bw;
}
#end_block

#method_before
public void setUnreservedBandwidths(List<UnreservedBandwidth> unreservedBandwidths) {
    this.unreservedBandwidths = unreservedBandwidths;
}
#method_after
public void setUnreservedBandwidths(List<UnreservedBandwidth> bwList) {
    this.unreservedBandwidths = bwList;
}
#end_block

#method_before
public void setTeDefaultMetric(Long teDefaultMetric) {
    this.teDefaultMetric = teDefaultMetric;
}
#method_after
public void setTeDefaultMetric(long metric) {
    this.teDefaultMetric = metric;
}
#end_block

#method_before
public void setExternalDomain(ExternalDomain externalDomain) {
    this.externalDomain = externalDomain;
}
#method_after
public void setExternalDomain(ExternalDomain extDomain) {
    this.externalDomain = extDomain;
}
#end_block

#method_before
public void setIsAbstract(Boolean isAbstract) {
    this.isAbstract = isAbstract;
}
#method_after
public void setIsAbstract(boolean isAbstract) {
    this.isAbstract = isAbstract;
}
#end_block

#method_before
public Long teDefaultMetric() {
    return teDefaultMetric;
}
#method_after
public long teDefaultMetric() {
    return teDefaultMetric;
}
#end_block

#method_before
public Boolean isAbstract() {
    return isAbstract;
}
#method_after
public boolean isAbstract() {
    return isAbstract;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(linkIndex, name, adminStatus, opStatus, accessType, linkProtectionType, maxLinkBandwidth, maxResvLinkBandwidth, unreservedBandwidths, teDefaultMetric, externalDomain, teSrlgs, isAbstract, underlay);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(linkIndex, name, adminStatus, opStatus, accessType, linkProtectionType, maxLinkBandwidth, maxResvLinkBandwidth, unreservedBandwidths, teDefaultMetric, externalDomain, teSrlgs, isAbstract, underlayPath);
}
#end_block

#method_before
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLink) {
        TeLink that = (TeLink) object;
        return Objects.equal(this.linkIndex, that.linkIndex) && Objects.equal(this.name, that.name) && Objects.equal(this.adminStatus, that.adminStatus) && Objects.equal(this.opStatus, that.opStatus) && Objects.equal(this.accessType, that.accessType) && Objects.equal(this.linkProtectionType, that.linkProtectionType) && Objects.equal(this.maxLinkBandwidth, that.maxLinkBandwidth) && Objects.equal(this.maxResvLinkBandwidth, that.maxResvLinkBandwidth) && Objects.equal(this.unreservedBandwidths, that.unreservedBandwidths) && Objects.equal(this.teDefaultMetric, that.teDefaultMetric) && Objects.equal(this.externalDomain, that.externalDomain) && Objects.equal(this.teSrlgs, that.teSrlgs) && Objects.equal(this.isAbstract, that.isAbstract) && Objects.equal(this.underlay, that.underlay);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object object) {
    if (this == object) {
        return true;
    }
    if (object instanceof TeLink) {
        TeLink that = (TeLink) object;
        return Objects.equal(this.linkIndex, that.linkIndex) && Objects.equal(this.name, that.name) && Objects.equal(this.adminStatus, that.adminStatus) && Objects.equal(this.opStatus, that.opStatus) && Objects.equal(this.accessType, that.accessType) && Objects.equal(this.linkProtectionType, that.linkProtectionType) && Objects.equal(this.maxLinkBandwidth, that.maxLinkBandwidth) && Objects.equal(this.maxResvLinkBandwidth, that.maxResvLinkBandwidth) && Objects.equal(this.unreservedBandwidths, that.unreservedBandwidths) && Objects.equal(this.teDefaultMetric, that.teDefaultMetric) && Objects.equal(this.externalDomain, that.externalDomain) && Objects.equal(this.teSrlgs, that.teSrlgs) && Objects.equal(this.isAbstract, that.isAbstract) && Objects.equal(this.underlayPath, that.underlayPath);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("linkIndex", linkIndex).add("name", name).add("adminStatus", adminStatus).add("opStatus", opStatus).add("accessType", accessType).add("linkProtectionType", linkProtectionType).add("maxLinkBandwidth", maxLinkBandwidth).add("maxResvLinkBandwidth", maxResvLinkBandwidth).add("unreservedBandwidths", unreservedBandwidths).add("teDefaultMetric", teDefaultMetric).add("externalDomain", externalDomain).add("teSrlgs", teSrlgs).add("isAbstract", isAbstract).add("underlay", underlay).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("linkIndex", linkIndex).add("name", name).add("adminStatus", adminStatus).add("opStatus", opStatus).add("accessType", accessType).add("linkProtectionType", linkProtectionType).add("maxLinkBandwidth", maxLinkBandwidth).add("maxResvLinkBandwidth", maxResvLinkBandwidth).add("unreservedBandwidths", unreservedBandwidths).add("teDefaultMetric", teDefaultMetric).add("externalDomain", externalDomain).add("teSrlgs", teSrlgs).add("isAbstract", isAbstract).add("underlayPath", underlayPath).toString();
}
#end_block

#method_before
public Short priority() {
    return priority;
}
#method_after
public short priority() {
    return priority;
}
#end_block

#method_before
public void setNodes(List<Node> nodes) {
    this.nodes = nodes;
}
#method_after
public void setNodes(List<NetworkNode> nodes) {
    this.nodes = nodes;
}
#end_block

#method_before
public void setLinks(List<Link> links) {
    this.links = links;
}
#method_after
public void setLinks(List<NetworkLink> links) {
    this.links = links;
}
#end_block

#method_before
public void setServerProvided(Boolean serverProvided) {
    this.serverProvided = serverProvided;
}
#method_after
public void setServerProvided(boolean serverProvided) {
    this.serverProvided = serverProvided;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(networkId, supportingNetworkIds, nodes, links, teTopologyId);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(networkId, supportingNetworkIds, nodes, links, serverProvided, teTopologyId);
}
#end_block

#method_before
public Long getInterLayerLockId() {
    return interLayerLockId;
}
#method_after
public long getInterLayerLockId() {
    return interLayerLockId;
}
#end_block

#method_before
public void setInterLayerLockId(Long interLayerLockId) {
    this.interLayerLockId = interLayerLockId;
}
#method_after
public void setInterLayerLockId(long interLayerLockId) {
    this.interLayerLockId = interLayerLockId;
}
#end_block

#method_before
public Long label() {
    return value;
}
#method_after
public long label() {
    return value;
}
#end_block

#method_before
public Long providerId() {
    return providerId;
}
#method_after
public long providerId() {
    return providerId;
}
#end_block

#method_before
public Long clientId() {
    return clientId;
}
#method_after
public long clientId() {
    return clientId;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof KeyId) {
        final KeyId that = (KeyId) obj;
        return this.getClass() == that.getClass() && Objects.equals(this.str, that.str);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof KeyId) {
        KeyId that = (KeyId) obj;
        return this.getClass() == that.getClass() && Objects.equals(this.str, that.str);
    }
    return false;
}
#end_block

#method_before
public void setSupportingTpIds(List<TerminationPointKey> supportingTpIds) {
    this.supportingTpIds = supportingTpIds;
}
#method_after
public void setSupportingTpIds(List<TerminationPointKey> tps) {
    this.supportingTpIds = tps;
}
#end_block

#method_before
public Long plugId() {
    return plugId;
}
#method_after
public long plugId() {
    return plugId;
}
#end_block

#method_before
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    ConnectPoint egressPort = egressInterface.connectPoint();
    Set<ConnectPoint> ingressPorts = Sets.newHashSet();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    Map<ConnectPoint, TrafficSelector> selectors = Maps.newHashMap();
    // TODO this should be only peering interfaces
    interfaceService.getInterfaces().stream().filter(intf -> !intf.equals(egressInterface)).filter(intf -> !intf.connectPoint().equals(egressPort)).forEach(intf -> {
        ingressPorts.add(intf.connectPoint());
        TrafficSelector.Builder selector = buildTrafficSelector(intf, prefix);
        ConnectPoint ingressPort = intf.connectPoint();
        selectors.put(ingressPort, selector.build());
    });
    // Rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    // Set egress VLAN Id
    VlanId egressVlanId = egressInterface.vlan();
    if (egressVlanId.equals(VlanId.NONE)) {
        treatment.popVlan();
    } else {
        treatment.setVlanId(egressVlanId);
    }
    // Set priority
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    // Set key
    Key key = Key.of(prefix.toString(), appId);
    return MultiPointToSinglePointIntent.builder().appId(appId).key(key).selectors(selectors).treatment(treatment.build()).ingressPoints(ingressPorts).egressPoint(egressPort).priority(priority).constraints(CONSTRAINTS).build();
}
#method_after
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    ConnectPoint egressPort = egressInterface.connectPoint();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    Set<FilteredConnectPoint> ingressFilteredCPs = Sets.newHashSet();
    // TODO this should be only peering interfaces
    interfaceService.getInterfaces().stream().forEach(intf -> {
        // Get ony ingress interfaces with IPs configured
        if (validIngressIntf(intf, egressInterface)) {
            TrafficSelector.Builder selector = buildIngressTrafficSelector(intf, prefix);
            FilteredConnectPoint ingressFilteredCP = new FilteredConnectPoint(intf.connectPoint(), selector.build());
            ingressFilteredCPs.add(ingressFilteredCP);
        }
    });
    // Build treatment: rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    // Build the egress selector for VLAN Id
    TrafficSelector.Builder selector = buildTrafficSelector(egressInterface);
    FilteredConnectPoint egressFilteredCP = new FilteredConnectPoint(egressPort, selector.build());
    // Set priority
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    // Set key
    Key key = Key.of(prefix.toString(), appId);
    return MultiPointToSinglePointIntent.builder().appId(appId).key(key).filteredIngressPoints(ingressFilteredCPs).filteredEgressPoint(egressFilteredCP).treatment(treatment.build()).priority(priority).constraints(CONSTRAINTS).build();
}
#end_block

#method_before
private void addInterface(Interface intf) {
    synchronized (this) {
        for (Map.Entry<IpPrefix, MultiPointToSinglePointIntent> entry : routeIntents.entrySet()) {
            // Retrieve the IP prefix and affected intent
            IpPrefix prefix = entry.getKey();
            MultiPointToSinglePointIntent intent = entry.getValue();
            // Add new ingress point
            Set<ConnectPoint> ingress = Sets.newHashSet(intent.ingressPoints());
            ingress.add(intf.connectPoint());
            // Add new traffic selector builder
            Map<ConnectPoint, TrafficSelector> selectors = Maps.newHashMap(intent.ingressSelectors());
            TrafficSelector.Builder selector = buildTrafficSelector(intf, prefix);
            selectors.put(intf.connectPoint(), selector.build());
            // Create new intent
            MultiPointToSinglePointIntent newIntent = MultiPointToSinglePointIntent.builder(intent).ingressPoints(ingress).build();
            routeIntents.put(entry.getKey(), newIntent);
            intentSynchronizer.submit(newIntent);
        }
    }
}
#method_after
private void addInterface(Interface intf) {
    synchronized (this) {
        for (Map.Entry<IpPrefix, MultiPointToSinglePointIntent> entry : routeIntents.entrySet()) {
            // Retrieve the IP prefix and affected intent
            IpPrefix prefix = entry.getKey();
            MultiPointToSinglePointIntent intent = entry.getValue();
            // Add new ingress FilteredConnectPoint
            Set<FilteredConnectPoint> ingressFilteredCPs = Sets.newHashSet(intent.filteredIngressPoints());
            // Create the new traffic selector
            TrafficSelector.Builder selector = buildIngressTrafficSelector(intf, prefix);
            // Create the Filtered ConnectPoint and add it to the existing set
            FilteredConnectPoint newIngressFilteredCP = new FilteredConnectPoint(intf.connectPoint(), selector.build());
            ingressFilteredCPs.add(newIngressFilteredCP);
            // Create new intent
            MultiPointToSinglePointIntent newIntent = MultiPointToSinglePointIntent.builder(intent).filteredIngressPoints(ingressFilteredCPs).build();
            routeIntents.put(entry.getKey(), newIntent);
            intentSynchronizer.submit(newIntent);
        }
    }
}
#end_block

#method_before
private void removeInterface(Interface intf) {
    synchronized (this) {
        for (Map.Entry<IpPrefix, MultiPointToSinglePointIntent> entry : routeIntents.entrySet()) {
            // Retrieve the IP prefix and affected intent
            IpPrefix prefix = entry.getKey();
            MultiPointToSinglePointIntent intent = entry.getValue();
            // The intergace is an egress interface for the intent
            if (intent.egressPoint().equals(intf.connectPoint())) {
                // This intent just lost its head. Remove it and let
                // higher layer routing reroute.
                intentSynchronizer.withdraw(routeIntents.remove(entry.getKey()));
            } else {
                // The interface is one of the ingress interfaces for the intent.
                if (intent.ingressPoints().contains(intf.connectPoint())) {
                    // Remove ingress point
                    Set<ConnectPoint> ingress = Sets.newHashSet(intent.ingressPoints());
                    ingress.remove(intf.connectPoint());
                    // Remove traffic selector builder
                    Map<ConnectPoint, TrafficSelector> selectors = Maps.newHashMap(intent.ingressSelectors());
                    TrafficSelector.Builder selector = buildTrafficSelector(intf, prefix);
                    selectors.remove(intf.connectPoint(), selector.build());
                    // Create new intent
                    MultiPointToSinglePointIntent newIntent = MultiPointToSinglePointIntent.builder(intent).ingressPoints(ingress).build();
                    routeIntents.put(entry.getKey(), newIntent);
                    intentSynchronizer.submit(newIntent);
                }
            }
        }
    }
}
#method_after
private void removeInterface(Interface intf) {
    synchronized (this) {
        for (Map.Entry<IpPrefix, MultiPointToSinglePointIntent> entry : routeIntents.entrySet()) {
            // Retrieve the IP prefix and intent possibly affected
            IpPrefix prefix = entry.getKey();
            MultiPointToSinglePointIntent intent = entry.getValue();
            // The interface removed might be an ingress interface, so the
            // selector needs to match on the interface tagging params and
            // on the prefix
            TrafficSelector.Builder ingressSelector = buildIngressTrafficSelector(intf, prefix);
            FilteredConnectPoint removedIngressFilteredCP = new FilteredConnectPoint(intf.connectPoint(), ingressSelector.build());
            // The interface removed might be an egress interface, so the
            // selector needs to match only on the interface tagging params
            TrafficSelector.Builder selector = buildTrafficSelector(intf);
            FilteredConnectPoint removedEgressFilteredCP = new FilteredConnectPoint(intf.connectPoint(), selector.build());
            if (intent.filteredEgressPoint().equals(removedEgressFilteredCP)) {
                // The interface is an egress interface for the intent.
                // This intent just lost its head. Remove it and let higher
                // layer routing reroute
                intentSynchronizer.withdraw(routeIntents.remove(entry.getKey()));
            } else {
                if (intent.filteredIngressPoints().contains(removedIngressFilteredCP)) {
                    // The FilteredConnectPoint is an ingress
                    // FilteredConnectPoint for the intent
                    Set<FilteredConnectPoint> ingressFilteredCPs = Sets.newHashSet(intent.filteredIngressPoints());
                    // Remove FilteredConnectPoint from the existing set
                    ingressFilteredCPs.remove(removedIngressFilteredCP);
                    if (!ingressFilteredCPs.isEmpty()) {
                        // There are still ingress points. Create a new
                        // intent and resubmit
                        MultiPointToSinglePointIntent newIntent = MultiPointToSinglePointIntent.builder(intent).filteredIngressPoints(ingressFilteredCPs).build();
                        routeIntents.put(entry.getKey(), newIntent);
                        intentSynchronizer.submit(newIntent);
                    } else {
                        // No more ingress FilteredConnectPoint. Withdraw
                        // the intent
                        intentSynchronizer.withdraw(routeIntents.remove(entry.getKey()));
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private TrafficSelector.Builder buildTrafficSelector(Interface intf, IpPrefix prefix) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    // Match the VlanId if specified in the network interface configuration
    VlanId ingressVlanId = intf.vlan();
    if (!ingressVlanId.equals(VlanId.NONE)) {
        selector.matchVlanId(ingressVlanId);
    }
    // Match the destination IP prefix at the first hop
    if (prefix.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPDst(prefix);
        }
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPv6Dst(prefix);
        }
    }
    return selector;
}
#method_after
private TrafficSelector.Builder buildTrafficSelector(Interface intf) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    // TODO: Consider other tag types
    // Match the VlanId if specified in the network interface configuration
    VlanId vlanId = intf.vlan();
    if (!vlanId.equals(VlanId.NONE)) {
        selector.matchVlanId(vlanId);
    }
    return selector;
}
#end_block

#method_before
@Override
public void event(InterfaceEvent event) {
    switch(event.type()) {
        case INTERFACE_ADDED:
            addInterface(event.subject());
            break;
        case INTERFACE_UPDATED:
            removeInterface(event.subject());
            addInterface(event.subject());
            break;
        case INTERFACE_REMOVED:
            removeInterface(event.subject());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(InterfaceEvent event) {
    switch(event.type()) {
        case INTERFACE_ADDED:
            addInterface(event.subject());
            break;
        case INTERFACE_UPDATED:
            removeInterface(event.prevSubject());
            addInterface(event.subject());
            break;
        case INTERFACE_REMOVED:
            removeInterface(event.subject());
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Test
public void testRouteAddToNoVlan() {
    // Build the expected route
    ResolvedRoute route = new ResolvedRoute(PREFIX1, IP3, MAC3);
    MultiPointToSinglePointIntent intent = createIntentToThree(PREFIX1);
    // Setup the expected intents
    intentSynchronizer.submit(eqExceptId(intent));
    replay(intentSynchronizer);
    // Send in the added event
    routeListener.event(new RouteEvent(RouteEvent.Type.ROUTE_ADDED, route));
    verify(intentSynchronizer);
}
#method_after
@Test
public void testRouteAddToNoVlan() {
    // Build the expected route
    ResolvedRoute route = new ResolvedRoute(PREFIX1, IP3, MAC3);
    MultiPointToSinglePointIntent intent = createIntentToThreeSrcOneTwo(PREFIX1);
    // Setup the expected intents
    intentSynchronizer.submit(eqExceptId(intent));
    replay(intentSynchronizer);
    // Send in the added event
    routeListener.event(new RouteEvent(RouteEvent.Type.ROUTE_ADDED, route));
    verify(intentSynchronizer);
}
#end_block

#method_before
@Test
public void testRouteUpdatesToNoVlan() {
    // Add a route first to a destination with no VLAN
    testRouteAddToVlan();
    // Build the new route entries for prefix1 and prefix2
    ResolvedRoute routePrefix = new ResolvedRoute(PREFIX2, IP3, MAC3);
    // Create the new expected intents
    MultiPointToSinglePointIntent newPrefixIntent = createIntentToThree(PREFIX2);
    // Set up test expectation
    reset(intentSynchronizer);
    // Setup the expected intents
    intentSynchronizer.submit(eqExceptId(newPrefixIntent));
    replay(intentSynchronizer);
    // Send in the update events
    routeListener.event(new RouteEvent(RouteEvent.Type.ROUTE_UPDATED, routePrefix));
    verify(intentSynchronizer);
}
#method_after
@Test
public void testRouteUpdatesToNoVlan() {
    // Add a route first to a destination with no VLAN
    testRouteAddToVlan();
    // Build the new route entries for prefix1 and prefix2
    ResolvedRoute routePrefix = new ResolvedRoute(PREFIX2, IP3, MAC3);
    // Create the new expected intents
    MultiPointToSinglePointIntent newPrefixIntent = createIntentToThreeSrcOneTwo(PREFIX2);
    // Set up test expectation
    reset(intentSynchronizer);
    // Setup the expected intents
    intentSynchronizer.submit(eqExceptId(newPrefixIntent));
    replay(intentSynchronizer);
    // Send in the update events
    routeListener.event(new RouteEvent(RouteEvent.Type.ROUTE_UPDATED, routePrefix));
    verify(intentSynchronizer);
}
#end_block

#method_before
@Test
public void testRouteDelete() {
    // Add a route first
    testRouteAddToNoVlan();
    // Construct the existing route entry
    ResolvedRoute route = new ResolvedRoute(PREFIX1, null, null);
    // Create existing intent
    MultiPointToSinglePointIntent addedIntent = createIntentToThree(PREFIX1);
    // Set up expectation
    reset(intentSynchronizer);
    // Setup the expected intents
    intentSynchronizer.withdraw(eqExceptId(addedIntent));
    replay(intentSynchronizer);
    // Send in the removed event
    routeListener.event(new RouteEvent(RouteEvent.Type.ROUTE_REMOVED, route));
    verify(intentSynchronizer);
}
#method_after
@Test
public void testRouteDelete() {
    // Add a route first
    testRouteAddToNoVlan();
    // Construct the existing route entry
    ResolvedRoute route = new ResolvedRoute(PREFIX1, null, null);
    // Create existing intent
    MultiPointToSinglePointIntent removedIntent = createIntentToThreeSrcOneTwo(PREFIX1);
    // Set up expectation
    reset(intentSynchronizer);
    // Setup the expected intents
    intentSynchronizer.withdraw(eqExceptId(removedIntent));
    replay(intentSynchronizer);
    // Send in the removed event
    routeListener.event(new RouteEvent(RouteEvent.Type.ROUTE_REMOVED, route));
    verify(intentSynchronizer);
}
#end_block

#method_before
@Test
public void testAddInterface() {
    // Add a route first
    testRouteAddToNoVlan();
    // Create the new expected intent
    MultiPointToSinglePointIntent addedIntent = createIntentToThreeWithFour(PREFIX1);
    reset(intentSynchronizer);
    intentSynchronizer.submit(eqExceptId(addedIntent));
    expectLastCall().once();
    replay(intentSynchronizer);
    // Create the new interface and add notify it
    Interface intf = new Interface("sw4-eth1", SW4_ETH1, Collections.singletonList(IIP4), MAC4, NO_VLAN);
    InterfaceEvent intfEvent = new InterfaceEvent(InterfaceEvent.Type.INTERFACE_ADDED, intf);
    interfaceListener.event(intfEvent);
    verify(intentSynchronizer);
}
#method_after
@Test
public void testAddInterface() {
    // Add a route first
    testRouteAddToNoVlan();
    // Create the new expected intent
    MultiPointToSinglePointIntent addedIntent = createIntentToThreeSrcOneTwoFour(PREFIX1);
    reset(intentSynchronizer);
    intentSynchronizer.submit(eqExceptId(addedIntent));
    expectLastCall().once();
    replay(intentSynchronizer);
    // Create the new interface and add notify it
    Interface intf = new Interface("sw4-eth1", SW4_ETH1, Collections.singletonList(IIP4), MAC4, NO_VLAN);
    InterfaceEvent intfEvent = new InterfaceEvent(InterfaceEvent.Type.INTERFACE_ADDED, intf);
    interfaceListener.event(intfEvent);
    verify(intentSynchronizer);
}
#end_block

#method_before
private MultiPointToSinglePointIntent createIntentToOne(IpPrefix ipPrefix) {
    // Build the expected treatment
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MAC1);
    treatmentBuilder.setVlanId(VLAN10);
    // Define ingress points
    Set<ConnectPoint> ingressPoints = Sets.newHashSet();
    ingressPoints.add(SW2_ETH1);
    ingressPoints.add(SW3_ETH1);
    // Build the expected selectors
    Map<ConnectPoint, TrafficSelector> selectors = Maps.newHashMap();
    // Build the expected selector for the first ingress point
    TrafficSelector.Builder selectorOne = DefaultTrafficSelector.builder();
    selectorOne.matchVlanId(VLAN20);
    selectorOne.matchEthType(Ethernet.TYPE_IPV4);
    selectorOne.matchIPDst(ipPrefix);
    selectors.put(SW2_ETH1, selectorOne.build());
    // Build the expected selector for the second ingress point
    TrafficSelector.Builder selectorTwo = DefaultTrafficSelector.builder();
    selectorTwo.matchEthType(Ethernet.TYPE_IPV4);
    selectorTwo.matchIPDst(ipPrefix);
    selectors.put(SW3_ETH1, selectorTwo.build());
    // Build the expected intent
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(APPID).key(Key.of(ipPrefix.toString(), APPID)).selectors(selectors).treatment(treatmentBuilder.build()).ingressPoints(ingressPoints).egressPoint(SW1_ETH1).constraints(SdnIpFib.CONSTRAINTS).build();
    return intent;
}
#method_after
private MultiPointToSinglePointIntent createIntentToOne(IpPrefix ipPrefix) {
    // Build the expected treatment
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MAC1);
    // Build the expected egress FilteredConnectPoint
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchVlanId(VLAN10);
    FilteredConnectPoint egressFilteredCP = new FilteredConnectPoint(SW1_ETH1, selector.build());
    // Build the expected selectors
    Set<FilteredConnectPoint> ingressFilteredCPs = Sets.newHashSet();
    // Build the expected ingress FilteredConnectPoint for sw2
    selector = DefaultTrafficSelector.builder();
    selector.matchVlanId(VLAN20);
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchIPDst(ipPrefix);
    FilteredConnectPoint ingressFilteredCP = new FilteredConnectPoint(SW2_ETH1, selector.build());
    ingressFilteredCPs.add(ingressFilteredCP);
    // Build the expected ingress FilteredConnectPoint for sw3
    selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchIPDst(ipPrefix);
    ingressFilteredCP = new FilteredConnectPoint(SW3_ETH1, selector.build());
    ingressFilteredCPs.add(ingressFilteredCP);
    // Build the expected intent
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(APPID).key(Key.of(ipPrefix.toString(), APPID)).filteredIngressPoints(ingressFilteredCPs).filteredEgressPoint(egressFilteredCP).treatment(treatmentBuilder.build()).constraints(SdnIpFib.CONSTRAINTS).build();
    return intent;
}
#end_block

#method_before
private MultiPointToSinglePointIntent createIntentToThreeSrcTwo(IpPrefix ipPrefix) {
    // Build the expected treatment
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MAC3);
    treatmentBuilder.popVlan();
    // Define ingress points
    Set<ConnectPoint> ingressPoints = Sets.newHashSet();
    ingressPoints.add(SW2_ETH1);
    // Build the expected selectors
    Map<ConnectPoint, TrafficSelector> selectors = Maps.newHashMap();
    // Build the expected selector for sw1
    TrafficSelector.Builder selectorOne = DefaultTrafficSelector.builder();
    selectorOne.matchVlanId(VLAN10);
    selectorOne.matchEthType(Ethernet.TYPE_IPV4);
    selectorOne.matchIPDst(ipPrefix);
    selectors.put(SW1_ETH1, selectorOne.build());
    // Build the expected intent
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(APPID).key(Key.of(ipPrefix.toString(), APPID)).selectors(selectors).treatment(treatmentBuilder.build()).ingressPoints(ingressPoints).egressPoint(SW3_ETH1).constraints(SdnIpFib.CONSTRAINTS).build();
    return intent;
}
#method_after
private MultiPointToSinglePointIntent createIntentToThreeSrcTwo(IpPrefix ipPrefix) {
    // Build the expected treatment
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MAC3);
    // Build the expected egress FilteredConnectPoint
    FilteredConnectPoint egressFilteredCP = new FilteredConnectPoint(SW3_ETH1);
    // Build the expected ingress FilteredConnectPoint for sw2
    Set<FilteredConnectPoint> ingressFilteredCPs = Sets.newHashSet();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchVlanId(VLAN20);
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchIPDst(ipPrefix);
    FilteredConnectPoint ingressFilteredCP = new FilteredConnectPoint(SW2_ETH1, selector.build());
    ingressFilteredCPs.add(ingressFilteredCP);
    // Build the expected intent
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(APPID).key(Key.of(ipPrefix.toString(), APPID)).filteredIngressPoints(ingressFilteredCPs).filteredEgressPoint(egressFilteredCP).treatment(treatmentBuilder.build()).constraints(SdnIpFib.CONSTRAINTS).build();
    return intent;
}
#end_block

#method_before
@Override
public Builder selector(TrafficSelector selector) {
    return (Builder) super.selector(selector);
}
#method_after
@Override
public Builder selector(TrafficSelector selector) {
    this.isIntentSelectorSet = true;
    return (Builder) super.selector(selector);
}
#end_block

#method_before
public Builder ingressPoint(ConnectPoint ingressPoint) {
    this.ingressPoint = ingressPoint;
    return this;
}
#method_after
public Builder ingressPoint(ConnectPoint ingressPoint) {
    this.ingressPoint = new FilteredConnectPoint(ingressPoint);
    return this;
}
#end_block

#method_before
public Builder egressPoints(Set<ConnectPoint> egressPoints) {
    this.egressPoints = ImmutableSet.copyOf(egressPoints);
    return this;
}
#method_after
public Builder egressPoints(Set<ConnectPoint> egressPoints) {
    Set<FilteredConnectPoint> filteredConnectPoints = egressPoints.stream().map(FilteredConnectPoint::new).collect(Collectors.toSet());
    this.egressPoints = ImmutableSet.copyOf(filteredConnectPoints);
    return this;
}
#end_block

#method_before
public SinglePointToMultiPointIntent build() {
    return new SinglePointToMultiPointIntent(appId, key, selector, treatment, ingressPoint, egressPoints, constraints, priority);
}
#method_after
public SinglePointToMultiPointIntent build() {
    /*
             * Throw exception if both intent selector and filtered connection point selector
             * is set or not.
             */
    if (isFilteredPointSet && isIntentSelectorSet) {
        throw new IntentException("Intent selector and filtered point can't be set at same time");
    }
    if (!isFilteredPointSet && !isIntentSelectorSet) {
        throw new IntentException("Intent selector or filtered point should be set.");
    }
    if (!isFilteredPointSet) {
        egressPoints = egressPoints.stream().map(FilteredConnectPoint::connectPoint).map(cp -> new FilteredConnectPoint(cp, selector)).collect(Collectors.toSet());
        ingressPoint = new FilteredConnectPoint(ingressPoint.connectPoint(), selector);
    }
    return new SinglePointToMultiPointIntent(appId, key, selector, treatment, ingressPoint, egressPoints, constraints, priority);
}
#end_block

#method_before
public ConnectPoint ingressPoint() {
    return ingressPoint;
}
#method_after
public ConnectPoint ingressPoint() {
    return ingressPoint.connectPoint();
}
#end_block

#method_before
public Set<ConnectPoint> egressPoints() {
    return egressPoints;
}
#method_after
public Set<ConnectPoint> egressPoints() {
    return egressPoints.stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Builder selector(TrafficSelector selector) {
    return (Builder) super.selector(selector);
}
#method_after
@Override
public Builder selector(TrafficSelector selector) {
    this.isIntentSelectorSet = true;
    return (Builder) super.selector(selector);
}
#end_block

#method_before
public Builder ingressPoints(Set<? extends ConnectPoint> ingressPoints) {
    this.ingressPoints = ImmutableSet.copyOf(ingressPoints);
    return this;
}
#method_after
public Builder ingressPoints(Set<ConnectPoint> ingressPoints) {
    this.ingressPoints = ingressPoints.stream().map(FilteredConnectPoint::new).collect(Collectors.toSet());
    return this;
}
#end_block

#method_before
public Builder egressPoint(ConnectPoint egressPoint) {
    this.egressPoint = egressPoint;
    return this;
}
#method_after
public Builder egressPoint(ConnectPoint egressPoint) {
    this.egressPoint = new FilteredConnectPoint(egressPoint);
    return this;
}
#end_block

#method_before
public MultiPointToSinglePointIntent build() {
    return new MultiPointToSinglePointIntent(appId, key, selector, treatment, ingressPoints, egressPoint, constraints, priority);
}
#method_after
public MultiPointToSinglePointIntent build() {
    /*
             * Throw exception if both intent selector and filtered connection point selector
             * is set or not.
             */
    if (isFilteredPointSet && isIntentSelectorSet) {
        throw new IntentException("Intent selector and filtered point can't be set at same time");
    }
    if (!isFilteredPointSet && !isIntentSelectorSet) {
        throw new IntentException("Intent selector or filtered point should be set.");
    }
    if (!isFilteredPointSet) {
        ingressPoints = ingressPoints.stream().map(FilteredConnectPoint::connectPoint).map(cp -> new FilteredConnectPoint(cp, selector)).collect(Collectors.toSet());
        egressPoint = new FilteredConnectPoint(egressPoint.connectPoint(), selector);
    }
    return new MultiPointToSinglePointIntent(appId, key, selector, treatment, ingressPoints, egressPoint, constraints, priority);
}
#end_block

#method_before
public Set<? extends ConnectPoint> ingressPoints() {
    return ingressPoints;
}
#method_after
public Set<ConnectPoint> ingressPoints() {
    return ingressPoints.stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet());
}
#end_block

#method_before
public ConnectPoint egressPoint() {
    return egressPoint;
}
#method_after
public ConnectPoint egressPoint() {
    return egressPoint.connectPoint();
}
#end_block

#method_before
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, DeviceId deviceId, Set<PortNumber> outPorts, Set<PortNumber> ingressPorts, Set<PortNumber> egressPorts) {
    TrafficTreatment.Builder defaultTreatmentBuilder = DefaultTrafficTreatment.builder();
    outPorts.forEach(defaultTreatmentBuilder::setOutput);
    TrafficTreatment outputOnlyTreatment = defaultTreatmentBuilder.build();
    TrafficSelector.Builder selectorBuilder;
    TrafficTreatment treatment;
    TrafficTreatment intentTreatment;
    if (!intent.applyTreatmentOnEgress()) {
        TrafficTreatment.Builder ingressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
        outPorts.forEach(ingressTreatmentBuilder::setOutput);
        intentTreatment = ingressTreatmentBuilder.build();
        if (ingressPorts.contains(inPort)) {
            if (intent.ingressSelectors() != null && !intent.ingressSelectors().isEmpty()) {
                /**
                 * We iterate on the ingress points looking for the connect point
                 * associated to inPort.
                 */
                Optional<ConnectPoint> connectPoint = intent.ingressPoints().stream().filter(ingressPoint -> ingressPoint.port().equals(inPort) && ingressPoint.deviceId().equals(deviceId)).findFirst();
                if (connectPoint.isPresent()) {
                    selectorBuilder = DefaultTrafficSelector.builder(intent.ingressSelectors().get(connectPoint.get()));
                } else {
                    throw new IntentCompilationException("Looking for connect point associated to the selector." + "inPort not in IngressPoints");
                }
            } else {
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            }
            treatment = this.updateBuilder(ingressTreatmentBuilder, selectorBuilder.build()).build();
        } else {
            selectorBuilder = this.createSelectorFromFwdInstructions(new ForwardingInstructions(intentTreatment, intent.selector()));
            treatment = outputOnlyTreatment;
        }
    } else {
        if (outPorts.stream().allMatch(egressPorts::contains)) {
            TrafficTreatment.Builder egressTreatmentBuilder = DefaultTrafficTreatment.builder();
            if (intent.egressTreatments() != null && !intent.egressTreatments().isEmpty()) {
                for (PortNumber outPort : outPorts) {
                    Optional<ConnectPoint> connectPoint = intent.egressPoints().stream().filter(egressPoint -> egressPoint.port().equals(outPort) && egressPoint.deviceId().equals(deviceId)).findFirst();
                    if (connectPoint.isPresent()) {
                        TrafficTreatment egressTreatment = intent.egressTreatments().get(connectPoint.get());
                        this.addTreatment(egressTreatmentBuilder, egressTreatment);
                        egressTreatmentBuilder = this.updateBuilder(egressTreatmentBuilder, intent.selector());
                        egressTreatmentBuilder.setOutput(outPort);
                    } else {
                        throw new IntentCompilationException("Looking for connect point associated to " + "the treatment. outPort not in egressPoints");
                    }
                }
            } else {
                egressTreatmentBuilder = this.updateBuilder(DefaultTrafficTreatment.builder(intent.treatment()), intent.selector());
                outPorts.forEach(egressTreatmentBuilder::setOutput);
            }
            selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            treatment = egressTreatmentBuilder.build();
        } else {
            selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
            treatment = outputOnlyTreatment;
        }
    }
    TrafficSelector selector = selectorBuilder.matchInPort(inPort).build();
    return new ForwardingInstructions(treatment, selector);
}
#method_after
protected ForwardingInstructions createForwardingInstructions(LinkCollectionIntent intent, PortNumber inPort, DeviceId deviceId, Set<PortNumber> outPorts, Set<PortNumber> ingressPorts, Set<PortNumber> egressPorts) {
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchInPort(inPort);
    if (!intent.applyTreatmentOnEgress()) {
        // Assume that it's compiled from mp2sp intent
        Optional<FilteredConnectPoint> filteredIngressPoint = getFilteredConnectPointFromIntent(deviceId, inPort, intent);
        Optional<FilteredConnectPoint> filteredEgressPoint = intent.filteredEgressPoints().stream().findFirst();
        if (filteredIngressPoint.isPresent()) {
            // Ingress device
            if (filteredEgressPoint.isPresent()) {
                filteredIngressPoint.get().trafficSelector().criteria().stream().forEach(selectorBuilder::add);
                TrafficTreatment forwardingTreatment = forwardingTreatment(filteredIngressPoint.get(), filteredEgressPoint.get());
                forwardingTreatment.allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
            } else {
                throw new IntentCompilationException("Can't find filtered connection point");
            }
            intent.treatment().allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
        } else {
            if (filteredEgressPoint.isPresent()) {
                filteredEgressPoint.get().trafficSelector().criteria().forEach(selectorBuilder::add);
            }
        }
        outPorts.forEach(treatmentBuilder::setOutput);
    } else {
        // Assume that it's compiled from sp2mp intent
        Optional<FilteredConnectPoint> filteredIngressPoint = intent.filteredIngressPoints().stream().findFirst();
        if (filteredIngressPoint.isPresent()) {
            filteredIngressPoint.get().trafficSelector().criteria().forEach(selectorBuilder::add);
        } else {
            throw new IntentCompilationException("Filtered connection point for ingress point not exist");
        }
        for (PortNumber outPort : outPorts) {
            Optional<FilteredConnectPoint> filteredEgressPoint = getFilteredConnectPointFromIntent(deviceId, outPort, intent);
            if (filteredEgressPoint.isPresent()) {
                // Egress port, apply treatment + forwarding treatment
                TrafficTreatment forwardingTreatment = forwardingTreatment(filteredIngressPoint.get(), filteredEgressPoint.get());
                forwardingTreatment.allInstructions().stream().filter(inst -> inst.type() != Instruction.Type.NOACTION).forEach(treatmentBuilder::add);
            }
            treatmentBuilder.setOutput(outPort);
        }
    }
    return new ForwardingInstructions(treatmentBuilder.build(), selectorBuilder.build());
}
#end_block

#method_before
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent, List<Intent> installable) {
    Set<Link> links = new HashSet<>();
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        if (egressPoint.deviceId().equals(intent.ingressPoint().deviceId())) {
            continue;
        }
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        links.addAll(path.links());
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).selector(intent.selector()).treatment(intent.treatment()).links(links).ingressPoints(ImmutableSet.of(intent.ingressPoint())).egressPoints(intent.egressPoints()).priority(intent.priority()).applyTreatmentOnEgress(true).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#method_after
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent, List<Intent> installable) {
    Set<Link> links = new HashSet<>();
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        if (egressPoint.deviceId().equals(intent.ingressPoint().deviceId())) {
            continue;
        }
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        links.addAll(path.links());
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).treatment(intent.treatment()).links(links).filteredIngressPoints(ImmutableSet.of(intent.filteredIngressPoint())).filteredEgressPoints(intent.filteredEgressPoints()).priority(intent.priority()).applyTreatmentOnEgress(true).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#end_block

#method_before
@Override
public Builder selector(TrafficSelector selector) {
    return (Builder) super.selector(selector);
}
#method_after
@Override
public Builder selector(TrafficSelector selector) {
    this.isIntentSelectorSet = true;
    return (Builder) super.selector(selector);
}
#end_block

#method_before
public Builder ingressPoints(Set<? extends ConnectPoint> ingressPoints) {
    this.ingressPoints = ImmutableSet.copyOf(ingressPoints);
    return this;
}
#method_after
public Builder ingressPoints(Set<ConnectPoint> ingressPoints) {
    this.ingressPoints = ingressPoints.stream().map(FilteredConnectPoint::new).collect(Collectors.toSet());
    return this;
}
#end_block

#method_before
public Builder egressPoints(Set<? extends ConnectPoint> egressPoints) {
    this.egressPoints = ImmutableSet.copyOf(egressPoints);
    return this;
}
#method_after
public Builder egressPoints(Set<ConnectPoint> egressPoints) {
    this.egressPoints = egressPoints.stream().map(FilteredConnectPoint::new).collect(Collectors.toSet());
    return this;
}
#end_block

#method_before
public LinkCollectionIntent build() {
    return new LinkCollectionIntent(appId, key, selector, treatment, links, ingressPoints, egressPoints, constraints, priority, egressTreatmentFlag);
}
#method_after
public LinkCollectionIntent build() {
    /*
             * Throw exception if both intent selector and filtered connection point selector
             * is set or not.
             */
    if (this.isFilteredPointSet && this.isIntentSelectorSet) {
        throw new IntentException("Intent selector and filtered point can't be set at same time");
    }
    if (!this.isFilteredPointSet && !this.isIntentSelectorSet) {
        throw new IntentException("Intent selector or filtered point should be set.");
    }
    if (!this.isFilteredPointSet) {
        ingressPoints = ingressPoints.stream().map(FilteredConnectPoint::connectPoint).map(cp -> new FilteredConnectPoint(cp, selector)).collect(Collectors.toSet());
        egressPoints = egressPoints.stream().map(FilteredConnectPoint::connectPoint).map(cp -> new FilteredConnectPoint(cp, selector)).collect(Collectors.toSet());
    }
    return new LinkCollectionIntent(appId, key, selector, treatment, links, ingressPoints, egressPoints, constraints, priority, egressTreatmentFlag);
}
#end_block

#method_before
public Set<? extends ConnectPoint> ingressPoints() {
    return ingressPoints;
}
#method_after
public Set<ConnectPoint> ingressPoints() {
    if (this.ingressPoints == null) {
        return null;
    }
    return ingressPoints.stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet());
}
#end_block

#method_before
public Set<? extends ConnectPoint> egressPoints() {
    return egressPoints;
}
#method_after
public Set<ConnectPoint> egressPoints() {
    if (this.egressPoints == null) {
        return null;
    }
    return egressPoints.stream().map(FilteredConnectPoint::connectPoint).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public List<Intent> compile(MultiPointToSinglePointIntent intent, List<Intent> installable) {
    Map<DeviceId, Link> links = new HashMap<>();
    ConnectPoint egressPoint = intent.egressPoint();
    final boolean allowMissingPaths = intentAllowsPartialFailure(intent);
    boolean partialTree = false;
    boolean anyMissingPaths = false;
    for (ConnectPoint ingressPoint : intent.ingressPoints()) {
        if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
            if (deviceService.isAvailable(ingressPoint.deviceId())) {
                partialTree = true;
            } else {
                anyMissingPaths = true;
            }
            continue;
        }
        Path path = getPath(ingressPoint, intent.egressPoint());
        if (path != null) {
            partialTree = true;
            for (Link link : path.links()) {
                if (links.containsKey(link.dst().deviceId())) {
                    // We've already reached the existing tree with the first
                    // part of this path. Add the merging point with different
                    // incoming port, but don't add the remainder of the path
                    // in case it differs from the path we already have.
                    links.put(link.src().deviceId(), link);
                    break;
                }
                links.put(link.src().deviceId(), link);
            }
        } else {
            anyMissingPaths = true;
        }
    }
    if (!partialTree) {
        throw new IntentException("Could not find any paths between ingress and egress points.");
    } else if (!allowMissingPaths && anyMissingPaths) {
        throw new IntentException("Missing some paths between ingress and egress ports.");
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).selector(intent.selector()).treatment(intent.treatment()).links(Sets.newHashSet(links.values())).ingressPoints(intent.ingressPoints()).egressPoints(ImmutableSet.of(intent.egressPoint())).priority(intent.priority()).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#method_after
@Override
public List<Intent> compile(MultiPointToSinglePointIntent intent, List<Intent> installable) {
    Map<DeviceId, Link> links = new HashMap<>();
    ConnectPoint egressPoint = intent.egressPoint();
    final boolean allowMissingPaths = intentAllowsPartialFailure(intent);
    boolean partialTree = false;
    boolean anyMissingPaths = false;
    for (ConnectPoint ingressPoint : intent.ingressPoints()) {
        if (ingressPoint.deviceId().equals(egressPoint.deviceId())) {
            if (deviceService.isAvailable(ingressPoint.deviceId())) {
                partialTree = true;
            } else {
                anyMissingPaths = true;
            }
            continue;
        }
        Path path = getPath(ingressPoint, intent.egressPoint());
        if (path != null) {
            partialTree = true;
            for (Link link : path.links()) {
                if (links.containsKey(link.dst().deviceId())) {
                    // We've already reached the existing tree with the first
                    // part of this path. Add the merging point with different
                    // incoming port, but don't add the remainder of the path
                    // in case it differs from the path we already have.
                    links.put(link.src().deviceId(), link);
                    break;
                }
                links.put(link.src().deviceId(), link);
            }
        } else {
            anyMissingPaths = true;
        }
    }
    if (!partialTree) {
        throw new IntentException("Could not find any paths between ingress and egress points.");
    } else if (!allowMissingPaths && anyMissingPaths) {
        throw new IntentException("Missing some paths between ingress and egress ports.");
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).treatment(intent.treatment()).links(Sets.newHashSet(links.values())).filteredIngressPoints(intent.filteredIngressPoints()).filteredEgressPoints(ImmutableSet.of(intent.filteredEgressPoint())).priority(intent.priority()).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#end_block

#method_before
public static YangType isTypeLeafref(YangType<?> attributeType) {
    if (attributeType.getDataType() == YangDataTypes.LEAFREF) {
        YangLeafRef leafRef = (YangLeafRef) attributeType.getDataTypeExtendedInfo();
        // TODO check if leafref itself is null.
        if (!leafRef.isInGrouping()) {
            return leafRef.getEffectiveDataType();
        }
    }
    return attributeType;
}
#method_after
public static YangType isTypeLeafref(YangType<?> attributeType) {
    if (attributeType.getDataType() == YangDataTypes.LEAFREF) {
        YangLeafRef leafRef = (YangLeafRef) attributeType.getDataTypeExtendedInfo();
        if (!leafRef.isInGrouping()) {
            return leafRef.getEffectiveDataType();
        }
    }
    return attributeType;
}
#end_block

#method_before
private static YangType<?> getReferredTypeFromLeafref(YangType type) {
    YangLeafRef<?> leafRefInfo = (YangLeafRef<?>) type.getDataTypeExtendedInfo();
    if (leafRefInfo.isInGrouping()) {
        return null;
    }
    return leafRefInfo.getEffectiveDataType();
}
#method_after
private static YangType<?> getReferredTypeFromLeafref(YangType type) {
    YangLeafRef<?> lri = (YangLeafRef<?>) type.getDataTypeExtendedInfo();
    return lri.isInGrouping() ? null : lri.getEffectiveDataType();
}
#end_block

#method_before
private static String getLeafRefImpClass(YangType type, YangToJavaNamingConflictUtil cnfg, boolean isList) {
    YangType<?> referredType = getReferredTypeFromLeafref(type);
    if (referredType == null) {
        return OBJECT_STRING;
    }
    return getJavaImportClass(referredType, isList, cnfg);
}
#method_after
private static String getLeafRefImpClass(YangType type, YangToJavaNamingConflictUtil cnfg, boolean isList) {
    YangType<?> rt = getReferredTypeFromLeafref(type);
    return rt == null ? OBJECT_STRING : getJavaImportClass(rt, isList, cnfg);
}
#end_block

#method_before
private static String getIdentityRefImpClass(YangType type, YangToJavaNamingConflictUtil cnfg) {
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    if (identityRef.isInGrouping()) {
        return OBJECT_STRING;
    }
    YangIdentity identity = identityRef.getReferredIdentity();
    return getCapitalCase(getCamelCase(identity.getName(), cnfg));
}
#method_after
private static String getIdentityRefImpClass(YangType type, YangToJavaNamingConflictUtil cnfg) {
    YangIdentityRef ir = (YangIdentityRef) type.getDataTypeExtendedInfo();
    if (ir.isInGrouping()) {
        return OBJECT_STRING;
    }
    YangIdentity identity = ir.getReferredIdentity();
    return getCapitalCase(getCamelCase(identity.getName(), cnfg));
}
#end_block

#method_before
private static String getLeafRefImpPkg(YangType type, YangToJavaNamingConflictUtil cnfg, boolean isList) {
    YangType<?> referredType = getReferredTypeFromLeafref(type);
    if (referredType == null) {
        return JAVA_LANG;
    }
    return getJavaImportPackage(referredType, isList, cnfg);
}
#method_after
private static String getLeafRefImpPkg(YangType type, YangToJavaNamingConflictUtil cnfg, boolean isList) {
    YangType<?> rt = getReferredTypeFromLeafref(type);
    return rt == null ? JAVA_LANG : getJavaImportPackage(rt, isList, cnfg);
}
#end_block

#method_before
T processLeafRefXpathLinking(List<YangAtomicPath> atomicPaths, YangNode root, YangLeafRef leafref) {
    YangNode targetNode;
    rootNode = root;
    prefixResolverTypes = new HashMap<>();
    parsePrefixResolverList(atomicPaths);
    YangAtomicPath leafRefPath = atomicPaths.get(atomicPaths.size() - 1);
    // When leaf-ref path contains only one absolute path.
    if (atomicPaths.size() == 1) {
        targetNode = getTargetNodeWhenPathSizeIsOne(atomicPaths);
    } else {
        for (YangAtomicPath atomicPath : atomicPaths) {
            if (atomicPath != leafRefPath) {
                absPaths.add(atomicPath);
            }
        }
        targetNode = parseData(root);
    }
    if (targetNode == null) {
        targetNode = searchInSubModule(root);
    }
    // Invalid path presence in the node list is checked.
    validateInvalidNodesInThePath(leafref);
    if (targetNode != null) {
        YangLeaf targetLeaf = searchReferredLeaf(targetNode, leafRefPath.getNodeIdentifier().getName());
        if (targetLeaf == null) {
            YangLeafList targetLeafList = searchReferredLeafList(targetNode, leafRefPath.getNodeIdentifier().getName());
            if (targetLeafList != null) {
                return (T) targetLeafList;
            } else {
                LinkerException linkerException = new LinkerException("YANG file error: Unable to find base " + "leaf/leaf-list for given leafref path " + leafref.getPath());
                linkerException.setCharPosition(leafref.getCharPosition());
                linkerException.setLine(leafref.getLineNumber());
                linkerException.setFileName(leafref.getFileName());
                throw linkerException;
            }
        }
        return (T) targetLeaf;
    }
    return null;
}
#method_after
T processLeafRefXpathLinking(List<YangAtomicPath> atomicPaths, YangNode root, YangLeafRef leafref) {
    YangNode targetNode;
    rootNode = root;
    prefixResolverTypes = new HashMap<>();
    parsePrefixResolverList(atomicPaths);
    YangAtomicPath leafRefPath = atomicPaths.get(atomicPaths.size() - 1);
    // When leaf-ref path contains only one absolute path.
    if (atomicPaths.size() == 1) {
        targetNode = getTargetNodeWhenPathSizeIsOne(atomicPaths);
    } else {
        for (YangAtomicPath atomicPath : atomicPaths) {
            if (atomicPath != leafRefPath) {
                absPaths.add(atomicPath);
            }
        }
        targetNode = parseData(root);
    }
    if (targetNode == null) {
        targetNode = searchInSubModule(root);
    }
    // Invalid path presence in the node list is checked.
    validateInvalidNodesInThePath(leafref);
    if (targetNode != null) {
        YangLeaf targetLeaf = searchReferredLeaf(targetNode, leafRefPath.getNodeIdentifier().getName());
        if (targetLeaf == null) {
            YangLeafList targetLeafList = searchReferredLeafList(targetNode, leafRefPath.getNodeIdentifier().getName());
            if (targetLeafList != null) {
                return (T) targetLeafList;
            } else {
                LinkerException ex = new LinkerException(FAILED_TO_FIND_LEAD_INFO_HOLDER + leafref.getPath());
                ex.setCharPosition(leafref.getCharPosition());
                ex.setLine(leafref.getLineNumber());
                ex.setFileName(leafref.getFileName());
                throw ex;
            }
        }
        return (T) targetLeaf;
    }
    return null;
}
#end_block

#method_before
private void validateInvalidNodesInThePath(YangLeafRef leafref) {
    for (YangAtomicPath absolutePath : (Iterable<YangAtomicPath>) leafref.getAtomicPath()) {
        YangNode nodeInPath = absolutePath.getResolvedNode();
        if (nodeInPath instanceof LeafRefInvalidHolder) {
            LinkerException linkerException = new LinkerException("YANG file error: The target node, in the " + "leafref path " + leafref.getPath() + ", is invalid.");
            linkerException.setCharPosition(leafref.getCharPosition());
            linkerException.setLine(leafref.getLineNumber());
            linkerException.setFileName(leafref.getFileName());
            throw linkerException;
        }
    }
}
#method_after
private void validateInvalidNodesInThePath(YangLeafRef leafref) {
    for (YangAtomicPath absolutePath : (Iterable<YangAtomicPath>) leafref.getAtomicPath()) {
        YangNode nodeInPath = absolutePath.getResolvedNode();
        if (nodeInPath instanceof LeafRefInvalidHolder) {
            LinkerException ex = new LinkerException(LEAFREF_ERROR + leafref.getPath() + IS_INVALID);
            ex.setCharPosition(leafref.getCharPosition());
            ex.setLine(leafref.getLineNumber());
            ex.setFileName(leafref.getFileName());
            throw ex;
        }
    }
}
#end_block

#method_before
private YangLeaf searchReferredLeaf(YangNode targetNode, String leafName) {
    if (!(targetNode instanceof YangLeavesHolder)) {
        throw new LinkerException("Referred node " + targetNode.getName() + "should be of type leaves holder in " + targetNode.getLineNumber() + " at " + targetNode.getCharPosition() + " in " + targetNode.getFileName());
    }
    YangLeavesHolder holder = (YangLeavesHolder) targetNode;
    List<YangLeaf> leaves = holder.getListOfLeaf();
    if (leaves != null && !leaves.isEmpty()) {
        for (YangLeaf leaf : leaves) {
            if (leaf.getName().equals(leafName)) {
                return leaf;
            }
        }
    }
    return null;
}
#method_after
private YangLeaf searchReferredLeaf(YangNode targetNode, String leafName) {
    if (!(targetNode instanceof YangLeavesHolder)) {
        throw new LinkerException(getErrorMsg(LEAF_HOLDER_ERROR, targetNode.getName(), targetNode.getLineNumber(), targetNode.getCharPosition(), targetNode.getFileName()));
    }
    YangLeavesHolder holder = (YangLeavesHolder) targetNode;
    List<YangLeaf> leaves = holder.getListOfLeaf();
    if (leaves != null && !leaves.isEmpty()) {
        for (YangLeaf leaf : leaves) {
            if (leaf.getName().equals(leafName)) {
                return leaf;
            }
        }
    }
    return null;
}
#end_block

#method_before
private YangLeafList searchReferredLeafList(YangNode targetNode, String leafListName) {
    if (!(targetNode instanceof YangLeavesHolder)) {
        throw new LinkerException("Referred node " + targetNode.getName() + "should be of type leaves holder in " + targetNode.getLineNumber() + " at " + targetNode.getCharPosition() + " in " + targetNode.getFileName());
    }
    YangLeavesHolder holder = (YangLeavesHolder) targetNode;
    List<YangLeafList> leavesList = holder.getListOfLeafList();
    if (leavesList != null && !leavesList.isEmpty()) {
        for (YangLeafList leafList : leavesList) {
            if (leafList.getName().equals(leafListName)) {
                return leafList;
            }
        }
    }
    return null;
}
#method_after
private YangLeafList searchReferredLeafList(YangNode targetNode, String name) {
    if (!(targetNode instanceof YangLeavesHolder)) {
        throw new LinkerException(getErrorMsg(LEAF_HOLDER_ERROR, targetNode.getName(), targetNode.getLineNumber(), targetNode.getCharPosition(), targetNode.getFileName()));
    }
    YangLeavesHolder holder = (YangLeavesHolder) targetNode;
    List<YangLeafList> leavesList = holder.getListOfLeafList();
    if (leavesList != null && !leavesList.isEmpty()) {
        for (YangLeafList leafList : leavesList) {
            if (leafList.getName().equals(name)) {
                return leafList;
            }
        }
    }
    return null;
}
#end_block

#method_before
private void parsePrefixResolverList(List<YangAtomicPath> absolutePaths) {
    Iterator<YangAtomicPath> pathIterator = absolutePaths.iterator();
    YangAtomicPath absPath;
    String prePrefix;
    String curPrefix = null;
    while (pathIterator.hasNext()) {
        prePrefix = curPrefix;
        absPath = pathIterator.next();
        curPrefix = absPath.getNodeIdentifier().getPrefix();
        if (curPrefix != null) {
            if (!curPrefix.equals(prePrefix)) {
                if (prePrefix != null) {
                    addToPrefixResolverList(INTER_TO_INTER, absPath);
                } else {
                    addToPrefixResolverList(INTRA_TO_INTER, absPath);
                }
            } else {
                addToPrefixResolverList(NO_PREFIX_CHANGE_FOR_INTER, absPath);
            }
        } else {
            if (prePrefix != null) {
                addToPrefixResolverList(INTER_TO_INTRA, absPath);
            } else {
                addToPrefixResolverList(NO_PREFIX_CHANGE_FOR_INTRA, absPath);
            }
        }
    }
}
#method_after
private void parsePrefixResolverList(List<YangAtomicPath> absolutePaths) {
    Iterator<YangAtomicPath> pathIterator = absolutePaths.iterator();
    YangAtomicPath absPath;
    String prePrefix;
    String curPrefix = null;
    while (pathIterator.hasNext()) {
        prePrefix = curPrefix;
        absPath = pathIterator.next();
        curPrefix = absPath.getNodeIdentifier().getPrefix();
        if (curPrefix != null) {
            if (!curPrefix.equals(prePrefix)) {
                if (prePrefix != null) {
                    prefixResolverTypes.put(absPath, INTER_TO_INTER);
                } else {
                    prefixResolverTypes.put(absPath, INTRA_TO_INTER);
                }
            } else {
                prefixResolverTypes.put(absPath, NO_PREFIX_CHANGE_FOR_INTER);
            }
        } else {
            if (prePrefix != null) {
                prefixResolverTypes.put(absPath, INTER_TO_INTRA);
            } else {
                prefixResolverTypes.put(absPath, NO_PREFIX_CHANGE_FOR_INTRA);
            }
        }
    }
}
#end_block

#method_before
public static void processOutputEntry(TreeWalkListener listener, GeneratedYangParser.OutputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, OUTPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangOutput yangOutput = getYangOutputNode(JAVA_GENERATION);
        yangOutput.setName(((YangRpc) curData).getName() + OUTPUT_KEYWORD);
        yangOutput.setJavaGenerationName(((YangRpc) curData).getName() + OUTPUT_KEYWORD);
        yangOutput.setName(OUTPUT);
        yangOutput.setLineNumber(ctx.getStart().getLine());
        yangOutput.setCharPosition(ctx.getStart().getCharPositionInLine());
        yangOutput.setFileName(listener.getFileName());
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangOutput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, OUTPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangOutput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, OUTPUT_DATA, "", ENTRY));
    }
}
#method_after
public static void processOutputEntry(TreeWalkListener listener, GeneratedYangParser.OutputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, OUTPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangOutput yangOutput = getYangOutputNode(JAVA_GENERATION);
        yangOutput.setName(OUTPUT);
        yangOutput.setLineNumber(ctx.getStart().getLine());
        yangOutput.setCharPosition(ctx.getStart().getCharPositionInLine());
        yangOutput.setFileName(listener.getFileName());
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangOutput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, OUTPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangOutput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, OUTPUT_DATA, "", ENTRY));
    }
}
#end_block

#method_before
public static void processInputEntry(TreeWalkListener listener, GeneratedYangParser.InputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, INPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangInput yangInput = getYangInputNode(JAVA_GENERATION);
        yangInput.setJavaGenerationName(((YangRpc) curData).getName() + INPUT_KEYWORD);
        yangInput.setName(INPUT);
        yangInput.setLineNumber(ctx.getStart().getLine());
        yangInput.setCharPosition(ctx.getStart().getCharPositionInLine());
        yangInput.setFileName(listener.getFileName());
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangInput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, INPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangInput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, INPUT_DATA, "", ENTRY));
    }
}
#method_after
public static void processInputEntry(TreeWalkListener listener, GeneratedYangParser.InputStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, INPUT_DATA, "", ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangRpc) {
        YangInput yangInput = getYangInputNode(JAVA_GENERATION);
        yangInput.setName(INPUT);
        yangInput.setLineNumber(ctx.getStart().getLine());
        yangInput.setCharPosition(ctx.getStart().getCharPositionInLine());
        yangInput.setFileName(listener.getFileName());
        YangNode curNode = (YangNode) curData;
        try {
            curNode.addChild(yangInput);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, INPUT_DATA, "", ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangInput);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, INPUT_DATA, "", ENTRY));
    }
}
#end_block

#method_before
public static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangJavaAugmentTranslator) {
        updatePackageForAugmentInfo(javaCodeGeneratorInfo, yangPluginConfig);
    } else {
        setJavaNameForTheNode(javaCodeGeneratorInfo, yangPluginConfig);
        javaCodeGeneratorInfo.getJavaFileInfo().setJavaAttributeName(javaCodeGeneratorInfo.getJavaFileInfo().getJavaName());
        javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) javaCodeGeneratorInfo));
    }
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPluginConfig.getCodeGenDir());
    javaCodeGeneratorInfo.getJavaFileInfo().setPluginConfig(yangPluginConfig);
}
#method_after
public static void updatePackageInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) {
    JavaFileInfoTranslator translator = info.getJavaFileInfo();
    if (info instanceof YangJavaAugmentTranslator) {
        updatePackageForAugmentInfo(info, config);
    } else {
        setNodeJavaName(info, config);
        translator.setJavaAttributeName(info.getJavaFileInfo().getJavaName());
        translator.setPackage(getCurNodePackage((YangNode) info));
    }
    updateCommonPackageInfo(translator, info, config);
}
#end_block

#method_before
private static void updatePackageForAugmentInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getAugmentClassName((YangJavaAugmentTranslator) javaCodeGeneratorInfo, yangPluginConfig));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getAugmentsNodePackage((YangNode) javaCodeGeneratorInfo, yangPluginConfig));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPluginConfig.getCodeGenDir());
    javaCodeGeneratorInfo.getJavaFileInfo().setPluginConfig(yangPluginConfig);
}
#method_after
private static void updatePackageForAugmentInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) {
    JavaFileInfoTranslator translator = info.getJavaFileInfo();
    translator.setJavaName(getAugmentClassName((YangJavaAugmentTranslator) info, config));
    translator.setPackage(getAugmentsNodePackage((YangNode) info, config));
    updateCommonPackageInfo(translator, info, config);
}
#end_block

#method_before
private static String getAugmentsNodePackage(YangNode yangNode, YangPluginConfig yangPluginConfig) {
    YangAugment augment = (YangAugment) yangNode;
    StringBuilder augmentPkg = new StringBuilder();
    augmentPkg.append(getCurNodePackage(augment));
    String pkg = PERIOD;
    for (YangAtomicPath atomicPath : augment.getTargetNode()) {
        pkg = pkg + getCamelCase(atomicPath.getNodeIdentifier().getName(), yangPluginConfig.getConflictResolver()) + PERIOD;
    }
    pkg = trimAtLast(pkg, PERIOD);
    augmentPkg.append(pkg.toLowerCase());
    return augmentPkg.toString();
}
#method_after
private static String getAugmentsNodePackage(YangNode yangNode, YangPluginConfig config) {
    YangAugment augment = (YangAugment) yangNode;
    StringBuilder augmentPkg = new StringBuilder();
    augmentPkg.append(getCurNodePackage(augment));
    StringBuilder pkg = new StringBuilder();
    pkg.append(PERIOD);
    for (YangAtomicPath atomicPath : augment.getTargetNode()) {
        pkg.append(getCamelCase(atomicPath.getNodeIdentifier().getName(), config.getConflictResolver())).append(PERIOD);
    }
    augmentPkg.append(trimAtLast(pkg.toString(), PERIOD).toLowerCase());
    return augmentPkg.toString();
}
#end_block

#method_before
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, String pkg) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPlugin.getConflictResolver()));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(pkg);
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
    javaCodeGeneratorInfo.getJavaFileInfo().setPluginConfig(yangPlugin);
}
#method_after
private static void updatePackageInfo(JavaCodeGeneratorInfo info, YangPluginConfig config, String pkg) {
    JavaFileInfoTranslator translator = info.getJavaFileInfo();
    translator.setJavaName(getCamelCase(((YangNode) info).getName(), config.getConflictResolver()));
    translator.setPackage(pkg);
    updateCommonPackageInfo(translator, info, config);
}
#end_block

#method_before
private static void createTempFragmentFile(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    javaCodeGeneratorInfo.setTempJavaCodeFragmentFiles(new TempJavaCodeFragmentFiles(javaCodeGeneratorInfo.getJavaFileInfo()));
}
#method_after
private static void createTempFragmentFile(JavaCodeGeneratorInfo info) throws IOException {
    info.setTempJavaCodeFragmentFiles(new TempJavaCodeFragmentFiles(info.getJavaFileInfo()));
}
#end_block

#method_before
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof RpcNotificationContainer) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().setRooNode(true);
        /*
             * Module / sub module node code generation.
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
        if (javaCodeGeneratorInfo instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        } else if (javaCodeGeneratorInfo instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(javaCodeGeneratorInfo, yangPluginConfig);
            }
        }
    }
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
        // Add operation type as an attribute.
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addOperationTypeToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((YangTypeHolder) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles().addEnumAttributeToTempFiles((YangNode) javaCodeGeneratorInfo, yangPluginConfig);
    } else if (javaCodeGeneratorInfo instanceof YangChoice) {
    /*Do nothing, only the interface needs to be generated*/
    } else {
        throw new TranslatorException("Unsupported Node Translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
}
#method_after
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles translator = info.getTempJavaCodeFragmentFiles();
    if (info instanceof RpcNotificationContainer) {
        getBeanFiles(info).setRootNode(true);
        /*
             * Module / sub module node code generation.
             */
        translator.getServiceTempFiles().addCurNodeLeavesInfoToTempFiles((YangNode) info, config);
        if (info instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) info).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(info, config);
            }
        } else if (info instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) info).getNotificationNodes().isEmpty()) {
                updateNotificationNodeInfo(info, config);
            }
        }
    }
    if (info instanceof YangLeavesHolder) {
        /*
             * Container
             * Case
             * Grouping
             * Input
             * List
             * Notification
             * Output
             */
        getBeanFiles(info).addCurNodeLeavesInfoToTempFiles((YangNode) info, config);
        // Add operation type as an attribute.
        getBeanFiles(info).addOperationTypeToTempFiles((YangNode) info, config);
    } else if (info instanceof YangTypeHolder) {
        /*
             * Typedef
             * Union
             */
        translator.addTypeInfoToTempFiles((YangTypeHolder) info, config);
    } else if (info instanceof YangJavaEnumerationTranslator) {
        /*
             * Enumeration
             */
        translator.getEnumTempFiles().addEnumAttributeToTempFiles((YangNode) info, config);
    } else if (!(info instanceof YangChoice)) {
        /*Do nothing, only the interface needs to be generated for choice*/
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
}
#end_block

#method_before
private static void generateTempFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("translation is not supported for " + "the node " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    createTempFragmentFile(javaCodeGeneratorInfo);
    updateTempFragmentFiles(javaCodeGeneratorInfo, yangPluginConfig);
}
#method_after
private static void generateTempFiles(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    createTempFragmentFile(info);
    updateTempFragmentFiles(info, config);
}
#end_block

#method_before
private static void updateNotificationNodeInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangJavaModuleTranslator) {
        for (YangNode notification : ((YangJavaModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes()) {
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEventFragmentFiles().addJavaSnippetOfEvent(notification, yangPluginConfig);
        }
    }
    if (javaCodeGeneratorInfo instanceof YangJavaSubModuleTranslator) {
        for (YangNode notification : ((YangJavaSubModuleTranslator) javaCodeGeneratorInfo).getNotificationNodes()) {
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getEventFragmentFiles().addJavaSnippetOfEvent(notification, yangPluginConfig);
        }
    }
}
#method_after
private static void updateNotificationNodeInfo(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    TempJavaCodeFragmentFiles translator = info.getTempJavaCodeFragmentFiles();
    if (info instanceof YangJavaModuleTranslator) {
        for (YangNode notification : ((YangJavaModuleTranslator) info).getNotificationNodes()) {
            translator.getEventFragmentFiles().addJavaSnippetOfEvent(notification, config);
        }
    }
    if (info instanceof YangJavaSubModuleTranslator) {
        for (YangNode notification : ((YangJavaSubModuleTranslator) info).getNotificationNodes()) {
            translator.getEventFragmentFiles().addJavaSnippetOfEvent(notification, config);
        }
    }
}
#end_block

#method_before
public static void generateCodeAndUpdateInParent(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("Invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    /*
         * Generate the Java files corresponding to the current node.
         */
    generateCodeOfAugmentableNode(javaCodeGeneratorInfo, yangPlugin);
    /*
         * Update the current nodes info in its parent nodes generated files.
         */
    addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance, yangPlugin);
}
#method_after
public static void generateCodeAndUpdateInParent(JavaCodeGeneratorInfo info, YangPluginConfig config, boolean isMultiInstance) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    /*
         * Generate the Java files corresponding to the current node.
         */
    generateCodeOfAugmentableNode(info, config);
    /*
         * Update the current nodes info in its parent nodes generated files.
         */
    addCurNodeInfoInParentTempFile((YangNode) info, isMultiInstance, config);
}
#end_block

#method_before
public static void generateCodeOfAugmentableNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    generateCodeOfNode(javaCodeGeneratorInfo, yangPlugin);
    TempJavaCodeFragmentFiles tempJavaCodeFragmentFiles = javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles();
    if (javaCodeGeneratorInfo instanceof YangCase) {
        YangNode parent = ((YangCase) javaCodeGeneratorInfo).getParent();
        JavaQualifiedTypeInfoTranslator parentsInfo = getQualifierInfoForCasesParent(parent, yangPlugin);
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaExtendsListHolder().addToExtendsList(parentsInfo, (YangNode) javaCodeGeneratorInfo, tempJavaCodeFragmentFiles.getBeanTempFiles());
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().getBeanTempFiles().addParentInfoInCurNodeTempFile((YangNode) javaCodeGeneratorInfo, yangPlugin);
    }
}
#method_after
public static void generateCodeOfAugmentableNode(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    generateCodeOfNode(info, config);
    TempJavaCodeFragmentFiles tempFiles = info.getTempJavaCodeFragmentFiles();
    if (info instanceof YangCase) {
        YangNode parent = ((YangCase) info).getParent();
        JavaQualifiedTypeInfoTranslator typeInfo = getQualifierInfoForCasesParent(parent, config);
        getBeanFiles(info).getJavaExtendsListHolder().addToExtendsList(typeInfo, (YangNode) info, tempFiles.getBeanTempFiles());
        getBeanFiles(info).addParentInfoInCurNodeTempFile((YangNode) info, config);
    }
}
#end_block

#method_before
public static JavaQualifiedTypeInfoTranslator getQualifierInfoForCasesParent(YangNode parent, YangPluginConfig yangPluginConfig) {
    String parentName;
    String parentPkg;
    JavaQualifiedTypeInfoTranslator parentsInfo = new JavaQualifiedTypeInfoTranslator();
    JavaFileInfoTranslator parentInfo;
    if (parent instanceof YangChoice) {
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    } else {
        parent = ((YangAugment) parent).getAugmentedNode();
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    }
    if (parentInfo.getPackage() != null) {
        parentName = getCapitalCase(parentInfo.getJavaName());
        parentPkg = parentInfo.getPackage();
    } else {
        parentName = getCapitalCase(getCamelCase(parent.getName(), yangPluginConfig.getConflictResolver()));
        parentPkg = getNodesPackage(parent, yangPluginConfig);
    }
    parentsInfo.setClassInfo(parentName);
    parentsInfo.setPkgInfo(parentPkg);
    return parentsInfo;
}
#method_after
public static JavaQualifiedTypeInfoTranslator getQualifierInfoForCasesParent(YangNode parent, YangPluginConfig config) {
    String parentName;
    String parentPkg;
    JavaFileInfoTranslator parentInfo;
    if (parent instanceof YangChoice) {
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    } else {
        parent = ((YangAugment) parent).getAugmentedNode();
        parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    }
    if (parentInfo.getPackage() != null) {
        parentName = getCapitalCase(parentInfo.getJavaName());
        parentPkg = parentInfo.getPackage();
    } else {
        parentName = getCapitalCase(getCamelCase(parent.getName(), config.getConflictResolver()));
        parentPkg = getNodesPackage(parent, config);
    }
    JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = new JavaQualifiedTypeInfoTranslator();
    qualifiedTypeInfo.setClassInfo(parentName);
    qualifiedTypeInfo.setPkgInfo(parentPkg);
    return qualifiedTypeInfo;
}
#end_block

#method_before
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPluginConfig);
    generateTempFiles(javaCodeGeneratorInfo, yangPluginConfig);
}
#method_after
public static void generateCodeOfNode(JavaCodeGeneratorInfo info, YangPluginConfig config) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    updatePackageInfo(info, config);
    generateTempFiles(info, config);
}
#end_block

#method_before
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPluginConfig, String rootPkg) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("invalid node for translation " + javaCodeGeneratorInfo.getLineNumber() + " at " + javaCodeGeneratorInfo.getCharPosition() + " in " + javaCodeGeneratorInfo.getFileName());
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPluginConfig, rootPkg);
    if (isRpcChildNodePresent((YangNode) javaCodeGeneratorInfo)) {
        javaCodeGeneratorInfo.getJavaFileInfo().addGeneratedFileTypes(GENERATE_SERVICE_AND_MANAGER);
    }
    generateTempFiles(javaCodeGeneratorInfo, yangPluginConfig);
}
#method_after
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo info, YangPluginConfig config, String rootPkg) throws IOException {
    if (!(info instanceof YangNode)) {
        throw new TranslatorException(getErrorMsgForCodeGenerator(INVALID_TRANSLATION_NODE, info));
    }
    updatePackageInfo(info, config, rootPkg);
    if (isRpcChildNodePresent((YangNode) info)) {
        info.getJavaFileInfo().addGeneratedFileTypes(GENERATE_SERVICE_AND_MANAGER);
    }
    generateTempFiles(info, config);
}
#end_block

#method_before
public static String getCurNodePackage(YangNode curNode) {
    String pkg;
    if (!(curNode instanceof JavaFileInfoContainer) || curNode.getParent() == null) {
        throw new TranslatorException("missing parent node to get " + "current node's package " + curNode.getName() + " in " + curNode.getLineNumber() + " at " + curNode.getCharPosition() + " in " + curNode.getFileName());
    }
    YangNode parentNode = DataModelUtils.getParentNodeInGenCode(curNode);
    if (!(parentNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException("missing parent java node to get " + "current node's package " + curNode.getName() + " in " + curNode.getLineNumber() + " at " + curNode.getCharPosition() + " in " + curNode.getFileName());
    }
    JavaFileInfoTranslator parentJavaFileHandle = ((JavaFileInfoContainer) parentNode).getJavaFileInfo();
    pkg = parentJavaFileHandle.getPackage() + PERIOD + parentJavaFileHandle.getJavaName();
    return pkg.toLowerCase();
}
#method_after
public static String getCurNodePackage(YangNode curNode) throws TranslatorException {
    String pkg;
    if (!(curNode instanceof JavaFileInfoContainer) || curNode.getParent() == null) {
        throw new TranslatorException(getErrorMsg(INVALID_NODE, curNode));
    }
    YangNode parentNode = DataModelUtils.getParentNodeInGenCode(curNode);
    if (!(parentNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException(getErrorMsg(INVALID_PARENT_NODE, curNode));
    }
    JavaFileInfoTranslator handle = ((JavaFileInfoContainer) parentNode).getJavaFileInfo();
    pkg = handle.getPackage() + PERIOD + handle.getJavaName();
    return pkg.toLowerCase();
}
#end_block

#method_before
public static boolean isRootNodesCodeGenRequired(YangNode node) {
    YangLeavesHolder holder = (YangLeavesHolder) node;
    if (holder.getListOfLeaf().isEmpty()) {
        if (holder.getListOfLeafList().isEmpty()) {
            YangNode tempNode = node.getChild();
            if (tempNode == null) {
                return false;
            }
            while (tempNode != null) {
                if (!(tempNode instanceof YangTranslatorOperatorNode)) {
                    return true;
                }
                tempNode = tempNode.getNextSibling();
            }
            return false;
        } else {
            return true;
        }
    } else {
        return true;
    }
}
#method_after
public static boolean isRootNodesCodeGenRequired(YangNode node) {
    return isNodeCodeGenRequired(node, true);
}
#end_block

#method_before
public static boolean isGetSetOfRootNodeRequired(YangNode curNode) {
    YangLeavesHolder holder = (YangLeavesHolder) curNode;
    if (holder.getListOfLeaf().isEmpty()) {
        if (holder.getListOfLeafList().isEmpty()) {
            curNode = curNode.getChild();
            if (curNode == null) {
                return false;
            }
            while (curNode != null) {
                if (!(curNode instanceof YangAugment)) {
                    return true;
                }
                curNode = curNode.getNextSibling();
            }
            return false;
        } else {
            return true;
        }
    } else {
        return true;
    }
}
#method_after
public static boolean isGetSetOfRootNodeRequired(YangNode node) {
    return isNodeCodeGenRequired(node, false);
}
#end_block

#method_before
public static String getNodesPackage(YangNode node, YangPluginConfig yangPluginConfig) {
    List<String> clsInfo = new ArrayList<>();
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, yangPluginConfig));
        } else {
            clsInfo.add(getCamelCase(node.getName(), yangPluginConfig.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getNameSpace(), module.getRevision(), yangPluginConfig.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), yangPluginConfig.getConflictResolver()));
    }
    String concat = "";
    for (int i = 1; i <= clsInfo.size(); i++) {
        concat = concat + "." + clsInfo.get(clsInfo.size() - i);
    }
    pkg.append(concat);
    return pkg.toString().toLowerCase();
}
#method_after
public static String getNodesPackage(YangNode node, YangPluginConfig config) {
    List<String> clsInfo = new ArrayList<>();
    while (node.getParent() != null) {
        if (node instanceof YangJavaAugmentTranslator) {
            clsInfo.add(getAugmentClassName((YangAugment) node, config));
        } else {
            clsInfo.add(getCamelCase(node.getName(), config.getConflictResolver()));
        }
        node = node.getParent();
    }
    StringBuilder pkg = new StringBuilder();
    if (node instanceof YangJavaModuleTranslator) {
        YangJavaModuleTranslator module = (YangJavaModuleTranslator) node;
        pkg.append(getRootPackage(module.getVersion(), module.getNameSpace(), module.getRevision(), config.getConflictResolver()));
    } else if (node instanceof YangJavaSubModuleTranslator) {
        YangJavaSubModuleTranslator subModule = (YangJavaSubModuleTranslator) node;
        pkg.append(getRootPackage(subModule.getVersion(), subModule.getNameSpaceFromModule(), subModule.getRevision(), config.getConflictResolver()));
    }
    pkg.append(EMPTY_STRING);
    int size = clsInfo.size();
    for (int i = size - 1; i >= 0; i--) {
        pkg.append(PERIOD).append(clsInfo.get(i));
    }
    return pkg.toString().toLowerCase();
}
#end_block

#method_before
private static String getAugmentClassName(YangAugment augment, YangPluginConfig yangPluginConfig) {
    YangNodeIdentifier yangNodeIdentifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String name = getCapitalCase(getCamelCase(yangNodeIdentifier.getName(), yangPluginConfig.getConflictResolver()));
    if (yangNodeIdentifier.getPrefix() != null) {
        return AUGMENTED + getCapitalCase(getCamelCase(yangNodeIdentifier.getPrefix(), yangPluginConfig.getConflictResolver())) + name;
    } else {
        return AUGMENTED + name;
    }
}
#method_after
private static String getAugmentClassName(YangAugment augment, YangPluginConfig config) {
    YangNodeIdentifier identifier = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier();
    String name = getCapitalCase(getCamelCase(identifier.getName(), config.getConflictResolver()));
    if (identifier.getPrefix() != null) {
        return AUGMENTED + getCapitalCase(getCamelCase(identifier.getPrefix(), config.getConflictResolver())) + name;
    }
    return AUGMENTED + name;
}
#end_block

#method_before
@Test
public void processOutputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("output"));
    assertThat(yangOutput.getJavaGenerationName(), is("activate-software-image_output"));
    ListIterator<YangLeaf> leafIterator = yangOutput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangOutput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements().getMaxElement(), is(10));
    assertThat(yangList.getMinElements().getMinElement(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#method_after
@Test
public void processOutputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("output"));
    ListIterator<YangLeaf> leafIterator = yangOutput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangOutput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements().getMaxElement(), is(10));
    assertThat(yangList.getMinElements().getMinElement(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#end_block

#method_before
@Test
public void processOutputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("output"));
    assertThat(yangOutput.getJavaGenerationName(), is("activate-software-image_output"));
    YangTypeDef typeDef = (YangTypeDef) yangOutput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#method_after
@Test
public void processOutputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("output"));
    YangTypeDef typeDef = (YangTypeDef) yangOutput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#end_block

#method_before
@Test
public void processInputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("input"));
    assertThat(yangInput.getJavaGenerationName(), is("activate-software-image_input"));
    ListIterator<YangLeaf> leafIterator = yangInput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangInput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements().getMaxElement(), is(10));
    assertThat(yangList.getMinElements().getMinElement(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#method_after
@Test
public void processInputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("input"));
    ListIterator<YangLeaf> leafIterator = yangInput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangInput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements().getMaxElement(), is(10));
    assertThat(yangList.getMinElements().getMinElement(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#end_block

#method_before
@Test
public void processInputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("input"));
    assertThat(yangInput.getJavaGenerationName(), is("activate-software-image_input"));
    YangTypeDef typeDef = (YangTypeDef) yangInput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#method_after
@Test
public void processInputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("input"));
    YangTypeDef typeDef = (YangTypeDef) yangInput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#end_block

#method_before
static String getImportText(JavaQualifiedTypeInfoTranslator importInfo) {
    return IMPORT + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
}
#method_after
static String getImportText(JavaQualifiedTypeInfoTranslator importInfo) {
    return getImportString(importInfo.getPkgInfo(), importInfo.getClassInfo());
}
#end_block

#method_before
public static String getJavaAttributeDefinition(String javaAttributeTypePkg, String javaAttributeType, String javaAttributeName, boolean isList, String attributeAccessType, YangCompilerAnnotation compilerAnnotation) {
    String attributeDefinition = attributeAccessType + SPACE;
    if (!isList) {
        if (javaAttributeTypePkg != null) {
            attributeDefinition = attributeDefinition + javaAttributeTypePkg + PERIOD;
        }
        attributeDefinition = attributeDefinition + javaAttributeType + SPACE + javaAttributeName + SEMI_COLAN + NEW_LINE;
    } else {
        if (compilerAnnotation != null && compilerAnnotation.getYangAppDataStructure() != null) {
            switch(compilerAnnotation.getYangAppDataStructure().getDataStructure()) {
                case QUEUE:
                    {
                        attributeDefinition = attributeDefinition + QUEUE + DIAMOND_OPEN_BRACKET;
                        break;
                    }
                case SET:
                    {
                        attributeDefinition = attributeDefinition + SET + DIAMOND_OPEN_BRACKET;
                        break;
                    }
                default:
                    {
                        attributeDefinition = attributeDefinition + LIST + DIAMOND_OPEN_BRACKET;
                    }
            }
        } else {
            attributeDefinition = attributeDefinition + LIST + DIAMOND_OPEN_BRACKET;
        }
        if (javaAttributeTypePkg != null) {
            attributeDefinition = attributeDefinition + javaAttributeTypePkg + PERIOD;
        }
        attributeDefinition = attributeDefinition + javaAttributeType;
        if (compilerAnnotation != null && compilerAnnotation.getYangAppDataStructure() != null) {
            switch(compilerAnnotation.getYangAppDataStructure().getDataStructure()) {
                default:
                    {
                        attributeDefinition = attributeDefinition + DIAMOND_CLOSE_BRACKET + SPACE + javaAttributeName + SEMI_COLAN + NEW_LINE;
                    }
            }
        } else {
            attributeDefinition = attributeDefinition + DIAMOND_CLOSE_BRACKET + SPACE + javaAttributeName + SEMI_COLAN + NEW_LINE;
        }
    }
    return attributeDefinition;
}
#method_after
public static String getJavaAttributeDefinition(String typePkg, String attrType, String attrName, boolean isList, String accessType, YangCompilerAnnotation annotation) {
    StringBuilder attrDef = new StringBuilder(FOUR_SPACE_INDENTATION);
    attrDef.append(accessType).append(SPACE);
    if (!isList) {
        if (typePkg != null) {
            attrDef.append(typePkg).append(PERIOD);
        }
        attrDef.append(attrType).append(SPACE).append(attrName).append(SEMI_COLON).append(NEW_LINE);
    } else {
        // Add starting definition.
        addAttrStartDef(annotation, attrDef);
        if (typePkg != null) {
            attrDef.append(typePkg).append(PERIOD);
        }
        attrDef.append(attrType);
        // Add ending definition.
        addAttrEndDef(annotation, attrDef, attrName);
    }
    return attrDef.toString();
}
#end_block

#method_before
public static String generateEnumAttributeString(String name, int value) {
    String enumName = getEnumJavaAttribute(name);
    return NEW_LINE + enumJavaDocForInnerClass(name) + EIGHT_SPACE_INDENTATION + enumName.toUpperCase() + OPEN_PARENTHESIS + value + CLOSE_PARENTHESIS + COMMA + NEW_LINE;
}
#method_after
public static String generateEnumAttributeString(String name, int value) {
    String enumName = getEnumJavaAttribute(name);
    return enumJavaDocForInnerClass(name) + EIGHT_SPACE_INDENTATION + enumName.toUpperCase() + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, value + EMPTY_STRING, null) + COMMA + NEW_LINE;
}
#end_block

#method_before
public static String generateEnumAttributeStringWithSchemaName(String name, int value, YangPluginConfig pluginConfig) {
    String enumName = getEnumJavaAttribute(name);
    return NEW_LINE + getJavaDoc(ENUM_ATTRIBUTE, name, false, pluginConfig, null) + FOUR_SPACE_INDENTATION + enumName.toUpperCase() + OPEN_PARENTHESIS + value + COMMA + SPACE + QUOTES + name + QUOTES + CLOSE_PARENTHESIS + COMMA + NEW_LINE;
}
#method_after
public static String generateEnumAttributeStringWithSchemaName(String name, int value) {
    String enumName = getEnumJavaAttribute(name);
    String str = value + COMMA + SPACE + QUOTES + name + QUOTES;
    return getJavaDoc(ENUM_ATTRIBUTE, name, false, null) + FOUR_SPACE_INDENTATION + enumName.toUpperCase() + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, str, null) + COMMA + NEW_LINE;
}
#end_block

#method_before
static String getEventEnumTypeStart() {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + ENUM + SPACE + TYPE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getEventEnumTypeStart() {
    return NEW_LINE + FOUR_SPACE_INDENTATION + getDefaultDefinition(ENUM, TYPE, PUBLIC);
}
#end_block

#method_before
public static void addListenersImport(YangNode curNode, List<String> imports, boolean operation, String classInfo) {
    String thisImport;
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    if (classInfo.equals(LISTENER_SERVICE)) {
        thisImport = tempJavaServiceFragmentFiles.getJavaImportData().getListenerServiceImport();
        performOperationOnImports(imports, thisImport, operation);
    } else {
        thisImport = tempJavaServiceFragmentFiles.getJavaImportData().getListenerRegistryImport();
        performOperationOnImports(imports, thisImport, operation);
    }
}
#method_after
public static void addListenersImport(YangNode curNode, List<String> imports, Operation operation) {
    String thisImport;
    TempJavaServiceFragmentFiles tempFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    thisImport = tempFiles.getJavaImportData().getListenerServiceImport();
    performOperationOnImports(imports, thisImport, operation);
}
#end_block

#method_before
private static List<String> performOperationOnImports(List<String> imports, String curImport, boolean operation) {
    if (operation) {
        imports.add(curImport);
    } else {
        imports.remove(curImport);
    }
    sortImports(imports);
    return imports;
}
#method_after
private static List<String> performOperationOnImports(List<String> imports, String curImport, Operation operation) {
    switch(operation) {
        case ADD:
            imports.add(curImport);
            break;
        case REMOVE:
            imports.remove(curImport);
            break;
        default:
            throw new TranslatorException("Invalid operation type");
    }
    sortImports(imports);
    return imports;
}
#end_block

#method_before
static String getEnumsValueAttribute(String className) {
    return NEW_LINE + FOUR_SPACE_INDENTATION + PRIVATE + SPACE + INT + SPACE + getSmallCase(className) + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + PRIVATE + SPACE + STRING_DATA_TYPE + SPACE + SCHEMA_NAME + SEMI_COLAN + NEW_LINE;
}
#method_after
static String getEnumsValueAttribute(String className) {
    return getJavaAttributeDefinition(null, INT, className, false, PRIVATE, null) + getJavaAttributeDefinition(null, STRING_DATA_TYPE, SCHEMA_NAME, false, PRIVATE, null);
}
#end_block

#method_before
static String addAugmentationAttribute() {
    return NEW_LINE + FOUR_SPACE_INDENTATION + PROTECTED + SPACE + MAP + DIAMOND_OPEN_BRACKET + CLASS_STRING + DIAMOND_OPEN_BRACKET + QUESTION_MARK + DIAMOND_CLOSE_BRACKET + COMMA + SPACE + OBJECT_STRING + DIAMOND_CLOSE_BRACKET + SPACE + getSmallCase(YANG_AUGMENTED_INFO) + MAP + SPACE + EQUAL + SPACE + NEW + SPACE + HASH_MAP + DIAMOND_OPEN_BRACKET + DIAMOND_CLOSE_BRACKET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN;
}
#method_after
static String addAugmentationAttribute() {
    String[] array = { NEW_LINE, SEMI_COLON };
    return trimAtLast(getJavaAttributeDefinition(null, getAugmentMapTypeString(), YANG_AUGMENTED_INFO_LOWER_CASE + MAP, false, PROTECTED, null), array) + SPACE + EQUAL + SPACE + NEW + SPACE + HASH_MAP + brackets(OPEN_CLOSE_DIAMOND, null, null) + brackets(OPEN_CLOSE_BRACKET, null, null) + signatureClose();
}
#end_block

#method_before
static String addStaticAttributeIntRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + INT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + INT_MAX_RANGE_ATTR;
    } else {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT_MAX_RANGE_ATTR;
    }
}
#method_after
static String addStaticAttributeIntRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return getTypeConflictAttributeStrings(modifier, INT_MIN_RANGE_ATTR, INT_MAX_RANGE_ATTR);
    }
    return getTypeConflictAttributeStrings(modifier, UINT_MIN_RANGE_ATTR, UINT_MAX_RANGE_ATTR);
}
#end_block

#method_before
static String addStaticAttributeLongRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + LONG_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + LONG_MAX_RANGE_ATTR;
    } else {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + ULONG_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + ULONG_MAX_RANGE_ATTR;
    }
}
#method_after
static String addStaticAttributeLongRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return getTypeConflictAttributeStrings(modifier, LONG_MIN_RANGE_ATTR, LONG_MAX_RANGE_ATTR);
    }
    return getTypeConflictAttributeStrings(modifier, ULONG_MIN_RANGE_ATTR, ULONG_MAX_RANGE_ATTR);
}
#end_block

#method_before
static String addStaticAttributeShortRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + SHORT_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + SHORT_MAX_RANGE_ATTR;
    } else {
        return NEW_LINE + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT8_MIN_RANGE_ATTR + FOUR_SPACE_INDENTATION + modifier + SPACE + UINT8_MAX_RANGE_ATTR;
    }
}
#method_after
static String addStaticAttributeShortRange(String modifier, boolean addFirst) {
    if (addFirst) {
        return getTypeConflictAttributeStrings(modifier, SHORT_MIN_RANGE_ATTR, SHORT_MAX_RANGE_ATTR);
    }
    return getTypeConflictAttributeStrings(modifier, UINT8_MIN_RANGE_ATTR, UINT8_MAX_RANGE_ATTR);
}
#end_block

#method_before
static String getOperationTypeEnum() {
    return "\n" + "    /**\n" + "     * Specify the node specific operation in protocols like NETCONF.\n" + "     * Applicable in protocol edit operation, not applicable in query operation\n" + "     */\n" + "    public enum OnosYangNodeOperationType {\n" + "        MERGE,\n" + "        REPLACE,\n" + "        CREATE,\n" + "        DELETE,\n" + "        REMOVE,\n" + "        NONE\n" + "    }\n";
}
#method_after
static String getOperationTypeEnum() {
    return "    /**\n" + "     * Specify the node specific operation in protocols " + "like NETCONF.\n" + "     * Applicable in protocol edit operation, not applicable" + " in query operation\n" + "     */\n" + "    public enum OnosYangNodeOperationType {\n" + "        MERGE,\n" + "        REPLACE,\n" + "        CREATE,\n" + "        DELETE,\n" + "        REMOVE,\n" + "        NONE\n" + "    }\n";
}
#end_block

#method_before
static String getYangAugmentedMapObjectForConstruct() {
    return "        this.yangAugmentedInfoMap = builderObject.yangAugmentedInfoMap();\n";
}
#method_after
static String getYangAugmentedMapObjectForConstruct() {
    return "        this.yangAugmentedInfoMap = builderObject" + ".yangAugmentedInfoMap();\n";
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    // Generate ENUM interface
    insertDataIntoJavaFile(file, getOperationTypeEnum());
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (isLeavesPresent) {
                insertDataIntoJavaFile(file, NEW_LINE + getInterfaceLeafIdEnumSignature(className) + NEW_LINE + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path), COMMA, SEMI_COLAN), NEW_LINE) + NEW_LINE + NEW_LINE + getInterfaceLeafIdEnumMethods());
            }
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, javaFileInfo.getPluginConfig());
        methods.add(NEW_LINE + processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(NEW_LINE + processSubtreeFilteringInterface(className));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + isLeafValueSetInterface());
        methods.add(NEW_LINE + isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    // Generate ENUM interface
    insertDataIntoJavaFile(file, getOperationTypeEnum());
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        // Add getter methods to interface file.
        try {
            // Leaf identifier enum.
            if (leavesPresent) {
                insertDataIntoJavaFile(file, getInterfaceLeafIdEnumSignature(className) + trimAtLast(replaceLast(getDataFromTempFileHandle(LEAF_IDENTIFIER_ENUM_ATTRIBUTES_MASK, getBeanFiles(curNode), path), COMMA, SEMI_COLON), NEW_LINE) + getInterfaceLeafIdEnumMethods());
            }
            insertDataIntoJavaFile(file, NEW_LINE);
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, INTERFACE));
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface());
    }
    if (curNode instanceof YangCase) {
        YangNode caseParent = curNode.getParent();
        JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifierInfoForCasesParent(caseParent, fileInfo.getPluginConfig());
        methods.add(processSubtreeFilteringInterface(qualifiedTypeInfo.getClassInfo()));
    } else {
        methods.add(processSubtreeFilteringInterface(className));
    }
    if (leavesPresent) {
        methods.add(isLeafValueSetInterface());
        methods.add(isSelectLeafSetInterface());
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list method.
            methods.add(NEW_LINE);
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder interface file generation");
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface(javaFileInfo.getPluginConfig()));
    }
    if (isLeavesPresent) {
        methods.add(NEW_LINE + setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (attrPresent) {
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, getBeanFiles(curNode), path));
            // Add to list method.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ADD_TO_LIST_INTERFACE_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_INTERFACE));
        }
    }
    if (curNode instanceof YangAugmentableNode && !(curNode instanceof YangChoice)) {
        methods.add(getAddAugmentInfoMethodInterface());
        methods.add(getYangAugmentInfoInterface());
        methods.add(getYangAugmentInfoMapInterface());
    }
    if (leavesPresent) {
        methods.add(setSelectLeafSetInterface(className));
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
/**
 * Returns generated builder class file for current node.
 *
 * @param file          file
 * @param curNode       current YANG node
 * @param isAttrPresent if any attribute is present or not
 * @return builder class file
 * @throws IOException when fails to write in file
 */
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            // Add operation attribute methods.
            if (isLeavesPresent) {
                methods.add(getOperationAttributesGetters() + NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl(curNode));
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig, curNode));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#method_after
public static File generateBuilderClassFile(File file, YangNode curNode, boolean attrPresent) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    String className = getCapitalCase(fileInfo.getJavaName());
    boolean isRootNode = false;
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        isRootNode = true;
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (attrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(ATTRIBUTES_MASK, getBeanFiles(curNode), path));
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
        if (leavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, getBeanFiles(curNode), path));
            // Add to list impl method.
            methods.add(getDataFromTempFileHandle(ADD_TO_LIST_IMPL_MASK, getBeanFiles(curNode), path));
            insertDataIntoJavaFile(file, NEW_LINE);
            // Add operation attribute methods.
            if (leavesPresent) {
                methods.add(getOperationAttributesGetters());
                insertDataIntoJavaFile(file, NEW_LINE);
                methods.add(getSetterForSelectLeaf(className, isRootNode));
            }
        } catch (IOException e) {
            throw new IOException(getErrorMsg(className, BUILDER_CLASS));
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    methods.add(addDefaultConstructor(curNode, PUBLIC, BUILDER));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return file;
}
#end_block

#method_before
public static File generateDefaultClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    boolean isLeavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        isLeavesPresent = leavesHolder.getListOfLeaf() != null && !leavesHolder.getListOfLeaf().isEmpty() || leavesHolder.getListOfLeafList() != null && !leavesHolder.getListOfLeafList().isEmpty();
    } else {
        isLeavesPresent = false;
    }
    boolean isRootNode = false;
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        opParamClassName = className + OP_PARAM;
        isRootNode = true;
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
        // Add operation attributes
        if (isLeavesPresent) {
            insertDataIntoJavaFile(file, getOperationAttributes());
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            if (isRootNode) {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(opParamClassName) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            } else {
                methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            }
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files " + "for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig, isRootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        if (isLeavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        if (curNode instanceof YangAugmentableNode) {
            constructor = constructor + getYangAugmentedMapObjectForConstruct();
        }
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        // add is filter content match.
        String augmentableSubTreeFiltering = "";
        if (curNode instanceof YangAugmentableNode) {
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(getProcessSubtreeFilteringStart(curNode, pluginConfig) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd());
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                methods.add(getProcessLeafSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                methods.add(getProcessLeafListSubtreeFiltering(curNode, pluginConfig, path));
            }
        }
        if (curNode.getChild() != null) {
            methods.add(getProcessChildNodeSubtreeFiltering(curNode, pluginConfig, path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PROTECTED, DEFAULT, pluginConfig, curNode));
    methods.add(builderMethod(className) + NEW_LINE);
    if (isLeavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateDefaultClassFile(File file, YangNode curNode, boolean attrPresent, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    boolean leavesPresent;
    YangLeavesHolder leavesHolder;
    if (curNode instanceof YangLeavesHolder) {
        leavesHolder = (YangLeavesHolder) curNode;
        leavesPresent = leavesPresent(leavesHolder);
    } else {
        leavesPresent = false;
    }
    boolean rootNode = false;
    String className = getCapitalCase(fileInfo.getJavaName());
    String opParamClassName = className;
    String path;
    if (curNode instanceof RpcNotificationContainer) {
        opParamClassName = className + OP_PARAM;
        rootNode = true;
        path = fileInfo.getPluginConfig().getCodeGenDir() + fileInfo.getPackageFilePath();
    } else {
        path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, DEFAULT_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (attrPresent) {
        addDefaultClassAttributeInfo(file, curNode, className, opParamClassName, path, methods, leavesPresent, rootNode);
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getYangAugmentInfoImpl());
        methods.add(getYangAugmentInfoMapImpl());
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, rootNode);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, getBeanFiles(curNode), path);
        if (leavesPresent) {
            constructor = constructor + getOperationAttributeForConstructor();
        }
        String augmentableSubTreeFiltering = EMPTY_STRING;
        if (curNode instanceof YangAugmentableNode) {
            constructor = constructor + getYangAugmentedMapObjectForConstruct();
            // add is filter content match.
            augmentableSubTreeFiltering = getAugmentableSubTreeFiltering();
        }
        methods.add(constructor + methodClose(FOUR_SPACE));
        methods.add(getProcessSubtreeFilteringStart(curNode, config) + getProcessSubtreeFunctionBody(curNode) + augmentableSubTreeFiltering + getProcessSubTreeFilteringEnd());
        if (curNode instanceof YangLeavesHolder) {
            if (((YangLeavesHolder) curNode).getListOfLeaf() != null && !((YangLeavesHolder) curNode).getListOfLeaf().isEmpty()) {
                methods.add(getProcessLeafSubtreeFiltering(curNode, config, path));
            }
            if (((YangLeavesHolder) curNode).getListOfLeafList() != null && !((YangLeavesHolder) curNode).getListOfLeafList().isEmpty()) {
                methods.add(getProcessLeafListSubtreeFiltering(curNode, config, path));
            }
        }
        if (curNode.getChild() != null) {
            methods.add(getProcessChildNodeSubtreeFiltering(curNode, config, path));
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, IMPL_CLASS));
    }
    methods.add(addDefaultConstructor(curNode, PROTECTED, DEFAULT));
    methods.add(builderMethod(className));
    if (leavesPresent) {
        methods.add(getOperationAttributesGetters());
        methods.add(getGettersForValueAndSelectLeaf());
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(BINARY)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(BITS)) {
            JavaQualifiedTypeInfoTranslator qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if ((type.getDataType().equals(YangDataTypes.DERIVED)) && (((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType().equals(YangDataTypes.IDENTITYREF))) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (type.getDataType().equals(YangDataTypes.IDENTITYREF)) {
            yangDataTypes = YangDataTypes.IDENTITYREF;
        }
        if (!yangDataTypes.equals(YangDataTypes.IDENTITYREF)) {
            methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file " + "generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(fileInfo.getJavaName());
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    YangDataTypes yangDataTypes = type.getDataType();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(ATTRIBUTES_MASK, getTypeFiles(curNode), path));
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, TYPEDEF_CLASS));
    }
    // Default constructor.
    methods.add(addDefaultConstructor(curNode, PRIVATE, EMPTY_STRING));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, getTypeFiles(curNode), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, getTypeFiles(curNode), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getTypeFiles(curNode), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, getTypeFiles(curNode), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, getTypeFiles(curNode), path)));
        // To string method.
        addTypedefToString(curNode, methods, path, type);
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        if (type.getDataType() == DERIVED && ((YangDerivedInfo) type.getDataTypeExtendedInfo()).getEffectiveBuiltInType() == IDENTITYREF) {
            yangDataTypes = IDENTITYREF;
        }
        if (type.getDataType() == IDENTITYREF) {
            yangDataTypes = IDENTITYREF;
        }
        if (yangDataTypes != IDENTITYREF) {
            methods.add(getFromStringMethodSignature(className) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, TYPEDEF_CLASS));
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempJavaTypeFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    boolean isIntConflict = false;
    boolean isLongConflict = false;
    boolean isShortConflict = false;
    JavaAttributeInfo intAttr = tempJavaTypeFragmentFiles.getIntAttribute();
    if (intAttr == null) {
        intAttr = tempJavaTypeFragmentFiles.getUIntAttribute();
    }
    JavaAttributeInfo longAttr = tempJavaTypeFragmentFiles.getLongAttribute();
    if (longAttr == null) {
        longAttr = tempJavaTypeFragmentFiles.getULongAttribute();
    }
    JavaAttributeInfo shortAttr = tempJavaTypeFragmentFiles.getShortAttribute();
    if (shortAttr == null) {
        shortAttr = tempJavaTypeFragmentFiles.getUInt8Attribute();
    }
    if (intAttr != null) {
        isIntConflict = intAttr.isIntConflict();
    }
    if (longAttr != null) {
        isLongConflict = longAttr.isLongConflict();
    }
    if (shortAttr != null) {
        isShortConflict = shortAttr.isShortConflict();
    }
    if (isLongConflict) {
        imports.add(tempJavaTypeFragmentFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        if (isIntConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeIntRange(PRIVATE, tempJavaTypeFragmentFiles.getIntIndex() < tempJavaTypeFragmentFiles.getUIntIndex()));
        }
        if (isLongConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeLongRange(PRIVATE, tempJavaTypeFragmentFiles.getLongIndex() < tempJavaTypeFragmentFiles.getULongIndex()));
        }
        if (isShortConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeShortRange(PRIVATE, tempJavaTypeFragmentFiles.getShortIndex() < tempJavaTypeFragmentFiles.getUInt8Index()));
        }
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig, curNode));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of string method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        // From string method.
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        if (isIntConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
        if (isLongConflict) {
            methods.add(getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
        if (isShortConflict && !isIntConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    String className = getCapitalCase(fileInfo.getJavaName());
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    boolean intConflict = false;
    boolean longConflict = false;
    boolean shortConflict = false;
    JavaAttributeInfo intAttr = tempFiles.getIntAttribute();
    if (intAttr == null) {
        intAttr = tempFiles.getUIntAttribute();
    }
    JavaAttributeInfo longAttr = tempFiles.getLongAttribute();
    if (longAttr == null) {
        longAttr = tempFiles.getULongAttribute();
    }
    JavaAttributeInfo shortAttr = tempFiles.getShortAttribute();
    if (shortAttr == null) {
        shortAttr = tempFiles.getUInt8Attribute();
    }
    if (intAttr != null) {
        intConflict = intAttr.isIntConflict();
    }
    if (longAttr != null) {
        longConflict = longAttr.isLongConflict();
    }
    if (shortAttr != null) {
        shortConflict = shortAttr.isShortConflict();
    }
    if (longConflict) {
        imports.add(tempFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        addUnionClassAttributeInfo(file, curNode, intConflict, longConflict, shortConflict, path, tempFiles);
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, UNION_CLASS));
    }
    // Default constructor.
    methods.add(addDefaultConstructor(curNode, PRIVATE, EMPTY_STRING));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, getTypeFiles(curNode), path));
        // Of string method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, getTypeFiles(curNode), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, getTypeFiles(curNode), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, getTypeFiles(curNode), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, getTypeFiles(curNode), path)));
        // To string method.
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, getTypeFiles(curNode), path) + getToStringMethodClose());
        // From string method.
        methods.add(getFromStringMethodSignature(className) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, getTypeFiles(curNode), path) + getFromStringMethodClose());
        if (intConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
        if (longConflict) {
            methods.add(getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
        if (shortConflict && !intConflict) {
            methods.add(getRangeValidatorMethodForUnion(INT));
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, UNION_CLASS));
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class " + "file generation");
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig, null) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    insertDataIntoJavaFile(file, getEnumsOfValueMethod(className, (YangEnumeration) curNode, pluginConfig) + NEW_LINE);
    insertDataIntoJavaFile(file, getEnumValueOfSchemaNameMethod(className, pluginConfig, (YangEnumeration) curNode));
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, SCHEMA_NAME, false, pluginConfig, null) + getGetter(STRING_DATA_TYPE, SCHEMA_NAME, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig config = fileInfo.getPluginConfig();
    String className = fileInfo.getJavaName();
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        String[] remove = { COMMA, NEW_LINE };
        insertDataIntoJavaFile(file, trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumTempFiles(), path), remove) + signatureClose());
    } catch (IOException e) {
        throw new IOException(getErrorMsg(getCapitalCase(className), ENUM_CLASS));
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(className));
    // Add a constructor for enum.
    // TODO: generate javadoc for method.
    insertDataIntoJavaFile(file, getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    insertDataIntoJavaFile(file, getEnumsOfValueMethod(className, (YangEnumeration) curNode, ENUM_METHOD_INT_VALUE));
    insertDataIntoJavaFile(file, getEnumsOfValueMethod(className, (YangEnumeration) curNode, ENUM_METHOD_STRING_VALUE));
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, null) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, SCHEMA_NAME, false, null) + getGetter(STRING_DATA_TYPE, SCHEMA_NAME, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className)) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException(getErrorMsg(getCapitalCase(className), ENUM_CLASS));
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        if (isGetSetOfRootNodeRequired(curNode)) {
            // Getter methods.
            methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
            // Setter methods.
            methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        }
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfoTranslator fileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(fileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = fileInfo.getBaseCodeGenPath() + fileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempFiles);
    try {
        if (isGetSetOfRootNodeRequired(curNode)) {
            // Getter methods.
            methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE);
            // Setter methods.
            methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE);
        }
        methods.add(getAugmentsDataMethodForService(curNode));
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, RPC_CLASS));
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static void generateEventFile(File file, YangNode curNode, List<String> imports) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_STRING;
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_EVENT_CLASS, imports, curNode, className);
    try {
        insertDataIntoJavaFile(file, NEW_LINE + getEventEnumTypeStart() + trimAtLast(getDataFromTempFileHandle(EVENT_ENUM_MASK, tempFiles, path), COMMA) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_METHOD_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while event class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#method_after
public static void generateEventFile(File file, YangNode curNode, List<String> imports) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_STRING;
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_EVENT_CLASS, imports, curNode, className);
    try {
        insertDataIntoJavaFile(file, getEventEnumTypeStart() + trimAtLast(getDataFromTempFileHandle(EVENT_ENUM_MASK, tempFiles, path), COMMA) + methodClose(FOUR_SPACE));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_METHOD_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, EVENT_CLASS));
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#end_block

#method_before
public static void generateEventSubjectFile(File file, YangNode curNode) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_SUBJECT_NAME_SUFFIX;
    initiateJavaFileGeneration(file, GENERATE_EVENT_SUBJECT_CLASS, null, curNode, className);
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    insertDataIntoJavaFile(file, NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_ATTRIBUTE_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_GETTER_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_SETTER_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while event class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#method_after
public static void generateEventSubjectFile(File file, YangNode curNode) throws IOException {
    String className = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()) + EVENT_SUBJECT_NAME_SUFFIX;
    initiateJavaFileGeneration(file, GENERATE_EVENT_SUBJECT_CLASS, null, curNode, className);
    String path = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getBaseCodeGenPath() + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackageFilePath();
    TempJavaEventFragmentFiles tempFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEventFragmentFiles();
    insertDataIntoJavaFile(file, NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_ATTRIBUTE_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_GETTER_MASK, tempFiles, path));
        insertDataIntoJavaFile(file, getDataFromTempFileHandle(EVENT_SUBJECT_SETTER_MASK, tempFiles, path));
    } catch (IOException e) {
        throw new IOException(getErrorMsg(className, EVENT_CLASS));
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    validateLineLength(file);
}
#end_block

#method_before
public static String parseBuilderInterfaceBuildMethodString(String name, YangPluginConfig pluginConfig) {
    return getJavaDoc(BUILD_METHOD, name, false, pluginConfig, null) + getBuildForInterface(name);
}
#method_after
public static String parseBuilderInterfaceBuildMethodString(String name) {
    return getJavaDoc(BUILD_METHOD, name, false, null) + getBuildForInterface(name);
}
#end_block

#method_before
public static String getGetterString(JavaAttributeInfo attr, int generatedJavaFiles, YangPluginConfig pluginConfig) {
    String returnType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    String appDataStructure = null;
    if (attr.getCompilerAnnotation() != null) {
        appDataStructure = attr.getCompilerAnnotation().getYangAppDataStructure().getDataStructure().name();
    }
    if (generatedJavaFiles == GENERATE_SERVICE_AND_MANAGER) {
        return generateForGetMethodWithAttribute(returnType) + getGetterForInterface(attributeName, returnType, attr.isListAttr(), generatedJavaFiles, attr.getCompilerAnnotation());
    }
    return getJavaDoc(GETTER_METHOD, attributeName, attr.isListAttr(), pluginConfig, appDataStructure) + getGetterForInterface(attributeName, returnType, attr.isListAttr(), generatedJavaFiles, attr.getCompilerAnnotation());
}
#method_after
public static String getGetterString(JavaAttributeInfo attr, int genType) {
    String returnType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    String appDataStructure = null;
    StringBuilder builder = new StringBuilder();
    if (attr.getCompilerAnnotation() != null) {
        appDataStructure = attr.getCompilerAnnotation().getYangAppDataStructure().getDataStructure().name();
    }
    if (genType == GENERATE_SERVICE_AND_MANAGER) {
        builder.append(generateForGetMethodWithAttribute(returnType)).append(getGetterForInterface(attributeName, returnType, attr.isListAttr(), genType, attr.getCompilerAnnotation()));
        return builder.toString();
    }
    builder.append(getJavaDoc(GETTER_METHOD, attributeName, attr.isListAttr(), appDataStructure)).append(getGetterForInterface(attributeName, returnType, attr.isListAttr(), genType, attr.getCompilerAnnotation()));
    return builder.toString();
}
#end_block

#method_before
public static String getSetterString(JavaAttributeInfo attr, String className, int generatedJavaFiles, YangPluginConfig pluginConfig) {
    String attrType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    JavaDocGen.JavaDocType type;
    if (generatedJavaFiles == GENERATE_SERVICE_AND_MANAGER) {
        type = MANAGER_SETTER_METHOD;
    } else {
        type = SETTER_METHOD;
    }
    String appDataStructure = null;
    if (attr.getCompilerAnnotation() != null) {
        appDataStructure = attr.getCompilerAnnotation().getYangAppDataStructure().getDataStructure().name();
    }
    return getJavaDoc(type, attributeName, attr.isListAttr(), pluginConfig, appDataStructure) + getSetterForInterface(attributeName, attrType, className, attr.isListAttr(), generatedJavaFiles, attr.getCompilerAnnotation());
}
#method_after
public static String getSetterString(JavaAttributeInfo attr, String className, int genType) {
    String attrType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    JavaDocGen.JavaDocType type;
    StringBuilder builder = new StringBuilder();
    if (genType == GENERATE_SERVICE_AND_MANAGER) {
        type = MANAGER_SETTER_METHOD;
    } else {
        type = SETTER_METHOD;
    }
    String appDataStructure = null;
    if (attr.getCompilerAnnotation() != null) {
        appDataStructure = attr.getCompilerAnnotation().getYangAppDataStructure().getDataStructure().name();
    }
    builder.append(getJavaDoc(type, attributeName, attr.isListAttr(), appDataStructure)).append(getSetterForInterface(attributeName, attrType, className, attr.isListAttr(), genType, attr.getCompilerAnnotation()));
    return builder.toString();
}
#end_block

#method_before
private static String getConstructorString(String name, YangPluginConfig pluginConfig) {
    return getJavaDoc(CONSTRUCTOR, name, false, pluginConfig, null);
}
#method_after
private static String getConstructorString(String name) {
    return getJavaDoc(CONSTRUCTOR, name, false, null);
}
#end_block

#method_before
public static String getDefaultConstructorString(String name, String modifierType, YangPluginConfig pluginConfig) {
    return getJavaDoc(DEFAULT_CONSTRUCTOR, name, false, pluginConfig, null) + getDefaultConstructor(name, modifierType) + NEW_LINE;
}
#method_after
public static String getDefaultConstructorString(String name, String modifierType) {
    return getJavaDoc(DEFAULT_CONSTRUCTOR, name, false, null) + getDefaultConstructor(name, modifierType) + NEW_LINE;
}
#end_block

#method_before
public static String getGetterForClass(JavaAttributeInfo attr, int generatedJavaFiles) {
    String attrQualifiedType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    if (!attr.isListAttr()) {
        return getGetter(attrQualifiedType, attributeName, generatedJavaFiles);
    }
    String attrParam = getListAttribute(attrQualifiedType, attr.getCompilerAnnotation());
    return getGetter(attrParam, attributeName, generatedJavaFiles);
}
#method_after
public static String getGetterForClass(JavaAttributeInfo attr, int generatedJavaFiles) {
    String attrQualifiedType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    if (!attr.isListAttr()) {
        return getGetter(attrQualifiedType, attributeName, generatedJavaFiles);
    }
    String attrParam = StringGenerator.getListAttribute(attrQualifiedType, attr.getCompilerAnnotation());
    return getGetter(attrParam, attributeName, generatedJavaFiles);
}
#end_block

#method_before
static String getGetter(String type, String name, int generatedJavaFiles) {
    String ret = parseTypeForReturnValue(type);
    if (generatedJavaFiles == GENERATE_SERVICE_AND_MANAGER) {
        return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + type + SPACE + GET_METHOD_PREFIX + getCapitalCase(name) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + YANG_UTILS_TODO + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + ret + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    } else {
        return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + type + SPACE + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + name + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    }
}
#method_after
static String getGetter(String type, String name, int genType) {
    StringBuilder builder = new StringBuilder();
    if (genType == GENERATE_SERVICE_AND_MANAGER) {
        // Append method signature.
        builder.append(methodSignature(getCapitalCase(name), GET, PUBLIC, null, type, null, CLASS_TYPE)).append(methodBody(MANAGER_METHODS, null, null, EIGHT_SPACE_INDENTATION, null, type, false)).append(signatureClose()).append(methodClose(FOUR_SPACE));
        return builder.toString();
    }
    builder.append(methodSignature(name, EMPTY_STRING, PUBLIC, null, type, null, CLASS_TYPE)).append(methodBody(GETTER, name, name, EIGHT_SPACE_INDENTATION, null, type, false)).append(signatureClose()).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
public static String getSetterForClass(JavaAttributeInfo attr, String className, int generatedJavaFiles) {
    String attrQualifiedType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    boolean isTypeNull = false;
    if (attr.getAttributeType() == null) {
        isTypeNull = true;
    }
    if (!attr.isListAttr()) {
        return getSetter(className, attributeName, attrQualifiedType, generatedJavaFiles, isTypeNull, false);
    }
    String attrParam = getListAttribute(attrQualifiedType, attr.getCompilerAnnotation());
    return getSetter(className, attributeName, attrParam, generatedJavaFiles, isTypeNull, true);
}
#method_after
public static String getSetterForClass(JavaAttributeInfo attr, String className, int generatedJavaFiles) {
    String attrQualifiedType = getReturnType(attr);
    String attributeName = attr.getAttributeName();
    boolean isTypeNull = false;
    if (attr.getAttributeType() == null) {
        isTypeNull = true;
    }
    if (!attr.isListAttr()) {
        return getSetter(className, attributeName, attrQualifiedType, generatedJavaFiles, isTypeNull, false);
    }
    String attrParam = StringGenerator.getListAttribute(attrQualifiedType, attr.getCompilerAnnotation());
    return getSetter(className, attributeName, attrParam, generatedJavaFiles, isTypeNull, true);
}
#end_block

#method_before
private static String getSetter(String className, String name, String type, int generatedJavaFiles, boolean isTypeNull, boolean isList) {
    if (generatedJavaFiles == GENERATE_SERVICE_AND_MANAGER) {
        return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + SET_METHOD_PREFIX + getCapitalCase(name) + OPEN_PARENTHESIS + type + SPACE + name + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + YANG_UTILS_TODO + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    } else if (generatedJavaFiles == GENERATE_EVENT_SUBJECT_CLASS) {
        return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + name + OPEN_PARENTHESIS + type + SPACE + name + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + THIS + PERIOD + name + SPACE + EQUAL + SPACE + name + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    } else {
        String method = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + name + OPEN_PARENTHESIS + type + SPACE + name + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET;
        if (!isTypeNull && !isList) {
            method = method + getValueLeafSetString(name);
        } else {
            method = method + EMPTY_STRING;
        }
        return method + NEW_LINE + EIGHT_SPACE_INDENTATION + THIS + PERIOD + name + SPACE + EQUAL + SPACE + name + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    }
}
#method_after
private static String getSetter(String className, String name, String type, int genType, boolean isTypeNull, boolean isList) {
    StringBuilder builder = new StringBuilder();
    if (genType == GENERATE_SERVICE_AND_MANAGER) {
        // Append method signature.
        builder.append(methodSignature(getCapitalCase(name), SET_METHOD_PREFIX, PUBLIC, name, VOID, type, CLASS_TYPE)).append(methodBody(MANAGER_METHODS, null, null, EIGHT_SPACE_INDENTATION, null, null, false)).append(methodClose(FOUR_SPACE));
        return builder.toString();
    }
    if (genType == GENERATE_EVENT_SUBJECT_CLASS) {
        builder.append(methodSignature(name, EMPTY_STRING, PUBLIC, name, VOID, type, CLASS_TYPE)).append(methodBody(SETTER, name, name, EIGHT_SPACE_INDENTATION, null, null, false)).append(methodClose(FOUR_SPACE));
        return builder.toString();
    }
    builder.append(methodSignature(name, EMPTY_STRING, PUBLIC, name, getCapitalCase(className) + BUILDER, type, CLASS_TYPE));
    if (!isTypeNull && !isList) {
        builder.append(StringGenerator.getValueLeafSetString(name));
    } else {
        builder.append(EMPTY_STRING);
    }
    // Append method body.
    builder.append(methodBody(SETTER, name, name, EIGHT_SPACE_INDENTATION, null, null, true)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
private static String getTypeDefSetter(String type, String name) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + SET_METHOD_PREFIX + getCapitalCase(name) + OPEN_PARENTHESIS + type + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + THIS + PERIOD + name + SPACE + EQUAL + SPACE + VALUE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
private static String getTypeDefSetter(String type, String name) {
    return methodSignature(getCapitalCase(name), SET_METHOD_PREFIX, PUBLIC, name, VOID, type, CLASS_TYPE) + methodBody(SETTER, name, name, EIGHT_SPACE_INDENTATION, null, null, false) + methodClose(FOUR_SPACE);
}
#end_block

#method_before
static String getGetterForInterface(String yangName, String returnType, boolean isList, int generatedJavaFiles, YangCompilerAnnotation compilerAnnotation) {
    if (!isList) {
        return getGetterInterfaceString(returnType, yangName, generatedJavaFiles);
    }
    String listAttr = getListAttribute(returnType, compilerAnnotation);
    return getGetterInterfaceString(listAttr, yangName, generatedJavaFiles);
}
#method_after
static String getGetterForInterface(String yangName, String returnType, boolean isList, int genType, YangCompilerAnnotation annotation) {
    if (!isList) {
        return getGetterInterfaceString(returnType, yangName, genType);
    }
    String listAttr = StringGenerator.getListAttribute(returnType, annotation);
    return getGetterInterfaceString(listAttr, yangName, genType);
}
#end_block

#method_before
private static String getGetterInterfaceString(String returnType, String yangName, int generatedJavaFiles) {
    if (generatedJavaFiles == GENERATE_SERVICE_AND_MANAGER) {
        return getGetMethodWithArgument(returnType, yangName);
    } else {
        return FOUR_SPACE_INDENTATION + returnType + SPACE + yangName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN;
    }
}
#method_after
private static String getGetterInterfaceString(String returnType, String yangName, int genType) {
    switch(genType) {
        case GENERATE_SERVICE_AND_MANAGER:
            return getGetMethodWithArgument(returnType, yangName);
        default:
            return methodSignature(yangName, EMPTY_STRING, null, null, returnType, null, INTERFACE_TYPE);
    }
}
#end_block

#method_before
static String getSetterForInterface(String attrName, String attrType, String className, boolean isList, int generatedJavaFiles, YangCompilerAnnotation compilerAnnotation) {
    if (!isList) {
        return getSetterInterfaceString(className, attrName, attrType, generatedJavaFiles);
    }
    String listAttr = getListAttribute(attrType, compilerAnnotation);
    return getSetterInterfaceString(className, attrName, listAttr, generatedJavaFiles);
}
#method_after
static String getSetterForInterface(String attrName, String attrType, String className, boolean isList, int genType, YangCompilerAnnotation annotation) {
    if (!isList) {
        return getSetterInterfaceString(className, attrName, attrType, genType);
    }
    String listAttr = StringGenerator.getListAttribute(attrType, annotation);
    return getSetterInterfaceString(className, attrName, listAttr, genType);
}
#end_block

#method_before
private static String getSetterInterfaceString(String className, String attrName, String attrType, int generatedJavaFiles) {
    if (generatedJavaFiles == GENERATE_SERVICE_AND_MANAGER) {
        return FOUR_SPACE_INDENTATION + VOID + SPACE + SET_METHOD_PREFIX + getCapitalCase(attrName) + OPEN_PARENTHESIS + attrType + OP_PARAM + SPACE + attrName + CLOSE_PARENTHESIS + SEMI_COLAN;
    } else {
        return FOUR_SPACE_INDENTATION + className + BUILDER + SPACE + attrName + OPEN_PARENTHESIS + attrType + SPACE + attrName + CLOSE_PARENTHESIS + SEMI_COLAN;
    }
}
#method_after
private static String getSetterInterfaceString(String name, String attrName, String attrType, int genType) {
    if (genType == GENERATE_SERVICE_AND_MANAGER) {
        return methodSignature(getCapitalCase(attrName), SET_METHOD_PREFIX, null, attrName, VOID, attrType + OP_PARAM, INTERFACE_TYPE);
    }
    return methodSignature(attrName, EMPTY_STRING, null, attrName, name + BUILDER, attrType, INTERFACE_TYPE);
}
#end_block

#method_before
private static String getReturnType(JavaAttributeInfo attr) {
    String returnType = EMPTY_STRING;
    if (attr.isQualifiedName() && attr.getImportInfo().getPkgInfo() != null) {
        returnType = attr.getImportInfo().getPkgInfo() + PERIOD;
    }
    returnType = returnType + attr.getImportInfo().getClassInfo();
    return returnType;
}
#method_after
private static String getReturnType(JavaAttributeInfo attr) {
    String returnType;
    StringBuilder builder = new StringBuilder();
    if (attr.isQualifiedName() && attr.getImportInfo().getPkgInfo() != null) {
        returnType = attr.getImportInfo().getPkgInfo() + PERIOD;
        builder.append(returnType);
    }
    returnType = attr.getImportInfo().getClassInfo();
    builder.append(returnType);
    return builder.toString();
}
#end_block

#method_before
static String getBuildForInterface(String yangName) {
    return FOUR_SPACE_INDENTATION + yangName + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String getBuildForInterface(String yangName) {
    return methodSignature(BUILD, EMPTY_STRING, null, null, yangName, null, INTERFACE_TYPE);
}
#end_block

#method_before
static String getConstructorStart(String yangName, YangPluginConfig pluginConfig, boolean isRootNode) {
    String javadoc = getConstructorString(yangName, pluginConfig);
    String returnType = getCapitalCase(DEFAULT) + yangName;
    if (isRootNode) {
        returnType = yangName + OP_PARAM;
    }
    String constructor = FOUR_SPACE_INDENTATION + PROTECTED + SPACE + returnType + OPEN_PARENTHESIS + yangName + BUILDER + SPACE + BUILDER.toLowerCase() + OBJECT + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    return javadoc + constructor;
}
#method_after
static String getConstructorStart(String yangName, boolean isRootNode) {
    StringBuilder builder = new StringBuilder(getConstructorString(yangName));
    String name = getCapitalCase(yangName);
    String returnType = DEFAULT_CAPS + name;
    if (isRootNode) {
        returnType = name + OP_PARAM;
    }
    builder.append(methodSignature(returnType, EMPTY_STRING, PROTECTED, BUILDER_LOWER_CASE + OBJECT, null, name + BUILDER, CLASS_TYPE));
    return builder.toString();
}
#end_block

#method_before
public static String getConstructor(JavaAttributeInfo attr, int generatedJavaFiles, YangPluginConfig pluginConfig) {
    String attributeName = attr.getAttributeName();
    String constructor;
    if (generatedJavaFiles == GENERATE_SERVICE_AND_MANAGER) {
        constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCapitalCase(getCamelCase(attributeName, pluginConfig.getConflictResolver())) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    } else {
        constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    }
    return constructor;
}
#method_after
public static String getConstructor(JavaAttributeInfo attr, int genType) {
    String attrName = attr.getAttributeName();
    String attrCaps = getCapitalCase(attrName);
    switch(genType) {
        case GENERATE_SERVICE_AND_MANAGER:
            return methodBody(MethodBodyTypes.CONSTRUCTOR, attrName, attrCaps, EIGHT_SPACE_INDENTATION, GET, null, false);
        default:
            return methodBody(MethodBodyTypes.CONSTRUCTOR, attrName, attrName, EIGHT_SPACE_INDENTATION, EMPTY_STRING, null, false);
    }
}
#end_block

#method_before
public static String getRpcServiceMethod(String rpcName, String inputName, String outputName, YangPluginConfig pluginConfig) {
    rpcName = getCamelCase(rpcName, pluginConfig.getConflictResolver());
    if (!inputName.equals(EMPTY_STRING)) {
        inputName = inputName + SPACE + RPC_INPUT_VAR_NAME;
    }
    return FOUR_SPACE_INDENTATION + outputName + SPACE + rpcName + OPEN_PARENTHESIS + inputName + CLOSE_PARENTHESIS + SEMI_COLAN;
}
#method_after
public static String getRpcServiceMethod(String rpcName, String input, String output) {
    String inputVal = EMPTY_STRING;
    if (!input.equals(EMPTY_STRING)) {
        inputVal = RPC_INPUT_VAR_NAME;
    }
    return methodSignature(rpcName, EMPTY_STRING, null, inputVal, output, input, INTERFACE_TYPE) + NEW_LINE;
}
#end_block

#method_before
static String getBuild(String yangName, boolean isRootNode) {
    String type = getCapitalCase(DEFAULT) + yangName;
    if (isRootNode) {
        type = yangName + OP_PARAM;
    }
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + yangName + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + type + OPEN_PARENTHESIS + THIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
static String getBuild(String yangName, boolean isRootNode) {
    String type = DEFAULT_CAPS + yangName;
    if (isRootNode) {
        type = yangName + OP_PARAM;
    }
    return methodSignature(BUILD, EMPTY_STRING, PUBLIC, null, yangName, null, CLASS_TYPE) + methodBody(MethodBodyTypes.BUILD, type, BUILD, EIGHT_SPACE_INDENTATION, EMPTY_STRING, null, false) + methodClose(FOUR_SPACE);
}
#end_block

#method_before
private static String getDefaultConstructor(String name, String modifierType) {
    return FOUR_SPACE_INDENTATION + modifierType + SPACE + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
private static String getDefaultConstructor(String name, String modifierType) {
    return methodSignature(name, EMPTY_STRING, modifierType, null, null, null, CLASS_TYPE) + methodClose(FOUR_SPACE);
}
#end_block

#method_before
static String getToStringMethodOpen() {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + GOOGLE_MORE_OBJECT_METHOD_STRING + NEW_LINE;
}
#method_after
static String getToStringMethodOpen() {
    String line;
    StringBuilder builder = new StringBuilder(getOverRideString());
    builder.append(methodSignature(TO + STRING_DATA_TYPE, EMPTY_STRING, PUBLIC, null, STRING_DATA_TYPE, null, CLASS_TYPE));
    line = getReturnString(GOOGLE_MORE_OBJECT_METHOD_STRING, EIGHT_SPACE_INDENTATION) + NEW_LINE;
    builder.append(line);
    return builder.toString();
}
#end_block

#method_before
static String getToStringMethodClose() {
    return TWELVE_SPACE_INDENTATION + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getToStringMethodClose() {
    return TWELVE_SPACE_INDENTATION + PERIOD + TO + STRING_DATA_TYPE + brackets(OPEN_CLOSE_BRACKET, null, null) + signatureClose() + methodClose(FOUR_SPACE);
}
#end_block

#method_before
public static String getToStringMethod(JavaAttributeInfo attr) {
    String attributeName = attr.getAttributeName();
    return TWELVE_SPACE_INDENTATION + PERIOD + ADD_STRING + OPEN_PARENTHESIS + QUOTES + attributeName + QUOTES + COMMA + SPACE + attributeName + CLOSE_PARENTHESIS;
}
#method_after
public static String getToStringMethod(JavaAttributeInfo attr) {
    String attributeName = attr.getAttributeName();
    return methodBody(TO_STRING, attributeName, null, TWELVE_SPACE_INDENTATION, null, null, false);
}
#end_block

#method_before
static String getFromStringMethodSignature(String className, YangPluginConfig pluginConfig) {
    return getJavaDoc(FROM_METHOD, className, false, pluginConfig, null) + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + className + SPACE + FROM_STRING_METHOD_NAME + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getFromStringMethodSignature(String className) {
    return getJavaDoc(FROM_METHOD, className, false, null) + methodSignature(FROM_STRING_METHOD_NAME, EMPTY_STRING, PUBLIC + SPACE + STATIC, FROM_STRING_PARAM_NAME, className, STRING_DATA_TYPE, CLASS_TYPE);
}
#end_block

#method_before
static String getFromStringMethodClose() {
    return EIGHT_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getFromStringMethodClose() {
    return getReturnString(NULL, EIGHT_SPACE_INDENTATION) + signatureClose() + methodClose(FOUR_SPACE);
}
#end_block

#method_before
public static String getFromStringMethod(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttributeInfo) {
    return EIGHT_SPACE_INDENTATION + getTrySubString() + NEW_LINE + TWELVE_SPACE_INDENTATION + getParsedSubString(attr, fromStringAttributeInfo) + NEW_LINE + TWELVE_SPACE_INDENTATION + getReturnOfSubString() + NEW_LINE + EIGHT_SPACE_INDENTATION + getCatchSubString() + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
public static String getFromStringMethod(JavaAttributeInfo attr, JavaAttributeInfo fromAttr) {
    return EIGHT_SPACE_INDENTATION + StringGenerator.getTrySubString() + StringGenerator.getNewLineAndSpace(TWELVE_SPACE_INDENTATION) + getParsedSubString(attr, fromAttr) + StringGenerator.getNewLineAndSpace(TWELVE_SPACE_INDENTATION) + StringGenerator.getReturnOfSubString() + StringGenerator.getNewLineAndSpace(EIGHT_SPACE_INDENTATION) + StringGenerator.getCatchSubString() + StringGenerator.getNewLineAndSpace(EIGHT_SPACE_INDENTATION) + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
private static String getParsedSubString(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttributeInfo) {
    String targetDataType = getReturnType(attr);
    if (fromStringAttributeInfo.getAttributeType().getDataType() == BITS) {
        String lines = targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + NEW + SPACE + targetDataType + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        lines += TWELVE_SPACE_INDENTATION + FROM_STRING_PARAM_NAME + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + REPLACE_STRING + OPEN_PARENTHESIS + SINGLE_QUOTE + OPEN_CURLY_BRACKET + SINGLE_QUOTE + COMMA + SPACE + SINGLE_QUOTE + SPACE + SINGLE_QUOTE + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        lines += TWELVE_SPACE_INDENTATION + FROM_STRING_PARAM_NAME + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + REPLACE_STRING + OPEN_PARENTHESIS + SINGLE_QUOTE + CLOSE_CURLY_BRACKET + SINGLE_QUOTE + COMMA + SPACE + SINGLE_QUOTE + SPACE + SINGLE_QUOTE + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        lines += TWELVE_SPACE_INDENTATION + FROM_STRING_PARAM_NAME + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + TRIM_STRING + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        lines += TWELVE_SPACE_INDENTATION + STRING_DATA_TYPE + SQUARE_BRACKETS + SPACE + BITS_STRING_ARRAY_VAR + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + SPLIT_STRING + OPEN_PARENTHESIS + QUOTES + COMMA + QUOTES + COMMA + SPACE + ZERO + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        lines += TWELVE_SPACE_INDENTATION + FOR + SPACE + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + BIT_TEMP_VAR + SPACE + COLON + SPACE + BITS_STRING_ARRAY_VAR + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
        lines += SIXTEEN_SPACE_INDENTATION + BIT_TEMP_VAR + SPACE + EQUAL + SPACE + BIT_TEMP_VAR + PERIOD + TRIM_STRING + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        lines += SIXTEEN_SPACE_INDENTATION + TMP_VAL + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + INTEGER_WRAPPER + PERIOD + PARSE_INT + OPEN_PARENTHESIS + BIT_TEMP_VAR + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        lines += TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
        return lines;
    } else if (attr.getAttributeType().getDataType() == BINARY) {
        return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + BASE64 + PERIOD + GET_DECODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + DECODE + OPEN_PARENTHESIS + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SEMI_COLAN;
    } else {
        String parseFromStringMethod = getParseFromStringMethod(targetDataType, fromStringAttributeInfo.getAttributeType());
        return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + parseFromStringMethod + OPEN_PARENTHESIS + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SEMI_COLAN;
    }
}
#method_after
private static String getParsedSubString(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttr) {
    String targetDataType = getReturnType(attr);
    StringBuilder builder = new StringBuilder();
    YangDataTypes types = fromStringAttr.getAttributeType().getDataType();
    switch(types) {
        case BITS:
            String lines = targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + NEW + SPACE + targetDataType + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
            builder.append(lines);
            /*
             *"            valInString = valInString.replace("{", " ");\n";
             */
            lines = TWELVE_SPACE_INDENTATION + FROM_STRING_PARAM_NAME + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + REPLACE_STRING + OPEN_PARENTHESIS + SINGLE_QUOTE + OPEN_CURLY_BRACKET + SINGLE_QUOTE + COMMA + SPACE + SINGLE_QUOTE + SPACE + SINGLE_QUOTE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
            builder.append(lines);
            /*
             *"            valInString = valInString.replace({, " ");\n";
             */
            lines = TWELVE_SPACE_INDENTATION + FROM_STRING_PARAM_NAME + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + REPLACE_STRING + OPEN_PARENTHESIS + SINGLE_QUOTE + CLOSE_CURLY_BRACKET + SINGLE_QUOTE + COMMA + SPACE + SINGLE_QUOTE + SPACE + SINGLE_QUOTE + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
            builder.append(lines);
            /*
             *"            valInString = valInString.trim();\n"
             */
            lines = TWELVE_SPACE_INDENTATION + FROM_STRING_PARAM_NAME + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + TRIM_STRING + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
            builder.append(lines);
            /*
             *"            String[] bitsTemp = valInString.split(",", 0);\n"
             */
            lines = TWELVE_SPACE_INDENTATION + STRING_DATA_TYPE + SQUARE_BRACKETS + SPACE + BITS_STRING_ARRAY_VAR + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + SPLIT_STRING + OPEN_PARENTHESIS + QUOTES + COMMA + QUOTES + COMMA + SPACE + ZERO + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
            builder.append(lines);
            /*
             *"            for (String bitTemp : bitsTemp) {\n"
             */
            lines = TWELVE_SPACE_INDENTATION + FOR + SPACE + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + BIT_TEMP_VAR + SPACE + COLON + SPACE + BITS_STRING_ARRAY_VAR + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
            builder.append(lines);
            /*
             *"                bitTemp = bitTemp.trim();\n"
             */
            lines = SIXTEEN_SPACE_INDENTATION + BIT_TEMP_VAR + SPACE + EQUAL + SPACE + BIT_TEMP_VAR + PERIOD + TRIM_STRING + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
            builder.append(lines);
            /*
             *"                tmpVal.set(Integer.parseInt(bitTemp));\n"
             */
            lines = SIXTEEN_SPACE_INDENTATION + TMP_VAL + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + INTEGER_WRAPPER + PERIOD + PARSE_INT + OPEN_PARENTHESIS + BIT_TEMP_VAR + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
            builder.append(lines);
            /*
             *"            }\n"
             */
            lines = TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            builder.append(lines);
            return builder.toString();
        case BINARY:
            return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + BASE64 + PERIOD + GET_DECODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + DECODE + OPEN_PARENTHESIS + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
        default:
            return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + StringGenerator.getParseFromStringMethod(targetDataType, fromStringAttr.getAttributeType()) + OPEN_PARENTHESIS + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SEMI_COLON + NEW_LINE;
    }
}
#end_block

#method_before
static String getHashCodeMethodOpen() {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + INT + SPACE + HASH_CODE_STRING + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + OBJECT_STRING + SUFFIX_S + PERIOD + HASH + OPEN_PARENTHESIS;
}
#method_after
static String getHashCodeMethodOpen() {
    String line;
    StringBuilder builder = new StringBuilder(getOverRideString());
    builder.append(methodSignature(HASH_CODE_STRING, EMPTY_STRING, PUBLIC, null, INT, null, CLASS_TYPE));
    line = getReturnString(OBJECT_STRING + SUFFIX_S + PERIOD + HASH + OPEN_PARENTHESIS, EIGHT_SPACE_INDENTATION);
    builder.append(line);
    return builder.toString();
}
#end_block

#method_before
static String getHashCodeMethodClose(String hashcodeString) {
    hashcodeString = trimAtLast(hashcodeString, COMMA);
    hashcodeString = trimAtLast(hashcodeString, SPACE);
    return hashcodeString + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getHashCodeMethodClose(String hashcodeString) {
    String[] array = { SPACE, COMMA };
    hashcodeString = trimAtLast(hashcodeString, array);
    return hashcodeString + CLOSE_PARENTHESIS + signatureClose() + methodClose(FOUR_SPACE);
}
#end_block

#method_before
static String getEqualsMethodOpen(String className) {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + BOOLEAN_DATA_TYPE + SPACE + EQUALS_STRING + OPEN_PARENTHESIS + OBJECT_STRING + SPACE + OBJ + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + getEqualsMethodsCommonIfCondition() + getEqualsMethodsSpecificIfCondition(className);
}
#method_after
static String getEqualsMethodOpen(String className) {
    return getOverRideString() + methodSignature(EQUALS_STRING, EMPTY_STRING, PUBLIC, OBJ, BOOLEAN_DATA_TYPE, OBJECT_STRING, CLASS_TYPE) + getEqualsMethodsCommonIfCondition() + getEqualsMethodsSpecificIfCondition(className);
}
#end_block

#method_before
private static String getEqualsMethodsCommonIfCondition() {
    return EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + THIS + SPACE + EQUAL + EQUAL + SPACE + OBJ + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
private static String getEqualsMethodsCommonIfCondition() {
    return getIfConditionBegin(EIGHT_SPACE_INDENTATION, THIS + SPACE + EQUAL + EQUAL + SPACE + OBJ) + getReturnString(TRUE, TWELVE_SPACE_INDENTATION) + signatureClose() + methodClose(EIGHT_SPACE);
}
#end_block

#method_before
private static String getEqualsMethodsSpecificIfCondition(String className) {
    return EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + OBJ + INSTANCE_OF + className + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + className + SPACE + OTHER + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + className + CLOSE_PARENTHESIS + SPACE + OBJ + SEMI_COLAN + NEW_LINE + TWELVE_SPACE_INDENTATION + RETURN + NEW_LINE;
}
#method_after
private static String getEqualsMethodsSpecificIfCondition(String className) {
    return EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + OBJ + INSTANCE_OF + className + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + className + SPACE + OTHER + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + className + CLOSE_PARENTHESIS + SPACE + OBJ + SEMI_COLON + NEW_LINE + TWELVE_SPACE_INDENTATION + RETURN + NEW_LINE;
}
#end_block

#method_before
static String getEqualsMethodClose(String equalMethodString) {
    equalMethodString = trimAtLast(equalMethodString, AND);
    equalMethodString = trimAtLast(equalMethodString, AND);
    equalMethodString = trimAtLast(equalMethodString, SPACE);
    equalMethodString = trimAtLast(equalMethodString, NEW_LINE) + SEMI_COLAN + NEW_LINE;
    return equalMethodString + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getEqualsMethodClose(String equalMethodString) {
    String[] array = { NEW_LINE, AND, AND, SPACE };
    equalMethodString = trimAtLast(equalMethodString, array) + signatureClose();
    return equalMethodString + methodClose(EIGHT_SPACE) + getReturnString(FALSE, EIGHT_SPACE_INDENTATION) + signatureClose() + methodClose(FOUR_SPACE);
}
#end_block

#method_before
public static String getEqualsMethod(JavaAttributeInfo attr) {
    String attributeName = attr.getAttributeName();
    return SIXTEEN_SPACE_INDENTATION + SPACE + OBJECT_STRING + SUFFIX_S + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + attributeName + COMMA + SPACE + OTHER + PERIOD + attributeName + CLOSE_PARENTHESIS + SPACE + AND + AND;
}
#method_after
public static String getEqualsMethod(JavaAttributeInfo attr) {
    String attributeName = attr.getAttributeName();
    return SIXTEEN_SPACE_INDENTATION + OBJECT_STRING + SUFFIX_S + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + attributeName + COMMA + SPACE + OTHER + PERIOD + attributeName + CLOSE_PARENTHESIS + SPACE + AND + AND;
}
#end_block

#method_before
public static String getOfMethodStringAndJavaDoc(JavaAttributeInfo attr, String generatedJavaClassName, YangPluginConfig pluginConfig) {
    String attrType = getReturnType(attr);
    String attrName = attr.getAttributeName();
    return getJavaDoc(OF_METHOD, generatedJavaClassName + " for type " + attrName, false, pluginConfig, null) + getOfMethodString(attrType, generatedJavaClassName);
}
#method_after
public static String getOfMethodStringAndJavaDoc(JavaAttributeInfo attr, String className) {
    String attrType = getReturnType(attr);
    String attrName = attr.getAttributeName();
    return getJavaDoc(OF_METHOD, className + FOR_TYPE_STRING + attrName, false, null) + getOfMethodString(attrType, className);
}
#end_block

#method_before
private static String getOfMethodString(String type, String className) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + className + SPACE + OF + OPEN_PARENTHESIS + type + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + className + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
private static String getOfMethodString(String type, String name) {
    return methodSignature(OF, EMPTY_STRING, PUBLIC + SPACE + STATIC, VALUE, name, type, CLASS_TYPE) + methodBody(MethodBodyTypes.OF_METHOD, name, null, EIGHT_SPACE_INDENTATION, EMPTY_STRING, null, false) + methodClose(FOUR_SPACE);
}
#end_block

#method_before
public static String getTypeConstructorStringAndJavaDoc(JavaAttributeInfo attr1, JavaAttributeInfo attr2, String generatedJavaClassName, YangPluginConfig pluginConfig, ValidatorTypeForUnionTypes type, boolean addFirst) {
    String attrType = getReturnType(attr1);
    String attrName1 = "";
    String attrName2 = "";
    if (attr1 != null) {
        attrName1 = attr1.getAttributeName();
    }
    if (attr2 != null) {
        attrName2 = attr2.getAttributeName();
    }
    String appDataStructure = null;
    if (attr1 != null && attr1.getCompilerAnnotation() != null) {
        appDataStructure = attr1.getCompilerAnnotation().getYangAppDataStructure().getDataStructure().name();
    }
    return getJavaDoc(TYPE_CONSTRUCTOR, generatedJavaClassName + " for type " + attrName1, false, pluginConfig, appDataStructure) + getTypeConstructorString(attrType, attrName1, attrName2, generatedJavaClassName, type, addFirst);
}
#method_after
public static String getTypeConstructorStringAndJavaDoc(JavaAttributeInfo attr, String className) {
    String attrType = getReturnType(attr);
    String attrName = attr.getAttributeName();
    return getJavaDoc(TYPE_CONSTRUCTOR, attrName, false, null) + getTypeConstructorString(attrType, attrName, className);
}
#end_block

#method_before
private static String getTypeConstructorString(String type, String name, String className) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + OPEN_PARENTHESIS + type + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + THIS + PERIOD + name + SPACE + EQUAL + SPACE + VALUE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
private static String getTypeConstructorString(String type, String name, String className) {
    return methodSignature(className, EMPTY_STRING, PUBLIC, name, null, type, CLASS_TYPE) + methodBody(SETTER, name, null, EIGHT_SPACE_INDENTATION, EMPTY_STRING, null, false) + methodClose(FOUR_SPACE);
}
#end_block

#method_before
private static String getTypeConstructorString(String type, String attr1, String attr2, String className, ValidatorTypeForUnionTypes validatorType, boolean addInt) {
    String constructor;
    constructor = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + OPEN_PARENTHESIS + type + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    String name1;
    String name2;
    if (addInt) {
        name1 = attr1;
        name2 = attr2;
    } else {
        name1 = attr2;
        name2 = attr1;
    }
    constructor = constructor + ifConditionForIntInTypeDefConstructor(validatorType, addInt) + TWELVE_SPACE_INDENTATION + THIS + PERIOD + name1 + SPACE + EQUAL + SPACE + VALUE + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + THIS + PERIOD + name2 + SPACE + EQUAL + SPACE + VALUE + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return constructor;
}
#method_after
private static String getTypeConstructorString(String type, String attr1, String attr2, String className, ValidatorTypeForUnionTypes validatorType, boolean addInt) {
    StringBuilder constructor = new StringBuilder(methodSignature(className, EMPTY_STRING, null, type, null, type, CLASS_TYPE)).append(ifConditionForIntInTypeDefConstructor(validatorType, addInt)).append(methodBody(SETTER, attr1, null, TWELVE_SPACE_INDENTATION, EMPTY_STRING, null, false));
    String str = EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + SPACE + ELSE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    constructor.append(str).append(methodBody(SETTER, attr2, null, TWELVE_SPACE_INDENTATION, EMPTY_STRING, null, false)).append(methodClose(FOUR_SPACE)).append(methodClose(EIGHT_SPACE));
    return constructor.toString();
}
#end_block

#method_before
static String getAddAugmentInfoMethodInterface() {
    return generateForAddAugmentation() + FOUR_SPACE_INDENTATION + VOID + SPACE + ADD_STRING + YANG_AUGMENTED_INFO + OPEN_PARENTHESIS + OBJECT_STRING + SPACE + VALUE + COMMA + SPACE + CLASS_STRING + SPACE + CLASS + OBJECT_STRING + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String getAddAugmentInfoMethodInterface() {
    StringBuilder builder = new StringBuilder(generateForAddAugmentation());
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put(OBJECT_STRING, VALUE);
    map.put(CLASS_STRING, CLASS + OBJECT_STRING);
    builder.append(multiAttrMethodSignature(ADD_STRING + YANG_AUGMENTED_INFO, EMPTY_STRING, EMPTY_STRING, VOID, map, INTERFACE_TYPE));
    return builder.toString();
}
#end_block

#method_before
static String getAddAugmentInfoMethodImpl() {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + ADD_STRING + YANG_AUGMENTED_INFO + OPEN_PARENTHESIS + OBJECT_STRING + SPACE + VALUE + COMMA + SPACE + CLASS_STRING + SPACE + CLASS + OBJECT_STRING + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + getSmallCase(YANG_AUGMENTED_INFO) + MAP + PERIOD + PUT + OPEN_PARENTHESIS + CLASS + OBJECT_STRING + COMMA + SPACE + VALUE + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getAddAugmentInfoMethodImpl() {
    StringBuilder builder = new StringBuilder(getOverRideString());
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put(OBJECT_STRING, VALUE);
    map.put(CLASS_STRING, CLASS + OBJECT_STRING);
    builder.append(multiAttrMethodSignature(ADD_STRING + YANG_AUGMENTED_INFO, EMPTY_STRING, PUBLIC, VOID, map, CLASS_TYPE)).append(methodBody(AUGMENTED_MAP_ADD, null, null, EIGHT_SPACE_INDENTATION, null, null, false)).append(methodClose(FOUR_SPACE)).append(NEW_LINE);
    return builder.toString();
}
#end_block

#method_before
static String getYangAugmentInfoInterface() {
    return generateForGetAugmentation() + FOUR_SPACE_INDENTATION + OBJECT_STRING + SPACE + getSmallCase(YANG_AUGMENTED_INFO) + OPEN_PARENTHESIS + CLASS_STRING + SPACE + CLASS + OBJECT_STRING + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String getYangAugmentInfoInterface() {
    return generateForGetAugmentation() + methodSignature(YANG_AUGMENTED_INFO_LOWER_CASE, EMPTY_STRING, null, CLASS + OBJECT_STRING, OBJECT_STRING, CLASS_STRING, INTERFACE_TYPE);
}
#end_block

#method_before
static String getYangAugmentInfoImpl() {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + OBJECT_STRING + SPACE + getSmallCase(YANG_AUGMENTED_INFO) + OPEN_PARENTHESIS + CLASS_STRING + SPACE + CLASS + OBJECT_STRING + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + getSmallCase(YANG_AUGMENTED_INFO) + MAP + PERIOD + GET + OPEN_PARENTHESIS + CLASS + OBJECT_STRING + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getYangAugmentInfoImpl() {
    return getOverRideString() + methodSignature(YANG_AUGMENTED_INFO_LOWER_CASE, EMPTY_STRING, PUBLIC, CLASS + OBJECT_STRING, OBJECT_STRING, CLASS_STRING, CLASS_TYPE) + methodBody(AUGMENTED_MAP_GET_VALUE, null, null, EIGHT_SPACE_INDENTATION, null, null, false) + methodClose(FOUR_SPACE);
}
#end_block

#method_before
static String getYangAugmentInfoMapInterface(YangPluginConfig pluginConfig) {
    return getJavaDoc(GETTER_METHOD, getSmallCase(YANG_AUGMENTED_INFO) + MAP, false, pluginConfig, null) + FOUR_SPACE_INDENTATION + MAP + DIAMOND_OPEN_BRACKET + CLASS_STRING + DIAMOND_OPEN_BRACKET + QUESTION_MARK + DIAMOND_CLOSE_BRACKET + COMMA + SPACE + OBJECT_STRING + DIAMOND_CLOSE_BRACKET + SPACE + getSmallCase(YANG_AUGMENTED_INFO) + MAP + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String getYangAugmentInfoMapInterface() {
    return NEW_LINE + getJavaDoc(GETTER_METHOD, YANG_AUGMENTED_INFO_LOWER_CASE + MAP, false, null) + methodSignature(YANG_AUGMENTED_INFO_LOWER_CASE + MAP, EMPTY_STRING, null, null, getAugmentMapTypeString(), null, INTERFACE_TYPE);
}
#end_block

#method_before
static String getYangAugmentInfoMapImpl() {
    return getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + MAP + DIAMOND_OPEN_BRACKET + CLASS_STRING + DIAMOND_OPEN_BRACKET + QUESTION_MARK + DIAMOND_CLOSE_BRACKET + COMMA + SPACE + OBJECT_STRING + DIAMOND_CLOSE_BRACKET + SPACE + getSmallCase(YANG_AUGMENTED_INFO) + MAP + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + getSmallCase(YANG_AUGMENTED_INFO) + MAP + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getYangAugmentInfoMapImpl() {
    return getOverRideString() + methodSignature(YANG_AUGMENTED_INFO_LOWER_CASE + MAP, EMPTY_STRING, PUBLIC, null, getAugmentMapTypeString(), null, CLASS_TYPE) + methodBody(AUGMENTED_MAP_GETTER, null, null, EIGHT_SPACE_INDENTATION, null, null, false) + methodClose(FOUR_SPACE);
}
#end_block

#method_before
static String getEnumsConstructor(String className) {
    return FOUR_SPACE_INDENTATION + className + OPEN_PARENTHESIS + INT + SPACE + VALUE + COMMA + SPACE + STRING_DATA_TYPE + SPACE + STR_VAL + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + getSmallCase(className) + SPACE + EQUAL + SPACE + VALUE + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + SCHEMA_NAME + SPACE + EQUAL + SPACE + STR_VAL + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
static String getEnumsConstructor(String className) {
    StringBuilder builder = new StringBuilder();
    String clsName = getSmallCase(className);
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put(INT, clsName);
    map.put(STRING_DATA_TYPE, SCHEMA_NAME);
    builder.append(multiAttrMethodSignature(className, EMPTY_STRING, EMPTY_STRING, null, map, CLASS_TYPE)).append(methodBody(SETTER, clsName, EMPTY_STRING, EIGHT_SPACE_INDENTATION, EMPTY_STRING, EMPTY_STRING, false)).append(methodBody(SETTER, SCHEMA_NAME, EMPTY_STRING, EIGHT_SPACE_INDENTATION, EMPTY_STRING, EMPTY_STRING, false)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
static String getEnumsOfValueMethod(String className, YangEnumeration enumeration, YangPluginConfig pluginConfig) {
    String method = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + getCapitalCase(className) + SPACE + OF + OPEN_PARENTHESIS + INT + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + SWITCH + SPACE + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    int value;
    String str;
    for (YangEnum yangEnum : enumeration.getEnumSet()) {
        value = yangEnum.getValue();
        str = getEnumJavaAttribute(yangEnum.getNamedValue()).toUpperCase();
        method = method + TWELVE_SPACE_INDENTATION + CASE + SPACE + value + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + getCapitalCase(className) + PERIOD + str + SEMI_COLAN + NEW_LINE;
    }
    method = method + TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return getJavaDoc(OF_METHOD, getCapitalCase(className) + " for value", false, pluginConfig, null) + method;
}
#method_after
static String getEnumsOfValueMethod(String className, YangEnumeration enumeration, MethodBodyTypes type) {
    String name = getCapitalCase(className);
    StringBuilder builder = new StringBuilder(getJavaDoc(OF_METHOD, name + SPACE + FOR, false, null));
    // Switch statement.
    String sw = EIGHT_SPACE_INDENTATION + SWITCH + SPACE + brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, VALUE, null) + methodSignatureClose(CLASS_TYPE);
    String str;
    switch(type) {
        case ENUM_METHOD_INT_VALUE:
            builder.append(getEnumValueMethodSignature(name, INT)).append(sw);
            for (YangEnum yangEnum : enumeration.getEnumSet()) {
                str = getEnumJavaAttribute(yangEnum.getNamedValue()).toUpperCase();
                builder.append(getEnumValueMethodCases(EMPTY_STRING + yangEnum.getValue(), str, name));
            }
            break;
        case ENUM_METHOD_STRING_VALUE:
            builder.append(getEnumValueMethodSignature(name, STRING_DATA_TYPE)).append(sw);
            for (YangEnum yangEnum : enumeration.getEnumSet()) {
                str = getEnumJavaAttribute(yangEnum.getNamedValue()).toUpperCase();
                builder.append(getEnumValueMethodCases(QUOTES + yangEnum.getNamedValue() + QUOTES, str, name));
            }
            break;
        default:
            return null;
    }
    String method = TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE;
    builder.append(method).append(getReturnString(NULL, SIXTEEN_SPACE_INDENTATION)).append(signatureClose()).append(methodClose(EIGHT_SPACE)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
static String getAugmentsDataMethodForService(YangNode parent) {
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangNode methodNode;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        methodNode = nodeId.getResolvedNode();
        if (((JavaFileInfoContainer) methodNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) methodNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(methodNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode, pluginConfig);
        method = generateForGetMethodWithAttribute(returnType) + getGetMethodWithArgument(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName)) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + getCapitalCase(curNodeName), false, pluginConfig, null) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER, null) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#method_after
static String getAugmentsDataMethodForService(YangNode parent) {
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangNode methodNode;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        methodNode = nodeId.getResolvedNode();
        if (((JavaFileInfoContainer) methodNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) methodNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(methodNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getCurNodeName(augmentedNode, pluginConfig);
        method = generateForGetMethodWithAttribute(returnType) + getGetMethodWithArgument(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName)) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + getCapitalCase(curNodeName), false, null) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER, null) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#end_block

#method_before
static String getRangeValidatorMethodForUnion(String type) {
    String newType;
    if (type.contentEquals(BIG_INTEGER)) {
        newType = LONG;
    } else {
        newType = INT;
    }
    String method = generateForValidatorMethod() + FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BOOLEAN_DATA_TYPE + SPACE + VALIDATE_RANGE + OPEN_PARENTHESIS + type + SPACE + MIN_RANGE + COMMA + SPACE + type + SPACE + MAX_RANGE + COMMA + SPACE + newType + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    if (type.contentEquals(BIG_INTEGER)) {
        method = method + EIGHT_SPACE_INDENTATION + BIG_INTEGER + SPACE + getSmallCase(BIG_INTEGER) + SPACE + EQUAL + SPACE + NEW + SPACE + BIG_INTEGER + OPEN_PARENTHESIS + QUOTES + SPACE + QUOTES + SPACE + ADD + SPACE + VALUE + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + getSmallCase(BIG_INTEGER) + PERIOD + "compareTo" + OPEN_PARENTHESIS + MIN_RANGE + CLOSE_PARENTHESIS + SPACE + EQUAL + EQUAL + " 1" + SPACE + AND + AND + SPACE + getSmallCase(BIG_INTEGER) + PERIOD + "compareTo" + OPEN_PARENTHESIS + MAX_RANGE + CLOSE_PARENTHESIS + SPACE + EQUAL + EQUAL + " 1" + SEMI_COLAN + NEW_LINE;
    } else {
        method = method + EIGHT_SPACE_INDENTATION + RETURN + SPACE + VALUE + SPACE + DIAMOND_CLOSE_BRACKET + EQUAL + SPACE + MIN_RANGE + SPACE + AND + AND + SPACE + VALUE + SPACE + DIAMOND_OPEN_BRACKET + EQUAL + SPACE + MAX_RANGE + SEMI_COLAN + NEW_LINE;
    }
    return method + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getRangeValidatorMethodForUnion(String type) {
    String newType;
    if (type.contentEquals(BIG_INTEGER)) {
        newType = LONG;
    } else {
        newType = INT;
    }
    StringBuilder builder = new StringBuilder(generateForValidatorMethod());
    String var = getSmallCase(BIG_INTEGER);
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put(MIN_RANGE, type);
    map.put(MAX_RANGE, type);
    map.put(VALUE, newType);
    builder.append(multiAttrMethodSignature(VALIDATE_RANGE, EMPTY_STRING, PRIVATE, BOOLEAN_DATA_TYPE, map, CLASS_TYPE));
    if (type.contentEquals(BIG_INTEGER)) {
        // Create new instance of big integer.
        builder.append(getNewInstance(BIG_INTEGER, var, EIGHT_SPACE_INDENTATION, QUOTES + SPACE + QUOTES + SPACE + ADD + SPACE + VALUE)).append(getReturnString(var, EIGHT_SPACE_INDENTATION)).append(getCompareToString()).append(ifAndAndCondition(// Add == condition
        ifEqualEqualCondition(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, MIN_RANGE, null), ONE), var)).append(getCompareToString()).append(ifEqualEqualCondition(brackets(OPEN_CLOSE_BRACKET_WITH_VALUE, MAX_RANGE, null), ONE)).append(signatureClose());
    } else {
        builder.append(getReturnString(VALUE, EIGHT_SPACE_INDENTATION)).append(getGreaterThanCondition()).append(ifAndAndCondition(MIN_RANGE, VALUE)).append(getLesserThanCondition()).append(MAX_RANGE).append(signatureClose());
    }
    builder.append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
private static String getGetMethodWithArgument(String returnType, String yangName) {
    return FOUR_SPACE_INDENTATION + returnType + SPACE + GET_METHOD_PREFIX + getCapitalCase(yangName) + OPEN_PARENTHESIS + returnType + OP_PARAM + SPACE + getSmallCase(returnType) + CLOSE_PARENTHESIS + SEMI_COLAN;
}
#method_after
private static String getGetMethodWithArgument(String returnType, String yangName) {
    return methodSignature(getCapitalCase(yangName), GET_METHOD_PREFIX, null, getSmallCase(returnType), returnType, returnType + OP_PARAM, INTERFACE_TYPE);
}
#end_block

#method_before
public static String getAddToListMethodInterface(JavaAttributeInfo attr, String className) {
    return FOUR_SPACE_INDENTATION + className + BUILDER + SPACE + ADD_STRING + getCapitalCase(TO) + getCapitalCase(attr.getAttributeName()) + OPEN_PARENTHESIS + getReturnType(attr) + SPACE + VALUE + CLOSE_PARENTHESIS + SEMI_COLAN;
}
#method_after
public static String getAddToListMethodInterface(JavaAttributeInfo attr, String className) {
    return methodSignature(ADD_STRING + TO_CAPS + getCapitalCase(attr.getAttributeName()), EMPTY_STRING, EMPTY_STRING, ADD_STRING + TO_CAPS, className + BUILDER, getReturnType(attr), INTERFACE_TYPE);
}
#end_block

#method_before
public static String getAddToListMethodImpl(JavaAttributeInfo attr, String generatedJavaClassName, boolean isRoot) {
    String retString = "";
    if (!isRoot) {
        retString = getOverRideString();
    }
    return retString + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + generatedJavaClassName + BUILDER + SPACE + ADD_STRING + getCapitalCase(TO) + getCapitalCase(attr.getAttributeName()) + OPEN_PARENTHESIS + getReturnType(attr) + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + getIfConditionForAddToListMethod(attr.getAttributeName()) + EIGHT_SPACE_INDENTATION + attr.getAttributeName() + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ADD_STRING + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
public static String getAddToListMethodImpl(JavaAttributeInfo attr, String name, boolean isRoot) {
    String attrName = attr.getAttributeName();
    String retString = "";
    if (!isRoot) {
        retString = getOverRideString();
    }
    StringBuilder builder = new StringBuilder(retString);
    builder.append(methodSignature(ADD_STRING + TO_CAPS + getCapitalCase(attrName), EMPTY_STRING, PUBLIC, ADD_STRING + TO_CAPS, name + BUILDER, getReturnType(attr), CLASS_TYPE)).append(getIfConditionForAddToListMethod(attrName));
    retString = EIGHT_SPACE_INDENTATION + attrName + PERIOD + ADD_STRING + OPEN_PARENTHESIS + ADD_STRING + TO_CAPS + CLOSE_PARENTHESIS;
    builder.append(retString).append(signatureClose()).append(getReturnString(THIS, EIGHT_SPACE_INDENTATION)).append(signatureClose()).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
private static String getIfConditionForAddToListMethod(String name) {
    return EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + name + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + EQUAL + EQUAL + SPACE + NULL + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + name + OPEN_PARENTHESIS + NEW + SPACE + ARRAY_LIST + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getIfConditionForAddToListMethod(String name) {
    return getIfConditionBegin(EIGHT_SPACE_INDENTATION, name + SPACE + EQUAL + EQUAL + SPACE + NULL) + TWELVE_SPACE_INDENTATION + name + SPACE + EQUAL + SPACE + NEW + SPACE + ARRAY_LIST + signatureClose() + methodClose(EIGHT_SPACE);
}
#end_block

#method_before
static String builderMethod(String name) {
    return NEW_LINE + generateForBuilderMethod(name) + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + name + BUILDER + SPACE + getSmallCase(BUILDER) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + name + BUILDER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
static String builderMethod(String name) {
    return generateForBuilderMethod(name) + methodSignature(BUILDER_LOWER_CASE, EMPTY_STRING, PUBLIC + SPACE + STATIC, null, name + BUILDER, null, CLASS_TYPE) + getReturnString(NEW + SPACE + name + BUILDER, EIGHT_SPACE_INDENTATION) + brackets(OPEN_CLOSE_BRACKET, null, null) + signatureClose() + methodClose(FOUR_SPACE);
}
#end_block

#method_before
static String processSubtreeFilteringInterface(String name) {
    String method = "    /**\n" + "     * Checks if the passed " + name + " maps the content match query condition.\n" + "     *\n" + "     * @param " + getSmallCase(name) + SPACE + getSmallCase(name) + SPACE + "being passed to check" + " for" + " content match\n" + "     * @param isSelectAllSchemaChild is select all schema child\n" + "     * @return match result\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + name + SPACE + PROCESS_SUBTREE_FILTERING + OPEN_PARENTHESIS + name + SPACE + getSmallCase(name) + COMMA + SPACE + BOOLEAN_DATA_TYPE + SPACE + "isSelectAllSchemaChild" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String processSubtreeFilteringInterface(String name) {
    String method = "   /**\n" + "     * Checks if the passed " + name + " maps the content match query condition.\n" + "     *\n" + "     * @param " + getSmallCase(name) + SPACE + getSmallCase(name) + SPACE + "being passed to check" + " for" + " content match\n" + "     * @param isSelectAllSchemaChild is select all schema child\n" + "     * @return match result\n" + "     */\n";
    LinkedHashMap<String, String> map = new LinkedHashMap<>();
    map.put(name, getSmallCase(name));
    map.put(BOOLEAN_DATA_TYPE, SELECT_ALL_CHILD);
    return method + multiAttrMethodSignature(PROCESS_SUBTREE_FILTERING, EMPTY_STRING, EMPTY_STRING, name, map, INTERFACE_TYPE);
}
#end_block

#method_before
static String isLeafValueSetInterface() {
    String method = "    /**\n" + "     * Checks if the leaf value is set.\n" + "     *\n" + "     * @param leaf leaf whose value status needs to checked\n" + "     * @return result of leaf value set in object\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + BOOLEAN_DATA_TYPE + SPACE + VALUE_LEAF_SET + OPEN_PARENTHESIS + LEAF_IDENTIFIER + SPACE + "leaf" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String isLeafValueSetInterface() {
    String method = "\n    /**\n" + "     * Checks if the leaf value is set.\n" + "     *\n" + "     * @param leaf leaf whose value status needs to checked\n" + "     * @return result of leaf value set in object\n" + "     */\n";
    return method + methodSignature(VALUE_LEAF_SET, EMPTY_STRING, null, LEAF, BOOLEAN_DATA_TYPE, LEAF_IDENTIFIER, INTERFACE_TYPE);
}
#end_block

#method_before
static String isSelectLeafSetInterface() {
    String method = "    /**\n" + "     * Checks if the leaf is set to be a selected leaf.\n" + "     *\n" + "     * @param leaf if leaf needs to be selected\n" + "     * @return result of leaf value set in object\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + BOOLEAN_DATA_TYPE + SPACE + IS_SELECT_LEAF + OPEN_PARENTHESIS + LEAF_IDENTIFIER + SPACE + "leaf" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String isSelectLeafSetInterface() {
    String method = "\n    /**\n" + "     * Checks if the leaf is set to be a selected leaf.\n" + "     *\n" + "     * @param leaf if leaf needs to be selected\n" + "     * @return result of leaf value set in object\n" + "     */\n";
    return method + methodSignature(IS_SELECT_LEAF, EMPTY_STRING, null, LEAF, BOOLEAN_DATA_TYPE, LEAF_IDENTIFIER, INTERFACE_TYPE);
}
#end_block

#method_before
static String setSelectLeafSetInterface(String name) {
    String method = "    /**\n" + "     * Set a leaf to be selected.\n" + "     *\n" + "     * @param leaf leaf needs to be selected\n" + "     * @return builder object for select leaf\n" + "     */\n";
    return method + FOUR_SPACE_INDENTATION + name + BUILDER + SPACE + SET_SELECT_LEAF + OPEN_PARENTHESIS + LEAF_IDENTIFIER + SPACE + "leaf" + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
}
#method_after
static String setSelectLeafSetInterface(String name) {
    String method = "    /**\n" + "     * Set a leaf to be selected.\n" + "     *\n" + "     * @param leaf leaf needs to be selected\n" + "     * @return builder object for select leaf\n" + "     */\n";
    return method + methodSignature(SET_SELECT_LEAF, EMPTY_STRING, null, LEAF, name + BUILDER, LEAF_IDENTIFIER, INTERFACE_TYPE) + NEW_LINE;
}
#end_block

#method_before
static String getInterfaceLeafIdEnumSignature(String name) {
    String start = "    /**\n" + "     * Identify the leaf of " + name + PERIOD + NEW_LINE + "     */\n";
    return start + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + ENUM + SPACE + LEAF_IDENTIFIER + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#method_after
static String getInterfaceLeafIdEnumSignature(String name) {
    String start = "\n    /**\n" + "     * Identify the leaf of " + name + PERIOD + NEW_LINE + "     */\n";
    return start + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + ENUM + SPACE + LEAF_IDENTIFIER + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
@Override
public void addToChildSchemaMap(YangSchemaNodeIdentifier schemaNodeIdentifier, YangSchemaNodeContextInfo yangSchemaNodeContextInfo) {
    getYsnContextInfoMap().put(schemaNodeIdentifier, yangSchemaNodeContextInfo);
}
#method_after
@Override
public void addToChildSchemaMap(YangSchemaNodeIdentifier id, YangSchemaNodeContextInfo context) {
    getYsnContextInfoMap().put(id, context);
}
#end_block

#method_before
@Override
public void addToDefaultChildMap(YangSchemaNodeIdentifier yangSchemaNodeIdentifier, YangSchemaNode yangSchemaNode) {
// TODO
}
#method_after
@Override
public void addToDefaultChildMap(YangSchemaNodeIdentifier id, YangSchemaNode node) {
// TODO
}
#end_block

#method_before
@Override
public YangSchemaNodeType getYangSchemaNodeType() {
    return YangSchemaNodeType.YANG_SINGLE_INSTANCE_NODE;
}
#method_after
@Override
public YangSchemaNodeType getYangSchemaNodeType() {
    return YANG_SINGLE_INSTANCE_NODE;
}
#end_block

#method_before
@Override
public List<YangImport> getImportList() {
    return importList;
}
#method_after
@Override
public List<YangImport> getImportList() {
    return unmodifiableList(importList);
}
#end_block

#method_before
@Override
public void addToImportList(YangImport importedModule) {
    getImportList().add(importedModule);
}
#method_after
@Override
public void addToImportList(YangImport importedModule) {
    importList.add(importedModule);
}
#end_block

#method_before
@Override
public List<YangInclude> getIncludeList() {
    return includeList;
}
#method_after
@Override
public List<YangInclude> getIncludeList() {
    return unmodifiableList(includeList);
}
#end_block

#method_before
@Override
public void addToIncludeList(YangInclude includeModule) {
    getIncludeList().add(includeModule);
}
#method_after
@Override
public void addToIncludeList(YangInclude includeModule) {
    includeList.add(includeModule);
}
#end_block

#method_before
@Override
public List<YangLeaf> getListOfLeaf() {
    return listOfLeaf;
}
#method_after
@Override
public List<YangLeaf> getListOfLeaf() {
    return unmodifiableList(listOfLeaf);
}
#end_block

#method_before
@Override
public void addLeaf(YangLeaf leaf) {
    getListOfLeaf().add(leaf);
}
#method_after
@Override
public void addLeaf(YangLeaf leaf) {
    listOfLeaf.add(leaf);
}
#end_block

#method_before
@Override
public List<YangLeafList> getListOfLeafList() {
    return listOfLeafList;
}
#method_after
@Override
public List<YangLeafList> getListOfLeafList() {
    return unmodifiableList(listOfLeafList);
}
#end_block

#method_before
@Override
public void addLeafList(YangLeafList leafList) {
    getListOfLeafList().add(leafList);
}
#method_after
@Override
public void addLeafList(YangLeafList leafList) {
    listOfLeafList.add(leafList);
}
#end_block

#method_before
@Override
public List<YangFeature> getFeatureList() {
    return listOfFeature;
}
#method_after
@Override
public List<YangFeature> getFeatureList() {
    return unmodifiableList(listOfFeature);
}
#end_block

#method_before
@Override
public void addFeatureList(YangFeature feature) {
    if (getFeatureList() == null) {
        setListOfFeature(new LinkedList<>());
    }
    getFeatureList().add(feature);
}
#method_after
@Override
public void addFeatureList(YangFeature feature) {
    listOfFeature.add(feature);
}
#end_block

#method_before
public void addExtension(YangExtension extension) {
    getExtensionList().add(extension);
}
#method_after
public void addExtension(YangExtension extension) {
    extensionList.add(extension);
}
#end_block

#method_before
public List<YangExtension> getExtensionList() {
    return extensionList;
}
#method_after
public List<YangExtension> getExtensionList() {
    return unmodifiableList(extensionList);
}
#end_block

#method_before
public void addToExtensionList(YangExtension extension) {
    if (getExtensionList() == null) {
        setExtensionList(new LinkedList<>());
    }
    getExtensionList().add(extension);
}
#method_after
public void addToExtensionList(YangExtension extension) {
    extensionList.add(extension);
}
#end_block

#method_before
@Override
public YangConstructType getYangConstructType() {
    return YangConstructType.MODULE_DATA;
}
#method_after
@Override
public YangConstructType getYangConstructType() {
    return MODULE_DATA;
}
#end_block

#method_before
@Override
public List<YangResolutionInfo> getUnresolvedResolutionList(ResolvableType type) {
    if (type == ResolvableType.YANG_DERIVED_DATA_TYPE) {
        return derivedTypeResolutionList;
    } else if (type == ResolvableType.YANG_USES) {
        return usesResolutionList;
    } else if (type == ResolvableType.YANG_AUGMENT) {
        return augmentResolutionList;
    } else if (type == ResolvableType.YANG_IF_FEATURE) {
        return ifFeatureResolutionList;
    } else if (type == ResolvableType.YANG_LEAFREF) {
        return leafRefResolutionList;
    } else if (type == ResolvableType.YANG_BASE) {
        return baseResolutionList;
    } else if (type == ResolvableType.YANG_IDENTITYREF) {
        return identityRefResolutionList;
    } else {
        return compilerAnnotationList;
    }
}
#method_after
@Override
public List<YangResolutionInfo> getUnresolvedResolutionList(ResolvableType type) {
    if (type == YANG_DERIVED_DATA_TYPE) {
        return unmodifiableList(derivedTypeResolutionList);
    } else if (type == YANG_USES) {
        return unmodifiableList(usesResolutionList);
    } else if (type == YANG_AUGMENT) {
        return unmodifiableList(augmentResolutionList);
    } else if (type == YANG_IF_FEATURE) {
        return unmodifiableList(ifFeatureResolutionList);
    } else if (type == YANG_LEAFREF) {
        return unmodifiableList(leafRefResolutionList);
    } else if (type == YANG_BASE) {
        return unmodifiableList(baseResolutionList);
    } else if (type == YANG_IDENTITYREF) {
        return unmodifiableList(identityRefResolutionList);
    } else {
        return unmodifiableList(compilerAnnotationList);
    }
}
#end_block

#method_before
@Override
public void addToResolutionList(YangResolutionInfo resolutionInfo, ResolvableType type) {
    if (type == ResolvableType.YANG_DERIVED_DATA_TYPE) {
        derivedTypeResolutionList.add(resolutionInfo);
    } else if (type == ResolvableType.YANG_USES) {
        usesResolutionList.add(resolutionInfo);
    } else if (type == ResolvableType.YANG_IF_FEATURE) {
        ifFeatureResolutionList.add(resolutionInfo);
    } else if (type == ResolvableType.YANG_LEAFREF) {
        leafRefResolutionList.add(resolutionInfo);
    } else if (type == ResolvableType.YANG_BASE) {
        baseResolutionList.add(resolutionInfo);
    } else if (type == ResolvableType.YANG_AUGMENT) {
        augmentResolutionList.add(resolutionInfo);
    } else if (type == ResolvableType.YANG_IDENTITYREF) {
        identityRefResolutionList.add(resolutionInfo);
    } else if (type == ResolvableType.YANG_COMPILER_ANNOTATION) {
        compilerAnnotationList.add(resolutionInfo);
    }
}
#method_after
@Override
public void addToResolutionList(YangResolutionInfo info, ResolvableType type) {
    if (type == YANG_DERIVED_DATA_TYPE) {
        derivedTypeResolutionList.add(info);
    } else if (type == YANG_USES) {
        usesResolutionList.add(info);
    } else if (type == YANG_IF_FEATURE) {
        ifFeatureResolutionList.add(info);
    } else if (type == YANG_LEAFREF) {
        leafRefResolutionList.add(info);
    } else if (type == YANG_BASE) {
        baseResolutionList.add(info);
    } else if (type == YANG_AUGMENT) {
        augmentResolutionList.add(info);
    } else if (type == YANG_IDENTITYREF) {
        identityRefResolutionList.add(info);
    } else if (type == YANG_COMPILER_ANNOTATION) {
        compilerAnnotationList.add(info);
    }
}
#end_block

#method_before
@Override
public void setResolutionList(List<YangResolutionInfo> resolutionList, ResolvableType type) {
    if (type == ResolvableType.YANG_DERIVED_DATA_TYPE) {
        derivedTypeResolutionList = resolutionList;
    } else if (type == ResolvableType.YANG_USES) {
        usesResolutionList = resolutionList;
    } else if (type == ResolvableType.YANG_IF_FEATURE) {
        ifFeatureResolutionList.add((YangResolutionInfo) resolutionList);
    } else if (type == ResolvableType.YANG_LEAFREF) {
        leafRefResolutionList = resolutionList;
    } else if (type == ResolvableType.YANG_BASE) {
        baseResolutionList = resolutionList;
    } else if (type == ResolvableType.YANG_AUGMENT) {
        augmentResolutionList = resolutionList;
    } else if (type == ResolvableType.YANG_IDENTITYREF) {
        identityRefResolutionList = resolutionList;
    } else if (type == ResolvableType.YANG_COMPILER_ANNOTATION) {
        compilerAnnotationList = resolutionList;
    }
}
#method_after
@Override
public void setResolutionList(List<YangResolutionInfo> resolutionList, ResolvableType type) {
    if (type == YANG_DERIVED_DATA_TYPE) {
        derivedTypeResolutionList = resolutionList;
    } else if (type == YANG_USES) {
        usesResolutionList = resolutionList;
    } else if (type == YANG_IF_FEATURE) {
        ifFeatureResolutionList.add((YangResolutionInfo) resolutionList);
    } else if (type == YANG_LEAFREF) {
        leafRefResolutionList = resolutionList;
    } else if (type == YANG_BASE) {
        baseResolutionList = resolutionList;
    } else if (type == YANG_AUGMENT) {
        augmentResolutionList = resolutionList;
    } else if (type == YANG_IDENTITYREF) {
        identityRefResolutionList = resolutionList;
    } else if (type == YANG_COMPILER_ANNOTATION) {
        compilerAnnotationList = resolutionList;
    }
}
#end_block

#method_before
@Override
public void addReferencesToImportList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangImport> importInfoIterator = getImportList().iterator();
    // Run through the imported list to add references.
    while (importInfoIterator.hasNext()) {
        YangImport yangImport = importInfoIterator.next();
        yangImport.addReferenceToImport(yangNodeSet);
    }
}
#method_after
@Override
public void addReferencesToImportList(Set<YangNode> yangNodeSet) throws DataModelException {
    // Run through the imported list to add references.
    for (YangImport yangImport : getImportList()) {
        yangImport.addReferenceToImport(yangNodeSet);
    }
}
#end_block

#method_before
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangInclude> includeInfoIterator = getIncludeList().iterator();
    // Run through the included list to add references.
    while (includeInfoIterator.hasNext()) {
        YangInclude yangInclude = includeInfoIterator.next();
        YangSubModule subModule = null;
        subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        // Check if the referred sub-modules parent is self
        if (!(subModule.getBelongsTo().getModuleNode() == this)) {
            yangInclude.reportIncludeError();
        }
    }
}
#method_after
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    // Run through the included list to add references.
    for (YangInclude yangInclude : getIncludeList()) {
        YangSubModule subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        // Check if the referred sub-modules parent is self
        if (!subModule.getBelongsTo().getModuleNode().equals(this)) {
            yangInclude.reportIncludeError();
        }
    }
}
#end_block

#method_before
@Override
public void addToNotificationEnumMap(String nameOfNotificationInEnum, YangSchemaNode notficationSchemaNode) {
    getNotificationEnumMap().put(nameOfNotificationInEnum, notficationSchemaNode);
}
#method_after
@Override
public void addToNotificationEnumMap(String enumName, YangSchemaNode notification) {
    notificationEnumMap.put(enumName, notification);
}
#end_block

#method_before
@Override
public YangSchemaNode getNotificationSchemaNode(String notificationNameInEnum) {
    return getNotificationEnumMap().get(notificationNameInEnum);
}
#method_after
@Override
public YangSchemaNode getNotificationSchemaNode(String enumName) {
    return notificationEnumMap.get(enumName);
}
#end_block

#method_before
public void start() {
    log.info("Starting Port Stats collection thread for {}", ofSwitch.getStringId());
    executor.scheduleWithFixedDelay(this::sendPortStatistic, 0, refreshInterval, TimeUnit.SECONDS);
}
#method_after
public synchronized void start() {
    log.info("Starting Port Stats collection thread for {}", sw.getStringId());
    task = new InternalTimerTask();
    SharedExecutors.getTimer().scheduleAtFixedRate(task, 1 * SECONDS, refreshInterval * SECONDS);
}
#end_block

#method_before
public synchronized void stop() {
    log.info("Stopping Port Stats collection thread for {}", ofSwitch.getStringId());
    executor.shutdown();
    executor = null;
}
#method_after
public synchronized void stop() {
    log.info("Stopping Port Stats collection thread for {}", sw.getStringId());
    task.cancel();
    task = null;
}
#end_block

#method_before
synchronized void adjustPollInterval(int pollInterval) {
    this.refreshInterval = pollInterval;
    restartCollector();
}
#method_after
public synchronized void adjustPollInterval(int pollInterval) {
    this.refreshInterval = pollInterval;
    task.cancel();
    task = new InternalTimerTask();
    timer.scheduleAtFixedRate(task, refreshInterval * SECONDS, refreshInterval * SECONDS);
}
#end_block

#method_before
private void sendPortStatistic() {
    if (ofSwitch.getRole() != RoleState.MASTER) {
        return;
    }
    Long statsXid = xidAtomic.getAndIncrement();
    OFPortStatsRequest statsRequest = ofSwitch.factory().buildPortStatsRequest().setPortNo(OFPort.ANY).setXid(statsXid).build();
    ofSwitch.sendMsg(statsRequest);
    log.trace("Collecting stats for {}", ofSwitch.getStringId());
}
#method_after
private void sendPortStatistic() {
    if (sw.getRole() != RoleState.MASTER) {
        return;
    }
    Long statsXid = xidAtomic.getAndIncrement();
    OFPortStatsRequest statsRequest = sw.factory().buildPortStatsRequest().setPortNo(OFPort.ANY).setXid(statsXid).build();
    sw.sendMsg(statsRequest);
}
#end_block

#method_before
private void processPortAdded(Port port) {
    // TODO check the node state is COMPLETE
    OpenstackPort osPort = openstackService.port(port);
    if (osPort == null) {
        log.warn("Failed to get OpenStack port for {}", port);
        return;
    }
    OpenstackNetwork osNet = openstackService.network(osPort.networkId());
    if (osNet == null) {
        log.warn("Failed to get OpenStack network {}", osPort.networkId());
        return;
    }
    Map.Entry<String, Ip4Address> fixedIp = osPort.fixedIps().entrySet().stream().findFirst().get();
    OpenstackSubnet openstackSubnet = openstackService.subnets().stream().filter(n -> n.networkId().equals(osPort.networkId()) && n.id().equals(fixedIp.getKey())).findFirst().orElse(null);
    if (openstackSubnet == null) {
        log.warn("Failed to find subnet for {}", osPort);
        return;
    }
    registerDhcpInfo(osPort, openstackSubnet);
    ConnectPoint connectPoint = new ConnectPoint(port.element().id(), port.number());
    // Added CREATE_TIME intentionally to trigger HOST_UPDATED event for the
    // existing instances.
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(NETWORK_ID, osPort.networkId()).set(SUBNET_ID, fixedIp.getKey()).set(PORT_ID, osPort.id()).set(VXLAN_ID, osNet.segmentId()).set(TENANT_ID, osNet.tenantId()).set(GATEWAY_IP, openstackSubnet.gatewayIp());
    HostDescription hostDesc = new DefaultHostDescription(osPort.macAddress(), VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), Sets.newHashSet(osPort.fixedIps().values()), annotations.build());
    HostId hostId = HostId.hostId(osPort.macAddress());
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#method_after
private void processPortAdded(Port port) {
    // TODO check the node state is COMPLETE
    OpenstackPort osPort = openstackService.port(port);
    if (osPort == null) {
        log.warn("Failed to get OpenStack port for {}", port);
        return;
    }
    OpenstackNetwork osNet = openstackService.network(osPort.networkId());
    if (osNet == null) {
        log.warn("Failed to get OpenStack network {}", osPort.networkId());
        return;
    }
    Map.Entry<String, Ip4Address> fixedIp = osPort.fixedIps().entrySet().stream().findFirst().get();
    OpenstackSubnet openstackSubnet = openstackService.subnets().stream().filter(n -> n.networkId().equals(osPort.networkId()) && n.id().equals(fixedIp.getKey())).findFirst().orElse(null);
    if (openstackSubnet == null) {
        log.warn("Failed to find subnet for {}", osPort);
        return;
    }
    registerDhcpInfo(osPort, openstackSubnet);
    ConnectPoint connectPoint = new ConnectPoint(port.element().id(), port.number());
    // Added CREATE_TIME intentionally to trigger HOST_UPDATED event for the
    // existing instances.
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(NETWORK_ID, osPort.networkId()).set(SUBNET_ID, fixedIp.getKey()).set(PORT_ID, osPort.id()).set(VXLAN_ID, osNet.segmentId()).set(TENANT_ID, osNet.tenantId()).set(GATEWAY_IP, openstackSubnet.gatewayIp()).set(CREATE_TIME, String.valueOf(System.currentTimeMillis()));
    HostDescription hostDesc = new DefaultHostDescription(osPort.macAddress(), VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), Sets.newHashSet(osPort.fixedIps().values()), annotations.build());
    HostId hostId = HostId.hostId(osPort.macAddress());
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#end_block

