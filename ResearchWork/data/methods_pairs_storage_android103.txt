403
#method_before
// This test may fail on kernel between 4.4 and 4.9, due to a kernel implementation detail
// change. Backporting the following kernel change will fix the test. http://b/31960002
public void testCreateServerSocketWithPortNoBacklog() throws IOException {
    ServerSocket serverSocket = ServerSocketFactory.getDefault().createServerSocket(0, 1);
    testSocket(serverSocket, 1);
}
#method_after
// This test may fail on kernel versions between 4.4 and 4.9, due to a kernel implementation
// detail change. Backporting the following kernel change will fix the behavior.
// http://b/31960002
public void testCreateServerSocketWithPortNoBacklog() throws IOException {
    ServerSocket serverSocket = ServerSocketFactory.getDefault().createServerSocket(0, 1);
    testSocket(serverSocket, 1);
}
#end_block

#method_before
@Test
public void testSubclassHasNoBridgeMethod() throws NoSuchMethodException {
    try {
        Method method = IoTracker.Mode.class.getMethod("compareTo", new Class[] { java.lang.Object.class });
        assertTrue(method.isBridge());
        assertTrue(method.isSynthetic());
        assertSame(method.getDeclaringClass(), java.lang.Enum.class);
    } catch (NoSuchMethodException e) {
        fail(e.getMessage());
    }
}
#method_after
@Test
public void testSubclassHasNoBridgeMethod() throws NoSuchMethodException {
    Method method = IoTracker.Mode.class.getMethod("compareTo", new Class[] { java.lang.Object.class });
    assertTrue(method.isBridge());
    assertTrue(method.isSynthetic());
    assertSame("Extra bridge methods found, use a javac that supports " + "-XDskipDuplicateBridges=true or set TURBINE_ENABLED=false " + "when building the platform", method.getDeclaringClass(), java.lang.Enum.class);
}
#end_block

#method_before
@VisibleForTesting
public void updatePhoneType() {
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mRestrictedState = new RestrictedState();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
        mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
    } else {
        // clear GSM regsitrations first
        mCi.unregisterForAvailable(this);
        mCi.unSetOnRestrictedStateChanged(this);
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that we've thrown away state and are starting over with
    // empty, detached ServiceStates.
    mVoiceRoamingOffRegistrants.notifyRegistrants();
    mDataRoamingOffRegistrants.notifyRegistrants();
    mDetachedRegistrants.notifyRegistrants();
    notifyDataRegStateRilRadioTechnologyChanged();
}
#method_after
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#end_block

#method_before
protected boolean notifySignalStrength() {
    boolean notified = false;
    if (!mSignalStrength.equals(mLastSignalStrength)) {
        try {
            mPhone.notifySignalStrength();
            notified = true;
        } catch (NullPointerException ex) {
            loge("updateSignalStrength() Phone already destroyed: " + ex + "SignalStrength not notified");
        }
    }
    return notified;
}
#method_after
protected boolean notifySignalStrength() {
    boolean notified = false;
    if (!mSignalStrength.equals(mLastSignalStrength)) {
        try {
            mPhone.notifySignalStrength();
            notified = true;
            mLastSignalStrength = mSignalStrength;
        } catch (NullPointerException ex) {
            loge("updateSignalStrength() Phone already destroyed: " + ex + "SignalStrength not notified");
        }
    }
    return notified;
}
#end_block

#method_before
public void registerForDataRoamingOff(Handler h, int what, Object obj) {
    Registrant r = new Registrant(h, what, obj);
    mDataRoamingOffRegistrants.add(r);
    if (!mSS.getDataRoaming()) {
        r.notifyRegistrant();
    }
}
#method_after
public void registerForDataRoamingOff(Handler h, int what, Object obj, boolean notifyNow) {
    Registrant r = new Registrant(h, what, obj);
    mDataRoamingOffRegistrants.add(r);
    if (notifyNow && !mSS.getDataRoaming()) {
        r.notifyRegistrant();
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_RADIO_AVAILABLE:
            // setPowerStateToDesired();
            break;
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_SIM_LOCKED:
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                log("EVENT_SIM_LOCKED received");
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
public int getOtasp() {
    int provisioningState;
    // if sim is not loaded, return otasp uninitialized
    if (!mPhone.getIccRecordsLoaded()) {
        if (DBG)
            log("getOtasp: otasp uninitialized due to sim not loaded");
        return OTASP_UNINITIALIZED;
    }
    // if voice tech is Gsm, return otasp not needed
    if (mPhone.isPhoneTypeGsm()) {
        if (DBG)
            log("getOtasp: otasp not needed for GSM");
        return OTASP_NOT_NEEDED;
    }
    // for ruim, min is null means require otasp.
    if (mIsSubscriptionFromRuim && mMin == null) {
        return OTASP_NEEDED;
    }
    if (mMin == null || (mMin.length() < 6)) {
        if (DBG)
            log("getOtasp: bad mMin='" + mMin + "'");
        provisioningState = OTASP_UNKNOWN;
    } else {
        if ((mMin.equals(UNACTIVATED_MIN_VALUE) || mMin.substring(0, 6).equals(UNACTIVATED_MIN2_VALUE)) || SystemProperties.getBoolean("test_cdma_setup", false)) {
            provisioningState = OTASP_NEEDED;
        } else {
            provisioningState = OTASP_NOT_NEEDED;
        }
    }
    if (DBG)
        log("getOtasp: state=" + provisioningState);
    return provisioningState;
}
#method_after
public int getOtasp() {
    int provisioningState;
    // if sim is not loaded, return otasp uninitialized
    if (!mPhone.getIccRecordsLoaded()) {
        if (DBG)
            log("getOtasp: otasp uninitialized due to sim not loaded");
        return TelephonyManager.OTASP_UNINITIALIZED;
    }
    // if voice tech is Gsm, return otasp not needed
    if (mPhone.isPhoneTypeGsm()) {
        if (DBG)
            log("getOtasp: otasp not needed for GSM");
        return TelephonyManager.OTASP_NOT_NEEDED;
    }
    // for ruim, min is null means require otasp.
    if (mIsSubscriptionFromRuim && mMin == null) {
        return TelephonyManager.OTASP_NEEDED;
    }
    if (mMin == null || (mMin.length() < 6)) {
        if (DBG)
            log("getOtasp: bad mMin='" + mMin + "'");
        provisioningState = TelephonyManager.OTASP_UNKNOWN;
    } else {
        if ((mMin.equals(UNACTIVATED_MIN_VALUE) || mMin.substring(0, 6).equals(UNACTIVATED_MIN2_VALUE)) || SystemProperties.getBoolean("test_cdma_setup", false)) {
            provisioningState = TelephonyManager.OTASP_NEEDED;
        } else {
            provisioningState = TelephonyManager.OTASP_NOT_NEEDED;
        }
    }
    if (DBG)
        log("getOtasp: state=" + provisioningState);
    return provisioningState;
}
#end_block

#method_before
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
            }
            // For CDMA, voice and data should have the same roaming status
            final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
            final int dataRegType = mNewSS.getRilDataRadioTechnology();
            if (isVoiceInService && ServiceState.isCdma(dataRegType)) {
                mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#method_after
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                boolean isRoamingBetweenOperators = isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS);
                if (isRoamingBetweenOperators != mNewSS.getVoiceRoaming()) {
                    log("isRoamingBetweenOperators=" + isRoamingBetweenOperators + ". Override CDMA voice roaming to " + isRoamingBetweenOperators);
                    mNewSS.setVoiceRoaming(isRoamingBetweenOperators);
                }
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    boolean isVoiceRoaming = mNewSS.getVoiceRoaming();
                    if (mNewSS.getDataRoaming() != isVoiceRoaming) {
                        log("Data roaming != Voice roaming. Override data roaming to " + isVoiceRoaming);
                        mNewSS.setDataRoaming(isVoiceRoaming);
                    }
                } else {
                    /**
                     * As per VoiceRegStateResult from radio types.hal the TSB58
                     * Roaming Indicator shall be sent if device is registered
                     * on a CDMA or EVDO system.
                     */
                    boolean isRoamIndForHomeSystem = isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator));
                    if (mNewSS.getDataRoaming() == isRoamIndForHomeSystem) {
                        log("isRoamIndForHomeSystem=" + isRoamIndForHomeSystem + ", override data roaming to " + !isRoamIndForHomeSystem);
                        mNewSS.setDataRoaming(!isRoamIndForHomeSystem);
                    }
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    // init with 0, because it is treated as a boolean
                    int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setCssIndicator(cssIndicator);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
private boolean isRoamIndForHomeSystem(String roamInd) {
    // retrieve the carrier-specified list of ERIs for home system
    String[] homeRoamIndicators = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.config_cdma_home_system);
    if (homeRoamIndicators != null) {
        // return true if one is found.
        for (String homeRoamInd : homeRoamIndicators) {
            if (homeRoamInd.equals(roamInd)) {
                return true;
            }
        }
        // no matches found against the list!
        return false;
    }
    // no system property found for the roaming indicators for home system
    return false;
}
#method_after
private boolean isRoamIndForHomeSystem(String roamInd) {
    // retrieve the carrier-specified list of ERIs for home system
    String[] homeRoamIndicators = Resources.getSystem().getStringArray(com.android.internal.R.array.config_cdma_home_system);
    log("isRoamIndForHomeSystem: homeRoamIndicators=" + Arrays.toString(homeRoamIndicators));
    if (homeRoamIndicators != null) {
        // return true if one is found.
        for (String homeRoamInd : homeRoamIndicators) {
            if (homeRoamInd.equals(roamInd)) {
                return true;
            }
        }
        // no matches found against the list!
        log("isRoamIndForHomeSystem: No match found against list for roamInd=" + roamInd);
        return false;
    }
    // no system property found for the roaming indicators for home system
    log("isRoamIndForHomeSystem: No list found");
    return false;
}
#end_block

#method_before
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            roaming = false;
        }
        // Save the roaming state before carrier config possibly overrides it.
        mNewSS.setDataRoamingFromRegistration(roaming);
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        // Save the roaming state before carrier config possibly overrides it.
        mNewSS.setDataRoamingFromRegistration(mNewSS.getDataRoaming());
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#method_after
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            log("updateRoamingState: resource override set non roaming.isSameNamedOperators=" + isSameNamedOperators(mNewSS) + ",isOperatorConsideredNonRoaming=" + isOperatorConsideredNonRoaming(mNewSS));
            roaming = false;
        }
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = getUiccCardApplication();
    if (mUiccApplcation != newUiccApplication) {
        mIsSimReady = false;
        if (mUiccApplcation != null) {
            log("Removing stale icc objects.");
            mUiccApplcation.unregisterForReady(this);
            mUiccApplcation.unregisterForLocked(this);
            if (mIccRecords != null) {
                mIccRecords.unregisterForRecordsLoaded(this);
            }
            mIccRecords = null;
            mUiccApplcation = null;
        }
        if (newUiccApplication != null) {
            log("New card found");
            mUiccApplcation = newUiccApplication;
            mIccRecords = mUiccApplcation.getIccRecords();
            if (mPhone.isPhoneTypeGsm()) {
                mUiccApplcation.registerForReady(this, EVENT_SIM_READY, null);
                mUiccApplcation.registerForLocked(this, EVENT_SIM_LOCKED, null);
                if (mIccRecords != null) {
                    mIccRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
                }
            } else if (mIsSubscriptionFromRuim) {
                mUiccApplcation.registerForReady(this, EVENT_RUIM_READY, null);
                if (mIccRecords != null) {
                    mIccRecords.registerForRecordsLoaded(this, EVENT_RUIM_RECORDS_LOADED, null);
                }
            }
        }
    }
}
#method_after
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = getUiccCardApplication();
    if (mUiccApplcation != newUiccApplication) {
        if (mUiccApplcation != null) {
            log("Removing stale icc objects.");
            mUiccApplcation.unregisterForReady(this);
            if (mIccRecords != null) {
                mIccRecords.unregisterForRecordsLoaded(this);
            }
            mIccRecords = null;
            mUiccApplcation = null;
        }
        if (newUiccApplication != null) {
            log("New card found");
            mUiccApplcation = newUiccApplication;
            mIccRecords = mUiccApplcation.getIccRecords();
            if (mPhone.isPhoneTypeGsm()) {
                mUiccApplcation.registerForReady(this, EVENT_SIM_READY, null);
                if (mIccRecords != null) {
                    mIccRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
                }
            } else if (mIsSubscriptionFromRuim) {
                mUiccApplcation.registerForReady(this, EVENT_RUIM_READY, null);
                if (mIccRecords != null) {
                    mIccRecords.registerForRecordsLoaded(this, EVENT_RUIM_RECORDS_LOADED, null);
                }
            }
        }
    }
}
#end_block

#method_before
public boolean isConcurrentVoiceAndDataAllowed() {
    if (mPhone.isPhoneTypeGsm()) {
        return (mSS.getRilVoiceRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else if (mPhone.isPhoneTypeCdma()) {
        // For the time-being, the return value will be false.
        return false;
    } else {
        // Using the Conncurrent Service Supported flag for CdmaLte devices.
        return mSS.getCssIndicator() == 1;
    }
}
#method_after
public boolean isConcurrentVoiceAndDataAllowed() {
    if (mSS.getCssIndicator() == 1) {
        // Checking the Concurrent Service Supported flag first for all phone types.
        return true;
    } else if (mPhone.isPhoneTypeGsm()) {
        return (mSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        return false;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(mRejectCode == 0 ? CS_REJECT_CAUSE_DISABLED : CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    mTimeZoneLog.log("pollStateDone: set time zone=" + zone.getID() + " mcc=" + mcc + " iso=" + iso);
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify using PhoneStateListener and the legacy intent ACTION_SERVICE_STATE_CHANGED
        mPhone.notifyServiceStateChanged(mSS);
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(mRejectCode == 0 ? CS_REJECT_CAUSE_DISABLED : CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                updateTimeZoneByNetworkCountryCode(iso);
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify using PhoneStateListener and the legacy intent ACTION_SERVICE_STATE_CHANGED
        mPhone.notifyServiceStateChanged(mSS);
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
protected void fixTimeZone(String isoCountryCode) {
    TimeZone zone = null;
    // If the offset is (0, false) and the time zone property
    // is set, use the time zone property rather than GMT.
    final String zoneName = SystemProperties.get(TIMEZONE_PROPERTY);
    if (DBG) {
        log("fixTimeZone zoneName='" + zoneName + "' mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst + " iso-cc='" + isoCountryCode + "' iso-cc-idx=" + Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode));
    }
    if ("".equals(isoCountryCode) && mNeedFixZoneAfterNitz) {
        // Country code not found.  This is likely a test network.
        // Get a TimeZone based only on the NITZ parameters (best guess).
        zone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (DBG)
            log("pollStateDone: using NITZ TimeZone");
    } else if ((mZoneOffset == 0) && (mZoneDst == false) && (zoneName != null) && (zoneName.length() > 0) && (Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode) < 0)) {
        // For NITZ string without time zone,
        // need adjust time to reflect default time zone setting
        zone = TimeZone.getDefault();
        if (mNeedFixZoneAfterNitz) {
            long ctm = System.currentTimeMillis();
            long tzOffset = zone.getOffset(ctm);
            if (DBG) {
                log("fixTimeZone: tzOffset=" + tzOffset + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            if (getAutoTime()) {
                long adj = ctm - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj ltod=" + TimeUtils.logTimeOfDay(adj));
                setAndBroadcastNetworkSetTime(adj);
            } else {
                // Adjust the saved NITZ time to account for tzOffset.
                mSavedTime = mSavedTime - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj mSavedTime=" + mSavedTime);
            }
        }
        if (DBG)
            log("fixTimeZone: using default TimeZone");
    } else {
        zone = TimeUtils.getTimeZone(mZoneOffset, mZoneDst, mZoneTime, isoCountryCode);
        if (DBG)
            log("fixTimeZone: using getTimeZone(off, dst, time, iso)");
    }
    final String tmpLog = "fixTimeZone zoneName=" + zoneName + " mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst + " iso-cc=" + isoCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " zone=" + (zone != null ? zone.getID() : "NULL");
    mTimeZoneLog.log(tmpLog);
    mNeedFixZoneAfterNitz = false;
    if (zone != null) {
        log("fixTimeZone: zone != null zone.getID=" + zone.getID());
        if (getAutoTimeZone()) {
            setAndBroadcastNetworkSetTimeZone(zone.getID());
        } else {
            log("fixTimeZone: skip changing zone as getAutoTimeZone was false");
        }
        saveNitzTimeZone(zone.getID());
    } else {
        log("fixTimeZone: zone == null, do nothing for zone");
    }
}
#method_after
protected void fixTimeZone(String isoCountryCode) {
    TimeZone zone = null;
    // If the offset is (0, false) and the time zone property
    // is set, use the time zone property rather than GMT.
    final String zoneName = SystemProperties.get(TIMEZONE_PROPERTY);
    if (DBG) {
        log("fixTimeZone zoneName='" + zoneName + "' mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst + " iso-cc='" + isoCountryCode + "' iso-cc-idx=" + Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode));
    }
    if ("".equals(isoCountryCode) && mNeedFixZoneAfterNitz) {
        // Country code not found.  This is likely a test network.
        // Get a TimeZone based only on the NITZ parameters (best guess).
        zone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (DBG)
            log("pollStateDone: using NITZ TimeZone");
    } else if ((mZoneOffset == 0) && (mZoneDst == false) && (zoneName != null) && (zoneName.length() > 0) && (Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode) < 0)) {
        // For NITZ string without time zone,
        // need adjust time to reflect default time zone setting
        zone = TimeZone.getDefault();
        if (mNeedFixZoneAfterNitz) {
            long ctm = System.currentTimeMillis();
            long tzOffset = zone.getOffset(ctm);
            if (DBG) {
                log("fixTimeZone: tzOffset=" + tzOffset + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            if (getAutoTime()) {
                long adj = ctm - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj ltod=" + TimeUtils.logTimeOfDay(adj));
                setAndBroadcastNetworkSetTime(adj);
            } else {
                // Adjust the saved NITZ time to account for tzOffset.
                mSavedTime = mSavedTime - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj mSavedTime=" + mSavedTime);
            }
        }
        if (DBG)
            log("fixTimeZone: using default TimeZone");
    } else {
        zone = TimeUtils.getTimeZone(mZoneOffset, mZoneDst, mZoneTime, isoCountryCode);
        if (DBG)
            log("fixTimeZone: using getTimeZone(off, dst, time, iso)");
    }
    final String tmpLog = "fixTimeZone zoneName=" + zoneName + " mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst + " iso-cc=" + isoCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " zone=" + (zone != null ? zone.getID() : "NULL");
    mTimeZoneLog.log(tmpLog);
    if (zone != null) {
        log("fixTimeZone: zone != null zone.getID=" + zone.getID());
        if (getAutoTimeZone()) {
            setAndBroadcastNetworkSetTimeZone(zone.getID());
        } else {
            log("fixTimeZone: skip changing zone as getAutoTimeZone was false");
        }
        if (mNeedFixZoneAfterNitz) {
            saveNitzTimeZone(zone.getID());
        }
    } else {
        log("fixTimeZone: zone == null, do nothing for zone");
    }
    mNeedFixZoneAfterNitz = false;
}
#end_block

#method_before
private boolean isOperatorConsideredNonRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    String[] numericArray = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.config_operatorConsideredNonRoaming);
    if (numericArray.length == 0 || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isOperatorConsideredNonRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_NON_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (!TextUtils.isEmpty(numeric) && operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private boolean isOperatorConsideredRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    String[] numericArray = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.config_sameNamedOperatorConsideredRoaming);
    if (numericArray.length == 0 || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isOperatorConsideredRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (!TextUtils.isEmpty(numeric) && operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public CellLocation getCellLocation(WorkSource workSource) {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (DBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo(workSource);
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (DBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (DBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (DBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#method_after
public CellLocation getCellLocation(WorkSource workSource) {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (VDBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo(workSource);
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (VDBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (VDBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (VDBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (VDBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (VDBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#end_block

#method_before
private void revertToNitzTimeZone() {
    if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) {
        return;
    }
    String tmpLog = "Reverting to NITZ TimeZone: tz=" + mSavedTimeZone;
    if (DBG)
        log(tmpLog);
    mTimeZoneLog.log(tmpLog);
    if (mSavedTimeZone != null) {
        setAndBroadcastNetworkSetTimeZone(mSavedTimeZone);
    }
}
#method_after
private void revertToNitzTimeZone() {
    if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) {
        return;
    }
    String tmpLog = "Reverting to NITZ TimeZone: tz=" + mSavedTimeZone;
    if (DBG)
        log(tmpLog);
    mTimeZoneLog.log(tmpLog);
    if (mSavedTimeZone != null) {
        setAndBroadcastNetworkSetTimeZone(mSavedTimeZone);
    } else {
        String iso = ((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getNetworkCountryIsoForPhone(mPhone.getPhoneId());
        if (!TextUtils.isEmpty(iso)) {
            updateTimeZoneByNetworkCountryCode(iso);
        }
    }
}
#end_block

#method_before
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnDataContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnNormalContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnEmergencyContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                // cancel notification because current reject code is not handled.
                notifyType = CS_REJECT_CAUSE_DISABLED;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
        case CS_REJECT_CAUSE_DISABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED || notifyType == CS_REJECT_CAUSE_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                // cancel notification because current reject code is not handled.
                notifyType = CS_REJECT_CAUSE_DISABLED;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
        case CS_REJECT_CAUSE_DISABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED || notifyType == CS_REJECT_CAUSE_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    // override isGsm for CDMA LTE
    if (mPhone.isPhoneTypeGsm() || (mPhone.isPhoneTypeCdmaLte() && ServiceState.isLte(mSS.getRilDataRadioTechnology()))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#end_block

#method_before
protected int getCombinedRegState() {
    int regState = mSS.getVoiceRegState();
    int dataRegState = mSS.getDataRegState();
    if ((regState == ServiceState.STATE_OUT_OF_SERVICE) && (dataRegState == ServiceState.STATE_IN_SERVICE)) {
        log("getCombinedRegState: return STATE_IN_SERVICE as Data is in service");
        regState = dataRegState;
    }
    return regState;
}
#method_after
protected int getCombinedRegState() {
    int regState = mSS.getVoiceRegState();
    int dataRegState = mSS.getDataRegState();
    if ((regState == ServiceState.STATE_OUT_OF_SERVICE || regState == ServiceState.STATE_POWER_OFF) && (dataRegState == ServiceState.STATE_IN_SERVICE)) {
        log("getCombinedRegState: return STATE_IN_SERVICE as Data is in service");
        regState = dataRegState;
    }
    return regState;
}
#end_block

#method_before
public void testReadMoreThan8kInOneRead() throws IOException {
    // Create a zip file with 1mb entry
    final File f = createTemporaryZipFile();
    writeEntries(createZipOutputStream(f), 1, 1024 * 1024, true);
    // Create a ~64kb read buffer (-32 bytes for a slack, defalter wont fill it completly)
    byte[] readBuffer = new byte[1024 * 64 - 32];
    // Read the data to read buffer
    ZipFile zipFile = new ZipFile(f);
    InputStream is = zipFile.getInputStream(zipFile.entries().nextElement());
    int read = is.read(readBuffer, 0, readBuffer.length);
    // Assert that whole buffer been filled. Due to openJdk choice of buffer size, read
    // never returned more than 8k of data.
    assertEquals(readBuffer.length, read);
    is.close();
    zipFile.close();
}
#method_after
public void testReadMoreThan8kInOneRead() throws IOException {
    // Create a zip file with 1mb entry
    final File f = createTemporaryZipFile();
    writeEntries(createZipOutputStream(f), 1, 1024 * 1024, true);
    // Create a ~64kb read buffer (-32 bytes for a slack, inflater wont fill it completly)
    byte[] readBuffer = new byte[1024 * 64 - 32];
    // Read the data to read buffer
    ZipFile zipFile = new ZipFile(f);
    InputStream is = zipFile.getInputStream(zipFile.entries().nextElement());
    int read = is.read(readBuffer, 0, readBuffer.length);
    // Assert that whole buffer been filled. Due to openJdk choice of buffer size, read
    // never returned more than 8k of data.
    assertEquals(readBuffer.length, read);
    is.close();
    zipFile.close();
}
#end_block

#method_before
// END Android-changed: Deprecated & unsupported as all calls are intercepted by the runtime
public int length() {
    // BEGIN Android-changed: Get length from count field rather than value array (see above)
    final boolean STRING_COMPRESSION_ENABLED = true;
    if (STRING_COMPRESSION_ENABLED) {
        // are ASCII), the least significant bit of "count" is used as the compression flag.
        return (count >>> 1);
    } else {
        return count;
    }
// END Android-changed: Get length from count field rather than value array (see above)
}
#method_after
// END Android-changed: Deprecated & unsupported as all calls are intercepted by the runtime.
public int length() {
    // BEGIN Android-changed: Get length from count field rather than value array (see above).
    // return value.length;
    final boolean STRING_COMPRESSION_ENABLED = true;
    if (STRING_COMPRESSION_ENABLED) {
        // are ASCII), the least significant bit of "count" is used as the compression flag.
        return (count >>> 1);
    } else {
        return count;
    }
// END Android-changed: Get length from count field rather than value array (see above).
}
#end_block

#method_before
public boolean isEmpty() {
    // Empty string has {@code count == 0} with or without string compression enabled.
    return count == 0;
}
#method_after
public boolean isEmpty() {
    // return value.length == 0;
    return count == 0;
}
#end_block

#method_before
// END Android-changed: Replace with implementation in runtime to access chars (see above)
public int codePointAt(int index) {
    if ((index < 0) || (index >= length())) {
        throw new StringIndexOutOfBoundsException(index);
    }
    // Android-changed: Skip codePointAtImpl optimization that needs access to java chars
    return Character.codePointAt(this, index);
}
#method_after
// END Android-changed: Replace with implementation in runtime to access chars (see above).
public int codePointAt(int index) {
    if ((index < 0) || (index >= length())) {
        throw new StringIndexOutOfBoundsException(index);
    }
    // Android-changed: Skip codePointAtImpl optimization that needs access to java chars.
    return Character.codePointAt(this, index);
}
#end_block

#method_before
public int codePointBefore(int index) {
    int i = index - 1;
    if ((i < 0) || (i >= length())) {
        throw new StringIndexOutOfBoundsException(index);
    }
    // Android-changed: Skip codePointBeforeImpl optimization that needs access to java chars
    return Character.codePointBefore(this, index);
}
#method_after
public int codePointBefore(int index) {
    int i = index - 1;
    if ((i < 0) || (i >= length())) {
        throw new StringIndexOutOfBoundsException(index);
    }
    // Android-changed: Skip codePointBeforeImpl optimization that needs access to java chars.
    return Character.codePointBefore(this, index);
}
#end_block

#method_before
public int codePointCount(int beginIndex, int endIndex) {
    if (beginIndex < 0 || endIndex > length() || beginIndex > endIndex) {
        throw new IndexOutOfBoundsException();
    }
    // Android-changed: Skip codePointCountImpl optimization that needs access to java chars
    return Character.codePointCount(this, beginIndex, endIndex);
}
#method_after
public int codePointCount(int beginIndex, int endIndex) {
    if (beginIndex < 0 || endIndex > length() || beginIndex > endIndex) {
        throw new IndexOutOfBoundsException();
    }
    // Android-changed: Skip codePointCountImpl optimization that needs access to java chars.
    return Character.codePointCount(this, beginIndex, endIndex);
}
#end_block

#method_before
void getChars(char[] dst, int dstBegin) {
    // Android-changed: Replace arraycopy with native call since chars are managed by runtime
    getCharsNoCheck(0, length(), dst, dstBegin);
}
#method_after
void getChars(char[] dst, int dstBegin) {
    // Android-changed: Replace arraycopy with native call since chars are managed by runtime.
    getCharsNoCheck(0, length(), dst, dstBegin);
}
#end_block

#method_before
public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {
    // BEGIN Android-changed: Implement in terms of length() and native getCharsNoCheck method
    if (dst == null) {
        throw new NullPointerException("dst == null");
    }
    if (srcBegin < 0) {
        throw new StringIndexOutOfBoundsException(this, srcBegin);
    }
    if (srcEnd > length()) {
        throw new StringIndexOutOfBoundsException(this, srcEnd);
    }
    int n = srcEnd - srcBegin;
    if (srcEnd < srcBegin) {
        throw new StringIndexOutOfBoundsException(this, srcBegin, n);
    }
    if (dstBegin < 0) {
        throw new ArrayIndexOutOfBoundsException("dstBegin < 0. dstBegin=" + dstBegin);
    }
    // copied.
    if (dstBegin > dst.length) {
        throw new ArrayIndexOutOfBoundsException("dstBegin > dst.length. dstBegin=" + dstBegin + ", dst.length=" + dst.length);
    }
    if (n > dst.length - dstBegin) {
        throw new ArrayIndexOutOfBoundsException("n > dst.length - dstBegin. n=" + n + ", dst.length=" + dst.length + "dstBegin=" + dstBegin);
    }
    getCharsNoCheck(srcBegin, srcEnd, dst, dstBegin);
// END Android-changed: Implement in terms of length() and native getCharsNoCheck method
}
#method_after
public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {
    // BEGIN Android-changed: Implement in terms of length() and native getCharsNoCheck method.
    if (dst == null) {
        throw new NullPointerException("dst == null");
    }
    if (srcBegin < 0) {
        throw new StringIndexOutOfBoundsException(this, srcBegin);
    }
    if (srcEnd > length()) {
        throw new StringIndexOutOfBoundsException(this, srcEnd);
    }
    int n = srcEnd - srcBegin;
    if (srcEnd < srcBegin) {
        throw new StringIndexOutOfBoundsException(this, srcBegin, n);
    }
    if (dstBegin < 0) {
        throw new ArrayIndexOutOfBoundsException("dstBegin < 0. dstBegin=" + dstBegin);
    }
    // copied.
    if (dstBegin > dst.length) {
        throw new ArrayIndexOutOfBoundsException("dstBegin > dst.length. dstBegin=" + dstBegin + ", dst.length=" + dst.length);
    }
    if (n > dst.length - dstBegin) {
        throw new ArrayIndexOutOfBoundsException("n > dst.length - dstBegin. n=" + n + ", dst.length=" + dst.length + "dstBegin=" + dstBegin);
    }
    getCharsNoCheck(srcBegin, srcEnd, dst, dstBegin);
// END Android-changed: Implement in terms of length() and native getCharsNoCheck method.
}
#end_block

#method_before
// END Android-added: Native method to access char storage managed by runtime
@Deprecated
public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {
    if (srcBegin < 0) {
        throw new StringIndexOutOfBoundsException(this, srcBegin);
    }
    if (srcEnd > length()) {
        throw new StringIndexOutOfBoundsException(this, srcEnd);
    }
    if (srcBegin > srcEnd) {
        throw new StringIndexOutOfBoundsException(this, srcEnd - srcBegin);
    }
    int j = dstBegin;
    int n = srcEnd;
    int i = srcBegin;
    while (i < n) {
        dst[j++] = (byte) charAt(i++);
    }
}
#method_after
// END Android-added: Native method to access char storage managed by runtime.
@Deprecated
public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {
    if (srcBegin < 0) {
        throw new StringIndexOutOfBoundsException(this, srcBegin);
    }
    if (srcEnd > length()) {
        throw new StringIndexOutOfBoundsException(this, srcEnd);
    }
    if (srcBegin > srcEnd) {
        throw new StringIndexOutOfBoundsException(this, srcEnd - srcBegin);
    }
    int j = dstBegin;
    int n = srcEnd;
    int i = srcBegin;
    while (i < n) {
        dst[j++] = (byte) charAt(i++);
    }
}
#end_block

#method_before
public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {
    if (charsetName == null)
        throw new NullPointerException();
    // Android-changed: Skip StringCoding optimization that needs access to java chars
    return getBytes(Charset.forNameUEE(charsetName));
}
#method_after
public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {
    if (charsetName == null)
        throw new NullPointerException();
    // return StringCoding.encode(charsetName, value, 0, value.length);
    return getBytes(Charset.forNameUEE(charsetName));
}
#end_block

#method_before
public byte[] getBytes(Charset charset) {
    // BEGIN Android-changed: Skip StringCoding optimization that needs access to java chars
    if (charset == null) {
        throw new NullPointerException("charset == null");
    }
    final int len = length();
    final String name = charset.name();
    if ("UTF-8".equals(name)) {
        return CharsetUtils.toUtf8Bytes(this, 0, len);
    } else if ("ISO-8859-1".equals(name)) {
        return CharsetUtils.toIsoLatin1Bytes(this, 0, len);
    } else if ("US-ASCII".equals(name)) {
        return CharsetUtils.toAsciiBytes(this, 0, len);
    } else if ("UTF-16BE".equals(name)) {
        return CharsetUtils.toBigEndianUtf16Bytes(this, 0, len);
    }
    ByteBuffer buffer = charset.encode(this);
    byte[] bytes = new byte[buffer.limit()];
    buffer.get(bytes);
    return bytes;
// END Android-changed: Skip StringCoding optimization that needs access to java chars
}
#method_after
public byte[] getBytes(Charset charset) {
    // return StringCoding.encode(charset, value, 0, value.length);
    if (charset == null) {
        throw new NullPointerException("charset == null");
    }
    final int len = length();
    final String name = charset.name();
    if ("UTF-8".equals(name)) {
        return CharsetUtils.toUtf8Bytes(this, 0, len);
    } else if ("ISO-8859-1".equals(name)) {
        return CharsetUtils.toIsoLatin1Bytes(this, 0, len);
    } else if ("US-ASCII".equals(name)) {
        return CharsetUtils.toAsciiBytes(this, 0, len);
    } else if ("UTF-16BE".equals(name)) {
        return CharsetUtils.toBigEndianUtf16Bytes(this, 0, len);
    }
    ByteBuffer buffer = charset.encode(this);
    byte[] bytes = new byte[buffer.limit()];
    buffer.get(bytes);
    return bytes;
// END Android-changed: Skip StringCoding optimization that needs access to java chars.
}
#end_block

#method_before
public byte[] getBytes() {
    // Android-changed: Skip StringCoding optimization that needs access to java chars
    return getBytes(Charset.defaultCharset());
}
#method_after
public byte[] getBytes() {
    // return StringCoding.encode(value, 0, value.length);
    return getBytes(Charset.defaultCharset());
}
#end_block

#method_before
// END Android-added: Native method to access char storage managed by runtime
private int indexOfSupplementary(int ch, int fromIndex) {
    if (Character.isValidCodePoint(ch)) {
        final char hi = Character.highSurrogate(ch);
        final char lo = Character.lowSurrogate(ch);
        final int max = length() - 1;
        for (int i = fromIndex; i < max; i++) {
            if (charAt(i) == hi && charAt(i + 1) == lo) {
                return i;
            }
        }
    }
    return -1;
}
#method_after
// END Android-added: Native method to access char storage managed by runtime.
private int indexOfSupplementary(int ch, int fromIndex) {
    if (Character.isValidCodePoint(ch)) {
        final char hi = Character.highSurrogate(ch);
        final char lo = Character.lowSurrogate(ch);
        final int max = length() - 1;
        for (int i = fromIndex; i < max; i++) {
            if (charAt(i) == hi && charAt(i + 1) == lo) {
                return i;
            }
        }
    }
    return -1;
}
#end_block

#method_before
public int indexOf(String str, int fromIndex) {
    // Android-changed: Change parameters to static indexOf to match new signature below
    return indexOf(this, str, fromIndex);
}
#method_after
public int indexOf(String str, int fromIndex) {
    // Android-changed: Change parameters to static indexOf to match new signature below.
    return indexOf(this, str, fromIndex);
}
#end_block

#method_before
/**
 * Code shared by String and AbstractStringBuilder to do searches. The
 * source is the character array being searched, and the target
 * is the string being searched for.
 *
 * @param   source       the characters being searched.
 * @param   target       the characters being searched for.
 * @param   fromIndex    the index to begin searching from.
 */
// BEGIN Android-changed: Change signature to take String object rather than char arrays
static int indexOf(String source, String target, int fromIndex) {
    final int sourceLength = source.length();
    final int targetLength = target.length();
    if (fromIndex >= sourceLength) {
        return (targetLength == 0 ? sourceLength : -1);
    }
    if (fromIndex < 0) {
        fromIndex = 0;
    }
    if (targetLength == 0) {
        return fromIndex;
    }
    char first = target.charAt(0);
    int max = (sourceLength - targetLength);
    for (int i = fromIndex; i <= max; i++) {
        /* Look for first character. */
        if (source.charAt(i) != first) {
            while (++i <= max && source.charAt(i) != first) ;
        }
        /* Found first character, now look at the rest of v2 */
        if (i <= max) {
            int j = i + 1;
            int end = j + targetLength - 1;
            for (int k = 1; j < end && source.charAt(j) == target.charAt(k); j++, k++) ;
            if (j == end) {
                /* Found whole string. */
                return i;
            }
        }
    }
    return -1;
}
#method_after
/**
 * Code shared by String and AbstractStringBuilder to do searches. The
 * source is the character array being searched, and the target
 * is the string being searched for.
 *
 * @param   source       the characters being searched.
 * @param   target       the characters being searched for.
 * @param   fromIndex    the index to begin searching from.
 */
// BEGIN Android-changed: Change signature to take String object rather than char arrays.
static int indexOf(String source, String target, int fromIndex) {
    final int sourceLength = source.length();
    final int targetLength = target.length();
    if (fromIndex >= sourceLength) {
        return (targetLength == 0 ? sourceLength : -1);
    }
    if (fromIndex < 0) {
        fromIndex = 0;
    }
    if (targetLength == 0) {
        return fromIndex;
    }
    char first = target.charAt(0);
    int max = (sourceLength - targetLength);
    for (int i = fromIndex; i <= max; i++) {
        /* Look for first character. */
        if (source.charAt(i) != first) {
            while (++i <= max && source.charAt(i) != first) ;
        }
        /* Found first character, now look at the rest of v2 */
        if (i <= max) {
            int j = i + 1;
            int end = j + targetLength - 1;
            for (int k = 1; j < end && source.charAt(j) == target.charAt(k); j++, k++) ;
            if (j == end) {
                /* Found whole string. */
                return i;
            }
        }
    }
    return -1;
}
#end_block

#method_before
// END Android-changed: Change signature to take String object rather than char arrays
static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) {
    if (fromIndex >= sourceCount) {
        return (targetCount == 0 ? sourceCount : -1);
    }
    if (fromIndex < 0) {
        fromIndex = 0;
    }
    if (targetCount == 0) {
        return fromIndex;
    }
    char first = target[targetOffset];
    int max = sourceOffset + (sourceCount - targetCount);
    for (int i = sourceOffset + fromIndex; i <= max; i++) {
        /* Look for first character. */
        if (source[i] != first) {
            while (++i <= max && source[i] != first) ;
        }
        /* Found first character, now look at the rest of v2 */
        if (i <= max) {
            int j = i + 1;
            int end = j + targetCount - 1;
            for (int k = targetOffset + 1; j < end && source[j] == target[k]; j++, k++) ;
            if (j == end) {
                /* Found whole string. */
                return i - sourceOffset;
            }
        }
    }
    return -1;
}
#method_after
// END Android-changed: Change signature to take String object rather than char arrays.
static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) {
    if (fromIndex >= sourceCount) {
        return (targetCount == 0 ? sourceCount : -1);
    }
    if (fromIndex < 0) {
        fromIndex = 0;
    }
    if (targetCount == 0) {
        return fromIndex;
    }
    char first = target[targetOffset];
    int max = sourceOffset + (sourceCount - targetCount);
    for (int i = sourceOffset + fromIndex; i <= max; i++) {
        /* Look for first character. */
        if (source[i] != first) {
            while (++i <= max && source[i] != first) ;
        }
        /* Found first character, now look at the rest of v2 */
        if (i <= max) {
            int j = i + 1;
            int end = j + targetCount - 1;
            for (int k = targetOffset + 1; j < end && source[j] == target[k]; j++, k++) ;
            if (j == end) {
                /* Found whole string. */
                return i - sourceOffset;
            }
        }
    }
    return -1;
}
#end_block

#method_before
public int lastIndexOf(String str, int fromIndex) {
    // Android-changed: Change parameters to static lastIndexOf to match new signature below
    return lastIndexOf(this, str, fromIndex);
}
#method_after
public int lastIndexOf(String str, int fromIndex) {
    // Android-changed: Change parameters to static lastIndexOf to match new signature below.
    return lastIndexOf(this, str, fromIndex);
}
#end_block

#method_before
/**
 * Code shared by String and AbstractStringBuilder to do searches. The
 * source is the character array being searched, and the target
 * is the string being searched for.
 *
 * @param   source       the characters being searched.
 * @param   target       the characters being searched for.
 * @param   fromIndex    the index to begin searching from.
 */
// BEGIN Android-changed: Change signature to take String object rather than char arrays
static int lastIndexOf(String source, String target, int fromIndex) {
    /*
         * Check arguments; return immediately where possible. For
         * consistency, don't check for null str.
         */
    final int sourceLength = source.length();
    final int targetLength = target.length();
    int rightIndex = sourceLength - targetLength;
    if (fromIndex < 0) {
        return -1;
    }
    if (fromIndex > rightIndex) {
        fromIndex = rightIndex;
    }
    /* Empty string always matches. */
    if (targetLength == 0) {
        return fromIndex;
    }
    int strLastIndex = targetLength - 1;
    char strLastChar = target.charAt(strLastIndex);
    int min = targetLength - 1;
    int i = min + fromIndex;
    startSearchForLastChar: while (true) {
        while (i >= min && source.charAt(i) != strLastChar) {
            i--;
        }
        if (i < min) {
            return -1;
        }
        int j = i - 1;
        int start = j - (targetLength - 1);
        int k = strLastIndex - 1;
        while (j > start) {
            if (source.charAt(j--) != target.charAt(k--)) {
                i--;
                continue startSearchForLastChar;
            }
        }
        return start + 1;
    }
}
#method_after
/**
 * Code shared by String and AbstractStringBuilder to do searches. The
 * source is the character array being searched, and the target
 * is the string being searched for.
 *
 * @param   source       the characters being searched.
 * @param   target       the characters being searched for.
 * @param   fromIndex    the index to begin searching from.
 */
// BEGIN Android-changed: Change signature to take String object rather than char arrays.
static int lastIndexOf(String source, String target, int fromIndex) {
    /*
         * Check arguments; return immediately where possible. For
         * consistency, don't check for null str.
         */
    final int sourceLength = source.length();
    final int targetLength = target.length();
    int rightIndex = sourceLength - targetLength;
    if (fromIndex < 0) {
        return -1;
    }
    if (fromIndex > rightIndex) {
        fromIndex = rightIndex;
    }
    /* Empty string always matches. */
    if (targetLength == 0) {
        return fromIndex;
    }
    int strLastIndex = targetLength - 1;
    char strLastChar = target.charAt(strLastIndex);
    int min = targetLength - 1;
    int i = min + fromIndex;
    startSearchForLastChar: while (true) {
        while (i >= min && source.charAt(i) != strLastChar) {
            i--;
        }
        if (i < min) {
            return -1;
        }
        int j = i - 1;
        int start = j - (targetLength - 1);
        int k = strLastIndex - 1;
        while (j > start) {
            if (source.charAt(j--) != target.charAt(k--)) {
                i--;
                continue startSearchForLastChar;
            }
        }
        return start + 1;
    }
}
#end_block

#method_before
// END Android-changed: Change signature to take String object rather than char arrays
static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) {
    /*
         * Check arguments; return immediately where possible. For
         * consistency, don't check for null str.
         */
    int rightIndex = sourceCount - targetCount;
    if (fromIndex < 0) {
        return -1;
    }
    if (fromIndex > rightIndex) {
        fromIndex = rightIndex;
    }
    /* Empty string always matches. */
    if (targetCount == 0) {
        return fromIndex;
    }
    int strLastIndex = targetOffset + targetCount - 1;
    char strLastChar = target[strLastIndex];
    int min = sourceOffset + targetCount - 1;
    int i = min + fromIndex;
    startSearchForLastChar: while (true) {
        while (i >= min && source[i] != strLastChar) {
            i--;
        }
        if (i < min) {
            return -1;
        }
        int j = i - 1;
        int start = j - (targetCount - 1);
        int k = strLastIndex - 1;
        while (j > start) {
            if (source[j--] != target[k--]) {
                i--;
                continue startSearchForLastChar;
            }
        }
        return start - sourceOffset + 1;
    }
}
#method_after
// END Android-changed: Change signature to take String object rather than char arrays.
static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) {
    /*
         * Check arguments; return immediately where possible. For
         * consistency, don't check for null str.
         */
    int rightIndex = sourceCount - targetCount;
    if (fromIndex < 0) {
        return -1;
    }
    if (fromIndex > rightIndex) {
        fromIndex = rightIndex;
    }
    /* Empty string always matches. */
    if (targetCount == 0) {
        return fromIndex;
    }
    int strLastIndex = targetOffset + targetCount - 1;
    char strLastChar = target[strLastIndex];
    int min = sourceOffset + targetCount - 1;
    int i = min + fromIndex;
    startSearchForLastChar: while (true) {
        while (i >= min && source[i] != strLastChar) {
            i--;
        }
        if (i < min) {
            return -1;
        }
        int j = i - 1;
        int start = j - (targetCount - 1);
        int k = strLastIndex - 1;
        while (j > start) {
            if (source[j--] != target[k--]) {
                i--;
                continue startSearchForLastChar;
            }
        }
        return start - sourceOffset + 1;
    }
}
#end_block

#method_before
public String substring(int beginIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(this, beginIndex);
    }
    int subLen = length() - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(this, beginIndex);
    }
    // Android-changed: Use native fastSubstring instead of String constructor
    return (beginIndex == 0) ? this : fastSubstring(beginIndex, subLen);
}
#method_after
public String substring(int beginIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(this, beginIndex);
    }
    int subLen = length() - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(this, beginIndex);
    }
    // Android-changed: Use native fastSubstring instead of String constructor.
    return (beginIndex == 0) ? this : fastSubstring(beginIndex, subLen);
}
#end_block

#method_before
public String substring(int beginIndex, int endIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(this, beginIndex);
    }
    if (endIndex > length()) {
        throw new StringIndexOutOfBoundsException(this, endIndex);
    }
    int subLen = endIndex - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    // Android-changed: Use native fastSubstring instead of String constructor
    return ((beginIndex == 0) && (endIndex == length())) ? this : fastSubstring(beginIndex, subLen);
}
#method_after
public String substring(int beginIndex, int endIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(this, beginIndex);
    }
    if (endIndex > length()) {
        throw new StringIndexOutOfBoundsException(this, endIndex);
    }
    int subLen = endIndex - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    // Android-changed: Use native fastSubstring instead of String constructor.
    return ((beginIndex == 0) && (endIndex == length())) ? this : fastSubstring(beginIndex, subLen);
}
#end_block

#method_before
// END Android-added: Native method to access char storage managed by runtime
public CharSequence subSequence(int beginIndex, int endIndex) {
    return this.substring(beginIndex, endIndex);
}
#method_after
// END Android-added: Native method to access char storage managed by runtime.
public CharSequence subSequence(int beginIndex, int endIndex) {
    return this.substring(beginIndex, endIndex);
}
#end_block

#method_before
// END Android-changed: Replace with implementation in runtime to access chars (see above)
public String replace(char oldChar, char newChar) {
    // BEGIN Android-changed: Replace with implementation using native doReplace method
    if (oldChar != newChar) {
        final int len = length();
        for (int i = 0; i < len; ++i) {
            if (charAt(i) == oldChar) {
                return doReplace(oldChar, newChar);
            }
        }
    }
    // END Android-changed: Replace with implementation using native doReplace method
    return this;
}
#method_after
// END Android-changed: Replace with implementation in runtime to access chars (see above).
public String replace(char oldChar, char newChar) {
    // BEGIN Android-changed: Replace with implementation using native doReplace method.
    if (oldChar != newChar) {
        final int len = length();
        for (int i = 0; i < len; ++i) {
            if (charAt(i) == oldChar) {
                return doReplace(oldChar, newChar);
            }
        }
    }
    // END Android-changed: Replace with implementation using native doReplace method.
    return this;
}
#end_block

#method_before
// END Android-added: Native method to access char storage managed by runtime
public boolean matches(String regex) {
    return Pattern.matches(regex, this);
}
#method_after
// END Android-added: Native method to access char storage managed by runtime.
public boolean matches(String regex) {
    return Pattern.matches(regex, this);
}
#end_block

#method_before
public String replace(CharSequence target, CharSequence replacement) {
    // BEGIN Android-changed: Replace regex-based implementation with a bespoke one
    if (target == null) {
        throw new NullPointerException("target == null");
    }
    if (replacement == null) {
        throw new NullPointerException("replacement == null");
    }
    String replacementStr = replacement.toString();
    String targetStr = target.toString();
    // Special case when target == "". This is a pretty nonsensical transformation and nobody
    // should be hitting this.
    // 
    // See commit 870b23b3febc85 and http://code.google.com/p/android/issues/detail?id=8807
    // An empty target is inserted at the start of the string, the end of the string and
    // between all characters.
    final int len = length();
    if (targetStr.isEmpty()) {
        // Note that overallocates by |replacement.size()| if |this| is the empty string, but
        // that should be a rare case within an already nonsensical case.
        StringBuilder sb = new StringBuilder(replacementStr.length() * (len + 2) + len);
        sb.append(replacementStr);
        for (int i = 0; i < len; ++i) {
            sb.append(charAt(i));
            sb.append(replacementStr);
        }
        return sb.toString();
    }
    // This is the "regular" case.
    int lastMatch = 0;
    StringBuilder sb = null;
    for (; ; ) {
        int currentMatch = indexOf(this, targetStr, lastMatch);
        if (currentMatch == -1) {
            break;
        }
        if (sb == null) {
            sb = new StringBuilder(len);
        }
        sb.append(this, lastMatch, currentMatch);
        sb.append(replacementStr);
        lastMatch = currentMatch + targetStr.length();
    }
    if (sb != null) {
        sb.append(this, lastMatch, len);
        return sb.toString();
    } else {
        return this;
    }
// END Android-changed: Replace regex-based implementation with a bespoke one
}
#method_after
public String replace(CharSequence target, CharSequence replacement) {
    // BEGIN Android-changed: Replace regex-based implementation with a bespoke one.
    if (target == null) {
        throw new NullPointerException("target == null");
    }
    if (replacement == null) {
        throw new NullPointerException("replacement == null");
    }
    String replacementStr = replacement.toString();
    String targetStr = target.toString();
    // Special case when target == "". This is a pretty nonsensical transformation and nobody
    // should be hitting this.
    // 
    // See commit 870b23b3febc85 and http://code.google.com/p/android/issues/detail?id=8807
    // An empty target is inserted at the start of the string, the end of the string and
    // between all characters.
    final int len = length();
    if (targetStr.isEmpty()) {
        // Note that overallocates by |replacement.size()| if |this| is the empty string, but
        // that should be a rare case within an already nonsensical case.
        StringBuilder sb = new StringBuilder(replacementStr.length() * (len + 2) + len);
        sb.append(replacementStr);
        for (int i = 0; i < len; ++i) {
            sb.append(charAt(i));
            sb.append(replacementStr);
        }
        return sb.toString();
    }
    // This is the "regular" case.
    int lastMatch = 0;
    StringBuilder sb = null;
    for (; ; ) {
        int currentMatch = indexOf(this, targetStr, lastMatch);
        if (currentMatch == -1) {
            break;
        }
        if (sb == null) {
            sb = new StringBuilder(len);
        }
        sb.append(this, lastMatch, currentMatch);
        sb.append(replacementStr);
        lastMatch = currentMatch + targetStr.length();
    }
    if (sb != null) {
        sb.append(this, lastMatch, len);
        return sb.toString();
    } else {
        return this;
    }
// END Android-changed: Replace regex-based implementation with a bespoke one.
}
#end_block

#method_before
public String[] split(String regex, int limit) {
    // BEGIN Android-changed: Replace custom fast-path with call to new Pattern.fastSplit method
    // Try fast splitting without allocating Pattern object
    String[] fast = Pattern.fastSplit(regex, this, limit);
    if (fast != null) {
        return fast;
    }
    // END Android-changed: Replace custom fast-path with call to new Pattern.fastSplit method
    return Pattern.compile(regex).split(this, limit);
}
#method_after
public String[] split(String regex, int limit) {
    // BEGIN Android-changed: Replace custom fast-path with use of new Pattern.fastSplit method.
    // Try fast splitting without allocating Pattern object
    String[] fast = Pattern.fastSplit(regex, this, limit);
    if (fast != null) {
        return fast;
    }
    // END Android-changed: Replace custom fast-path with use of new Pattern.fastSplit method.
    return Pattern.compile(regex).split(this, limit);
}
#end_block

#method_before
public String toLowerCase(Locale locale) {
    // Android-changed: Replace custom code with call to new CaseMapper class
    return CaseMapper.toLowerCase(locale, this);
}
#method_after
public String toLowerCase(Locale locale) {
    // Android-changed: Replace custom code with call to new CaseMapper class.
    return CaseMapper.toLowerCase(locale, this);
}
#end_block

#method_before
public String toUpperCase(Locale locale) {
    // Android-changed: Replace custom code with call to new CaseMapper class
    return CaseMapper.toUpperCase(locale, this, length());
}
#method_after
public String toUpperCase(Locale locale) {
    // Android-changed: Replace custom code with call to new CaseMapper class.
    return CaseMapper.toUpperCase(locale, this, length());
}
#end_block

#method_before
// END Android-changed: Replace with implementation in runtime to access chars (see above)
public static String format(String format, Object... args) {
    return new Formatter().format(format, args).toString();
}
#method_after
// END Android-changed: Replace with implementation in runtime to access chars (see above).
public static String format(String format, Object... args) {
    return new Formatter().format(format, args).toString();
}
#end_block

#method_before
public static String valueOf(char[] data) {
    // Android-changed: Replace constructor call with call to new StringFactory class
    return StringFactory.newStringFromChars(data);
}
#method_after
public static String valueOf(char[] data) {
    // return new String(data);
    return StringFactory.newStringFromChars(data);
}
#end_block

#method_before
public static String valueOf(char[] data, int offset, int count) {
    // Android-changed: Replace constructor call with call to new StringFactory class
    return StringFactory.newStringFromChars(data, offset, count);
}
#method_after
public static String valueOf(char[] data, int offset, int count) {
    // return new String(data, offset, count);
    return StringFactory.newStringFromChars(data, offset, count);
}
#end_block

#method_before
public static String copyValueOf(char[] data, int offset, int count) {
    // All public String constructors now copy the data.
    return StringFactory.newStringFromChars(data, offset, count);
}
#method_after
public static String copyValueOf(char[] data, int offset, int count) {
    // return new String(data, offset, count);
    return StringFactory.newStringFromChars(data, offset, count);
}
#end_block

#method_before
public static String copyValueOf(char[] data) {
    // Android-changed: Replace constructor call with call to new StringFactory class
    return StringFactory.newStringFromChars(data);
}
#method_after
public static String copyValueOf(char[] data) {
    // return new String(data);
    return StringFactory.newStringFromChars(data);
}
#end_block

#method_before
public static String valueOf(char c) {
    // Android-changed: Replace constructor call with call to new StringFactory class
    return StringFactory.newStringFromChars(0, 1, new char[] { c });
}
#method_after
public static String valueOf(char c) {
    // return new String(data, true);
    return StringFactory.newStringFromChars(0, 1, new char[] { c });
}
#end_block

#method_before
private void onSetComplete(Message msg, AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof CommandException) {
            CommandException err = (CommandException) ar.exception;
            if (err.getCommandError() == CommandException.Error.PASSWORD_INCORRECT) {
                sb.append(mContext.getText(com.android.internal.R.string.passwordIncorrect));
            } else if (err.getCommandError() == CommandException.Error.FDN_CHECK_FAILURE) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (err.getMessage() != null) {
                sb.append(err.getMessage());
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
            }
        } else {
            ImsException error = (ImsException) ar.exception;
            if (error.getCode() == ImsReasonInfo.CODE_FDN_BLOCKED) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (error.getMessage() != null) {
                sb.append(error.getMessage());
            } else {
                sb.append(getErrorMessage(ar));
            }
        }
    } else if (isActivate()) {
        mState = State.COMPLETE;
        if (mIsCallFwdReg) {
            sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
        }
    } else if (isDeactivate()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
    } else if (isRegister()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
    } else if (isErasure()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceErased));
    } else {
        mState = State.FAILED;
        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onSetComplete: mmi=" + this);
    mPhone.onMMIDone(this);
}
#method_after
private void onSetComplete(Message msg, AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof CommandException) {
            CommandException err = (CommandException) ar.exception;
            if (err.getCommandError() == CommandException.Error.PASSWORD_INCORRECT) {
                sb.append(mContext.getText(com.android.internal.R.string.passwordIncorrect));
            } else if (err.getCommandError() == CommandException.Error.FDN_CHECK_FAILURE) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (err.getMessage() != null) {
                sb.append(err.getMessage());
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
            }
        } else if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        }
    } else if (isActivate()) {
        mState = State.COMPLETE;
        if (mIsCallFwdReg) {
            sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
        }
    } else if (isDeactivate()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
    } else if (isRegister()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceRegistered));
    } else if (isErasure()) {
        mState = State.COMPLETE;
        sb.append(mContext.getText(com.android.internal.R.string.serviceErased));
    } else {
        mState = State.FAILED;
        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onSetComplete: mmi=" + this);
    mPhone.onMMIDone(this);
}
#end_block

#method_before
private void onQueryCfComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            ImsException error = (ImsException) ar.exception;
            if (error.getCode() == ImsReasonInfo.CODE_FDN_BLOCKED) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (error.getMessage() != null) {
                sb.append(error.getMessage());
            } else {
                sb.append(getErrorMessage(ar));
            }
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        CallForwardInfo[] infos;
        infos = (CallForwardInfo[]) ar.result;
        if (infos.length == 0) {
            // Assume the default is not active
            sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
            // Set unconditional CFF in SIM to false
            if (mIccRecords != null) {
                mPhone.setVoiceCallForwardingFlag(1, false, null);
            }
        } else {
            SpannableStringBuilder tb = new SpannableStringBuilder();
            for (int serviceClassMask = 1; serviceClassMask <= SERVICE_CLASS_MAX; serviceClassMask <<= 1) {
                for (int i = 0, s = infos.length; i < s; i++) {
                    if ((serviceClassMask & infos[i].serviceClass) != 0) {
                        tb.append(makeCFQueryResultMessage(infos[i], serviceClassMask));
                        tb.append("\n");
                    }
                }
            }
            sb.append(tb);
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryCfComplete: mmi=" + this);
    mPhone.onMMIDone(this);
}
#method_after
private void onQueryCfComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        CallForwardInfo[] infos;
        infos = (CallForwardInfo[]) ar.result;
        if (infos.length == 0) {
            // Assume the default is not active
            sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
            // Set unconditional CFF in SIM to false
            if (mIccRecords != null) {
                mPhone.setVoiceCallForwardingFlag(1, false, null);
            }
        } else {
            SpannableStringBuilder tb = new SpannableStringBuilder();
            for (int serviceClassMask = 1; serviceClassMask <= SERVICE_CLASS_MAX; serviceClassMask <<= 1) {
                for (int i = 0, s = infos.length; i < s; i++) {
                    if ((serviceClassMask & infos[i].serviceClass) != 0) {
                        tb.append(makeCFQueryResultMessage(infos[i], serviceClassMask));
                        tb.append("\n");
                    }
                }
            }
            sb.append(tb);
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryCfComplete: mmi=" + this);
    mPhone.onMMIDone(this);
}
#end_block

#method_before
private void onSuppSvcQueryComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            ImsException error = (ImsException) ar.exception;
            if (error.getCode() == ImsReasonInfo.CODE_FDN_BLOCKED) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (error.getMessage() != null) {
                sb.append(error.getMessage());
            } else {
                sb.append(getErrorMessage(ar));
            }
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        mState = State.FAILED;
        ImsSsInfo ssInfo = null;
        if (ar.result instanceof Bundle) {
            Rlog.d(LOG_TAG, "onSuppSvcQueryComplete: Received CLIP/COLP/COLR Response.");
            // Response for CLIP, COLP and COLR queries.
            Bundle ssInfoResp = (Bundle) ar.result;
            ssInfo = (ImsSsInfo) ssInfoResp.getParcelable(UT_BUNDLE_KEY_SSINFO);
            if (ssInfo != null) {
                Rlog.d(LOG_TAG, "onSuppSvcQueryComplete: ImsSsInfo mStatus = " + ssInfo.mStatus);
                if (ssInfo.mStatus == ImsSsInfo.DISABLED) {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
                    mState = State.COMPLETE;
                } else if (ssInfo.mStatus == ImsSsInfo.ENABLED) {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
                    mState = State.COMPLETE;
                } else {
                    sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                }
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
            }
        } else {
            Rlog.d(LOG_TAG, "onSuppSvcQueryComplete: Received Call Barring Response.");
            // Response for Call Barring queries.
            int[] cbInfos = (int[]) ar.result;
            if (cbInfos[0] == 1) {
                sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
                mState = State.COMPLETE;
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
                mState = State.COMPLETE;
            }
        }
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onSuppSvcQueryComplete mmi=" + this);
    mPhone.onMMIDone(this);
}
#method_after
private void onSuppSvcQueryComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    mState = State.FAILED;
    if (ar.exception != null) {
        if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        ImsSsInfo ssInfo = null;
        if (ar.result instanceof Bundle) {
            Rlog.d(LOG_TAG, "onSuppSvcQueryComplete: Received CLIP/COLP/COLR Response.");
            // Response for CLIP, COLP and COLR queries.
            Bundle ssInfoResp = (Bundle) ar.result;
            ssInfo = (ImsSsInfo) ssInfoResp.getParcelable(UT_BUNDLE_KEY_SSINFO);
            if (ssInfo != null) {
                Rlog.d(LOG_TAG, "onSuppSvcQueryComplete: ImsSsInfo mStatus = " + ssInfo.mStatus);
                if (ssInfo.mStatus == ImsSsInfo.DISABLED) {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
                    mState = State.COMPLETE;
                } else if (ssInfo.mStatus == ImsSsInfo.ENABLED) {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
                    mState = State.COMPLETE;
                } else {
                    sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                }
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
            }
        } else {
            Rlog.d(LOG_TAG, "onSuppSvcQueryComplete: Received Call Barring Response.");
            // Response for Call Barring queries.
            int[] cbInfos = (int[]) ar.result;
            if (cbInfos[0] == 1) {
                sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
                mState = State.COMPLETE;
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
                mState = State.COMPLETE;
            }
        }
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onSuppSvcQueryComplete mmi=" + this);
    mPhone.onMMIDone(this);
}
#end_block

#method_before
private void onIcbQueryComplete(AsyncResult ar) {
    Rlog.d(LOG_TAG, "onIcbQueryComplete mmi=" + this);
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            ImsException error = (ImsException) ar.exception;
            if (error.getCode() == ImsReasonInfo.CODE_FDN_BLOCKED) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (error.getMessage() != null) {
                sb.append(error.getMessage());
            } else {
                sb.append(getErrorMessage(ar));
            }
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        ImsSsInfo[] infos = (ImsSsInfo[]) ar.result;
        if (infos.length == 0) {
            sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
        } else {
            for (int i = 0, s = infos.length; i < s; i++) {
                if (infos[i].mIcbNum != null) {
                    sb.append("Num: " + infos[i].mIcbNum + " status: " + infos[i].mStatus + "\n");
                } else if (infos[i].mStatus == 1) {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
                } else {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
                }
            }
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    mPhone.onMMIDone(this);
}
#method_after
private void onIcbQueryComplete(AsyncResult ar) {
    Rlog.d(LOG_TAG, "onIcbQueryComplete mmi=" + this);
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        ImsSsInfo[] infos = (ImsSsInfo[]) ar.result;
        if (infos.length == 0) {
            sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
        } else {
            for (int i = 0, s = infos.length; i < s; i++) {
                if (infos[i].mIcbNum != null) {
                    sb.append("Num: " + infos[i].mIcbNum + " status: " + infos[i].mStatus + "\n");
                } else if (infos[i].mStatus == 1) {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
                } else {
                    sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
                }
            }
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    mPhone.onMMIDone(this);
}
#end_block

#method_before
private void onQueryClirComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    mState = State.FAILED;
    if (ar.exception != null) {
        if (ar.exception instanceof ImsException) {
            ImsException error = (ImsException) ar.exception;
            if (error.getCode() == ImsReasonInfo.CODE_FDN_BLOCKED) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (error.getMessage() != null) {
                sb.append(error.getMessage());
            } else {
                sb.append(getErrorMessage(ar));
            }
        }
    } else {
        Bundle ssInfo = (Bundle) ar.result;
        int[] clirInfo = ssInfo.getIntArray(UT_BUNDLE_KEY_CLIR);
        // clirInfo[0] = The 'n' parameter from TS 27.007 7.7
        // clirInfo[1] = The 'm' parameter from TS 27.007 7.7
        Rlog.d(LOG_TAG, "onQueryClirComplete: CLIR param n=" + clirInfo[0] + " m=" + clirInfo[1]);
        // 'm' parameter.
        switch(clirInfo[1]) {
            case CLIR_NOT_PROVISIONED:
                sb.append(mContext.getText(com.android.internal.R.string.serviceNotProvisioned));
                mState = State.COMPLETE;
                break;
            case CLIR_PROVISIONED_PERMANENT:
                sb.append(mContext.getText(com.android.internal.R.string.CLIRPermanent));
                mState = State.COMPLETE;
                break;
            case CLIR_PRESENTATION_RESTRICTED_TEMPORARY:
                // 'n' parameter.
                switch(clirInfo[0]) {
                    case CLIR_DEFAULT:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOnNextCallOn));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_INVOCATION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOnNextCallOn));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_SUPPRESSION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOnNextCallOff));
                        mState = State.COMPLETE;
                        break;
                    default:
                        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                        mState = State.FAILED;
                }
                break;
            case CLIR_PRESENTATION_ALLOWED_TEMPORARY:
                // 'n' parameter.
                switch(clirInfo[0]) {
                    case CLIR_DEFAULT:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOffNextCallOff));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_INVOCATION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOffNextCallOn));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_SUPPRESSION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOffNextCallOff));
                        mState = State.COMPLETE;
                        break;
                    default:
                        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                        mState = State.FAILED;
                }
                break;
            default:
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                mState = State.FAILED;
        }
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryClirComplete mmi=" + this);
    mPhone.onMMIDone(this);
}
#method_after
private void onQueryClirComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    mState = State.FAILED;
    if (ar.exception != null) {
        if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        }
    } else {
        Bundle ssInfo = (Bundle) ar.result;
        int[] clirInfo = ssInfo.getIntArray(UT_BUNDLE_KEY_CLIR);
        // clirInfo[0] = The 'n' parameter from TS 27.007 7.7
        // clirInfo[1] = The 'm' parameter from TS 27.007 7.7
        Rlog.d(LOG_TAG, "onQueryClirComplete: CLIR param n=" + clirInfo[0] + " m=" + clirInfo[1]);
        // 'm' parameter.
        switch(clirInfo[1]) {
            case CLIR_NOT_PROVISIONED:
                sb.append(mContext.getText(com.android.internal.R.string.serviceNotProvisioned));
                mState = State.COMPLETE;
                break;
            case CLIR_PROVISIONED_PERMANENT:
                sb.append(mContext.getText(com.android.internal.R.string.CLIRPermanent));
                mState = State.COMPLETE;
                break;
            case CLIR_PRESENTATION_RESTRICTED_TEMPORARY:
                // 'n' parameter.
                switch(clirInfo[0]) {
                    case CLIR_DEFAULT:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOnNextCallOn));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_INVOCATION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOnNextCallOn));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_SUPPRESSION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOnNextCallOff));
                        mState = State.COMPLETE;
                        break;
                    default:
                        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                        mState = State.FAILED;
                }
                break;
            case CLIR_PRESENTATION_ALLOWED_TEMPORARY:
                // 'n' parameter.
                switch(clirInfo[0]) {
                    case CLIR_DEFAULT:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOffNextCallOff));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_INVOCATION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOffNextCallOn));
                        mState = State.COMPLETE;
                        break;
                    case CLIR_SUPPRESSION:
                        sb.append(mContext.getText(com.android.internal.R.string.CLIRDefaultOffNextCallOff));
                        mState = State.COMPLETE;
                        break;
                    default:
                        sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                        mState = State.FAILED;
                }
                break;
            default:
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
                mState = State.FAILED;
        }
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryClirComplete mmi=" + this);
    mPhone.onMMIDone(this);
}
#end_block

#method_before
private void onQueryComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            ImsException error = (ImsException) ar.exception;
            if (error.getCode() == ImsReasonInfo.CODE_FDN_BLOCKED) {
                sb.append(mContext.getText(com.android.internal.R.string.mmiFdnError));
            } else if (error.getMessage() != null) {
                sb.append(error.getMessage());
            } else {
                sb.append(getErrorMessage(ar));
            }
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        int[] ints = (int[]) ar.result;
        if (ints.length != 0) {
            if (ints[0] == 0) {
                sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
            } else if (mSc.equals(SC_WAIT)) {
                // Call Waiting includes additional data in the response.
                sb.append(createQueryCallWaitingResultMessage(ints[1]));
            } else if (ints[0] == 1) {
                // for all other services, treat it as a boolean
                sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
            }
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.mmiError));
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryComplete mmi=" + this);
    mPhone.onMMIDone(this);
}
#method_after
private void onQueryComplete(AsyncResult ar) {
    StringBuilder sb = new StringBuilder(getScString());
    sb.append("\n");
    if (ar.exception != null) {
        mState = State.FAILED;
        if (ar.exception instanceof ImsException) {
            sb.append(getImsErrorMessage(ar));
        } else {
            sb.append(getErrorMessage(ar));
        }
    } else {
        int[] ints = (int[]) ar.result;
        if (ints.length != 0) {
            if (ints[0] == 0) {
                sb.append(mContext.getText(com.android.internal.R.string.serviceDisabled));
            } else if (mSc.equals(SC_WAIT)) {
                // Call Waiting includes additional data in the response.
                sb.append(createQueryCallWaitingResultMessage(ints[1]));
            } else if (ints[0] == 1) {
                // for all other services, treat it as a boolean
                sb.append(mContext.getText(com.android.internal.R.string.serviceEnabled));
            } else {
                sb.append(mContext.getText(com.android.internal.R.string.mmiError));
            }
        } else {
            sb.append(mContext.getText(com.android.internal.R.string.mmiError));
        }
        mState = State.COMPLETE;
    }
    mMessage = sb;
    Rlog.d(LOG_TAG, "onQueryComplete mmi=" + this);
    mPhone.onMMIDone(this);
}
#end_block

#method_before
@Override
public void setTTYMode(int ttyMode, Message onComplete) {
    super.setTTYMode(ttyMode, onComplete);
    mCT.setTtyMode(ttyMode);
}
#method_after
@Override
public void setTTYMode(int ttyMode, Message onComplete) {
    mCT.setTtyMode(ttyMode);
}
#end_block

#method_before
@Deprecated
public URL toURL() throws MalformedURLException {
    if (isInvalid()) {
        throw new MalformedURLException("Invalid file path");
    }
    // Android-changed: Fix for new File("").toURL()
    return new URL("file", "", slashify(getAbsolutePath(), getAbsoluteFile().isDirectory()));
}
#method_after
@Deprecated
public URL toURL() throws MalformedURLException {
    if (isInvalid()) {
        throw new MalformedURLException("Invalid file path");
    }
    // return new URL("file", "", slashify(getAbsolutePath(), isDirectory()));
    return new URL("file", "", slashify(getAbsolutePath(), getAbsoluteFile().isDirectory()));
}
#end_block

#method_before
// Android-added: Additional information about android behaviour
public void deleteOnExit() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkDelete(path);
    }
    if (isInvalid()) {
        return;
    }
    DeleteOnExitHook.add(path);
}
#method_after
// Android-added: Additional information about Android behaviour.
public void deleteOnExit() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkDelete(path);
    }
    if (isInvalid()) {
        return;
    }
    DeleteOnExitHook.add(path);
}
#end_block

#method_before
// Android-changed: Replaced generic platform info with android specific one
public boolean renameTo(File dest) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
        security.checkWrite(dest.path);
    }
    if (dest == null) {
        throw new NullPointerException();
    }
    if (this.isInvalid() || dest.isInvalid()) {
        return false;
    }
    return fs.rename(this, dest);
}
#method_after
// Android-changed: Replaced generic platform info with Android specific one.
public boolean renameTo(File dest) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
        security.checkWrite(dest.path);
    }
    if (dest == null) {
        throw new NullPointerException();
    }
    if (this.isInvalid() || dest.isInvalid()) {
        return false;
    }
    return fs.rename(this, dest);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean setReadOnly() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setReadOnly(this);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean setReadOnly() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setReadOnly(this);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean setWritable(boolean writable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_WRITE, writable, ownerOnly);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean setWritable(boolean writable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_WRITE, writable, ownerOnly);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean setWritable(boolean writable) {
    return setWritable(writable, true);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean setWritable(boolean writable) {
    return setWritable(writable, true);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean setReadable(boolean readable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_READ, readable, ownerOnly);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean setReadable(boolean readable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_READ, readable, ownerOnly);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean setReadable(boolean readable) {
    return setReadable(readable, true);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean setReadable(boolean readable) {
    return setReadable(readable, true);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean setExecutable(boolean executable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_EXECUTE, executable, ownerOnly);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean setExecutable(boolean executable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_EXECUTE, executable, ownerOnly);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean setExecutable(boolean executable) {
    return setExecutable(executable, true);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean setExecutable(boolean executable) {
    return setExecutable(executable, true);
}
#end_block

#method_before
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on android
public boolean canExecute() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkExec(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.checkAccess(this, FileSystem.ACCESS_EXECUTE);
}
#method_after
// Android-changed. Removed javadoc comment about special privileges
// that doesn't make sense on Android.
public boolean canExecute() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkExec(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.checkAccess(this, FileSystem.ACCESS_EXECUTE);
}
#end_block

#method_before
/* -- Filesystem interface -- */
// Android-changed: Replaced generic platform info with android specific one
public static File[] listRoots() {
    return fs.listRoots();
}
#method_after
/* -- Filesystem interface -- */
// Android-changed: Replaced generic platform info with Android specific one.
public static File[] listRoots() {
    return fs.listRoots();
}
#end_block

#method_before
// Android-added: Replaced generic platform info with android specific one
public long getUsableSpace() {
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        sm.checkPermission(new RuntimePermission("getFileSystemAttributes"));
        sm.checkRead(path);
    }
    if (isInvalid()) {
        return 0L;
    }
    return fs.getSpace(this, FileSystem.SPACE_USABLE);
}
#method_after
// Android-added: Replaced generic platform info with Android specific one.
public long getUsableSpace() {
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        sm.checkPermission(new RuntimePermission("getFileSystemAttributes"));
        sm.checkRead(path);
    }
    if (isInvalid()) {
        return 0L;
    }
    return fs.getSpace(this, FileSystem.SPACE_USABLE);
}
#end_block

#method_before
// Android-changed: Don't cache java.io.tmpdir value
// temporary directory location
// private static final File tmpdir = new File(AccessController
// .doPrivileged(new GetPropertyAction("java.io.tmpdir")));
// static File location() {
// return tmpdir;
// }
// file name generation
static File generateFile(String prefix, String suffix, File dir) throws IOException {
    // Android-changed: Use Math.randomIntInternal. This (pseudo) random number
    // is initialized post-fork
    long n = Math.randomLongInternal();
    if (n == Long.MIN_VALUE) {
        // corner case
        n = 0;
    } else {
        n = Math.abs(n);
    }
    // Android-changed: Reject invalid file prefixes
    // Use only the file name from the supplied prefix
    // prefix = (new File(prefix)).getName();
    String name = prefix + Long.toString(n) + suffix;
    File f = new File(dir, name);
    if (!name.equals(f.getName()) || f.isInvalid()) {
        if (System.getSecurityManager() != null)
            throw new IOException("Unable to create temporary file");
        else
            throw new IOException("Unable to create temporary file, " + f);
    }
    return f;
}
#method_after
// Android-changed: Don't cache java.io.tmpdir value
// temporary directory location.
/*
        private static final File tmpdir = new File(AccessController
           .doPrivileged(new GetPropertyAction("java.io.tmpdir")));
        static File location() {
            return tmpdir;
        }
        */
// file name generation
static File generateFile(String prefix, String suffix, File dir) throws IOException {
    // Android-changed: Use Math.randomIntInternal. This (pseudo) random number
    // is initialized post-fork
    long n = Math.randomLongInternal();
    if (n == Long.MIN_VALUE) {
        // corner case
        n = 0;
    } else {
        n = Math.abs(n);
    }
    // Android-changed: Reject invalid file prefixes
    // Use only the file name from the supplied prefix
    // prefix = (new File(prefix)).getName();
    String name = prefix + Long.toString(n) + suffix;
    File f = new File(dir, name);
    if (!name.equals(f.getName()) || f.isInvalid()) {
        if (System.getSecurityManager() != null)
            throw new IOException("Unable to create temporary file");
        else
            throw new IOException("Unable to create temporary file, " + f);
    }
    return f;
}
#end_block

#method_before
public static File createTempFile(String prefix, String suffix, File directory) throws IOException {
    if (prefix.length() < 3)
        throw new IllegalArgumentException("Prefix string too short");
    if (suffix == null)
        suffix = ".tmp";
    // Android-changed: Handle java.io.tmpdir changes.
    File tmpdir = (directory != null) ? directory : new File(System.getProperty("java.io.tmpdir", "."));
    // SecurityManager sm = System.getSecurityManager();
    File f;
    do {
        f = TempDirectory.generateFile(prefix, suffix, tmpdir);
    // Android-changed: sm is always null on android
    // if (sm != null) {
    // try {
    // sm.checkWrite(f.getPath());
    // } catch (SecurityException se) {
    // // don't reveal temporary directory location
    // if (directory == null)
    // throw new SecurityException("Unable to create temporary file");
    // throw se;
    // }
    // }
    } while ((fs.getBooleanAttributes(f) & FileSystem.BA_EXISTS) != 0);
    if (!fs.createFileExclusively(f.getPath()))
        throw new IOException("Unable to create temporary file");
    return f;
}
#method_after
public static File createTempFile(String prefix, String suffix, File directory) throws IOException {
    if (prefix.length() < 3)
        throw new IllegalArgumentException("Prefix string too short");
    if (suffix == null)
        suffix = ".tmp";
    // Android-changed: Handle java.io.tmpdir changes.
    File tmpdir = (directory != null) ? directory : new File(System.getProperty("java.io.tmpdir", "."));
    // SecurityManager sm = System.getSecurityManager();
    File f;
    do {
        f = TempDirectory.generateFile(prefix, suffix, tmpdir);
    // Android-changed: sm is always null on Android.
    /*
            if (sm != null) {
                try {
                    sm.checkWrite(f.getPath());
                } catch (SecurityException se) {
                    // don't reveal temporary directory location
                    if (directory == null)
                        throw new SecurityException("Unable to create temporary file");
                    throw se;
                }
            }
            */
    } while ((fs.getBooleanAttributes(f) & FileSystem.BA_EXISTS) != 0);
    if (!fs.createFileExclusively(f.getPath()))
        throw new IOException("Unable to create temporary file");
    return f;
}
#end_block

#method_before
public static void main(String[] args) {
    int arg = 123456;
    float floatArg = 123456.125f;
    assertLongEquals(arg, $noinline$Add0(arg));
    assertIntEquals(5, $noinline$AddAddSubAddConst(1));
    assertIntEquals(arg, $noinline$AndAllOnes(arg));
    assertLongEquals(arg, $noinline$Div1(arg));
    assertIntEquals(-arg, $noinline$DivN1(arg));
    assertLongEquals(arg, $noinline$Mul1(arg));
    assertIntEquals(-arg, $noinline$MulN1(arg));
    assertLongEquals((128 * arg), $noinline$MulPowerOfTwo128(arg));
    assertLongEquals(2640, $noinline$MulMulMulConst(2));
    assertIntEquals(arg, $noinline$Or0(arg));
    assertLongEquals(arg, $noinline$OrSame(arg));
    assertIntEquals(arg, $noinline$Shl0(arg));
    assertLongEquals(arg, $noinline$Shr0(arg));
    assertLongEquals(arg, $noinline$Shr64(arg));
    assertLongEquals(arg, $noinline$Sub0(arg));
    assertIntEquals(-arg, $noinline$SubAliasNeg(arg));
    assertIntEquals(9, $noinline$SubAddConst1(2));
    assertIntEquals(-2, $noinline$SubAddConst2(3));
    assertLongEquals(3, $noinline$SubSubConst(4));
    assertLongEquals(arg, $noinline$UShr0(arg));
    assertIntEquals(arg, $noinline$Xor0(arg));
    assertIntEquals(~arg, $noinline$XorAllOnes(arg));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$AddNegs3(arg, arg + 1));
    assertLongEquals(1, $noinline$AddNeg1(arg, arg + 1));
    assertLongEquals(-1, $noinline$AddNeg2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NegNeg1(arg));
    assertIntEquals(0, $noinline$NegNeg2(arg));
    assertLongEquals(arg, $noinline$NegNeg3(arg));
    assertIntEquals(1, $noinline$NegSub1(arg, arg + 1));
    assertIntEquals(1, $noinline$NegSub2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NotNot1(arg));
    assertLongEquals(arg, $noinline$runSmaliTestLong("NotNot1", arg));
    assertIntEquals(-1, $noinline$NotNot2(arg));
    assertIntEquals(-1, $noinline$runSmaliTestInt("NotNot2", arg));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$SubNeg3(arg, arg + 1));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(true, $noinline$NotNotBool(true));
    assertBooleanEquals(true, $noinline$runSmaliTestBoolean("NotNotBool", true));
    assertBooleanEquals(false, $noinline$NotNotBool(false));
    assertBooleanEquals(false, $noinline$runSmaliTestBoolean("NotNotBool", false));
    assertFloatEquals(50.0f, $noinline$Div2(100.0f));
    assertDoubleEquals(75.0, $noinline$Div2(150.0));
    assertFloatEquals(-400.0f, $noinline$DivMP25(100.0f));
    assertDoubleEquals(-600.0, $noinline$DivMP25(150.0));
    assertIntEquals(0xc, $noinline$UShr28And15(0xc1234567));
    assertLongEquals(0xcL, $noinline$UShr60And15(0xc123456787654321L));
    assertIntEquals(0x4, $noinline$UShr28And7(0xc1234567));
    assertLongEquals(0x4L, $noinline$UShr60And7(0xc123456787654321L));
    assertIntEquals(0xc1, $noinline$Shr24And255(0xc1234567));
    assertLongEquals(0xc1L, $noinline$Shr56And255(0xc123456787654321L));
    assertIntEquals(0x41, $noinline$Shr24And127(0xc1234567));
    assertLongEquals(0x41L, $noinline$Shr56And127(0xc123456787654321L));
    assertIntEquals(0, $noinline$mulPow2Plus1(0));
    assertIntEquals(9, $noinline$mulPow2Plus1(1));
    assertIntEquals(18, $noinline$mulPow2Plus1(2));
    assertIntEquals(900, $noinline$mulPow2Plus1(100));
    assertIntEquals(111105, $noinline$mulPow2Plus1(12345));
    assertLongEquals(0, $noinline$mulPow2Minus1(0));
    assertLongEquals(31, $noinline$mulPow2Minus1(1));
    assertLongEquals(62, $noinline$mulPow2Minus1(2));
    assertLongEquals(3100, $noinline$mulPow2Minus1(100));
    assertLongEquals(382695, $noinline$mulPow2Minus1(12345));
    booleanField = false;
    assertIntEquals($noinline$booleanFieldNotEqualOne(), 54);
    assertIntEquals($noinline$booleanFieldEqualZero(), 54);
    booleanField = true;
    assertIntEquals(13, $noinline$booleanFieldNotEqualOne());
    assertIntEquals(13, $noinline$booleanFieldEqualZero());
    assertIntEquals(54, $noinline$intConditionNotEqualOne(6));
    assertIntEquals(13, $noinline$intConditionNotEqualOne(43));
    assertIntEquals(54, $noinline$intConditionEqualZero(6));
    assertIntEquals(13, $noinline$intConditionEqualZero(43));
    assertIntEquals(54, $noinline$floatConditionNotEqualOne(6.0f));
    assertIntEquals(13, $noinline$floatConditionNotEqualOne(43.0f));
    assertIntEquals(54, $noinline$doubleConditionEqualZero(6.0));
    assertIntEquals(13, $noinline$doubleConditionEqualZero(43.0));
    assertIntEquals(1234567, $noinline$intToDoubleToInt(1234567));
    assertIntEquals(Integer.MIN_VALUE, $noinline$intToDoubleToInt(Integer.MIN_VALUE));
    assertIntEquals(Integer.MAX_VALUE, $noinline$intToDoubleToInt(Integer.MAX_VALUE));
    assertStringEquals("d=7654321.0, i=7654321", $noinline$intToDoubleToIntPrint(7654321));
    assertIntEquals(12, $noinline$byteToDoubleToInt((byte) 12));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToInt(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToInt(Byte.MAX_VALUE));
    assertIntEquals(11, $noinline$floatToDoubleToInt(11.3f));
    assertStringEquals("d=12.25, i=12", $noinline$floatToDoubleToIntPrint(12.25f));
    assertIntEquals(123, $noinline$byteToDoubleToShort((byte) 123));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToShort(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToShort(Byte.MAX_VALUE));
    assertIntEquals(1234, $noinline$charToDoubleToShort((char) 1234));
    assertIntEquals(Character.MIN_VALUE, $noinline$charToDoubleToShort(Character.MIN_VALUE));
    assertIntEquals(/* sign-extended */
    -1, $noinline$charToDoubleToShort(Character.MAX_VALUE));
    assertIntEquals(12345, $noinline$floatToIntToShort(12345.75f));
    assertIntEquals(Short.MAX_VALUE, $noinline$floatToIntToShort((float) (Short.MIN_VALUE - 1)));
    assertIntEquals(Short.MIN_VALUE, $noinline$floatToIntToShort((float) (Short.MAX_VALUE + 1)));
    assertIntEquals(-54321, $noinline$intToFloatToInt(-54321));
    assertDoubleEquals((double) 0x12345678, $noinline$longToIntToDouble(0x1234567812345678L));
    assertDoubleEquals(0.0, $noinline$longToIntToDouble(Long.MIN_VALUE));
    assertDoubleEquals(-1.0, $noinline$longToIntToDouble(Long.MAX_VALUE));
    assertLongEquals(0x0000000012345678L, $noinline$longToIntToLong(0x1234567812345678L));
    assertLongEquals(0xffffffff87654321L, $noinline$longToIntToLong(0x1234567887654321L));
    assertLongEquals(0L, $noinline$longToIntToLong(Long.MIN_VALUE));
    assertLongEquals(-1L, $noinline$longToIntToLong(Long.MAX_VALUE));
    assertIntEquals((short) -5678, $noinline$shortToCharToShort((short) -5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToCharToShort(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToCharToShort(Short.MAX_VALUE));
    assertIntEquals(5678, $noinline$shortToLongToInt((short) 5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToLongToInt(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToLongToInt(Short.MAX_VALUE));
    assertIntEquals(0x34, $noinline$shortToCharToByte((short) 0x1234));
    assertIntEquals(-0x10, $noinline$shortToCharToByte((short) 0x12f0));
    assertIntEquals(0, $noinline$shortToCharToByte(Short.MIN_VALUE));
    assertIntEquals(-1, $noinline$shortToCharToByte(Short.MAX_VALUE));
    assertStringEquals("c=1025, b=1", $noinline$shortToCharToBytePrint((short) 1025));
    assertStringEquals("c=1023, b=-1", $noinline$shortToCharToBytePrint((short) 1023));
    assertStringEquals("c=65535, b=-1", $noinline$shortToCharToBytePrint((short) -1));
    assertLongEquals(0x55411410L, $noinline$intAndSmallLongConstant(0x55555555));
    assertLongEquals(0xffffffffaa028aa2L, $noinline$intAndSmallLongConstant(0xaaaaaaaa));
    assertLongEquals(0x44101440L, $noinline$intAndLargeLongConstant(0x55555555));
    assertLongEquals(0x208a002aaL, $noinline$intAndLargeLongConstant(0xaaaaaaaa));
    assertLongEquals(7L, $noinline$intShr28And15L(0x76543210));
    assertIntEquals(0x21, $noinline$longAnd0xffToByte(0x1234432112344321L));
    assertIntEquals(0, $noinline$longAnd0xffToByte(Long.MIN_VALUE));
    assertIntEquals(-1, $noinline$longAnd0xffToByte(Long.MAX_VALUE));
    assertIntEquals(0x1234, $noinline$intAnd0x1ffffToChar(0x43211234));
    assertIntEquals(0, $noinline$intAnd0x1ffffToChar(Integer.MIN_VALUE));
    assertIntEquals(Character.MAX_VALUE, $noinline$intAnd0x1ffffToChar(Integer.MAX_VALUE));
    assertIntEquals(0x4321, $noinline$intAnd0x17fffToShort(0x87654321));
    assertIntEquals(0x0888, $noinline$intAnd0x17fffToShort(0x88888888));
    assertIntEquals(0, $noinline$intAnd0x17fffToShort(Integer.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$intAnd0x17fffToShort(Integer.MAX_VALUE));
    assertDoubleEquals(0.0, $noinline$shortAnd0xffffToShortToDouble((short) 0));
    assertDoubleEquals(1.0, $noinline$shortAnd0xffffToShortToDouble((short) 1));
    assertDoubleEquals(-2.0, $noinline$shortAnd0xffffToShortToDouble((short) -2));
    assertDoubleEquals(12345.0, $noinline$shortAnd0xffffToShortToDouble((short) 12345));
    assertDoubleEquals((double) Short.MAX_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MAX_VALUE));
    assertDoubleEquals((double) Short.MIN_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MIN_VALUE));
    assertIntEquals(13, $noinline$intReverseCondition(41));
    assertIntEquals(13, $noinline$intReverseConditionNaN(-5));
    for (String condition : new String[] { "Equal", "NotEqual" }) {
        for (String constant : new String[] { "True", "False" }) {
            for (String side : new String[] { "Rhs", "Lhs" }) {
                String name = condition + constant + side;
                assertIntEquals(5, $noinline$runSmaliTest(name, true));
                assertIntEquals(3, $noinline$runSmaliTest(name, false));
            }
        }
    }
    assertIntEquals(0, $noinline$runSmaliTestInt("AddSubConst", 1));
    assertIntEquals(3, $noinline$runSmaliTestInt("SubAddConst", 2));
    assertIntEquals(-16, $noinline$runSmaliTestInt("SubSubConst1", 3));
    assertIntEquals(-5, $noinline$runSmaliTestInt("SubSubConst2", 4));
    assertIntEquals(26, $noinline$runSmaliTestInt("SubSubConst3", 5));
    assertIntEquals(0x5e6f7808, $noinline$intUnnecessaryShiftMasking(0xabcdef01, 3));
    assertIntEquals(0x5e6f7808, $noinline$intUnnecessaryShiftMasking(0xabcdef01, 3 + 32));
    assertLongEquals(0xffffffffffffeaf3L, $noinline$longUnnecessaryShiftMasking(0xabcdef0123456789L, 50));
    assertLongEquals(0xffffffffffffeaf3L, $noinline$longUnnecessaryShiftMasking(0xabcdef0123456789L, 50 + 64));
    assertIntEquals(0x2af37b, $noinline$intUnnecessaryWiderShiftMasking(0xabcdef01, 10));
    assertIntEquals(0x2af37b, $noinline$intUnnecessaryWiderShiftMasking(0xabcdef01, 10 + 128));
    assertLongEquals(0xaf37bc048d159e24L, $noinline$longSmallerShiftMasking(0xabcdef0123456789L, 2));
    assertLongEquals(0xaf37bc048d159e24L, $noinline$longSmallerShiftMasking(0xabcdef0123456789L, 2 + 256));
    assertIntEquals(0xfffd5e7c, $noinline$otherUseOfUnnecessaryShiftMasking(0xabcdef01, 13));
    assertIntEquals(0xfffd5e7c, $noinline$otherUseOfUnnecessaryShiftMasking(0xabcdef01, 13 + 512));
    assertIntEquals(0x5f49eb48, $noinline$intUnnecessaryShiftModifications(0xabcdef01, 2));
    assertIntEquals(0xbd4c29b0, $noinline$intUnnecessaryShiftModifications(0xabcdef01, 3));
    assertIntEquals(0xc0fed1ca, $noinline$intNecessaryShiftModifications(0xabcdef01, 2));
    assertIntEquals(0x03578ebc, $noinline$intNecessaryShiftModifications(0xabcdef01, 3));
    assertIntEquals(654321, $noinline$intAddSubSimplifyArg1(arg, 654321));
    assertIntEquals(arg, $noinline$intAddSubSimplifyArg2(arg, 654321));
    assertIntEquals(arg, $noinline$intSubAddSimplifyLeft(arg, 654321));
    assertIntEquals(arg, $noinline$intSubAddSimplifyRight(arg, 654321));
    assertFloatEquals(654321.125f, $noinline$floatAddSubSimplifyArg1(floatArg, 654321.125f));
    assertFloatEquals(floatArg, $noinline$floatAddSubSimplifyArg2(floatArg, 654321.125f));
    assertFloatEquals(floatArg, $noinline$floatSubAddSimplifyLeft(floatArg, 654321.125f));
    assertFloatEquals(floatArg, $noinline$floatSubAddSimplifyRight(floatArg, 654321.125f));
}
#method_after
public static void main(String[] args) {
    int arg = 123456;
    float floatArg = 123456.125f;
    assertLongEquals(arg, $noinline$Add0(arg));
    assertIntEquals(5, $noinline$AddAddSubAddConst(1));
    assertIntEquals(arg, $noinline$AndAllOnes(arg));
    assertLongEquals(arg, $noinline$Div1(arg));
    assertIntEquals(-arg, $noinline$DivN1(arg));
    assertLongEquals(arg, $noinline$Mul1(arg));
    assertIntEquals(-arg, $noinline$MulN1(arg));
    assertLongEquals((128 * arg), $noinline$MulPowerOfTwo128(arg));
    assertLongEquals(2640, $noinline$MulMulMulConst(2));
    assertIntEquals(arg, $noinline$Or0(arg));
    assertLongEquals(arg, $noinline$OrSame(arg));
    assertIntEquals(arg, $noinline$Shl0(arg));
    assertLongEquals(arg, $noinline$Shr0(arg));
    assertLongEquals(arg, $noinline$Shr64(arg));
    assertLongEquals(arg, $noinline$Sub0(arg));
    assertIntEquals(-arg, $noinline$SubAliasNeg(arg));
    assertIntEquals(9, $noinline$SubAddConst1(2));
    assertIntEquals(-2, $noinline$SubAddConst2(3));
    assertLongEquals(3, $noinline$SubSubConst(4));
    assertLongEquals(arg, $noinline$UShr0(arg));
    assertIntEquals(arg, $noinline$Xor0(arg));
    assertIntEquals(~arg, $noinline$XorAllOnes(arg));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$AddNegs2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$AddNegs3(arg, arg + 1));
    assertLongEquals(1, $noinline$AddNeg1(arg, arg + 1));
    assertLongEquals(-1, $noinline$AddNeg2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NegNeg1(arg));
    assertIntEquals(0, $noinline$NegNeg2(arg));
    assertLongEquals(arg, $noinline$NegNeg3(arg));
    assertIntEquals(1, $noinline$NegSub1(arg, arg + 1));
    assertIntEquals(1, $noinline$NegSub2(arg, arg + 1));
    assertLongEquals(arg, $noinline$NotNot1(arg));
    assertLongEquals(arg, $noinline$runSmaliTestLong("$noinline$NotNot1", arg));
    assertIntEquals(-1, $noinline$NotNot2(arg));
    assertIntEquals(-1, $noinline$runSmaliTestInt("$noinline$NotNot2", arg));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg1(arg, arg + 1));
    assertIntEquals(-(arg + arg + 1), $noinline$SubNeg2(arg, arg + 1));
    assertLongEquals(-(2 * arg + 1), $noinline$SubNeg3(arg, arg + 1));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(true, $noinline$EqualBoolVsIntConst(true));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(false, $noinline$NotEqualBoolVsIntConst(false));
    assertBooleanEquals(true, $noinline$NotNotBool(true));
    assertBooleanEquals(true, $noinline$runSmaliTestBoolean("$noinline$NotNotBool", true));
    assertBooleanEquals(false, $noinline$NotNotBool(false));
    assertBooleanEquals(false, $noinline$runSmaliTestBoolean("$noinline$NotNotBool", false));
    assertFloatEquals(50.0f, $noinline$Div2(100.0f));
    assertDoubleEquals(75.0, $noinline$Div2(150.0));
    assertFloatEquals(-400.0f, $noinline$DivMP25(100.0f));
    assertDoubleEquals(-600.0, $noinline$DivMP25(150.0));
    assertIntEquals(0xc, $noinline$UShr28And15(0xc1234567));
    assertLongEquals(0xcL, $noinline$UShr60And15(0xc123456787654321L));
    assertIntEquals(0x4, $noinline$UShr28And7(0xc1234567));
    assertLongEquals(0x4L, $noinline$UShr60And7(0xc123456787654321L));
    assertIntEquals(0xc1, $noinline$Shr24And255(0xc1234567));
    assertLongEquals(0xc1L, $noinline$Shr56And255(0xc123456787654321L));
    assertIntEquals(0x41, $noinline$Shr24And127(0xc1234567));
    assertLongEquals(0x41L, $noinline$Shr56And127(0xc123456787654321L));
    assertIntEquals(0, $noinline$mulPow2Plus1(0));
    assertIntEquals(9, $noinline$mulPow2Plus1(1));
    assertIntEquals(18, $noinline$mulPow2Plus1(2));
    assertIntEquals(900, $noinline$mulPow2Plus1(100));
    assertIntEquals(111105, $noinline$mulPow2Plus1(12345));
    assertLongEquals(0, $noinline$mulPow2Minus1(0));
    assertLongEquals(31, $noinline$mulPow2Minus1(1));
    assertLongEquals(62, $noinline$mulPow2Minus1(2));
    assertLongEquals(3100, $noinline$mulPow2Minus1(100));
    assertLongEquals(382695, $noinline$mulPow2Minus1(12345));
    booleanField = false;
    assertIntEquals($noinline$booleanFieldNotEqualOne(), 54);
    assertIntEquals($noinline$booleanFieldEqualZero(), 54);
    booleanField = true;
    assertIntEquals(13, $noinline$booleanFieldNotEqualOne());
    assertIntEquals(13, $noinline$booleanFieldEqualZero());
    assertIntEquals(54, $noinline$intConditionNotEqualOne(6));
    assertIntEquals(13, $noinline$intConditionNotEqualOne(43));
    assertIntEquals(54, $noinline$intConditionEqualZero(6));
    assertIntEquals(13, $noinline$intConditionEqualZero(43));
    assertIntEquals(54, $noinline$floatConditionNotEqualOne(6.0f));
    assertIntEquals(13, $noinline$floatConditionNotEqualOne(43.0f));
    assertIntEquals(54, $noinline$doubleConditionEqualZero(6.0));
    assertIntEquals(13, $noinline$doubleConditionEqualZero(43.0));
    assertIntEquals(1234567, $noinline$intToDoubleToInt(1234567));
    assertIntEquals(Integer.MIN_VALUE, $noinline$intToDoubleToInt(Integer.MIN_VALUE));
    assertIntEquals(Integer.MAX_VALUE, $noinline$intToDoubleToInt(Integer.MAX_VALUE));
    assertStringEquals("d=7654321.0, i=7654321", $noinline$intToDoubleToIntPrint(7654321));
    assertIntEquals(12, $noinline$byteToDoubleToInt((byte) 12));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToInt(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToInt(Byte.MAX_VALUE));
    assertIntEquals(11, $noinline$floatToDoubleToInt(11.3f));
    assertStringEquals("d=12.25, i=12", $noinline$floatToDoubleToIntPrint(12.25f));
    assertIntEquals(123, $noinline$byteToDoubleToShort((byte) 123));
    assertIntEquals(Byte.MIN_VALUE, $noinline$byteToDoubleToShort(Byte.MIN_VALUE));
    assertIntEquals(Byte.MAX_VALUE, $noinline$byteToDoubleToShort(Byte.MAX_VALUE));
    assertIntEquals(1234, $noinline$charToDoubleToShort((char) 1234));
    assertIntEquals(Character.MIN_VALUE, $noinline$charToDoubleToShort(Character.MIN_VALUE));
    assertIntEquals(/* sign-extended */
    -1, $noinline$charToDoubleToShort(Character.MAX_VALUE));
    assertIntEquals(12345, $noinline$floatToIntToShort(12345.75f));
    assertIntEquals(Short.MAX_VALUE, $noinline$floatToIntToShort((float) (Short.MIN_VALUE - 1)));
    assertIntEquals(Short.MIN_VALUE, $noinline$floatToIntToShort((float) (Short.MAX_VALUE + 1)));
    assertIntEquals(-54321, $noinline$intToFloatToInt(-54321));
    assertDoubleEquals((double) 0x12345678, $noinline$longToIntToDouble(0x1234567812345678L));
    assertDoubleEquals(0.0, $noinline$longToIntToDouble(Long.MIN_VALUE));
    assertDoubleEquals(-1.0, $noinline$longToIntToDouble(Long.MAX_VALUE));
    assertLongEquals(0x0000000012345678L, $noinline$longToIntToLong(0x1234567812345678L));
    assertLongEquals(0xffffffff87654321L, $noinline$longToIntToLong(0x1234567887654321L));
    assertLongEquals(0L, $noinline$longToIntToLong(Long.MIN_VALUE));
    assertLongEquals(-1L, $noinline$longToIntToLong(Long.MAX_VALUE));
    assertIntEquals((short) -5678, $noinline$shortToCharToShort((short) -5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToCharToShort(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToCharToShort(Short.MAX_VALUE));
    assertIntEquals(5678, $noinline$shortToLongToInt((short) 5678));
    assertIntEquals(Short.MIN_VALUE, $noinline$shortToLongToInt(Short.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$shortToLongToInt(Short.MAX_VALUE));
    assertIntEquals(0x34, $noinline$shortToCharToByte((short) 0x1234));
    assertIntEquals(-0x10, $noinline$shortToCharToByte((short) 0x12f0));
    assertIntEquals(0, $noinline$shortToCharToByte(Short.MIN_VALUE));
    assertIntEquals(-1, $noinline$shortToCharToByte(Short.MAX_VALUE));
    assertStringEquals("c=1025, b=1", $noinline$shortToCharToBytePrint((short) 1025));
    assertStringEquals("c=1023, b=-1", $noinline$shortToCharToBytePrint((short) 1023));
    assertStringEquals("c=65535, b=-1", $noinline$shortToCharToBytePrint((short) -1));
    assertLongEquals(0x55411410L, $noinline$intAndSmallLongConstant(0x55555555));
    assertLongEquals(0xffffffffaa028aa2L, $noinline$intAndSmallLongConstant(0xaaaaaaaa));
    assertLongEquals(0x44101440L, $noinline$intAndLargeLongConstant(0x55555555));
    assertLongEquals(0x208a002aaL, $noinline$intAndLargeLongConstant(0xaaaaaaaa));
    assertLongEquals(7L, $noinline$intShr28And15L(0x76543210));
    assertIntEquals(0x21, $noinline$longAnd0xffToByte(0x1234432112344321L));
    assertIntEquals(0, $noinline$longAnd0xffToByte(Long.MIN_VALUE));
    assertIntEquals(-1, $noinline$longAnd0xffToByte(Long.MAX_VALUE));
    assertIntEquals(0x1234, $noinline$intAnd0x1ffffToChar(0x43211234));
    assertIntEquals(0, $noinline$intAnd0x1ffffToChar(Integer.MIN_VALUE));
    assertIntEquals(Character.MAX_VALUE, $noinline$intAnd0x1ffffToChar(Integer.MAX_VALUE));
    assertIntEquals(0x4321, $noinline$intAnd0x17fffToShort(0x87654321));
    assertIntEquals(0x0888, $noinline$intAnd0x17fffToShort(0x88888888));
    assertIntEquals(0, $noinline$intAnd0x17fffToShort(Integer.MIN_VALUE));
    assertIntEquals(Short.MAX_VALUE, $noinline$intAnd0x17fffToShort(Integer.MAX_VALUE));
    assertDoubleEquals(0.0, $noinline$shortAnd0xffffToShortToDouble((short) 0));
    assertDoubleEquals(1.0, $noinline$shortAnd0xffffToShortToDouble((short) 1));
    assertDoubleEquals(-2.0, $noinline$shortAnd0xffffToShortToDouble((short) -2));
    assertDoubleEquals(12345.0, $noinline$shortAnd0xffffToShortToDouble((short) 12345));
    assertDoubleEquals((double) Short.MAX_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MAX_VALUE));
    assertDoubleEquals((double) Short.MIN_VALUE, $noinline$shortAnd0xffffToShortToDouble(Short.MIN_VALUE));
    assertIntEquals(13, $noinline$intReverseCondition(41));
    assertIntEquals(13, $noinline$intReverseConditionNaN(-5));
    for (String condition : new String[] { "Equal", "NotEqual" }) {
        for (String constant : new String[] { "True", "False" }) {
            for (String side : new String[] { "Rhs", "Lhs" }) {
                String name = condition + constant + side;
                assertIntEquals(5, $noinline$runSmaliTest(name, true));
                assertIntEquals(3, $noinline$runSmaliTest(name, false));
            }
        }
    }
    assertIntEquals(0, $noinline$runSmaliTestInt("AddSubConst", 1));
    assertIntEquals(3, $noinline$runSmaliTestInt("SubAddConst", 2));
    assertIntEquals(-16, $noinline$runSmaliTestInt("SubSubConst1", 3));
    assertIntEquals(-5, $noinline$runSmaliTestInt("SubSubConst2", 4));
    assertIntEquals(26, $noinline$runSmaliTestInt("SubSubConst3", 5));
    assertIntEquals(0x5e6f7808, $noinline$intUnnecessaryShiftMasking(0xabcdef01, 3));
    assertIntEquals(0x5e6f7808, $noinline$intUnnecessaryShiftMasking(0xabcdef01, 3 + 32));
    assertLongEquals(0xffffffffffffeaf3L, $noinline$longUnnecessaryShiftMasking(0xabcdef0123456789L, 50));
    assertLongEquals(0xffffffffffffeaf3L, $noinline$longUnnecessaryShiftMasking(0xabcdef0123456789L, 50 + 64));
    assertIntEquals(0x2af37b, $noinline$intUnnecessaryWiderShiftMasking(0xabcdef01, 10));
    assertIntEquals(0x2af37b, $noinline$intUnnecessaryWiderShiftMasking(0xabcdef01, 10 + 128));
    assertLongEquals(0xaf37bc048d159e24L, $noinline$longSmallerShiftMasking(0xabcdef0123456789L, 2));
    assertLongEquals(0xaf37bc048d159e24L, $noinline$longSmallerShiftMasking(0xabcdef0123456789L, 2 + 256));
    assertIntEquals(0xfffd5e7c, $noinline$otherUseOfUnnecessaryShiftMasking(0xabcdef01, 13));
    assertIntEquals(0xfffd5e7c, $noinline$otherUseOfUnnecessaryShiftMasking(0xabcdef01, 13 + 512));
    assertIntEquals(0x5f49eb48, $noinline$intUnnecessaryShiftModifications(0xabcdef01, 2));
    assertIntEquals(0xbd4c29b0, $noinline$intUnnecessaryShiftModifications(0xabcdef01, 3));
    assertIntEquals(0xc0fed1ca, $noinline$intNecessaryShiftModifications(0xabcdef01, 2));
    assertIntEquals(0x03578ebc, $noinline$intNecessaryShiftModifications(0xabcdef01, 3));
    assertIntEquals(654321, $noinline$intAddSubSimplifyArg1(arg, 654321));
    assertIntEquals(arg, $noinline$intAddSubSimplifyArg2(arg, 654321));
    assertIntEquals(arg, $noinline$intSubAddSimplifyLeft(arg, 654321));
    assertIntEquals(arg, $noinline$intSubAddSimplifyRight(arg, 654321));
    assertFloatEquals(654321.125f, $noinline$floatAddSubSimplifyArg1(floatArg, 654321.125f));
    assertFloatEquals(floatArg, $noinline$floatAddSubSimplifyArg2(floatArg, 654321.125f));
    assertFloatEquals(floatArg, $noinline$floatSubAddSimplifyLeft(floatArg, 654321.125f));
    assertFloatEquals(floatArg, $noinline$floatSubAddSimplifyRight(floatArg, 654321.125f));
}
#end_block

#method_before
public void configure(ConfigurableProvider provider) {
    // BEGIN Android-removed: Unsupported algorithms
    /*
            provider.addAlgorithm("AlgorithmParameterGenerator.RC2", PREFIX + "$AlgParamGen");
            provider.addAlgorithm("AlgorithmParameterGenerator.1.2.840.113549.3.2", PREFIX + "$AlgParamGen");

            provider.addAlgorithm("KeyGenerator.RC2", PREFIX + "$KeyGenerator");
            provider.addAlgorithm("KeyGenerator.1.2.840.113549.3.2", PREFIX + "$KeyGenerator");

            provider.addAlgorithm("AlgorithmParameters.RC2", PREFIX + "$AlgParams");
            provider.addAlgorithm("AlgorithmParameters.1.2.840.113549.3.2", PREFIX + "$AlgParams");

            provider.addAlgorithm("Cipher.RC2", PREFIX + "$ECB");
            provider.addAlgorithm("Cipher.RC2WRAP", PREFIX + "$Wrap");
            provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.id_alg_CMSRC2wrap, "RC2WRAP");
            provider.addAlgorithm("Cipher", PKCSObjectIdentifiers.RC2_CBC, PREFIX + "$CBC");

            provider.addAlgorithm("Mac.RC2MAC", PREFIX + "$CBCMAC");
            provider.addAlgorithm("Alg.Alias.Mac.RC2", "RC2MAC");
            provider.addAlgorithm("Mac.RC2MAC/CFB8", PREFIX + "$CFB8MAC");
            provider.addAlgorithm("Alg.Alias.Mac.RC2/CFB8", "RC2MAC/CFB8");

            provider.addAlgorithm("Alg.Alias.SecretKeyFactory.PBEWITHMD2ANDRC2-CBC", "PBEWITHMD2ANDRC2");
            */
    // END Android-removed: Unsupported algorithms
    // Android-note: The non-disabled algorithms here are all necessary for KeyStore.PKCS12
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.PBEWITHMD5ANDRC2-CBC", "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.PBEWITHSHA1ANDRC2-CBC", "PBEWITHSHA1ANDRC2");
    // Android-removed: Unsupported algorithms
    // provider.addAlgorithm("Alg.Alias.SecretKeyFactory", PKCSObjectIdentifiers.pbeWithMD2AndRC2_CBC, "PBEWITHMD2ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory", PKCSObjectIdentifiers.pbeWithMD5AndRC2_CBC, "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory", PKCSObjectIdentifiers.pbeWithSHA1AndRC2_CBC, "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.1.2.840.113549.1.12.1.5", "PBEWITHSHAAND128BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.1.2.840.113549.1.12.1.6", "PBEWITHSHAAND40BITRC2-CBC");
    // Android-removed: Unsupported algorithms
    // provider.addAlgorithm("SecretKeyFactory.PBEWITHMD2ANDRC2", PREFIX + "$PBEWithMD2KeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHMD5ANDRC2", PREFIX + "$PBEWithMD5KeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHSHA1ANDRC2", PREFIX + "$PBEWithSHA1KeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHSHAAND128BITRC2-CBC", PREFIX + "$PBEWithSHAAnd128BitKeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHSHAAND40BITRC2-CBC", PREFIX + "$PBEWithSHAAnd40BitKeyFactory");
    // Android-removed: Unsupported algorithms
    // provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithMD2AndRC2_CBC, "PBEWITHMD2ANDRC2");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithMD5AndRC2_CBC, "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithSHA1AndRC2_CBC, "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.1.2.840.113549.1.12.1.5", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.1.2.840.113549.1.12.1.6", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWithSHAAnd3KeyTripleDES", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithSHAAnd128BitRC2_CBC, "PBEWITHSHAAND128BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithSHAAnd40BitRC2_CBC, "PBEWITHSHAAND40BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHA1AND128BITRC2-CBC", "PBEWITHSHAAND128BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHA1AND40BITRC2-CBC", "PBEWITHSHAAND40BITRC2-CBC");
    provider.addAlgorithm("Cipher.PBEWITHSHA1ANDRC2", PREFIX + "$PBEWithSHA1AndRC2");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHAANDRC2-CBC", "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHA1ANDRC2-CBC", "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Cipher.PBEWITHSHAAND128BITRC2-CBC", PREFIX + "$PBEWithSHAAnd128BitRC2");
    provider.addAlgorithm("Cipher.PBEWITHSHAAND40BITRC2-CBC", PREFIX + "$PBEWithSHAAnd40BitRC2");
    provider.addAlgorithm("Cipher.PBEWITHMD5ANDRC2", PREFIX + "$PBEWithMD5AndRC2");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHMD5ANDRC2-CBC", "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHA1ANDRC2", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHAANDRC2", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHA1ANDRC2-CBC", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHAAND40BITRC2-CBC", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHAAND128BITRC2-CBC", "PKCS12PBE");
}
#method_after
public void configure(ConfigurableProvider provider) {
    // BEGIN Android-removed: Unsupported algorithms
    /*
            provider.addAlgorithm("AlgorithmParameterGenerator.RC2", PREFIX + "$AlgParamGen");
            provider.addAlgorithm("AlgorithmParameterGenerator.1.2.840.113549.3.2", PREFIX + "$AlgParamGen");

            provider.addAlgorithm("KeyGenerator.RC2", PREFIX + "$KeyGenerator");
            provider.addAlgorithm("KeyGenerator.1.2.840.113549.3.2", PREFIX + "$KeyGenerator");

            provider.addAlgorithm("AlgorithmParameters.RC2", PREFIX + "$AlgParams");
            provider.addAlgorithm("AlgorithmParameters.1.2.840.113549.3.2", PREFIX + "$AlgParams");

            provider.addAlgorithm("Cipher.RC2", PREFIX + "$ECB");
            provider.addAlgorithm("Cipher.RC2WRAP", PREFIX + "$Wrap");
            provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.id_alg_CMSRC2wrap, "RC2WRAP");
            provider.addAlgorithm("Cipher", PKCSObjectIdentifiers.RC2_CBC, PREFIX + "$CBC");

            provider.addAlgorithm("Mac.RC2MAC", PREFIX + "$CBCMAC");
            provider.addAlgorithm("Alg.Alias.Mac.RC2", "RC2MAC");
            provider.addAlgorithm("Mac.RC2MAC/CFB8", PREFIX + "$CFB8MAC");
            provider.addAlgorithm("Alg.Alias.Mac.RC2/CFB8", "RC2MAC/CFB8");

            provider.addAlgorithm("Alg.Alias.SecretKeyFactory.PBEWITHMD2ANDRC2-CBC", "PBEWITHMD2ANDRC2");
            */
    // END Android-removed: Unsupported algorithms
    // Android-note: All of the non-disabled algorithms in this class are necessary
    // for KeyStore.PKCS12
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.PBEWITHMD5ANDRC2-CBC", "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.PBEWITHSHA1ANDRC2-CBC", "PBEWITHSHA1ANDRC2");
    // Android-removed: Unsupported algorithms
    // provider.addAlgorithm("Alg.Alias.SecretKeyFactory", PKCSObjectIdentifiers.pbeWithMD2AndRC2_CBC, "PBEWITHMD2ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory", PKCSObjectIdentifiers.pbeWithMD5AndRC2_CBC, "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory", PKCSObjectIdentifiers.pbeWithSHA1AndRC2_CBC, "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.1.2.840.113549.1.12.1.5", "PBEWITHSHAAND128BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.SecretKeyFactory.1.2.840.113549.1.12.1.6", "PBEWITHSHAAND40BITRC2-CBC");
    // Android-removed: Unsupported algorithms
    // provider.addAlgorithm("SecretKeyFactory.PBEWITHMD2ANDRC2", PREFIX + "$PBEWithMD2KeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHMD5ANDRC2", PREFIX + "$PBEWithMD5KeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHSHA1ANDRC2", PREFIX + "$PBEWithSHA1KeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHSHAAND128BITRC2-CBC", PREFIX + "$PBEWithSHAAnd128BitKeyFactory");
    provider.addAlgorithm("SecretKeyFactory.PBEWITHSHAAND40BITRC2-CBC", PREFIX + "$PBEWithSHAAnd40BitKeyFactory");
    // Android-removed: Unsupported algorithms
    // provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithMD2AndRC2_CBC, "PBEWITHMD2ANDRC2");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithMD5AndRC2_CBC, "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithSHA1AndRC2_CBC, "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.1.2.840.113549.1.12.1.5", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.1.2.840.113549.1.12.1.6", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWithSHAAnd3KeyTripleDES", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithSHAAnd128BitRC2_CBC, "PBEWITHSHAAND128BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.Cipher", PKCSObjectIdentifiers.pbeWithSHAAnd40BitRC2_CBC, "PBEWITHSHAAND40BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHA1AND128BITRC2-CBC", "PBEWITHSHAAND128BITRC2-CBC");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHA1AND40BITRC2-CBC", "PBEWITHSHAAND40BITRC2-CBC");
    provider.addAlgorithm("Cipher.PBEWITHSHA1ANDRC2", PREFIX + "$PBEWithSHA1AndRC2");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHAANDRC2-CBC", "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHSHA1ANDRC2-CBC", "PBEWITHSHA1ANDRC2");
    provider.addAlgorithm("Cipher.PBEWITHSHAAND128BITRC2-CBC", PREFIX + "$PBEWithSHAAnd128BitRC2");
    provider.addAlgorithm("Cipher.PBEWITHSHAAND40BITRC2-CBC", PREFIX + "$PBEWithSHAAnd40BitRC2");
    provider.addAlgorithm("Cipher.PBEWITHMD5ANDRC2", PREFIX + "$PBEWithMD5AndRC2");
    provider.addAlgorithm("Alg.Alias.Cipher.PBEWITHMD5ANDRC2-CBC", "PBEWITHMD5ANDRC2");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHA1ANDRC2", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHAANDRC2", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHA1ANDRC2-CBC", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHAAND40BITRC2-CBC", "PKCS12PBE");
    provider.addAlgorithm("Alg.Alias.AlgorithmParameters.PBEWITHSHAAND128BITRC2-CBC", "PKCS12PBE");
}
#end_block

#method_before
private void onDataReconnect(Bundle bundle) {
    String reason = bundle.getString(INTENT_RECONNECT_ALARM_EXTRA_REASON);
    String apnType = bundle.getString(INTENT_RECONNECT_ALARM_EXTRA_TYPE);
    ApnContext apnContext = mApnContexts.get(apnType);
    if (DBG) {
        log("onDataReconnect: mState=" + mState + " reason=" + reason + " apnType=" + apnType + " apnContext=" + apnContext + " mDataConnectionAsyncChannels=" + mDataConnectionAcHashMap);
    }
    if ((apnContext != null) && (apnContext.isEnabled())) {
        apnContext.setReason(reason);
        DctConstants.State apnContextState = apnContext.getState();
        if (DBG) {
            log("onDataReconnect: apnContext state=" + apnContextState);
        }
        if ((apnContextState == DctConstants.State.FAILED) || (apnContextState == DctConstants.State.IDLE)) {
            if (DBG) {
                log("onDataReconnect: state is FAILED|IDLE, disassociate");
            }
            DcAsyncChannel dcac = apnContext.getDcAc();
            if (dcac != null) {
                if (DBG) {
                    log("onDataReconnect: tearDown apnContext=" + apnContext);
                }
                dcac.tearDown(apnContext, "", null);
            }
            apnContext.setDataConnectionAc(null);
            apnContext.setState(DctConstants.State.IDLE);
        } else {
            if (DBG)
                log("onDataReconnect: keep associated");
        }
        // TODO: IF already associated should we send the EVENT_TRY_SETUP_DATA???
        sendMessage(obtainMessage(DctConstants.EVENT_TRY_SETUP_DATA, apnContext));
        apnContext.setReconnectedParameter(null);
    }
}
#method_after
private void onDataReconnect(Bundle bundle) {
    String reason = bundle.getString(INTENT_RECONNECT_ALARM_EXTRA_REASON);
    String apnType = bundle.getString(INTENT_RECONNECT_ALARM_EXTRA_TYPE);
    int phoneSubId = mPhone.getSubId();
    int currSubId = bundle.getInt(PhoneConstants.SUBSCRIPTION_KEY, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
    log("onDataReconnect: currSubId = " + currSubId + " phoneSubId=" + phoneSubId);
    // FIXME STOPSHIP - phoneSubId is coming up as -1 way after boot and failing this?
    if (!SubscriptionManager.isValidSubscriptionId(currSubId) || (currSubId != phoneSubId)) {
        log("receive ReconnectAlarm but subId incorrect, ignore");
        return;
    }
    ApnContext apnContext = mApnContexts.get(apnType);
    if (DBG) {
        log("onDataReconnect: mState=" + mState + " reason=" + reason + " apnType=" + apnType + " apnContext=" + apnContext + " mDataConnectionAsyncChannels=" + mDataConnectionAcHashMap);
    }
    if ((apnContext != null) && (apnContext.isEnabled())) {
        apnContext.setReason(reason);
        DctConstants.State apnContextState = apnContext.getState();
        if (DBG) {
            log("onDataReconnect: apnContext state=" + apnContextState);
        }
        if ((apnContextState == DctConstants.State.FAILED) || (apnContextState == DctConstants.State.IDLE)) {
            if (DBG) {
                log("onDataReconnect: state is FAILED|IDLE, disassociate");
            }
            DcAsyncChannel dcac = apnContext.getDcAc();
            if (dcac != null) {
                if (DBG) {
                    log("onDataReconnect: tearDown apnContext=" + apnContext);
                }
                dcac.tearDown(apnContext, "", null);
            }
            apnContext.setDataConnectionAc(null);
            apnContext.setState(DctConstants.State.IDLE);
        } else {
            if (DBG)
                log("onDataReconnect: keep associated");
        }
        // TODO: IF already associated should we send the EVENT_TRY_SETUP_DATA???
        sendMessage(obtainMessage(DctConstants.EVENT_TRY_SETUP_DATA, apnContext));
        apnContext.setReconnectIntent(null);
    }
}
#end_block

#method_before
private void cleanUpConnection(boolean tearDown, ApnContext apnContext) {
    if (apnContext == null) {
        if (DBG)
            log("cleanUpConnection: apn context is null");
        return;
    }
    DcAsyncChannel dcac = apnContext.getDcAc();
    String str = "cleanUpConnection: tearDown=" + tearDown + " reason=" + apnContext.getReason();
    if (VDBG)
        log(str + " apnContext=" + apnContext);
    apnContext.requestLog(str);
    if (tearDown) {
        if (apnContext.isDisconnected()) {
            // The request is tearDown and but ApnContext is not connected.
            // If apnContext is not enabled anymore, break the linkage to the DCAC/DC.
            apnContext.setState(DctConstants.State.IDLE);
            if (!apnContext.isReady()) {
                if (dcac != null) {
                    str = "cleanUpConnection: teardown, disconnected, !ready";
                    if (DBG)
                        log(str + " apnContext=" + apnContext);
                    apnContext.requestLog(str);
                    dcac.tearDown(apnContext, "", null);
                }
                apnContext.setDataConnectionAc(null);
            }
        } else {
            // Connection is still there. Try to clean up.
            if (dcac != null) {
                if (apnContext.getState() != DctConstants.State.DISCONNECTING) {
                    boolean disconnectAll = false;
                    if (PhoneConstants.APN_TYPE_DUN.equals(apnContext.getApnType())) {
                        // if (PhoneConstants.APN_TYPE_DUN.equals(PhoneConstants.APN_TYPE_DEFAULT)) {
                        if (teardownForDun()) {
                            if (DBG) {
                                log("cleanUpConnection: disconnectAll DUN connection");
                            }
                            // we need to tear it down - we brought it up just for dun and
                            // other people are camped on it and now dun is done.  We need
                            // to stop using it and let the normal apn list get used to find
                            // connections for the remaining desired connections
                            disconnectAll = true;
                        }
                    }
                    final int generation = apnContext.getConnectionGeneration();
                    str = "cleanUpConnection: tearing down" + (disconnectAll ? " all" : "") + " using gen#" + generation;
                    if (DBG)
                        log(str + "apnContext=" + apnContext);
                    apnContext.requestLog(str);
                    Pair<ApnContext, Integer> pair = new Pair<ApnContext, Integer>(apnContext, generation);
                    Message msg = obtainMessage(DctConstants.EVENT_DISCONNECT_DONE, pair);
                    if (disconnectAll) {
                        apnContext.getDcAc().tearDownAll(apnContext.getReason(), msg);
                    } else {
                        apnContext.getDcAc().tearDown(apnContext, apnContext.getReason(), msg);
                    }
                    apnContext.setState(DctConstants.State.DISCONNECTING);
                    mDisconnectPendingCount++;
                }
            } else {
                // apn is connected but no reference to dcac.
                // Should not be happen, but reset the state in case.
                apnContext.setState(DctConstants.State.IDLE);
                apnContext.requestLog("cleanUpConnection: connected, bug no DCAC");
                mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
            }
        }
    } else {
        // force clean up the data connection.
        if (dcac != null)
            dcac.reqReset();
        apnContext.setState(DctConstants.State.IDLE);
        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
        apnContext.setDataConnectionAc(null);
    }
    // associated to the connection.
    if (dcac != null) {
        cancelReconnectEvent(apnContext);
    }
    str = "cleanUpConnection: X tearDown=" + tearDown + " reason=" + apnContext.getReason();
    if (DBG)
        log(str + " apnContext=" + apnContext + " dcac=" + apnContext.getDcAc());
    apnContext.requestLog(str);
}
#method_after
private void cleanUpConnection(boolean tearDown, ApnContext apnContext) {
    if (apnContext == null) {
        if (DBG)
            log("cleanUpConnection: apn context is null");
        return;
    }
    DcAsyncChannel dcac = apnContext.getDcAc();
    String str = "cleanUpConnection: tearDown=" + tearDown + " reason=" + apnContext.getReason();
    if (VDBG)
        log(str + " apnContext=" + apnContext);
    apnContext.requestLog(str);
    if (tearDown) {
        if (apnContext.isDisconnected()) {
            // The request is tearDown and but ApnContext is not connected.
            // If apnContext is not enabled anymore, break the linkage to the DCAC/DC.
            apnContext.setState(DctConstants.State.IDLE);
            if (!apnContext.isReady()) {
                if (dcac != null) {
                    str = "cleanUpConnection: teardown, disconnected, !ready";
                    if (DBG)
                        log(str + " apnContext=" + apnContext);
                    apnContext.requestLog(str);
                    dcac.tearDown(apnContext, "", null);
                }
                apnContext.setDataConnectionAc(null);
            }
        } else {
            // Connection is still there. Try to clean up.
            if (dcac != null) {
                if (apnContext.getState() != DctConstants.State.DISCONNECTING) {
                    boolean disconnectAll = false;
                    if (PhoneConstants.APN_TYPE_DUN.equals(apnContext.getApnType())) {
                        // if (PhoneConstants.APN_TYPE_DUN.equals(PhoneConstants.APN_TYPE_DEFAULT)) {
                        if (teardownForDun()) {
                            if (DBG) {
                                log("cleanUpConnection: disconnectAll DUN connection");
                            }
                            // we need to tear it down - we brought it up just for dun and
                            // other people are camped on it and now dun is done.  We need
                            // to stop using it and let the normal apn list get used to find
                            // connections for the remaining desired connections
                            disconnectAll = true;
                        }
                    }
                    final int generation = apnContext.getConnectionGeneration();
                    str = "cleanUpConnection: tearing down" + (disconnectAll ? " all" : "") + " using gen#" + generation;
                    if (DBG)
                        log(str + "apnContext=" + apnContext);
                    apnContext.requestLog(str);
                    Pair<ApnContext, Integer> pair = new Pair<ApnContext, Integer>(apnContext, generation);
                    Message msg = obtainMessage(DctConstants.EVENT_DISCONNECT_DONE, pair);
                    if (disconnectAll) {
                        apnContext.getDcAc().tearDownAll(apnContext.getReason(), msg);
                    } else {
                        apnContext.getDcAc().tearDown(apnContext, apnContext.getReason(), msg);
                    }
                    apnContext.setState(DctConstants.State.DISCONNECTING);
                    mDisconnectPendingCount++;
                }
            } else {
                // apn is connected but no reference to dcac.
                // Should not be happen, but reset the state in case.
                apnContext.setState(DctConstants.State.IDLE);
                apnContext.requestLog("cleanUpConnection: connected, bug no DCAC");
                mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
            }
        }
    } else {
        // force clean up the data connection.
        if (dcac != null)
            dcac.reqReset();
        apnContext.setState(DctConstants.State.IDLE);
        mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
        apnContext.setDataConnectionAc(null);
    }
    // associated to the connection.
    if (dcac != null) {
        cancelReconnectAlarm(apnContext);
    }
    str = "cleanUpConnection: X tearDown=" + tearDown + " reason=" + apnContext.getReason();
    if (DBG)
        log(str + " apnContext=" + apnContext + " dcac=" + apnContext.getDcAc());
    apnContext.requestLog(str);
}
#end_block

#method_before
private void onDataSetupCompleteError(AsyncResult ar) {
    ApnContext apnContext = getValidApnContext(ar, "onDataSetupCompleteError");
    if (apnContext == null)
        return;
    long delay = apnContext.getDelayForNextApn(mFailFast);
    // Check if we need to retry or not.
    if (delay >= 0) {
        if (DBG)
            log("onDataSetupCompleteError: Try next APN. delay = " + delay);
        apnContext.setState(DctConstants.State.SCANNING);
        // Wait a bit before trying the next APN, so that
        // we're not tying up the RIL command channel
        sendDelayEventForDataReconnect(delay, apnContext);
    } else {
        // If we are not going to retry any APN, set this APN context to failed state.
        // This would be the final state of a data connection.
        apnContext.setState(DctConstants.State.FAILED);
        mPhone.notifyDataConnection(Phone.REASON_APN_FAILED, apnContext.getApnType());
        apnContext.setDataConnectionAc(null);
        log("onDataSetupCompleteError: Stop retrying APNs.");
    }
}
#method_after
private void onDataSetupCompleteError(AsyncResult ar) {
    ApnContext apnContext = getValidApnContext(ar, "onDataSetupCompleteError");
    if (apnContext == null)
        return;
    long delay = apnContext.getDelayForNextApn(mFailFast);
    // Check if we need to retry or not.
    if (delay >= 0) {
        if (DBG)
            log("onDataSetupCompleteError: Try next APN. delay = " + delay);
        apnContext.setState(DctConstants.State.SCANNING);
        // Wait a bit before trying the next APN, so that
        // we're not tying up the RIL command channel
        startAlarmForReconnect(delay, apnContext);
    } else {
        // If we are not going to retry any APN, set this APN context to failed state.
        // This would be the final state of a data connection.
        apnContext.setState(DctConstants.State.FAILED);
        mPhone.notifyDataConnection(Phone.REASON_APN_FAILED, apnContext.getApnType());
        apnContext.setDataConnectionAc(null);
        log("onDataSetupCompleteError: Stop retrying APNs.");
    }
}
#end_block

#method_before
private void onDisconnectDone(AsyncResult ar) {
    ApnContext apnContext = getValidApnContext(ar, "onDisconnectDone");
    if (apnContext == null)
        return;
    if (DBG)
        log("onDisconnectDone: EVENT_DISCONNECT_DONE apnContext=" + apnContext);
    apnContext.setState(DctConstants.State.IDLE);
    mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
    // pending.
    if (isDisconnected()) {
        if (mPhone.getServiceStateTracker().processPendingRadioPowerOffAfterDataOff()) {
            if (DBG)
                log("onDisconnectDone: radio will be turned off, no retries");
            // Radio will be turned off. No need to retry data setup
            apnContext.setApnSetting(null);
            apnContext.setDataConnectionAc(null);
            // Otherwise, it would cause 30s delayed to turn on Airplane mode.
            if (mDisconnectPendingCount > 0) {
                mDisconnectPendingCount--;
            }
            if (mDisconnectPendingCount == 0) {
                notifyDataDisconnectComplete();
                notifyAllDataDisconnected();
            }
            return;
        }
    }
    // If APN is still enabled, try to bring it back up automatically
    if (mAttached.get() && apnContext.isReady() && retryAfterDisconnected(apnContext)) {
        try {
            SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
        } catch (RuntimeException ex) {
            log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
        }
        // This also helps in any external dependency to turn off the context.
        if (DBG)
            log("onDisconnectDone: attached, ready and retry after disconnect");
        long delay = apnContext.getRetryAfterDisconnectDelay();
        if (delay > 0) {
            // Data connection is in IDLE state, so when we reconnect later, we'll rebuild
            // the waiting APN list, which will also reset/reconfigure the retry manager.
            sendDelayEventForDataReconnect(delay, apnContext);
        }
    } else {
        boolean restartRadioAfterProvisioning = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_restartRadioAfterProvisioning);
        if (apnContext.isProvisioningApn() && restartRadioAfterProvisioning) {
            log("onDisconnectDone: restartRadio after provisioning");
            restartRadio();
        }
        apnContext.setApnSetting(null);
        apnContext.setDataConnectionAc(null);
        if (isOnlySingleDcAllowed(mPhone.getServiceState().getRilDataRadioTechnology())) {
            if (DBG)
                log("onDisconnectDone: isOnlySigneDcAllowed true so setup single apn");
            setupDataOnConnectableApns(Phone.REASON_SINGLE_PDN_ARBITRATION);
        } else {
            if (DBG)
                log("onDisconnectDone: not retrying");
        }
    }
    if (mDisconnectPendingCount > 0)
        mDisconnectPendingCount--;
    if (mDisconnectPendingCount == 0) {
        apnContext.setConcurrentVoiceAndDataAllowed(mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed());
        notifyDataDisconnectComplete();
        notifyAllDataDisconnected();
    }
}
#method_after
private void onDisconnectDone(AsyncResult ar) {
    ApnContext apnContext = getValidApnContext(ar, "onDisconnectDone");
    if (apnContext == null)
        return;
    if (DBG)
        log("onDisconnectDone: EVENT_DISCONNECT_DONE apnContext=" + apnContext);
    apnContext.setState(DctConstants.State.IDLE);
    mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
    // pending.
    if (isDisconnected()) {
        if (mPhone.getServiceStateTracker().processPendingRadioPowerOffAfterDataOff()) {
            if (DBG)
                log("onDisconnectDone: radio will be turned off, no retries");
            // Radio will be turned off. No need to retry data setup
            apnContext.setApnSetting(null);
            apnContext.setDataConnectionAc(null);
            // Otherwise, it would cause 30s delayed to turn on Airplane mode.
            if (mDisconnectPendingCount > 0) {
                mDisconnectPendingCount--;
            }
            if (mDisconnectPendingCount == 0) {
                notifyDataDisconnectComplete();
                notifyAllDataDisconnected();
            }
            return;
        }
    }
    // If APN is still enabled, try to bring it back up automatically
    if (mAttached.get() && apnContext.isReady() && retryAfterDisconnected(apnContext)) {
        try {
            SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
        } catch (RuntimeException ex) {
            log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
        }
        // This also helps in any external dependency to turn off the context.
        if (DBG)
            log("onDisconnectDone: attached, ready and retry after disconnect");
        long delay = apnContext.getRetryAfterDisconnectDelay();
        if (delay > 0) {
            // Data connection is in IDLE state, so when we reconnect later, we'll rebuild
            // the waiting APN list, which will also reset/reconfigure the retry manager.
            startAlarmForReconnect(delay, apnContext);
        }
    } else {
        boolean restartRadioAfterProvisioning = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_restartRadioAfterProvisioning);
        if (apnContext.isProvisioningApn() && restartRadioAfterProvisioning) {
            log("onDisconnectDone: restartRadio after provisioning");
            restartRadio();
        }
        apnContext.setApnSetting(null);
        apnContext.setDataConnectionAc(null);
        if (isOnlySingleDcAllowed(mPhone.getServiceState().getRilDataRadioTechnology())) {
            if (DBG)
                log("onDisconnectDone: isOnlySigneDcAllowed true so setup single apn");
            setupDataOnConnectableApns(Phone.REASON_SINGLE_PDN_ARBITRATION);
        } else {
            if (DBG)
                log("onDisconnectDone: not retrying");
        }
    }
    if (mDisconnectPendingCount > 0)
        mDisconnectPendingCount--;
    if (mDisconnectPendingCount == 0) {
        apnContext.setConcurrentVoiceAndDataAllowed(mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed());
        notifyDataDisconnectComplete();
        notifyAllDataDisconnected();
    }
}
#end_block

#method_before
private static void unsupported(String msg) throws UnsupportedOperationException {
    // TODO(b/65872996): Remove this function when no longer required.
    throw new UnsupportedOperationException(msg);
}
#method_after
// BEGIN Android-added: unsupported() helper function.
private static void unsupported(String msg) throws UnsupportedOperationException {
    throw new UnsupportedOperationException(msg);
}
#end_block

#method_before
// Android-changed: We do not use MemberName / MethodHandleImpl.
// 
// private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
// static { MethodHandleImpl.initStatics(); }
// See IMPL_LOOKUP below.
// // Method handle creation from ordinary methods.
/**
 * Returns a {@link Lookup lookup object} with
 * full capabilities to emulate all supported bytecode behaviors of the caller.
 * These capabilities include <a href="MethodHandles.Lookup.html#privacc">private access</a> to the caller.
 * Factory methods on the lookup object can create
 * <a href="MethodHandleInfo.html#directmh">direct method handles</a>
 * for any member that the caller has access to via bytecodes,
 * including protected and private fields and methods.
 * This lookup object is a <em>capability</em> which may be delegated to trusted agents.
 * Do not store it in place where untrusted code can access it.
 * <p>
 * This method is caller sensitive, which means that it may return different
 * values to different callers.
 * <p>
 * For any given caller class {@code C}, the lookup object returned by this call
 * has equivalent capabilities to any lookup object
 * supplied by the JVM to the bootstrap method of an
 * <a href="package-summary.html#indyinsn">invokedynamic instruction</a>
 * executing in the same caller class {@code C}.
 * @return a lookup object for the caller of this method, with private access
 */
// Android-changed: Remove caller sensitive.
public static Lookup lookup() {
    // Android-changed: Do not use Reflection.getCallerClass().
    return new Lookup(VMStack.getStackClass1());
}
#method_after
// END Android-added: unsupported() helper function.
// Android-changed: We do not use MemberName / MethodHandleImpl.
// 
// private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
// static { MethodHandleImpl.initStatics(); }
// See IMPL_LOOKUP below.
// // Method handle creation from ordinary methods.
/**
 * Returns a {@link Lookup lookup object} with
 * full capabilities to emulate all supported bytecode behaviors of the caller.
 * These capabilities include <a href="MethodHandles.Lookup.html#privacc">private access</a> to the caller.
 * Factory methods on the lookup object can create
 * <a href="MethodHandleInfo.html#directmh">direct method handles</a>
 * for any member that the caller has access to via bytecodes,
 * including protected and private fields and methods.
 * This lookup object is a <em>capability</em> which may be delegated to trusted agents.
 * Do not store it in place where untrusted code can access it.
 * <p>
 * This method is caller sensitive, which means that it may return different
 * values to different callers.
 * <p>
 * For any given caller class {@code C}, the lookup object returned by this call
 * has equivalent capabilities to any lookup object
 * supplied by the JVM to the bootstrap method of an
 * <a href="package-summary.html#indyinsn">invokedynamic instruction</a>
 * executing in the same caller class {@code C}.
 * @return a lookup object for the caller of this method, with private access
 */
// Android-changed: Remove caller sensitive.
public static Lookup lookup() {
    // Android-changed: Do not use Reflection.getCallerClass().
    return new Lookup(VMStack.getStackClass1());
}
#end_block

#method_before
public MethodHandle findVirtual(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // itself, we can return one of our specialized invokers.
    if (refc == MethodHandle.class) {
        MethodHandle mh = findVirtualForMH(name, type);
        if (mh != null) {
            return mh;
        }
    }
    if (refc == VarHandle.class) {
        // TODO(b/65872996)
        unsupported("MethodHandles.findVirtual with refc == VarHandle.class");
        return null;
    }
    Method method = refc.getInstanceMethod(name, type.ptypes());
    if (method == null) {
        // general.
        try {
            Method m = refc.getDeclaredMethod(name, type.ptypes());
            if (Modifier.isStatic(m.getModifiers())) {
                throw new IllegalAccessException("Method" + m + " is static");
            }
        } catch (NoSuchMethodException ignored) {
        }
        throw new NoSuchMethodException(name + " " + Arrays.toString(type.ptypes()));
    }
    checkReturnType(method, type);
    // We have a valid method, perform access checks.
    checkAccess(refc, method.getDeclaringClass(), method.getModifiers(), method.getName());
    // Insert the leading reference parameter.
    MethodType handleType = type.insertParameterTypes(0, refc);
    return createMethodHandle(method, MethodHandle.INVOKE_VIRTUAL, handleType);
}
#method_after
public MethodHandle findVirtual(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // itself, we can return one of our specialized invokers.
    if (refc == MethodHandle.class) {
        MethodHandle mh = findVirtualForMH(name, type);
        if (mh != null) {
            return mh;
        }
    }
    // Implementation to follow. TODO(b/65872996)
    if (refc == VarHandle.class) {
        unsupported("MethodHandles.findVirtual with refc == VarHandle.class");
        return null;
    }
    // END Android-changed: Added VarHandle handling here.
    Method method = refc.getInstanceMethod(name, type.ptypes());
    if (method == null) {
        // general.
        try {
            Method m = refc.getDeclaredMethod(name, type.ptypes());
            if (Modifier.isStatic(m.getModifiers())) {
                throw new IllegalAccessException("Method" + m + " is static");
            }
        } catch (NoSuchMethodException ignored) {
        }
        throw new NoSuchMethodException(name + " " + Arrays.toString(type.ptypes()));
    }
    checkReturnType(method, type);
    // We have a valid method, perform access checks.
    checkAccess(refc, method.getDeclaringClass(), method.getModifiers(), method.getName());
    // Insert the leading reference parameter.
    MethodType handleType = type.insertParameterTypes(0, refc);
    return createMethodHandle(method, MethodHandle.INVOKE_VIRTUAL, handleType);
}
#end_block

#method_before
public VarHandle findVarHandle(Class<?> recv, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(b/65872996)
    unsupported("MethodHandles.Lookup.findVarHandle()");
    return null;
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public VarHandle findVarHandle(Class<?> recv, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(b/65872996)
    unsupported("MethodHandles.Lookup.findVarHandle()");
    return null;
}
#end_block

#method_before
public MethodHandle findStaticGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    return findAccessor(refc, name, type, MethodHandle.SGET);
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public MethodHandle findStaticGetter(Class<?> refc, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    return findAccessor(refc, name, type, MethodHandle.SGET);
}
#end_block

#method_before
public VarHandle findStaticVarHandle(Class<?> decl, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(b/65872996)
    unsupported("MethodHandles.Lookup.findStaticVarHandle()");
    return null;
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public VarHandle findStaticVarHandle(Class<?> decl, String name, Class<?> type) throws NoSuchFieldException, IllegalAccessException {
    // TODO(b/65872996)
    unsupported("MethodHandles.Lookup.findStaticVarHandle()");
    return null;
}
#end_block

#method_before
public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    MethodHandle handle = findVirtual(receiver.getClass(), name, type);
    MethodHandle adapter = handle.bindTo(receiver);
    MethodType adapterType = adapter.type();
    if (handle.isVarargsCollector()) {
        adapter = adapter.asVarargsCollector(adapterType.parameterType(adapterType.parameterCount() - 1));
    }
    return adapter;
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    MethodHandle handle = findVirtual(receiver.getClass(), name, type);
    MethodHandle adapter = handle.bindTo(receiver);
    MethodType adapterType = adapter.type();
    if (handle.isVarargsCollector()) {
        adapter = adapter.asVarargsCollector(adapterType.parameterType(adapterType.parameterCount() - 1));
    }
    return adapter;
}
#end_block

#method_before
public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
    // TODO(b/65872996)
    unsupported("MethodHandles.Lookup.unreflectVarHandle()");
    return null;
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
    // TODO(b/65872996)
    unsupported("MethodHandles.Lookup.unreflectVarHandle()");
    return null;
}
#end_block

#method_before
public MethodHandleInfo revealDirect(MethodHandle target) {
    MethodHandleImpl directTarget = getMethodHandleImpl(target);
    MethodHandleInfo info = directTarget.reveal();
    try {
        checkAccess(lookupClass(), info.getDeclaringClass(), info.getModifiers(), info.getName());
    } catch (IllegalAccessException exception) {
        throw new IllegalArgumentException("Unable to access memeber.", exception);
    }
    return info;
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory method for bring up purposes.
public MethodHandleInfo revealDirect(MethodHandle target) {
    MethodHandleImpl directTarget = getMethodHandleImpl(target);
    MethodHandleInfo info = directTarget.reveal();
    try {
        checkAccess(lookupClass(), info.getDeclaringClass(), info.getModifiers(), info.getName());
    } catch (IllegalAccessException exception) {
        throw new IllegalArgumentException("Unable to access memeber.", exception);
    }
    return info;
}
#end_block

#method_before
public static VarHandle arrayElementVarHandle(Class<?> arrayClass) throws IllegalArgumentException {
    // TODO(b/65872996)
    unsupported("MethodHandles.arrayElementVarHandle()");
    return null;
}
#method_after
// BEGIN Android-changed: OpenJDK 9+181 VarHandle API factory methods for bring up purposes.
public static VarHandle arrayElementVarHandle(Class<?> arrayClass) throws IllegalArgumentException {
    // TODO(b/65872996)
    unsupported("MethodHandles.arrayElementVarHandle()");
    return null;
}
#end_block

#method_before
// / method handle invocation (reflective style)
static public MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
    if (leadingArgCount < 0 || leadingArgCount > type.parameterCount())
        throw newIllegalArgumentException("bad argument count", leadingArgCount);
    MethodHandle invoker = MethodHandles.invoker(type);
    int spreadArgCount = type.parameterCount() - leadingArgCount;
    invoker = invoker.asSpreader(Object[].class, spreadArgCount);
    return invoker;
}
#method_after
// END Android-changed: OpenJDK 9+181 VarHandle API factory methods for bring up purposes.
// / method handle invocation (reflective style)
static public MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
    if (leadingArgCount < 0 || leadingArgCount > type.parameterCount())
        throw newIllegalArgumentException("bad argument count", leadingArgCount);
    MethodHandle invoker = MethodHandles.invoker(type);
    int spreadArgCount = type.parameterCount() - leadingArgCount;
    invoker = invoker.asSpreader(Object[].class, spreadArgCount);
    return invoker;
}
#end_block

#method_before
private static void unsupported(String msg) throws UnsupportedOperationException {
    // TODO(b/65872996): Remove this function when no longer required.
    throw new UnsupportedOperationException(msg);
}
#method_after
// BEGIN Android-removed: No VarForm in Android implementation.
/*
    final VarForm vform;

    VarHandle(VarForm vform) {
        this.vform = vform;
    }
    */
// END Android-removed: No VarForm in Android implementation.
RuntimeException unsupported() {
    return new UnsupportedOperationException();
}
#end_block

#method_before
public final Class<?> varType() {
    MethodType typeSet = accessModeType(AccessMode.SET);
    return typeSet.parameterType(typeSet.parameterCount() - 1);
}
#method_after
// BEGIN Android-removed: AccessDescriptor not used in Android implementation.
/*
    static final class AccessDescriptor {
        final MethodType symbolicMethodTypeErased;
        final MethodType symbolicMethodTypeInvoker;
        final Class<?> returnType;
        final int type;
        final int mode;

        public AccessDescriptor(MethodType symbolicMethodType, int type, int mode) {
            this.symbolicMethodTypeErased = symbolicMethodType.erase();
            this.symbolicMethodTypeInvoker = symbolicMethodType.insertParameterTypes(0, VarHandle.class);
            this.returnType = symbolicMethodType.returnType();
            this.type = type;
            this.mode = mode;
        }
    }
    */
// END Android-removed: AccessDescriptor not used in Android implementation.
public final Class<?> varType() {
    MethodType typeSet = accessModeType(AccessMode.SET);
    return typeSet.parameterType(typeSet.parameterCount() - 1);
}
#end_block

#method_before
public final MethodType accessModeType(AccessMode accessMode) {
    // Android-changed:
    // TODO(b/65872996)
    unsupported("VarHandle.accessModeType()");
    return null;
}
#method_after
public final MethodType accessModeType(AccessMode accessMode) {
    // BEGIN Android-removed: Relies on internal class that is not part of the
    // Android implementation.
    /*
        TypesAndInvokers tis = getTypesAndInvokers();
        MethodType mt = tis.methodType_table[accessMode.at.ordinal()];
        if (mt == null) {
            mt = tis.methodType_table[accessMode.at.ordinal()] =
                    accessModeTypeUncached(accessMode);
        }
        return mt;
        */
    // END Android-removed: Relies on internal class that is not part of the
    // Android implementation.
    // Android-added: Throw an exception until implemented.
    // TODO(b/65872996)
    unsupported();
    return null;
}
#end_block

#method_before
public final boolean isAccessModeSupported(AccessMode accessMode) {
    // Android-changed:
    // TODO(b/65872996)
    unsupported("VarHandle.isAccessModeSupport()");
    return false;
}
#method_after
// Android-removed: Not part of the Android implementation.
// abstract MethodType accessModeTypeUncached(AccessMode accessMode);
public final boolean isAccessModeSupported(AccessMode accessMode) {
    // Android-removed: Refers to unused field vform.
    // return AccessMode.getMemberName(accessMode.ordinal(), vform) != null;
    // Android-added: Throw an exception until implemented.
    // TODO(b/65872996)
    unsupported();
    return false;
}
#end_block

#method_before
public final MethodHandle toMethodHandle(AccessMode accessMode) {
    throw new UnsupportedOperationException("Not implemented");
// Android-changed:
// 
// MemberName mn = AccessMode.getMemberName(accessMode.ordinal(), vform);
// if (mn != null) {
// MethodHandle mh = getMethodHandle(accessMode.ordinal());
// return mh.bindTo(this);
// }
// else {
// // Ensure an UnsupportedOperationException is thrown
// return MethodHandles.varHandleInvoker(accessMode, accessModeType(accessMode)).
// bindTo(this);
// }
}
#method_after
public final MethodHandle toMethodHandle(AccessMode accessMode) {
    // BEGIN Android-removed: no vform field in Android implementation.
    /*
        MemberName mn = AccessMode.getMemberName(accessMode.ordinal(), vform);
        if (mn != null) {
            MethodHandle mh = getMethodHandle(accessMode.ordinal());
            return mh.bindTo(this);
        }
        else {
            // Ensure an UnsupportedOperationException is thrown
            return MethodHandles.varHandleInvoker(accessMode, accessModeType(accessMode)).
                    bindTo(this);
        }
        */
    // Android-added: Throw an exception until implemented.
    // TODO(b/65872996)
    unsupported();
    return null;
}
#end_block

#method_before
// Android-changed:
// 
// @ForceInline
// private final TypesAndInvokers getTypesAndInvokers() {
// TypesAndInvokers tis = typesAndInvokers;
// if (tis == null) {
// tis = typesAndInvokers = new TypesAndInvokers();
// }
// return tis;
// }
// @ForceInline
// final MethodHandle getMethodHandle(int mode) {
// TypesAndInvokers tis = getTypesAndInvokers();
// MethodHandle mh = tis.methodHandle_table[mode];
// if (mh == null) {
// mh = tis.methodHandle_table[mode] = getMethodHandleUncached(mode);
// }
// return mh;
// }
// private final MethodHandle getMethodHandleUncached(int mode) {
// MethodType mt = accessModeType(AccessMode.values()[mode]).
// insertParameterTypes(0, VarHandle.class);
// MemberName mn = vform.getMemberName(mode);
// DirectMethodHandle dmh = DirectMethodHandle.make(mn);
// // Such a method handle must not be publically exposed directly
// // otherwise it can be cracked, it must be transformed or rebound
// // before exposure
// MethodHandle mh = dmh.copyWith(mt, dmh.form);
// assert mh.type().erase() == mn.getMethodType().erase();
// return mh;
// }
/*non-public*/
// Android-changed:
// 
// final void updateVarForm(VarForm newVForm) {
// if (vform == newVForm) return;
// UNSAFE.putObject(this, VFORM_OFFSET, newVForm);
// UNSAFE.fullFence();
// }
// 
// static final BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException>
// AIOOBE_SUPPLIER = Preconditions.outOfBoundsExceptionFormatter(
// new Function<String, ArrayIndexOutOfBoundsException>() {
// @Override
// public ArrayIndexOutOfBoundsException apply(String s) {
// return new ArrayIndexOutOfBoundsException(s);
// }
// });
// private static final long VFORM_OFFSET;
// static {
// try {
// VFORM_OFFSET = UNSAFE.objectFieldOffset(VarHandle.class.getDeclaredField("vform"));
// }
// catch (ReflectiveOperationException e) {
// throw newInternalError(e);
// }
// // The VarHandleGuards must be initialized to ensure correct
// // compilation of the guard methods
// UNSAFE.ensureClassInitialized(VarHandleGuards.class);
// }
// Fence methods
public static void fullFence() {
    UNSAFE.fullFence();
}
#method_after
// BEGIN Android-removed: Not used in Android implementation.
/*
    @Stable
    TypesAndInvokers typesAndInvokers;

    static class TypesAndInvokers {
        final @Stable
        MethodType[] methodType_table =
                new MethodType[VarHandle.AccessType.values().length];

        final @Stable
        MethodHandle[] methodHandle_table =
                new MethodHandle[AccessMode.values().length];
    }

    @ForceInline
    private final TypesAndInvokers getTypesAndInvokers() {
        TypesAndInvokers tis = typesAndInvokers;
        if (tis == null) {
            tis = typesAndInvokers = new TypesAndInvokers();
        }
        return tis;
    }

    @ForceInline
    final MethodHandle getMethodHandle(int mode) {
        TypesAndInvokers tis = getTypesAndInvokers();
        MethodHandle mh = tis.methodHandle_table[mode];
        if (mh == null) {
            mh = tis.methodHandle_table[mode] = getMethodHandleUncached(mode);
        }
        return mh;
    }
    private final MethodHandle getMethodHandleUncached(int mode) {
        MethodType mt = accessModeType(AccessMode.values()[mode]).
                insertParameterTypes(0, VarHandle.class);
        MemberName mn = vform.getMemberName(mode);
        DirectMethodHandle dmh = DirectMethodHandle.make(mn);
        // Such a method handle must not be publically exposed directly
        // otherwise it can be cracked, it must be transformed or rebound
        // before exposure
        MethodHandle mh = dmh.copyWith(mt, dmh.form);
        assert mh.type().erase() == mn.getMethodType().erase();
        return mh;
    }
    */
// END Android-removed: Not used in Android implementation.
/*non-public*/
// BEGIN Android-removed: No VarForm in Android implementation.
/*
    final void updateVarForm(VarForm newVForm) {
        if (vform == newVForm) return;
        UNSAFE.putObject(this, VFORM_OFFSET, newVForm);
        UNSAFE.fullFence();
    }

    static final BiFunction<String, List<Integer>, ArrayIndexOutOfBoundsException>
            AIOOBE_SUPPLIER = Preconditions.outOfBoundsExceptionFormatter(
            new Function<String, ArrayIndexOutOfBoundsException>() {
                @Override
                public ArrayIndexOutOfBoundsException apply(String s) {
                    return new ArrayIndexOutOfBoundsException(s);
                }
            });

    private static final long VFORM_OFFSET;

    static {
        try {
            VFORM_OFFSET = UNSAFE.objectFieldOffset(VarHandle.class.getDeclaredField("vform"));
        }
        catch (ReflectiveOperationException e) {
            throw newInternalError(e);
        }

        // The VarHandleGuards must be initialized to ensure correct
        // compilation of the guard methods
        UNSAFE.ensureClassInitialized(VarHandleGuards.class);
    }
    */
// END Android-removed: No VarForm in Android implementation.
// Fence methods
/**
 * Ensures that loads and stores before the fence will not be reordered
 * with
 * loads and stores after the fence.
 *
 * @apiNote Ignoring the many semantic differences from C and C++, this
 * method has memory ordering effects compatible with
 * {@code atomic_thread_fence(memory_order_seq_cst)}
 */
// Android-removed: @ForceInline is an unsupported attribute.
public static void fullFence() {
    UNSAFE.fullFence();
}
#end_block

#method_before
public static void acquireFence() {
    UNSAFE.loadFence();
}
#method_after
/**
 * Ensures that loads before the fence will not be reordered with loads and
 * stores after the fence.
 *
 * @apiNote Ignoring the many semantic differences from C and C++, this
 * method has memory ordering effects compatible with
 * {@code atomic_thread_fence(memory_order_acquire)}
 */
// Android-removed: @ForceInline is an unsupported attribute.
public static void acquireFence() {
    UNSAFE.loadFence();
}
#end_block

#method_before
public static void releaseFence() {
    UNSAFE.storeFence();
}
#method_after
/**
 * Ensures that loads and stores before the fence will not be
 * reordered with stores after the fence.
 *
 * @apiNote Ignoring the many semantic differences from C and C++, this
 * method has memory ordering effects compatible with
 * {@code atomic_thread_fence(memory_order_release)}
 */
// Android-removed: @ForceInline is an unsupported attribute.
public static void releaseFence() {
    UNSAFE.storeFence();
}
#end_block

#method_before
public static void loadLoadFence() {
    // Android-changed:
    UNSAFE.loadFence();
}
#method_after
/**
 * Ensures that loads before the fence will not be reordered with
 * loads after the fence.
 */
// Android-removed: @ForceInline is an unsupported attribute.
public static void loadLoadFence() {
    // Android-changed: Not using UNSAFE.loadLoadFence() as not present on Android.
    // NB The compiler recognizes all the fences here as intrinsics.
    UNSAFE.loadFence();
}
#end_block

#method_before
public static void storeStoreFence() {
    // Android-changed:
    UNSAFE.storeFence();
}
#method_after
/**
 * Ensures that stores before the fence will not be reordered with
 * stores after the fence.
 */
// Android-removed: @ForceInline is an unsupported attribute.
public static void storeStoreFence() {
    // Android-changed: Not using UNSAFE.storeStoreFence() as not present on Android.
    // NB The compiler recognizes all the fences here as intrinsics.
    UNSAFE.storeFence();
}
#end_block

#method_before
@SmallTest
public void testNetworkCallbackMaximum() {
    final int MAX_REQUESTS = 100;
    final int CALLBACKS = 90;
    final int INTENTS = 10;
    assertEquals(MAX_REQUESTS, CALLBACKS + INTENTS);
    NetworkRequest networkRequest = new NetworkRequest.Builder().build();
    ArrayList<Object> registered = new ArrayList<>();
    int j = 0;
    while (j++ < CALLBACKS / 2) {
        NetworkCallback cb = new NetworkCallback();
        mCm.requestNetwork(networkRequest, cb);
        registered.add(cb);
    }
    while (j++ < CALLBACKS) {
        NetworkCallback cb = new NetworkCallback();
        mCm.registerNetworkCallback(networkRequest, cb);
        registered.add(cb);
    }
    j = 0;
    while (j++ < INTENTS / 2) {
        PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, new Intent("a" + j), 0);
        mCm.requestNetwork(networkRequest, pi);
        registered.add(pi);
    }
    while (j++ < INTENTS) {
        PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, new Intent("b" + j), 0);
        mCm.registerNetworkCallback(networkRequest, pi);
        registered.add(pi);
    }
    // Test that the limit is enforced when MAX_REQUESTS simultaneous requests are added.
    try {
        mCm.requestNetwork(networkRequest, new NetworkCallback());
        fail("Registering " + MAX_REQUESTS + " NetworkRequests did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    try {
        mCm.registerNetworkCallback(networkRequest, new NetworkCallback());
        fail("Registering " + MAX_REQUESTS + " NetworkRequests did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    try {
        mCm.requestNetwork(networkRequest, PendingIntent.getBroadcast(mContext, 0, new Intent("c"), 0));
        fail("Registering " + MAX_REQUESTS + " NetworkRequests did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    try {
        mCm.registerNetworkCallback(networkRequest, PendingIntent.getBroadcast(mContext, 0, new Intent("d"), 0));
        fail("Registering " + MAX_REQUESTS + " NetworkRequests did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    for (Object o : registered) {
        if (o instanceof NetworkCallback) {
            mCm.unregisterNetworkCallback((NetworkCallback) o);
        }
        if (o instanceof PendingIntent) {
            mCm.unregisterNetworkCallback((PendingIntent) o);
        }
    }
    waitForIdle();
    // Test that the limit is not hit when MAX_REQUESTS requests are added and removed.
    for (int i = 0; i < MAX_REQUESTS; i++) {
        NetworkCallback networkCallback = new NetworkCallback();
        mCm.requestNetwork(networkRequest, networkCallback);
        mCm.unregisterNetworkCallback(networkCallback);
    }
    for (int i = 0; i < MAX_REQUESTS; i++) {
        NetworkCallback networkCallback = new NetworkCallback();
        mCm.registerNetworkCallback(networkRequest, networkCallback);
        mCm.unregisterNetworkCallback(networkCallback);
    }
    for (int i = 0; i < MAX_REQUESTS; i++) {
        PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("e" + i), 0);
        mCm.requestNetwork(networkRequest, pendingIntent);
        mCm.unregisterNetworkCallback(pendingIntent);
    }
    for (int i = 0; i < MAX_REQUESTS; i++) {
        PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("f" + i), 0);
        mCm.registerNetworkCallback(networkRequest, pendingIntent);
        mCm.unregisterNetworkCallback(pendingIntent);
    }
}
#method_after
@SmallTest
public void testNetworkCallbackMaximum() {
    final int MAX_REQUESTS = 100;
    final int CALLBACKS = 90;
    final int INTENTS = 10;
    assertEquals(MAX_REQUESTS, CALLBACKS + INTENTS);
    NetworkRequest networkRequest = new NetworkRequest.Builder().build();
    ArrayList<Object> registered = new ArrayList<>();
    int j = 0;
    while (j++ < CALLBACKS / 2) {
        NetworkCallback cb = new NetworkCallback();
        mCm.requestNetwork(networkRequest, cb);
        registered.add(cb);
    }
    while (j++ < CALLBACKS) {
        NetworkCallback cb = new NetworkCallback();
        mCm.registerNetworkCallback(networkRequest, cb);
        registered.add(cb);
    }
    j = 0;
    while (j++ < INTENTS / 2) {
        PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, new Intent("a" + j), 0);
        mCm.requestNetwork(networkRequest, pi);
        registered.add(pi);
    }
    while (j++ < INTENTS) {
        PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, new Intent("b" + j), 0);
        mCm.registerNetworkCallback(networkRequest, pi);
        registered.add(pi);
    }
    // Test that the limit is enforced when MAX_REQUESTS simultaneous requests are added.
    try {
        mCm.requestNetwork(networkRequest, new NetworkCallback());
        fail("Registering " + MAX_REQUESTS + " network requests did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    try {
        mCm.registerNetworkCallback(networkRequest, new NetworkCallback());
        fail("Registering " + MAX_REQUESTS + " network callbacks did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    try {
        mCm.requestNetwork(networkRequest, PendingIntent.getBroadcast(mContext, 0, new Intent("c"), 0));
        fail("Registering " + MAX_REQUESTS + " PendingIntent requests did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    try {
        mCm.registerNetworkCallback(networkRequest, PendingIntent.getBroadcast(mContext, 0, new Intent("d"), 0));
        fail("Registering " + MAX_REQUESTS + " PendingIntent callbacks did not throw exception");
    } catch (TooManyRequestsException expected) {
    }
    for (Object o : registered) {
        if (o instanceof NetworkCallback) {
            mCm.unregisterNetworkCallback((NetworkCallback) o);
        }
        if (o instanceof PendingIntent) {
            mCm.unregisterNetworkCallback((PendingIntent) o);
        }
    }
    waitForIdle();
    // Test that the limit is not hit when MAX_REQUESTS requests are added and removed.
    for (int i = 0; i < MAX_REQUESTS; i++) {
        NetworkCallback networkCallback = new NetworkCallback();
        mCm.requestNetwork(networkRequest, networkCallback);
        mCm.unregisterNetworkCallback(networkCallback);
    }
    for (int i = 0; i < MAX_REQUESTS; i++) {
        NetworkCallback networkCallback = new NetworkCallback();
        mCm.registerNetworkCallback(networkRequest, networkCallback);
        mCm.unregisterNetworkCallback(networkCallback);
    }
    for (int i = 0; i < MAX_REQUESTS; i++) {
        PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("e" + i), 0);
        mCm.requestNetwork(networkRequest, pendingIntent);
        mCm.unregisterNetworkCallback(pendingIntent);
    }
    for (int i = 0; i < MAX_REQUESTS; i++) {
        PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("f" + i), 0);
        mCm.registerNetworkCallback(networkRequest, pendingIntent);
        mCm.unregisterNetworkCallback(pendingIntent);
    }
}
#end_block

#method_before
private static String generateRootHash(String inputResource, byte[] salt) throws IOException {
    byte[] input = Resources.toByteArray(VerityTreeBuilderTest.class, inputResource);
    assertNotNull(input);
    VerityTreeBuilder builder = new VerityTreeBuilder(salt);
    return toHexString(builder.generateVerityTreeRootHash(DataSources.asDataSource(ByteBuffer.wrap(input))));
}
#method_after
private static String generateRootHash(String inputResource, byte[] salt) throws IOException {
    byte[] input = Resources.toByteArray(VerityTreeBuilderTest.class, inputResource);
    assertNotNull(input);
    try {
        VerityTreeBuilder builder = new VerityTreeBuilder(salt);
        return HexEncoding.encode(builder.generateVerityTreeRootHash(DataSources.asDataSource(ByteBuffer.wrap(input))));
    } catch (NoSuchAlgorithmException e) {
        fail(e.getMessage());
        return null;
    }
}
#end_block

#method_before
public byte[] generateVerityTreeRootHash(DataSource fileSource) throws IOException {
    if (fileSource.size() > Integer.MAX_VALUE) {
        throw new UnsupportedOperationException("Input file is bigger than Integer.MAX_VALUE");
    }
    try {
        int digestSize = MessageDigest.getInstance(JCA_ALGORITHM).getDigestLength();
        // Calculate the summed area table of level size. In other word, this is the offset
        // table of each level, plus the next non-existing level.
        int[] levelOffset = calculateLevelOffset((int) fileSource.size(), digestSize);
        ByteBuffer verityBuffer = ByteBuffer.allocate(levelOffset[levelOffset.length - 1]);
        // Generate the hash tree bottom-up.
        for (int i = levelOffset.length - 2; i >= 0; i--) {
            DataSource src;
            if (i == levelOffset.length - 2) {
                src = fileSource;
            } else {
                src = DataSources.asDataSource(slice(verityBuffer.asReadOnlyBuffer(), levelOffset[i + 1], levelOffset[i + 2]));
            }
            DataSink middleBufferSink = DataSinks.asDataSink(slice(verityBuffer, levelOffset[i], levelOffset[i + 1]));
            DigestSink chunkedDigestSink = new DigestSink(middleBufferSink, JCA_ALGORITHM, mSalt);
            feedDataByChunks(src, chunkedDigestSink);
            // If the output is not full chunk, pad with 0s.
            int incomplete = (int) (chunkedDigestSink.getTotalOutputBytes() % CHUNK_SIZE);
            if (incomplete > 0) {
                byte[] padding = new byte[CHUNK_SIZE - incomplete];
                middleBufferSink.consume(padding, 0, padding.length);
            }
        }
        // Finally, calculate the root hash from the top level (only page).
        ByteBuffer firstPage = slice(verityBuffer.asReadOnlyBuffer(), 0, CHUNK_SIZE);
        ByteArrayDataSink rootHashSink = new ByteArrayDataSink(digestSize);
        new DigestSink(rootHashSink, JCA_ALGORITHM, mSalt).consume(firstPage);
        if (rootHashSink.size() != digestSize) {
            throw new RuntimeException("Root hash digest size mismatch: " + rootHashSink.size() + " != " + digestSize);
        }
        return rootHashSink.getByteBuffer(0, digestSize).array();
    } catch (NoSuchAlgorithmException e) {
        throw new UnsupportedOperationException(JCA_ALGORITHM + " is not supported", e);
    }
}
#method_after
public byte[] generateVerityTreeRootHash(DataSource fileSource) throws IOException {
    int digestSize = mMd.getDigestLength();
    // Calculate the summed area table of level size. In other word, this is the offset
    // table of each level, plus the next non-existing level.
    int[] levelOffset = calculateLevelOffset(fileSource.size(), digestSize);
    ByteBuffer verityBuffer = ByteBuffer.allocate(levelOffset[levelOffset.length - 1]);
    // Generate the hash tree bottom-up.
    for (int i = levelOffset.length - 2; i >= 0; i--) {
        DataSource src;
        if (i == levelOffset.length - 2) {
            src = fileSource;
        } else {
            src = DataSources.asDataSource(slice(verityBuffer.asReadOnlyBuffer(), levelOffset[i + 1], levelOffset[i + 2]));
        }
        DataSink middleBufferSink = new ByteBufferSink(slice(verityBuffer, levelOffset[i], levelOffset[i + 1]));
        digestDataByChunks(src, middleBufferSink);
        // If the output is not full chunk, pad with 0s.
        long totalOutput = divideRoundup(src.size(), CHUNK_SIZE) * digestSize;
        int incomplete = (int) (totalOutput % CHUNK_SIZE);
        if (incomplete > 0) {
            byte[] padding = new byte[CHUNK_SIZE - incomplete];
            middleBufferSink.consume(padding, 0, padding.length);
        }
    }
    // Finally, calculate the root hash from the top level (only page).
    ByteBuffer firstPage = slice(verityBuffer.asReadOnlyBuffer(), 0, CHUNK_SIZE);
    return saltedDigest(firstPage);
}
#end_block

#method_before
private static int[] calculateLevelOffset(int dataSize, int digestSize) {
    // Compute total size of each level, bottom to top.
    ArrayList<Integer> levelSize = new ArrayList<Integer>();
    while (true) {
        int chunkNumber = divideRoundup(dataSize, CHUNK_SIZE);
        levelSize.add(CHUNK_SIZE * divideRoundup(chunkNumber * digestSize, CHUNK_SIZE));
        if (chunkNumber * digestSize <= CHUNK_SIZE) {
            break;
        }
        dataSize = chunkNumber * digestSize;
    }
    // Reverse and convert to summed area table.
    int[] levelOffset = new int[levelSize.size() + 1];
    levelOffset[0] = 0;
    for (int i = 0; i < levelSize.size(); i++) {
        levelOffset[i + 1] = levelOffset[i] + levelSize.get(levelSize.size() - i - 1);
    }
    return levelOffset;
}
#method_after
private static int[] calculateLevelOffset(long dataSize, int digestSize) {
    // Compute total size of each level, bottom to top.
    ArrayList<Long> levelSize = new ArrayList<>();
    while (true) {
        long chunkCount = divideRoundup(dataSize, CHUNK_SIZE);
        long size = CHUNK_SIZE * divideRoundup(chunkCount * digestSize, CHUNK_SIZE);
        levelSize.add(size);
        if (chunkCount * digestSize <= CHUNK_SIZE) {
            break;
        }
        dataSize = chunkCount * digestSize;
    }
    // Reverse and convert to summed area table.
    int[] levelOffset = new int[levelSize.size() + 1];
    levelOffset[0] = 0;
    for (int i = 0; i < levelSize.size(); i++) {
        // We don't support verity tree if it is larger then Integer.MAX_VALUE.
        levelOffset[i + 1] = levelOffset[i] + Math.toIntExact(levelSize.get(levelSize.size() - i - 1));
    }
    return levelOffset;
}
#end_block

#method_before
private static int divideRoundup(int dividend, int divisor) {
    return (dividend + divisor - 1) / divisor;
}
#method_after
private static long divideRoundup(long dividend, long divisor) {
    return (dividend + divisor - 1) / divisor;
}
#end_block

#method_before
private ByteBuffer slice(ByteBuffer buffer, int begin, int end) {
    ByteBuffer b = buffer.duplicate();
    b.limit(end);
    b.position(begin);
    return b.slice();
}
#method_after
private static ByteBuffer slice(ByteBuffer buffer, int begin, int end) {
    ByteBuffer b = buffer.duplicate();
    // to ensure position <= limit invariant.
    b.position(0);
    b.limit(end);
    b.position(begin);
    return b.slice();
}
#end_block

#method_before
@Override
public void setUp() {
    resetLatch();
    mLocalSocket = null;
    mLocalSockName = null;
    mLastRecvBuf = null;
    mExited = false;
    mReceiver = new BlockingSocketReader() {

        @Override
        protected FileDescriptor createSocket() {
            FileDescriptor s = null;
            try {
                s = Os.socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
                Os.bind(s, LOOPBACK6, 0);
                mLocalSockName = (InetSocketAddress) Os.getsockname(s);
                Os.setsockoptTimeval(s, SOL_SOCKET, SO_SNDTIMEO, TIMEO);
            } catch (ErrnoException | SocketException e) {
                closeSocket(s);
                fail();
                return null;
            }
            mLocalSocket = s;
            return s;
        }

        @Override
        protected void handlePacket(byte[] recvbuf, int length) {
            mLastRecvBuf = Arrays.copyOf(recvbuf, length);
            mLatch.countDown();
        }

        @Override
        protected void onExit() {
            mExited = true;
            mLatch.countDown();
        }
    };
}
#method_after
@Override
public void setUp() {
    resetLatch();
    mLocalSocket = null;
    mLocalSockName = null;
    mLastRecvBuf = null;
    mStopped = false;
    mHandlerThread = new HandlerThread(BlockingSocketReaderTest.class.getSimpleName());
    mHandlerThread.start();
}
#end_block

#method_before
@Override
public void tearDown() {
    if (mReceiver != null)
        mReceiver.stop();
    mReceiver = null;
}
#method_after
@Override
public void tearDown() throws Exception {
    if (mReceiver != null) {
        mHandlerThread.getThreadHandler().post(() -> {
            mReceiver.stop();
        });
        waitForActivity();
    }
    mReceiver = null;
    mHandlerThread.quit();
    mHandlerThread = null;
}
#end_block

#method_before
void waitForActivity() throws Exception {
    assertTrue(mLatch.await(1000, TimeUnit.MILLISECONDS));
    resetLatch();
}
#method_after
void waitForActivity() throws Exception {
    try {
        mLatch.await(1000, TimeUnit.MILLISECONDS);
    } finally {
        resetLatch();
    }
}
#end_block

#method_before
public void testBasicWorking() throws Exception {
    assertTrue(mReceiver.start());
    assertTrue(mLocalSockName != null);
    assertEquals(LOOPBACK6, mLocalSockName.getAddress());
    assertTrue(0 < mLocalSockName.getPort());
    assertTrue(mLocalSocket != null);
    assertFalse(mExited);
    final byte[] one = "one 1".getBytes("UTF-8");
    sendPacket(one);
    waitForActivity();
    assertEquals(1, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(one, mLastRecvBuf));
    assertFalse(mExited);
    final byte[] two = "two 2".getBytes("UTF-8");
    sendPacket(two);
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertFalse(mExited);
    mReceiver.stop();
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertTrue(mExited);
}
#method_after
public void testBasicWorking() throws Exception {
    final Handler h = mHandlerThread.getThreadHandler();
    mReceiver = new UdpLoopbackReader(h);
    h.post(() -> {
        mReceiver.start();
    });
    waitForActivity();
    assertTrue(mLocalSockName != null);
    assertEquals(LOOPBACK6, mLocalSockName.getAddress());
    assertTrue(0 < mLocalSockName.getPort());
    assertTrue(mLocalSocket != null);
    assertFalse(mStopped);
    final byte[] one = "one 1".getBytes("UTF-8");
    sendPacket(one);
    waitForActivity();
    assertEquals(1, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(one, mLastRecvBuf));
    assertFalse(mStopped);
    final byte[] two = "two 2".getBytes("UTF-8");
    sendPacket(two);
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertFalse(mStopped);
    mReceiver.stop();
    waitForActivity();
    assertEquals(2, mReceiver.numPacketsReceived());
    assertTrue(Arrays.equals(two, mLastRecvBuf));
    assertTrue(mStopped);
    mReceiver = null;
}
#end_block

#method_before
public final boolean start() {
    if (mSocket != null)
        return false;
    try {
        mSocket = createSocket();
    } catch (Exception e) {
        logError("Failed to create socket: ", e);
        return false;
    }
    if (mSocket == null)
        return false;
    mThread.start();
    mLooper = mThread.getLooper();
    mHandler = mThread.getThreadHandler();
    mHandler.post(() -> {
        setupListeningSocket();
    });
    mRunning = true;
    return true;
}
#method_after
public final void start() {
    if (onCorrectThread()) {
        createAndRegisterFd();
    } else {
        mHandler.post(() -> {
            logError("start() called from off-thread", null);
            createAndRegisterFd();
        });
    }
}
#end_block

#method_before
public final void stop() {
    mRunning = false;
    if (mHandler != null) {
        mHandler.post(() -> {
            if (mSocket != null) {
                mLooper.getQueue().removeOnFileDescriptorEventListener(mSocket);
                closeSocket(mSocket);
            }
            mSocket = null;
            onExit();
            mLooper.quitSafely();
            mLooper = null;
        });
        mHandler = null;
    }
}
#method_after
public final void stop() {
    if (onCorrectThread()) {
        unregisterAndDestroyFd();
    } else {
        mHandler.post(() -> {
            logError("stop() called from off-thread", null);
            unregisterAndDestroyFd();
        });
    }
}
#end_block

#method_before
public final boolean isRunning() {
    return mRunning;
}
#method_after
private boolean isRunning() {
    return (mFd != null) && mFd.valid();
}
#end_block

#method_before
private boolean handleInput() {
    while (isRunning()) {
        final int bytesRead;
        try {
            // Nonblocking read.
            IoUtils.setBlocking(mSocket, false);
            // TODO: See if this can be converted to recvfrom.
            bytesRead = Os.read(mSocket, mPacket, 0, mPacket.length);
            if (bytesRead < 1) {
                if (isRunning())
                    logError("Socket closed, exiting", null);
                break;
            }
            mPacketsReceived++;
        } catch (ErrnoException e) {
            if (e.errno == OsConstants.EAGAIN) {
                // We've read everything there is to read this time around.
                return true;
            }
            if (e.errno != OsConstants.EINTR) {
                if (isRunning())
                    logError("read error: ", e);
                break;
            }
            continue;
        } catch (IOException ioe) {
            if (isRunning())
                logError("read error: ", ioe);
            continue;
        }
        try {
            handlePacket(mPacket, bytesRead);
        } catch (Exception e) {
            logError("Unexpected exception: ", e);
            break;
        }
    }
    return false;
}
#method_after
private boolean handleInput() {
    while (isRunning()) {
        final int bytesRead;
        try {
            bytesRead = readPacket(mFd, mPacket);
            if (bytesRead < 1) {
                if (isRunning())
                    logError("Socket closed, exiting", null);
                break;
            }
            mPacketsReceived++;
        } catch (ErrnoException e) {
            if (e.errno == OsConstants.EAGAIN) {
                // We've read everything there is to read this time around.
                return true;
            } else if (e.errno == OsConstants.EINTR) {
                continue;
            } else {
                if (isRunning())
                    logError("readPacket error: ", e);
                break;
            }
        } catch (Exception e) {
            if (isRunning())
                logError("readPacket error: ", e);
            break;
        }
        try {
            handlePacket(mPacket, bytesRead);
        } catch (Exception e) {
            logError("handlePacket error: ", e);
            break;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void getAuthToken(IAccountManagerResponse response, final Account account, final String authTokenType, final boolean notifyOnAuthFailure, final boolean expectActivityLaunch, final Bundle loginOptions) {
    Bundle.setDefusable(loginOptions, true);
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "getAuthToken: " + account + ", response " + response + ", authTokenType " + authTokenType + ", notifyOnAuthFailure " + notifyOnAuthFailure + ", expectActivityLaunch " + expectActivityLaunch + ", caller's uid " + Binder.getCallingUid() + ", pid " + Binder.getCallingPid());
    }
    Preconditions.checkArgument(response != null, "response cannot be null");
    try {
        if (account == null) {
            Slog.w(TAG, "getAuthToken called with null account");
            response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, "account is null");
            return;
        }
        if (authTokenType == null) {
            Slog.w(TAG, "getAuthToken called with null authTokenType");
            response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, "authTokenType is null");
            return;
        }
    } catch (RemoteException e) {
        Slog.w(TAG, "Failed to report error back to the client." + e);
        return;
    }
    int userId = UserHandle.getCallingUserId();
    long ident = Binder.clearCallingIdentity();
    final UserAccounts accounts;
    final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;
    try {
        accounts = getUserAccounts(userId);
        authenticatorInfo = mAuthenticatorCache.getServiceInfo(AuthenticatorDescription.newKey(account.type), accounts.userId);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    final boolean customTokens = authenticatorInfo != null && authenticatorInfo.type.customTokens;
    // skip the check if customTokens
    final int callerUid = Binder.getCallingUid();
    final boolean permissionGranted = customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);
    // Get the calling package. We will use it for the purpose of caching.
    final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);
    List<String> callerOwnedPackageNames;
    ident = Binder.clearCallingIdentity();
    try {
        callerOwnedPackageNames = Arrays.asList(mPackageManager.getPackagesForUid(callerUid));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    if (callerPkg == null || !callerOwnedPackageNames.contains(callerPkg)) {
        String msg = String.format("Uid %s is attempting to illegally masquerade as package %s!", callerUid, callerPkg);
        throw new SecurityException(msg);
    }
    // let authenticator know the identity of the caller
    loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);
    loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());
    if (notifyOnAuthFailure) {
        loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);
    }
    long identityToken = clearCallingIdentity();
    try {
        // Distill the caller's package signatures into a single digest.
        final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);
        // route of starting a Session
        if (!customTokens && permissionGranted) {
            String authToken = readAuthTokenInternal(accounts, account, authTokenType);
            if (authToken != null) {
                Bundle result = new Bundle();
                result.putString(AccountManager.KEY_AUTHTOKEN, authToken);
                result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
                result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
                onResult(response, result);
                return;
            }
        }
        if (customTokens) {
            /*
                 * Look up tokens in the new cache only if the loginOptions don't have parameters
                 * outside of those expected to be injected by the AccountManager, e.g.
                 * ANDORID_PACKAGE_NAME.
                 */
            String token = readCachedTokenInternal(accounts, account, authTokenType, callerPkg, callerPkgSigDigest);
            if (token != null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "getAuthToken: cache hit ofr custom token authenticator.");
                }
                Bundle result = new Bundle();
                result.putString(AccountManager.KEY_AUTHTOKEN, token);
                result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
                result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
                onResult(response, result);
                return;
            }
        }
        new Session(accounts, response, account.type, expectActivityLaunch, false, /* stripAuthTokenFromResult */
        account.name, false) {

            /* authDetailsRequired */
            @Override
            protected String toDebugString(long now) {
                if (loginOptions != null)
                    loginOptions.keySet();
                return super.toDebugString(now) + ", getAuthToken" + ", " + account + ", authTokenType " + authTokenType + ", loginOptions " + loginOptions + ", notifyOnAuthFailure " + notifyOnAuthFailure;
            }

            @Override
            public void run() throws RemoteException {
                // "grant permission" intent instead of the "getAuthToken" intent.
                if (!permissionGranted) {
                    mAuthenticator.getAuthTokenLabel(this, authTokenType);
                } else {
                    mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);
                }
            }

            @Override
            public void onResult(Bundle result) {
                Bundle.setDefusable(result, true);
                if (result != null) {
                    if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {
                        Intent intent = newGrantCredentialsPermissionIntent(account, null, callerUid, new AccountAuthenticatorResponse(this), authTokenType, true);
                        Bundle bundle = new Bundle();
                        bundle.putParcelable(AccountManager.KEY_INTENT, intent);
                        onResult(bundle);
                        return;
                    }
                    String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);
                    if (authToken != null) {
                        String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);
                        String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
                        if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {
                            onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "the type and name should not be empty");
                            return;
                        }
                        Account resultAccount = new Account(name, type);
                        if (!customTokens) {
                            saveAuthTokenToDatabase(mAccounts, resultAccount, authTokenType, authToken);
                        }
                        long expiryMillis = result.getLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);
                        if (customTokens && expiryMillis > System.currentTimeMillis()) {
                            saveCachedToken(mAccounts, account, callerPkg, callerPkgSigDigest, authTokenType, authToken, expiryMillis);
                        }
                    }
                    Intent intent = result.getParcelable(AccountManager.KEY_INTENT);
                    if (intent != null && notifyOnAuthFailure && !customTokens) {
                        /*
                             * Make sure that the supplied intent is owned by the authenticator
                             * giving it to the system. Otherwise a malicious authenticator could
                             * have users launching arbitrary activities by tricking users to
                             * interact with malicious notifications.
                             */
                        if (!checkKeyIntent(Binder.getCallingUid(), intent)) {
                            onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "invalid intent in bundle returned");
                        }
                        doNotification(mAccounts, account, result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE), intent, "android", accounts.userId);
                    }
                }
                super.onResult(result);
            }
        }.bind();
    } finally {
        restoreCallingIdentity(identityToken);
    }
}
#method_after
@Override
public void getAuthToken(IAccountManagerResponse response, final Account account, final String authTokenType, final boolean notifyOnAuthFailure, final boolean expectActivityLaunch, final Bundle loginOptions) {
    Bundle.setDefusable(loginOptions, true);
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "getAuthToken: " + account + ", response " + response + ", authTokenType " + authTokenType + ", notifyOnAuthFailure " + notifyOnAuthFailure + ", expectActivityLaunch " + expectActivityLaunch + ", caller's uid " + Binder.getCallingUid() + ", pid " + Binder.getCallingPid());
    }
    Preconditions.checkArgument(response != null, "response cannot be null");
    try {
        if (account == null) {
            Slog.w(TAG, "getAuthToken called with null account");
            response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, "account is null");
            return;
        }
        if (authTokenType == null) {
            Slog.w(TAG, "getAuthToken called with null authTokenType");
            response.onError(AccountManager.ERROR_CODE_BAD_ARGUMENTS, "authTokenType is null");
            return;
        }
    } catch (RemoteException e) {
        Slog.w(TAG, "Failed to report error back to the client." + e);
        return;
    }
    int userId = UserHandle.getCallingUserId();
    long ident = Binder.clearCallingIdentity();
    final UserAccounts accounts;
    final RegisteredServicesCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;
    try {
        accounts = getUserAccounts(userId);
        authenticatorInfo = mAuthenticatorCache.getServiceInfo(AuthenticatorDescription.newKey(account.type), accounts.userId);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    final boolean customTokens = authenticatorInfo != null && authenticatorInfo.type.customTokens;
    // skip the check if customTokens
    final int callerUid = Binder.getCallingUid();
    final boolean permissionGranted = customTokens || permissionIsGranted(account, authTokenType, callerUid, userId);
    // Get the calling package. We will use it for the purpose of caching.
    final String callerPkg = loginOptions.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);
    List<String> callerOwnedPackageNames;
    ident = Binder.clearCallingIdentity();
    try {
        callerOwnedPackageNames = Arrays.asList(mPackageManager.getPackagesForUid(callerUid));
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    if (callerPkg == null || !callerOwnedPackageNames.contains(callerPkg)) {
        String msg = String.format("Uid %s is attempting to illegally masquerade as package %s!", callerUid, callerPkg);
        throw new SecurityException(msg);
    }
    // let authenticator know the identity of the caller
    loginOptions.putInt(AccountManager.KEY_CALLER_UID, callerUid);
    loginOptions.putInt(AccountManager.KEY_CALLER_PID, Binder.getCallingPid());
    if (notifyOnAuthFailure) {
        loginOptions.putBoolean(AccountManager.KEY_NOTIFY_ON_FAILURE, true);
    }
    long identityToken = clearCallingIdentity();
    try {
        // Distill the caller's package signatures into a single digest.
        final byte[] callerPkgSigDigest = calculatePackageSignatureDigest(callerPkg);
        // route of starting a Session
        if (!customTokens && permissionGranted) {
            String authToken = readAuthTokenInternal(accounts, account, authTokenType);
            if (authToken != null) {
                Bundle result = new Bundle();
                result.putString(AccountManager.KEY_AUTHTOKEN, authToken);
                result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
                result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
                onResult(response, result);
                return;
            }
        }
        if (customTokens) {
            /*
                 * Look up tokens in the new cache only if the loginOptions don't have parameters
                 * outside of those expected to be injected by the AccountManager, e.g.
                 * ANDORID_PACKAGE_NAME.
                 */
            String token = readCachedTokenInternal(accounts, account, authTokenType, callerPkg, callerPkgSigDigest);
            if (token != null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "getAuthToken: cache hit ofr custom token authenticator.");
                }
                Bundle result = new Bundle();
                result.putString(AccountManager.KEY_AUTHTOKEN, token);
                result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
                result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
                onResult(response, result);
                return;
            }
        }
        new Session(accounts, response, account.type, expectActivityLaunch, false, /* stripAuthTokenFromResult */
        account.name, false) {

            /* authDetailsRequired */
            @Override
            protected String toDebugString(long now) {
                if (loginOptions != null)
                    loginOptions.keySet();
                return super.toDebugString(now) + ", getAuthToken" + ", " + account + ", authTokenType " + authTokenType + ", loginOptions " + loginOptions + ", notifyOnAuthFailure " + notifyOnAuthFailure;
            }

            @Override
            public void run() throws RemoteException {
                // "grant permission" intent instead of the "getAuthToken" intent.
                if (!permissionGranted) {
                    mAuthenticator.getAuthTokenLabel(this, authTokenType);
                } else {
                    mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions);
                }
            }

            @Override
            public void onResult(Bundle result) {
                Bundle.setDefusable(result, true);
                if (result != null) {
                    if (result.containsKey(AccountManager.KEY_AUTH_TOKEN_LABEL)) {
                        Intent intent = newGrantCredentialsPermissionIntent(account, null, callerUid, new AccountAuthenticatorResponse(this), authTokenType, true);
                        Bundle bundle = new Bundle();
                        bundle.putParcelable(AccountManager.KEY_INTENT, intent);
                        onResult(bundle);
                        return;
                    }
                    String authToken = result.getString(AccountManager.KEY_AUTHTOKEN);
                    if (authToken != null) {
                        String name = result.getString(AccountManager.KEY_ACCOUNT_NAME);
                        String type = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
                        if (TextUtils.isEmpty(type) || TextUtils.isEmpty(name)) {
                            onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "the type and name should not be empty");
                            return;
                        }
                        Account resultAccount = new Account(name, type);
                        if (!customTokens) {
                            saveAuthTokenToDatabase(mAccounts, resultAccount, authTokenType, authToken);
                        }
                        long expiryMillis = result.getLong(AbstractAccountAuthenticator.KEY_CUSTOM_TOKEN_EXPIRY, 0L);
                        if (customTokens && expiryMillis > System.currentTimeMillis()) {
                            saveCachedToken(mAccounts, account, callerPkg, callerPkgSigDigest, authTokenType, authToken, expiryMillis);
                        }
                    }
                    Intent intent = result.getParcelable(AccountManager.KEY_INTENT);
                    if (intent != null && notifyOnAuthFailure && !customTokens) {
                        /*
                             * Make sure that the supplied intent is owned by the authenticator
                             * giving it to the system. Otherwise a malicious authenticator could
                             * have users launching arbitrary activities by tricking users to
                             * interact with malicious notifications.
                             */
                        if (!checkKeyIntent(Binder.getCallingUid(), intent)) {
                            onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "invalid intent in bundle returned");
                            return;
                        }
                        doNotification(mAccounts, account, result.getString(AccountManager.KEY_AUTH_FAILED_MESSAGE), intent, "android", accounts.userId);
                    }
                }
                super.onResult(result);
            }
        }.bind();
    } finally {
        restoreCallingIdentity(identityToken);
    }
}
#end_block

#method_before
@Override
public void onResult(Bundle result) {
    Bundle.setDefusable(result, true);
    mNumResults++;
    Intent intent = null;
    boolean isValidIntent = false;
    if (result != null && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
        isValidIntent = checkKeyIntent(Binder.getCallingUid(), intent);
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response == null) {
        return;
    }
    if (result == null) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, getClass().getSimpleName() + " calling onError() on response " + response);
        }
        sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE, "null bundle returned");
        return;
    }
    if (!isValidIntent) {
        sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE, "invalid intent in bundle returned");
    }
    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {
        // All AccountManager error codes are greater
        // than 0
        sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE), result.getString(AccountManager.KEY_ERROR_MESSAGE));
        return;
    }
    // Omit passwords if the caller isn't permitted to see them.
    if (!mIsPasswordForwardingAllowed) {
        result.remove(AccountManager.KEY_PASSWORD);
    }
    // Strip auth token from result.
    result.remove(AccountManager.KEY_AUTHTOKEN);
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
    }
    // Get the session bundle created by authenticator. The
    // bundle contains data necessary for finishing the session
    // later. The session bundle will be encrypted here and
    // decrypted later when trying to finish the session.
    Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);
    if (sessionBundle != null) {
        String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (TextUtils.isEmpty(accountType) || !mAccountType.equalsIgnoreCase(accountType)) {
            Log.w(TAG, "Account type in session bundle doesn't match request.");
        }
        // Add accountType info to session bundle. This will
        // override any value set by authenticator.
        sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);
        // Encrypt session bundle before returning to caller.
        try {
            CryptoHelper cryptoHelper = CryptoHelper.getInstance();
            Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);
            result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);
        } catch (GeneralSecurityException e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.v(TAG, "Failed to encrypt session bundle!", e);
            }
            sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE, "failed to encrypt session bundle");
            return;
        }
    }
    sendResponse(response, result);
}
#method_after
@Override
public void onResult(Bundle result) {
    Bundle.setDefusable(result, true);
    mNumResults++;
    Intent intent = null;
    if (result != null && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
        if (!checkKeyIntent(Binder.getCallingUid(), intent)) {
            onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "invalid intent in bundle returned");
            return;
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response == null) {
        return;
    }
    if (result == null) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, getClass().getSimpleName() + " calling onError() on response " + response);
        }
        sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE, "null bundle returned");
        return;
    }
    if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {
        // All AccountManager error codes are greater
        // than 0
        sendErrorResponse(response, result.getInt(AccountManager.KEY_ERROR_CODE), result.getString(AccountManager.KEY_ERROR_MESSAGE));
        return;
    }
    // Omit passwords if the caller isn't permitted to see them.
    if (!mIsPasswordForwardingAllowed) {
        result.remove(AccountManager.KEY_PASSWORD);
    }
    // Strip auth token from result.
    result.remove(AccountManager.KEY_AUTHTOKEN);
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
    }
    // Get the session bundle created by authenticator. The
    // bundle contains data necessary for finishing the session
    // later. The session bundle will be encrypted here and
    // decrypted later when trying to finish the session.
    Bundle sessionBundle = result.getBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE);
    if (sessionBundle != null) {
        String accountType = sessionBundle.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (TextUtils.isEmpty(accountType) || !mAccountType.equalsIgnoreCase(accountType)) {
            Log.w(TAG, "Account type in session bundle doesn't match request.");
        }
        // Add accountType info to session bundle. This will
        // override any value set by authenticator.
        sessionBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, mAccountType);
        // Encrypt session bundle before returning to caller.
        try {
            CryptoHelper cryptoHelper = CryptoHelper.getInstance();
            Bundle encryptedBundle = cryptoHelper.encryptBundle(sessionBundle);
            result.putBundle(AccountManager.KEY_ACCOUNT_SESSION_BUNDLE, encryptedBundle);
        } catch (GeneralSecurityException e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.v(TAG, "Failed to encrypt session bundle!", e);
            }
            sendErrorResponse(response, AccountManager.ERROR_CODE_INVALID_RESPONSE, "failed to encrypt session bundle");
            return;
        }
    }
    sendResponse(response, result);
}
#end_block

#method_before
protected boolean checkKeyIntent(int authUid, Intent intent) throws SecurityException {
    long bid = Binder.clearCallingIdentity();
    try {
        PackageManager pm = mContext.getPackageManager();
        ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);
        if (resolveInfo == null) {
            return false;
        }
        ActivityInfo targetActivityInfo = resolveInfo.activityInfo;
        int targetUid = targetActivityInfo.applicationInfo.uid;
        if (!isExportedSystemActivity(targetActivityInfo) && (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authUid, targetUid))) {
            String pkgName = targetActivityInfo.packageName;
            String activityName = targetActivityInfo.name;
            String tmpl = "KEY_INTENT resolved to an Activity (%s) in a package (%s) that " + "does not share a signature with the supplying authenticator (%s).";
            throw new SecurityException(String.format(tmpl, activityName, pkgName, mAccountType));
        }
        return true;
    } catch (SecurityException se) {
        return false;
    } finally {
        Binder.restoreCallingIdentity(bid);
    }
}
#method_after
protected boolean checkKeyIntent(int authUid, Intent intent) {
    long bid = Binder.clearCallingIdentity();
    try {
        PackageManager pm = mContext.getPackageManager();
        ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);
        if (resolveInfo == null) {
            return false;
        }
        ActivityInfo targetActivityInfo = resolveInfo.activityInfo;
        int targetUid = targetActivityInfo.applicationInfo.uid;
        if (!isExportedSystemActivity(targetActivityInfo) && (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authUid, targetUid))) {
            String pkgName = targetActivityInfo.packageName;
            String activityName = targetActivityInfo.name;
            String tmpl = "KEY_INTENT resolved to an Activity (%s) in a package (%s) that " + "does not share a signature with the supplying authenticator (%s).";
            Log.e(TAG, String.format(tmpl, activityName, pkgName, mAccountType));
            return false;
        }
        return true;
    } finally {
        Binder.restoreCallingIdentity(bid);
    }
}
#end_block

#method_before
@Override
public void onResult(Bundle result) {
    Bundle.setDefusable(result, true);
    mNumResults++;
    Intent intent = null;
    boolean isValidIntent = false;
    if (result != null) {
        boolean isSuccessfulConfirmCreds = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
        boolean isSuccessfulUpdateCredsOrAddAccount = result.containsKey(AccountManager.KEY_ACCOUNT_NAME) && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);
        // We should only update lastAuthenticated time, if
        // mUpdateLastAuthenticatedTime is true and the confirmRequest
        // or updateRequest was successful
        boolean needUpdate = mUpdateLastAuthenticatedTime && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);
        if (needUpdate || mAuthDetailsRequired) {
            boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);
            if (needUpdate && accountPresent) {
                updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));
            }
            if (mAuthDetailsRequired) {
                long lastAuthenticatedTime = -1;
                if (accountPresent) {
                    lastAuthenticatedTime = mAccounts.accountsDb.findAccountLastAuthenticatedTime(new Account(mAccountName, mAccountType));
                }
                result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME, lastAuthenticatedTime);
            }
        }
    }
    if (result != null && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
        isValidIntent = checkKeyIntent(Binder.getCallingUid(), intent);
    }
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(mAccounts, account), new UserHandle(mAccounts.userId));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + " calling onError() on response " + response);
                }
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "null bundle returned");
            } else {
                if (!isValidIntent) {
                    response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "invalid intent in bundle returned");
                }
                if (mStripAuthTokenFromResult) {
                    result.remove(AccountManager.KEY_AUTHTOKEN);
                }
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
                }
                if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {
                    // All AccountManager error codes are greater than 0
                    response.onError(result.getInt(AccountManager.KEY_ERROR_CODE), result.getString(AccountManager.KEY_ERROR_MESSAGE));
                } else {
                    response.onResult(result);
                }
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, "failure while notifying response", e);
            }
        }
    }
}
#method_after
@Override
public void onResult(Bundle result) {
    Bundle.setDefusable(result, true);
    mNumResults++;
    Intent intent = null;
    if (result != null) {
        boolean isSuccessfulConfirmCreds = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
        boolean isSuccessfulUpdateCredsOrAddAccount = result.containsKey(AccountManager.KEY_ACCOUNT_NAME) && result.containsKey(AccountManager.KEY_ACCOUNT_TYPE);
        // We should only update lastAuthenticated time, if
        // mUpdateLastAuthenticatedTime is true and the confirmRequest
        // or updateRequest was successful
        boolean needUpdate = mUpdateLastAuthenticatedTime && (isSuccessfulConfirmCreds || isSuccessfulUpdateCredsOrAddAccount);
        if (needUpdate || mAuthDetailsRequired) {
            boolean accountPresent = isAccountPresentForCaller(mAccountName, mAccountType);
            if (needUpdate && accountPresent) {
                updateLastAuthenticatedTime(new Account(mAccountName, mAccountType));
            }
            if (mAuthDetailsRequired) {
                long lastAuthenticatedTime = -1;
                if (accountPresent) {
                    lastAuthenticatedTime = mAccounts.accountsDb.findAccountLastAuthenticatedTime(new Account(mAccountName, mAccountType));
                }
                result.putLong(AccountManager.KEY_LAST_AUTHENTICATED_TIME, lastAuthenticatedTime);
            }
        }
    }
    if (result != null && (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {
        if (!checkKeyIntent(Binder.getCallingUid(), intent)) {
            onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "invalid intent in bundle returned");
            return;
        }
    }
    if (result != null && !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {
        String accountName = result.getString(AccountManager.KEY_ACCOUNT_NAME);
        String accountType = result.getString(AccountManager.KEY_ACCOUNT_TYPE);
        if (!TextUtils.isEmpty(accountName) && !TextUtils.isEmpty(accountType)) {
            Account account = new Account(accountName, accountType);
            cancelNotification(getSigninRequiredNotificationId(mAccounts, account), new UserHandle(mAccounts.userId));
        }
    }
    IAccountManagerResponse response;
    if (mExpectActivityLaunch && result != null && result.containsKey(AccountManager.KEY_INTENT)) {
        response = mResponse;
    } else {
        response = getResponseAndClose();
    }
    if (response != null) {
        try {
            if (result == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + " calling onError() on response " + response);
                }
                response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "null bundle returned");
            } else {
                if (mStripAuthTokenFromResult) {
                    result.remove(AccountManager.KEY_AUTHTOKEN);
                }
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, getClass().getSimpleName() + " calling onResult() on response " + response);
                }
                if ((result.getInt(AccountManager.KEY_ERROR_CODE, -1) > 0) && (intent == null)) {
                    // All AccountManager error codes are greater than 0
                    response.onError(result.getInt(AccountManager.KEY_ERROR_CODE), result.getString(AccountManager.KEY_ERROR_MESSAGE));
                } else {
                    response.onResult(result);
                }
            }
        } catch (RemoteException e) {
            // if the caller is dead then there is no one to care about remote exceptions
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, "failure while notifying response", e);
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean hasService(String name) {
    return Context.ETHERNET_SERVICE.equals(name);
}
#method_after
@Override
public boolean hasService(String name) {
    // ETHERNET_SERVICE.
    return Context.ETHERNET_SERVICE.equals(name);
}
#end_block

#method_before
public void testNetworkTypes() {
    // Ensure that our mocks for the networkAttributes config variable work as expected. If they
    // don't, then tests that depend on CONNECTIVITY_ACTION broadcasts for these network types
    // will fail. Failing here is much easier to debug.
    assertTrue(mCm.isNetworkSupported(TYPE_WIFI));
    assertTrue(mCm.isNetworkSupported(TYPE_MOBILE));
    assertTrue(mCm.isNetworkSupported(TYPE_ETHERNET));
}
#method_after
public void testNetworkTypes() {
    // Ensure that our mocks for the networkAttributes config variable work as expected. If they
    // don't, then tests that depend on CONNECTIVITY_ACTION broadcasts for these network types
    // will fail. Failing here is much easier to debug.
    assertTrue(mCm.isNetworkSupported(TYPE_WIFI));
    assertTrue(mCm.isNetworkSupported(TYPE_MOBILE));
    assertTrue(mCm.isNetworkSupported(TYPE_MOBILE_MMS));
    assertFalse(mCm.isNetworkSupported(TYPE_MOBILE_FOTA));
    // Check that TYPE_ETHERNET is supported. Unlike the asserts above, which only validate our
    // mocks, this assert exercises the ConnectivityService code path that ensures that
    // TYPE_ETHERNET is supported if the ethernet service is running.
    assertTrue(mCm.isNetworkSupported(TYPE_ETHERNET));
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (argsContain(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (argsContain(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (argsContain(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (argsContain(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (argsContain(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (argsContain(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                if (VDBG) {
                    log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
                }
                LinkProperties oldLp = nai.linkProperties;
                synchronized (nai) {
                    nai.linkProperties = (LinkProperties) msg.obj;
                }
                if (nai.everConnected)
                    updateLinkProperties(nai, oldLp);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score.intValue());
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_ADDED:
            {
                try {
                    mNetd.addVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in addVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_REMOVED:
            {
                try {
                    mNetd.removeVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in removeVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#method_after
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score.intValue());
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_ADDED:
            {
                try {
                    mNetd.addVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in addVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_REMOVED:
            {
                try {
                    mNetd.removeVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in removeVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#end_block

#method_before
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (nri.request.isListen())
                    continue;
                NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, (nai != null ? nai.getCurrentScore() : 0), 0, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#method_after
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (nri.request.isListen())
                    continue;
                NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, (nai != null ? nai.getCurrentScore() : 0), 0, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#end_block

#method_before
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            logDefaultNetworkEvent(null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        for (String iface : nai.linkProperties.getAllInterfaceNames()) {
            // Disable wakeup packet monitoring for each interface.
            wakeupModifyInterface(iface, nai.networkCapabilities, false);
        }
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        updateClat(null, nai.linkProperties, nai);
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                mNetworkForRequestId.remove(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            ensureNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#method_after
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            logDefaultNetworkEvent(null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        for (String iface : nai.linkProperties.getAllInterfaceNames()) {
            // Disable wakeup packet monitoring for each interface.
            wakeupModifyInterface(iface, nai.networkCapabilities, false);
        }
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        nai.maybeStopClat();
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                clearNetworkForRequest(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            ensureNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#end_block

#method_before
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (nri.request.isListen()) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.request.isRequest() && mNetworkForRequestId.get(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, 0);
    }
}
#method_after
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (nri.request.isListen()) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.request.isRequest() && getNetworkForRequest(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, 0);
    }
}
#end_block

#method_before
// Determines whether the network is the best (or could become the best, if it validated), for
// none of a particular type of NetworkRequests. The type of NetworkRequests considered depends
// on the value of reason:
// 
// - UnneededFor.TEARDOWN: non-listen NetworkRequests. If a network is unneeded for this reason,
// then it should be torn down.
// - UnneededFor.LINGER: foreground NetworkRequests. If a network is unneeded for this reason,
private boolean unneeded(NetworkAgentInfo nai, UnneededFor reason) {
    final int numRequests;
    switch(reason) {
        case TEARDOWN:
            numRequests = nai.numRequestNetworkRequests();
            break;
        case LINGER:
            numRequests = nai.numForegroundNetworkRequests();
            break;
        default:
            Slog.wtf(TAG, "Invalid reason. Cannot happen.");
            return true;
    }
    if (!nai.everConnected || nai.isVPN() || nai.isLingering() || numRequests > 0) {
        return false;
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        if (reason == UnneededFor.LINGER && nri.request.isBackgroundRequest()) {
            // Background requests don't affect lingering.
            continue;
        }
        // there is hope for it to become one if it validated, then it is needed.
        if (nri.request.isRequest() && nai.satisfies(nri.request) && (nai.isSatisfyingRequest(nri.request.requestId) || // WiFi ends up validating and out scoring cellular.
        mNetworkForRequestId.get(nri.request.requestId).getCurrentScore() < nai.getCurrentScoreAsValidated())) {
            return false;
        }
    }
    return true;
}
#method_after
// Determines whether the network is the best (or could become the best, if it validated), for
// none of a particular type of NetworkRequests. The type of NetworkRequests considered depends
// on the value of reason:
// 
// - UnneededFor.TEARDOWN: non-listen NetworkRequests. If a network is unneeded for this reason,
// then it should be torn down.
// - UnneededFor.LINGER: foreground NetworkRequests. If a network is unneeded for this reason,
private boolean unneeded(NetworkAgentInfo nai, UnneededFor reason) {
    final int numRequests;
    switch(reason) {
        case TEARDOWN:
            numRequests = nai.numRequestNetworkRequests();
            break;
        case LINGER:
            numRequests = nai.numForegroundNetworkRequests();
            break;
        default:
            Slog.wtf(TAG, "Invalid reason. Cannot happen.");
            return true;
    }
    if (!nai.everConnected || nai.isVPN() || nai.isLingering() || numRequests > 0) {
        return false;
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        if (reason == UnneededFor.LINGER && nri.request.isBackgroundRequest()) {
            // Background requests don't affect lingering.
            continue;
        }
        // there is hope for it to become one if it validated, then it is needed.
        if (nri.request.isRequest() && nai.satisfies(nri.request) && (nai.isSatisfyingRequest(nri.request.requestId) || // WiFi ends up validating and out scoring cellular.
        getNetworkForRequest(nri.request.requestId).getCurrentScore() < nai.getCurrentScoreAsValidated())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void handleTimedOutNetworkRequest(final NetworkRequestInfo nri) {
    if (mNetworkRequests.get(nri.request) == null) {
        return;
    }
    if (mNetworkForRequestId.get(nri.request.requestId) != null) {
        return;
    }
    if (VDBG || (DBG && nri.request.isRequest())) {
        log("releasing " + nri.request + " (timeout)");
    }
    handleRemoveNetworkRequest(nri);
    callCallbackForRequest(nri, null, ConnectivityManager.CALLBACK_UNAVAIL, 0);
}
#method_after
private void handleTimedOutNetworkRequest(final NetworkRequestInfo nri) {
    if (mNetworkRequests.get(nri.request) == null) {
        return;
    }
    if (getNetworkForRequest(nri.request.requestId) != null) {
        return;
    }
    if (VDBG || (DBG && nri.request.isRequest())) {
        log("releasing " + nri.request + " (timeout)");
    }
    handleRemoveNetworkRequest(nri);
    callCallbackForRequest(nri, null, ConnectivityManager.CALLBACK_UNAVAIL, 0);
}
#end_block

#method_before
private void handleRemoveNetworkRequest(final NetworkRequestInfo nri) {
    nri.unlinkDeathRecipient();
    mNetworkRequests.remove(nri.request);
    synchronized (mUidToNetworkRequestCount) {
        int requests = mUidToNetworkRequestCount.get(nri.mUid, 0);
        if (requests < 1) {
            Slog.wtf(TAG, "BUG: too small request count " + requests + " for UID " + nri.mUid);
        } else if (requests == 1) {
            mUidToNetworkRequestCount.removeAt(mUidToNetworkRequestCount.indexOfKey(nri.mUid));
        } else {
            mUidToNetworkRequestCount.put(nri.mUid, requests - 1);
        }
    }
    mNetworkRequestInfoLogs.log("RELEASE " + nri);
    if (nri.request.isRequest()) {
        boolean wasKept = false;
        NetworkAgentInfo nai = mNetworkForRequestId.get(nri.request.requestId);
        if (nai != null) {
            boolean wasBackgroundNetwork = nai.isBackgroundNetwork();
            nai.removeRequest(nri.request.requestId);
            if (VDBG) {
                log(" Removing from current network " + nai.name() + ", leaving " + nai.numNetworkRequests() + " requests.");
            }
            // If there are still lingered requests on this network, don't tear it down,
            // but resume lingering instead.
            updateLingerState(nai, SystemClock.elapsedRealtime());
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (DBG)
                    log("no live requests for " + nai.name() + "; disconnecting");
                teardownUnneededNetwork(nai);
            } else {
                wasKept = true;
            }
            mNetworkForRequestId.remove(nri.request.requestId);
            if (!wasBackgroundNetwork && nai.isBackgroundNetwork()) {
                // Went from foreground to background.
                updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
            }
        }
        // network satisfying it, so this loop is wasteful
        for (NetworkAgentInfo otherNai : mNetworkAgentInfos.values()) {
            if (otherNai.isSatisfyingRequest(nri.request.requestId) && otherNai != nai) {
                Slog.wtf(TAG, "Request " + nri.request + " satisfied by " + otherNai.name() + ", but mNetworkAgentInfos says " + (nai != null ? nai.name() : "null"));
            }
        }
        // phantom disconnect for this type.
        if (nri.request.legacyType != TYPE_NONE && nai != null) {
            boolean doRemove = true;
            if (wasKept) {
                // same legacy type - if so, don't remove the nai
                for (int i = 0; i < nai.numNetworkRequests(); i++) {
                    NetworkRequest otherRequest = nai.requestAt(i);
                    if (otherRequest.legacyType == nri.request.legacyType && otherRequest.isRequest()) {
                        if (DBG)
                            log(" still have other legacy request - leaving");
                        doRemove = false;
                    }
                }
            }
            if (doRemove) {
                mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
            }
        }
        for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
            nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
        }
    } else {
        // if this listen request applies and remove it.
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            nai.removeRequest(nri.request.requestId);
            if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
            }
        }
    }
}
#method_after
private void handleRemoveNetworkRequest(final NetworkRequestInfo nri) {
    nri.unlinkDeathRecipient();
    mNetworkRequests.remove(nri.request);
    synchronized (mUidToNetworkRequestCount) {
        int requests = mUidToNetworkRequestCount.get(nri.mUid, 0);
        if (requests < 1) {
            Slog.wtf(TAG, "BUG: too small request count " + requests + " for UID " + nri.mUid);
        } else if (requests == 1) {
            mUidToNetworkRequestCount.removeAt(mUidToNetworkRequestCount.indexOfKey(nri.mUid));
        } else {
            mUidToNetworkRequestCount.put(nri.mUid, requests - 1);
        }
    }
    mNetworkRequestInfoLogs.log("RELEASE " + nri);
    if (nri.request.isRequest()) {
        boolean wasKept = false;
        NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
        if (nai != null) {
            boolean wasBackgroundNetwork = nai.isBackgroundNetwork();
            nai.removeRequest(nri.request.requestId);
            if (VDBG) {
                log(" Removing from current network " + nai.name() + ", leaving " + nai.numNetworkRequests() + " requests.");
            }
            // If there are still lingered requests on this network, don't tear it down,
            // but resume lingering instead.
            updateLingerState(nai, SystemClock.elapsedRealtime());
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (DBG)
                    log("no live requests for " + nai.name() + "; disconnecting");
                teardownUnneededNetwork(nai);
            } else {
                wasKept = true;
            }
            clearNetworkForRequest(nri.request.requestId);
            if (!wasBackgroundNetwork && nai.isBackgroundNetwork()) {
                // Went from foreground to background.
                updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
            }
        }
        // network satisfying it, so this loop is wasteful
        for (NetworkAgentInfo otherNai : mNetworkAgentInfos.values()) {
            if (otherNai.isSatisfyingRequest(nri.request.requestId) && otherNai != nai) {
                Slog.wtf(TAG, "Request " + nri.request + " satisfied by " + otherNai.name() + ", but mNetworkAgentInfos says " + (nai != null ? nai.name() : "null"));
            }
        }
        // phantom disconnect for this type.
        if (nri.request.legacyType != TYPE_NONE && nai != null) {
            boolean doRemove = true;
            if (wasKept) {
                // same legacy type - if so, don't remove the nai
                for (int i = 0; i < nai.numNetworkRequests(); i++) {
                    NetworkRequest otherRequest = nai.requestAt(i);
                    if (otherRequest.legacyType == nri.request.legacyType && otherRequest.isRequest()) {
                        if (DBG)
                            log(" still have other legacy request - leaving");
                        doRemove = false;
                    }
                }
            }
            if (doRemove) {
                mLegacyTypeTracker.remove(nri.request.legacyType, nai, false);
            }
        }
        for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
            nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_CANCEL_REQUEST, nri.request);
        }
    } else {
        // if this listen request applies and remove it.
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            nai.removeRequest(nri.request.requestId);
            if (nri.request.networkCapabilities.hasSignalStrength() && nai.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(nai, "RELEASE", nri.request);
            }
        }
    }
}
#end_block

#method_before
// Called when we lose the default network and have no replacement yet.
// This will automatically be cleared after X seconds or a new default network
// becomes CONNECTED, whichever happens first.  The timer is started by the
private void ensureNetworkTransitionWakelock(String forWhom) {
    synchronized (this) {
        if (mNetTransitionWakeLock.isHeld()) {
            return;
        }
        mNetTransitionWakeLock.acquire();
    }
    mWakelockLogs.log("ACQUIRE for " + forWhom);
    Message msg = mHandler.obtainMessage(EVENT_EXPIRE_NET_TRANSITION_WAKELOCK);
    mHandler.sendMessageDelayed(msg, mNetTransitionWakeLockTimeout);
}
#method_after
// Called when we lose the default network and have no replacement yet.
// This will automatically be cleared after X seconds or a new default network
// becomes CONNECTED, whichever happens first.  The timer is started by the
private void ensureNetworkTransitionWakelock(String forWhom) {
    synchronized (this) {
        if (mNetTransitionWakeLock.isHeld()) {
            return;
        }
        mNetTransitionWakeLock.acquire();
        mLastWakeLockAcquireTimestamp = SystemClock.elapsedRealtime();
        mTotalWakelockAcquisitions++;
    }
    mWakelockLogs.log("ACQUIRE for " + forWhom);
    Message msg = mHandler.obtainMessage(EVENT_EXPIRE_NET_TRANSITION_WAKELOCK);
    mHandler.sendMessageDelayed(msg, mNetTransitionWakeLockTimeout);
}
#end_block

#method_before
// Called when either message of ensureNetworkTransitionWakelock or
private void handleReleaseNetworkTransitionWakelock(int eventId) {
    String event = eventName(eventId);
    synchronized (this) {
        if (!mNetTransitionWakeLock.isHeld()) {
            mWakelockLogs.log(String.format("RELEASE: already released (%s)", event));
            Slog.w(TAG, "expected Net Transition WakeLock to be held");
            return;
        }
        mNetTransitionWakeLock.release();
    }
    mWakelockLogs.log(String.format("RELEASE (%s)", event));
}
#method_after
// Called when either message of ensureNetworkTransitionWakelock or
private void handleReleaseNetworkTransitionWakelock(int eventId) {
    String event = eventName(eventId);
    synchronized (this) {
        if (!mNetTransitionWakeLock.isHeld()) {
            mWakelockLogs.log(String.format("RELEASE: already released (%s)", event));
            Slog.w(TAG, "expected Net Transition WakeLock to be held");
            return;
        }
        mNetTransitionWakeLock.release();
        long lockDuration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
        mTotalWakelockDurationMs += lockDuration;
        mMaxWakelockDurationMs = Math.max(mMaxWakelockDurationMs, lockDuration);
        mTotalWakelockReleases++;
    }
    mWakelockLogs.log(String.format("RELEASE (%s)", event));
}
#end_block

#method_before
private NetworkAgentInfo getDefaultNetwork() {
    return mNetworkForRequestId.get(mDefaultRequest.requestId);
}
#method_after
private NetworkAgentInfo getDefaultNetwork() {
    return getNetworkForRequest(mDefaultRequest.requestId);
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), new LinkProperties(linkProperties), new NetworkCapabilities(networkCapabilities), currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, networkInfo.getExtraInfo());
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, new NetworkCapabilities(networkCapabilities), currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, networkInfo.getExtraInfo());
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    updateClat(newLp, oldLp, networkAgent);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp, networkAgent);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp, networkAgent);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void updateInterfaces(LinkProperties newLp, LinkProperties oldLp, int netId, NetworkCapabilities caps) {
    CompareResult<String> interfaceDiff = new CompareResult<String>();
    if (oldLp != null) {
        interfaceDiff = oldLp.compareAllInterfaceNames(newLp);
    } else if (newLp != null) {
        interfaceDiff.added = newLp.getAllInterfaceNames();
    }
    for (String iface : interfaceDiff.added) {
        try {
            if (DBG)
                log("Adding iface " + iface + " to network " + netId);
            mNetd.addInterfaceToNetwork(iface, netId);
            wakeupModifyInterface(iface, caps, true);
        } catch (Exception e) {
            loge("Exception adding interface: " + e);
        }
    }
    for (String iface : interfaceDiff.removed) {
        try {
            if (DBG)
                log("Removing iface " + iface + " from network " + netId);
            wakeupModifyInterface(iface, caps, false);
            mNetd.removeInterfaceFromNetwork(iface, netId);
        } catch (Exception e) {
            loge("Exception removing interface: " + e);
        }
    }
}
#method_after
private void updateInterfaces(LinkProperties newLp, LinkProperties oldLp, int netId, NetworkCapabilities caps) {
    CompareResult<String> interfaceDiff = new CompareResult<String>(oldLp != null ? oldLp.getAllInterfaceNames() : null, newLp != null ? newLp.getAllInterfaceNames() : null);
    for (String iface : interfaceDiff.added) {
        try {
            if (DBG)
                log("Adding iface " + iface + " to network " + netId);
            mNetd.addInterfaceToNetwork(iface, netId);
            wakeupModifyInterface(iface, caps, true);
        } catch (Exception e) {
            loge("Exception adding interface: " + e);
        }
    }
    for (String iface : interfaceDiff.removed) {
        try {
            if (DBG)
                log("Removing iface " + iface + " from network " + netId);
            wakeupModifyInterface(iface, caps, false);
            mNetd.removeInterfaceFromNetwork(iface, netId);
        } catch (Exception e) {
            loge("Exception removing interface: " + e);
        }
    }
}
#end_block

#method_before
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>();
    if (oldLp != null) {
        routeDiff = oldLp.compareAllRoutes(newLp);
    } else if (newLp != null) {
        routeDiff.added = newLp.getAllRoutes();
    }
    // do this twice, adding non-nexthop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (VDBG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNetd.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#method_after
private boolean updateRoutes(LinkProperties newLp, LinkProperties oldLp, int netId) {
    // Compare the route diff to determine which routes should be added and removed.
    CompareResult<RouteInfo> routeDiff = new CompareResult<RouteInfo>(oldLp != null ? oldLp.getAllRoutes() : null, newLp != null ? newLp.getAllRoutes() : null);
    // do this twice, adding non-nexthop routes first, then routes they are dependent on
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway())
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getDestination().getAddress() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for non-gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.added) {
        if (route.hasGateway() == false)
            continue;
        if (VDBG)
            log("Adding Route [" + route + "] to network " + netId);
        try {
            mNetd.addRoute(netId, route);
        } catch (Exception e) {
            if ((route.getGateway() instanceof Inet4Address) || VDBG) {
                loge("Exception in addRoute for gateway: " + e);
            }
        }
    }
    for (RouteInfo route : routeDiff.removed) {
        if (VDBG)
            log("Removing Route [" + route + "] from network " + netId);
        try {
            mNetd.removeRoute(netId, route);
        } catch (Exception e) {
            loge("Exception in removeRoute: " + e);
        }
    }
    return !routeDiff.added.isEmpty() || !routeDiff.removed.isEmpty();
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void setupTests(ArrayTestListAdapter adapter) {
    final Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_prepare_notifications, "BYOD_TurnOffWorkCreateNotification", R.string.provisioning_byod_turn_off_work_prepare_notifications_instruction, new Intent(ByodHelperActivity.ACTION_NOTIFICATION)));
    mTurnOffWorkTest = new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_turned_off, "BYOD_WorkTurnedOff") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            Toast.makeText(TurnOffWorkActivity.this, R.string.provisioning_byod_turn_off_work_turned_off_toast, Toast.LENGTH_SHORT).show();
        }
    };
    adapter.add(mTurnOffWorkTest);
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_notifications, "BYOD_TurnOffWorkNotifications", R.string.provisioning_byod_turn_off_work_notifications_instruction, new Intent(ByodHelperActivity.ACTION_NOTIFICATION)));
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_icon, "BYOD_TurnOffWorkIcon", R.string.provisioning_byod_turn_off_work_icon_instruction, new Intent(Settings.ACTION_SETTINGS)));
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE))
        adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_launcher, "BYOD_TurnOffWorkStartApps", R.string.provisioning_byod_turn_off_work_launcher_instruction, homeIntent));
    mTurnOnWorkTest = new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_turned_on, "BYOD_WorkTurnedOn") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            Toast.makeText(TurnOffWorkActivity.this, R.string.provisioning_byod_turn_off_work_turned_on_toast, Toast.LENGTH_SHORT).show();
        }
    };
    adapter.add(mTurnOnWorkTest);
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_on_work_icon, "BYOD_TurnOnWorkIcon", R.string.provisioning_byod_turn_on_work_icon_instruction, new Intent(Settings.ACTION_SETTINGS)));
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE))
        adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_on_work_launcher, "BYOD_TurnOnWorkStartApps", R.string.provisioning_byod_turn_on_work_launcher_instruction, homeIntent));
}
#method_after
@Override
protected void setupTests(ArrayTestListAdapter adapter) {
    final Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_prepare_notifications, "BYOD_TurnOffWorkCreateNotification", R.string.provisioning_byod_turn_off_work_prepare_notifications_instruction, new Intent(ByodHelperActivity.ACTION_NOTIFICATION)));
    mTurnOffWorkTest = new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_turned_off, "BYOD_WorkTurnedOff") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            Toast.makeText(TurnOffWorkActivity.this, R.string.provisioning_byod_turn_off_work_turned_off_toast, Toast.LENGTH_SHORT).show();
        }
    };
    adapter.add(mTurnOffWorkTest);
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_notifications, "BYOD_TurnOffWorkNotifications", R.string.provisioning_byod_turn_off_work_notifications_instruction, new Intent(ByodHelperActivity.ACTION_NOTIFICATION)));
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_icon, "BYOD_TurnOffWorkIcon", R.string.provisioning_byod_turn_off_work_icon_instruction, new Intent(Settings.ACTION_SETTINGS)));
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_launcher, "BYOD_TurnOffWorkStartApps", R.string.provisioning_byod_turn_off_work_launcher_instruction, homeIntent));
    }
    mTurnOnWorkTest = new DialogTestListItem(this, R.string.provisioning_byod_turn_off_work_turned_on, "BYOD_WorkTurnedOn") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            Toast.makeText(TurnOffWorkActivity.this, R.string.provisioning_byod_turn_off_work_turned_on_toast, Toast.LENGTH_SHORT).show();
        }
    };
    adapter.add(mTurnOnWorkTest);
    adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_on_work_icon, "BYOD_TurnOnWorkIcon", R.string.provisioning_byod_turn_on_work_icon_instruction, new Intent(Settings.ACTION_SETTINGS)));
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        adapter.add(new DialogTestListItem(this, R.string.provisioning_byod_turn_on_work_launcher, "BYOD_TurnOnWorkStartApps", R.string.provisioning_byod_turn_on_work_launcher_instruction, homeIntent));
    }
}
#end_block

#method_before
@Override
protected void setupTests(ArrayTestListAdapter adapter) {
    mProfileOwnerInstalled = new DialogTestListItem(this, R.string.provisioning_byod_profileowner, "BYOD_ProfileOwnerInstalled") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            queryProfileOwner(true);
        }
    };
    mDiskEncryptionTest = new DialogTestListItem(this, R.string.provisioning_byod_disk_encryption, "BYOD_DiskEncryptionTest") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            checkDiskEncryption();
        }
    };
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        mWorkAppVisibleTest = new DialogTestListItemWithIcon(this, R.string.provisioning_byod_workapps_visible, "BYOD_WorkAppVisibleTest", R.string.provisioning_byod_workapps_visible_instruction, new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME), R.drawable.badged_icon);
        mConfirmWorkCredentials = new DialogTestListItem(this, R.string.provisioning_byod_confirm_work_credentials, "BYOD_ConfirmWorkCredentials", R.string.provisioning_byod_confirm_work_credentials_description, new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME));
        mWiFiDataUsageSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_wifi_data_usage_settings, "BYOD_WiFiDataUsageSettingsVisibleTest", R.string.provisioning_byod_wifi_data_usage_settings_instruction, new Intent(Settings.ACTION_SETTINGS));
    }
    mWorkNotificationBadgedTest = new DialogTestListItemWithIcon(this, R.string.provisioning_byod_work_notification, "BYOD_WorkNotificationBadgedTest", R.string.provisioning_byod_work_notification_instruction, new Intent(ByodHelperActivity.ACTION_NOTIFICATION), R.drawable.ic_corp_icon);
    Intent workStatusIcon = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
    workStatusIcon.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mWorkStatusBarIconTest = new DialogTestListItemWithIcon(this, R.string.provisioning_byod_work_status_icon, "BYOD_WorkStatusBarIconTest", R.string.provisioning_byod_work_status_icon_instruction, workStatusIcon, R.drawable.stat_sys_managed_profile_status);
    Intent workStatusToast = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
    workStatusToast.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mWorkStatusBarToastTest = new DialogTestListItem(this, R.string.provisioning_byod_work_status_toast, "BYOD_WorkStatusBarToastTest", R.string.provisioning_byod_work_status_toast_instruction, workStatusToast);
    mDisableNonMarketTest = new DialogTestListItem(this, R.string.provisioning_byod_nonmarket_deny, "BYOD_DisableNonMarketTest", R.string.provisioning_byod_nonmarket_deny_info, new Intent(ByodHelperActivity.ACTION_INSTALL_APK).putExtra(ByodHelperActivity.EXTRA_ALLOW_NON_MARKET_APPS, false));
    mEnableNonMarketTest = new DialogTestListItem(this, R.string.provisioning_byod_nonmarket_allow, "BYOD_EnableNonMarketTest", R.string.provisioning_byod_nonmarket_allow_info, new Intent(ByodHelperActivity.ACTION_INSTALL_APK).putExtra(ByodHelperActivity.EXTRA_ALLOW_NON_MARKET_APPS, true));
    mProfileAccountVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_profile_visible, "BYOD_ProfileAccountVisibleTest", R.string.provisioning_byod_profile_visible_instruction, new Intent(Settings.ACTION_SETTINGS));
    mAppSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_app_settings, "BYOD_AppSettingsVisibleTest", R.string.provisioning_byod_app_settings_instruction, new Intent(Settings.ACTION_APPLICATION_SETTINGS));
    mDeviceAdminVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_admin_visible, "BYOD_DeviceAdminVisibleTest", R.string.provisioning_byod_admin_visible_instruction, new Intent(Settings.ACTION_SECURITY_SETTINGS));
    mCredSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_cred_settings, "BYOD_CredSettingsVisibleTest", R.string.provisioning_byod_cred_settings_instruction, new Intent(Settings.ACTION_SECURITY_SETTINGS));
    mLocationSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_location_settings, "BYOD_LocationSettingsVisibleTest", R.string.provisioning_byod_location_settings_instruction, new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));
    mCellularDataUsageSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_cellular_data_usage_settings, "BYOD_CellularDataUsageSettingsVisibleTest", R.string.provisioning_byod_cellular_data_usage_settings_instruction, new Intent(Settings.ACTION_SETTINGS));
    mPrintSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_print_settings, "BYOD_PrintSettingsVisibleTest", R.string.provisioning_byod_print_settings_instruction, new Intent(Settings.ACTION_PRINT_SETTINGS));
    Intent intent = new Intent(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
    intent.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, false);
    Intent chooser = Intent.createChooser(intent, getResources().getString(R.string.provisioning_cross_profile_chooser));
    mCrossProfileIntentFiltersTestFromPersonal = new DialogTestListItem(this, R.string.provisioning_byod_cross_profile_from_personal, "BYOD_CrossProfileIntentFiltersTestFromPersonal", R.string.provisioning_byod_cross_profile_from_personal_instruction, chooser);
    mCrossProfileIntentFiltersTestFromWork = new DialogTestListItem(this, R.string.provisioning_byod_cross_profile_from_work, "BYOD_CrossProfileIntentFiltersTestFromWork", R.string.provisioning_byod_cross_profile_from_work_instruction, new Intent(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG));
    /* Disable due to b/33571176
        mAppLinkingTest = new DialogTestListItem(this,
                R.string.provisioning_app_linking,
                "BYOD_AppLinking",
                R.string.provisioning_byod_app_linking_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG));
        */
    mKeyguardDisabledFeaturesTest = TestListItem.newTest(this, R.string.provisioning_byod_keyguard_disabled_features, KeyguardDisabledFeaturesActivity.class.getName(), new Intent(this, KeyguardDisabledFeaturesActivity.class), null);
    mAuthenticationBoundKeyTest = TestListItem.newTest(this, R.string.provisioning_byod_auth_bound_key, AuthenticationBoundKeyTestActivity.class.getName(), new Intent(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST), null);
    mVpnTest = TestListItem.newTest(this, R.string.provisioning_byod_vpn, VpnTestActivity.class.getName(), new Intent(VpnTestActivity.ACTION_VPN), null);
    mDisallowAppsControlTest = TestListItem.newTest(this, R.string.provisioning_byod_disallow_apps_control, DisallowAppsControlActivity.class.getName(), new Intent(this, DisallowAppsControlActivity.class), null);
    // Test for checking if the required intent filters are set during managed provisioning.
    mIntentFiltersTest = new DialogTestListItem(this, R.string.provisioning_byod_cross_profile_intent_filters, "BYOD_IntentFiltersTest") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            checkIntentFilters();
        }
    };
    mTurnOffWorkFeaturesTest = TestListItem.newTest(this, R.string.provisioning_byod_turn_off_work, TurnOffWorkActivity.class.getName(), new Intent(this, TurnOffWorkActivity.class), null);
    Intent permissionCheckIntent = new Intent(PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
    mPermissionLockdownTest = new DialogTestListItem(this, R.string.device_profile_owner_permission_lockdown_test, "BYOD_PermissionLockdownTest", R.string.profile_owner_permission_lockdown_test_info, permissionCheckIntent);
    mSelectWorkChallenge = new DialogTestListItem(this, R.string.provisioning_byod_select_work_challenge, "BYOD_SelectWorkChallenge", R.string.provisioning_byod_select_work_challenge_description, new Intent(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE));
    mRecentsTest = TestListItem.newTest(this, R.string.provisioning_byod_recents, RecentsRedactionActivity.class.getName(), new Intent(RecentsRedactionActivity.ACTION_RECENTS), null);
    mOrganizationInfoTest = TestListItem.newTest(this, R.string.provisioning_byod_organization_info, OrganizationInfoTestActivity.class.getName(), new Intent(this, OrganizationInfoTestActivity.class), null);
    mParentProfilePassword = new DialogTestListItem(this, R.string.provisioning_byod_parent_profile_password, "BYOD_ParentProfilePasswordTest", R.string.provisioning_byod_parent_profile_password_description, new Intent(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD));
    final Intent policyTransparencyTestIntent = new Intent(this, PolicyTransparencyTestListActivity.class);
    policyTransparencyTestIntent.putExtra(PolicyTransparencyTestListActivity.EXTRA_MODE, PolicyTransparencyTestListActivity.MODE_PROFILE_OWNER);
    policyTransparencyTestIntent.putExtra(PolicyTransparencyTestActivity.EXTRA_TEST_ID, "BYOD_PolicyTransparency");
    mPolicyTransparencyTest = TestListItem.newTest(this, R.string.device_profile_owner_policy_transparency_test, "BYOD_PolicyTransparency", policyTransparencyTestIntent, null);
    adapter.add(mProfileOwnerInstalled);
    adapter.add(mDiskEncryptionTest);
    // Badge related tests
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE))
        adapter.add(mWorkAppVisibleTest);
    adapter.add(mWorkNotificationBadgedTest);
    adapter.add(mWorkStatusBarIconTest);
    adapter.add(mWorkStatusBarToastTest);
    // Settings related tests.
    adapter.add(mProfileAccountVisibleTest);
    adapter.add(mDeviceAdminVisibleTest);
    adapter.add(mCredSettingsVisibleTest);
    adapter.add(mAppSettingsVisibleTest);
    adapter.add(mLocationSettingsVisibleTest);
    adapter.add(mPrintSettingsVisibleTest);
    adapter.add(mCrossProfileIntentFiltersTestFromPersonal);
    adapter.add(mCrossProfileIntentFiltersTestFromWork);
    /* Disable due to b/33571176
        adapter.add(mAppLinkingTest);
        */
    adapter.add(mDisableNonMarketTest);
    adapter.add(mEnableNonMarketTest);
    adapter.add(mIntentFiltersTest);
    adapter.add(mPermissionLockdownTest);
    adapter.add(mKeyguardDisabledFeaturesTest);
    adapter.add(mAuthenticationBoundKeyTest);
    adapter.add(mVpnTest);
    adapter.add(mTurnOffWorkFeaturesTest);
    adapter.add(mSelectWorkChallenge);
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE))
        adapter.add(mConfirmWorkCredentials);
    adapter.add(mRecentsTest);
    adapter.add(mOrganizationInfoTest);
    adapter.add(mParentProfilePassword);
    adapter.add(mPolicyTransparencyTest);
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
            adapter.add(mWiFiDataUsageSettingsVisibleTest);
        }
    }
    mCm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
    if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) != null) {
        adapter.add(mCellularDataUsageSettingsVisibleTest);
    }
    if (canResolveIntent(new Intent(Settings.ACTION_APPLICATION_SETTINGS))) {
        adapter.add(mDisallowAppsControlTest);
    }
    /* If there is an application that handles ACTION_IMAGE_CAPTURE, test that it handles it
         * well.
         */
    if (canResolveIntent(ByodHelperActivity.getCaptureImageIntent())) {
        // Capture image intent can be resolved in primary profile, so test.
        mCrossProfileImageCaptureSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_image_support, "BYOD_CrossProfileImageCaptureSupportTest", R.string.provisioning_byod_capture_image_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE));
        adapter.add(mCrossProfileImageCaptureSupportTest);
    } else {
        // Capture image intent cannot be resolved in primary profile, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_image_capture_resolver, Toast.LENGTH_SHORT).show();
    }
    /* If there is an application that handles ACTION_VIDEO_CAPTURE, test that it handles it
         * well.
         */
    if (canResolveIntent(ByodHelperActivity.getCaptureVideoIntent())) {
        // Capture video intent can be resolved in primary profile, so test.
        mCrossProfileVideoCaptureWithExtraOutputSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_video_support_with_extra_output, "BYOD_CrossProfileVideoCaptureWithExtraOutputSupportTest", R.string.provisioning_byod_capture_video_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT));
        adapter.add(mCrossProfileVideoCaptureWithExtraOutputSupportTest);
        mCrossProfileVideoCaptureWithoutExtraOutputSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_video_support_without_extra_output, "BYOD_CrossProfileVideoCaptureWithoutExtraOutputSupportTest", R.string.provisioning_byod_capture_video_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT));
        adapter.add(mCrossProfileVideoCaptureWithoutExtraOutputSupportTest);
    } else {
        // Capture video intent cannot be resolved in primary profile, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_video_capture_resolver, Toast.LENGTH_SHORT).show();
    }
    if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC)) {
        mDisableNfcBeamTest = new DialogTestListItem(this, R.string.provisioning_byod_nfc_beam, "BYOD_DisableNfcBeamTest", R.string.provisioning_byod_nfc_beam_allowed_instruction, new Intent(ByodHelperActivity.ACTION_TEST_NFC_BEAM)) {

            @Override
            public void performTest(final DialogTestListActivity activity) {
                activity.showManualTestDialog(mDisableNfcBeamTest, new DefaultTestCallback(mDisableNfcBeamTest) {

                    @Override
                    public void onPass() {
                        // Start a second test with beam disallowed by policy.
                        Intent testNfcBeamIntent = new Intent(ByodHelperActivity.ACTION_TEST_NFC_BEAM);
                        testNfcBeamIntent.putExtra(NfcTestActivity.EXTRA_DISALLOW_BY_POLICY, true);
                        DialogTestListItem disableNfcBeamTest2 = new DialogTestListItem(activity, R.string.provisioning_byod_nfc_beam, "BYOD_DisableNfcBeamTest", R.string.provisioning_byod_nfc_beam_disallowed_instruction, testNfcBeamIntent);
                        // The result should be reflected on the original test.
                        activity.showManualTestDialog(disableNfcBeamTest2, new DefaultTestCallback(mDisableNfcBeamTest));
                    }
                });
            }
        };
        adapter.add(mDisableNfcBeamTest);
    }
    /* If there is an application that handles RECORD_SOUND_ACTION, test that it handles it
         * well.
         */
    if (canResolveIntent(ByodHelperActivity.getCaptureAudioIntent())) {
        // Capture audio intent can be resolved in primary profile, so test.
        mCrossProfileAudioCaptureSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_audio_support, "BYOD_CrossProfileAudioCaptureSupportTest", R.string.provisioning_byod_capture_audio_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO));
        adapter.add(mCrossProfileAudioCaptureSupportTest);
    } else {
        // Capture audio intent cannot be resolved in primary profile, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_audio_capture_resolver, Toast.LENGTH_SHORT).show();
    }
    if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION_GPS)) {
        mEnableLocationModeTest = new DialogTestListItem(this, R.string.provisioning_byod_location_mode_enable, "BYOD_LocationModeEnableTest", R.string.provisioning_byod_location_mode_enable_instruction, new Intent(ByodHelperActivity.ACTION_BYOD_SET_LOCATION_AND_CHECK_UPDATES));
        mDisableLocationModeThroughMainSwitchTest = new DialogTestListItem(this, R.string.provisioning_byod_location_mode_disable, "BYOD_LocationModeDisableMainTest", R.string.provisioning_byod_location_mode_disable_instruction, new Intent(ByodHelperActivity.ACTION_BYOD_SET_LOCATION_AND_CHECK_UPDATES));
        mDisableLocationModeThroughWorkSwitchTest = new DialogTestListItem(this, R.string.provisioning_byod_work_location_mode_disable, "BYOD_LocationModeDisableWorkTest", R.string.provisioning_byod_work_location_mode_disable_instruction, new Intent(ByodHelperActivity.ACTION_BYOD_SET_LOCATION_AND_CHECK_UPDATES));
        mPrimaryLocationWhenWorkDisabledTest = new DialogTestListItem(this, R.string.provisioning_byod_primary_location_when_work_disabled, "BYOD_PrimaryLocationWhenWorkDisabled", R.string.provisioning_byod_primary_location_when_work_disabled_instruction, new Intent(LocationListenerActivity.ACTION_SET_LOCATION_AND_CHECK_UPDATES));
        adapter.add(mEnableLocationModeTest);
        adapter.add(mDisableLocationModeThroughMainSwitchTest);
        adapter.add(mDisableLocationModeThroughWorkSwitchTest);
        adapter.add(mPrimaryLocationWhenWorkDisabledTest);
    } else {
        // The system does not support GPS feature, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_gps_location_feature, Toast.LENGTH_SHORT).show();
    }
}
#method_after
@Override
protected void setupTests(ArrayTestListAdapter adapter) {
    mProfileOwnerInstalled = new DialogTestListItem(this, R.string.provisioning_byod_profileowner, "BYOD_ProfileOwnerInstalled") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            queryProfileOwner(true);
        }
    };
    mDiskEncryptionTest = new DialogTestListItem(this, R.string.provisioning_byod_disk_encryption, "BYOD_DiskEncryptionTest") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            checkDiskEncryption();
        }
    };
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        mWorkAppVisibleTest = new DialogTestListItemWithIcon(this, R.string.provisioning_byod_workapps_visible, "BYOD_WorkAppVisibleTest", R.string.provisioning_byod_workapps_visible_instruction, new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME), R.drawable.badged_icon);
        mConfirmWorkCredentials = new DialogTestListItem(this, R.string.provisioning_byod_confirm_work_credentials, "BYOD_ConfirmWorkCredentials", R.string.provisioning_byod_confirm_work_credentials_description, new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME));
        mWiFiDataUsageSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_wifi_data_usage_settings, "BYOD_WiFiDataUsageSettingsVisibleTest", R.string.provisioning_byod_wifi_data_usage_settings_instruction, new Intent(Settings.ACTION_SETTINGS));
    }
    mWorkNotificationBadgedTest = new DialogTestListItemWithIcon(this, R.string.provisioning_byod_work_notification, "BYOD_WorkNotificationBadgedTest", R.string.provisioning_byod_work_notification_instruction, new Intent(ByodHelperActivity.ACTION_NOTIFICATION), R.drawable.ic_corp_icon);
    Intent workStatusIcon = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
    workStatusIcon.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mWorkStatusBarIconTest = new DialogTestListItemWithIcon(this, R.string.provisioning_byod_work_status_icon, "BYOD_WorkStatusBarIconTest", R.string.provisioning_byod_work_status_icon_instruction, workStatusIcon, R.drawable.stat_sys_managed_profile_status);
    Intent workStatusToast = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
    workStatusToast.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mWorkStatusBarToastTest = new DialogTestListItem(this, R.string.provisioning_byod_work_status_toast, "BYOD_WorkStatusBarToastTest", R.string.provisioning_byod_work_status_toast_instruction, workStatusToast);
    mDisableNonMarketTest = new DialogTestListItem(this, R.string.provisioning_byod_nonmarket_deny, "BYOD_DisableNonMarketTest", R.string.provisioning_byod_nonmarket_deny_info, new Intent(ByodHelperActivity.ACTION_INSTALL_APK).putExtra(ByodHelperActivity.EXTRA_ALLOW_NON_MARKET_APPS, false));
    mEnableNonMarketTest = new DialogTestListItem(this, R.string.provisioning_byod_nonmarket_allow, "BYOD_EnableNonMarketTest", R.string.provisioning_byod_nonmarket_allow_info, new Intent(ByodHelperActivity.ACTION_INSTALL_APK).putExtra(ByodHelperActivity.EXTRA_ALLOW_NON_MARKET_APPS, true));
    mProfileAccountVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_profile_visible, "BYOD_ProfileAccountVisibleTest", R.string.provisioning_byod_profile_visible_instruction, new Intent(Settings.ACTION_SETTINGS));
    mAppSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_app_settings, "BYOD_AppSettingsVisibleTest", R.string.provisioning_byod_app_settings_instruction, new Intent(Settings.ACTION_APPLICATION_SETTINGS));
    mDeviceAdminVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_admin_visible, "BYOD_DeviceAdminVisibleTest", R.string.provisioning_byod_admin_visible_instruction, new Intent(Settings.ACTION_SECURITY_SETTINGS));
    mCredSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_cred_settings, "BYOD_CredSettingsVisibleTest", R.string.provisioning_byod_cred_settings_instruction, new Intent(Settings.ACTION_SECURITY_SETTINGS));
    mLocationSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_location_settings, "BYOD_LocationSettingsVisibleTest", R.string.provisioning_byod_location_settings_instruction, new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));
    mCellularDataUsageSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_cellular_data_usage_settings, "BYOD_CellularDataUsageSettingsVisibleTest", R.string.provisioning_byod_cellular_data_usage_settings_instruction, new Intent(Settings.ACTION_SETTINGS));
    mPrintSettingsVisibleTest = new DialogTestListItem(this, R.string.provisioning_byod_print_settings, "BYOD_PrintSettingsVisibleTest", R.string.provisioning_byod_print_settings_instruction, new Intent(Settings.ACTION_PRINT_SETTINGS));
    Intent intent = new Intent(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
    intent.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, false);
    Intent chooser = Intent.createChooser(intent, getResources().getString(R.string.provisioning_cross_profile_chooser));
    mCrossProfileIntentFiltersTestFromPersonal = new DialogTestListItem(this, R.string.provisioning_byod_cross_profile_from_personal, "BYOD_CrossProfileIntentFiltersTestFromPersonal", R.string.provisioning_byod_cross_profile_from_personal_instruction, chooser);
    mCrossProfileIntentFiltersTestFromWork = new DialogTestListItem(this, R.string.provisioning_byod_cross_profile_from_work, "BYOD_CrossProfileIntentFiltersTestFromWork", R.string.provisioning_byod_cross_profile_from_work_instruction, new Intent(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG));
    /* Disable due to b/33571176
        mAppLinkingTest = new DialogTestListItem(this,
                R.string.provisioning_app_linking,
                "BYOD_AppLinking",
                R.string.provisioning_byod_app_linking_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG));
        */
    mKeyguardDisabledFeaturesTest = TestListItem.newTest(this, R.string.provisioning_byod_keyguard_disabled_features, KeyguardDisabledFeaturesActivity.class.getName(), new Intent(this, KeyguardDisabledFeaturesActivity.class), null);
    mAuthenticationBoundKeyTest = TestListItem.newTest(this, R.string.provisioning_byod_auth_bound_key, AuthenticationBoundKeyTestActivity.class.getName(), new Intent(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST), null);
    mVpnTest = TestListItem.newTest(this, R.string.provisioning_byod_vpn, VpnTestActivity.class.getName(), new Intent(VpnTestActivity.ACTION_VPN), null);
    mDisallowAppsControlTest = TestListItem.newTest(this, R.string.provisioning_byod_disallow_apps_control, DisallowAppsControlActivity.class.getName(), new Intent(this, DisallowAppsControlActivity.class), null);
    // Test for checking if the required intent filters are set during managed provisioning.
    mIntentFiltersTest = new DialogTestListItem(this, R.string.provisioning_byod_cross_profile_intent_filters, "BYOD_IntentFiltersTest") {

        @Override
        public void performTest(DialogTestListActivity activity) {
            checkIntentFilters();
        }
    };
    mTurnOffWorkFeaturesTest = TestListItem.newTest(this, R.string.provisioning_byod_turn_off_work, TurnOffWorkActivity.class.getName(), new Intent(this, TurnOffWorkActivity.class), null);
    Intent permissionCheckIntent = new Intent(PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
    mPermissionLockdownTest = new DialogTestListItem(this, R.string.device_profile_owner_permission_lockdown_test, "BYOD_PermissionLockdownTest", R.string.profile_owner_permission_lockdown_test_info, permissionCheckIntent);
    mSelectWorkChallenge = new DialogTestListItem(this, R.string.provisioning_byod_select_work_challenge, "BYOD_SelectWorkChallenge", R.string.provisioning_byod_select_work_challenge_description, new Intent(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE));
    mRecentsTest = TestListItem.newTest(this, R.string.provisioning_byod_recents, RecentsRedactionActivity.class.getName(), new Intent(RecentsRedactionActivity.ACTION_RECENTS), null);
    mOrganizationInfoTest = TestListItem.newTest(this, R.string.provisioning_byod_organization_info, OrganizationInfoTestActivity.class.getName(), new Intent(this, OrganizationInfoTestActivity.class), null);
    mParentProfilePassword = new DialogTestListItem(this, R.string.provisioning_byod_parent_profile_password, "BYOD_ParentProfilePasswordTest", R.string.provisioning_byod_parent_profile_password_description, new Intent(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD));
    final Intent policyTransparencyTestIntent = new Intent(this, PolicyTransparencyTestListActivity.class);
    policyTransparencyTestIntent.putExtra(PolicyTransparencyTestListActivity.EXTRA_MODE, PolicyTransparencyTestListActivity.MODE_PROFILE_OWNER);
    policyTransparencyTestIntent.putExtra(PolicyTransparencyTestActivity.EXTRA_TEST_ID, "BYOD_PolicyTransparency");
    mPolicyTransparencyTest = TestListItem.newTest(this, R.string.device_profile_owner_policy_transparency_test, "BYOD_PolicyTransparency", policyTransparencyTestIntent, null);
    adapter.add(mProfileOwnerInstalled);
    adapter.add(mDiskEncryptionTest);
    // Badge related tests
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        adapter.add(mWorkAppVisibleTest);
    }
    adapter.add(mWorkNotificationBadgedTest);
    adapter.add(mWorkStatusBarIconTest);
    adapter.add(mWorkStatusBarToastTest);
    // Settings related tests.
    adapter.add(mProfileAccountVisibleTest);
    adapter.add(mDeviceAdminVisibleTest);
    adapter.add(mCredSettingsVisibleTest);
    adapter.add(mAppSettingsVisibleTest);
    adapter.add(mLocationSettingsVisibleTest);
    adapter.add(mPrintSettingsVisibleTest);
    adapter.add(mCrossProfileIntentFiltersTestFromPersonal);
    adapter.add(mCrossProfileIntentFiltersTestFromWork);
    /* Disable due to b/33571176
        adapter.add(mAppLinkingTest);
        */
    adapter.add(mDisableNonMarketTest);
    adapter.add(mEnableNonMarketTest);
    adapter.add(mIntentFiltersTest);
    adapter.add(mPermissionLockdownTest);
    adapter.add(mKeyguardDisabledFeaturesTest);
    adapter.add(mAuthenticationBoundKeyTest);
    adapter.add(mVpnTest);
    adapter.add(mTurnOffWorkFeaturesTest);
    adapter.add(mSelectWorkChallenge);
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        adapter.add(mConfirmWorkCredentials);
    }
    adapter.add(mRecentsTest);
    adapter.add(mOrganizationInfoTest);
    adapter.add(mParentProfilePassword);
    adapter.add(mPolicyTransparencyTest);
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
            adapter.add(mWiFiDataUsageSettingsVisibleTest);
        }
    }
    mCm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
    if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) != null) {
        adapter.add(mCellularDataUsageSettingsVisibleTest);
    }
    if (canResolveIntent(new Intent(Settings.ACTION_APPLICATION_SETTINGS))) {
        adapter.add(mDisallowAppsControlTest);
    }
    /* If there is an application that handles ACTION_IMAGE_CAPTURE, test that it handles it
         * well.
         */
    if (canResolveIntent(ByodHelperActivity.getCaptureImageIntent())) {
        // Capture image intent can be resolved in primary profile, so test.
        mCrossProfileImageCaptureSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_image_support, "BYOD_CrossProfileImageCaptureSupportTest", R.string.provisioning_byod_capture_image_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE));
        adapter.add(mCrossProfileImageCaptureSupportTest);
    } else {
        // Capture image intent cannot be resolved in primary profile, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_image_capture_resolver, Toast.LENGTH_SHORT).show();
    }
    /* If there is an application that handles ACTION_VIDEO_CAPTURE, test that it handles it
         * well.
         */
    if (canResolveIntent(ByodHelperActivity.getCaptureVideoIntent())) {
        // Capture video intent can be resolved in primary profile, so test.
        mCrossProfileVideoCaptureWithExtraOutputSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_video_support_with_extra_output, "BYOD_CrossProfileVideoCaptureWithExtraOutputSupportTest", R.string.provisioning_byod_capture_video_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT));
        adapter.add(mCrossProfileVideoCaptureWithExtraOutputSupportTest);
        mCrossProfileVideoCaptureWithoutExtraOutputSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_video_support_without_extra_output, "BYOD_CrossProfileVideoCaptureWithoutExtraOutputSupportTest", R.string.provisioning_byod_capture_video_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT));
        adapter.add(mCrossProfileVideoCaptureWithoutExtraOutputSupportTest);
    } else {
        // Capture video intent cannot be resolved in primary profile, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_video_capture_resolver, Toast.LENGTH_SHORT).show();
    }
    if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC)) {
        mDisableNfcBeamTest = new DialogTestListItem(this, R.string.provisioning_byod_nfc_beam, "BYOD_DisableNfcBeamTest", R.string.provisioning_byod_nfc_beam_allowed_instruction, new Intent(ByodHelperActivity.ACTION_TEST_NFC_BEAM)) {

            @Override
            public void performTest(final DialogTestListActivity activity) {
                activity.showManualTestDialog(mDisableNfcBeamTest, new DefaultTestCallback(mDisableNfcBeamTest) {

                    @Override
                    public void onPass() {
                        // Start a second test with beam disallowed by policy.
                        Intent testNfcBeamIntent = new Intent(ByodHelperActivity.ACTION_TEST_NFC_BEAM);
                        testNfcBeamIntent.putExtra(NfcTestActivity.EXTRA_DISALLOW_BY_POLICY, true);
                        DialogTestListItem disableNfcBeamTest2 = new DialogTestListItem(activity, R.string.provisioning_byod_nfc_beam, "BYOD_DisableNfcBeamTest", R.string.provisioning_byod_nfc_beam_disallowed_instruction, testNfcBeamIntent);
                        // The result should be reflected on the original test.
                        activity.showManualTestDialog(disableNfcBeamTest2, new DefaultTestCallback(mDisableNfcBeamTest));
                    }
                });
            }
        };
        adapter.add(mDisableNfcBeamTest);
    }
    /* If there is an application that handles RECORD_SOUND_ACTION, test that it handles it
         * well.
         */
    if (canResolveIntent(ByodHelperActivity.getCaptureAudioIntent())) {
        // Capture audio intent can be resolved in primary profile, so test.
        mCrossProfileAudioCaptureSupportTest = new DialogTestListItem(this, R.string.provisioning_byod_capture_audio_support, "BYOD_CrossProfileAudioCaptureSupportTest", R.string.provisioning_byod_capture_audio_support_info, new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO));
        adapter.add(mCrossProfileAudioCaptureSupportTest);
    } else {
        // Capture audio intent cannot be resolved in primary profile, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_audio_capture_resolver, Toast.LENGTH_SHORT).show();
    }
    if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION_GPS)) {
        mEnableLocationModeTest = new DialogTestListItem(this, R.string.provisioning_byod_location_mode_enable, "BYOD_LocationModeEnableTest", R.string.provisioning_byod_location_mode_enable_instruction, new Intent(ByodHelperActivity.ACTION_BYOD_SET_LOCATION_AND_CHECK_UPDATES));
        mDisableLocationModeThroughMainSwitchTest = new DialogTestListItem(this, R.string.provisioning_byod_location_mode_disable, "BYOD_LocationModeDisableMainTest", R.string.provisioning_byod_location_mode_disable_instruction, new Intent(ByodHelperActivity.ACTION_BYOD_SET_LOCATION_AND_CHECK_UPDATES));
        mDisableLocationModeThroughWorkSwitchTest = new DialogTestListItem(this, R.string.provisioning_byod_work_location_mode_disable, "BYOD_LocationModeDisableWorkTest", R.string.provisioning_byod_work_location_mode_disable_instruction, new Intent(ByodHelperActivity.ACTION_BYOD_SET_LOCATION_AND_CHECK_UPDATES));
        mPrimaryLocationWhenWorkDisabledTest = new DialogTestListItem(this, R.string.provisioning_byod_primary_location_when_work_disabled, "BYOD_PrimaryLocationWhenWorkDisabled", R.string.provisioning_byod_primary_location_when_work_disabled_instruction, new Intent(LocationListenerActivity.ACTION_SET_LOCATION_AND_CHECK_UPDATES));
        adapter.add(mEnableLocationModeTest);
        adapter.add(mDisableLocationModeThroughMainSwitchTest);
        adapter.add(mDisableLocationModeThroughWorkSwitchTest);
        adapter.add(mPrimaryLocationWhenWorkDisabledTest);
    } else {
        // The system does not support GPS feature, so skip test.
        Toast.makeText(ByodFlowTestActivity.this, R.string.provisioning_byod_no_gps_location_feature, Toast.LENGTH_SHORT).show();
    }
}
#end_block

#method_before
@Override
protected boolean refreshUi() {
    try {
        if (mPackageInfo == null || mPm.getPackageInfo(mPackageName, 0) == null) {
            return false;
        }
    } catch (NameNotFoundException e) {
        return false;
    }
    mUsageState = mUsageBridge.getUsageInfo(mPackageName, mPackageInfo.applicationInfo.uid);
    boolean hasAccess = mUsageState.isPermissible();
    mSwitchPref.setChecked(hasAccess);
    mSwitchPref.setEnabled(mUsageState.permissionDeclared);
    mUsagePrefs.setEnabled(hasAccess);
    ResolveInfo resolveInfo = mPm.resolveActivityAsUser(mSettingsIntent, PackageManager.GET_META_DATA, mUserId);
    if (resolveInfo != null) {
        if (findPreference(KEY_APP_OPS_SETTINGS_PREFS) == null) {
            getPreferenceScreen().addPreference(mUsagePrefs);
        }
        Bundle metaData = resolveInfo.activityInfo.metaData;
        mSettingsIntent.setComponent(new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name));
        if (metaData != null && metaData.containsKey(Settings.METADATA_USAGE_ACCESS_REASON)) {
            mSwitchPref.setSummary(metaData.getString(Settings.METADATA_USAGE_ACCESS_REASON));
        }
    } else {
        if (findPreference(KEY_APP_OPS_SETTINGS_PREFS) != null) {
            getPreferenceScreen().removePreference(mUsagePrefs);
        }
    }
    return true;
}
#method_after
@Override
protected boolean refreshUi() {
    if (mPackageInfo == null) {
        return false;
    }
    mUsageState = mUsageBridge.getUsageInfo(mPackageName, mPackageInfo.applicationInfo.uid);
    boolean hasAccess = mUsageState.isPermissible();
    mSwitchPref.setChecked(hasAccess);
    mSwitchPref.setEnabled(mUsageState.permissionDeclared);
    mUsagePrefs.setEnabled(hasAccess);
    ResolveInfo resolveInfo = mPm.resolveActivityAsUser(mSettingsIntent, PackageManager.GET_META_DATA, mUserId);
    if (resolveInfo != null) {
        if (findPreference(KEY_APP_OPS_SETTINGS_PREFS) == null) {
            getPreferenceScreen().addPreference(mUsagePrefs);
        }
        Bundle metaData = resolveInfo.activityInfo.metaData;
        mSettingsIntent.setComponent(new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name));
        if (metaData != null && metaData.containsKey(Settings.METADATA_USAGE_ACCESS_REASON)) {
            mSwitchPref.setSummary(metaData.getString(Settings.METADATA_USAGE_ACCESS_REASON));
        }
    } else {
        if (findPreference(KEY_APP_OPS_SETTINGS_PREFS) != null) {
            getPreferenceScreen().removePreference(mUsagePrefs);
        }
    }
    return true;
}
#end_block

#method_before
private static int compareBooleansSmali(boolean x, boolean y) {
    try {
        Class<?> c = Class.forName("Smali");
        Method m = c.getMethod("compareBooleans", boolean.class, boolean.class);
        return (Integer) m.invoke(null, x, y);
    } catch (Exception ex) {
        throw new Error(ex);
    }
}
#method_after
private static int compareBooleansSmali(boolean x, boolean y) throws Exception {
    Class<?> c = Class.forName("Smali");
    Method m = c.getMethod("compareBooleans", boolean.class, boolean.class);
    return (Integer) m.invoke(null, x, y);
}
#end_block

#method_before
public static void testCompareBooleans() {
    expectEquals(-1, compareBooleans(false, true));
    expectEquals(-1, compareBooleansSmali(false, true));
    expectEquals(0, compareBooleans(false, false));
    expectEquals(0, compareBooleans(true, true));
    expectEquals(0, compareBooleansSmali(false, false));
    expectEquals(0, compareBooleansSmali(true, true));
    expectEquals(1, compareBooleans(true, false));
    expectEquals(1, compareBooleansSmali(true, false));
}
#method_after
public static void testCompareBooleans() throws Exception {
    expectEquals(-1, compareBooleans(false, true));
    expectEquals(-1, compareBooleansSmali(false, true));
    expectEquals(0, compareBooleans(false, false));
    expectEquals(0, compareBooleans(true, true));
    expectEquals(0, compareBooleansSmali(false, false));
    expectEquals(0, compareBooleansSmali(true, true));
    expectEquals(1, compareBooleans(true, false));
    expectEquals(1, compareBooleansSmali(true, false));
}
#end_block

#method_before
public static void main(String[] args) {
    $opt$noinline$testReplaceInputWithItself(42);
    testCompareBooleans();
    testCompareBytes();
    testCompareShorts();
    testCompareChars();
    testCompareInts();
    testCompareLongs();
    testCompareByteShort();
    testCompareByteChar();
    testCompareByteInt();
    testCompareShortByte();
    testCompareShortChar();
    testCompareShortInt();
    testCompareCharByte();
    testCompareCharShort();
    testCompareCharInt();
    testCompareIntByte();
    testCompareIntShort();
    testCompareIntChar();
    System.out.println("passed");
}
#method_after
public static void main(String[] args) throws Exception {
    $opt$noinline$testReplaceInputWithItself(42);
    testCompareBooleans();
    testCompareBytes();
    testCompareShorts();
    testCompareChars();
    testCompareInts();
    testCompareLongs();
    testCompareByteShort();
    testCompareByteChar();
    testCompareByteInt();
    testCompareShortByte();
    testCompareShortChar();
    testCompareShortInt();
    testCompareCharByte();
    testCompareCharShort();
    testCompareCharInt();
    testCompareIntByte();
    testCompareIntShort();
    testCompareIntChar();
    System.out.println("passed");
}
#end_block

#method_before
public void onKeyguardOccludedChanged(boolean keyguardOccluded) {
    mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);
}
#method_after
public void onKeyguardOccludedChanged(boolean keyguardOccluded) {
    if (mNavigationBar != null) {
        mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);
    }
}
#end_block

#method_before
public boolean onBackPressed() {
    if (mStatusBarKeyguardViewManager.onBackPressed()) {
        return true;
    }
    if (mNotificationPanel.isQsExpanded()) {
        if (mNotificationPanel.isQsDetailShowing()) {
            mNotificationPanel.closeQsDetail();
        } else {
            mNotificationPanel.animateCloseQs();
        }
        return true;
    }
    if (mState != StatusBarState.KEYGUARD && mState != StatusBarState.SHADE_LOCKED) {
        animateCollapsePanels();
        return true;
    }
    if (mKeyguardUserSwitcher.hideIfNotSimple(true)) {
        return true;
    }
    return false;
}
#method_after
public boolean onBackPressed() {
    if (mStatusBarKeyguardViewManager.onBackPressed()) {
        return true;
    }
    if (mNotificationPanel.isQsExpanded()) {
        if (mNotificationPanel.isQsDetailShowing()) {
            mNotificationPanel.closeQsDetail();
        } else {
            mNotificationPanel.animateCloseQs();
        }
        return true;
    }
    if (mState != StatusBarState.KEYGUARD && mState != StatusBarState.SHADE_LOCKED) {
        animateCollapsePanels();
        return true;
    }
    if (mKeyguardUserSwitcher != null && mKeyguardUserSwitcher.hideIfNotSimple(true)) {
        return true;
    }
    return false;
}
#end_block

#method_before
public NavigationBarView getNavigationBarView() {
    if (mNavigationBar != null)
        return (NavigationBarView) mNavigationBar.getView();
    else
        return null;
}
#method_after
public NavigationBarView getNavigationBarView() {
    return (mNavigationBar != null) ? (NavigationBarView) mNavigationBar.getView() : null;
}
#end_block

#method_before
@Override
public void addAccount(IAccountAuthenticatorResponse response, String accountType, String authTokenType, String[] features, Bundle options) throws RemoteException {
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "addAccount: accountType " + accountType + ", authTokenType " + authTokenType + ", features " + (features == null ? "[]" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, "addAccount: result " + AccountManager.sanitizeResult(result));
        }
        response.onResult(result);
    } catch (Exception e) {
        handleException(response, "addAccount", accountType, e);
    }
}
#method_after
@Override
public void addAccount(IAccountAuthenticatorResponse response, String accountType, String authTokenType, String[] features, Bundle options) throws RemoteException {
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "addAccount: accountType " + accountType + ", authTokenType " + authTokenType + ", features " + (features == null ? "[]" : Arrays.toString(features)));
    }
    checkBinderPermission();
    try {
        final Bundle result = AbstractAccountAuthenticator.this.addAccount(new AccountAuthenticatorResponse(response), accountType, authTokenType, features, options);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            if (result != null) {
                // force it to be unparcelled
                result.keySet();
            }
            Log.v(TAG, "addAccount: result " + AccountManager.sanitizeResult(result));
        }
        if (result != null) {
            response.onResult(result);
        } else {
            response.onError(AccountManager.ERROR_CODE_INVALID_RESPONSE, "null bundle returned");
        }
    } catch (Exception e) {
        handleException(response, "addAccount", accountType, e);
    }
}
#end_block

#method_before
private void openChannel(int aidId) {
    // Send open logical channel request.
    String mAID = (aidId == 0) ? ARAD_AID : ARAM_AID;
    int p2 = 0x00;
    mUiccCard.iccOpenLogicalChannel(mAID, p2, /* supported p2 value */
    obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, 0, aidId, null));
}
#method_after
private void openChannel(int aidId) {
    // Send open logical channel request.
    String aid = (aidId == ARAD) ? ARAD_AID : ARAM_AID;
    int p2 = 0x00;
    mUiccCard.iccOpenLogicalChannel(aid, p2, /* supported p2 value */
    obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, 0, aidId, null));
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    // 0 means ARA-D and 1 means ARA-M.
    mAIDInUse = msg.arg2;
    switch(msg.what) {
        case EVENT_OPEN_LOGICAL_CHANNEL_DONE:
            log("EVENT_OPEN_LOGICAL_CHANNEL_DONE");
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mChannelId = ((int[]) ar.result)[0];
                mUiccCard.iccTransmitApduLogicalChannel(mChannelId, CLA, COMMAND, P1, P2, P3, DATA, obtainMessage(EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE, mChannelId, mAIDInUse));
            } else {
                // so we retry up to MAX_RETRY times, with an interval of RETRY_INTERVAL_MS.
                if (ar.exception instanceof CommandException && mRetryCount < MAX_RETRY && ((CommandException) (ar.exception)).getCommandError() == CommandException.Error.MISSING_RESOURCE) {
                    mRetryCount++;
                    removeCallbacks(mRetryRunnable);
                    postDelayed(mRetryRunnable, RETRY_INTERVAL_MS);
                } else {
                    if (mAIDInUse == 0) {
                        // Open logical channel with ARA_M.
                        mRules = "";
                        openChannel(1);
                    }
                    if (mAIDInUse == 1) {
                        if (mCheckedRules) {
                            updateState(STATE_LOADED, "Success!");
                        } else {
                            // if rules cannot be read from both ARA_D and ARA_M applet,
                            // fallback to PKCS15-based ARF.
                            log("No ARA, try ARF next.");
                            mUiccPkcs15 = new UiccPkcs15(mUiccCard, obtainMessage(EVENT_PKCS15_READ_DONE));
                        }
                    }
                }
            }
            break;
        case EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE:
            log("EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE");
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                IccIoResult response = (IccIoResult) ar.result;
                if (response.sw1 == 0x90 && response.sw2 == 0x00 && response.payload != null && response.payload.length > 0) {
                    try {
                        mRules += IccUtils.bytesToHexString(response.payload).toUpperCase(Locale.US);
                        if (isDataComplete()) {
                            mAccessRules.addAll(parseRules(mRules));
                            if (mAIDInUse == 0) {
                                mCheckedRules = true;
                            }
                        } else {
                            mUiccCard.iccTransmitApduLogicalChannel(mChannelId, CLA, COMMAND, P1, P2_EXTENDED_DATA, P3, DATA, obtainMessage(EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE, mChannelId, mAIDInUse));
                            break;
                        }
                    } catch (IllegalArgumentException | IndexOutOfBoundsException ex) {
                        updateState(STATE_ERROR, "Error parsing rules: " + ex);
                    }
                } else {
                    String errorMsg = "Invalid response: payload=" + response.payload + " sw1=" + response.sw1 + " sw2=" + response.sw2;
                    updateState(STATE_ERROR, errorMsg);
                }
            } else {
                updateState(STATE_ERROR, "Error reading value from SIM.");
            }
            mUiccCard.iccCloseLogicalChannel(mChannelId, obtainMessage(EVENT_CLOSE_LOGICAL_CHANNEL_DONE, 0, mAIDInUse));
            mChannelId = -1;
            break;
        case EVENT_CLOSE_LOGICAL_CHANNEL_DONE:
            log("EVENT_CLOSE_LOGICAL_CHANNEL_DONE");
            if (mAIDInUse == 0) {
                // Close logical channel with ARA_D and then open logical channel with ARA_M.
                mRules = "";
                openChannel(1);
            } else {
                updateState(STATE_LOADED, "Success!");
            }
            break;
        case EVENT_PKCS15_READ_DONE:
            log("EVENT_PKCS15_READ_DONE");
            if (mUiccPkcs15 == null || mUiccPkcs15.getRules() == null) {
                updateState(STATE_ERROR, "No ARA or ARF.");
            } else {
                for (String cert : mUiccPkcs15.getRules()) {
                    AccessRule accessRule = new AccessRule(IccUtils.hexStringToBytes(cert), "", 0x00);
                    mAccessRules.add(accessRule);
                }
                updateState(STATE_LOADED, "Success!");
            }
            break;
        default:
            Rlog.e(LOG_TAG, "Unknown event " + msg.what);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    // 0 means ARA-D and 1 means ARA-M.
    mAIDInUse = msg.arg2;
    switch(msg.what) {
        case EVENT_OPEN_LOGICAL_CHANNEL_DONE:
            log("EVENT_OPEN_LOGICAL_CHANNEL_DONE");
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mChannelId = ((int[]) ar.result)[0];
                mUiccCard.iccTransmitApduLogicalChannel(mChannelId, CLA, COMMAND, P1, P2, P3, DATA, obtainMessage(EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE, mChannelId, mAIDInUse));
            } else {
                // so we retry up to MAX_RETRY times, with an interval of RETRY_INTERVAL_MS.
                if (ar.exception instanceof CommandException && mRetryCount < MAX_RETRY && ((CommandException) (ar.exception)).getCommandError() == CommandException.Error.MISSING_RESOURCE) {
                    mRetryCount++;
                    removeCallbacks(mRetryRunnable);
                    postDelayed(mRetryRunnable, RETRY_INTERVAL_MS);
                } else {
                    if (mAIDInUse == ARAD) {
                        // Open logical channel with ARA_M.
                        mRules = "";
                        openChannel(1);
                    }
                    if (mAIDInUse == ARAM) {
                        if (mCheckedRules) {
                            updateState(STATE_LOADED, "Success!");
                        } else {
                            // if rules cannot be read from both ARA_D and ARA_M applet,
                            // fallback to PKCS15-based ARF.
                            log("No ARA, try ARF next.");
                            mUiccPkcs15 = new UiccPkcs15(mUiccCard, obtainMessage(EVENT_PKCS15_READ_DONE));
                        }
                    }
                }
            }
            break;
        case EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE:
            log("EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE");
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                IccIoResult response = (IccIoResult) ar.result;
                if (response.sw1 == 0x90 && response.sw2 == 0x00 && response.payload != null && response.payload.length > 0) {
                    try {
                        mRules += IccUtils.bytesToHexString(response.payload).toUpperCase(Locale.US);
                        if (isDataComplete()) {
                            mAccessRules.addAll(parseRules(mRules));
                            if (mAIDInUse == ARAD) {
                                mCheckedRules = true;
                            } else {
                                updateState(STATE_LOADED, "Success!");
                            }
                        } else {
                            mUiccCard.iccTransmitApduLogicalChannel(mChannelId, CLA, COMMAND, P1, P2_EXTENDED_DATA, P3, DATA, obtainMessage(EVENT_TRANSMIT_LOGICAL_CHANNEL_DONE, mChannelId, mAIDInUse));
                            break;
                        }
                    } catch (IllegalArgumentException | IndexOutOfBoundsException ex) {
                        if (mAIDInUse == ARAM) {
                            updateState(STATE_ERROR, "Error parsing rules: " + ex);
                        }
                    }
                } else {
                    if (mAIDInUse == ARAM) {
                        String errorMsg = "Invalid response: payload=" + response.payload + " sw1=" + response.sw1 + " sw2=" + response.sw2;
                        updateState(STATE_ERROR, errorMsg);
                    }
                }
            } else {
                if (mAIDInUse == ARAM) {
                    updateState(STATE_ERROR, "Error reading value from SIM.");
                }
            }
            mUiccCard.iccCloseLogicalChannel(mChannelId, obtainMessage(EVENT_CLOSE_LOGICAL_CHANNEL_DONE, 0, mAIDInUse));
            mChannelId = -1;
            break;
        case EVENT_CLOSE_LOGICAL_CHANNEL_DONE:
            log("EVENT_CLOSE_LOGICAL_CHANNEL_DONE");
            if (mAIDInUse == ARAD) {
                // Close logical channel with ARA_D and then open logical channel with ARA_M.
                mRules = "";
                openChannel(1);
            }
            break;
        case EVENT_PKCS15_READ_DONE:
            log("EVENT_PKCS15_READ_DONE");
            if (mUiccPkcs15 == null || mUiccPkcs15.getRules() == null) {
                updateState(STATE_ERROR, "No ARA or ARF.");
            } else {
                for (String cert : mUiccPkcs15.getRules()) {
                    AccessRule accessRule = new AccessRule(IccUtils.hexStringToBytes(cert), "", 0x00);
                    mAccessRules.add(accessRule);
                }
                updateState(STATE_LOADED, "Success!");
            }
            break;
        default:
            Rlog.e(LOG_TAG, "Unknown event " + msg.what);
    }
}
#end_block

#method_before
private static AccessRule parseRefArdo(String rule) {
    log("Got rule: " + rule);
    String certificateHash = null;
    String packageName = null;
    String tmp = null;
    long accessType = 0;
    while (!rule.isEmpty()) {
        if (rule.startsWith(TAG_REF_DO)) {
            // E1
            TLV refDo = new TLV(TAG_REF_DO);
            rule = refDo.parse(rule, false);
            // Skip unrelated rules.
            if (!refDo.value.startsWith(TAG_DEVICE_APP_ID_REF_DO)) {
                return null;
            }
            // C1
            TLV deviceDo = new TLV(TAG_DEVICE_APP_ID_REF_DO);
            tmp = deviceDo.parse(refDo.value, false);
            certificateHash = deviceDo.value;
            if (!tmp.isEmpty()) {
                if (!tmp.startsWith(TAG_PKG_REF_DO)) {
                    return null;
                }
                // CA
                TLV pkgDo = new TLV(TAG_PKG_REF_DO);
                pkgDo.parse(tmp, true);
                packageName = new String(IccUtils.hexStringToBytes(pkgDo.value));
            } else {
                packageName = null;
            }
        } else if (rule.startsWith(TAG_AR_DO)) {
            // E3
            TLV arDo = new TLV(TAG_AR_DO);
            rule = arDo.parse(rule, false);
            // Skip unrelated rules.
            if (!arDo.value.startsWith(TAG_PERM_AR_DO)) {
                return null;
            }
            // DB
            TLV permDo = new TLV(TAG_PERM_AR_DO);
            permDo.parse(arDo.value, true);
        } else {
            // Spec requires it must be either TAG_REF_DO or TAG_AR_DO.
            throw new RuntimeException("Invalid Rule type");
        }
    }
    AccessRule accessRule = new AccessRule(IccUtils.hexStringToBytes(certificateHash), packageName, accessType);
    return accessRule;
}
#method_after
private static AccessRule parseRefArdo(String rule) {
    log("Got rule: " + rule);
    String certificateHash = null;
    String packageName = null;
    String tmp = null;
    long accessType = 0;
    while (!rule.isEmpty()) {
        if (rule.startsWith(TAG_REF_DO)) {
            // E1
            TLV refDo = new TLV(TAG_REF_DO);
            rule = refDo.parse(rule, false);
            // Allow 4F tag with a default value "FF FF FF FF FF FF" to be compatible with
            // devices having GP access control enforcer:
            // - If no 4F tag is present, it's a CP rule.
            // - If 4F tag has value "FF FF FF FF FF FF", it's a CP rule.
            // - If 4F tag has other values, it's not a CP rule and Android should ignore it.
            // C1
            TLV deviceDo = new TLV(TAG_DEVICE_APP_ID_REF_DO);
            if (refDo.value.startsWith(TAG_AID_REF_DO)) {
                // 4F
                TLV cpDo = new TLV(TAG_AID_REF_DO);
                String remain = cpDo.parse(refDo.value, false);
                if (!cpDo.lengthBytes.equals("06") || !cpDo.value.equals(CARRIER_PRIVILEGE_AID) || remain.isEmpty() || !remain.startsWith(TAG_DEVICE_APP_ID_REF_DO)) {
                    return null;
                }
                tmp = deviceDo.parse(remain, false);
                certificateHash = deviceDo.value;
            } else if (refDo.value.startsWith(TAG_DEVICE_APP_ID_REF_DO)) {
                tmp = deviceDo.parse(refDo.value, false);
                certificateHash = deviceDo.value;
            } else {
                return null;
            }
            if (!tmp.isEmpty()) {
                if (!tmp.startsWith(TAG_PKG_REF_DO)) {
                    return null;
                }
                // CA
                TLV pkgDo = new TLV(TAG_PKG_REF_DO);
                pkgDo.parse(tmp, true);
                packageName = new String(IccUtils.hexStringToBytes(pkgDo.value));
            } else {
                packageName = null;
            }
        } else if (rule.startsWith(TAG_AR_DO)) {
            // E3
            TLV arDo = new TLV(TAG_AR_DO);
            rule = arDo.parse(rule, false);
            // Skip all the irrelevant tags (All the optional tags here are two bytes
            // according to the spec GlobalPlatform Secure Element Access Control).
            String remain = arDo.value;
            while (!remain.isEmpty() && !remain.startsWith(TAG_PERM_AR_DO)) {
                TLV tmpDo = new TLV(remain.substring(0, 2));
                remain = tmpDo.parse(remain, false);
            }
            if (remain.isEmpty()) {
                return null;
            }
            // DB
            TLV permDo = new TLV(TAG_PERM_AR_DO);
            permDo.parse(remain, true);
        } else {
            // Spec requires it must be either TAG_REF_DO or TAG_AR_DO.
            throw new RuntimeException("Invalid Rule type");
        }
    }
    AccessRule accessRule = new AccessRule(IccUtils.hexStringToBytes(certificateHash), packageName, accessType);
    return accessRule;
}
#end_block

#method_before
@Deprecated
public static String calledPartyBCDToString(byte[] bytes, int offset, int length) {
    return calledPartyBCDToString(bytes, offset, length, BCDExtendedType.EF_ADN);
}
#method_after
@Deprecated
public static String calledPartyBCDToString(byte[] bytes, int offset, int length) {
    return calledPartyBCDToString(bytes, offset, length, BCD_EXTENDED_TYPE_EF_ADN);
}
#end_block

#method_before
public static String calledPartyBCDToString(byte[] bytes, int offset, int length, BCDExtendedType bcdExtType) {
    boolean prependPlus = false;
    StringBuilder ret = new StringBuilder(1 + length * 2);
    if (length < 2) {
        return "";
    }
    // Only TON field should be taken in consideration
    if ((bytes[offset] & 0xf0) == (TOA_International & 0xf0)) {
        prependPlus = true;
    }
    internalCalledPartyBCDFragmentToString(ret, bytes, offset + 1, length - 1, bcdExtType);
    if (prependPlus && ret.length() == 0) {
        // If the only thing there is a prepended plus, return ""
        return "";
    }
    if (prependPlus) {
        // This is an "international number" and should have
        // a plus prepended to the dialing number. But there
        // can also be GSM MMI codes as defined in TS 22.030 6.5.2
        // so we need to handle those also.
        // 
        // http://web.telia.com/~u47904776/gsmkode.htm
        // has a nice list of some of these GSM codes.
        // 
        // Examples are:
        // **21*+886988171479#
        // **21*8311234567#
        // *21#
        // #21#
        // *#21#
        // *31#+11234567890
        // #31#+18311234567
        // #31#8311234567
        // 18311234567
        // +18311234567#
        // +18311234567
        // Odd ball cases that some phones handled
        // where there is no dialing number so they
        // append the "+"
        // *21#+
        // **21#+
        String retString = ret.toString();
        Pattern p = Pattern.compile("(^[#*])(.*)([#*])(.*)(#)$");
        Matcher m = p.matcher(retString);
        if (m.matches()) {
            if ("".equals(m.group(2))) {
                // Started with two [#*] ends with #
                // So no dialing number and we'll just
                // append a +, this handles **21#+
                ret = new StringBuilder();
                ret.append(m.group(1));
                ret.append(m.group(3));
                ret.append(m.group(4));
                ret.append(m.group(5));
                ret.append("+");
            } else {
                // Starts with [#*] and ends with #
                // Assume group 4 is a dialing number
                // such as *21*+1234554#
                ret = new StringBuilder();
                ret.append(m.group(1));
                ret.append(m.group(2));
                ret.append(m.group(3));
                ret.append("+");
                ret.append(m.group(4));
                ret.append(m.group(5));
            }
        } else {
            p = Pattern.compile("(^[#*])(.*)([#*])(.*)");
            m = p.matcher(retString);
            if (m.matches()) {
                // Starts with [#*] and only one other [#*]
                // Assume the data after last [#*] is dialing
                // number (i.e. group 4) such as *31#+11234567890.
                // This also includes the odd ball *21#+
                ret = new StringBuilder();
                ret.append(m.group(1));
                ret.append(m.group(2));
                ret.append(m.group(3));
                ret.append("+");
                ret.append(m.group(4));
            } else {
                // Does NOT start with [#*] just prepend '+'
                ret = new StringBuilder();
                ret.append('+');
                ret.append(retString);
            }
        }
    }
    return ret.toString();
}
#method_after
public static String calledPartyBCDToString(byte[] bytes, int offset, int length, int bcdExtType) {
    boolean prependPlus = false;
    StringBuilder ret = new StringBuilder(1 + length * 2);
    if (length < 2) {
        return "";
    }
    // Only TON field should be taken in consideration
    if ((bytes[offset] & 0xf0) == (TOA_International & 0xf0)) {
        prependPlus = true;
    }
    internalCalledPartyBCDFragmentToString(ret, bytes, offset + 1, length - 1, bcdExtType);
    if (prependPlus && ret.length() == 0) {
        // If the only thing there is a prepended plus, return ""
        return "";
    }
    if (prependPlus) {
        // This is an "international number" and should have
        // a plus prepended to the dialing number. But there
        // can also be GSM MMI codes as defined in TS 22.030 6.5.2
        // so we need to handle those also.
        // 
        // http://web.telia.com/~u47904776/gsmkode.htm
        // has a nice list of some of these GSM codes.
        // 
        // Examples are:
        // **21*+886988171479#
        // **21*8311234567#
        // *21#
        // #21#
        // *#21#
        // *31#+11234567890
        // #31#+18311234567
        // #31#8311234567
        // 18311234567
        // +18311234567#
        // +18311234567
        // Odd ball cases that some phones handled
        // where there is no dialing number so they
        // append the "+"
        // *21#+
        // **21#+
        String retString = ret.toString();
        Pattern p = Pattern.compile("(^[#*])(.*)([#*])(.*)(#)$");
        Matcher m = p.matcher(retString);
        if (m.matches()) {
            if ("".equals(m.group(2))) {
                // Started with two [#*] ends with #
                // So no dialing number and we'll just
                // append a +, this handles **21#+
                ret = new StringBuilder();
                ret.append(m.group(1));
                ret.append(m.group(3));
                ret.append(m.group(4));
                ret.append(m.group(5));
                ret.append("+");
            } else {
                // Starts with [#*] and ends with #
                // Assume group 4 is a dialing number
                // such as *21*+1234554#
                ret = new StringBuilder();
                ret.append(m.group(1));
                ret.append(m.group(2));
                ret.append(m.group(3));
                ret.append("+");
                ret.append(m.group(4));
                ret.append(m.group(5));
            }
        } else {
            p = Pattern.compile("(^[#*])(.*)([#*])(.*)");
            m = p.matcher(retString);
            if (m.matches()) {
                // Starts with [#*] and only one other [#*]
                // Assume the data after last [#*] is dialing
                // number (i.e. group 4) such as *31#+11234567890.
                // This also includes the odd ball *21#+
                ret = new StringBuilder();
                ret.append(m.group(1));
                ret.append(m.group(2));
                ret.append(m.group(3));
                ret.append("+");
                ret.append(m.group(4));
            } else {
                // Does NOT start with [#*] just prepend '+'
                ret = new StringBuilder();
                ret.append('+');
                ret.append(retString);
            }
        }
    }
    return ret.toString();
}
#end_block

#method_before
private static void internalCalledPartyBCDFragmentToString(StringBuilder sb, byte[] bytes, int offset, int length, BCDExtendedType bcdExtType) {
    for (int i = offset; i < length + offset; i++) {
        byte b;
        char c;
        c = bcdToChar((byte) (bytes[i] & 0xf), bcdExtType);
        if (c == 0) {
            return;
        }
        sb.append(c);
        // FIXME(mkf) TS 23.040 9.1.2.3 says
        // "if a mobile receives 1111 in a position prior to
        // the last semi-octet then processing shall commence with
        // the next semi-octet and the intervening
        // semi-octet shall be ignored"
        // How does this jive with 24.008 10.5.4.7
        b = (byte) ((bytes[i] >> 4) & 0xf);
        if (b == 0xf && i + 1 == length + offset) {
            // ignore final 0xf
            break;
        }
        c = bcdToChar(b, bcdExtType);
        if (c == 0) {
            return;
        }
        sb.append(c);
    }
}
#method_after
private static void internalCalledPartyBCDFragmentToString(StringBuilder sb, byte[] bytes, int offset, int length, int bcdExtType) {
    for (int i = offset; i < length + offset; i++) {
        byte b;
        char c;
        c = bcdToChar((byte) (bytes[i] & 0xf), bcdExtType);
        if (c == 0) {
            return;
        }
        sb.append(c);
        // FIXME(mkf) TS 23.040 9.1.2.3 says
        // "if a mobile receives 1111 in a position prior to
        // the last semi-octet then processing shall commence with
        // the next semi-octet and the intervening
        // semi-octet shall be ignored"
        // How does this jive with 24.008 10.5.4.7
        b = (byte) ((bytes[i] >> 4) & 0xf);
        if (b == 0xf && i + 1 == length + offset) {
            // ignore final 0xf
            break;
        }
        c = bcdToChar(b, bcdExtType);
        if (c == 0) {
            return;
        }
        sb.append(c);
    }
}
#end_block

#method_before
@Deprecated
public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length) {
    return calledPartyBCDFragmentToString(bytes, offset, length, BCDExtendedType.EF_ADN);
}
#method_after
@Deprecated
public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length) {
    return calledPartyBCDFragmentToString(bytes, offset, length, BCD_EXTENDED_TYPE_EF_ADN);
}
#end_block

#method_before
public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, BCDExtendedType bcdExtType) {
    StringBuilder ret = new StringBuilder(length * 2);
    internalCalledPartyBCDFragmentToString(ret, bytes, offset, length, bcdExtType);
    return ret.toString();
}
#method_after
public static String calledPartyBCDFragmentToString(byte[] bytes, int offset, int length, int bcdExtType) {
    StringBuilder ret = new StringBuilder(length * 2);
    internalCalledPartyBCDFragmentToString(ret, bytes, offset, length, bcdExtType);
    return ret.toString();
}
#end_block

#method_before
private static char bcdToChar(byte b, BCDExtendedType bcdExtType) {
    if (b < 0xa) {
        return (char) ('0' + b);
    }
    String extended = null;
    if (BCDExtendedType.EF_ADN.equals(bcdExtType)) {
        extended = BCD_EF_ADN_EXTENDED;
    } else if (BCDExtendedType.CALLED_PARTY.equals(bcdExtType)) {
        extended = BCD_CALLED_PARTY_EXTENDED;
    }
    if (extended == null || b - 0xa >= extended.length()) {
        return 0;
    }
    return extended.charAt(b - 0xa);
}
#method_after
private static char bcdToChar(byte b, int bcdExtType) {
    if (b < 0xa) {
        return (char) ('0' + b);
    }
    String extended = null;
    if (BCD_EXTENDED_TYPE_EF_ADN == bcdExtType) {
        extended = BCD_EF_ADN_EXTENDED;
    } else if (BCD_EXTENDED_TYPE_CALLED_PARTY == bcdExtType) {
        extended = BCD_CALLED_PARTY_EXTENDED;
    }
    if (extended == null || b - 0xa >= extended.length()) {
        return 0;
    }
    return extended.charAt(b - 0xa);
}
#end_block

#method_before
private static int charToBCD(char c, BCDExtendedType bcdExtType) {
    if ('0' <= c && c <= '9') {
        return c - '0';
    }
    String extended = null;
    if (BCDExtendedType.EF_ADN.equals(bcdExtType)) {
        extended = BCD_EF_ADN_EXTENDED;
    } else if (BCDExtendedType.CALLED_PARTY.equals(bcdExtType)) {
        extended = BCD_CALLED_PARTY_EXTENDED;
    }
    if (extended == null || extended.indexOf(c) == -1) {
        throw new RuntimeException("invalid char for BCD " + c);
    }
    return 0xa + extended.indexOf(c);
}
#method_after
private static int charToBCD(char c, int bcdExtType) {
    if ('0' <= c && c <= '9') {
        return c - '0';
    }
    String extended = null;
    if (BCD_EXTENDED_TYPE_EF_ADN == bcdExtType) {
        extended = BCD_EF_ADN_EXTENDED;
    } else if (BCD_EXTENDED_TYPE_CALLED_PARTY == bcdExtType) {
        extended = BCD_CALLED_PARTY_EXTENDED;
    }
    if (extended == null || extended.indexOf(c) == -1) {
        throw new RuntimeException("invalid char for BCD " + c);
    }
    return 0xa + extended.indexOf(c);
}
#end_block

#method_before
public static byte[] networkPortionToCalledPartyBCD(String s) {
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, false, BCDExtendedType.EF_ADN);
}
#method_after
public static byte[] networkPortionToCalledPartyBCD(String s) {
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, false, BCD_EXTENDED_TYPE_EF_ADN);
}
#end_block

#method_before
public static byte[] networkPortionToCalledPartyBCDWithLength(String s) {
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, true, BCDExtendedType.EF_ADN);
}
#method_after
public static byte[] networkPortionToCalledPartyBCDWithLength(String s) {
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, true, BCD_EXTENDED_TYPE_EF_ADN);
}
#end_block

#method_before
@Deprecated
public static byte[] numberToCalledPartyBCD(String number) {
    return numberToCalledPartyBCD(number, BCDExtendedType.EF_ADN);
}
#method_after
@Deprecated
public static byte[] numberToCalledPartyBCD(String number) {
    return numberToCalledPartyBCD(number, BCD_EXTENDED_TYPE_EF_ADN);
}
#end_block

#method_before
public static byte[] numberToCalledPartyBCD(String number, BCDExtendedType bcdExtType) {
    return numberToCalledPartyBCDHelper(number, false, bcdExtType);
}
#method_after
public static byte[] numberToCalledPartyBCD(String number, int bcdExtType) {
    return numberToCalledPartyBCDHelper(number, false, bcdExtType);
}
#end_block

#method_before
private static byte[] numberToCalledPartyBCDHelper(String number, boolean includeLength, BCDExtendedType bcdExtType) {
    int numberLenReal = number.length();
    int numberLenEffective = numberLenReal;
    boolean hasPlus = number.indexOf('+') != -1;
    if (hasPlus)
        numberLenEffective--;
    if (numberLenEffective == 0)
        return null;
    // Encoded numbers require only 4 bits each.
    int resultLen = (numberLenEffective + 1) / 2;
    // Prepended TOA byte.
    int extraBytes = 1;
    // Optional prepended length byte.
    if (includeLength)
        extraBytes++;
    resultLen += extraBytes;
    byte[] result = new byte[resultLen];
    int digitCount = 0;
    for (int i = 0; i < numberLenReal; i++) {
        char c = number.charAt(i);
        if (c == '+')
            continue;
        int shift = ((digitCount & 0x01) == 1) ? 4 : 0;
        result[extraBytes + (digitCount >> 1)] |= (byte) ((charToBCD(c, bcdExtType) & 0x0F) << shift);
        digitCount++;
    }
    // 1-fill any trailing odd nibble/quartet.
    if ((digitCount & 0x01) == 1)
        result[extraBytes + (digitCount >> 1)] |= 0xF0;
    int offset = 0;
    if (includeLength)
        result[offset++] = (byte) (resultLen - 1);
    result[offset] = (byte) (hasPlus ? TOA_International : TOA_Unknown);
    return result;
}
#method_after
private static byte[] numberToCalledPartyBCDHelper(String number, boolean includeLength, int bcdExtType) {
    int numberLenReal = number.length();
    int numberLenEffective = numberLenReal;
    boolean hasPlus = number.indexOf('+') != -1;
    if (hasPlus)
        numberLenEffective--;
    if (numberLenEffective == 0)
        return null;
    // Encoded numbers require only 4 bits each.
    int resultLen = (numberLenEffective + 1) / 2;
    // Prepended TOA byte.
    int extraBytes = 1;
    // Optional prepended length byte.
    if (includeLength)
        extraBytes++;
    resultLen += extraBytes;
    byte[] result = new byte[resultLen];
    int digitCount = 0;
    for (int i = 0; i < numberLenReal; i++) {
        char c = number.charAt(i);
        if (c == '+')
            continue;
        int shift = ((digitCount & 0x01) == 1) ? 4 : 0;
        result[extraBytes + (digitCount >> 1)] |= (byte) ((charToBCD(c, bcdExtType) & 0x0F) << shift);
        digitCount++;
    }
    // 1-fill any trailing odd nibble/quartet.
    if ((digitCount & 0x01) == 1)
        result[extraBytes + (digitCount >> 1)] |= 0xF0;
    int offset = 0;
    if (includeLength)
        result[offset++] = (byte) (resultLen - 1);
    result[offset] = (byte) (hasPlus ? TOA_International : TOA_Unknown);
    return result;
}
#end_block

#method_before
String getSCAddress() {
    int len;
    String ret;
    // length of SC Address
    len = getByte();
    if (len == 0) {
        // no SC address
        ret = null;
    } else {
        // SC address
        try {
            ret = PhoneNumberUtils.calledPartyBCDToString(mPdu, mCur, len, BCDExtendedType.CALLED_PARTY);
        } catch (RuntimeException tr) {
            Rlog.d(LOG_TAG, "invalid SC address: ", tr);
            ret = null;
        }
    }
    mCur += len;
    return ret;
}
#method_after
String getSCAddress() {
    int len;
    String ret;
    // length of SC Address
    len = getByte();
    if (len == 0) {
        // no SC address
        ret = null;
    } else {
        // SC address
        try {
            ret = PhoneNumberUtils.calledPartyBCDToString(mPdu, mCur, len, PhoneNumberUtils.BCD_EXTENDED_TYPE_CALLED_PARTY);
        } catch (RuntimeException tr) {
            Rlog.d(LOG_TAG, "invalid SC address: ", tr);
            ret = null;
        }
    }
    mCur += len;
    return ret;
}
#end_block

#method_before
void discoveryStateChangeCallback(int state) {
    infoLog("Callback:discoveryStateChangeCallback with state:" + state);
    synchronized (mObject) {
        Intent intent;
        if (state == AbstractionLayer.BT_DISCOVERY_STOPPED) {
            mDiscovering = false;
            mDiscoveryEndMs = System.currentTimeMillis();
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
            mService.sendBroadcast(intent, mService.BLUETOOTH_PERM);
        } else if (state == AbstractionLayer.BT_DISCOVERY_STARTED) {
            mDiscovering = true;
            mDiscoveryEndMs = System.currentTimeMillis() + DEFAULT_DISCOVERY_TIMEOUT_MS;
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
            mService.sendBroadcast(intent, mService.BLUETOOTH_PERM);
        }
    }
}
#method_after
void discoveryStateChangeCallback(int state) {
    infoLog("Callback:discoveryStateChangeCallback with state:" + state);
    synchronized (mObject) {
        Intent intent;
        if (state == AbstractionLayer.BT_DISCOVERY_STOPPED) {
            mDiscovering = false;
            mDiscoveryEndMs = System.currentTimeMillis();
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
            mService.sendBroadcast(intent, AdapterService.BLUETOOTH_PERM);
        } else if (state == AbstractionLayer.BT_DISCOVERY_STARTED) {
            mDiscovering = true;
            mDiscoveryEndMs = System.currentTimeMillis() + DEFAULT_DISCOVERY_TIMEOUT_MS;
            intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
            mService.sendBroadcast(intent, AdapterService.BLUETOOTH_PERM);
        }
    }
}
#end_block

#method_before
private final void closeService() {
    if (VERBOSE)
        Log.v(TAG, "Pbap Service closeService in");
    BluetoothPbapUtils.savePbapParams(this, BluetoothPbapUtils.primaryVersionCounter, BluetoothPbapUtils.secondaryVersionCounter, BluetoothPbapUtils.mDbIdentifier.get(), BluetoothPbapUtils.contactsLastUpdated, BluetoothPbapUtils.totalFields, BluetoothPbapUtils.totalSvcFields, BluetoothPbapUtils.totalContacts);
    // exit initSocket early
    mInterrupted = true;
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    if (mServerSession != null) {
        mServerSession.close();
        mServerSession = null;
    }
    closeConnectionSocket();
    closeServerSocket();
    mServerSockets.shutdown(true);
    mServerSockets = null;
    if (mSessionStatusHandler != null)
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    if (VERBOSE)
        Log.v(TAG, "Pbap Service closeService out");
}
#method_after
private final void closeService() {
    if (VERBOSE)
        Log.v(TAG, "Pbap Service closeService in");
    BluetoothPbapUtils.savePbapParams(this, BluetoothPbapUtils.primaryVersionCounter, BluetoothPbapUtils.secondaryVersionCounter, BluetoothPbapUtils.mDbIdentifier.get(), BluetoothPbapUtils.contactsLastUpdated, BluetoothPbapUtils.totalFields, BluetoothPbapUtils.totalSvcFields, BluetoothPbapUtils.totalContacts);
    // exit initSocket early
    mInterrupted = true;
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    if (mServerSession != null) {
        mServerSession.close();
        mServerSession = null;
    }
    closeConnectionSocket();
    closeServerSocket();
    if (mServerSockets != null) {
        mServerSockets.shutdown(false);
        mServerSockets = null;
    }
    if (mSessionStatusHandler != null)
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    if (VERBOSE)
        Log.v(TAG, "Pbap Service closeService out");
}
#end_block

#method_before
private void startListeningForCalls() throws ImsException {
    mImsServiceRetryCount = 0;
    mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
    mImsManager.setImsConfigListener(mImsConfigListener);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
}
#method_after
private void startListeningForCalls() throws ImsException {
    mImsServiceRetryCount = 0;
    mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
    mImsManager.setImsConfigListener(mImsConfigListener);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
    if (mCarrierConfigLoaded) {
        ImsManager.updateImsServiceConfig(mPhone.getContext(), mPhone.getPhoneId(), true);
    }
}
#end_block

#method_before
public int getPhoneCount() {
    int phoneCount = 1;
    switch(getMultiSimConfiguration()) {
        case UNKNOWN:
            phoneCount = 1;
            break;
        case DSDS:
        case DSDA:
            phoneCount = PhoneConstants.MAX_PHONE_COUNT_DUAL_SIM;
            break;
        case TSTS:
            phoneCount = PhoneConstants.MAX_PHONE_COUNT_TRI_SIM;
            break;
    }
    return phoneCount;
}
#method_after
public int getPhoneCount() {
    int phoneCount = 1;
    switch(getMultiSimConfiguration()) {
        case UNKNOWN:
            // if voice or sms or data is supported, return 1 otherwise 0
            if (isVoiceCapable() || isSmsCapable()) {
                phoneCount = 1;
            } else {
                // todo: try to clean this up further by getting rid of the nested conditions
                if (mContext == null) {
                    phoneCount = 1;
                } else {
                    // check for data support
                    ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    if (cm == null) {
                        phoneCount = 1;
                    } else {
                        if (cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE)) {
                            phoneCount = 1;
                        } else {
                            phoneCount = 0;
                        }
                    }
                }
            }
            break;
        case DSDS:
        case DSDA:
            phoneCount = PhoneConstants.MAX_PHONE_COUNT_DUAL_SIM;
            break;
        case TSTS:
            phoneCount = PhoneConstants.MAX_PHONE_COUNT_TRI_SIM;
            break;
    }
    return phoneCount;
}
#end_block

#method_before
// 
// 
// Device Info
// 
// 
public String getDeviceSoftwareVersion() {
    return getDeviceSoftwareVersion(getDefaultSim());
}
#method_after
// 
// 
// Device Info
// 
// 
public String getDeviceSoftwareVersion() {
    return getDeviceSoftwareVersion(getSlotIndex());
}
#end_block

#method_before
/**
 * Returns the software version number for the device, for example,
 * the IMEI/SV for GSM phones. Return null if the software version is
 * not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param slotId of which deviceID is returned
 */
public String getDeviceSoftwareVersion(int slotId) {
    // FIXME methods taking slot id should not use subscription, instead us Uicc directly
    int[] subId = SubscriptionManager.getSubId(slotId);
    if (subId == null || subId.length == 0) {
        return null;
    }
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getDeviceSvnUsingSubId(subId[0], mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
/**
 * Returns the software version number for the device, for example,
 * the IMEI/SV for GSM phones. Return null if the software version is
 * not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param slotIndex of which deviceID is returned
 */
public String getDeviceSoftwareVersion(int slotIndex) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getDeviceSoftwareVersionForSlot(slotIndex, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
public String getDeviceId() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return null;
        return telephony.getDeviceId(mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
@Deprecated
public String getDeviceId() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return null;
        return telephony.getDeviceId(mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
public String getDeviceId(int slotId) {
    // FIXME this assumes phoneId == slotId
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getDeviceIdForPhone(slotId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
@Deprecated
public String getDeviceId(int slotIndex) {
    // FIXME this assumes phoneId == slotIndex
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getDeviceIdForPhone(slotIndex, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
/**
 * Returns the IMEI. Return null if IMEI is not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public String getImei() {
    return getImei(getDefaultSim());
}
#method_after
public String getImei() {
    return getImei(getSlotIndex());
}
#end_block

#method_before
/**
 * Returns the IMEI. Return null if IMEI is not available.
 *
 * <p>Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param slotId of which deviceID is returned
 */
public String getImei(int slotId) {
    int[] subId = SubscriptionManager.getSubId(slotId);
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getImeiForSubscriber(subId[0], mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
public String getImei(int slotIndex) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getImeiForSlot(slotIndex, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
/**
 * Returns the NAI. Return null if NAI is not available.
 */
public String getNai() {
    return getNai(getDefaultSim());
}
#method_after
/**
 * Returns the NAI. Return null if NAI is not available.
 */
public String getNai() {
    return getNai(getSlotIndex());
}
#end_block

#method_before
/**
 * Returns the NAI. Return null if NAI is not available.
 *
 *  @param slotId of which Nai is returned
 */
public String getNai(int slotId) {
    int[] subId = SubscriptionManager.getSubId(slotId);
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        String nai = info.getNaiForSubscriber(subId[0], mContext.getOpPackageName());
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Rlog.v(TAG, "Nai = " + nai);
        }
        return nai;
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
/**
 * Returns the NAI. Return null if NAI is not available.
 *
 *  @param slotIndex of which Nai is returned
 */
public String getNai(int slotIndex) {
    int[] subId = SubscriptionManager.getSubId(slotIndex);
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        String nai = info.getNaiForSubscriber(subId[0], mContext.getOpPackageName());
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Rlog.v(TAG, "Nai = " + nai);
        }
        return nai;
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
public CellLocation getCellLocation() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null) {
            Rlog.d(TAG, "getCellLocation returning null because telephony is null");
            return null;
        }
        Bundle bundle = telephony.getCellLocation(mContext.getOpPackageName());
        if (bundle.isEmpty()) {
            Rlog.d(TAG, "getCellLocation returning null because bundle is empty");
            return null;
        }
        CellLocation cl = CellLocation.newFromBundle(bundle);
        if (cl.isEmpty()) {
            Rlog.d(TAG, "getCellLocation returning null because CellLocation is empty");
            return null;
        }
        return cl;
    } catch (RemoteException ex) {
        Rlog.d(TAG, "getCellLocation returning null due to RemoteException " + ex);
        return null;
    } catch (NullPointerException ex) {
        Rlog.d(TAG, "getCellLocation returning null due to NullPointerException " + ex);
        return null;
    }
}
#method_after
@Deprecated
public CellLocation getCellLocation() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null) {
            Rlog.d(TAG, "getCellLocation returning null because telephony is null");
            return null;
        }
        Bundle bundle = telephony.getCellLocation(mContext.getOpPackageName());
        if (bundle.isEmpty()) {
            Rlog.d(TAG, "getCellLocation returning null because bundle is empty");
            return null;
        }
        CellLocation cl = CellLocation.newFromBundle(bundle);
        if (cl.isEmpty()) {
            Rlog.d(TAG, "getCellLocation returning null because CellLocation is empty");
            return null;
        }
        return cl;
    } catch (RemoteException ex) {
        Rlog.d(TAG, "getCellLocation returning null due to RemoteException " + ex);
        return null;
    } catch (NullPointerException ex) {
        Rlog.d(TAG, "getCellLocation returning null due to NullPointerException " + ex);
        return null;
    }
}
#end_block

#method_before
public void enableLocationUpdates() {
    enableLocationUpdates(getDefaultSubscription());
}
#method_after
public void enableLocationUpdates() {
    enableLocationUpdates(getSubId());
}
#end_block

#method_before
/**
 * Enables location update notifications for a subscription.
 * {@link PhoneStateListener#onCellLocationChanged
 * PhoneStateListener.onCellLocationChanged} will be called on location updates.
 *
 * <p>Requires Permission: {@link android.Manifest.permission#CONTROL_LOCATION_UPDATES
 * CONTROL_LOCATION_UPDATES}
 *
 * @param subId for which the location updates are enabled
 */
public void enableLocationUpdates(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.enableLocationUpdatesForSubscriber(subId);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#method_after
public void enableLocationUpdates(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.enableLocationUpdatesForSubscriber(subId);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#end_block

#method_before
public void disableLocationUpdates() {
    disableLocationUpdates(getDefaultSubscription());
}
#method_after
public void disableLocationUpdates() {
    disableLocationUpdates(getSubId());
}
#end_block

#method_before
@SystemApi
public int getCurrentPhoneType() {
    return getCurrentPhoneType(getDefaultSubscription());
}
#method_after
@SystemApi
public int getCurrentPhoneType() {
    return getCurrentPhoneType(getSubId());
}
#end_block

#method_before
/**
 * Returns a constant indicating the device phone type for a subscription.
 *
 * @see #PHONE_TYPE_NONE
 * @see #PHONE_TYPE_GSM
 * @see #PHONE_TYPE_CDMA
 *
 * @param subId for which phone type is returned
 */
@SystemApi
public int getCurrentPhoneType(int subId) {
    int phoneId;
    if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
        // if we don't have any sims, we don't have subscriptions, but we
        // still may want to know what type of phone we've got.
        phoneId = 0;
    } else {
        phoneId = SubscriptionManager.getPhoneId(subId);
    }
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null && subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            return telephony.getActivePhoneTypeForSubscriber(subId);
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return getPhoneTypeFromProperty(phoneId);
        }
    } catch (RemoteException ex) {
        // read from the system property.
        return getPhoneTypeFromProperty(phoneId);
    } catch (NullPointerException ex) {
        // read from the system property.
        return getPhoneTypeFromProperty(phoneId);
    }
}
#method_after
@SystemApi
public int getCurrentPhoneType(int subId) {
    int phoneId;
    if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
        // if we don't have any sims, we don't have subscriptions, but we
        // still may want to know what type of phone we've got.
        phoneId = 0;
    } else {
        phoneId = SubscriptionManager.getPhoneId(subId);
    }
    return getCurrentPhoneTypeForSlot(phoneId);
}
#end_block

#method_before
private int getPhoneTypeFromProperty() {
    return getPhoneTypeFromProperty(getDefaultPhone());
}
#method_after
private int getPhoneTypeFromProperty() {
    return getPhoneTypeFromProperty(getPhoneId());
}
#end_block

#method_before
private int getPhoneTypeFromProperty(int phoneId) {
    String type = getTelephonyProperty(phoneId, TelephonyProperties.CURRENT_ACTIVE_PHONE, null);
    if (type == null || type.equals("")) {
        return getPhoneTypeFromNetworkType(phoneId);
    }
    return Integer.parseInt(type);
}
#method_after
private int getPhoneTypeFromProperty(int phoneId) {
    String type = getTelephonyProperty(phoneId, TelephonyProperties.CURRENT_ACTIVE_PHONE, null);
    if (type == null || type.isEmpty()) {
        return getPhoneTypeFromNetworkType(phoneId);
    }
    return Integer.parseInt(type);
}
#end_block

#method_before
private int getPhoneTypeFromNetworkType() {
    return getPhoneTypeFromNetworkType(getDefaultPhone());
}
#method_after
private int getPhoneTypeFromNetworkType() {
    return getPhoneTypeFromNetworkType(getPhoneId());
}
#end_block

#method_before
private int getPhoneTypeFromNetworkType(int phoneId) {
    // When the system property CURRENT_ACTIVE_PHONE, has not been set,
    // use the system property for default network type.
    // This is a fail safe, and can only happen at first boot.
    String mode = getTelephonyProperty(phoneId, "ro.telephony.default_network", null);
    if (mode != null) {
        return TelephonyManager.getPhoneType(Integer.parseInt(mode));
    }
    return TelephonyManager.PHONE_TYPE_NONE;
}
#method_after
private int getPhoneTypeFromNetworkType(int phoneId) {
    // When the system property CURRENT_ACTIVE_PHONE, has not been set,
    // use the system property for default network type.
    // This is a fail safe, and can only happen at first boot.
    String mode = getTelephonyProperty(phoneId, "ro.telephony.default_network", null);
    if (mode != null && !mode.isEmpty()) {
        return TelephonyManager.getPhoneType(Integer.parseInt(mode));
    }
    return TelephonyManager.PHONE_TYPE_NONE;
}
#end_block

#method_before
// 
// 
// Current Network
// 
// 
public String getNetworkOperatorName() {
    return getNetworkOperatorName(getDefaultSubscription());
}
#method_after
// 
// 
// Current Network
// 
// 
public String getNetworkOperatorName() {
    return getNetworkOperatorName(getSubId());
}
#end_block

#method_before
/**
 * Returns the alphabetic name of current registered operator
 * for a particular subscription.
 * <p>
 * Availability: Only when user is registered to a network. Result may be
 * unreliable on CDMA networks (use {@link #getPhoneType()} to determine if
 * on a CDMA network).
 * @param subId
 */
public String getNetworkOperatorName(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ALPHA, "");
}
#method_after
public String getNetworkOperatorName(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ALPHA, "");
}
#end_block

#method_before
public String getNetworkOperator() {
    return getNetworkOperatorForPhone(getDefaultPhone());
}
#method_after
public String getNetworkOperator() {
    return getNetworkOperatorForPhone(getPhoneId());
}
#end_block

#method_before
public String getNetworkOperator() {
    return getNetworkOperatorForPhone(getDefaultPhone());
}
#method_after
public String getNetworkOperator(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getNetworkOperatorForPhone(phoneId);
}
#end_block

#method_before
public boolean isNetworkRoaming() {
    return isNetworkRoaming(getDefaultSubscription());
}
#method_after
public boolean isNetworkRoaming() {
    return isNetworkRoaming(getSubId());
}
#end_block

#method_before
/**
 * Returns true if the device is considered roaming on the current
 * network for a subscription.
 * <p>
 * Availability: Only when user registered to a network.
 *
 * @param subId
 */
public boolean isNetworkRoaming(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return Boolean.parseBoolean(getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ISROAMING, null));
}
#method_after
public boolean isNetworkRoaming(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return Boolean.parseBoolean(getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ISROAMING, null));
}
#end_block

#method_before
public String getNetworkCountryIso() {
    return getNetworkCountryIsoForPhone(getDefaultPhone());
}
#method_after
public String getNetworkCountryIso() {
    return getNetworkCountryIsoForPhone(getPhoneId());
}
#end_block

#method_before
public String getNetworkCountryIso() {
    return getNetworkCountryIsoForPhone(getDefaultPhone());
}
#method_after
public String getNetworkCountryIso(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getNetworkCountryIsoForPhone(phoneId);
}
#end_block

#method_before
/**
 * Returns a constant indicating the radio technology (network type)
 * currently in use on the device for a subscription.
 * @return the network type
 *
 * @param subId for which network type is returned
 *
 * @see #NETWORK_TYPE_UNKNOWN
 * @see #NETWORK_TYPE_GPRS
 * @see #NETWORK_TYPE_EDGE
 * @see #NETWORK_TYPE_UMTS
 * @see #NETWORK_TYPE_HSDPA
 * @see #NETWORK_TYPE_HSUPA
 * @see #NETWORK_TYPE_HSPA
 * @see #NETWORK_TYPE_CDMA
 * @see #NETWORK_TYPE_EVDO_0
 * @see #NETWORK_TYPE_EVDO_A
 * @see #NETWORK_TYPE_EVDO_B
 * @see #NETWORK_TYPE_1xRTT
 * @see #NETWORK_TYPE_IDEN
 * @see #NETWORK_TYPE_LTE
 * @see #NETWORK_TYPE_EHRPD
 * @see #NETWORK_TYPE_HSPAP
 *
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public int getNetworkType(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getNetworkTypeForSubscriber(subId, getOpPackageName());
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
public int getNetworkType(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getNetworkTypeForSubscriber(subId, getOpPackageName());
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
public int getDataNetworkType() {
    return getDataNetworkType(getDefaultSubscription());
}
#method_after
public int getDataNetworkType() {
    return getDataNetworkType(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#end_block

#method_before
/**
 * Returns a constant indicating the radio technology (network type)
 * currently in use on the device for data transmission for a subscription
 * @return the network type
 *
 * @param subId for which network type is returned
 *
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public int getDataNetworkType(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getDataNetworkTypeForSubscriber(subId, getOpPackageName());
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
public int getDataNetworkType(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getDataNetworkTypeForSubscriber(subId, getOpPackageName());
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
public int getVoiceNetworkType() {
    return getVoiceNetworkType(getDefaultSubscription());
}
#method_after
public int getVoiceNetworkType() {
    return getVoiceNetworkType(getSubId());
}
#end_block

#method_before
/**
 * Returns the NETWORK_TYPE_xxxx for voice for a subId
 *
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public int getVoiceNetworkType(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getVoiceNetworkTypeForSubscriber(subId, getOpPackageName());
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
public int getVoiceNetworkType(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getVoiceNetworkTypeForSubscriber(subId, getOpPackageName());
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
public static int getNetworkClass(int networkType) {
    switch(networkType) {
        case NETWORK_TYPE_GPRS:
        case NETWORK_TYPE_GSM:
        case NETWORK_TYPE_EDGE:
        case NETWORK_TYPE_CDMA:
        case NETWORK_TYPE_1xRTT:
        case NETWORK_TYPE_IDEN:
            return NETWORK_CLASS_2_G;
        case NETWORK_TYPE_UMTS:
        case NETWORK_TYPE_EVDO_0:
        case NETWORK_TYPE_EVDO_A:
        case NETWORK_TYPE_HSDPA:
        case NETWORK_TYPE_HSUPA:
        case NETWORK_TYPE_HSPA:
        case NETWORK_TYPE_EVDO_B:
        case NETWORK_TYPE_EHRPD:
        case NETWORK_TYPE_HSPAP:
        case NETWORK_TYPE_TD_SCDMA:
            return NETWORK_CLASS_3_G;
        case NETWORK_TYPE_LTE:
        case NETWORK_TYPE_IWLAN:
            return NETWORK_CLASS_4_G;
        default:
            return NETWORK_CLASS_UNKNOWN;
    }
}
#method_after
public static int getNetworkClass(int networkType) {
    switch(networkType) {
        case NETWORK_TYPE_GPRS:
        case NETWORK_TYPE_GSM:
        case NETWORK_TYPE_EDGE:
        case NETWORK_TYPE_CDMA:
        case NETWORK_TYPE_1xRTT:
        case NETWORK_TYPE_IDEN:
            return NETWORK_CLASS_2_G;
        case NETWORK_TYPE_UMTS:
        case NETWORK_TYPE_EVDO_0:
        case NETWORK_TYPE_EVDO_A:
        case NETWORK_TYPE_HSDPA:
        case NETWORK_TYPE_HSUPA:
        case NETWORK_TYPE_HSPA:
        case NETWORK_TYPE_EVDO_B:
        case NETWORK_TYPE_EHRPD:
        case NETWORK_TYPE_HSPAP:
        case NETWORK_TYPE_TD_SCDMA:
            return NETWORK_CLASS_3_G;
        case NETWORK_TYPE_LTE:
        case NETWORK_TYPE_IWLAN:
        case NETWORK_TYPE_LTE_CA:
            return NETWORK_CLASS_4_G;
        default:
            return NETWORK_CLASS_UNKNOWN;
    }
}
#end_block

#method_before
/**
 * Returns a string representation of the radio technology (network type)
 * currently in use on the device.
 * @param subId for which network type is returned
 * @return the name of the radio technology
 */
public static String getNetworkTypeName(int type) {
    switch(type) {
        case NETWORK_TYPE_GPRS:
            return "GPRS";
        case NETWORK_TYPE_EDGE:
            return "EDGE";
        case NETWORK_TYPE_UMTS:
            return "UMTS";
        case NETWORK_TYPE_HSDPA:
            return "HSDPA";
        case NETWORK_TYPE_HSUPA:
            return "HSUPA";
        case NETWORK_TYPE_HSPA:
            return "HSPA";
        case NETWORK_TYPE_CDMA:
            return "CDMA";
        case NETWORK_TYPE_EVDO_0:
            return "CDMA - EvDo rev. 0";
        case NETWORK_TYPE_EVDO_A:
            return "CDMA - EvDo rev. A";
        case NETWORK_TYPE_EVDO_B:
            return "CDMA - EvDo rev. B";
        case NETWORK_TYPE_1xRTT:
            return "CDMA - 1xRTT";
        case NETWORK_TYPE_LTE:
            return "LTE";
        case NETWORK_TYPE_EHRPD:
            return "CDMA - eHRPD";
        case NETWORK_TYPE_IDEN:
            return "iDEN";
        case NETWORK_TYPE_HSPAP:
            return "HSPA+";
        case NETWORK_TYPE_GSM:
            return "GSM";
        case NETWORK_TYPE_TD_SCDMA:
            return "TD_SCDMA";
        case NETWORK_TYPE_IWLAN:
            return "IWLAN";
        default:
            return "UNKNOWN";
    }
}
#method_after
/**
 * Returns a string representation of the radio technology (network type)
 * currently in use on the device.
 * @param subId for which network type is returned
 * @return the name of the radio technology
 */
public static String getNetworkTypeName(int type) {
    switch(type) {
        case NETWORK_TYPE_GPRS:
            return "GPRS";
        case NETWORK_TYPE_EDGE:
            return "EDGE";
        case NETWORK_TYPE_UMTS:
            return "UMTS";
        case NETWORK_TYPE_HSDPA:
            return "HSDPA";
        case NETWORK_TYPE_HSUPA:
            return "HSUPA";
        case NETWORK_TYPE_HSPA:
            return "HSPA";
        case NETWORK_TYPE_CDMA:
            return "CDMA";
        case NETWORK_TYPE_EVDO_0:
            return "CDMA - EvDo rev. 0";
        case NETWORK_TYPE_EVDO_A:
            return "CDMA - EvDo rev. A";
        case NETWORK_TYPE_EVDO_B:
            return "CDMA - EvDo rev. B";
        case NETWORK_TYPE_1xRTT:
            return "CDMA - 1xRTT";
        case NETWORK_TYPE_LTE:
            return "LTE";
        case NETWORK_TYPE_EHRPD:
            return "CDMA - eHRPD";
        case NETWORK_TYPE_IDEN:
            return "iDEN";
        case NETWORK_TYPE_HSPAP:
            return "HSPA+";
        case NETWORK_TYPE_GSM:
            return "GSM";
        case NETWORK_TYPE_TD_SCDMA:
            return "TD_SCDMA";
        case NETWORK_TYPE_IWLAN:
            return "IWLAN";
        case NETWORK_TYPE_LTE_CA:
            return "LTE_CA";
        default:
            return "UNKNOWN";
    }
}
#end_block

#method_before
public boolean hasIccCard() {
    return hasIccCard(getDefaultSim());
}
#method_after
public boolean hasIccCard() {
    return hasIccCard(getSlotIndex());
}
#end_block

#method_before
/**
 * @return true if a ICC card is present for a subscription
 *
 * @param slotId for which icc card presence is checked
 */
/**
 * {@hide}
 */
public boolean hasIccCard(int slotId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return false;
        return telephony.hasIccCardUsingSlotId(slotId);
    } catch (RemoteException ex) {
        // Assume no ICC card if remote exception which shouldn't happen
        return false;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return false;
    }
}
#method_after
/**
 * @return true if a ICC card is present for a subscription
 *
 * @param slotIndex for which icc card presence is checked
 */
/**
 * {@hide}
 */
public boolean hasIccCard(int slotIndex) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return false;
        return telephony.hasIccCardUsingSlotIndex(slotIndex);
    } catch (RemoteException ex) {
        // Assume no ICC card if remote exception which shouldn't happen
        return false;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return false;
    }
}
#end_block

#method_before
public int getSimState() {
    int slotIdx = getDefaultSim();
    // sim state
    if (slotIdx < 0) {
        // return unknown
        for (int i = 0; i < getPhoneCount(); i++) {
            int simState = getSimState(i);
            if (simState != SIM_STATE_ABSENT) {
                Rlog.d(TAG, "getSimState: default sim:" + slotIdx + ", sim state for " + "slotIdx=" + i + " is " + simState + ", return state as unknown");
                return SIM_STATE_UNKNOWN;
            }
        }
        Rlog.d(TAG, "getSimState: default sim:" + slotIdx + ", all SIMs absent, return " + "state as absent");
        return SIM_STATE_ABSENT;
    }
    return getSimState(slotIdx);
}
#method_after
public int getSimState() {
    int slotIndex = getSlotIndex();
    // sim state
    if (slotIndex < 0) {
        // return unknown
        for (int i = 0; i < getPhoneCount(); i++) {
            int simState = getSimState(i);
            if (simState != SIM_STATE_ABSENT) {
                Rlog.d(TAG, "getSimState: default sim:" + slotIndex + ", sim state for " + "slotIndex=" + i + " is " + simState + ", return state as unknown");
                return SIM_STATE_UNKNOWN;
            }
        }
        Rlog.d(TAG, "getSimState: default sim:" + slotIndex + ", all SIMs absent, return " + "state as absent");
        return SIM_STATE_ABSENT;
    }
    return getSimState(slotIndex);
}
#end_block

#method_before
/**
 * Returns a constant indicating the state of the device SIM card in a slot.
 *
 * @param slotIdx
 *
 * @see #SIM_STATE_UNKNOWN
 * @see #SIM_STATE_ABSENT
 * @see #SIM_STATE_PIN_REQUIRED
 * @see #SIM_STATE_PUK_REQUIRED
 * @see #SIM_STATE_NETWORK_LOCKED
 * @see #SIM_STATE_READY
 * @see #SIM_STATE_NOT_READY
 * @see #SIM_STATE_PERM_DISABLED
 * @see #SIM_STATE_CARD_IO_ERROR
 */
public int getSimState(int slotIdx) {
    int simState = SubscriptionManager.getSimStateForSlotIdx(slotIdx);
    return simState;
}
#method_after
public int getSimState(int slotIndex) {
    int simState = SubscriptionManager.getSimStateForSlotIndex(slotIndex);
    return simState;
}
#end_block

#method_before
public String getSimOperator(int subId) {
    return getSimOperatorNumericForSubscription(subId);
}
#method_after
public String getSimOperator(int subId) {
    return getSimOperatorNumeric(subId);
}
#end_block

#method_before
public String getSimOperatorNumeric() {
    int subId = SubscriptionManager.getDefaultDataSubId();
    if (!SubscriptionManager.isUsableSubIdValue(subId)) {
        subId = SubscriptionManager.getDefaultSmsSubId();
        if (!SubscriptionManager.isUsableSubIdValue(subId)) {
            subId = SubscriptionManager.getDefaultVoiceSubId();
            if (!SubscriptionManager.isUsableSubIdValue(subId)) {
                subId = SubscriptionManager.getDefaultSubId();
            }
        }
    }
    return getSimOperatorNumericForSubscription(subId);
}
#method_after
public String getSimOperatorNumeric() {
    int subId = SubscriptionManager.getDefaultDataSubscriptionId();
    if (!SubscriptionManager.isUsableSubIdValue(subId)) {
        subId = SubscriptionManager.getDefaultSmsSubscriptionId();
        if (!SubscriptionManager.isUsableSubIdValue(subId)) {
            subId = SubscriptionManager.getDefaultVoiceSubscriptionId();
            if (!SubscriptionManager.isUsableSubIdValue(subId)) {
                subId = SubscriptionManager.getDefaultSubscriptionId();
            }
        }
    }
    return getSimOperatorNumeric(subId);
}
#end_block

#method_before
public String getSimOperatorNumeric() {
    int subId = SubscriptionManager.getDefaultDataSubId();
    if (!SubscriptionManager.isUsableSubIdValue(subId)) {
        subId = SubscriptionManager.getDefaultSmsSubId();
        if (!SubscriptionManager.isUsableSubIdValue(subId)) {
            subId = SubscriptionManager.getDefaultVoiceSubId();
            if (!SubscriptionManager.isUsableSubIdValue(subId)) {
                subId = SubscriptionManager.getDefaultSubId();
            }
        }
    }
    return getSimOperatorNumericForSubscription(subId);
}
#method_after
public String getSimOperatorNumeric(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getSimOperatorNumericForPhone(phoneId);
}
#end_block

#method_before
public String getSimOperatorName() {
    return getSimOperatorNameForPhone(getDefaultPhone());
}
#method_after
public String getSimOperatorName() {
    return getSimOperatorNameForPhone(getPhoneId());
}
#end_block

#method_before
public String getSimOperatorName() {
    return getSimOperatorNameForPhone(getDefaultPhone());
}
#method_after
public String getSimOperatorName(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getSimOperatorNameForPhone(phoneId);
}
#end_block

#method_before
public String getSimCountryIso() {
    return getSimCountryIsoForPhone(getDefaultPhone());
}
#method_after
public String getSimCountryIso() {
    return getSimCountryIsoForPhone(getPhoneId());
}
#end_block

#method_before
public String getSimCountryIso(int subId) {
    return getSimCountryIsoForSubscription(subId);
}
#method_after
public String getSimCountryIso(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getSimCountryIsoForPhone(phoneId);
}
#end_block

#method_before
public String getSimSerialNumber() {
    return getSimSerialNumber(getDefaultSubscription());
}
#method_after
public String getSimSerialNumber() {
    return getSimSerialNumber(getSubId());
}
#end_block

#method_before
/**
 * Returns the serial number for the given subscription, if applicable. Return null if it is
 * unavailable.
 * <p>
 * @param subId for which Sim Serial number is returned
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public String getSimSerialNumber(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getIccSerialNumberForSubscriber(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
public String getSimSerialNumber(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getIccSerialNumberForSubscriber(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
public int getLteOnCdmaMode() {
    return getLteOnCdmaMode(getDefaultSubscription());
}
#method_after
public int getLteOnCdmaMode() {
    return getLteOnCdmaMode(getSubId());
}
#end_block

#method_before
/**
 * Return if the current radio is LTE on CDMA for Subscription. This
 * is a tri-state return value as for a period of time
 * the mode may be unknown.
 *
 * @param subId for which radio is LTE on CDMA is returned
 * @return {@link PhoneConstants#LTE_ON_CDMA_UNKNOWN}, {@link PhoneConstants#LTE_ON_CDMA_FALSE}
 * or {@link PhoneConstants#LTE_ON_CDMA_TRUE}
 *
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public int getLteOnCdmaMode(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
        return telephony.getLteOnCdmaModeForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // Assume no ICC card if remote exception which shouldn't happen
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    }
}
#method_after
public int getLteOnCdmaMode(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
        return telephony.getLteOnCdmaModeForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // Assume no ICC card if remote exception which shouldn't happen
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    }
}
#end_block

#method_before
// 
// 
// Subscriber Info
// 
// 
public String getSubscriberId() {
    return getSubscriberId(getDefaultSubscription());
}
#method_after
// 
// 
// Subscriber Info
// 
// 
public String getSubscriberId() {
    return getSubscriberId(getSubId());
}
#end_block

#method_before
/**
 * Returns the unique subscriber ID, for example, the IMSI for a GSM phone
 * for a subscription.
 * Return null if it is unavailable.
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param subId whose subscriber id is returned
 */
public String getSubscriberId(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getSubscriberIdForSubscriber(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
public String getSubscriberId(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getSubscriberIdForSubscriber(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
/**
 * Returns the Group Identifier Level1 for a GSM phone for a particular subscription.
 * Return null if it is unavailable.
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param subscription whose subscriber id is returned
 */
public String getGroupIdLevel1(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getGroupIdLevel1ForSubscriber(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
public String getGroupIdLevel1(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getGroupIdLevel1ForSubscriber(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
public String getLine1Number() {
    return getLine1NumberForSubscriber(getDefaultSubscription());
}
#method_after
public String getLine1Number() {
    return getLine1Number(getSubId());
}
#end_block

#method_before
public String getLine1Number() {
    return getLine1NumberForSubscriber(getDefaultSubscription());
}
#method_after
public String getLine1Number(int subId) {
    String number = null;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            number = telephony.getLine1NumberForDisplay(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    if (number != null) {
        return number;
    }
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getLine1NumberForSubscriber(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
public boolean setLine1NumberForDisplay(String alphaTag, String number) {
    return setLine1NumberForDisplayForSubscriber(getDefaultSubscription(), alphaTag, number);
}
#method_after
public boolean setLine1NumberForDisplay(String alphaTag, String number) {
    return setLine1NumberForDisplay(getSubId(), alphaTag, number);
}
#end_block

#method_before
public boolean setLine1NumberForDisplay(String alphaTag, String number) {
    return setLine1NumberForDisplayForSubscriber(getDefaultSubscription(), alphaTag, number);
}
#method_after
public boolean setLine1NumberForDisplay(int subId, String alphaTag, String number) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setLine1NumberForDisplayForSubscriber(subId, alphaTag, number);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#end_block

#method_before
public String getLine1AlphaTag() {
    return getLine1AlphaTagForSubscriber(getDefaultSubscription());
}
#method_after
public String getLine1AlphaTag() {
    return getLine1AlphaTag(getSubId());
}
#end_block

#method_before
public String getLine1AlphaTag() {
    return getLine1AlphaTagForSubscriber(getDefaultSubscription());
}
#method_after
public String getLine1AlphaTag(int subId) {
    String alphaTag = null;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            alphaTag = telephony.getLine1AlphaTagForDisplay(subId, getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    if (alphaTag != null) {
        return alphaTag;
    }
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getLine1AlphaTagForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
public String getMsisdn() {
    return getMsisdn(getDefaultSubscription());
}
#method_after
public String getMsisdn() {
    return getMsisdn(getSubId());
}
#end_block

#method_before
/**
 * Returns the MSISDN string.
 * for a GSM phone. Return null if it is unavailable.
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param subId for which msisdn is returned
 */
public String getMsisdn(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getMsisdnForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
public String getMsisdn(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getMsisdnForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
public String getVoiceMailNumber() {
    return getVoiceMailNumber(getDefaultSubscription());
}
#method_after
public String getVoiceMailNumber() {
    return getVoiceMailNumber(getSubId());
}
#end_block

#method_before
/**
 * Returns the voice mail number for a subscription.
 * Return null if it is unavailable.
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 * @param subId whose voice mail number is returned
 */
public String getVoiceMailNumber(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getVoiceMailNumberForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
public String getVoiceMailNumber(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getVoiceMailNumberForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
public String getCompleteVoiceMailNumber() {
    return getCompleteVoiceMailNumber(getDefaultSubscription());
}
#method_after
public String getCompleteVoiceMailNumber() {
    return getCompleteVoiceMailNumber(getSubId());
}
#end_block

#method_before
/**
 * Returns the complete voice mail number. Return null if it is unavailable.
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#CALL_PRIVILEGED CALL_PRIVILEGED}
 *
 * @param subId
 */
public String getCompleteVoiceMailNumber(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getCompleteVoiceMailNumberForSubscriber(subId);
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
public String getCompleteVoiceMailNumber(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getCompleteVoiceMailNumberForSubscriber(subId);
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
public boolean setVoiceMailNumber(String alphaTag, String number) {
    return setVoiceMailNumber(getDefaultSubscription(), alphaTag, number);
}
#method_after
public boolean setVoiceMailNumber(String alphaTag, String number) {
    return setVoiceMailNumber(getSubId(), alphaTag, number);
}
#end_block

#method_before
/**
 * Sets the voicemail number for the given subscriber.
 *
 * <p>Requires that the calling app has carrier privileges.
 * @see #hasCarrierPrivileges
 *
 * @param subId The subscription id.
 * @param alphaTag The alpha tag to display.
 * @param number The voicemail number.
 */
public boolean setVoiceMailNumber(int subId, String alphaTag, String number) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setVoiceMailNumber(subId, alphaTag, number);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#method_after
public boolean setVoiceMailNumber(int subId, String alphaTag, String number) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setVoiceMailNumber(subId, alphaTag, number);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#end_block

#method_before
public int getVoiceMessageCount() {
    return getVoiceMessageCount(getDefaultSubscription());
}
#method_after
public int getVoiceMessageCount() {
    return getVoiceMessageCount(getSubId());
}
#end_block

#method_before
/**
 * Returns the voice mail count for a subscription. Return 0 if unavailable.
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 * @param subId whose voice message count is returned
 */
public int getVoiceMessageCount(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return 0;
        return telephony.getVoiceMessageCountForSubscriber(subId);
    } catch (RemoteException ex) {
        return 0;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return 0;
    }
}
#method_after
public int getVoiceMessageCount(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return 0;
        return telephony.getVoiceMessageCountForSubscriber(subId);
    } catch (RemoteException ex) {
        return 0;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return 0;
    }
}
#end_block

#method_before
public String getVoiceMailAlphaTag() {
    return getVoiceMailAlphaTag(getDefaultSubscription());
}
#method_after
public String getVoiceMailAlphaTag() {
    return getVoiceMailAlphaTag(getSubId());
}
#end_block

#method_before
/**
 * Retrieves the alphabetic identifier associated with the voice
 * mail number for a subscription.
 * <p>
 * Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 * @param subId whose alphabetic identifier associated with the
 * voice mail number is returned
 */
public String getVoiceMailAlphaTag(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getVoiceMailAlphaTagForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
public String getVoiceMailAlphaTag(int subId) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getVoiceMailAlphaTagForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
/**
 * Returns a constant indicating the call state (cellular) on the device
 * for a subscription.
 *
 * @param subId whose call state is returned
 */
public int getCallState(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return CALL_STATE_IDLE;
        return telephony.getCallStateForSubscriber(subId);
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    } catch (NullPointerException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    }
}
#method_after
public int getCallState(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getCallStateForSlot(phoneId);
}
#end_block

#method_before
// 
// 
// PhoneStateListener
// 
// 
public void listen(PhoneStateListener listener, int events) {
    if (mContext == null)
        return;
    try {
        Boolean notifyNow = (getITelephony() != null);
        sRegistry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
    } catch (RemoteException ex) {
    // system process dead
    } catch (NullPointerException ex) {
    // system process dead
    }
}
#method_after
// 
// 
// PhoneStateListener
// 
// 
public void listen(PhoneStateListener listener, int events) {
    if (mContext == null)
        return;
    try {
        boolean notifyNow = (getITelephony() != null);
        // telephony manager is created with.
        if (listener.mSubId == null) {
            listener.mSubId = mSubId;
        }
        sRegistry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
    } catch (RemoteException ex) {
    // system process dead
    } catch (NullPointerException ex) {
    // system process dead
    }
}
#end_block

#method_before
public int getCdmaEriIconIndex() {
    return getCdmaEriIconIndex(getDefaultSubscription());
}
#method_after
public int getCdmaEriIconIndex() {
    return getCdmaEriIconIndex(getSubId());
}
#end_block

#method_before
/**
 * Returns the CDMA ERI icon index to display for a subscription
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public int getCdmaEriIconIndex(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return -1;
        return telephony.getCdmaEriIconIndexForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return -1;
    } catch (NullPointerException ex) {
        return -1;
    }
}
#method_after
public int getCdmaEriIconIndex(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return -1;
        return telephony.getCdmaEriIconIndexForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return -1;
    } catch (NullPointerException ex) {
        return -1;
    }
}
#end_block

#method_before
public int getCdmaEriIconMode() {
    return getCdmaEriIconMode(getDefaultSubscription());
}
#method_after
public int getCdmaEriIconMode() {
    return getCdmaEriIconMode(getSubId());
}
#end_block

#method_before
/**
 * Returns the CDMA ERI icon mode for a subscription.
 * 0 - ON
 * 1 - FLASHING
 *
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public int getCdmaEriIconMode(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return -1;
        return telephony.getCdmaEriIconModeForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return -1;
    } catch (NullPointerException ex) {
        return -1;
    }
}
#method_after
public int getCdmaEriIconMode(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return -1;
        return telephony.getCdmaEriIconModeForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return -1;
    } catch (NullPointerException ex) {
        return -1;
    }
}
#end_block

#method_before
public String getCdmaEriText() {
    return getCdmaEriText(getDefaultSubscription());
}
#method_after
public String getCdmaEriText() {
    return getCdmaEriText(getSubId());
}
#end_block

#method_before
/**
 * Returns the CDMA ERI text, of a subscription
 *
 * <p>
 * Requires Permission:
 *   {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */
public String getCdmaEriText(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return null;
        return telephony.getCdmaEriTextForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
public String getCdmaEriText(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return null;
        return telephony.getCdmaEriTextForSubscriber(subId, getOpPackageName());
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccOpenLogicalChannel(AID);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#method_after
@Deprecated
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) {
    return iccOpenLogicalChannel(getSubId(), AID, -1);
}
#end_block

#method_before
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccOpenLogicalChannel(AID);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#method_after
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID, int p2) {
    return iccOpenLogicalChannel(getSubId(), AID, p2);
}
#end_block

#method_before
public boolean iccCloseLogicalChannel(int channel) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccCloseLogicalChannel(channel);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#method_after
public boolean iccCloseLogicalChannel(int channel) {
    return iccCloseLogicalChannel(getSubId(), channel);
}
#end_block

#method_before
public boolean iccCloseLogicalChannel(int channel) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccCloseLogicalChannel(channel);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#method_after
public boolean iccCloseLogicalChannel(int subId, int channel) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccCloseLogicalChannel(subId, channel);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
#end_block

#method_before
public String iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduLogicalChannel(channel, cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#method_after
public String iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data) {
    return iccTransmitApduLogicalChannel(getSubId(), channel, cla, instruction, p1, p2, p3, data);
}
#end_block

#method_before
public String iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduLogicalChannel(channel, cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#method_after
public String iccTransmitApduLogicalChannel(int subId, int channel, int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduLogicalChannel(subId, channel, cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#end_block

#method_before
public String iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduBasicChannel(cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#method_after
public String iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data) {
    return iccTransmitApduBasicChannel(getSubId(), cla, instruction, p1, p2, p3, data);
}
#end_block

#method_before
public String iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduBasicChannel(cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#method_after
public String iccTransmitApduBasicChannel(int subId, int cla, int instruction, int p1, int p2, int p3, String data) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduBasicChannel(subId, cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#end_block

#method_before
public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3, String filePath) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccExchangeSimIO(fileID, command, p1, p2, p3, filePath);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#method_after
public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3, String filePath) {
    return iccExchangeSimIO(getSubId(), fileID, command, p1, p2, p3, filePath);
}
#end_block

#method_before
public byte[] iccExchangeSimIO(int fileID, int command, int p1, int p2, int p3, String filePath) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccExchangeSimIO(fileID, command, p1, p2, p3, filePath);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#method_after
public byte[] iccExchangeSimIO(int subId, int fileID, int command, int p1, int p2, int p3, String filePath) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccExchangeSimIO(subId, fileID, command, p1, p2, p3, filePath);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#end_block

#method_before
public String sendEnvelopeWithStatus(String content) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.sendEnvelopeWithStatus(content);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#method_after
public String sendEnvelopeWithStatus(String content) {
    return sendEnvelopeWithStatus(getSubId(), content);
}
#end_block

#method_before
public String sendEnvelopeWithStatus(String content) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.sendEnvelopeWithStatus(content);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#method_after
public String sendEnvelopeWithStatus(int subId, String content) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.sendEnvelopeWithStatus(subId, content);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
#end_block

#method_before
public static void setTelephonyProperty(int phoneId, String property, String value) {
    String propVal = "";
    String[] p = null;
    String prop = SystemProperties.get(property);
    if (value == null) {
        value = "";
    }
    if (prop != null) {
        p = prop.split(",");
    }
    if (!SubscriptionManager.isValidPhoneId(phoneId)) {
        Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId + " property=" + property + " value: " + value + " prop=" + prop);
        return;
    }
    for (int i = 0; i < phoneId; i++) {
        String str = "";
        if ((p != null) && (i < p.length)) {
            str = p[i];
        }
        propVal = propVal + str + ",";
    }
    propVal = propVal + value;
    if (p != null) {
        for (int i = phoneId + 1; i < p.length; i++) {
            propVal = propVal + "," + p[i];
        }
    }
    if (property.length() > SystemProperties.PROP_NAME_MAX || propVal.length() > SystemProperties.PROP_VALUE_MAX) {
        Rlog.d(TAG, "setTelephonyProperty: property to long phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
        return;
    }
    Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
    SystemProperties.set(property, propVal);
}
#method_after
public static void setTelephonyProperty(int phoneId, String property, String value) {
    String propVal = "";
    String[] p = null;
    String prop = SystemProperties.get(property);
    if (value == null) {
        value = "";
    }
    if (prop != null) {
        p = prop.split(",");
    }
    if (!SubscriptionManager.isValidPhoneId(phoneId)) {
        Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId + " property=" + property + " value: " + value + " prop=" + prop);
        return;
    }
    for (int i = 0; i < phoneId; i++) {
        String str = "";
        if ((p != null) && (i < p.length)) {
            str = p[i];
        }
        propVal = propVal + str + ",";
    }
    propVal = propVal + value;
    if (p != null) {
        for (int i = phoneId + 1; i < p.length; i++) {
            propVal = propVal + "," + p[i];
        }
    }
    if (propVal.length() > SystemProperties.PROP_VALUE_MAX) {
        Rlog.d(TAG, "setTelephonyProperty: property too long phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
        return;
    }
    Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
    SystemProperties.set(property, propVal);
}
#end_block

#method_before
public boolean setPreferredNetworkTypeToGlobal() {
    return setPreferredNetworkType(getDefaultSubscription(), RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA);
}
#method_after
public boolean setPreferredNetworkTypeToGlobal() {
    return setPreferredNetworkTypeToGlobal(getSubId());
}
#end_block

#method_before
public boolean setPreferredNetworkTypeToGlobal() {
    return setPreferredNetworkType(getDefaultSubscription(), RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA);
}
#method_after
public boolean setPreferredNetworkTypeToGlobal(int subId) {
    return setPreferredNetworkType(subId, RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA);
}
#end_block

#method_before
public boolean hasCarrierPrivileges() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getCarrierPrivilegeStatus() == CARRIER_PRIVILEGE_STATUS_HAS_ACCESS;
    } catch (RemoteException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges NPE", ex);
    }
    return false;
}
#method_after
public boolean hasCarrierPrivileges() {
    return hasCarrierPrivileges(getSubId());
}
#end_block

#method_before
public boolean hasCarrierPrivileges() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getCarrierPrivilegeStatus() == CARRIER_PRIVILEGE_STATUS_HAS_ACCESS;
    } catch (RemoteException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges NPE", ex);
    }
    return false;
}
#method_after
public boolean hasCarrierPrivileges(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getCarrierPrivilegeStatus(mSubId) == CARRIER_PRIVILEGE_STATUS_HAS_ACCESS;
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges NPE", ex);
    }
    return false;
}
#end_block

#method_before
public boolean setOperatorBrandOverride(String brand) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setOperatorBrandOverride(brand);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setOperatorBrandOverride RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setOperatorBrandOverride NPE", ex);
    }
    return false;
}
#method_after
public boolean setOperatorBrandOverride(String brand) {
    return setOperatorBrandOverride(getSubId(), brand);
}
#end_block

#method_before
public boolean setOperatorBrandOverride(String brand) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setOperatorBrandOverride(brand);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setOperatorBrandOverride RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setOperatorBrandOverride NPE", ex);
    }
    return false;
}
#method_after
public boolean setOperatorBrandOverride(int subId, String brand) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setOperatorBrandOverride(subId, brand);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setOperatorBrandOverride RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setOperatorBrandOverride NPE", ex);
    }
    return false;
}
#end_block

#method_before
public boolean setRoamingOverride(List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setRoamingOverride(gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setRoamingOverride RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setRoamingOverride NPE", ex);
    }
    return false;
}
#method_after
public boolean setRoamingOverride(List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList) {
    return setRoamingOverride(getSubId(), gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
}
#end_block

#method_before
public boolean setRoamingOverride(List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setRoamingOverride(gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setRoamingOverride RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setRoamingOverride NPE", ex);
    }
    return false;
}
#method_after
public boolean setRoamingOverride(int subId, List<String> gsmRoamingList, List<String> gsmNonRoamingList, List<String> cdmaRoamingList, List<String> cdmaNonRoamingList) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setRoamingOverride(subId, gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setRoamingOverride RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setRoamingOverride NPE", ex);
    }
    return false;
}
#end_block

#method_before
/**
 * Expose the rest of ITelephony to @SystemApi
 */
@SystemApi
public String getCdmaMdn() {
    return getCdmaMdn(getDefaultSubscription());
}
#method_after
/**
 * Expose the rest of ITelephony to @SystemApi
 */
@SystemApi
public String getCdmaMdn() {
    return getCdmaMdn(getSubId());
}
#end_block

#method_before
@SystemApi
public String getCdmaMin() {
    return getCdmaMin(getDefaultSubscription());
}
#method_after
@SystemApi
public String getCdmaMin() {
    return getCdmaMin(getSubId());
}
#end_block

#method_before
@SystemApi
public List<String> getCarrierPackageNamesForIntent(Intent intent) {
    return getCarrierPackageNamesForIntentAndPhone(intent, getDefaultPhone());
}
#method_after
@SystemApi
public List<String> getCarrierPackageNamesForIntent(Intent intent) {
    return getCarrierPackageNamesForIntentAndPhone(intent, getPhoneId());
}
#end_block

#method_before
@SystemApi
public boolean isDataConnectivityPossible() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.isDataConnectivityPossible();
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#isDataConnectivityPossible", e);
    }
    return false;
}
#method_after
@SystemApi
public boolean isDataConnectivityPossible() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.isDataConnectivityPossible(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#isDataAllowed", e);
    }
    return false;
}
#end_block

#method_before
@SystemApi
public void setDataEnabled(boolean enable) {
    setDataEnabled(SubscriptionManager.getDefaultDataSubId(), enable);
}
#method_after
public void setDataEnabled(boolean enable) {
    setDataEnabled(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()), enable);
}
#end_block

#method_before
@SystemApi
public boolean getDataEnabled() {
    return getDataEnabled(SubscriptionManager.getDefaultDataSubId());
}
#method_after
@SystemApi
@Deprecated
public boolean getDataEnabled() {
    return isDataEnabled();
}
#end_block

#method_before
@SystemApi
public boolean getDataEnabled(int subId) {
    boolean retVal = false;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            retVal = telephony.getDataEnabled(subId);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getDataEnabled", e);
    } catch (NullPointerException e) {
    }
    Log.d(TAG, "getDataEnabled: retVal=" + retVal);
    return retVal;
}
#method_after
@SystemApi
public boolean getDataEnabled(int subId) {
    boolean retVal = false;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            retVal = telephony.getDataEnabled(subId);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getDataEnabled", e);
    } catch (NullPointerException e) {
    }
    return retVal;
}
#end_block

#method_before
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}
#method_after
@Deprecated
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}
#end_block

#method_before
public void setSimOperatorNumeric(String numeric) {
    int phoneId = getDefaultPhone();
    setSimOperatorNumericForPhone(phoneId, numeric);
}
#method_after
public void setSimOperatorNumeric(String numeric) {
    int phoneId = getPhoneId();
    setSimOperatorNumericForPhone(phoneId, numeric);
}
#end_block

#method_before
public void setSimOperatorName(String name) {
    int phoneId = getDefaultPhone();
    setSimOperatorNameForPhone(phoneId, name);
}
#method_after
public void setSimOperatorName(String name) {
    int phoneId = getPhoneId();
    setSimOperatorNameForPhone(phoneId, name);
}
#end_block

#method_before
public void setSimCountryIso(String iso) {
    int phoneId = getDefaultPhone();
    setSimCountryIsoForPhone(phoneId, iso);
}
#method_after
public void setSimCountryIso(String iso) {
    int phoneId = getPhoneId();
    setSimCountryIsoForPhone(phoneId, iso);
}
#end_block

#method_before
public void setSimState(String state) {
    int phoneId = getDefaultPhone();
    setSimStateForPhone(phoneId, state);
}
#method_after
public void setSimState(String state) {
    int phoneId = getPhoneId();
    setSimStateForPhone(phoneId, state);
}
#end_block

#method_before
public void setBasebandVersion(String version) {
    int phoneId = getDefaultPhone();
    setBasebandVersionForPhone(phoneId, version);
}
#method_after
public void setBasebandVersion(String version) {
    int phoneId = getPhoneId();
    setBasebandVersionForPhone(phoneId, version);
}
#end_block

#method_before
public void setPhoneType(int type) {
    int phoneId = getDefaultPhone();
    setPhoneType(phoneId, type);
}
#method_after
public void setPhoneType(int type) {
    int phoneId = getPhoneId();
    setPhoneType(phoneId, type);
}
#end_block

#method_before
public String getOtaSpNumberSchema(String defaultValue) {
    int phoneId = getDefaultPhone();
    return getOtaSpNumberSchemaForPhone(phoneId, defaultValue);
}
#method_after
public String getOtaSpNumberSchema(String defaultValue) {
    int phoneId = getPhoneId();
    return getOtaSpNumberSchemaForPhone(phoneId, defaultValue);
}
#end_block

#method_before
public boolean getSmsReceiveCapable(boolean defaultValue) {
    int phoneId = getDefaultPhone();
    return getSmsReceiveCapableForPhone(phoneId, defaultValue);
}
#method_after
public boolean getSmsReceiveCapable(boolean defaultValue) {
    int phoneId = getPhoneId();
    return getSmsReceiveCapableForPhone(phoneId, defaultValue);
}
#end_block

#method_before
public boolean getSmsSendCapable(boolean defaultValue) {
    int phoneId = getDefaultPhone();
    return getSmsSendCapableForPhone(phoneId, defaultValue);
}
#method_after
public boolean getSmsSendCapable(boolean defaultValue) {
    int phoneId = getPhoneId();
    return getSmsSendCapableForPhone(phoneId, defaultValue);
}
#end_block

#method_before
public void setNetworkOperatorName(String name) {
    int phoneId = getDefaultPhone();
    setNetworkOperatorNameForPhone(phoneId, name);
}
#method_after
public void setNetworkOperatorName(String name) {
    int phoneId = getPhoneId();
    setNetworkOperatorNameForPhone(phoneId, name);
}
#end_block

#method_before
public void setNetworkOperatorNumeric(String numeric) {
    int phoneId = getDefaultPhone();
    setNetworkOperatorNumericForPhone(phoneId, numeric);
}
#method_after
public void setNetworkOperatorNumeric(String numeric) {
    int phoneId = getPhoneId();
    setNetworkOperatorNumericForPhone(phoneId, numeric);
}
#end_block

#method_before
public void setNetworkRoaming(boolean isRoaming) {
    int phoneId = getDefaultPhone();
    setNetworkRoamingForPhone(phoneId, isRoaming);
}
#method_after
public void setNetworkRoaming(boolean isRoaming) {
    int phoneId = getPhoneId();
    setNetworkRoamingForPhone(phoneId, isRoaming);
}
#end_block

#method_before
public void setNetworkCountryIso(String iso) {
    int phoneId = getDefaultPhone();
    setNetworkCountryIsoForPhone(phoneId, iso);
}
#method_after
public void setNetworkCountryIso(String iso) {
    int phoneId = getPhoneId();
    setNetworkCountryIsoForPhone(phoneId, iso);
}
#end_block

#method_before
public void setDataNetworkType(int type) {
    int phoneId = getDefaultPhone();
    setDataNetworkTypeForPhone(phoneId, type);
}
#method_after
public void setDataNetworkType(int type) {
    int phoneId = getPhoneId(SubscriptionManager.getDefaultDataSubscriptionId());
    setDataNetworkTypeForPhone(phoneId, type);
}
#end_block

#method_before
@Override
public void process(Context context, CompilationUnit cu) {
    List types = cu.types();
    ASTRewrite rewrite = context.rewrite();
    Set<String> imports = Sets.newHashSet();
    for (Object type : types) {
        if (type instanceof TypeDeclaration) {
            annotateTestType(cu, rewrite, (TypeDeclaration) type, imports);
        }
    }
}
#method_after
@Override
public void process(Context context, CompilationUnit cu) {
    List types = cu.types();
    ASTRewrite rewrite = context.rewrite();
    Set<String> imports = Sets.newHashSet();
    for (Object type : types) {
        if (type instanceof TypeDeclaration) {
            TypeDeclaration declaration = (TypeDeclaration) type;
            if (needsAnnotation(declaration)) {
                annotateTestType(cu, rewrite, declaration, imports);
            }
        }
    }
}
#end_block

#method_before
private void annotateTestType(CompilationUnit cu, ASTRewrite rewrite, TypeDeclaration type, Set<String> imports) {
    AST ast = cu.getAST();
    String className = cu.getPackage().getName().getFullyQualifiedName() + '.' + type.getName().getIdentifier();
    String annotationName = getAnnotationName(className);
    if (!imports.contains(annotationName)) {
        appendImport(cu, rewrite, annotationName);
        imports.add(annotationName);
    }
    MarkerAnnotation annotation = ast.newMarkerAnnotation();
    annotation.setTypeName(ast.newSimpleName(annotationName));
    TextEditGroup editGroup = null;
    rewrite.getListRewrite(type, type.getModifiersProperty()).insertFirst(annotation, editGroup);
}
#method_after
private void annotateTestType(CompilationUnit cu, ASTRewrite rewrite, TypeDeclaration type, Set<String> imports) {
    AST ast = cu.getAST();
    String className = getPackageName(type) + '.' + type.getName().getIdentifier();
    String annotationName = getAnnotationName(className);
    if (!imports.contains(annotationName)) {
        appendImport(cu, rewrite, annotationName);
        imports.add(annotationName);
    }
    MarkerAnnotation annotation = ast.newMarkerAnnotation();
    annotation.setTypeName(ast.newSimpleName(annotationName));
    TextEditGroup editGroup = null;
    rewrite.getListRewrite(type, type.getModifiersProperty()).insertFirst(annotation, editGroup);
}
#end_block

#method_before
private static List<Rule> createTransformRules() {
    List<Rule> rules = Lists.newArrayList(Icu4jTransform.Icu4jRules.getRepackagingRules());
    // Switch all embedded comment references from com.ibm.icu to android.icu.
    rules.add(createOptionalRule(new ReplaceTextCommentScanner(Icu4jTransform.ORIGINAL_ICU_PACKAGE, Icu4jTransform.ANDROID_ICU_PACKAGE)));
    // Change sample jcite begin / end tags ---XYZ to Androids 'BEGIN(XYZ)' / 'END(XYZ)'
    rules.add(createOptionalRule(new TranslateJcite.BeginEndTagsHandler()));
    rules.add(createOptionalRule(new ShardingAnnotator()));
    return rules;
}
#method_after
private static List<Rule> createTransformRules() {
    List<Rule> rules = Lists.newArrayList(Icu4jTransform.Icu4jRules.getRepackagingRules());
    // Switch all embedded comment references from com.ibm.icu to android.icu.
    rules.add(createOptionalRule(new ReplaceTextCommentScanner(Icu4jTransform.ORIGINAL_ICU_PACKAGE, Icu4jTransform.ANDROID_ICU_PACKAGE)));
    // Change sample jcite begin / end tags ---XYZ to Androids 'BEGIN(XYZ)' / 'END(XYZ)'
    rules.add(createOptionalRule(new TranslateJcite.BeginEndTagsHandler()));
    // Add annotations to each test file so that they can be sharded across multiple processes.
    rules.add(createOptionalRule(new ShardingAnnotator()));
    return rules;
}
#end_block

#method_before
public static <K extends Comparable, V extends Comparable, T extends Entry<K, V>> int compare(T a, T b) {
    if (a == null) {
        return b == null ? 0 : -1;
    } else if (b == null) {
        return 1;
    }
    int diff = compare(a.getKey(), b.getKey());
    if (diff != 0) {
        return diff;
    }
    return compare(a.getValue(), b.getValue());
}
#method_after
public static <T extends Comparable> int compare(T a, T b) {
    return a == null ? b == null ? 0 : -1 : b == null ? 1 : a.compareTo(b);
}
#end_block

#method_before
public static <T extends Comparable, U extends Set<T>> int compare(U o1, U o2) {
    int diff = o1.size() - o2.size();
    if (diff != 0) {
        return diff;
    }
    Collection<T> x1 = SortedSet.class.isInstance(o1) ? o1 : new TreeSet<T>(o1);
    Collection<T> x2 = SortedSet.class.isInstance(o2) ? o2 : new TreeSet<T>(o2);
    return compare(x1, x2);
}
#method_after
public static <T extends Comparable, U extends Collection<T>> int compare(U o1, U o2) {
    int diff = o1.size() - o2.size();
    if (diff != 0) {
        return diff;
    }
    Iterator<T> iterator1 = o1.iterator();
    Iterator<T> iterator2 = o2.iterator();
    return compare(iterator1, iterator2);
}
#end_block

#method_before
public static <K extends Comparable, V extends Comparable, T extends Entry<K, V>> int compare(T a, T b) {
    if (a == null) {
        return b == null ? 0 : -1;
    } else if (b == null) {
        return 1;
    }
    int diff = compare(a.getKey(), b.getKey());
    if (diff != 0) {
        return diff;
    }
    return compare(a.getValue(), b.getValue());
}
#method_after
public static <T extends Comparable, U extends Set<T>> int compare(U o1, U o2) {
    int diff = o1.size() - o2.size();
    if (diff != 0) {
        return diff;
    }
    Collection<T> x1 = SortedSet.class.isInstance(o1) ? o1 : new TreeSet<T>(o1);
    Collection<T> x2 = SortedSet.class.isInstance(o2) ? o2 : new TreeSet<T>(o2);
    return compare(x1, x2);
}
#end_block

#method_before
public static ImsManager getInstance(Context context, int phoneId) {
    synchronized (sImsManagerInstances) {
        if (sImsManagerInstances.containsKey(phoneId)) {
            return sImsManagerInstances.get(phoneId);
        }
        ImsManager mgr = new ImsManager(context, phoneId);
        sImsManagerInstances.put(phoneId, mgr);
        return mgr;
    }
}
#method_after
public static ImsManager getInstance(Context context, int phoneId) {
    synchronized (sImsManagerInstances) {
        if (sImsManagerInstances.containsKey(phoneId)) {
            ImsManager m = sImsManagerInstances.get(phoneId);
            // May be null for some tests
            if (m != null) {
                m.connectIfServiceIsAvailable();
            }
            return m;
        }
        ImsManager mgr = new ImsManager(context, phoneId);
        sImsManagerInstances.put(phoneId, mgr);
        return mgr;
    }
}
#end_block

#method_before
public static boolean isNonTtyOrTtyOnVolteEnabled(Context context) {
    if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
        return true;
    }
    return Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, TelecomManager.TTY_MODE_OFF) == TelecomManager.TTY_MODE_OFF;
}
#method_after
public static boolean isNonTtyOrTtyOnVolteEnabled(Context context) {
    if (getBooleanCarrierConfig(context, CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
        return true;
    }
    TelecomManager tm = (TelecomManager) context.getSystemService(Context.TELECOM_SERVICE);
    if (tm == null) {
        Log.w(TAG, "isNonTtyOrTtyOnVolteEnabled: telecom not available");
        return true;
    }
    return tm.getCurrentTtyMode() == TelecomManager.TTY_MODE_OFF;
}
#end_block

#method_before
public boolean isNonTtyOrTtyOnVolteEnabledForSlot() {
    if (getBooleanCarrierConfigForSlot(CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
        return true;
    }
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, TelecomManager.TTY_MODE_OFF) == TelecomManager.TTY_MODE_OFF;
}
#method_after
public boolean isNonTtyOrTtyOnVolteEnabledForSlot() {
    if (getBooleanCarrierConfigForSlot(CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
        return true;
    }
    TelecomManager tm = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);
    if (tm == null) {
        Log.w(TAG, "isNonTtyOrTtyOnVolteEnabledForSlot: telecom not available");
        return true;
    }
    return tm.getCurrentTtyMode() == TelecomManager.TTY_MODE_OFF;
}
#end_block

#method_before
@Override
protected Void doInBackground(Void... params) {
    // disable on any error
    setVolteProvisionedProperty(false);
    setWfcProvisionedProperty(false);
    setVtProvisionedProperty(false);
    try {
        ImsConfig config = getConfigInterface();
        if (config != null) {
            setVolteProvisionedProperty(getProvisionedBool(config, ImsConfig.ConfigConstants.VLT_SETTING_ENABLED));
            if (DBG)
                Rlog.d(TAG, "isVoLteProvisioned = " + isVolteProvisioned());
            setWfcProvisionedProperty(getProvisionedBool(config, ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
            if (DBG)
                Rlog.d(TAG, "isWfcProvisioned = " + isWfcProvisioned());
            setVtProvisionedProperty(getProvisionedBool(config, ImsConfig.ConfigConstants.LVC_SETTING_ENABLED));
            if (DBG)
                Rlog.d(TAG, "isVtProvisioned = " + isVtProvisioned());
        }
    } catch (ImsException ie) {
        Rlog.e(TAG, "AsyncUpdateProvisionedValues error: ", ie);
    }
    return null;
}
#method_after
@Override
protected Boolean doInBackground(Void... params) {
    // disable on any error
    setVolteProvisionedProperty(false);
    setWfcProvisionedProperty(false);
    setVtProvisionedProperty(false);
    try {
        ImsConfig config = getConfigInterface();
        if (config != null) {
            setVolteProvisionedProperty(getProvisionedBool(config, ImsConfig.ConfigConstants.VLT_SETTING_ENABLED));
            if (DBG)
                Rlog.d(TAG, "isVoLteProvisioned = " + isVolteProvisioned());
            setWfcProvisionedProperty(getProvisionedBool(config, ImsConfig.ConfigConstants.VOICE_OVER_WIFI_SETTING_ENABLED));
            if (DBG)
                Rlog.d(TAG, "isWfcProvisioned = " + isWfcProvisioned());
            setVtProvisionedProperty(getProvisionedBool(config, ImsConfig.ConfigConstants.LVC_SETTING_ENABLED));
            if (DBG)
                Rlog.d(TAG, "isVtProvisioned = " + isVtProvisioned());
        }
    } catch (ImsException ie) {
        Rlog.e(TAG, "AsyncUpdateProvisionedValues error: ", ie);
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean getProvisionedBool(ImsConfig config, int item) throws ImsException {
    return config.getProvisionedValue(item) == ImsConfig.FeatureValueConstants.ON;
}
#method_after
private boolean getProvisionedBool(ImsConfig config, int item) throws ImsException {
    int value = config.getProvisionedValue(item);
    if (value == ImsConfig.FeatureValueConstants.ERROR) {
        throw new ImsException("getProvisionedBool failed with error for item: " + item, ImsReasonInfo.CODE_LOCAL_INTERNAL_ERROR);
    }
    return config.getProvisionedValue(item) == ImsConfig.FeatureValueConstants.ON;
}
#end_block

#method_before
private void updateProvisionedValues() {
    if (getBooleanCarrierConfigForSlot(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL)) {
        new AsyncUpdateProvisionedValues().execute();
    }
}
#method_after
private void updateProvisionedValues() {
    // Start trying to receive provisioning status after BACKOFF_INITIAL_DELAY_MS.
    if (mProvisionBackoff != null) {
        mProvisionBackoff.start();
    } else {
        // bypass and launch async thread once without backoff.
        handleUpdateProvisionedValues();
    }
}
#end_block

#method_before
private boolean updateWfcFeatureAndProvisionedValues() throws ImsException {
    boolean isNetworkRoaming = TelephonyManager.getDefault().isNetworkRoaming();
    boolean available = isWfcEnabledByPlatformForSlot();
    boolean enabled = isWfcEnabledByUserForSlot();
    updateDefaultWfcModeForSlot();
    int mode = getWfcModeForSlot(isNetworkRoaming);
    boolean roaming = isWfcRoamingEnabledByUserForSlot();
    boolean isFeatureOn = available && enabled;
    log("updateWfcFeatureAndProvisionedValues: available = " + available + ", enabled = " + enabled + ", mode = " + mode + ", roaming = " + roaming);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
    if (!isFeatureOn) {
        mode = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
        roaming = false;
    }
    setWfcModeInternal(mContext, mode);
    setWfcRoamingSettingInternal(roaming);
    return isFeatureOn;
}
#method_after
private boolean updateWfcFeatureAndProvisionedValues() throws ImsException {
    boolean isNetworkRoaming = TelephonyManager.getDefault().isNetworkRoaming();
    boolean available = isWfcEnabledByPlatformForSlot();
    boolean enabled = isWfcEnabledByUserForSlot();
    updateDefaultWfcMode();
    int mode = getWfcModeForSlot(isNetworkRoaming);
    boolean roaming = isWfcRoamingEnabledByUserForSlot();
    boolean isFeatureOn = available && enabled;
    log("updateWfcFeatureAndProvisionedValues: available = " + available + ", enabled = " + enabled + ", mode = " + mode + ", roaming = " + roaming);
    getConfigInterface().setFeatureValue(ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI, TelephonyManager.NETWORK_TYPE_IWLAN, isFeatureOn ? ImsConfig.FeatureValueConstants.ON : ImsConfig.FeatureValueConstants.OFF, mImsConfigListener);
    if (!isFeatureOn) {
        mode = ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED;
        roaming = false;
    }
    setWfcModeInternal(mContext, mode);
    setWfcRoamingSettingInternal(roaming);
    return isFeatureOn;
}
#end_block

#method_before
public boolean isServiceAvailable() {
    if (mImsServiceProxy == null) {
        createImsService();
    }
    // mImsServiceProxy will always create an ImsServiceProxy.
    return mImsServiceProxy.isBinderAlive();
}
#method_after
public boolean isServiceAvailable() {
    connectIfServiceIsAvailable();
    // mImsServiceProxy will always create an ImsServiceProxy.
    return mImsServiceProxy.isBinderAlive();
}
#end_block

#method_before
public ImsUtInterface getSupplementaryServiceConfiguration() throws ImsException {
    // FIXME: manage the multiple Ut interfaces based on the session id
    if (mUt == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsUt iUt = mImsServiceProxy.getUtInterface();
            if (iUt == null) {
                throw new ImsException("getSupplementaryServiceConfiguration()", ImsReasonInfo.CODE_UT_NOT_SUPPORTED);
            }
            mUt = new ImsUt(iUt);
        } catch (RemoteException e) {
            throw new ImsException("getSupplementaryServiceConfiguration()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mUt;
}
#method_after
public ImsUtInterface getSupplementaryServiceConfiguration() throws ImsException {
    // FIXME: manage the multiple Ut interfaces based on the session id
    if (mUt != null && mUt.isBinderAlive()) {
        return mUt;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsUt iUt = mImsServiceProxy.getUtInterface();
        if (iUt == null) {
            throw new ImsException("getSupplementaryServiceConfiguration()", ImsReasonInfo.CODE_UT_NOT_SUPPORTED);
        }
        mUt = new ImsUt(iUt);
    } catch (RemoteException e) {
        throw new ImsException("getSupplementaryServiceConfiguration()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mUt;
}
#end_block

#method_before
public ImsConfig getConfigInterface() throws ImsException {
    if (mConfig == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsConfig config = mImsServiceProxy.getConfigInterface();
            if (config == null) {
                throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
            }
            mConfig = new ImsConfig(config, mContext);
        } catch (RemoteException e) {
            throw new ImsException("getConfigInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    if (DBG)
        log("getConfigInterface(), mConfig= " + mConfig);
    return mConfig;
}
#method_after
public ImsConfig getConfigInterface() throws ImsException {
    if (mConfig != null && mConfig.isBinderAlive()) {
        return mConfig;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsConfig config = mImsServiceProxy.getConfigInterface();
        if (config == null) {
            throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
        }
        mConfig = new ImsConfig(config, mContext);
    } catch (RemoteException e) {
        throw new ImsException("getConfigInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mConfig;
}
#end_block

#method_before
public void setUiTTYMode(Context context, int uiTtyMode, Message onComplete) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mImsServiceProxy.setUiTTYMode(uiTtyMode, onComplete);
    } catch (RemoteException e) {
        throw new ImsException("setTTYMode()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    if (!getBooleanCarrierConfigForSlot(CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
        setAdvanced4GMode((uiTtyMode == TelecomManager.TTY_MODE_OFF) && isEnhanced4gLteModeSettingEnabledByUserForSlot());
    }
}
#method_after
public void setUiTTYMode(Context context, int uiTtyMode, Message onComplete) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        mImsServiceProxy.setUiTTYMode(uiTtyMode, onComplete);
    } catch (RemoteException e) {
        throw new ImsException("setTTYMode()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
@Deprecated
public void registrationConnected() {
    if (DBG) {
        log("registrationConnected ::");
    }
    if (mListener != null) {
        mListener.onImsConnected();
    }
}
#method_after
@Deprecated
public void registrationConnected() {
    if (DBG) {
        log("registrationConnected ::");
    }
    if (mListener != null) {
        mListener.onImsConnected(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN);
    }
}
#end_block

#method_before
@Deprecated
public void registrationProgressing() {
    if (DBG) {
        log("registrationProgressing ::");
    }
    if (mListener != null) {
        mListener.onImsProgressing();
    }
}
#method_after
@Deprecated
public void registrationProgressing() {
    if (DBG) {
        log("registrationProgressing ::");
    }
    if (mListener != null) {
        mListener.onImsProgressing(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN);
    }
}
#end_block

#method_before
@Override
public void registrationConnectedWithRadioTech(int imsRadioTech) {
    // values in ServiceState.java.
    if (DBG) {
        log("registrationConnectedWithRadioTech :: imsRadioTech=" + imsRadioTech);
    }
    if (mListener != null) {
        mListener.onImsConnected();
        mListener.onImsConnected(imsRadioTech);
    }
}
#method_after
@Override
public void registrationConnectedWithRadioTech(int imsRadioTech) {
    // values in ServiceState.java.
    if (DBG) {
        log("registrationConnectedWithRadioTech :: imsRadioTech=" + imsRadioTech);
    }
    if (mListener != null) {
        mListener.onImsConnected(imsRadioTech);
    }
}
#end_block

#method_before
@Override
public void registrationProgressingWithRadioTech(int imsRadioTech) {
    // values in ServiceState.java.
    if (DBG) {
        log("registrationProgressingWithRadioTech :: imsRadioTech=" + imsRadioTech);
    }
    if (mListener != null) {
        mListener.onImsProgressing();
    }
}
#method_after
@Override
public void registrationProgressingWithRadioTech(int imsRadioTech) {
    // values in ServiceState.java.
    if (DBG) {
        log("registrationProgressingWithRadioTech :: imsRadioTech=" + imsRadioTech);
    }
    if (mListener != null) {
        mListener.onImsProgressing(imsRadioTech);
    }
}
#end_block

#method_before
@Override
public void registrationServiceCapabilityChanged(int serviceClass, int event) {
    log("registrationServiceCapabilityChanged :: serviceClass=" + serviceClass + ", event=" + event);
    if (mListener != null) {
        mListener.onImsConnected();
    }
}
#method_after
@Override
public void registrationServiceCapabilityChanged(int serviceClass, int event) {
    log("registrationServiceCapabilityChanged :: serviceClass=" + serviceClass + ", event=" + event);
    if (mListener != null) {
        mListener.onImsConnected(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN);
    }
}
#end_block

#method_before
public ImsEcbm getEcbmInterface(int serviceId) throws ImsException {
    if (mEcbm == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsEcbm iEcbm = mImsServiceProxy.getEcbmInterface();
            if (iEcbm == null) {
                throw new ImsException("getEcbmInterface()", ImsReasonInfo.CODE_ECBM_NOT_SUPPORTED);
            }
            mEcbm = new ImsEcbm(iEcbm);
        } catch (RemoteException e) {
            throw new ImsException("getEcbmInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mEcbm;
}
#method_after
public ImsEcbm getEcbmInterface(int serviceId) throws ImsException {
    if (mEcbm != null && mEcbm.isBinderAlive()) {
        return mEcbm;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsEcbm iEcbm = mImsServiceProxy.getEcbmInterface();
        if (iEcbm == null) {
            throw new ImsException("getEcbmInterface()", ImsReasonInfo.CODE_ECBM_NOT_SUPPORTED);
        }
        mEcbm = new ImsEcbm(iEcbm);
    } catch (RemoteException e) {
        throw new ImsException("getEcbmInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mEcbm;
}
#end_block

#method_before
public ImsMultiEndpoint getMultiEndpointInterface(int serviceId) throws ImsException {
    if (mMultiEndpoint == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsMultiEndpoint iImsMultiEndpoint = mImsServiceProxy.getMultiEndpointInterface();
            if (iImsMultiEndpoint == null) {
                throw new ImsException("getMultiEndpointInterface()", ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED);
            }
            mMultiEndpoint = new ImsMultiEndpoint(iImsMultiEndpoint);
        } catch (RemoteException e) {
            throw new ImsException("getMultiEndpointInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mMultiEndpoint;
}
#method_after
public ImsMultiEndpoint getMultiEndpointInterface(int serviceId) throws ImsException {
    if (mMultiEndpoint != null && mMultiEndpoint.isBinderAlive()) {
        return mMultiEndpoint;
    }
    checkAndThrowExceptionIfServiceUnavailable();
    try {
        IImsMultiEndpoint iImsMultiEndpoint = mImsServiceProxy.getMultiEndpointInterface();
        if (iImsMultiEndpoint == null) {
            throw new ImsException("getMultiEndpointInterface()", ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED);
        }
        mMultiEndpoint = new ImsMultiEndpoint(iImsMultiEndpoint);
    } catch (RemoteException e) {
        throw new ImsException("getMultiEndpointInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
    return mMultiEndpoint;
}
#end_block

#method_before
public List<BluetoothDevice> getConnectedDevices() {
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
#method_after
@Override
public List<BluetoothDevice> getConnectedDevices() {
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
#end_block

#method_before
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
#method_after
@Override
public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
#end_block

#method_before
public int getConnectionState(BluetoothDevice device) {
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
#method_after
@Override
public int getConnectionState(BluetoothDevice device) {
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
#end_block

#method_before
public void bindResponse(int ind_id, boolean ind_status) {
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.bindResponse(ind_id, ind_status);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
#method_after
public void bindResponse(int indId, boolean indStatus) {
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.bindResponse(indId, indStatus);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
#end_block

#method_before
private boolean isEnabled() {
    if (mAdapter.getState() == BluetoothAdapter.STATE_ON)
        return true;
    return false;
}
#method_after
private boolean isEnabled() {
    return mAdapter.getState() == BluetoothAdapter.STATE_ON;
}
#end_block

#method_before
private boolean isDisabled() {
    if (mAdapter.getState() == BluetoothAdapter.STATE_OFF)
        return true;
    return false;
}
#method_after
private boolean isDisabled() {
    return mAdapter.getState() == BluetoothAdapter.STATE_OFF;
}
#end_block

#method_before
private boolean isValidDevice(BluetoothDevice device) {
    if (device == null)
        return false;
    if (BluetoothAdapter.checkBluetoothAddress(device.getAddress()))
        return true;
    return false;
}
#method_after
private static boolean isValidDevice(BluetoothDevice device) {
    return device != null && BluetoothAdapter.checkBluetoothAddress(device.getAddress());
}
#end_block

#method_before
@Override
public NetworkStats getTetherStats(int how) {
    // interface counters.
    if (how != STATS_PER_UID) {
        return new NetworkStats(SystemClock.elapsedRealtime(), 0);
    }
    PersistableBundle bundle;
    try {
        bundle = mNetdService.tetherGetStats();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException("problem parsing tethering stats: ", e);
    }
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), bundle.size());
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    for (String iface : bundle.keySet()) {
        long[] statsArray = bundle.getLongArray(iface);
        try {
            entry.iface = iface;
            entry.uid = UID_TETHERING;
            entry.set = SET_DEFAULT;
            entry.tag = TAG_NONE;
            entry.rxBytes = statsArray[INetd.TETHER_STATS_RX_BYTES];
            entry.rxPackets = statsArray[INetd.TETHER_STATS_RX_PACKETS];
            entry.txBytes = statsArray[INetd.TETHER_STATS_TX_BYTES];
            entry.txPackets = statsArray[INetd.TETHER_STATS_TX_PACKETS];
            Slog.d(TAG, "Got tethering entry=" + entry);
            stats.combineValues(entry);
        } catch (NullPointerException e) {
            throw new IllegalStateException("null tethering stats for " + iface, e);
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalStateException("invalid tethering stats for " + iface, e);
        }
    }
    return stats;
}
#method_after
@Override
public NetworkStats getTetherStats(int how) {
    // interface counters.
    if (how != STATS_PER_UID) {
        return new NetworkStats(SystemClock.elapsedRealtime(), 0);
    }
    final PersistableBundle bundle;
    try {
        bundle = mNetdService.tetherGetStats();
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException("problem parsing tethering stats: ", e);
    }
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), bundle.size());
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    for (String iface : bundle.keySet()) {
        long[] statsArray = bundle.getLongArray(iface);
        try {
            entry.iface = iface;
            entry.uid = UID_TETHERING;
            entry.set = SET_DEFAULT;
            entry.tag = TAG_NONE;
            entry.rxBytes = statsArray[INetd.TETHER_STATS_RX_BYTES];
            entry.rxPackets = statsArray[INetd.TETHER_STATS_RX_PACKETS];
            entry.txBytes = statsArray[INetd.TETHER_STATS_TX_BYTES];
            entry.txPackets = statsArray[INetd.TETHER_STATS_TX_PACKETS];
            stats.combineValues(entry);
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalStateException("invalid tethering stats for " + iface, e);
        }
    }
    return stats;
}
#end_block

#method_before
private void addIndexExemplars(ULocale locale) {
    UnicodeSet exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_INDEX);
    // Android changed: check for empty exemplar sets (http://b/64953401).
    if (exemplars != null && !exemplars.isEmpty()) {
        initialLabels.addAll(exemplars);
        return;
    }
    // The locale data did not include explicit Index characters.
    // Synthesize a set of them from the locale's standard exemplar characters.
    exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_STANDARD);
    exemplars = exemplars.cloneAsThawed();
    // question: should we add auxiliary exemplars?
    if (exemplars.containsSome('a', 'z') || exemplars.size() == 0) {
        exemplars.addAll('a', 'z');
    }
    if (exemplars.containsSome(0xAC00, 0xD7A3)) {
        // Hangul syllables
        // cut down to small list
        exemplars.remove(0xAC00, 0xD7A3).add(0xAC00).add(0xB098).add(0xB2E4).add(0xB77C).add(0xB9C8).add(0xBC14).add(0xC0AC).add(0xC544).add(0xC790).add(0xCC28).add(0xCE74).add(0xD0C0).add(0xD30C).add(0xD558);
    }
    if (exemplars.containsSome(0x1200, 0x137F)) {
        // Ethiopic block
        // cut down to small list
        // make use of the fact that Ethiopic is allocated in 8's, where
        // the base is 0 mod 8.
        UnicodeSet ethiopic = new UnicodeSet("[[:Block=Ethiopic:]&[:Script=Ethiopic:]]");
        UnicodeSetIterator it = new UnicodeSetIterator(ethiopic);
        while (it.next() && it.codepoint != UnicodeSetIterator.IS_STRING) {
            if ((it.codepoint & 0x7) != 0) {
                exemplars.remove(it.codepoint);
            }
        }
    }
    // (We only do this for synthesized index characters.)
    for (String item : exemplars) {
        initialLabels.add(UCharacter.toUpperCase(locale, item));
    }
}
#method_after
private void addIndexExemplars(ULocale locale) {
    UnicodeSet exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_INDEX);
    // Android-changed: check for empty exemplar sets (http://b/64953401).
    if (exemplars != null && !exemplars.isEmpty()) {
        initialLabels.addAll(exemplars);
        return;
    }
    // The locale data did not include explicit Index characters.
    // Synthesize a set of them from the locale's standard exemplar characters.
    exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_STANDARD);
    exemplars = exemplars.cloneAsThawed();
    // question: should we add auxiliary exemplars?
    if (exemplars.containsSome('a', 'z') || exemplars.size() == 0) {
        exemplars.addAll('a', 'z');
    }
    if (exemplars.containsSome(0xAC00, 0xD7A3)) {
        // Hangul syllables
        // cut down to small list
        exemplars.remove(0xAC00, 0xD7A3).add(0xAC00).add(0xB098).add(0xB2E4).add(0xB77C).add(0xB9C8).add(0xBC14).add(0xC0AC).add(0xC544).add(0xC790).add(0xCC28).add(0xCE74).add(0xD0C0).add(0xD30C).add(0xD558);
    }
    if (exemplars.containsSome(0x1200, 0x137F)) {
        // Ethiopic block
        // cut down to small list
        // make use of the fact that Ethiopic is allocated in 8's, where
        // the base is 0 mod 8.
        UnicodeSet ethiopic = new UnicodeSet("[[:Block=Ethiopic:]&[:Script=Ethiopic:]]");
        UnicodeSetIterator it = new UnicodeSetIterator(ethiopic);
        while (it.next() && it.codepoint != UnicodeSetIterator.IS_STRING) {
            if ((it.codepoint & 0x7) != 0) {
                exemplars.remove(it.codepoint);
            }
        }
    }
    // (We only do this for synthesized index characters.)
    for (String item : exemplars) {
        initialLabels.add(UCharacter.toUpperCase(locale, item));
    }
}
#end_block

#method_before
private void addIndexExemplars(ULocale locale) {
    UnicodeSet exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_INDEX);
    // Android changed: check for empty exemplar sets (http://b/64953401).
    if (exemplars != null && !exemplars.isEmpty()) {
        initialLabels.addAll(exemplars);
        return;
    }
    // The locale data did not include explicit Index characters.
    // Synthesize a set of them from the locale's standard exemplar characters.
    exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_STANDARD);
    exemplars = exemplars.cloneAsThawed();
    // question: should we add auxiliary exemplars?
    if (exemplars.containsSome('a', 'z') || exemplars.size() == 0) {
        exemplars.addAll('a', 'z');
    }
    if (exemplars.containsSome(0xAC00, 0xD7A3)) {
        // Hangul syllables
        // cut down to small list
        exemplars.remove(0xAC00, 0xD7A3).add(0xAC00).add(0xB098).add(0xB2E4).add(0xB77C).add(0xB9C8).add(0xBC14).add(0xC0AC).add(0xC544).add(0xC790).add(0xCC28).add(0xCE74).add(0xD0C0).add(0xD30C).add(0xD558);
    }
    if (exemplars.containsSome(0x1200, 0x137F)) {
        // Ethiopic block
        // cut down to small list
        // make use of the fact that Ethiopic is allocated in 8's, where
        // the base is 0 mod 8.
        UnicodeSet ethiopic = new UnicodeSet("[[:Block=Ethiopic:]&[:Script=Ethiopic:]]");
        UnicodeSetIterator it = new UnicodeSetIterator(ethiopic);
        while (it.next() && it.codepoint != UnicodeSetIterator.IS_STRING) {
            if ((it.codepoint & 0x7) != 0) {
                exemplars.remove(it.codepoint);
            }
        }
    }
    // (We only do this for synthesized index characters.)
    for (String item : exemplars) {
        initialLabels.add(UCharacter.toUpperCase(locale, item));
    }
}
#method_after
private void addIndexExemplars(ULocale locale) {
    UnicodeSet exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_INDEX);
    // Android-changed: check for empty exemplar sets (http://b/64953401).
    if (exemplars != null && !exemplars.isEmpty()) {
        initialLabels.addAll(exemplars);
        return;
    }
    // The locale data did not include explicit Index characters.
    // Synthesize a set of them from the locale's standard exemplar characters.
    exemplars = LocaleData.getExemplarSet(locale, 0, LocaleData.ES_STANDARD);
    exemplars = exemplars.cloneAsThawed();
    // question: should we add auxiliary exemplars?
    if (exemplars.containsSome('a', 'z') || exemplars.size() == 0) {
        exemplars.addAll('a', 'z');
    }
    if (exemplars.containsSome(0xAC00, 0xD7A3)) {
        // Hangul syllables
        // cut down to small list
        exemplars.remove(0xAC00, 0xD7A3).add(0xAC00).add(0xB098).add(0xB2E4).add(0xB77C).add(0xB9C8).add(0xBC14).add(0xC0AC).add(0xC544).add(0xC790).add(0xCC28).add(0xCE74).add(0xD0C0).add(0xD30C).add(0xD558);
    }
    if (exemplars.containsSome(0x1200, 0x137F)) {
        // Ethiopic block
        // cut down to small list
        // make use of the fact that Ethiopic is allocated in 8's, where
        // the base is 0 mod 8.
        UnicodeSet ethiopic = new UnicodeSet("[[:Block=Ethiopic:]&[:Script=Ethiopic:]]");
        UnicodeSetIterator it = new UnicodeSetIterator(ethiopic);
        while (it.next() && it.codepoint != UnicodeSetIterator.IS_STRING) {
            if ((it.codepoint & 0x7) != 0) {
                exemplars.remove(it.codepoint);
            }
        }
    }
    // (We only do this for synthesized index characters.)
    for (String item : exemplars) {
        initialLabels.add(UCharacter.toUpperCase(locale, item));
    }
}
#end_block

#method_before
@Test
public void test_amharic() {
    verifyIndex(Locale.forLanguageTag("am"));
}
#method_after
@Test
public void test_amharic() {
    Locale amharic = Locale.forLanguageTag("am");
    UnicodeSet exemplarSet = LocaleData.getExemplarSet(ULocale.forLocale(amharic), 0, LocaleData.ES_INDEX);
    // If this assert fails it means that the am locale has gained an exemplar characters set
    // for index (see key ExemplarCharactersIndex in locale/am.txt). If that's the case, please
    // find another locale that's missing that key where the logic in
    // AlphabeticIndex.addIndexExemplars will generate buckets from alternate data.
    assertTrue(exemplarSet == null || exemplarSet.isEmpty());
    verifyIndex(amharic);
}
#end_block

#method_before
private void verifyIndex(Locale locale) {
    ULocale uLocale = ULocale.forLocale(locale);
    AlphabeticIndex index = new AlphabeticIndex(uLocale);
    LocaleData localeData = LocaleData.getInstance(uLocale);
    UnicodeSet exemplarSet = localeData.getExemplarSet(0, LocaleData.ES_STANDARD);
    for (String s : exemplarSet) {
        index.addRecord(s, s);
    }
    assertTrue("Not enough buckets: " + index.getBucketLabels(), index.getBucketCount() > 1);
}
#method_after
private void verifyIndex(Locale locale) {
    ULocale uLocale = ULocale.forLocale(locale);
    AlphabeticIndex index = new AlphabeticIndex(uLocale);
    LocaleData localeData = LocaleData.getInstance(uLocale);
    // 0 = "default options", there is no constant for this.
    UnicodeSet exemplarSet = localeData.getExemplarSet(0, LocaleData.ES_STANDARD);
    for (String s : exemplarSet) {
        index.addRecord(s, s);
    }
    assertTrue("Not enough buckets: " + index.getBucketLabels(), index.getBucketCount() > 1);
}
#end_block

#method_before
public void shutdown() {
    mShuttingDown = true;
    stop();
    mMultinetworkPolicyTracker.shutdown();
}
#method_after
public void shutdown() {
    stop();
    sendMessage(CMD_TERMINATE_AFTER_STOP);
}
#end_block

#method_before
@Override
protected String getLogRecString(Message msg) {
    final String logLine = String.format("%s/%d %d %d %s [%s]", mInterfaceName, mNetworkInterface == null ? -1 : mNetworkInterface.getIndex(), msg.arg1, msg.arg2, Objects.toString(msg.obj), mMsgStateLogger);
    final String richerLogLine = getWhatToString(msg.what) + " " + logLine;
    mLog.log(richerLogLine);
    if (VDBG) {
        Log.d(mTag, richerLogLine);
    }
    mMsgStateLogger.reset();
    return logLine;
}
#method_after
@Override
protected String getLogRecString(Message msg) {
    final String logLine = String.format("%s/%d %d %d %s [%s]", mInterfaceName, mNetworkInterface == null ? -1 : mNetworkInterface.getIndex(), msg.arg1, msg.arg2, Objects.toString(msg.obj), mMsgStateLogger);
    final String richerLogLine = getWhatToString(msg.what) + " " + logLine;
    mLog.log(richerLogLine);
    if (DBG) {
        Log.d(mTag, richerLogLine);
    }
    mMsgStateLogger.reset();
    return logLine;
}
#end_block

#method_before
private void dispatchCallback(ProvisioningChange delta, LinkProperties newLp) {
    switch(delta) {
        case GAINED_PROVISIONING:
            if (VDBG) {
                Log.d(mTag, "onProvisioningSuccess()");
            }
            recordMetric(IpManagerEvent.PROVISIONING_OK);
            mCallback.onProvisioningSuccess(newLp);
            break;
        case LOST_PROVISIONING:
            if (VDBG) {
                Log.d(mTag, "onProvisioningFailure()");
            }
            recordMetric(IpManagerEvent.PROVISIONING_FAIL);
            mCallback.onProvisioningFailure(newLp);
            break;
        default:
            if (VDBG) {
                Log.d(mTag, "onLinkPropertiesChange()");
            }
            mCallback.onLinkPropertiesChange(newLp);
            break;
    }
}
#method_after
private void dispatchCallback(ProvisioningChange delta, LinkProperties newLp) {
    switch(delta) {
        case GAINED_PROVISIONING:
            if (DBG) {
                Log.d(mTag, "onProvisioningSuccess()");
            }
            recordMetric(IpManagerEvent.PROVISIONING_OK);
            mCallback.onProvisioningSuccess(newLp);
            break;
        case LOST_PROVISIONING:
            if (DBG) {
                Log.d(mTag, "onProvisioningFailure()");
            }
            recordMetric(IpManagerEvent.PROVISIONING_FAIL);
            mCallback.onProvisioningFailure(newLp);
            break;
        default:
            if (DBG) {
                Log.d(mTag, "onLinkPropertiesChange()");
            }
            mCallback.onLinkPropertiesChange(newLp);
            break;
    }
}
#end_block

#method_before
private LinkProperties assembleLinkProperties() {
    // [1] Create a new LinkProperties object to populate.
    LinkProperties newLp = new LinkProperties();
    newLp.setInterfaceName(mInterfaceName);
    // [2] Pull in data from netlink:
    // - IPv4 addresses
    // - IPv6 addresses
    // - IPv6 routes
    // - IPv6 DNS servers
    // 
    // N.B.: this is fundamentally race-prone and should be fixed by
    // changing NetlinkTracker from a hybrid edge/level model to an
    // edge-only model, or by giving IpManager its own netlink socket(s)
    // so as to track all required information directly.
    LinkProperties netlinkLinkProperties = mNetlinkTracker.getLinkProperties();
    newLp.setLinkAddresses(netlinkLinkProperties.getLinkAddresses());
    for (RouteInfo route : netlinkLinkProperties.getRoutes()) {
        newLp.addRoute(route);
    }
    addAllReachableDnsServers(newLp, netlinkLinkProperties.getDnsServers());
    // to worry about concurrent modification.
    if (mDhcpResults != null) {
        for (RouteInfo route : mDhcpResults.getRoutes(mInterfaceName)) {
            newLp.addRoute(route);
        }
        addAllReachableDnsServers(newLp, mDhcpResults.dnsServers);
        newLp.setDomains(mDhcpResults.domains);
        if (mDhcpResults.mtu != 0) {
            newLp.setMtu(mDhcpResults.mtu);
        }
    }
    // [4] Add in TCP buffer sizes and HTTP Proxy config, if available.
    if (!TextUtils.isEmpty(mTcpBufferSizes)) {
        newLp.setTcpBufferSizes(mTcpBufferSizes);
    }
    if (mHttpProxy != null) {
        newLp.setHttpProxy(mHttpProxy);
    }
    // [5] Add data from InitialConfiguration
    if (mConfiguration != null && mConfiguration.mInitialConfig != null) {
        InitialConfiguration config = mConfiguration.mInitialConfig;
        // specified in the InitialConfiguration have been observed with Netlink.
        if (config.isProvisionedBy(newLp.getLinkAddresses(), null)) {
            for (IpPrefix prefix : config.directlyConnectedRoutes) {
                newLp.addRoute(new RouteInfo(prefix, null, mInterfaceName));
            }
        }
        addAllReachableDnsServers(newLp, config.dnsServers);
    }
    final LinkProperties oldLp = mLinkProperties;
    if (VDBG) {
        Log.d(mTag, String.format("Netlink-seen LPs: %s, new LPs: %s; old LPs: %s", netlinkLinkProperties, newLp, oldLp));
    }
    // from a static IP v4 config instead of manually patching them in in steps [3] and [5].
    return newLp;
}
#method_after
private LinkProperties assembleLinkProperties() {
    // [1] Create a new LinkProperties object to populate.
    LinkProperties newLp = new LinkProperties();
    newLp.setInterfaceName(mInterfaceName);
    // [2] Pull in data from netlink:
    // - IPv4 addresses
    // - IPv6 addresses
    // - IPv6 routes
    // - IPv6 DNS servers
    // 
    // N.B.: this is fundamentally race-prone and should be fixed by
    // changing NetlinkTracker from a hybrid edge/level model to an
    // edge-only model, or by giving IpManager its own netlink socket(s)
    // so as to track all required information directly.
    LinkProperties netlinkLinkProperties = mNetlinkTracker.getLinkProperties();
    newLp.setLinkAddresses(netlinkLinkProperties.getLinkAddresses());
    for (RouteInfo route : netlinkLinkProperties.getRoutes()) {
        newLp.addRoute(route);
    }
    addAllReachableDnsServers(newLp, netlinkLinkProperties.getDnsServers());
    // to worry about concurrent modification.
    if (mDhcpResults != null) {
        for (RouteInfo route : mDhcpResults.getRoutes(mInterfaceName)) {
            newLp.addRoute(route);
        }
        addAllReachableDnsServers(newLp, mDhcpResults.dnsServers);
        newLp.setDomains(mDhcpResults.domains);
        if (mDhcpResults.mtu != 0) {
            newLp.setMtu(mDhcpResults.mtu);
        }
    }
    // [4] Add in TCP buffer sizes and HTTP Proxy config, if available.
    if (!TextUtils.isEmpty(mTcpBufferSizes)) {
        newLp.setTcpBufferSizes(mTcpBufferSizes);
    }
    if (mHttpProxy != null) {
        newLp.setHttpProxy(mHttpProxy);
    }
    // [5] Add data from InitialConfiguration
    if (mConfiguration != null && mConfiguration.mInitialConfig != null) {
        InitialConfiguration config = mConfiguration.mInitialConfig;
        // specified in the InitialConfiguration have been observed with Netlink.
        if (config.isProvisionedBy(newLp.getLinkAddresses(), null)) {
            for (IpPrefix prefix : config.directlyConnectedRoutes) {
                newLp.addRoute(new RouteInfo(prefix, null, mInterfaceName));
            }
        }
        addAllReachableDnsServers(newLp, config.dnsServers);
    }
    final LinkProperties oldLp = mLinkProperties;
    if (DBG) {
        Log.d(mTag, String.format("Netlink-seen LPs: %s, new LPs: %s; old LPs: %s", netlinkLinkProperties, newLp, oldLp));
    }
    // from a static IP v4 config instead of manually patching them in in steps [3] and [5].
    return newLp;
}
#end_block

#method_before
private boolean setIPv4Address(LinkAddress address) {
    final InterfaceConfiguration ifcg = new InterfaceConfiguration();
    ifcg.setLinkAddress(address);
    try {
        mNwService.setInterfaceConfig(mInterfaceName, ifcg);
        if (VDBG)
            Log.d(mTag, "IPv4 configuration succeeded");
    } catch (IllegalStateException | RemoteException e) {
        logError("IPv4 configuration failed: %s", e);
        return false;
    }
    return true;
}
#method_after
private boolean setIPv4Address(LinkAddress address) {
    final InterfaceConfiguration ifcg = new InterfaceConfiguration();
    ifcg.setLinkAddress(address);
    try {
        mNwService.setInterfaceConfig(mInterfaceName, ifcg);
        if (DBG)
            Log.d(mTag, "IPv4 configuration succeeded");
    } catch (IllegalStateException | RemoteException e) {
        logError("IPv4 configuration failed: %s", e);
        return false;
    }
    return true;
}
#end_block

#method_before
private void handleIPv4Success(DhcpResults dhcpResults) {
    mDhcpResults = new DhcpResults(dhcpResults);
    final LinkProperties newLp = assembleLinkProperties();
    final ProvisioningChange delta = setLinkProperties(newLp);
    if (VDBG) {
        Log.d(mTag, "onNewDhcpResults(" + Objects.toString(dhcpResults) + ")");
    }
    mCallback.onNewDhcpResults(dhcpResults);
    dispatchCallback(delta, newLp);
}
#method_after
private void handleIPv4Success(DhcpResults dhcpResults) {
    mDhcpResults = new DhcpResults(dhcpResults);
    final LinkProperties newLp = assembleLinkProperties();
    final ProvisioningChange delta = setLinkProperties(newLp);
    if (DBG) {
        Log.d(mTag, "onNewDhcpResults(" + Objects.toString(dhcpResults) + ")");
    }
    mCallback.onNewDhcpResults(dhcpResults);
    dispatchCallback(delta, newLp);
}
#end_block

#method_before
private void handleIPv4Failure() {
    // TODO: Investigate deleting this clearIPv4Address() call.
    // 
    // DhcpClient will send us CMD_CLEAR_LINKADDRESS in all circumstances
    // that could trigger a call to this function. If we missed handling
    // that message in StartedState for some reason we would still clear
    // any addresses upon entry to StoppedState.
    clearIPv4Address();
    mDhcpResults = null;
    if (VDBG) {
        Log.d(mTag, "onNewDhcpResults(null)");
    }
    mCallback.onNewDhcpResults(null);
    handleProvisioningFailure();
}
#method_after
private void handleIPv4Failure() {
    // TODO: Investigate deleting this clearIPv4Address() call.
    // 
    // DhcpClient will send us CMD_CLEAR_LINKADDRESS in all circumstances
    // that could trigger a call to this function. If we missed handling
    // that message in StartedState for some reason we would still clear
    // any addresses upon entry to StoppedState.
    clearIPv4Address();
    mDhcpResults = null;
    if (DBG) {
        Log.d(mTag, "onNewDhcpResults(null)");
    }
    mCallback.onNewDhcpResults(null);
    handleProvisioningFailure();
}
#end_block

#method_before
@Override
public void enter() {
    stopAllIP();
    resetLinkProperties();
    if (mStartTimeMillis > 0) {
        recordMetric(IpManagerEvent.COMPLETE_LIFECYCLE);
        mStartTimeMillis = 0;
    }
    if (mShuttingDown) {
        quit();
    }
}
#method_after
@Override
public void enter() {
    stopAllIP();
    resetLinkProperties();
    if (mStartTimeMillis > 0) {
        recordMetric(IpManagerEvent.COMPLETE_LIFECYCLE);
        mStartTimeMillis = 0;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_STOP:
            break;
        case CMD_START:
            mConfiguration = (ProvisioningConfiguration) msg.obj;
            transitionTo(mStartedState);
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            break;
        case CMD_UPDATE_TCP_BUFFER_SIZES:
            mTcpBufferSizes = (String) msg.obj;
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            break;
        case CMD_UPDATE_HTTP_PROXY:
            mHttpProxy = (ProxyInfo) msg.obj;
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            break;
        case CMD_SET_MULTICAST_FILTER:
            mMulticastFiltering = (boolean) msg.obj;
            break;
        case DhcpClient.CMD_ON_QUIT:
            // Everything is already stopped.
            logError("Unexpected CMD_ON_QUIT (already stopped).");
            break;
        default:
            return NOT_HANDLED;
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_TERMINATE_AFTER_STOP:
            stopStateMachineUpdaters();
            quit();
            break;
        case CMD_STOP:
            break;
        case CMD_START:
            mConfiguration = (ProvisioningConfiguration) msg.obj;
            transitionTo(mStartedState);
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            break;
        case CMD_UPDATE_TCP_BUFFER_SIZES:
            mTcpBufferSizes = (String) msg.obj;
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            break;
        case CMD_UPDATE_HTTP_PROXY:
            mHttpProxy = (ProxyInfo) msg.obj;
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            break;
        case CMD_SET_MULTICAST_FILTER:
            mMulticastFiltering = (boolean) msg.obj;
            break;
        case DhcpClient.CMD_ON_QUIT:
            // Everything is already stopped.
            logError("Unexpected CMD_ON_QUIT (already stopped).");
            break;
        default:
            return NOT_HANDLED;
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#end_block

#method_before
public static String formatKernelVersion(String rawKernelVersion) {
    // Example (see tests for more):
    // Linux version 4.9.29-g958411d (android-build@xyz) (Android clang version 3.8.256229 (based on LLVM 3.8.256229)) #1 SMP PREEMPT Wed Jun 7 00:06:03 CST 2017
    // Linux version 4.9.29-geb63318482a7 (android-build@xyz) (gcc version 4.9.x 20150123 (prerelease) (GCC) ) #1 SMP PREEMPT Thu Jun 1 03:41:57 UTC 2017
    final String PROC_VERSION_REGEX = "Linux version (\\S+) " + /* group 1: "3.0.31-g6fb96c9" */
    "\\((\\S+?)\\) " + /* group 2: "x@y.com" (kernel builder) */
    "\\((.+?)\\) " + /* group 3:  kernel toolchain version information */
    "(#\\d+) " + /* group 4: "#1" */
    "(?:.*?)?" + /* ignore: optional SMP, PREEMPT, and any CONFIG_FLAGS */
    "((Sun|Mon|Tue|Wed|Thu|Fri|Sat).+)";
    /* group 5: "Thu Jun 28 11:02:39 PDT 2012" */
    Matcher m = Pattern.compile(PROC_VERSION_REGEX).matcher(rawKernelVersion);
    if (!m.matches()) {
        Log.e(TAG, "Regex did not match on /proc/version: " + rawKernelVersion);
        return "Unavailable";
    } else if (m.groupCount() < 4) {
        Log.e(TAG, "Regex match on /proc/version only returned " + m.groupCount() + " groups");
        return "Unavailable";
    }
    return // 3.0.31-g6fb96c9
    m.group(1) + " (" + m.group(3) + ")\n" + m.group(2) + " " + m.group(4) + // x@y.com #1
    "\n" + // Thu Jun 28 11:02:39 PDT 2012
    m.group(5);
}
#method_after
public static String formatKernelVersion(String rawKernelVersion) {
    // Example (see tests for more):
    // Linux version 4.9.29-g958411d (android-build@xyz) (Android clang version 3.8.256229 \
    // (based on LLVM 3.8.256229)) #1 SMP PREEMPT Wed Jun 7 00:06:03 CST 2017
    // Linux version 4.9.29-geb63318482a7 (android-build@xyz) (gcc version 4.9.x 20150123 \
    // (prerelease) (GCC) ) #1 SMP PREEMPT Thu Jun 1 03:41:57 UTC 2017
    final String PROC_VERSION_REGEX = "Linux version (\\S+) " + /* group 1: "3.0.31-g6fb96c9" */
    "\\((\\S+?)\\) " + /* group 2: "(x@y.com) " */
    "\\((.+?)\\) " + /* group 3:  kernel toolchain version information */
    "(#\\d+) " + /* group 4: "#1" */
    "(?:.*?)?" + /* ignore: optional SMP, PREEMPT, and any CONFIG_FLAGS */
    "((Sun|Mon|Tue|Wed|Thu|Fri|Sat).+)";
    /* group 5: "Thu Jun 28 11:02:39 PDT 2012" */
    Matcher m = Pattern.compile(PROC_VERSION_REGEX).matcher(rawKernelVersion);
    if (!m.matches()) {
        Log.e(TAG, "Regex did not match on /proc/version: " + rawKernelVersion);
        return "Unavailable";
    } else if (m.groupCount() < 4) {
        Log.e(TAG, "Regex match on /proc/version only returned " + m.groupCount() + " groups");
        return "Unavailable";
    }
    return // 3.0.31-g6fb96c9 (toolchain version)
    m.group(1) + " (" + m.group(3) + ")\n" + m.group(2) + " " + m.group(4) + // x@y.com #1
    "\n" + // Thu Jun 28 11:02:39 PDT 2012
    m.group(5);
}
#end_block

#method_before
public static String toString(int cause) {
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_ON_WRONG_SLOT:
            return "DIALED_ON_WRONG_SLOT";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case EMERGENCY_TEMP_FAILURE:
            return "EMERGENCY_TEMP_FAILURE";
        case EMERGENCY_PERM_FAILURE:
            return "EMERGENCY_PERM_FAILURE";
        default:
            return "INVALID: " + cause;
    }
}
#method_after
public static String toString(int cause) {
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        case EMERGENCY_TEMP_FAILURE:
            return "EMERGENCY_TEMP_FAILURE";
        case EMERGENCY_PERM_FAILURE:
            return "EMERGENCY_PERM_FAILURE";
        default:
            return "INVALID: " + cause;
    }
}
#end_block

#method_before
@Override
public void onDisconnect() {
    Log.v(this, "onDisconnect");
    hangup(android.telephony.DisconnectCause.LOCAL);
}
#method_after
@Override
public void onDisconnect() {
    Log.v(this, "onDisconnect");
    mHandler.obtainMessage(MSG_HANGUP, android.telephony.DisconnectCause.LOCAL).sendToTarget();
}
#end_block

#method_before
@Override
public void onAbort() {
    Log.v(this, "onAbort");
    hangup(android.telephony.DisconnectCause.LOCAL);
}
#method_after
@Override
public void onAbort() {
    Log.v(this, "onAbort");
    mHandler.obtainMessage(MSG_HANGUP, android.telephony.DisconnectCause.LOCAL).sendToTarget();
}
#end_block

#method_before
@Override
public void onReject() {
    Log.v(this, "onReject");
    if (isValidRingingCall()) {
        hangup(android.telephony.DisconnectCause.INCOMING_REJECTED);
    }
    super.onReject();
}
#method_after
@Override
public void onReject() {
    Log.v(this, "onReject");
    if (isValidRingingCall()) {
        mHandler.obtainMessage(MSG_HANGUP, android.telephony.DisconnectCause.INCOMING_REJECTED).sendToTarget();
    }
    super.onReject();
}
#end_block

#method_before
protected void hangup(int telephonyDisconnectCode) {
    synchronized (mLock) {
        if (mOriginalConnection != null) {
            try {
                // will not get sent to voicemail if the user opts to reject the call.
                if (isValidRingingCall()) {
                    Call call = getCall();
                    if (call != null) {
                        call.hangup();
                    } else {
                        Log.w(this, "Attempting to hangup a connection without backing call.");
                    }
                } else {
                    // We still prefer to call connection.hangup() for non-ringing calls
                    // in order to support hanging-up specific calls within a conference call.
                    // If we invoked call.hangup() while in a conference, we would end up
                    // hanging up the entire conference call instead of the specific connection.
                    mOriginalConnection.hangup();
                }
            } catch (CallStateException e) {
                Log.e(this, e, "Call to Connection.hangup failed with exception");
            }
        } else {
            if (getState() == STATE_DISCONNECTED) {
                Log.i(this, "hangup called on an already disconnected call!");
                close();
            } else {
                // There are a few cases where mOriginalConnection has not been set yet. For
                // example, when the radio has to be turned on to make an emergency call,
                // mOriginalConnection could not be set for many seconds.
                setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.LOCAL, "Local Disconnect before connection established."));
                close();
            }
        }
    }
}
#method_after
protected void hangup(int telephonyDisconnectCode) {
    if (mOriginalConnection != null) {
        try {
            // will not get sent to voicemail if the user opts to reject the call.
            if (isValidRingingCall()) {
                Call call = getCall();
                if (call != null) {
                    call.hangup();
                } else {
                    Log.w(this, "Attempting to hangup a connection without backing call.");
                }
            } else {
                // We still prefer to call connection.hangup() for non-ringing calls
                // in order to support hanging-up specific calls within a conference call.
                // If we invoked call.hangup() while in a conference, we would end up
                // hanging up the entire conference call instead of the specific connection.
                mOriginalConnection.hangup();
            }
        } catch (CallStateException e) {
            Log.e(this, e, "Call to Connection.hangup failed with exception");
        }
    } else {
        if (getState() == STATE_DISCONNECTED) {
            Log.i(this, "hangup called on an already disconnected call!");
            close();
        } else {
            // There are a few cases where mOriginalConnection has not been set yet. For
            // example, when the radio has to be turned on to make an emergency call,
            // mOriginalConnection could not be set for many seconds.
            setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.LOCAL, "Local Disconnect before connection established."));
            close();
        }
    }
}
#end_block

#method_before
void updateStateInternal() {
    if (mOriginalConnection == null) {
        return;
    }
    Call.State newState;
    // then we continue in the overridden state, else we go to the original connection's state.
    if (mIsStateOverridden && mOriginalConnectionState == mOriginalConnection.getState()) {
        newState = mConnectionOverriddenState;
    } else {
        newState = mOriginalConnection.getState();
    }
    int cause = mOriginalConnection.getDisconnectCause();
    final boolean isEmergencyNumber = PhoneNumberUtils.isEmergencyNumber(mOriginalConnection.getAddress());
    Log.v(this, "Update state from %s to %s for %s", mConnectionState, newState, this);
    if (mConnectionState != newState) {
        mConnectionState = newState;
        switch(newState) {
            case IDLE:
                break;
            case ACTIVE:
                setActiveInternal();
                break;
            case HOLDING:
                setOnHold();
                break;
            case DIALING:
            case ALERTING:
                if (mOriginalConnection != null && mOriginalConnection.isPulledCall()) {
                    setPulling();
                } else {
                    setDialing();
                }
                break;
            case INCOMING:
            case WAITING:
                setRinging();
                break;
            case DISCONNECTED:
                synchronized (mLock) {
                    if (isEmergencyNumber && (TelephonyManager.getDefault().getPhoneCount() > 1) && ((cause == android.telephony.DisconnectCause.EMERGENCY_TEMP_FAILURE) || (cause == android.telephony.DisconnectCause.EMERGENCY_PERM_FAILURE))) {
                        // We can get into a situation where the radio wants us to redial the
                        // same emergency call on the other available slot. This will not set
                        // the state to disconnected and will instead tell the
                        // TelephonyConnectionService to
                        // create a new originalConnection using the new Slot.
                        fireOnOriginalConnectionRetryDial(cause == android.telephony.DisconnectCause.EMERGENCY_PERM_FAILURE);
                    } else {
                        setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(mOriginalConnection.getDisconnectCause(), mOriginalConnection.getVendorDisconnectCause()));
                        resetDisconnectCause();
                        close();
                    }
                }
                break;
            case DISCONNECTING:
                break;
        }
    }
}
#method_after
void updateStateInternal() {
    if (mOriginalConnection == null) {
        return;
    }
    Call.State newState;
    // then we continue in the overridden state, else we go to the original connection's state.
    if (mIsStateOverridden && mOriginalConnectionState == mOriginalConnection.getState()) {
        newState = mConnectionOverriddenState;
    } else {
        newState = mOriginalConnection.getState();
    }
    int cause = mOriginalConnection.getDisconnectCause();
    Log.v(this, "Update state from %s to %s for %s", mConnectionState, newState, this);
    if (mConnectionState != newState) {
        mConnectionState = newState;
        switch(newState) {
            case IDLE:
                break;
            case ACTIVE:
                setActiveInternal();
                break;
            case HOLDING:
                setOnHold();
                break;
            case DIALING:
            case ALERTING:
                if (mOriginalConnection != null && mOriginalConnection.isPulledCall()) {
                    setPulling();
                } else {
                    setDialing();
                }
                break;
            case INCOMING:
            case WAITING:
                setRinging();
                break;
            case DISCONNECTED:
                if (shouldTreatAsEmergencyCall() && (cause == android.telephony.DisconnectCause.EMERGENCY_TEMP_FAILURE || cause == android.telephony.DisconnectCause.EMERGENCY_PERM_FAILURE)) {
                    // We can get into a situation where the radio wants us to redial the
                    // same emergency call on the other available slot. This will not set
                    // the state to disconnected and will instead tell the
                    // TelephonyConnectionService to
                    // create a new originalConnection using the new Slot.
                    fireOnOriginalConnectionRetryDial(cause == android.telephony.DisconnectCause.EMERGENCY_PERM_FAILURE);
                } else {
                    setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(mOriginalConnection.getDisconnectCause(), mOriginalConnection.getVendorDisconnectCause()));
                    close();
                }
                break;
            case DISCONNECTING:
                break;
        }
    }
}
#end_block

#method_before
private void refreshConferenceSupported() {
    boolean isVideoCall = VideoProfile.isVideo(getVideoState());
    Phone phone = getPhone();
    boolean isIms = phone.getPhoneType() == PhoneConstants.PHONE_TYPE_IMS;
    boolean isVoWifiEnabled = false;
    if (isIms) {
        ImsPhone imsPhone = (ImsPhone) phone;
        isVoWifiEnabled = imsPhone.isWifiCallingEnabled();
    }
    PhoneAccountHandle phoneAccountHandle = isIms ? PhoneUtils.makePstnPhoneAccountHandle(phone.getDefaultPhone()) : PhoneUtils.makePstnPhoneAccountHandle(phone);
    TelecomAccountRegistry telecomAccountRegistry = TelecomAccountRegistry.getInstance(getPhone().getContext());
    boolean isConferencingSupported = telecomAccountRegistry.isMergeCallSupported(phoneAccountHandle);
    boolean isImsConferencingSupported = telecomAccountRegistry.isMergeImsCallSupported(phoneAccountHandle);
    mIsCarrierVideoConferencingSupported = telecomAccountRegistry.isVideoConferencingSupported(phoneAccountHandle);
    boolean isMergeOfWifiCallsAllowedWhenVoWifiOff = telecomAccountRegistry.isMergeOfWifiCallsAllowedWhenVoWifiOff(phoneAccountHandle);
    Log.v(this, "refreshConferenceSupported : isConfSupp=%b, isImsConfSupp=%b, " + "isVidConfSupp=%b, isMergeOfWifiAllowed=%b, " + "isWifi=%b, isVoWifiEnabled=%b", isConferencingSupported, isImsConferencingSupported, mIsCarrierVideoConferencingSupported, isMergeOfWifiCallsAllowedWhenVoWifiOff, isWifi(), isVoWifiEnabled);
    boolean isConferenceSupported = true;
    if (mTreatAsEmergencyCall) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; emergency call");
    } else if (!isConferencingSupported || isIms && !isImsConferencingSupported) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; carrier doesn't support conf.");
    } else if (isVideoCall && !mIsCarrierVideoConferencingSupported) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; video conf not supported.");
    } else if (!isMergeOfWifiCallsAllowedWhenVoWifiOff && isWifi() && !isVoWifiEnabled) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; can't merge wifi calls when voWifi off.");
    } else {
        Log.d(this, "refreshConferenceSupported = true.");
    }
    if (isConferenceSupported != isConferenceSupported()) {
        setConferenceSupported(isConferenceSupported);
        notifyConferenceSupportedChanged(isConferenceSupported);
    }
}
#method_after
private void refreshConferenceSupported() {
    boolean isVideoCall = VideoProfile.isVideo(getVideoState());
    Phone phone = getPhone();
    if (phone == null) {
        Log.w(this, "refreshConferenceSupported = false; phone is null");
        if (isConferenceSupported()) {
            setConferenceSupported(false);
            notifyConferenceSupportedChanged(false);
        }
        return;
    }
    boolean isIms = phone.getPhoneType() == PhoneConstants.PHONE_TYPE_IMS;
    boolean isVoWifiEnabled = false;
    if (isIms) {
        ImsPhone imsPhone = (ImsPhone) phone;
        isVoWifiEnabled = ImsUtil.isWfcEnabled(phone.getContext());
    }
    PhoneAccountHandle phoneAccountHandle = isIms ? PhoneUtils.makePstnPhoneAccountHandle(phone.getDefaultPhone()) : PhoneUtils.makePstnPhoneAccountHandle(phone);
    TelecomAccountRegistry telecomAccountRegistry = TelecomAccountRegistry.getInstance(getPhone().getContext());
    boolean isConferencingSupported = telecomAccountRegistry.isMergeCallSupported(phoneAccountHandle);
    boolean isImsConferencingSupported = telecomAccountRegistry.isMergeImsCallSupported(phoneAccountHandle);
    mIsCarrierVideoConferencingSupported = telecomAccountRegistry.isVideoConferencingSupported(phoneAccountHandle);
    boolean isMergeOfWifiCallsAllowedWhenVoWifiOff = telecomAccountRegistry.isMergeOfWifiCallsAllowedWhenVoWifiOff(phoneAccountHandle);
    Log.v(this, "refreshConferenceSupported : isConfSupp=%b, isImsConfSupp=%b, " + "isVidConfSupp=%b, isMergeOfWifiAllowed=%b, " + "isWifi=%b, isVoWifiEnabled=%b", isConferencingSupported, isImsConferencingSupported, mIsCarrierVideoConferencingSupported, isMergeOfWifiCallsAllowedWhenVoWifiOff, isWifi(), isVoWifiEnabled);
    boolean isConferenceSupported = true;
    if (mTreatAsEmergencyCall) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; emergency call");
    } else if (!isConferencingSupported || isIms && !isImsConferencingSupported) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; carrier doesn't support conf.");
    } else if (isVideoCall && !mIsCarrierVideoConferencingSupported) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; video conf not supported.");
    } else if (!isMergeOfWifiCallsAllowedWhenVoWifiOff && isWifi() && !isVoWifiEnabled) {
        isConferenceSupported = false;
        Log.d(this, "refreshConferenceSupported = false; can't merge wifi calls when voWifi off.");
    } else {
        Log.d(this, "refreshConferenceSupported = true.");
    }
    if (isConferenceSupported != isConferenceSupported()) {
        setConferenceSupported(isConferenceSupported);
        notifyConferenceSupportedChanged(isConferenceSupported);
    }
}
#end_block

#method_before
@Override
public Connection onCreateOutgoingConnection(PhoneAccountHandle connectionManagerPhoneAccount, final ConnectionRequest request) {
    Log.i(this, "onCreateOutgoingConnection, request: " + request);
    Uri handle = request.getAddress();
    if (handle == null) {
        Log.d(this, "onCreateOutgoingConnection, handle is null");
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.NO_PHONE_NUMBER_SUPPLIED, "No phone number supplied"));
    }
    String scheme = handle.getScheme();
    String number;
    if (PhoneAccount.SCHEME_VOICEMAIL.equals(scheme)) {
        // TODO: We don't check for SecurityException here (requires
        // CALL_PRIVILEGED permission).
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), false);
        if (phone == null) {
            Log.d(this, "onCreateOutgoingConnection, phone is null");
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "Phone is null"));
        }
        number = phone.getVoiceMailNumber();
        if (TextUtils.isEmpty(number)) {
            Log.d(this, "onCreateOutgoingConnection, no voicemail number set.");
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.VOICEMAIL_NUMBER_MISSING, "Voicemail scheme provided but no voicemail number set."));
        }
        // Convert voicemail: to tel:
        handle = Uri.fromParts(PhoneAccount.SCHEME_TEL, number, null);
    } else {
        if (!PhoneAccount.SCHEME_TEL.equals(scheme)) {
            Log.d(this, "onCreateOutgoingConnection, Handle %s is not type tel", scheme);
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.INVALID_NUMBER, "Handle scheme is not type tel"));
        }
        number = handle.getSchemeSpecificPart();
        if (TextUtils.isEmpty(number)) {
            Log.d(this, "onCreateOutgoingConnection, unable to parse number");
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.INVALID_NUMBER, "Unable to parse number"));
        }
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), false);
        if (phone != null && CDMA_ACTIVATION_CODE_REGEX_PATTERN.matcher(number).matches()) {
            // Obtain the configuration for the outgoing phone's SIM. If the outgoing number
            // matches the *228 regex pattern, fail the call. This number is used for OTASP, and
            // when dialed could lock LTE SIMs to 3G if not prohibited..
            boolean disableActivation = false;
            CarrierConfigManager cfgManager = (CarrierConfigManager) phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            if (cfgManager != null) {
                disableActivation = cfgManager.getConfigForSubId(phone.getSubId()).getBoolean(CarrierConfigManager.KEY_DISABLE_CDMA_ACTIVATION_CODE_BOOL);
            }
            if (disableActivation) {
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.CDMA_ALREADY_ACTIVATED, "Tried to dial *228"));
            }
        }
    }
    // This is required in some regions (e.g. Taiwan).
    if (!PhoneNumberUtils.isLocalEmergencyNumber(this, number) && PhoneNumberUtils.isConvertToEmergencyNumberEnabled()) {
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), false);
        // service.
        if (phone == null || phone.getServiceState().getState() != ServiceState.STATE_IN_SERVICE) {
            String convertedNumber = PhoneNumberUtils.convertToEmergencyNumber(number);
            if (!TextUtils.equals(convertedNumber, number)) {
                Log.i(this, "onCreateOutgoingConnection, converted to emergency number");
                number = convertedNumber;
                handle = Uri.fromParts(PhoneAccount.SCHEME_TEL, number, null);
            }
        }
    }
    final String numberToDial = number;
    final boolean isEmergencyNumber = PhoneNumberUtils.isLocalEmergencyNumber(this, numberToDial);
    if ((isEmergencyNumber && !isRadioOn()) || isRadioPowerDownOnBluetooth()) {
        final Uri resultHandle = handle;
        // By default, Connection based on the default Phone, since we need to return to Telecom
        // now.
        final Connection resultConnection = getTelephonyConnection(request, numberToDial, isEmergencyNumber, resultHandle, PhoneFactory.getDefaultPhone());
        RadioOnHelper radioOnHelper = new RadioOnHelper(this);
        radioOnHelper.enableRadioOnCalling(new RadioOnStateListener.Callback() {

            @Override
            public void onComplete(RadioOnStateListener listener, boolean isRadioReady) {
                handleOnComplete(isRadioReady, isEmergencyNumber, resultConnection, request, numberToDial, resultHandle);
            }

            @Override
            public boolean isOkToCall(Phone phone, int serviceState) {
                if (isEmergencyNumber) {
                    return (phone.getState() == PhoneConstants.State.OFFHOOK) || phone.getServiceStateTracker().isRadioOn();
                } else {
                    return (phone.getState() == PhoneConstants.State.OFFHOOK) || serviceState == ServiceState.STATE_IN_SERVICE;
                }
            }
        });
        // connecting it to the underlying Phone.
        return resultConnection;
    } else {
        if (!canAddCall() && !isEmergencyNumber) {
            Log.d(this, "onCreateOutgoingConnection, cannot add call .");
            return Connection.createFailedConnection(new DisconnectCause(DisconnectCause.ERROR, getApplicationContext().getText(R.string.incall_error_cannot_add_call), getApplicationContext().getText(R.string.incall_error_cannot_add_call), "Add call restricted due to ongoing video call"));
        }
        // Get the right phone object from the account data passed in.
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), isEmergencyNumber);
        Connection resultConnection = getTelephonyConnection(request, numberToDial, isEmergencyNumber, handle, phone);
        // so don't place the call!
        if (resultConnection instanceof TelephonyConnection) {
            placeOutgoingConnection((TelephonyConnection) resultConnection, phone, request);
        }
        return resultConnection;
    }
}
#method_after
@Override
public Connection onCreateOutgoingConnection(PhoneAccountHandle connectionManagerPhoneAccount, final ConnectionRequest request) {
    Log.i(this, "onCreateOutgoingConnection, request: " + request);
    Uri handle = request.getAddress();
    if (handle == null) {
        Log.d(this, "onCreateOutgoingConnection, handle is null");
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.NO_PHONE_NUMBER_SUPPLIED, "No phone number supplied"));
    }
    String scheme = handle.getScheme();
    String number;
    if (PhoneAccount.SCHEME_VOICEMAIL.equals(scheme)) {
        // TODO: We don't check for SecurityException here (requires
        // CALL_PRIVILEGED permission).
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), false);
        if (phone == null) {
            Log.d(this, "onCreateOutgoingConnection, phone is null");
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "Phone is null"));
        }
        number = phone.getVoiceMailNumber();
        if (TextUtils.isEmpty(number)) {
            Log.d(this, "onCreateOutgoingConnection, no voicemail number set.");
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.VOICEMAIL_NUMBER_MISSING, "Voicemail scheme provided but no voicemail number set."));
        }
        // Convert voicemail: to tel:
        handle = Uri.fromParts(PhoneAccount.SCHEME_TEL, number, null);
    } else {
        if (!PhoneAccount.SCHEME_TEL.equals(scheme)) {
            Log.d(this, "onCreateOutgoingConnection, Handle %s is not type tel", scheme);
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.INVALID_NUMBER, "Handle scheme is not type tel"));
        }
        number = handle.getSchemeSpecificPart();
        if (TextUtils.isEmpty(number)) {
            Log.d(this, "onCreateOutgoingConnection, unable to parse number");
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.INVALID_NUMBER, "Unable to parse number"));
        }
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), false);
        if (phone != null && CDMA_ACTIVATION_CODE_REGEX_PATTERN.matcher(number).matches()) {
            // Obtain the configuration for the outgoing phone's SIM. If the outgoing number
            // matches the *228 regex pattern, fail the call. This number is used for OTASP, and
            // when dialed could lock LTE SIMs to 3G if not prohibited..
            boolean disableActivation = false;
            CarrierConfigManager cfgManager = (CarrierConfigManager) phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            if (cfgManager != null) {
                disableActivation = cfgManager.getConfigForSubId(phone.getSubId()).getBoolean(CarrierConfigManager.KEY_DISABLE_CDMA_ACTIVATION_CODE_BOOL);
            }
            if (disableActivation) {
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.CDMA_ALREADY_ACTIVATED, "Tried to dial *228"));
            }
        }
    }
    // This is required in some regions (e.g. Taiwan).
    if (!PhoneNumberUtils.isLocalEmergencyNumber(this, number)) {
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), false);
        // service.
        if (phone == null || phone.getServiceState().getState() != ServiceState.STATE_IN_SERVICE) {
            String convertedNumber = PhoneNumberUtils.convertToEmergencyNumber(this, number);
            if (!TextUtils.equals(convertedNumber, number)) {
                Log.i(this, "onCreateOutgoingConnection, converted to emergency number");
                number = convertedNumber;
                handle = Uri.fromParts(PhoneAccount.SCHEME_TEL, number, null);
            }
        }
    }
    final String numberToDial = number;
    final boolean isEmergencyNumber = PhoneNumberUtils.isLocalEmergencyNumber(this, numberToDial);
    final boolean isAirplaneModeOn = Settings.Global.getInt(getContentResolver(), Settings.Global.AIRPLANE_MODE_ON, 0) > 0;
    boolean needToTurnOnRadio = (isEmergencyNumber && (!isRadioOn() || isAirplaneModeOn)) || isRadioPowerDownOnBluetooth();
    if (needToTurnOnRadio) {
        final Uri resultHandle = handle;
        // By default, Connection based on the default Phone, since we need to return to Telecom
        // now.
        final int originalPhoneType = PhoneFactory.getDefaultPhone().getPhoneType();
        final Connection resultConnection = getTelephonyConnection(request, numberToDial, isEmergencyNumber, resultHandle, PhoneFactory.getDefaultPhone());
        if (mRadioOnHelper == null) {
            mRadioOnHelper = new RadioOnHelper(this);
        }
        mRadioOnHelper.triggerRadioOnAndListen(new RadioOnStateListener.Callback() {

            @Override
            public void onComplete(RadioOnStateListener listener, boolean isRadioReady) {
                handleOnComplete(isRadioReady, isEmergencyNumber, resultConnection, request, numberToDial, resultHandle, originalPhoneType);
            }

            @Override
            public boolean isOkToCall(Phone phone, int serviceState) {
                if (isEmergencyNumber) {
                    // reporting the OUT_OF_SERVICE state.
                    return (phone.getState() == PhoneConstants.State.OFFHOOK) || phone.getServiceStateTracker().isRadioOn();
                } else {
                    // to save power on watches.
                    return (phone.getState() == PhoneConstants.State.OFFHOOK) || serviceState == ServiceState.STATE_IN_SERVICE;
                }
            }
        });
        // connecting it to the underlying Phone.
        return resultConnection;
    } else {
        if (!canAddCall() && !isEmergencyNumber) {
            Log.d(this, "onCreateOutgoingConnection, cannot add call .");
            return Connection.createFailedConnection(new DisconnectCause(DisconnectCause.ERROR, getApplicationContext().getText(R.string.incall_error_cannot_add_call), getApplicationContext().getText(R.string.incall_error_cannot_add_call), "Add call restricted due to ongoing video call"));
        }
        // Get the right phone object from the account data passed in.
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), isEmergencyNumber);
        Connection resultConnection = getTelephonyConnection(request, numberToDial, isEmergencyNumber, handle, phone);
        // so don't place the call!
        if (resultConnection instanceof TelephonyConnection) {
            placeOutgoingConnection((TelephonyConnection) resultConnection, phone, request);
        }
        return resultConnection;
    }
}
#end_block

#method_before
private boolean isRadioPowerDownOnBluetooth() {
    final Context context = getApplicationContext();
    final boolean allowed = context.getResources().getBoolean(R.bool.config_allowRadioPowerDownOnBluetooth);
    final int cellOn = Settings.Global.getInt(context.getContentResolver(), Settings.Global.CELL_ON, PhoneConstants.CELL_ON_FLAG);
    return (allowed && cellOn == PhoneConstants.CELL_ON_FLAG && !isRadioOn());
}
#method_after
private boolean isRadioPowerDownOnBluetooth() {
    final Context context = getApplicationContext();
    final boolean allowed = context.getResources().getBoolean(R.bool.config_allowRadioPowerDownOnBluetooth);
    final int cellOn = Settings.Global.getInt(context.getContentResolver(), Settings.Global.CELL_ON, PhoneConstants.CELL_OFF_FLAG);
    return (allowed && cellOn == PhoneConstants.CELL_ON_FLAG && !isRadioOn());
}
#end_block

#method_before
private void handleOnComplete(boolean isRadioReady, boolean isEmergencyNumber, Connection originalConnection, ConnectionRequest request, String numberToDial, Uri handle) {
    // Make sure the Call has not already been canceled by the user.
    if (originalConnection.getState() == Connection.STATE_DISCONNECTED) {
        Log.i(this, "Emergency call disconnected before the outgoing call was " + "placed. Skipping emergency call placement.");
        return;
    }
    if (isRadioReady) {
        // Get the right phone object since the radio has been turned on
        // successfully.
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), isEmergencyNumber);
        // replace it in Telecom.
        if (phone.getPhoneType() != PhoneFactory.getDefaultPhone().getPhoneType()) {
            Connection repConnection = getTelephonyConnection(request, numberToDial, isEmergencyNumber, handle, phone);
            // TelephonyConnection, so don't place the call, just return!
            if (repConnection instanceof TelephonyConnection) {
                placeOutgoingConnection((TelephonyConnection) repConnection, phone, request);
            }
            // Notify Telecom of the new Connection type.
            // TODO: Switch out the underlying connection instead of creating a new
            // one and causing UI Jank.
            addExistingConnection(PhoneUtils.makePstnPhoneAccountHandle(phone), repConnection);
            // Remove the old connection from Telecom after.
            originalConnection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUTGOING_CANCELED, "Reconnecting outgoing Emergency Call."));
            originalConnection.destroy();
        } else {
            placeOutgoingConnection((TelephonyConnection) originalConnection, phone, request);
        }
    } else {
        Log.w(this, "onCreateOutgoingConnection, failed to turn on radio");
        originalConnection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.POWER_OFF, "Failed to turn on radio."));
        originalConnection.destroy();
    }
}
#method_after
private void handleOnComplete(boolean isRadioReady, boolean isEmergencyNumber, Connection originalConnection, ConnectionRequest request, String numberToDial, Uri handle, int originalPhoneType) {
    // Make sure the Call has not already been canceled by the user.
    if (originalConnection.getState() == Connection.STATE_DISCONNECTED) {
        Log.i(this, "Call disconnected before the outgoing call was placed. Skipping call " + "placement.");
        return;
    }
    if (isRadioReady) {
        // Get the right phone object since the radio has been turned on
        // successfully.
        final Phone phone = getPhoneForAccount(request.getAccountHandle(), isEmergencyNumber);
        // need create a new Connection using that PhoneType and replace it in Telecom.
        if (phone.getPhoneType() != originalPhoneType) {
            Connection repConnection = getTelephonyConnection(request, numberToDial, isEmergencyNumber, handle, phone);
            // TelephonyConnection, so don't place the call, just return!
            if (repConnection instanceof TelephonyConnection) {
                placeOutgoingConnection((TelephonyConnection) repConnection, phone, request);
            }
            // Notify Telecom of the new Connection type.
            // TODO: Switch out the underlying connection instead of creating a new
            // one and causing UI Jank.
            addExistingConnection(PhoneUtils.makePstnPhoneAccountHandle(phone), repConnection);
            // Remove the old connection from Telecom after.
            originalConnection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUTGOING_CANCELED, "Reconnecting outgoing Emergency Call."));
            originalConnection.destroy();
        } else {
            placeOutgoingConnection((TelephonyConnection) originalConnection, phone, request);
        }
    } else {
        Log.w(this, "onCreateOutgoingConnection, failed to turn on radio");
        originalConnection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.POWER_OFF, "Failed to turn on radio."));
        originalConnection.destroy();
    }
}
#end_block

#method_before
private Connection getTelephonyConnection(final ConnectionRequest request, final String number, boolean isEmergencyNumber, final Uri handle, Phone phone) {
    if (phone == null) {
        final Context context = getApplicationContext();
        if (context.getResources().getBoolean(R.bool.config_checkSimStateBeforeOutgoingCall)) {
            // Check SIM card state before the outgoing call.
            // Start the SIM unlock activity if PIN_REQUIRED.
            final Phone defaultPhone = PhoneFactory.getDefaultPhone();
            final IccCard icc = defaultPhone.getIccCard();
            IccCardConstants.State simState = IccCardConstants.State.UNKNOWN;
            if (icc != null) {
                simState = icc.getState();
            }
            if (simState == IccCardConstants.State.PIN_REQUIRED) {
                final String simUnlockUiPackage = context.getResources().getString(R.string.config_simUnlockUiPackage);
                final String simUnlockUiClass = context.getResources().getString(R.string.config_simUnlockUiClass);
                if (simUnlockUiPackage != null && simUnlockUiClass != null) {
                    Intent simUnlockIntent = new Intent().setComponent(new ComponentName(simUnlockUiPackage, simUnlockUiClass));
                    simUnlockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        context.startActivity(simUnlockIntent);
                    } catch (ActivityNotFoundException exception) {
                        Log.e(this, exception, "Unable to find SIM unlock UI activity.");
                    }
                }
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "SIM_STATE_PIN_REQUIRED"));
            }
        }
        Log.d(this, "onCreateOutgoingConnection, phone is null");
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "Phone is null"));
    }
    // Check both voice & data RAT to enable normal CS call,
    // when voice RAT is OOS but Data RAT is present.
    int state = phone.getServiceState().getState();
    if (state == ServiceState.STATE_OUT_OF_SERVICE) {
        int dataNetType = phone.getServiceState().getDataNetworkType();
        if (dataNetType == TelephonyManager.NETWORK_TYPE_LTE || dataNetType == TelephonyManager.NETWORK_TYPE_LTE_CA) {
            state = phone.getServiceState().getDataRegState();
        }
    }
    // carrier configuration specifies that we cannot make non-emergency calls in ECM mode.
    if (!isEmergencyNumber && phone.isInEcm()) {
        boolean allowNonEmergencyCalls = true;
        CarrierConfigManager cfgManager = (CarrierConfigManager) phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (cfgManager != null) {
            allowNonEmergencyCalls = cfgManager.getConfigForSubId(phone.getSubId()).getBoolean(CarrierConfigManager.KEY_ALLOW_NON_EMERGENCY_CALLS_IN_ECM_BOOL);
        }
        if (!allowNonEmergencyCalls) {
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.CDMA_NOT_EMERGENCY, "Cannot make non-emergency call in ECM mode."));
        }
    }
    if (!isEmergencyNumber) {
        switch(state) {
            case ServiceState.STATE_IN_SERVICE:
            case ServiceState.STATE_EMERGENCY_ONLY:
                break;
            case ServiceState.STATE_OUT_OF_SERVICE:
                if (phone.isUtEnabled() && number.endsWith("#")) {
                    Log.d(this, "onCreateOutgoingConnection dial for UT");
                    break;
                } else {
                    return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "ServiceState.STATE_OUT_OF_SERVICE"));
                }
            case ServiceState.STATE_POWER_OFF:
                // Don't disconnect if radio is power off because the device is on Bluetooth.
                if (isRadioPowerDownOnBluetooth()) {
                    break;
                }
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.POWER_OFF, "ServiceState.STATE_POWER_OFF"));
            default:
                Log.d(this, "onCreateOutgoingConnection, unknown service state: %d", state);
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUTGOING_FAILURE, "Unknown service state " + state));
        }
    }
    final Context context = getApplicationContext();
    if (VideoProfile.isVideo(request.getVideoState()) && isTtyModeEnabled(context) && !isEmergencyNumber) {
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED));
    }
    // Check for additional limits on CDMA phones.
    final Connection failedConnection = checkAdditionalOutgoingCallLimits(phone);
    if (failedConnection != null) {
        return failedConnection;
    }
    // Check roaming status to see if we should block custom call forwarding codes
    if (blockCallForwardingNumberWhileRoaming(phone, number)) {
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.DIALED_CALL_FORWARDING_WHILE_ROAMING, "Call forwarding while roaming"));
    }
    final TelephonyConnection connection = createConnectionFor(phone, null, true, /* isOutgoing */
    request.getAccountHandle(), request.getTelecomCallId(), request.getAddress(), request.getVideoState());
    if (connection == null) {
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUTGOING_FAILURE, "Invalid phone type"));
    }
    connection.setAddress(handle, PhoneConstants.PRESENTATION_ALLOWED);
    connection.setInitializing();
    connection.setVideoState(request.getVideoState());
    return connection;
}
#method_after
private Connection getTelephonyConnection(final ConnectionRequest request, final String number, boolean isEmergencyNumber, final Uri handle, Phone phone) {
    if (phone == null) {
        final Context context = getApplicationContext();
        if (context.getResources().getBoolean(R.bool.config_checkSimStateBeforeOutgoingCall)) {
            // Check SIM card state before the outgoing call.
            // Start the SIM unlock activity if PIN_REQUIRED.
            final Phone defaultPhone = mPhoneFactoryProxy.getDefaultPhone();
            final IccCard icc = defaultPhone.getIccCard();
            IccCardConstants.State simState = IccCardConstants.State.UNKNOWN;
            if (icc != null) {
                simState = icc.getState();
            }
            if (simState == IccCardConstants.State.PIN_REQUIRED) {
                final String simUnlockUiPackage = context.getResources().getString(R.string.config_simUnlockUiPackage);
                final String simUnlockUiClass = context.getResources().getString(R.string.config_simUnlockUiClass);
                if (simUnlockUiPackage != null && simUnlockUiClass != null) {
                    Intent simUnlockIntent = new Intent().setComponent(new ComponentName(simUnlockUiPackage, simUnlockUiClass));
                    simUnlockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        context.startActivity(simUnlockIntent);
                    } catch (ActivityNotFoundException exception) {
                        Log.e(this, exception, "Unable to find SIM unlock UI activity.");
                    }
                }
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "SIM_STATE_PIN_REQUIRED"));
            }
        }
        Log.d(this, "onCreateOutgoingConnection, phone is null");
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "Phone is null"));
    }
    // Check both voice & data RAT to enable normal CS call,
    // when voice RAT is OOS but Data RAT is present.
    int state = phone.getServiceState().getState();
    if (state == ServiceState.STATE_OUT_OF_SERVICE) {
        int dataNetType = phone.getServiceState().getDataNetworkType();
        if (dataNetType == TelephonyManager.NETWORK_TYPE_LTE || dataNetType == TelephonyManager.NETWORK_TYPE_LTE_CA) {
            state = phone.getServiceState().getDataRegState();
        }
    }
    // carrier configuration specifies that we cannot make non-emergency calls in ECM mode.
    if (!isEmergencyNumber && phone.isInEcm()) {
        boolean allowNonEmergencyCalls = true;
        CarrierConfigManager cfgManager = (CarrierConfigManager) phone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (cfgManager != null) {
            allowNonEmergencyCalls = cfgManager.getConfigForSubId(phone.getSubId()).getBoolean(CarrierConfigManager.KEY_ALLOW_NON_EMERGENCY_CALLS_IN_ECM_BOOL);
        }
        if (!allowNonEmergencyCalls) {
            return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.CDMA_NOT_EMERGENCY, "Cannot make non-emergency call in ECM mode."));
        }
    }
    if (!isEmergencyNumber) {
        switch(state) {
            case ServiceState.STATE_IN_SERVICE:
            case ServiceState.STATE_EMERGENCY_ONLY:
                break;
            case ServiceState.STATE_OUT_OF_SERVICE:
                if (phone.isUtEnabled() && number.endsWith("#")) {
                    Log.d(this, "onCreateOutgoingConnection dial for UT");
                    break;
                } else {
                    return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUT_OF_SERVICE, "ServiceState.STATE_OUT_OF_SERVICE"));
                }
            case ServiceState.STATE_POWER_OFF:
                // Don't disconnect if radio is power off because the device is on Bluetooth.
                if (isRadioPowerDownOnBluetooth()) {
                    break;
                }
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.POWER_OFF, "ServiceState.STATE_POWER_OFF"));
            default:
                Log.d(this, "onCreateOutgoingConnection, unknown service state: %d", state);
                return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUTGOING_FAILURE, "Unknown service state " + state));
        }
    }
    final Context context = getApplicationContext();
    if (VideoProfile.isVideo(request.getVideoState()) && isTtyModeEnabled(context) && !isEmergencyNumber) {
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED));
    }
    // Check for additional limits on CDMA phones.
    final Connection failedConnection = checkAdditionalOutgoingCallLimits(phone);
    if (failedConnection != null) {
        return failedConnection;
    }
    // Check roaming status to see if we should block custom call forwarding codes
    if (blockCallForwardingNumberWhileRoaming(phone, number)) {
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.DIALED_CALL_FORWARDING_WHILE_ROAMING, "Call forwarding while roaming"));
    }
    final TelephonyConnection connection = createConnectionFor(phone, null, true, /* isOutgoing */
    request.getAccountHandle(), request.getTelecomCallId(), request.getAddress(), request.getVideoState());
    if (connection == null) {
        return Connection.createFailedConnection(DisconnectCauseUtil.toTelecomDisconnectCause(android.telephony.DisconnectCause.OUTGOING_FAILURE, "Invalid phone type"));
    }
    connection.setAddress(handle, PhoneConstants.PRESENTATION_ALLOWED);
    connection.setInitializing();
    connection.setVideoState(request.getVideoState());
    return connection;
}
#end_block

#method_before
private boolean isRadioOn() {
    boolean result = false;
    for (Phone phone : PhoneFactory.getPhones()) {
        result |= phone.isRadioOn();
    }
    return result;
}
#method_after
private boolean isRadioOn() {
    boolean result = false;
    for (Phone phone : mPhoneFactoryProxy.getPhones()) {
        result |= phone.isRadioOn();
    }
    return result;
}
#end_block

#method_before
private Pair<WeakReference<TelephonyConnection>, List<Phone>> makeCachedConnectionPhonePair(TelephonyConnection c) {
    List<Phone> phones = new ArrayList<>(TelephonyManager.getDefault().getPhoneCount());
    for (Phone phone : PhoneFactory.getPhones()) {
        if (mIsPermDiscCauseReceived[phone.getPhoneId()] == false) {
            phones.add(phone);
        }
    }
    return new Pair<>(new WeakReference<>(c), phones);
}
#method_after
private Pair<WeakReference<TelephonyConnection>, List<Phone>> makeCachedConnectionPhonePair(TelephonyConnection c) {
    List<Phone> phones = new ArrayList<>(Arrays.asList(mPhoneFactoryProxy.getPhones()));
    return new Pair<>(new WeakReference<>(c), phones);
}
#end_block

#method_before
private void retryOutgoingOriginalConnection(TelephonyConnection c, boolean isPermanentFailure) {
    int phoneId = c.getPhone().getPhoneId();
    mIsPermDiscCauseReceived[phoneId] = isPermanentFailure;
    // Regenerate cache connection phone pair based on disconnect cause received.
    mEmergencyRetryCache = makeCachedConnectionPhonePair(c);
    Phone newPhoneToUse = getPhoneForRedial(c.getPhone());
    if (newPhoneToUse != null) {
        int videoState = c.getVideoState();
        Bundle connExtras = c.getExtras();
        Log.i(this, "retryOutgoingOriginalConnection, redialing on Phone Id: " + newPhoneToUse);
        c.clearOriginalConnection();
        if (phoneId != newPhoneToUse.getPhoneId())
            updatePhoneAccount(c, newPhoneToUse);
        placeOutgoingConnection(c, newPhoneToUse, videoState, connExtras);
    } else {
        // We have run out of Phones to use. Disconnect the call and destroy the connection.
        Log.i(this, "retryOutgoingOriginalConnection, no more Phones to use. Disconnecting.");
        c.setDisconnected(new DisconnectCause(DisconnectCause.ERROR));
        c.clearOriginalConnection();
        resetDisconnectCause();
        c.destroy();
    }
}
#method_after
private void retryOutgoingOriginalConnection(TelephonyConnection c, boolean isPermanentFailure) {
    int phoneId = c.getPhone() == null ? -1 : c.getPhone().getPhoneId();
    updateCachedConnectionPhonePair(c, isPermanentFailure);
    Phone newPhoneToUse = (mEmergencyRetryCache.second != null) ? mEmergencyRetryCache.second.get(0) : null;
    if (newPhoneToUse != null) {
        int videoState = c.getVideoState();
        Bundle connExtras = c.getExtras();
        Log.i(this, "retryOutgoingOriginalConnection, redialing on Phone Id: " + newPhoneToUse);
        c.clearOriginalConnection();
        if (phoneId != newPhoneToUse.getPhoneId())
            updatePhoneAccount(c, newPhoneToUse);
        placeOutgoingConnection(c, newPhoneToUse, videoState, connExtras);
    } else {
        // We have run out of Phones to use. Disconnect the call and destroy the connection.
        Log.i(this, "retryOutgoingOriginalConnection, no more Phones to use. Disconnecting.");
        c.setDisconnected(new DisconnectCause(DisconnectCause.ERROR));
        c.clearOriginalConnection();
        c.destroy();
    }
}
#end_block

#method_before
private void updatePhoneAccount(TelephonyConnection connection, Phone phone) {
    PhoneAccountHandle pHandle = PhoneUtils.makePstnPhoneAccountHandle(phone);
    // For ECall handling on MSIM, till the request reaches here(i.e PhoneApp)
    // we dont know on which phone account ECall can be placed, once after deciding
    // the phone account for ECall we should inform Telecomm so that
    // the proper sub information will be displayed on InCallUI.
    Log.i(this, "updatePhoneAccount setPhoneAccountHandle, account = " + pHandle);
    Bundle extrasAccountHandle = new Bundle();
    extrasAccountHandle.putParcelable(TelephonyManager.EMR_DIAL_ACCOUNT, pHandle);
    connection.sendConnectionEvent(TelephonyManager.EVENT_PHONE_ACCOUNT_CHANGED, extrasAccountHandle);
}
#method_after
private void updatePhoneAccount(TelephonyConnection connection, Phone phone) {
    PhoneAccountHandle pHandle = PhoneUtils.makePstnPhoneAccountHandle(phone);
    // For ECall handling on MSIM, till the request reaches here(i.e PhoneApp)
    // we dont know on which phone account ECall can be placed, once after deciding
    // the phone account for ECall we should inform Telecomm so that
    // the proper sub information will be displayed on InCallUI.
    Log.i(this, "updatePhoneAccount setPhoneAccountHandle, account = " + pHandle);
    connection.notifyPhoneAccountChanged(pHandle);
}
#end_block

#method_before
private void placeOutgoingConnection(TelephonyConnection connection, Phone phone, int videoState, Bundle extras) {
    String number = connection.getAddress().getSchemeSpecificPart();
    com.android.internal.telephony.Connection originalConnection = null;
    try {
        if (phone != null) {
            originalConnection = phone.dial(number, null, videoState, extras);
            if (phone instanceof GsmCdmaPhone) {
                GsmCdmaPhone gsmCdmaPhone = (GsmCdmaPhone) phone;
                if (gsmCdmaPhone.isNotificationOfWfcCallRequired(number)) {
                    // Send connection event to InCall UI to inform the user of the fact they
                    // are potentially placing an international call on WFC.
                    Log.i(this, "placeOutgoingConnection - sending international call on WFC " + "confirmation event");
                    connection.sendConnectionEvent(TelephonyManager.EVENT_NOTIFY_INTERNATIONAL_CALL_ON_WFC, null);
                }
            }
        }
    } catch (CallStateException e) {
        Log.e(this, e, "placeOutgoingConnection, phone.dial exception: " + e);
        int cause = android.telephony.DisconnectCause.OUTGOING_FAILURE;
        if (e.getError() == CallStateException.ERROR_DISCONNECTED) {
            cause = android.telephony.DisconnectCause.OUT_OF_SERVICE;
        } else if (e.getError() == CallStateException.ERROR_POWER_OFF) {
            cause = android.telephony.DisconnectCause.POWER_OFF;
        }
        connection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(cause, e.getMessage()));
        return;
    }
    if (originalConnection == null) {
        int telephonyDisconnectCause = android.telephony.DisconnectCause.OUTGOING_FAILURE;
        // On GSM phones, null connection means that we dialed an MMI code
        if (phone.getPhoneType() == PhoneConstants.PHONE_TYPE_GSM) {
            Log.d(this, "dialed MMI code");
            int subId = phone.getSubId();
            Log.d(this, "subId: " + subId);
            telephonyDisconnectCause = android.telephony.DisconnectCause.DIALED_MMI;
            final Intent intent = new Intent(this, MMIDialogActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            if (SubscriptionManager.isValidSubscriptionId(subId)) {
                intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
            }
            startActivity(intent);
        }
        Log.d(this, "placeOutgoingConnection, phone.dial returned null");
        connection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(telephonyDisconnectCause, "Connection is null"));
    } else {
        connection.setOriginalConnection(originalConnection);
    }
}
#method_after
private void placeOutgoingConnection(TelephonyConnection connection, Phone phone, int videoState, Bundle extras) {
    String number = connection.getAddress().getSchemeSpecificPart();
    com.android.internal.telephony.Connection originalConnection = null;
    try {
        if (phone != null) {
            originalConnection = phone.dial(number, null, videoState, extras);
        }
    } catch (CallStateException e) {
        Log.e(this, e, "placeOutgoingConnection, phone.dial exception: " + e);
        int cause = android.telephony.DisconnectCause.OUTGOING_FAILURE;
        if (e.getError() == CallStateException.ERROR_OUT_OF_SERVICE) {
            cause = android.telephony.DisconnectCause.OUT_OF_SERVICE;
        } else if (e.getError() == CallStateException.ERROR_POWER_OFF) {
            cause = android.telephony.DisconnectCause.POWER_OFF;
        }
        connection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(cause, e.getMessage()));
        return;
    }
    if (originalConnection == null) {
        int telephonyDisconnectCause = android.telephony.DisconnectCause.OUTGOING_FAILURE;
        // On GSM phones, null connection means that we dialed an MMI code
        if (phone.getPhoneType() == PhoneConstants.PHONE_TYPE_GSM) {
            Log.d(this, "dialed MMI code");
            int subId = phone.getSubId();
            Log.d(this, "subId: " + subId);
            telephonyDisconnectCause = android.telephony.DisconnectCause.DIALED_MMI;
            final Intent intent = new Intent(this, MMIDialogActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            if (SubscriptionManager.isValidSubscriptionId(subId)) {
                intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
            }
            startActivity(intent);
        }
        Log.d(this, "placeOutgoingConnection, phone.dial returned null");
        connection.setDisconnected(DisconnectCauseUtil.toTelecomDisconnectCause(telephonyDisconnectCause, "Connection is null"));
    } else {
        connection.setOriginalConnection(originalConnection);
    }
}
#end_block

#method_before
private TelephonyConnection createConnectionFor(Phone phone, com.android.internal.telephony.Connection originalConnection, boolean isOutgoing, PhoneAccountHandle phoneAccountHandle, String telecomCallId, Uri address, int videoState) {
    TelephonyConnection returnConnection = null;
    int phoneType = phone.getPhoneType();
    if (phoneType == TelephonyManager.PHONE_TYPE_GSM) {
        returnConnection = new GsmConnection(originalConnection, telecomCallId);
    } else if (phoneType == TelephonyManager.PHONE_TYPE_CDMA) {
        boolean allowsMute = allowsMute(phone);
        returnConnection = new CdmaConnection(originalConnection, mEmergencyTonePlayer, allowsMute, isOutgoing, telecomCallId);
    }
    if (returnConnection != null) {
        // Listen to Telephony specific callbacks from the connection
        returnConnection.addTelephonyConnectionListener(mTelephonyConnectionListener);
        returnConnection.setVideoPauseSupported(TelecomAccountRegistry.getInstance(this).isVideoPauseSupported(phoneAccountHandle));
    }
    return returnConnection;
}
#method_after
private TelephonyConnection createConnectionFor(Phone phone, com.android.internal.telephony.Connection originalConnection, boolean isOutgoing, PhoneAccountHandle phoneAccountHandle, String telecomCallId, Uri address, int videoState) {
    TelephonyConnection returnConnection = null;
    int phoneType = phone.getPhoneType();
    if (phoneType == TelephonyManager.PHONE_TYPE_GSM) {
        returnConnection = new GsmConnection(originalConnection, telecomCallId, isOutgoing);
    } else if (phoneType == TelephonyManager.PHONE_TYPE_CDMA) {
        boolean allowsMute = allowsMute(phone);
        returnConnection = new CdmaConnection(originalConnection, mEmergencyTonePlayer, allowsMute, isOutgoing, telecomCallId);
    }
    if (returnConnection != null) {
        // Listen to Telephony specific callbacks from the connection
        returnConnection.addTelephonyConnectionListener(mTelephonyConnectionListener);
        returnConnection.setVideoPauseSupported(TelecomAccountRegistry.getInstance(this).isVideoPauseSupported(phoneAccountHandle));
    }
    return returnConnection;
}
#end_block

#method_before
private Phone getPhoneForAccount(PhoneAccountHandle accountHandle, boolean isEmergency) {
    Phone chosenPhone = null;
    int subId = PhoneUtils.getSubIdForPhoneAccountHandle(accountHandle);
    if (subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
        int phoneId = SubscriptionManager.getPhoneId(subId);
        chosenPhone = PhoneFactory.getPhone(phoneId);
    }
    // default as a last chance backup.
    if (isEmergency && (chosenPhone == null || ServiceState.STATE_IN_SERVICE != chosenPhone.getServiceState().getState())) {
        Log.d(this, "getPhoneForAccount: phone for phone acct handle %s is out of service " + "or invalid for emergency call.", accountHandle);
        chosenPhone = getFirstPhoneForEmergencyCall();
        Log.d(this, "getPhoneForAccount: using subId: " + (chosenPhone == null ? "null" : chosenPhone.getSubId()));
    }
    return chosenPhone;
}
#method_after
private Phone getPhoneForAccount(PhoneAccountHandle accountHandle, boolean isEmergency) {
    Phone chosenPhone = null;
    int subId = PhoneUtils.getSubIdForPhoneAccountHandle(accountHandle);
    if (subId != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
        int phoneId = mSubscriptionManagerProxy.getPhoneId(subId);
        chosenPhone = mPhoneFactoryProxy.getPhone(phoneId);
    }
    // default as a last chance backup.
    if (isEmergency && (chosenPhone == null || ServiceState.STATE_IN_SERVICE != chosenPhone.getServiceState().getState())) {
        Log.d(this, "getPhoneForAccount: phone for phone acct handle %s is out of service " + "or invalid for emergency call.", accountHandle);
        chosenPhone = getFirstPhoneForEmergencyCall();
        Log.d(this, "getPhoneForAccount: using subId: " + (chosenPhone == null ? "null" : chosenPhone.getSubId()));
    }
    return chosenPhone;
}
#end_block

#method_before
private Phone getFirstPhoneForEmergencyCall() {
    // 1)
    int phoneId = SubscriptionManager.getDefaultVoicePhoneId();
    if (phoneId != SubscriptionManager.INVALID_PHONE_INDEX) {
        Phone defaultPhone = PhoneFactory.getPhone(phoneId);
        if (defaultPhone != null && isAvailableForEmergencyCalls(defaultPhone)) {
            return defaultPhone;
        }
    }
    Phone firstPhoneWithSim = null;
    int phoneCount = TelephonyManager.getDefault().getPhoneCount();
    List<Pair<Integer, Integer>> phoneNetworkType = new ArrayList<>(phoneCount);
    for (int i = 0; i < phoneCount; i++) {
        Phone phone = PhoneFactory.getPhone(i);
        if (phone == null)
            continue;
        // 2)
        if (isAvailableForEmergencyCalls(phone)) {
            // the slot has the radio on & state is in service.
            Log.i(this, "getFirstPhoneForEmergencyCall, radio on & in service, Phone Id:" + i);
            return phone;
        }
        // 3)
        // Store the RAF Capabilities for sorting later only if there are capabilities to sort.
        int radioAccessFamily = phone.getRadioAccessFamily();
        if (RadioAccessFamily.getHighestRafCapability(radioAccessFamily) != 0) {
            phoneNetworkType.add(new Pair<>(i, radioAccessFamily));
            Log.i(this, "getFirstPhoneForEmergencyCall, RAF:" + Integer.toHexString(radioAccessFamily) + " saved for Phone Id:" + i);
        }
        // 4)
        if (firstPhoneWithSim == null && TelephonyManager.getDefault().hasIccCard(i)) {
            // The slot has a SIM card inserted, but is not in service, so keep track of this
            // Phone. Do not return because we want to make sure that none of the other Phones
            // are in service (because that is always faster).
            Log.i(this, "getFirstPhoneForEmergencyCall, SIM card inserted, Phone Id:" + i);
            firstPhoneWithSim = phone;
        }
    }
    // 5)
    if (firstPhoneWithSim == null && phoneNetworkType.isEmpty()) {
        // No SIMs inserted, get the default.
        Log.i(this, "getFirstPhoneForEmergencyCall, return default phone");
        return PhoneFactory.getDefaultPhone();
    } else {
        // 3)
        final Phone firstOccupiedSlot = firstPhoneWithSim;
        if (!phoneNetworkType.isEmpty()) {
            // Only sort if there are enough elements to do so.
            if (phoneNetworkType.size() > 1) {
                Collections.sort(phoneNetworkType, (o1, o2) -> {
                    // First start by sorting by number of RadioAccessFamily Capabilities.
                    int compare = Integer.bitCount(o1.second) - Integer.bitCount(o2.second);
                    if (compare == 0) {
                        // Sort by highest RAF Capability if the number is the same.
                        compare = RadioAccessFamily.getHighestRafCapability(o1.second) - RadioAccessFamily.getHighestRafCapability(o2.second);
                        if (compare == 0 && firstOccupiedSlot != null) {
                            // always choose the first).
                            if (o1.first == firstOccupiedSlot.getPhoneId()) {
                                return 1;
                            } else if (o2.first == firstOccupiedSlot.getPhoneId()) {
                                return -1;
                            }
                        // Compare is still 0, return equal.
                        }
                    }
                    return compare;
                });
            }
            int mostCapablePhoneId = phoneNetworkType.get(phoneNetworkType.size() - 1).first;
            Log.i(this, "getFirstPhoneForEmergencyCall, Using Phone Id: " + mostCapablePhoneId + "with highest capability");
            return PhoneFactory.getPhone(mostCapablePhoneId);
        } else {
            // 4)
            return firstPhoneWithSim;
        }
    }
}
#method_after
@VisibleForTesting
public Phone getFirstPhoneForEmergencyCall() {
    // 1)
    int phoneId = mSubscriptionManagerProxy.getDefaultVoicePhoneId();
    if (phoneId != SubscriptionManager.INVALID_PHONE_INDEX) {
        Phone defaultPhone = mPhoneFactoryProxy.getPhone(phoneId);
        if (defaultPhone != null && isAvailableForEmergencyCalls(defaultPhone)) {
            return defaultPhone;
        }
    }
    Phone firstPhoneWithSim = null;
    int phoneCount = mTelephonyManagerProxy.getPhoneCount();
    List<SlotStatus> phoneSlotStatus = new ArrayList<>(phoneCount);
    for (int i = 0; i < phoneCount; i++) {
        Phone phone = mPhoneFactoryProxy.getPhone(i);
        if (phone == null) {
            continue;
        }
        // 2)
        if (isAvailableForEmergencyCalls(phone)) {
            // the slot has the radio on & state is in service.
            Log.i(this, "getFirstPhoneForEmergencyCall, radio on & in service, Phone Id:" + i);
            return phone;
        }
        // 4)
        // Store the RAF Capabilities for sorting later.
        int radioAccessFamily = phone.getRadioAccessFamily();
        SlotStatus status = new SlotStatus(i, radioAccessFamily);
        phoneSlotStatus.add(status);
        Log.i(this, "getFirstPhoneForEmergencyCall, RAF:" + Integer.toHexString(radioAccessFamily) + " saved for Phone Id:" + i);
        // 3)
        // Report Slot's PIN/PUK lock status for sorting later.
        int simState = mSubscriptionManagerProxy.getSimStateForSlotIdx(i);
        if (simState == TelephonyManager.SIM_STATE_PIN_REQUIRED || simState == TelephonyManager.SIM_STATE_PUK_REQUIRED) {
            status.isLocked = true;
        }
        // 5)
        if (firstPhoneWithSim == null && mTelephonyManagerProxy.hasIccCard(i)) {
            // The slot has a SIM card inserted, but is not in service, so keep track of this
            // Phone. Do not return because we want to make sure that none of the other Phones
            // are in service (because that is always faster).
            firstPhoneWithSim = phone;
            Log.i(this, "getFirstPhoneForEmergencyCall, SIM card inserted, Phone Id:" + firstPhoneWithSim.getPhoneId());
        }
    }
    // 6)
    if (firstPhoneWithSim == null && phoneSlotStatus.isEmpty()) {
        // No Phones available, get the default.
        Log.i(this, "getFirstPhoneForEmergencyCall, return default phone");
        return mPhoneFactoryProxy.getDefaultPhone();
    } else {
        // 4)
        final int defaultPhoneId = mPhoneFactoryProxy.getDefaultPhone().getPhoneId();
        final Phone firstOccupiedSlot = firstPhoneWithSim;
        if (!phoneSlotStatus.isEmpty()) {
            // Only sort if there are enough elements to do so.
            if (phoneSlotStatus.size() > 1) {
                Collections.sort(phoneSlotStatus, (o1, o2) -> {
                    // by capability instead.
                    if (o1.isLocked && !o2.isLocked) {
                        return -1;
                    }
                    if (o2.isLocked && !o1.isLocked) {
                        return 1;
                    }
                    // sort by number of RadioAccessFamily Capabilities.
                    int compare = Integer.bitCount(o1.capabilities) - Integer.bitCount(o2.capabilities);
                    if (compare == 0) {
                        // Sort by highest RAF Capability if the number is the same.
                        compare = RadioAccessFamily.getHighestRafCapability(o1.capabilities) - RadioAccessFamily.getHighestRafCapability(o2.capabilities);
                        if (compare == 0) {
                            if (firstOccupiedSlot != null) {
                                // are, always choose the first).
                                if (o1.slotId == firstOccupiedSlot.getPhoneId()) {
                                    return 1;
                                } else if (o2.slotId == firstOccupiedSlot.getPhoneId()) {
                                    return -1;
                                }
                            } else {
                                // Phone Id greater than the others.
                                if (o1.slotId == defaultPhoneId) {
                                    return 1;
                                } else if (o2.slotId == defaultPhoneId) {
                                    return -1;
                                }
                            }
                        }
                    }
                    return compare;
                });
            }
            int mostCapablePhoneId = phoneSlotStatus.get(phoneSlotStatus.size() - 1).slotId;
            Log.i(this, "getFirstPhoneForEmergencyCall, Using Phone Id: " + mostCapablePhoneId + "with highest capability");
            return mPhoneFactoryProxy.getPhone(mostCapablePhoneId);
        } else {
            // 5)
            return firstPhoneWithSim;
        }
    }
}
#end_block

#method_before
public Builder setConnectable(boolean connectable) {
    this.mConnectable = connectable;
    return this;
}
#method_after
public Builder setConnectable(boolean connectable) {
    mConnectable = connectable;
    return this;
}
#end_block

#method_before
public Builder setScannable(boolean scannable) {
    this.mScannable = scannable;
    return this;
}
#method_after
public Builder setScannable(boolean scannable) {
    mScannable = scannable;
    return this;
}
#end_block

#method_before
public Builder setLegacyMode(boolean isLegacy) {
    this.mIsLegacy = isLegacy;
    return this;
}
#method_after
public Builder setLegacyMode(boolean isLegacy) {
    mIsLegacy = isLegacy;
    return this;
}
#end_block

#method_before
public Builder setAnonymous(boolean isAnonymous) {
    this.mIsAnonymous = isAnonymous;
    return this;
}
#method_after
public Builder setAnonymous(boolean isAnonymous) {
    mIsAnonymous = isAnonymous;
    return this;
}
#end_block

#method_before
public Builder setIncludeTxPower(boolean includeTxPower) {
    this.mIncludeTxPower = includeTxPower;
    return this;
}
#method_after
public Builder setIncludeTxPower(boolean includeTxPower) {
    mIncludeTxPower = includeTxPower;
    return this;
}
#end_block

#method_before
public Builder setPrimaryPhy(int primaryPhy) {
    if (primaryPhy != BluetoothDevice.PHY_LE_1M && primaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException("bad primaryPhy " + primaryPhy);
    }
    this.mPrimaryPhy = primaryPhy;
    return this;
}
#method_after
public Builder setPrimaryPhy(int primaryPhy) {
    if (primaryPhy != BluetoothDevice.PHY_LE_1M && primaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException("bad primaryPhy " + primaryPhy);
    }
    mPrimaryPhy = primaryPhy;
    return this;
}
#end_block

#method_before
public Builder setSecondaryPhy(int secondaryPhy) {
    if (secondaryPhy != BluetoothDevice.PHY_LE_1M && secondaryPhy != BluetoothDevice.PHY_LE_2M && secondaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException("bad secondaryPhy " + secondaryPhy);
    }
    this.mSecondaryPhy = secondaryPhy;
    return this;
}
#method_after
public Builder setSecondaryPhy(int secondaryPhy) {
    if (secondaryPhy != BluetoothDevice.PHY_LE_1M && secondaryPhy != BluetoothDevice.PHY_LE_2M && secondaryPhy != BluetoothDevice.PHY_LE_CODED) {
        throw new IllegalArgumentException("bad secondaryPhy " + secondaryPhy);
    }
    mSecondaryPhy = secondaryPhy;
    return this;
}
#end_block

#method_before
public Builder setInterval(int interval) {
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException("unknown interval " + interval);
    }
    this.mInterval = interval;
    return this;
}
#method_after
public Builder setInterval(int interval) {
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException("unknown interval " + interval);
    }
    mInterval = interval;
    return this;
}
#end_block

#method_before
public Builder setTxPowerLevel(int txPowerLevel) {
    if (txPowerLevel < TX_POWER_MIN || txPowerLevel > TX_POWER_MAX) {
        throw new IllegalArgumentException("unknown txPowerLevel " + txPowerLevel);
    }
    this.mTxPowerLevel = txPowerLevel;
    return this;
}
#method_after
public Builder setTxPowerLevel(int txPowerLevel) {
    if (txPowerLevel < TX_POWER_MIN || txPowerLevel > TX_POWER_MAX) {
        throw new IllegalArgumentException("unknown txPowerLevel " + txPowerLevel);
    }
    mTxPowerLevel = txPowerLevel;
    return this;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(this.mRfcommChannelNumber);
    dest.writeInt(this.mProfileVersion);
    dest.writeString(this.mServiceName);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mRfcommChannelNumber);
    dest.writeInt(mProfileVersion);
    dest.writeString(mServiceName);
}
#end_block

#method_before
/**
 * Register an application callback to start using GattServer.
 *
 * <p>This is an asynchronous call. The callback is used to notify
 * success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param callback GATT callback handler that will receive asynchronous
 *                 callbacks.
 * @return true, the callback will be called to notify success or failure,
 * false on immediate error
 */
boolean registerCallback(BluetoothGattServerCallback callback) {
    if (DBG)
        Log.d(TAG, "registerCallback()");
    if (mService == null) {
        Log.e(TAG, "GATT service not available");
        return false;
    }
    UUID uuid = UUID.randomUUID();
    if (DBG)
        Log.d(TAG, "registerCallback() - UUID=" + uuid);
    synchronized (mServerIfLock) {
        if (mCallback != null) {
            Log.e(TAG, "App can register callback only once");
            return false;
        }
        mCallback = callback;
        try {
            mService.registerServer(new ParcelUuid(uuid), mBluetoothGattServerCallback);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
            mCallback = null;
            return false;
        }
        try {
            mServerIfLock.wait(CALLBACK_REG_TIMEOUT);
        } catch (InterruptedException e) {
            Log.e(TAG, "" + e);
            mCallback = null;
        }
        if (mServerIf == 0) {
            mCallback = null;
            return false;
        } else {
            return true;
        }
    }
}
#method_after
/**
 * Register an application callback to start using GattServer.
 *
 * <p>This is an asynchronous call. The callback is used to notify
 * success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @return true, the callback will be called to notify success or failure, false on immediate
 * error
 */
boolean registerCallback(BluetoothGattServerCallback callback) {
    if (DBG)
        Log.d(TAG, "registerCallback()");
    if (mService == null) {
        Log.e(TAG, "GATT service not available");
        return false;
    }
    UUID uuid = UUID.randomUUID();
    if (DBG)
        Log.d(TAG, "registerCallback() - UUID=" + uuid);
    synchronized (mServerIfLock) {
        if (mCallback != null) {
            Log.e(TAG, "App can register callback only once");
            return false;
        }
        mCallback = callback;
        try {
            mService.registerServer(new ParcelUuid(uuid), mBluetoothGattServerCallback);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
            mCallback = null;
            return false;
        }
        try {
            mServerIfLock.wait(CALLBACK_REG_TIMEOUT);
        } catch (InterruptedException e) {
            Log.e(TAG, "" + e);
            mCallback = null;
        }
        if (mServerIf == 0) {
            mCallback = null;
            return false;
        } else {
            return true;
        }
    }
}
#end_block

#method_before
public boolean connect(BluetoothDevice device, boolean autoConnect) {
    if (DBG) {
        Log.d(TAG, "connect() - device: " + device.getAddress() + ", auto: " + autoConnect);
    }
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), autoConnect ? false : true, // autoConnect is inverse of "isDirect"
        mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
#method_after
public boolean connect(BluetoothDevice device, boolean autoConnect) {
    if (DBG) {
        Log.d(TAG, "connect() - device: " + device.getAddress() + ", auto: " + autoConnect);
    }
    if (mService == null || mServerIf == 0)
        return false;
    try {
        // autoConnect is inverse of "isDirect"
        mService.serverConnect(mServerIf, device.getAddress(), !autoConnect, mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
#end_block

#method_before
void setAdvertiserId(int advertiserId) {
    this.mAdvertiserId = advertiserId;
}
#method_after
void setAdvertiserId(int advertiserId) {
    mAdvertiserId = advertiserId;
}
#end_block

#method_before
public void enableAdvertising(boolean enable, int duration, int maxExtendedAdvertisingEvents) {
    try {
        mGatt.enableAdvertisingSet(this.mAdvertiserId, enable, duration, maxExtendedAdvertisingEvents);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void enableAdvertising(boolean enable, int duration, int maxExtendedAdvertisingEvents) {
    try {
        mGatt.enableAdvertisingSet(mAdvertiserId, enable, duration, maxExtendedAdvertisingEvents);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
public void setAdvertisingData(AdvertiseData advertiseData) {
    try {
        mGatt.setAdvertisingData(this.mAdvertiserId, advertiseData);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void setAdvertisingData(AdvertiseData advertiseData) {
    try {
        mGatt.setAdvertisingData(mAdvertiserId, advertiseData);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
public void setScanResponseData(AdvertiseData scanResponse) {
    try {
        mGatt.setScanResponseData(this.mAdvertiserId, scanResponse);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void setScanResponseData(AdvertiseData scanResponse) {
    try {
        mGatt.setScanResponseData(mAdvertiserId, scanResponse);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
public void setAdvertisingParameters(AdvertisingSetParameters parameters) {
    try {
        mGatt.setAdvertisingParameters(this.mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void setAdvertisingParameters(AdvertisingSetParameters parameters) {
    try {
        mGatt.setAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
public void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters parameters) {
    try {
        mGatt.setPeriodicAdvertisingParameters(this.mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void setPeriodicAdvertisingParameters(PeriodicAdvertisingParameters parameters) {
    try {
        mGatt.setPeriodicAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
public void setPeriodicAdvertisingData(AdvertiseData periodicData) {
    try {
        mGatt.setPeriodicAdvertisingData(this.mAdvertiserId, periodicData);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void setPeriodicAdvertisingData(AdvertiseData periodicData) {
    try {
        mGatt.setPeriodicAdvertisingData(mAdvertiserId, periodicData);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
public void setPeriodicAdvertisingEnabled(boolean enable) {
    try {
        mGatt.setPeriodicAdvertisingEnable(this.mAdvertiserId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void setPeriodicAdvertisingEnabled(boolean enable) {
    try {
        mGatt.setPeriodicAdvertisingEnable(mAdvertiserId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
public void getOwnAddress() {
    try {
        mGatt.getOwnAddress(this.mAdvertiserId);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#method_after
public void getOwnAddress() {
    try {
        mGatt.getOwnAddress(mAdvertiserId);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
#end_block

#method_before
/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect parameter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device      Remote device to connect to
 * @param autoConnect Whether to directly connect to the remote device (false)
 *                    or to automatically connect as soon as the remote
 *                    device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
boolean connect(Boolean autoConnect, BluetoothGattCallback callback, Handler handler) {
    if (DBG) {
        Log.d(TAG, "connect() - device: " + mDevice.getAddress() + ", auto: " + autoConnect);
    }
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException("Not idle");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    mAutoConnect = autoConnect;
    if (!registerApp(callback, handler)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, "Failed to register callback");
        return false;
    }
    // The connection will continue in the onClientRegistered callback
    return true;
}
#method_after
/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect parameter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Remote device to connect to
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
boolean connect(Boolean autoConnect, BluetoothGattCallback callback, Handler handler) {
    if (DBG) {
        Log.d(TAG, "connect() - device: " + mDevice.getAddress() + ", auto: " + autoConnect);
    }
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException("Not idle");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    mAutoConnect = autoConnect;
    if (!registerApp(callback, handler)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, "Failed to register callback");
        return false;
    }
    // The connection will continue in the onClientRegistered callback
    return true;
}
#end_block

#method_before
public void setLeBluetoothDeviceAddress(byte[] leBluetoothDeviceAddress) {
    this.mLeBluetoothDeviceAddress = leBluetoothDeviceAddress;
}
#method_after
public void setLeBluetoothDeviceAddress(byte[] leBluetoothDeviceAddress) {
    mLeBluetoothDeviceAddress = leBluetoothDeviceAddress;
}
#end_block

#method_before
public void setSecurityManagerTk(byte[] securityManagerTk) {
    this.mSecurityManagerTk = securityManagerTk;
}
#method_after
public void setSecurityManagerTk(byte[] securityManagerTk) {
    mSecurityManagerTk = securityManagerTk;
}
#end_block

#method_before
public void setLeSecureConnectionsConfirmation(byte[] leSecureConnectionsConfirmation) {
    this.mLeSecureConnectionsConfirmation = leSecureConnectionsConfirmation;
}
#method_after
public void setLeSecureConnectionsConfirmation(byte[] leSecureConnectionsConfirmation) {
    mLeSecureConnectionsConfirmation = leSecureConnectionsConfirmation;
}
#end_block

#method_before
public void setLeSecureConnectionsRandom(byte[] leSecureConnectionsRandom) {
    this.mLeSecureConnectionsRandom = leSecureConnectionsRandom;
}
#method_after
public void setLeSecureConnectionsRandom(byte[] leSecureConnectionsRandom) {
    mLeSecureConnectionsRandom = leSecureConnectionsRandom;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(this.mRawSize);
    dest.writeByteArray(this.mRawData);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mRawSize);
    dest.writeByteArray(mRawData);
}
#end_block

#method_before
public void setExcludeSdp(boolean excludeSdp) {
    this.mExcludeSdp = excludeSdp;
}
#method_after
public void setExcludeSdp(boolean excludeSdp) {
    mExcludeSdp = excludeSdp;
}
#end_block

#method_before
/**
 * Returns the device associated with this service.
 *
 * @hide
 */
void setDevice(BluetoothDevice device) {
    this.mDevice = device;
}
#method_after
/**
 * Returns the device associated with this service.
 *
 * @hide
 */
void setDevice(BluetoothDevice device) {
    mDevice = device;
}
#end_block

#method_before
public void setAdvertisePreferred(boolean advertisePreferred) {
    this.mAdvertisePreferred = advertisePreferred;
}
#method_after
public void setAdvertisePreferred(boolean advertisePreferred) {
    mAdvertisePreferred = advertisePreferred;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(this.mMasInstanceId);
    dest.writeInt(this.mL2capPsm);
    dest.writeInt(this.mRfcommChannelNumber);
    dest.writeInt(this.mProfileVersion);
    dest.writeInt(this.mSupportedFeatures);
    dest.writeInt(this.mSupportedMessageTypes);
    dest.writeString(this.mServiceName);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mMasInstanceId);
    dest.writeInt(mL2capPsm);
    dest.writeInt(mRfcommChannelNumber);
    dest.writeInt(mProfileVersion);
    dest.writeInt(mSupportedFeatures);
    dest.writeInt(mSupportedMessageTypes);
    dest.writeString(mServiceName);
}
#end_block

#method_before
public Builder setIncludeTxPower(boolean includeTxPower) {
    this.mIncludeTxPower = includeTxPower;
    return this;
}
#method_after
public Builder setIncludeTxPower(boolean includeTxPower) {
    mIncludeTxPower = includeTxPower;
    return this;
}
#end_block

#method_before
public Builder setInterval(int interval) {
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException("Invalid interval (must be " + INTERVAL_MIN + "-" + INTERVAL_MAX + ")");
    }
    this.mInterval = interval;
    return this;
}
#method_after
public Builder setInterval(int interval) {
    if (interval < INTERVAL_MIN || interval > INTERVAL_MAX) {
        throw new IllegalArgumentException("Invalid interval (must be " + INTERVAL_MIN + "-" + INTERVAL_MAX + ")");
    }
    mInterval = interval;
    return this;
}
#end_block

#method_before
/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect parameter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device      Remote device to connect to
 * @param autoConnect Whether to directly connect to the remote device (false)
 *                    or to automatically connect as soon as the remote
 *                    device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
boolean connect(Boolean autoConnect, BluetoothGattCallback callback, Handler handler) {
    if (DBG) {
        Log.d(TAG, "connect() - device: " + mDevice.getAddress() + ", auto: " + autoConnect);
    }
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException("Not idle");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    mAutoConnect = autoConnect;
    if (!registerApp(callback, handler)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, "Failed to register callback");
        return false;
    }
    // The connection will continue in the onClientRegistered callback
    return true;
}
#method_after
/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect parameter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Remote device to connect to
 * @param autoConnect Whether to directly connect to the remote device (false) or to
 * automatically connect as soon as the remote device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */
boolean connect(Boolean autoConnect, BluetoothGattCallback callback, Handler handler) {
    if (DBG) {
        Log.d(TAG, "connect() - device: " + mDevice.getAddress() + ", auto: " + autoConnect);
    }
    synchronized (mStateLock) {
        if (mConnState != CONN_STATE_IDLE) {
            throw new IllegalStateException("Not idle");
        }
        mConnState = CONN_STATE_CONNECTING;
    }
    mAutoConnect = autoConnect;
    if (!registerApp(callback, handler)) {
        synchronized (mStateLock) {
            mConnState = CONN_STATE_IDLE;
        }
        Log.e(TAG, "Failed to register callback");
        return false;
    }
    // The connection will continue in the onClientRegistered callback
    return true;
}
#end_block

#method_before
/**
 * Register an application callback to start using GattServer.
 *
 * <p>This is an asynchronous call. The callback is used to notify
 * success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param callback GATT callback handler that will receive asynchronous
 *                 callbacks.
 * @return true, the callback will be called to notify success or failure,
 * false on immediate error
 */
boolean registerCallback(BluetoothGattServerCallback callback) {
    if (DBG)
        Log.d(TAG, "registerCallback()");
    if (mService == null) {
        Log.e(TAG, "GATT service not available");
        return false;
    }
    UUID uuid = UUID.randomUUID();
    if (DBG)
        Log.d(TAG, "registerCallback() - UUID=" + uuid);
    synchronized (mServerIfLock) {
        if (mCallback != null) {
            Log.e(TAG, "App can register callback only once");
            return false;
        }
        mCallback = callback;
        try {
            mService.registerServer(new ParcelUuid(uuid), mBluetoothGattServerCallback);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
            mCallback = null;
            return false;
        }
        try {
            mServerIfLock.wait(CALLBACK_REG_TIMEOUT);
        } catch (InterruptedException e) {
            Log.e(TAG, "" + e);
            mCallback = null;
        }
        if (mServerIf == 0) {
            mCallback = null;
            return false;
        } else {
            return true;
        }
    }
}
#method_after
/**
 * Register an application callback to start using GattServer.
 *
 * <p>This is an asynchronous call. The callback is used to notify
 * success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @return true, the callback will be called to notify success or failure, false on immediate
 * error
 */
boolean registerCallback(BluetoothGattServerCallback callback) {
    if (DBG)
        Log.d(TAG, "registerCallback()");
    if (mService == null) {
        Log.e(TAG, "GATT service not available");
        return false;
    }
    UUID uuid = UUID.randomUUID();
    if (DBG)
        Log.d(TAG, "registerCallback() - UUID=" + uuid);
    synchronized (mServerIfLock) {
        if (mCallback != null) {
            Log.e(TAG, "App can register callback only once");
            return false;
        }
        mCallback = callback;
        try {
            mService.registerServer(new ParcelUuid(uuid), mBluetoothGattServerCallback);
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
            mCallback = null;
            return false;
        }
        try {
            mServerIfLock.wait(CALLBACK_REG_TIMEOUT);
        } catch (InterruptedException e) {
            Log.e(TAG, "" + e);
            mCallback = null;
        }
        if (mServerIf == 0) {
            mCallback = null;
            return false;
        } else {
            return true;
        }
    }
}
#end_block

#method_before
static void checkAdapterStateOn(BluetoothAdapter adapter) {
    if (adapter == null || !adapter.isLeEnabled()) {
        throw new IllegalStateException("BT Adapter is not turned ON");
    }
}
#method_after
static void checkAdapterStateOn(BluetoothAdapter adapter) {
    if (adapter == null || !adapter.isLeEnabled()) {
        // adapter.getState() != BluetoothAdapter.STATE_ON) {
        throw new IllegalStateException("BT Adapter is not turned ON");
    }
}
#end_block

#method_before
@Override
boolean build() {
    if (super.build()) {
        if (sourceFiles.isEmpty()) {
            return true;
        }
        File destFile = new File(destPath);
        if (!destFile.exists() && !destFile.mkdirs()) {
            System.err.println("failed to create destination dir");
            return false;
        }
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);
        try {
            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(new File[] { new File(destPath) }));
            fileManager.setLocation(StandardLocation.CLASS_PATH, Arrays.asList(classPath.split(":")).stream().map(n -> {
                return new File(n);
            }).collect(Collectors.toList()));
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        Iterable<? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromStrings(sourceFiles);
        List<String> options = Arrays.asList(new String[] { "-source", "1.7", "-target", "1.7" });
        Boolean result = compiler.getTask(null, fileManager, null, null, null, compilationUnits).call();
        try {
            fileManager.close();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return Boolean.TRUE.equals(result);
    }
    return false;
}
#method_after
@Override
boolean build() {
    if (super.build()) {
        if (sourceFiles.isEmpty()) {
            return true;
        }
        File destFile = new File(destPath);
        if (!destFile.exists() && !destFile.mkdirs()) {
            System.err.println("failed to create destination dir");
            return false;
        }
        Iterable<File> classPathFiles = Arrays.asList(classPath.split(":")).stream().map(File::new).collect(Collectors.toList());
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        try (StandardJavaFileManager fileManager = compiler.getStandardFileManager(// diagnosticListener: we don't care about the details.
        null, // locale: use default locale.
        null, null)) {
            // charset: use platform default.
            fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(new File(destPath)));
            fileManager.setLocation(StandardLocation.CLASS_PATH, classPathFiles);
            Iterable<? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromStrings(sourceFiles);
            List<String> options = Arrays.asList("-source", "1.7", "-target", "1.7");
            return compiler.getTask(// out: write errors to System.err.
            null, fileManager, // diagnosticListener: we don't care about the details.
            null, options, // classes: classes for annotation processing = none.
            null, compilationUnits).call();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }
    return false;
}
#end_block

#method_before
public void $noinline$busyLoop() {
    assertIsManaged();
    for (; ; ) {
        if (sExitFlag) {
            break;
        }
    }
    assertIsInterpreted();
}
#method_after
public void $noinline$busyLoop() {
    assertIsManaged();
    sEntered = true;
    for (; ; ) {
        if (sExitFlag) {
            break;
        }
    }
    assertIsInterpreted();
}
#end_block

#method_before
public void run() {
    if (threadIndex == 0) {
        try {
            Thread.sleep(5000);
        } catch (Exception e) {
        }
        deoptimizeAll();
        sExitFlag = true;
    } else {
        ensureJitCompiled(Main.class, "$noinline$busyLoop");
        $noinline$busyLoop();
    }
}
#method_after
public void run() {
    if (threadIndex == 0) {
        while (!sEntered) {
            Thread.yield();
        }
        deoptimizeAll();
        sExitFlag = true;
    } else {
        ensureJitCompiled(Main.class, "$noinline$busyLoop");
        $noinline$busyLoop();
    }
}
#end_block

#method_before
public void checkAndStartWifi() {
    // First check if we will end up restarting WifiService
    if (mFrameworkFacade.inStorageManagerCryptKeeperBounce()) {
        Log.d(TAG, "Device still encrypted. Need to restart SystemServer.  Do not start wifi.");
        return;
    }
    // Check if wi-fi needs to be enabled
    boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
    Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled"));
    registerForScanModeChange();
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (mSettingsStore.handleAirplaneModeToggled()) {
                mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
            }
            if (mSettingsStore.isAirplaneModeOn()) {
                Log.d(TAG, "resetting country code because Airplane mode is ON");
                mCountryCode.airplaneModeEnabled();
            }
        }
    }, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
            if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was removed");
                mWifiStateMachine.resetSimAuthNetworks(false);
                Log.d(TAG, "resetting country code because SIM is removed");
                mCountryCode.simCardRemoved();
            } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was loaded");
                mWifiStateMachine.resetSimAuthNetworks(true);
            }
        }
    }, new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
    // Adding optimizations of only receiving broadcasts when wifi is enabled
    // can result in race conditions when apps toggle wifi in the background
    // without active user involvement. Always receive broadcasts.
    registerForBroadcasts();
    registerForPackageOrUserRemoval();
    mInIdleMode = mPowerManager.isDeviceIdleMode();
    if (!mWifiStateMachine.syncInitialize(mWifiStateMachineChannel)) {
        Log.wtf(TAG, "Failed to initialize WifiStateMachine");
    }
    mWifiController.start();
    // state here
    if (wifiEnabled) {
        try {
            setWifiEnabled(mContext.getPackageName(), wifiEnabled);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
    }
}
#method_after
public void checkAndStartWifi() {
    // First check if we will end up restarting WifiService
    if (mFrameworkFacade.inStorageManagerCryptKeeperBounce()) {
        Log.d(TAG, "Device still encrypted. Need to restart SystemServer.  Do not start wifi.");
        return;
    }
    // Check if wi-fi needs to be enabled
    boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
    Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled"));
    registerForScanModeChange();
    registerForBackgroundThrottleChanges();
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (mSettingsStore.handleAirplaneModeToggled()) {
                mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
            }
            if (mSettingsStore.isAirplaneModeOn()) {
                Log.d(TAG, "resetting country code because Airplane mode is ON");
                mCountryCode.airplaneModeEnabled();
            }
        }
    }, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
            if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was removed");
                mWifiStateMachine.resetSimAuthNetworks(false);
                Log.d(TAG, "resetting country code because SIM is removed");
                mCountryCode.simCardRemoved();
            } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was loaded");
                mWifiStateMachine.resetSimAuthNetworks(true);
            }
        }
    }, new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
    // Adding optimizations of only receiving broadcasts when wifi is enabled
    // can result in race conditions when apps toggle wifi in the background
    // without active user involvement. Always receive broadcasts.
    registerForBroadcasts();
    registerForPackageOrUserRemoval();
    mInIdleMode = mPowerManager.isDeviceIdleMode();
    if (!mWifiStateMachine.syncInitialize(mWifiStateMachineChannel)) {
        Log.wtf(TAG, "Failed to initialize WifiStateMachine");
    }
    mWifiController.start();
    // state here
    if (wifiEnabled) {
        try {
            setWifiEnabled(mContext.getPackageName(), wifiEnabled);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
    }
}
#end_block

#method_before
@Override
public void startScan(ScanSettings settings, WorkSource workSource) {
    enforceChangePermission();
    mLog.trace("startScan uid=%").c(Binder.getCallingUid()).flush();
    synchronized (this) {
        if (mWifiScanner == null) {
            mWifiScanner = mWifiInjector.getWifiScanner();
        }
        if (mInIdleMode) {
            // Need to send an immediate scan result broadcast in case the
            // caller is waiting for a result ..
            // clear calling identity to send broadcast
            long callingIdentity = Binder.clearCallingIdentity();
            try {
                // TODO: investigate if the logic to cancel scans when idle can move to
                // WifiScanningServiceImpl.  This will 1 - clean up WifiServiceImpl and 2 -
                // avoid plumbing an awkward path to report a cancelled/failed scan.  This will
                // be sent directly until b/31398592 is fixed.
                Intent intent = new Intent(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                intent.putExtra(WifiManager.EXTRA_RESULTS_UPDATED, false);
                mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
            } finally {
                // restore calling identity
                Binder.restoreCallingIdentity(callingIdentity);
            }
            mScanPending = true;
            return;
        }
    }
    if (settings != null) {
        settings = new ScanSettings(settings);
        if (!settings.isValid()) {
            Slog.e(TAG, "invalid scan setting");
            return;
        }
    }
    if (workSource != null) {
        enforceWorkSourcePermission();
        // WifiManager currently doesn't use names, so need to clear names out of the
        // supplied WorkSource to allow future WorkSource combining.
        workSource.clearNames();
    }
    if (workSource == null && Binder.getCallingUid() >= 0) {
        workSource = new WorkSource(Binder.getCallingUid());
    }
    mWifiStateMachine.startScan(Binder.getCallingUid(), scanRequestCounter++, settings, workSource);
}
#method_after
@Override
public void startScan(ScanSettings settings, WorkSource workSource, String packageName) {
    enforceChangePermission();
    mLog.trace("startScan uid=%").c(Binder.getCallingUid()).flush();
    // Check and throttle background apps for wifi scan.
    if (isRequestFromBackground(packageName)) {
        long lastScanMs = mLastScanTimestamps.getOrDefault(packageName, 0L);
        long elapsedRealtime = mClock.getElapsedSinceBootMillis();
        if (lastScanMs != 0 && (elapsedRealtime - lastScanMs) < mBackgroundThrottleInterval) {
            sendFailedScanBroadcast();
            return;
        }
        // Proceed with the scan request and record the time.
        mLastScanTimestamps.put(packageName, elapsedRealtime);
    }
    synchronized (this) {
        if (mWifiScanner == null) {
            mWifiScanner = mWifiInjector.getWifiScanner();
        }
        if (mInIdleMode) {
            // Need to send an immediate scan result broadcast in case the
            // caller is waiting for a result ..
            // TODO: investigate if the logic to cancel scans when idle can move to
            // WifiScanningServiceImpl.  This will 1 - clean up WifiServiceImpl and 2 -
            // avoid plumbing an awkward path to report a cancelled/failed scan.  This will
            // be sent directly until b/31398592 is fixed.
            sendFailedScanBroadcast();
            mScanPending = true;
            return;
        }
    }
    if (settings != null) {
        settings = new ScanSettings(settings);
        if (!settings.isValid()) {
            Slog.e(TAG, "invalid scan setting");
            return;
        }
    }
    if (workSource != null) {
        enforceWorkSourcePermission();
        // WifiManager currently doesn't use names, so need to clear names out of the
        // supplied WorkSource to allow future WorkSource combining.
        workSource.clearNames();
    }
    if (workSource == null && Binder.getCallingUid() >= 0) {
        workSource = new WorkSource(Binder.getCallingUid());
    }
    mWifiStateMachine.startScan(Binder.getCallingUid(), scanRequestCounter++, settings, workSource);
}
#end_block

#method_before
void handleIdleModeChanged() {
    boolean doScan = false;
    synchronized (this) {
        boolean idle = mPowerManager.isDeviceIdleMode();
        if (mInIdleMode != idle) {
            mInIdleMode = idle;
            if (!idle) {
                if (mScanPending) {
                    mScanPending = false;
                    doScan = true;
                }
            }
        }
    }
    if (doScan) {
        // Someone requested a scan while we were idle; do a full scan now.
        startScan(null, null);
    }
}
#method_after
void handleIdleModeChanged() {
    boolean doScan = false;
    synchronized (this) {
        boolean idle = mPowerManager.isDeviceIdleMode();
        if (mInIdleMode != idle) {
            mInIdleMode = idle;
            if (!idle) {
                if (mScanPending) {
                    mScanPending = false;
                    doScan = true;
                }
            }
        }
    }
    if (doScan) {
        // Someone requested a scan while we were idle; do a full scan now.
        // The package name doesn't matter as the request comes from System UID.
        startScan(null, null, "");
    }
}
#end_block

#method_before
@Override
public WifiActivityEnergyInfo reportActivityInfo() {
    enforceAccessPermission();
    mLog.trace("reportActivityInfo uid=%").c(Binder.getCallingUid()).flush();
    if ((getSupportedFeatures() & WifiManager.WIFI_FEATURE_LINK_LAYER_STATS) == 0) {
        return null;
    }
    WifiLinkLayerStats stats;
    WifiActivityEnergyInfo energyInfo = null;
    if (mWifiStateMachineChannel != null) {
        stats = mWifiStateMachine.syncGetLinkLayerStats(mWifiStateMachineChannel);
        if (stats != null) {
            final long rxIdleCurrent = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_idle_receive_cur_ma);
            final long rxCurrent = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_active_rx_cur_ma);
            final long txCurrent = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_tx_cur_ma);
            final double voltage = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_operating_voltage_mv) / 1000.0;
            final long rxIdleTime = stats.on_time - stats.tx_time - stats.rx_time;
            final long[] txTimePerLevel;
            if (stats.tx_time_per_level != null) {
                txTimePerLevel = new long[stats.tx_time_per_level.length];
                for (int i = 0; i < txTimePerLevel.length; i++) {
                    txTimePerLevel[i] = stats.tx_time_per_level[i];
                // TODO(b/27227497): Need to read the power consumed per level from config
                }
            } else {
                // This will happen if the HAL get link layer API returned null.
                txTimePerLevel = new long[0];
            }
            final long energyUsed = (long) ((stats.tx_time * txCurrent + stats.rx_time * rxCurrent + rxIdleTime * rxIdleCurrent) * voltage);
            if (VDBG || rxIdleTime < 0 || stats.on_time < 0 || stats.tx_time < 0 || stats.rx_time < 0 || energyUsed < 0) {
                StringBuilder sb = new StringBuilder();
                sb.append(" rxIdleCur=" + rxIdleCurrent);
                sb.append(" rxCur=" + rxCurrent);
                sb.append(" txCur=" + txCurrent);
                sb.append(" voltage=" + voltage);
                sb.append(" on_time=" + stats.on_time);
                sb.append(" tx_time=" + stats.tx_time);
                sb.append(" tx_time_per_level=" + Arrays.toString(txTimePerLevel));
                sb.append(" rx_time=" + stats.rx_time);
                sb.append(" rxIdleTime=" + rxIdleTime);
                sb.append(" energy=" + energyUsed);
                Log.d(TAG, " reportActivityInfo: " + sb.toString());
            }
            // Convert the LinkLayerStats into EnergyActivity
            energyInfo = new WifiActivityEnergyInfo(SystemClock.elapsedRealtime(), WifiActivityEnergyInfo.STACK_STATE_STATE_IDLE, stats.tx_time, txTimePerLevel, stats.rx_time, rxIdleTime, energyUsed);
        }
        if (energyInfo != null && energyInfo.isValid()) {
            return energyInfo;
        } else {
            return null;
        }
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
        return null;
    }
}
#method_after
@Override
public WifiActivityEnergyInfo reportActivityInfo() {
    enforceAccessPermission();
    mLog.trace("reportActivityInfo uid=%").c(Binder.getCallingUid()).flush();
    if ((getSupportedFeatures() & WifiManager.WIFI_FEATURE_LINK_LAYER_STATS) == 0) {
        return null;
    }
    WifiLinkLayerStats stats;
    WifiActivityEnergyInfo energyInfo = null;
    if (mWifiStateMachineChannel != null) {
        stats = mWifiStateMachine.syncGetLinkLayerStats(mWifiStateMachineChannel);
        if (stats != null) {
            final long rxIdleCurrent = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_idle_receive_cur_ma);
            final long rxCurrent = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_active_rx_cur_ma);
            final long txCurrent = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_tx_cur_ma);
            final double voltage = mContext.getResources().getInteger(com.android.internal.R.integer.config_wifi_operating_voltage_mv) / 1000.0;
            final long rxIdleTime = stats.on_time - stats.tx_time - stats.rx_time;
            final long[] txTimePerLevel;
            if (stats.tx_time_per_level != null) {
                txTimePerLevel = new long[stats.tx_time_per_level.length];
                for (int i = 0; i < txTimePerLevel.length; i++) {
                    txTimePerLevel[i] = stats.tx_time_per_level[i];
                // TODO(b/27227497): Need to read the power consumed per level from config
                }
            } else {
                // This will happen if the HAL get link layer API returned null.
                txTimePerLevel = new long[0];
            }
            final long energyUsed = (long) ((stats.tx_time * txCurrent + stats.rx_time * rxCurrent + rxIdleTime * rxIdleCurrent) * voltage);
            if (VDBG || rxIdleTime < 0 || stats.on_time < 0 || stats.tx_time < 0 || stats.rx_time < 0 || energyUsed < 0) {
                StringBuilder sb = new StringBuilder();
                sb.append(" rxIdleCur=" + rxIdleCurrent);
                sb.append(" rxCur=" + rxCurrent);
                sb.append(" txCur=" + txCurrent);
                sb.append(" voltage=" + voltage);
                sb.append(" on_time=" + stats.on_time);
                sb.append(" tx_time=" + stats.tx_time);
                sb.append(" tx_time_per_level=" + Arrays.toString(txTimePerLevel));
                sb.append(" rx_time=" + stats.rx_time);
                sb.append(" rxIdleTime=" + rxIdleTime);
                sb.append(" energy=" + energyUsed);
                Log.d(TAG, " reportActivityInfo: " + sb.toString());
            }
            // Convert the LinkLayerStats into EnergyActivity
            energyInfo = new WifiActivityEnergyInfo(mClock.getElapsedSinceBootMillis(), WifiActivityEnergyInfo.STACK_STATE_STATE_IDLE, stats.tx_time, txTimePerLevel, stats.rx_time, rxIdleTime, energyUsed);
        }
        if (energyInfo != null && energyInfo.isValid()) {
            return energyInfo;
        } else {
            return null;
        }
    } else {
        Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
        return null;
    }
}
#end_block

#method_before
@Override
public boolean addOrUpdatePasspointConfiguration(PasspointConfiguration config) {
    enforceChangePermission();
    mLog.trace("addorUpdatePasspointConfiguration uid=%").c(Binder.getCallingUid()).flush();
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_wifi_hotspot2_enabled)) {
        throw new UnsupportedOperationException("Passpoint not enabled");
    }
    return mWifiStateMachine.syncAddOrUpdatePasspointConfig(mWifiStateMachineChannel, config);
}
#method_after
@Override
public boolean addOrUpdatePasspointConfiguration(PasspointConfiguration config) {
    enforceChangePermission();
    mLog.trace("addorUpdatePasspointConfiguration uid=%").c(Binder.getCallingUid()).flush();
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_wifi_hotspot2_enabled)) {
        throw new UnsupportedOperationException("Passpoint not enabled");
    }
    return mWifiStateMachine.syncAddOrUpdatePasspointConfig(mWifiStateMachineChannel, config, Binder.getCallingUid());
}
#end_block

#method_before
public static String checkValidity(WifiConfiguration config) {
    if (config.allowedKeyManagement == null)
        return "allowed kmgmt";
    if (config.allowedKeyManagement.cardinality() > 1) {
        if (config.allowedKeyManagement.cardinality() != 2) {
            return "cardinality != 2";
        }
        if (!config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP)) {
            return "not WPA_EAP";
        }
        if ((!config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && (!config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK))) {
            return "not PSK or 8021X";
        }
    }
    return null;
}
#method_after
public static String checkValidity(WifiConfiguration config) {
    if (config.allowedKeyManagement == null)
        return "allowed kmgmt";
    if (config.allowedKeyManagement.cardinality() > 1) {
        if (config.allowedKeyManagement.cardinality() != 2) {
            return "cardinality != 2";
        }
        if (!config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP)) {
            return "not WPA_EAP";
        }
        if ((!config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && (!config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK))) {
            return "not PSK or 8021X";
        }
    }
    if (config.getIpAssignment() == IpConfiguration.IpAssignment.STATIC) {
        StaticIpConfiguration staticIpConf = config.getStaticIpConfiguration();
        if (staticIpConf == null) {
            return "null StaticIpConfiguration";
        }
        if (staticIpConf.ipAddress == null) {
            return "null static ip Address";
        }
    }
    return null;
}
#end_block

