519
#method_before
@SuppressWarnings("ReferenceEquality")
void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) {
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        if (f.mState == Fragment.INITIALIZING && f.isInBackStack()) {
            // Allow the fragment to be created so that it can be saved later.
            newState = Fragment.CREATED;
        } else {
            // While removing a fragment, we can't change it to a higher state.
            newState = f.mState;
        }
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.ACTIVITY_CREATED) {
        newState = Fragment.ACTIVITY_CREATED;
    }
    // Ensure that Fragments are capped at CREATED instead of ACTIVITY_CREATED.
    if (f.mMaxState.ordinal() == Fragment.ACTIVITY_CREATED) {
        newState = Math.min(newState, Fragment.CREATED);
    } else {
        newState = Math.min(newState, f.mMaxState.ordinal());
    }
    if (f.mState <= newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.getAnimatingAway() != null || f.getAnimator() != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.setAnimatingAway(null);
            f.setAnimator(null);
            moveToState(f, f.getStateAfterAnimating(), 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (newState > Fragment.INITIALIZING) {
                    if (DEBUG)
                        Log.v(TAG, "moveto CREATED: " + f);
                    if (f.mSavedFragmentState != null) {
                        f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                        Fragment target = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                        f.mTargetWho = target != null ? target.mWho : null;
                        if (f.mTargetWho != null) {
                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                        }
                        if (f.mSavedUserVisibleHint != null) {
                            f.mUserVisibleHint = f.mSavedUserVisibleHint;
                            f.mSavedUserVisibleHint = null;
                        } else {
                            f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                        }
                        if (!f.mUserVisibleHint) {
                            f.mDeferStart = true;
                            if (newState > Fragment.ACTIVITY_CREATED) {
                                newState = Fragment.ACTIVITY_CREATED;
                            }
                        }
                    }
                    f.mHost = mHost;
                    f.mParentFragment = mParent;
                    f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.mFragmentManager;
                    // so that this one can rely on it as an initialized dependency.
                    if (f.mTarget != null) {
                        if (mActive.get(f.mTarget.mWho) != f.mTarget) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTarget + " that does not belong to this FragmentManager!");
                        }
                        if (f.mTarget.mState < Fragment.CREATED) {
                            moveToState(f.mTarget, Fragment.CREATED, 0, 0, true);
                        }
                        f.mTargetWho = f.mTarget.mWho;
                        f.mTarget = null;
                    }
                    if (f.mTargetWho != null) {
                        Fragment target = mActive.get(f.mTargetWho);
                        if (target == null) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTargetWho + " that does not belong to this FragmentManager!");
                        }
                        if (target.mState < Fragment.CREATED) {
                            moveToState(target, Fragment.CREATED, 0, 0, true);
                        }
                    }
                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);
                    f.performAttach();
                    if (f.mParentFragment == null) {
                        mHost.onAttachFragment(f);
                    } else {
                        f.mParentFragment.onAttachFragment(f);
                    }
                    dispatchOnFragmentAttached(f, mHost.getContext(), false);
                    if (!f.mIsCreated) {
                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false);
                        f.performCreate(f.mSavedFragmentState);
                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                    } else {
                        f.restoreChildFragmentState(f.mSavedFragmentState);
                        f.mState = Fragment.CREATED;
                    }
                }
            // fall through
            case Fragment.CREATED:
                // we move from CREATED => CREATED as part of the case fall through above.
                if (newState > Fragment.INITIALIZING) {
                    ensureInflatedFragmentView(f);
                }
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto ACTIVITY_CREATED: " + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException("Cannot create fragment " + f + " for a container view with no id"));
                            }
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (Resources.NotFoundException e) {
                                    resName = "unknown";
                                }
                                throwException(new IllegalArgumentException("No view found for id 0x" + Integer.toHexString(f.mContainerId) + " (" + resName + ") for fragment " + f));
                            }
                        }
                        f.mContainer = container;
                        f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mInnerView = f.mView;
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                container.addView(f.mView);
                            }
                            if (f.mHidden) {
                                f.mView.setVisibility(View.GONE);
                            }
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false);
                            // Only animate the view if it is visible. This is done after
                            // dispatchOnFragmentViewCreated in case visibility is changed
                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) && f.mContainer != null;
                        } else {
                            f.mInnerView = null;
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto STARTED: " + f);
                    f.performStart();
                    dispatchOnFragmentStarted(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto RESUMED: " + f);
                    f.performResume();
                    dispatchOnFragmentResumed(f, false);
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom RESUMED: " + f);
                    f.performPause();
                    dispatchOnFragmentPaused(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom STARTED: " + f);
                    f.performStop();
                    dispatchOnFragmentStopped(f, false);
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom ACTIVITY_CREATED: " + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    dispatchOnFragmentViewDestroyed(f, false);
                    if (f.mView != null && f.mContainer != null) {
                        // Stop any current animations:
                        f.mContainer.endViewTransition(f.mView);
                        f.mView.clearAnimation();
                        AnimationOrAnimator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed && f.mView.getVisibility() == View.VISIBLE && f.mPostponedAlpha >= 0) {
                            anim = loadAnimation(f, transit, false, transitionStyle);
                        }
                        f.mPostponedAlpha = 0;
                        if (anim != null) {
                            animateRemoveFragment(f, anim, newState);
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                    // Set here to ensure that Observers are called after
                    // the Fragment's view is set to null
                    f.mViewLifecycleOwner = null;
                    f.mViewLifecycleOwnerLiveData.setValue(null);
                    f.mInnerView = null;
                    f.mInLayout = false;
                }
            // fall through
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        // the fragment.
                        if (f.getAnimatingAway() != null) {
                            View v = f.getAnimatingAway();
                            f.setAnimatingAway(null);
                            v.clearAnimation();
                        } else if (f.getAnimator() != null) {
                            Animator animator = f.getAnimator();
                            f.setAnimator(null);
                            animator.cancel();
                        }
                    }
                    if (f.getAnimatingAway() != null || f.getAnimator() != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.setStateAfterAnimating(newState);
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, "movefrom CREATED: " + f);
                        boolean beingRemoved = f.mRemoving && !f.isInBackStack();
                        if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                            boolean shouldClear;
                            if (mHost instanceof ViewModelStoreOwner) {
                                shouldClear = mNonConfig.isCleared();
                            } else if (mHost.getContext() instanceof Activity) {
                                Activity activity = (Activity) mHost.getContext();
                                shouldClear = !activity.isChangingConfigurations();
                            } else {
                                shouldClear = true;
                            }
                            if (beingRemoved || shouldClear) {
                                mNonConfig.clearNonConfigState(f);
                            }
                            f.performDestroy();
                            dispatchOnFragmentDestroyed(f, false);
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        dispatchOnFragmentDetached(f, false);
                        if (!keepActive) {
                            if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                if (f.mTargetWho != null) {
                                    Fragment target = mActive.get(f.mTargetWho);
                                    if (target != null && target.getRetainInstance()) {
                                        // Only keep references to other retained Fragments
                                        // to avoid developers accessing Fragments that
                                        // are never coming back
                                        f.mTarget = target;
                                    }
                                }
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, "moveToState: Fragment state for " + f + " not updated inline; " + "expected state " + newState + " found " + f.mState);
        f.mState = newState;
    }
}
#method_after
@SuppressWarnings("ReferenceEquality")
void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) {
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        if (f.mState == Fragment.INITIALIZING && f.isInBackStack()) {
            // Allow the fragment to be created so that it can be saved later.
            newState = Fragment.CREATED;
        } else {
            // While removing a fragment, we can't change it to a higher state.
            newState = f.mState;
        }
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.ACTIVITY_CREATED) {
        newState = Fragment.ACTIVITY_CREATED;
    }
    // Ensure that Fragments are capped at CREATED instead of ACTIVITY_CREATED.
    if (f.mMaxState == Lifecycle.State.CREATED) {
        newState = Math.min(newState, Fragment.CREATED);
    } else {
        newState = Math.min(newState, f.mMaxState.ordinal());
    }
    if (f.mState <= newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.getAnimatingAway() != null || f.getAnimator() != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.setAnimatingAway(null);
            f.setAnimator(null);
            moveToState(f, f.getStateAfterAnimating(), 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (newState > Fragment.INITIALIZING) {
                    if (DEBUG)
                        Log.v(TAG, "moveto CREATED: " + f);
                    if (f.mSavedFragmentState != null) {
                        f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                        Fragment target = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                        f.mTargetWho = target != null ? target.mWho : null;
                        if (f.mTargetWho != null) {
                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                        }
                        if (f.mSavedUserVisibleHint != null) {
                            f.mUserVisibleHint = f.mSavedUserVisibleHint;
                            f.mSavedUserVisibleHint = null;
                        } else {
                            f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                        }
                        if (!f.mUserVisibleHint) {
                            f.mDeferStart = true;
                            if (newState > Fragment.ACTIVITY_CREATED) {
                                newState = Fragment.ACTIVITY_CREATED;
                            }
                        }
                    }
                    f.mHost = mHost;
                    f.mParentFragment = mParent;
                    f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.mFragmentManager;
                    // so that this one can rely on it as an initialized dependency.
                    if (f.mTarget != null) {
                        if (mActive.get(f.mTarget.mWho) != f.mTarget) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTarget + " that does not belong to this FragmentManager!");
                        }
                        if (f.mTarget.mState < Fragment.CREATED) {
                            moveToState(f.mTarget, Fragment.CREATED, 0, 0, true);
                        }
                        f.mTargetWho = f.mTarget.mWho;
                        f.mTarget = null;
                    }
                    if (f.mTargetWho != null) {
                        Fragment target = mActive.get(f.mTargetWho);
                        if (target == null) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTargetWho + " that does not belong to this FragmentManager!");
                        }
                        if (target.mState < Fragment.CREATED) {
                            moveToState(target, Fragment.CREATED, 0, 0, true);
                        }
                    }
                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);
                    f.performAttach();
                    if (f.mParentFragment == null) {
                        mHost.onAttachFragment(f);
                    } else {
                        f.mParentFragment.onAttachFragment(f);
                    }
                    dispatchOnFragmentAttached(f, mHost.getContext(), false);
                    if (!f.mIsCreated) {
                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false);
                        f.performCreate(f.mSavedFragmentState);
                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                    } else {
                        f.restoreChildFragmentState(f.mSavedFragmentState);
                        f.mState = Fragment.CREATED;
                    }
                }
            // fall through
            case Fragment.CREATED:
                // we move from CREATED => CREATED as part of the case fall through above.
                if (newState > Fragment.INITIALIZING) {
                    ensureInflatedFragmentView(f);
                }
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto ACTIVITY_CREATED: " + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException("Cannot create fragment " + f + " for a container view with no id"));
                            }
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (Resources.NotFoundException e) {
                                    resName = "unknown";
                                }
                                throwException(new IllegalArgumentException("No view found for id 0x" + Integer.toHexString(f.mContainerId) + " (" + resName + ") for fragment " + f));
                            }
                        }
                        f.mContainer = container;
                        f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mInnerView = f.mView;
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                container.addView(f.mView);
                            }
                            if (f.mHidden) {
                                f.mView.setVisibility(View.GONE);
                            }
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false);
                            // Only animate the view if it is visible. This is done after
                            // dispatchOnFragmentViewCreated in case visibility is changed
                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) && f.mContainer != null;
                        } else {
                            f.mInnerView = null;
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto STARTED: " + f);
                    f.performStart();
                    dispatchOnFragmentStarted(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto RESUMED: " + f);
                    f.performResume();
                    dispatchOnFragmentResumed(f, false);
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom RESUMED: " + f);
                    f.performPause();
                    dispatchOnFragmentPaused(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom STARTED: " + f);
                    f.performStop();
                    dispatchOnFragmentStopped(f, false);
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom ACTIVITY_CREATED: " + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    dispatchOnFragmentViewDestroyed(f, false);
                    if (f.mView != null && f.mContainer != null) {
                        // Stop any current animations:
                        f.mContainer.endViewTransition(f.mView);
                        f.mView.clearAnimation();
                        AnimationOrAnimator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed && f.mView.getVisibility() == View.VISIBLE && f.mPostponedAlpha >= 0) {
                            anim = loadAnimation(f, transit, false, transitionStyle);
                        }
                        f.mPostponedAlpha = 0;
                        if (anim != null) {
                            animateRemoveFragment(f, anim, newState);
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                    // Set here to ensure that Observers are called after
                    // the Fragment's view is set to null
                    f.mViewLifecycleOwner = null;
                    f.mViewLifecycleOwnerLiveData.setValue(null);
                    f.mInnerView = null;
                    f.mInLayout = false;
                }
            // fall through
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        // the fragment.
                        if (f.getAnimatingAway() != null) {
                            View v = f.getAnimatingAway();
                            f.setAnimatingAway(null);
                            v.clearAnimation();
                        } else if (f.getAnimator() != null) {
                            Animator animator = f.getAnimator();
                            f.setAnimator(null);
                            animator.cancel();
                        }
                    }
                    if (f.getAnimatingAway() != null || f.getAnimator() != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.setStateAfterAnimating(newState);
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, "movefrom CREATED: " + f);
                        boolean beingRemoved = f.mRemoving && !f.isInBackStack();
                        if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                            boolean shouldClear;
                            if (mHost instanceof ViewModelStoreOwner) {
                                shouldClear = mNonConfig.isCleared();
                            } else if (mHost.getContext() instanceof Activity) {
                                Activity activity = (Activity) mHost.getContext();
                                shouldClear = !activity.isChangingConfigurations();
                            } else {
                                shouldClear = true;
                            }
                            if (beingRemoved || shouldClear) {
                                mNonConfig.clearNonConfigState(f);
                            }
                            f.performDestroy();
                            dispatchOnFragmentDestroyed(f, false);
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        dispatchOnFragmentDetached(f, false);
                        if (!keepActive) {
                            if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                if (f.mTargetWho != null) {
                                    Fragment target = mActive.get(f.mTargetWho);
                                    if (target != null && target.getRetainInstance()) {
                                        // Only keep references to other retained Fragments
                                        // to avoid developers accessing Fragments that
                                        // are never coming back
                                        f.mTarget = target;
                                    }
                                }
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, "moveToState: Fragment state for " + f + " not updated inline; " + "expected state " + newState + " found " + f.mState);
        f.mState = newState;
    }
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY)
@SuppressLint("NewApi")
@RequiresFeature(name = WebViewFeature.FORCE_DARK, enforcement = "androidx.webkit.WebViewFeature#isFeatureSupported")
@ForceDark
public static int getForceDark(WebSettings webSettings) {
    WebViewFeatureInternal webViewFeature = WebViewFeatureInternal.getFeature(WebViewFeature.FORCE_DARK);
    if (webViewFeature.isSupportedByWebView()) {
        return getAdapter(webSettings).getForceDark();
    } else {
        throw WebViewFeatureInternal.getUnsupportedOperationException();
    }
}
#method_after
/**
 * Get the force dark mode for this WebView.
 *
 * <p>
 * The default force dark mode is {@link #FORCE_DARK_AUTO}
 *
 * <p>
 * This method should only be called if
 * {@link WebViewFeature#isFeatureSupported(String)}
 * returns true for {@link WebViewFeature#FORCE_DARK}.
 *
 * @return the currently set force dark mode.
 *
 * TODO(amalova): unhide
 * @hide
 */
@RestrictTo(RestrictTo.Scope.LIBRARY)
@SuppressLint("NewApi")
@RequiresFeature(name = WebViewFeature.FORCE_DARK, enforcement = "androidx.webkit.WebViewFeature#isFeatureSupported")
@ForceDark
public static int getForceDark(WebSettings webSettings) {
    WebViewFeatureInternal webViewFeature = WebViewFeatureInternal.getFeature(WebViewFeature.FORCE_DARK);
    if (webViewFeature.isSupportedByWebView()) {
        return getAdapter(webSettings).getForceDark();
    } else {
        throw WebViewFeatureInternal.getUnsupportedOperationException();
    }
}
#end_block

#method_before
@Override
public void onInfo(MediaPlayer2 mp, final MediaItem item, final int mp2What, final int extra) {
    switch(mp2What) {
        case MediaPlayer2.MEDIA_INFO_BUFFERING_START:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_STARVED);
            break;
        case MediaPlayer2.MEDIA_INFO_PREPARED:
        case MediaPlayer2.MEDIA_INFO_BUFFERING_END:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
            break;
        case MediaPlayer2.MEDIA_INFO_BUFFERING_UPDATE:
            if (extra >= /* percent */
            100) {
                setBufferingState(item, BUFFERING_STATE_COMPLETE);
            }
            break;
        case MediaPlayer2.MEDIA_INFO_DATA_SOURCE_LIST_END:
            setState(PLAYER_STATE_PAUSED);
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer.PlayerCallback callback) {
                    callback.onPlaybackCompleted(MediaPlayer.this);
                }
            });
            break;
    }
    final int what = sInfoCodeMap.containsKey(mp2What) ? sInfoCodeMap.get(mp2What) : MEDIA_INFO_UNKNOWN;
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onInfo(MediaPlayer.this, item, what, extra);
        }
    });
}
#method_after
@Override
public void onInfo(MediaPlayer2 mp, final MediaItem item, final int mp2What, final int extra) {
    switch(mp2What) {
        case MediaPlayer2.MEDIA_INFO_BUFFERING_START:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_STARVED);
            break;
        case MediaPlayer2.MEDIA_INFO_PREPARED:
        case MediaPlayer2.MEDIA_INFO_BUFFERING_END:
            setBufferingState(item, BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
            break;
        case MediaPlayer2.MEDIA_INFO_BUFFERING_UPDATE:
            if (extra >= /* percent */
            100) {
                setBufferingState(item, BUFFERING_STATE_COMPLETE);
            }
            break;
        case MediaPlayer2.MEDIA_INFO_DATA_SOURCE_LIST_END:
            setState(PLAYER_STATE_PAUSED);
            notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                @Override
                public void callCallback(SessionPlayer.PlayerCallback callback) {
                    callback.onPlaybackCompleted(MediaPlayer.this);
                }
            });
            break;
    }
    if (sInfoCodeMap.containsKey(mp2What)) {
        final int what = sInfoCodeMap.get(mp2What);
        notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

            @Override
            public void callCallback(PlayerCallback callback) {
                callback.onInfo(MediaPlayer.this, item, what, extra);
            }
        });
    }
}
#end_block

#method_before
@Override
@NonNull
public MediaController build() {
    if (mToken == null && mCompatToken == null) {
        throw new IllegalArgumentException("token and compat token shouldn't be both null");
    }
    if (mCallback != null && mCallbackExecutor == null) {
        throw new IllegalArgumentException("an executor is required if a callback is set");
    }
    if (mToken != null) {
        return new MediaController(mContext, mToken, mConnectionHints, mCallbackExecutor, mCallback);
    } else {
        return new MediaController(mContext, mCompatToken, mConnectionHints, mCallbackExecutor, mCallback);
    }
}
#method_after
@Override
@NonNull
public MediaController build() {
    if (mToken == null && mCompatToken == null) {
        throw new IllegalArgumentException("token and compat token shouldn't be both null");
    }
    if (mToken != null) {
        return new MediaController(mContext, mToken, mConnectionHints, mCallbackExecutor, mCallback);
    } else {
        return new MediaController(mContext, mCompatToken, mConnectionHints, mCallbackExecutor, mCallback);
    }
}
#end_block

#method_before
@Override
@NonNull
public ControllerCallback getCallback() {
    return mCallback;
}
#method_after
@Override
@Nullable
public ControllerCallback getCallback() {
    return mCallback;
}
#end_block

#method_before
@Override
@NonNull
public MediaBrowser build() {
    if (mToken == null && mCompatToken == null) {
        throw new IllegalArgumentException("token and compat token shouldn't be both null");
    }
    if (mCallback != null && mCallbackExecutor == null) {
        throw new IllegalArgumentException("an executor is required if a callback is set");
    }
    if (mToken != null) {
        return new MediaBrowser(mContext, mToken, mConnectionHints, mCallbackExecutor, (BrowserCallback) mCallback);
    } else {
        return new MediaBrowser(mContext, mCompatToken, mConnectionHints, mCallbackExecutor, (BrowserCallback) mCallback);
    }
}
#method_after
@Override
@NonNull
public MediaBrowser build() {
    if (mToken == null && mCompatToken == null) {
        throw new IllegalArgumentException("token and compat token shouldn't be both null");
    }
    if (mToken != null) {
        return new MediaBrowser(mContext, mToken, mConnectionHints, mCallbackExecutor, (BrowserCallback) mCallback);
    } else {
        return new MediaBrowser(mContext, mCompatToken, mConnectionHints, mCallbackExecutor, (BrowserCallback) mCallback);
    }
}
#end_block

#method_before
@Override
public void exit() {
    log("Exit Disconnected(" + mDevice + "): " + messageWhatToString(getCurrentMessage().what));
    mLastConnectionState = BluetoothProfile.STATE_DISCONNECTED;
    mStillInWhitelist = false;
}
#method_after
@Override
public void exit() {
    log("Exit Disconnected(" + mDevice + "): " + messageWhatToString(getCurrentMessage().what));
    mLastConnectionState = BluetoothProfile.STATE_DISCONNECTED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    log("Disconnected process message(" + mDevice + "): " + messageWhatToString(message.what));
    switch(message.what) {
        case CONNECT:
            log("Connecting to " + mDevice);
            if (!mNativeInterface.connectHearingAid(mDevice)) {
                Log.e(TAG, "Disconnected: error connecting to " + mDevice);
                break;
            }
            if (mService.okToConnect(mDevice)) {
                transitionTo(mConnecting);
            } else {
                // Reject the request and stay in Disconnected state
                Log.w(TAG, "Outgoing HearingAid Connecting request rejected: " + mDevice);
            }
            break;
        case DISCONNECT:
            if (mStillInWhitelist) {
                Log.d(TAG, "Disconnected: DISCONNECT but device is still in whitelist: " + mDevice);
                mNativeInterface.disconnectHearingAid(mDevice);
            } else {
                Log.w(TAG, "Disconnected: DISCONNECT ignored: " + mDevice);
            }
        case STACK_EVENT:
            HearingAidStackEvent event = (HearingAidStackEvent) message.obj;
            if (DBG) {
                Log.d(TAG, "Disconnected: stack event: " + event);
            }
            if (!mDevice.equals(event.device)) {
                Log.wtfStack(TAG, "Device(" + mDevice + "): event mismatch: " + event);
            }
            switch(event.type) {
                case HearingAidStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(event.valueInt1);
                    break;
                default:
                    Log.e(TAG, "Disconnected: ignoring stack event: " + event);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    log("Disconnected process message(" + mDevice + "): " + messageWhatToString(message.what));
    switch(message.what) {
        case CONNECT:
            log("Connecting to " + mDevice);
            if (!mNativeInterface.connectHearingAid(mDevice)) {
                Log.e(TAG, "Disconnected: error connecting to " + mDevice);
                break;
            }
            if (mService.okToConnect(mDevice)) {
                transitionTo(mConnecting);
            } else {
                // Reject the request and stay in Disconnected state
                Log.w(TAG, "Outgoing HearingAid Connecting request rejected: " + mDevice);
            }
            break;
        case DISCONNECT:
            Log.d(TAG, "Disconnected: DISCONNECT: call native disconnect for " + mDevice);
            mNativeInterface.disconnectHearingAid(mDevice);
            break;
        case STACK_EVENT:
            HearingAidStackEvent event = (HearingAidStackEvent) message.obj;
            if (DBG) {
                Log.d(TAG, "Disconnected: stack event: " + event);
            }
            if (!mDevice.equals(event.device)) {
                Log.wtfStack(TAG, "Device(" + mDevice + "): event mismatch: " + event);
            }
            switch(event.type) {
                case HearingAidStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(event.valueInt1);
                    break;
                default:
                    Log.e(TAG, "Disconnected: ignoring stack event: " + event);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    log("Connecting process message(" + mDevice + "): " + messageWhatToString(message.what));
    switch(message.what) {
        case CONNECT:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            Log.w(TAG, "Connecting connection timeout: " + mDevice);
            mNativeInterface.disconnectHearingAid(mDevice);
            HearingAidStackEvent disconnectEvent = new HearingAidStackEvent(HearingAidStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED);
            disconnectEvent.device = mDevice;
            disconnectEvent.valueInt1 = HearingAidStackEvent.CONNECTION_STATE_DISCONNECTED;
            sendMessage(STACK_EVENT, disconnectEvent);
            break;
        case DISCONNECT:
            log("Connecting: connection canceled to " + mDevice);
            mNativeInterface.disconnectHearingAid(mDevice);
            transitionTo(mDisconnected);
            break;
        case STACK_EVENT:
            HearingAidStackEvent event = (HearingAidStackEvent) message.obj;
            log("Connecting: stack event: " + event);
            if (!mDevice.equals(event.device)) {
                Log.wtfStack(TAG, "Device(" + mDevice + "): event mismatch: " + event);
            }
            switch(event.type) {
                case HearingAidStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(event.valueInt1);
                    break;
                default:
                    Log.e(TAG, "Connecting: ignoring stack event: " + event);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    log("Connecting process message(" + mDevice + "): " + messageWhatToString(message.what));
    switch(message.what) {
        case CONNECT:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            Log.w(TAG, "Connecting connection timeout: " + mDevice);
            mNativeInterface.disconnectHearingAid(mDevice);
            if (mService.isConnectedPeerDevices(mDevice)) {
                Log.w(TAG, "One side connection timeout: " + mDevice + ". Try whitelist");
                mNativeInterface.addToWhiteList(mDevice);
            }
            HearingAidStackEvent disconnectEvent = new HearingAidStackEvent(HearingAidStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED);
            disconnectEvent.device = mDevice;
            disconnectEvent.valueInt1 = HearingAidStackEvent.CONNECTION_STATE_DISCONNECTED;
            sendMessage(STACK_EVENT, disconnectEvent);
            break;
        case DISCONNECT:
            log("Connecting: connection canceled to " + mDevice);
            mNativeInterface.disconnectHearingAid(mDevice);
            transitionTo(mDisconnected);
            break;
        case STACK_EVENT:
            HearingAidStackEvent event = (HearingAidStackEvent) message.obj;
            log("Connecting: stack event: " + event);
            if (!mDevice.equals(event.device)) {
                Log.wtfStack(TAG, "Device(" + mDevice + "): event mismatch: " + event);
            }
            switch(event.type) {
                case HearingAidStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(event.valueInt1);
                    break;
                default:
                    Log.e(TAG, "Connecting: ignoring stack event: " + event);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private void processConnectionEvent(int state) {
    switch(state) {
        case HearingAidStackEvent.CONNECTION_STATE_DISCONNECTED:
            Log.i(TAG, "Disconnected from " + mDevice + " but still in Whitelist");
            mStillInWhitelist = true;
            transitionTo(mDisconnected);
            break;
        case HearingAidStackEvent.CONNECTION_STATE_DISCONNECTING:
            Log.i(TAG, "Disconnecting from " + mDevice);
            transitionTo(mDisconnecting);
            break;
        default:
            Log.e(TAG, "Connection State Device: " + mDevice + " bad state: " + state);
            break;
    }
}
#method_after
private void processConnectionEvent(int state) {
    switch(state) {
        case HearingAidStackEvent.CONNECTION_STATE_DISCONNECTED:
            Log.i(TAG, "Disconnected from " + mDevice + " but still in Whitelist");
            transitionTo(mDisconnected);
            break;
        case HearingAidStackEvent.CONNECTION_STATE_DISCONNECTING:
            Log.i(TAG, "Disconnecting from " + mDevice);
            transitionTo(mDisconnecting);
            break;
        default:
            Log.e(TAG, "Connection State Device: " + mDevice + " bad state: " + state);
            break;
    }
}
#end_block

#method_before
@Test
public void compareAndSetDefault() {
    MimeMap otherMimeMap = mock(TestMimeMap.class);
    MimeMap defaultMimeMap = MimeMap.getDefault();
    assertTrue(MimeMap.compareAndSetDefaut(defaultMimeMap, mimeMap));
    try {
        assertNotNull(defaultMimeMap);
        assertEquals(mimeMap, MimeMap.getDefault());
        assertFalse(MimeMap.compareAndSetDefaut(defaultMimeMap, otherMimeMap));
    } finally {
        assertTrue(MimeMap.compareAndSetDefaut(mimeMap, defaultMimeMap));
    }
}
#method_after
@Test
public void compareAndSetDefault() {
    MimeMap otherMimeMap = mock(TestMimeMap.class);
    MimeMap defaultMimeMap = MimeMap.getDefault();
    assertTrue(MimeMap.compareAndSetDefault(defaultMimeMap, mimeMap));
    try {
        assertNotNull(defaultMimeMap);
        assertEquals(mimeMap, MimeMap.getDefault());
        assertFalse(MimeMap.compareAndSetDefault(defaultMimeMap, otherMimeMap));
    } finally {
        assertTrue(MimeMap.compareAndSetDefault(mimeMap, defaultMimeMap));
    }
}
#end_block

#method_before
@Test
public void compareAndSetDefault_null() {
    MimeMap defaultMimeMap = MimeMap.getDefault();
    try {
        MimeMap.compareAndSetDefaut(defaultMimeMap, null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        MimeMap.compareAndSetDefaut(null, defaultMimeMap);
        fail();
    } catch (NullPointerException expected) {
    }
    // For comparison, this does not throw (but has no effect):
    MimeMap.compareAndSetDefaut(defaultMimeMap, defaultMimeMap);
    assertEquals(defaultMimeMap, MimeMap.getDefault());
}
#method_after
@Test
public void compareAndSetDefault_null() {
    MimeMap defaultMimeMap = MimeMap.getDefault();
    try {
        MimeMap.compareAndSetDefault(defaultMimeMap, null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        MimeMap.compareAndSetDefault(null, defaultMimeMap);
        fail();
    } catch (NullPointerException expected) {
    }
    // For comparison, this does not throw (but has no effect):
    MimeMap.compareAndSetDefault(defaultMimeMap, defaultMimeMap);
    assertEquals(defaultMimeMap, MimeMap.getDefault());
}
#end_block

#method_before
public static MimeMap getDefault() {
    return defaultHolder.get();
}
#method_after
@NonNull
public static MimeMap getDefault() {
    return defaultHolder.get();
}
#end_block

#method_before
private static void parseTypes(Map<String, String> mimeTypeToExtension, Map<String, String> extensionToMimeType, String resource) {
    try (BufferedReader r = new BufferedReader(new InputStreamReader(MimeUtils.class.getResourceAsStream(resource)))) {
        String line;
        while ((line = r.readLine()) != null) {
            int commentPos = line.indexOf('#');
            if (commentPos >= 0) {
                line = line.substring(0, commentPos);
            }
            line = line.trim();
            if (line.equals("")) {
                continue;
            }
            final String[] split = splitPattern.split(line);
            final String mimeType = toLowerCase(split[0]);
            if (isNullOrEmpty(mimeType)) {
                throw new IllegalArgumentException("Invalid mimeType " + mimeType + " in: " + line);
            }
            for (int i = 1; i < split.length; i++) {
                String extension = toLowerCase(split[i]);
                if (isNullOrEmpty(extension)) {
                    throw new IllegalArgumentException("Invalid extension " + extension + " in: " + line);
                }
                if (extension.endsWith("!")) {
                    extension = extension.substring(0, extension.length() - 1);
                    // Overriding MIME definition wins
                    mimeTypeToExtension.put(mimeType, extension);
                } else {
                    // First MIME definition wins
                    if (!mimeTypeToExtension.containsKey(mimeType)) {
                        mimeTypeToExtension.put(mimeType, extension);
                    }
                }
                // Last extension definition wins
                extensionToMimeType.put(extension, mimeType);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("Failed to parse " + resource, e);
    }
}
#method_after
private static void parseTypes(Map<String, String> mimeTypeToExtension, Map<String, String> extensionToMimeType, String resource) {
    try (BufferedReader r = new BufferedReader(new InputStreamReader(MimeMap.class.getResourceAsStream(resource)))) {
        String line;
        while ((line = r.readLine()) != null) {
            int commentPos = line.indexOf('#');
            if (commentPos >= 0) {
                line = line.substring(0, commentPos);
            }
            line = line.trim();
            if (line.equals("")) {
                continue;
            }
            final String[] split = splitPattern.split(line);
            final String mimeType = toLowerCase(split[0]);
            if (isNullOrEmpty(mimeType)) {
                throw new IllegalArgumentException("Invalid mimeType " + mimeType + " in: " + line);
            }
            for (int i = 1; i < split.length; i++) {
                String extension = toLowerCase(split[i]);
                if (isNullOrEmpty(extension)) {
                    throw new IllegalArgumentException("Invalid extension " + extension + " in: " + line);
                }
                if (extension.endsWith("!")) {
                    extension = extension.substring(0, extension.length() - 1);
                    // Overriding MIME definition wins
                    mimeTypeToExtension.put(mimeType, extension);
                } else {
                    // First MIME definition wins
                    if (!mimeTypeToExtension.containsKey(mimeType)) {
                        mimeTypeToExtension.put(mimeType, extension);
                    }
                }
                // Last extension definition wins
                extensionToMimeType.put(extension, mimeType);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("Failed to parse " + resource, e);
    }
}
#end_block

#method_before
@NonNull
public Builder setExtras(@Nullable Bundle extras) {
    mBundle = extras;
    return this;
}
#method_after
@NonNull
@Override
public Builder setExtras(@NonNull Bundle extras) {
    return super.setExtras(extras);
}
#end_block

#method_before
@NonNull
public LibraryParams build() {
    return new LibraryParams(mBundle, mRecent, mOffline, mSuggested);
}
#method_after
@Override
@NonNull
public MediaLibrarySession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {
        };
    }
    return new MediaLibrarySession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback, mExtras);
}
#end_block

#method_before
public PlaybackStateCompat build() {
    return new PlaybackStateCompat(mState, mPosition, mBufferedPosition, mRate, mActions, mErrorCode, mErrorMessage, mUpdateTime, mCustomActions, mActiveItemId, mExtras);
}
#method_after
public CustomAction build() {
    return new CustomAction(mAction, mName, mIcon, mExtras);
}
#end_block

#method_before
@NonNull
public Builder setExtras(@Nullable Bundle extras) {
    mExtras = extras;
    return this;
}
#method_after
@NonNull
@Override
public Builder setExtras(@NonNull Bundle extras) {
    return super.setExtras(extras);
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback, mExtras);
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> setMediaItemsInternal(@NonNull MediaItem curItem, @Nullable MediaItem nextItem) {
    boolean setMediaItemCalled;
    synchronized (mPlaylistLock) {
        setMediaItemCalled = mSetMediaItemCalled;
    }
    ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
    if (setMediaItemCalled) {
        futures.add(setNextMediaItemInternal(curItem));
        futures.add(skipToNextInternal());
    } else {
        futures.add(setMediaItemInternal(curItem));
    }
    if (nextItem != null) {
        futures.add(setNextMediaItemInternal(nextItem));
    }
    return futures;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
List<ResolvableFuture<PlayerResult>> setMediaItemsInternal(@NonNull MediaItem curItem, @Nullable MediaItem nextItem) {
    if (curItem == null) {
        throw new NullPointerException("curItem shouldn't be null");
    }
    boolean setMediaItemCalled;
    synchronized (mPlaylistLock) {
        setMediaItemCalled = mSetMediaItemCalled;
    }
    ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
    if (setMediaItemCalled) {
        futures.add(setNextMediaItemInternal(curItem));
        futures.add(skipToNextInternal());
    } else {
        futures.add(setMediaItemInternal(curItem));
    }
    if (nextItem != null) {
        futures.add(setNextMediaItemInternal(nextItem));
    }
    return futures;
}
#end_block

#method_before
@Override
public ListenableFuture<LibraryResult> getSearchResult(@NonNull final String query, final int page, final int pageSize, @Nullable final LibraryParams param) {
    MediaBrowserCompat browserCompat = getBrowserCompat();
    if (browserCompat == null) {
        return LibraryResult.createFutureWithResult(RESULT_ERROR_SESSION_DISCONNECTED);
    }
    final ResolvableFuture<LibraryResult> future = ResolvableFuture.create();
    Bundle options = createBundle(param);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browserCompat.search(query, options, new MediaBrowserCompat.SearchCallback() {

        @Override
        public void onSearchResult(final String query, final Bundle extrasSent, final List<MediaBrowserCompat.MediaItem> items) {
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    List<MediaItem> item2List = MediaUtils.convertMediaItemListToMediaItemList(items);
                    future.set(new LibraryResult(RESULT_SUCCESS, item2List, null));
                }
            });
        }

        @Override
        public void onError(final String query, final Bundle extrasSent) {
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    future.set(new LibraryResult(RESULT_ERROR_UNKNOWN));
                }
            });
        }
    });
    return future;
}
#method_after
@Override
public ListenableFuture<LibraryResult> getSearchResult(@NonNull final String query, final int page, final int pageSize, @Nullable final LibraryParams param) {
    MediaBrowserCompat browserCompat = getBrowserCompat();
    if (browserCompat == null) {
        return LibraryResult.createFutureWithResult(RESULT_ERROR_SESSION_DISCONNECTED);
    }
    final ResolvableFuture<LibraryResult> future = ResolvableFuture.create();
    Bundle options = createBundle(param);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE, page);
    options.putInt(MediaBrowserCompat.EXTRA_PAGE_SIZE, pageSize);
    browserCompat.search(query, options, new MediaBrowserCompat.SearchCallback() {

        @Override
        public void onSearchResult(final String query, final Bundle extrasSent, final List<MediaBrowserCompat.MediaItem> items) {
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    List<MediaItem> item2List = MediaUtils.convertMediaItemListToMediaItemList(items);
                    future.set(new LibraryResult(RESULT_SUCCESS, item2List, null));
                }
            });
        }

        @Override
        public void onError(final String query, final Bundle extrasSent) {
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    future.set(new LibraryResult(RESULT_ERROR_UNKNOWN));
                }
            });
        }
    });
    return future;
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP_PREFIX)
public ListenableFuture<SessionResult> playFromMediaId(@NonNull String mediaId, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("mediaId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().playFromMediaId(mediaId, extras);
    }
    return createDisconnectedFuture();
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public ListenableFuture<SessionResult> playFromMediaId(@NonNull String mediaId, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("mediaId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().playFromMediaId(mediaId, extras);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP_PREFIX)
public ListenableFuture<SessionResult> playFromSearch(@NonNull String query, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().playFromSearch(query, extras);
    }
    return createDisconnectedFuture();
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public ListenableFuture<SessionResult> playFromSearch(@NonNull String query, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().playFromSearch(query, extras);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP_PREFIX)
public ListenableFuture<SessionResult> playFromUri(@NonNull Uri uri, @Nullable Bundle extras) {
    if (uri == null) {
        throw new NullPointerException("uri shouldn't be null");
    }
    if (isConnected()) {
        return getImpl().playFromUri(uri, extras);
    }
    return createDisconnectedFuture();
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public ListenableFuture<SessionResult> playFromUri(@NonNull Uri uri, @Nullable Bundle extras) {
    if (uri == null) {
        throw new NullPointerException("uri shouldn't be null");
    }
    if (isConnected()) {
        return getImpl().playFromUri(uri, extras);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP_PREFIX)
public ListenableFuture<SessionResult> prepareFromMediaId(@NonNull String mediaId, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("mediaId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().prepareFromMediaId(mediaId, extras);
    }
    return createDisconnectedFuture();
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public ListenableFuture<SessionResult> prepareFromMediaId(@NonNull String mediaId, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("mediaId shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().prepareFromMediaId(mediaId, extras);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP_PREFIX)
public ListenableFuture<SessionResult> prepareFromSearch(@NonNull String query, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().prepareFromSearch(query, extras);
    }
    return createDisconnectedFuture();
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public ListenableFuture<SessionResult> prepareFromSearch(@NonNull String query, @Nullable Bundle extras) {
    if (TextUtils.isEmpty(query)) {
        throw new IllegalArgumentException("query shouldn't be empty");
    }
    if (isConnected()) {
        return getImpl().prepareFromSearch(query, extras);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP_PREFIX)
public ListenableFuture<SessionResult> prepareFromUri(@NonNull Uri uri, @Nullable Bundle extras) {
    if (uri == null) {
        throw new NullPointerException("uri shouldn't be null");
    }
    if (isConnected()) {
        return getImpl().prepareFromUri(uri, extras);
    }
    return createDisconnectedFuture();
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public ListenableFuture<SessionResult> prepareFromUri(@NonNull Uri uri, @Nullable Bundle extras) {
    if (uri == null) {
        throw new NullPointerException("uri shouldn't be null");
    }
    if (isConnected()) {
        return getImpl().prepareFromUri(uri, extras);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@NonNull
ControllerCallback getCallback() {
    return isConnected() ? getImpl().getCallback() : null;
}
#method_after
@Nullable
ControllerCallback getCallback() {
    return isConnected() ? getImpl().getCallback() : null;
}
#end_block

#method_before
@NonNull
Executor getCallbackExecutor() {
    return isConnected() ? getImpl().getCallbackExecutor() : null;
}
#method_after
@Nullable
Executor getCallbackExecutor() {
    return isConnected() ? getImpl().getCallbackExecutor() : null;
}
#end_block

#method_before
@Test
public void testOpenAndCloseUdpEncapsulationSocket() throws Exception {
    int localport = findUnusedPort();
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    assertEquals(localport, udpEncapResp.port);
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    udpEncapResp.fileDescriptor.close();
    // Verify quota and RefcountedResource objects cleaned up
    IpSecService.UserRecord userRecord = mIpSecService.mUserResourceTracker.getUserRecord(Os.getuid());
    assertEquals(0, userRecord.mSocketQuotaTracker.mCurrent);
    try {
        userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(udpEncapResp.resourceId);
        fail("Expected IllegalArgumentException on attempt to access deleted resource");
    } catch (IllegalArgumentException expected) {
    }
}
#method_after
@Test
public void testOpenAndCloseUdpEncapsulationSocket() throws Exception {
    int localport = -1;
    IpSecUdpEncapResponse udpEncapResp = null;
    for (int i = 0; i < IpSecService.MAX_PORT_BIND_ATTEMPTS; i++) {
        localport = findUnusedPort();
        udpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
        assertNotNull(udpEncapResp);
        if (udpEncapResp.status == IpSecManager.Status.OK) {
            break;
        }
    // Else retry to reduce possibility for port-bind failures.
    }
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    assertEquals(localport, udpEncapResp.port);
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    udpEncapResp.fileDescriptor.close();
    // Verify quota and RefcountedResource objects cleaned up
    IpSecService.UserRecord userRecord = mIpSecService.mUserResourceTracker.getUserRecord(Os.getuid());
    assertEquals(0, userRecord.mSocketQuotaTracker.mCurrent);
    try {
        userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(udpEncapResp.resourceId);
        fail("Expected IllegalArgumentException on attempt to access deleted resource");
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
@Test
public void testOpenUdpEncapsulationSocketAfterClose() throws Exception {
    int localport = findUnusedPort();
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    assertEquals(localport, udpEncapResp.port);
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    udpEncapResp.fileDescriptor.close();
    /**
     * Check if localport is available.
     */
    FileDescriptor newSocket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    Os.bind(newSocket, INADDR_ANY, localport);
    Os.close(newSocket);
}
#method_after
@Test
public void testOpenUdpEncapsulationSocketAfterClose() throws Exception {
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    int localport = udpEncapResp.port;
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    udpEncapResp.fileDescriptor.close();
    /**
     * Check if localport is available.
     */
    FileDescriptor newSocket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    Os.bind(newSocket, INADDR_ANY, localport);
    Os.close(newSocket);
}
#end_block

#method_before
@Test
public void testUdpEncapPortNotReleased() throws Exception {
    int localport = findUnusedPort();
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    assertEquals(localport, udpEncapResp.port);
    udpEncapResp.fileDescriptor.close();
    FileDescriptor newSocket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    try {
        Os.bind(newSocket, INADDR_ANY, localport);
        fail("ErrnoException not thrown");
    } catch (ErrnoException e) {
        assertEquals(EADDRINUSE, e.errno);
    }
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
}
#method_after
@Test
public void testUdpEncapPortNotReleased() throws Exception {
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    int localport = udpEncapResp.port;
    udpEncapResp.fileDescriptor.close();
    FileDescriptor newSocket = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    try {
        Os.bind(newSocket, INADDR_ANY, localport);
        fail("ErrnoException not thrown");
    } catch (ErrnoException e) {
        assertEquals(EADDRINUSE, e.errno);
    }
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
}
#end_block

#method_before
@Test
public void testOpenUdpEncapsulationSocketTwice() throws Exception {
    int localport = findUnusedPort();
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    assertEquals(localport, udpEncapResp.port);
    mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
    IpSecUdpEncapResponse testUdpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
    assertEquals(IpSecManager.Status.RESOURCE_UNAVAILABLE, testUdpEncapResp.status);
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    udpEncapResp.fileDescriptor.close();
}
#method_after
@Test
public void testOpenUdpEncapsulationSocketTwice() throws Exception {
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    int localport = udpEncapResp.port;
    IpSecUdpEncapResponse testUdpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
    assertEquals(IpSecManager.Status.RESOURCE_UNAVAILABLE, testUdpEncapResp.status);
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    udpEncapResp.fileDescriptor.close();
}
#end_block

#method_before
@Test
public void testEncapSocketReleasedBeforeKeepaliveReleased() throws Exception {
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    // Get encap socket record, verify initial starting refcount.
    IpSecService.UserRecord userRecord = mIpSecService.mUserResourceTracker.getUserRecord(mUid);
    IpSecService.RefcountedResource encapSocketRefcountedRecord = userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(udpEncapResp.resourceId);
    assertEquals(1, encapSocketRefcountedRecord.mRefCount);
    // Verify that the reference was added
    int nattKeepaliveResourceId = mIpSecService.lockEncapSocketForNattKeepalive(udpEncapResp.resourceId, mUid);
    assertNotEquals(IpSecManager.INVALID_RESOURCE_ID, nattKeepaliveResourceId);
    assertEquals(2, encapSocketRefcountedRecord.mRefCount);
    // Close UDP encap socket, but expect the refcountedRecord to still have a reference.
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    assertEquals(1, encapSocketRefcountedRecord.mRefCount);
    assertTrue(encapSocketRefcountedRecord.mUserReleased);
    // Verify UDP encap socket cleaned up once reference is removed. Expect -1 if cleanup
    // was properly complted.
    mIpSecService.releaseNattKeepalive(nattKeepaliveResourceId, mUid);
    assertEquals(-1, encapSocketRefcountedRecord.mRefCount);
}
#method_after
@Test
public void testEncapSocketReleasedBeforeKeepaliveReleased() throws Exception {
    IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(0, new Binder());
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    // Get encap socket record, verify initial starting refcount.
    IpSecService.UserRecord userRecord = mIpSecService.mUserResourceTracker.getUserRecord(mUid);
    IpSecService.RefcountedResource encapSocketRefcountedRecord = userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(udpEncapResp.resourceId);
    assertEquals(1, encapSocketRefcountedRecord.mRefCount);
    // Verify that the reference was added
    int nattKeepaliveResourceId = mIpSecService.lockEncapSocketForNattKeepalive(udpEncapResp.resourceId, mUid);
    assertNotEquals(IpSecManager.INVALID_RESOURCE_ID, nattKeepaliveResourceId);
    assertEquals(2, encapSocketRefcountedRecord.mRefCount);
    // Close UDP encap socket, but expect the refcountedRecord to still have a reference.
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    assertEquals(1, encapSocketRefcountedRecord.mRefCount);
    // Verify UDP encap socket cleaned up once reference is removed. Expect -1 if cleanup
    // was properly completed.
    mIpSecService.releaseNattKeepalive(nattKeepaliveResourceId, mUid);
    assertEquals(-1, encapSocketRefcountedRecord.mRefCount);
}
#end_block

#method_before
@GuardedBy("IpSecService.this")
public void userRelease() throws RemoteException {
    // to keep it around.)
    if (mUserReleased) {
        return;
    }
    if (mBinder != null) {
        mBinder.unlinkToDeath(this, 0);
        mBinder = null;
    }
    mResource.invalidate();
    releaseReference();
    mUserReleased = true;
}
#method_after
@GuardedBy("IpSecService.this")
public void userRelease() throws RemoteException {
    // userRelease() multiple times.
    if (mBinder == null) {
        return;
    }
    if (mBinder != DUMMY_BINDER) {
        mBinder.unlinkToDeath(this, 0);
    }
    mBinder = null;
    mResource.invalidate();
    releaseReference();
}
#end_block

#method_before
// No quota for NATT keepalive, since a pre-requisite is having a EncapSocket resource.
void removeSpiRecord(int resourceId) {
    mSpiRecords.remove(resourceId);
}
#method_after
void removeSpiRecord(int resourceId) {
    mSpiRecords.remove(resourceId);
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append("{mSpiQuotaTracker=").append(mSpiQuotaTracker).append(", mTransformQuotaTracker=").append(mTransformQuotaTracker).append(", mSocketQuotaTracker=").append(mSocketQuotaTracker).append(", mTunnelQuotaTracker=").append(mTunnelQuotaTracker).append(", mSpiRecords=").append(mSpiRecords).append(", mTransformRecords=").append(mTransformRecords).append(", mEncapSocketRecords=").append(mEncapSocketRecords).append(", mTunnelInterfaceRecords=").append(mTunnelInterfaceRecords).append("}").toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append("{mSpiQuotaTracker=").append(mSpiQuotaTracker).append(", mTransformQuotaTracker=").append(mTransformQuotaTracker).append(", mSocketQuotaTracker=").append(mSocketQuotaTracker).append(", mNattKeepaliveQuotaTracker=").append(mNattKeepaliveQuotaTracker).append(", mTunnelQuotaTracker=").append(mTunnelQuotaTracker).append(", mSpiRecords=").append(mSpiRecords).append(", mTransformRecords=").append(mTransformRecords).append(", mEncapSocketRecords=").append(mEncapSocketRecords).append(", mNattKeepaliveRecords=").append(mNattKeepaliveRecords).append(", mTunnelInterfaceRecords=").append(mTunnelInterfaceRecords).append("}").toString();
}
#end_block

#method_before
@Override
public void freeUnderlyingResources() {
    Log.d(TAG, "Natt Keepalive released: " + mResourceId);
}
#method_after
@Override
@GuardedBy("IpSecService.this")
public void freeUnderlyingResources() {
    Log.d(TAG, "Natt Keepalive released: " + mResourceId);
    getResourceTracker().give();
}
#end_block

#method_before
@Override
protected ResourceTracker getResourceTracker() {
    return null;
}
#method_after
@Override
protected ResourceTracker getResourceTracker() {
    return getUserRecord().mNattKeepaliveQuotaTracker;
}
#end_block

#method_before
public synchronized int lockEncapSocketForNattKeepalive(int encapSocketResourceId, int ownerUid) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.NETWORK_STACK, TAG);
    // Verify ownership. Will throw IllegalArgumentException if the UID specified does not
    // own the specified UDP encapsulation socket
    UserRecord userRecord = mUserResourceTracker.getUserRecord(ownerUid);
    RefcountedResource<EncapSocketRecord> refcountedSocketRecord = userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(encapSocketResourceId);
    // Build NattKeepaliveRecord
    final int resourceId = mNextResourceId++;
    userRecord.mNattKeepaliveRecords.put(resourceId, new RefcountedResource<NattKeepaliveRecord>(new NattKeepaliveRecord(resourceId), refcountedSocketRecord));
    return resourceId;
}
#method_after
public synchronized int lockEncapSocketForNattKeepalive(int encapSocketResourceId, int ownerUid) {
    verifyNetworkStackCaller();
    // Verify ownership. Will throw IllegalArgumentException if the UID specified does not
    // own the specified UDP encapsulation socket
    UserRecord userRecord = mUserResourceTracker.getUserRecord(ownerUid);
    RefcountedResource<EncapSocketRecord> refcountedSocketRecord = userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(encapSocketResourceId);
    // Build NattKeepaliveRecord
    final int resourceId = mNextResourceId++;
    userRecord.mNattKeepaliveRecords.put(resourceId, new RefcountedResource<NattKeepaliveRecord>(new NattKeepaliveRecord(resourceId), refcountedSocketRecord));
    return resourceId;
}
#end_block

#method_before
@Override
public synchronized void releaseNattKeepalive(int nattKeepaliveResourceId, int ownerUid) throws RemoteException {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.NETWORK_STACK, TAG);
    UserRecord userRecord = mUserResourceTracker.getUserRecord(ownerUid);
    releaseResource(userRecord.mNattKeepaliveRecords, nattKeepaliveResourceId);
}
#method_after
@Override
public synchronized void releaseNattKeepalive(int nattKeepaliveResourceId, int ownerUid) throws RemoteException {
    verifyNetworkStackCaller();
    UserRecord userRecord = mUserResourceTracker.getUserRecord(ownerUid);
    releaseResource(userRecord.mNattKeepaliveRecords, nattKeepaliveResourceId);
}
#end_block

#method_before
private void doTestNattSocketKeepalivesWithExecutor(Executor executor) throws Exception {
    // TODO: 1. Move this outside of ConnectivityServiceTest.
    // 2. Make test to verify that Nat-T keepalive socket is created by IpSecService.
    // 3. Mock ipsec service.
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress notMyIPv4 = InetAddress.getByName("192.0.2.35");
    final InetAddress myIPv6 = InetAddress.getByName("2001:db8::1");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final InetAddress dstIPv6 = InetAddress.getByName("2001:4860:4860::8888");
    final int validKaInterval = 15;
    final int invalidKaInterval = 9;
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket();
    final int srcPort = testSocket.getPort();
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv6, 64));
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("fe80::1234")));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network notMyNet = new Network(61234);
    Network myNet = connectKeepaliveNetwork(lp);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Invalid network.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(notMyNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
    }
    // Invalid interval.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(invalidKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_INTERVAL);
    }
    // Invalid destination.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Invalid source;
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // NAT-T is only supported for IPv4.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Sanity check before testing started keepalive.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_UNSUPPORTED);
    }
    // Check that a started keepalive can be stopped.
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
        ka.stop();
        callback.expectStopped();
        // Check that keepalive could be restarted.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
        // Check that keepalive can be restarted without waiting for callback.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        ka.start(validKaInterval);
        callback.expectStopped();
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that deleting the IP address stops the keepalive.
    LinkProperties bogusLp = new LinkProperties(lp);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        bogusLp.removeLinkAddress(new LinkAddress(myIPv4, 25));
        bogusLp.addLinkAddress(new LinkAddress(notMyIPv4, 25));
        mWiFiNetworkAgent.sendLinkProperties(bogusLp);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
        mWiFiNetworkAgent.sendLinkProperties(lp);
    }
    // Check that a started keepalive is stopped correctly when the network disconnects.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.disconnect();
        waitFor(mWiFiNetworkAgent.getDisconnectedCV());
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
        // ... and that stopping it after that has no adverse effects.
        waitForIdle();
        final Network myNetAlias = myNet;
        assertNull(mCm.getNetworkCapabilities(myNetAlias));
        ka.stop();
        callback.assertNoCallback();
    }
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    // Check that keepalive slots start from 1 and increment. The first one gets slot 1.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    int srcPort2 = 0;
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        // The second one gets slot 2.
        mWiFiNetworkAgent.setExpectedKeepaliveSlot(2);
        final UdpEncapsulationSocket testSocket2 = mIpSec.openUdpEncapsulationSocket();
        srcPort2 = testSocket2.getPort();
        TestSocketKeepaliveCallback callback2 = new TestSocketKeepaliveCallback(executor);
        try (SocketKeepalive ka2 = mCm.createSocketKeepalive(myNet, testSocket2, myIPv4, dstIPv4, executor, callback2)) {
            ka2.start(validKaInterval);
            callback2.expectStarted();
            ka.stop();
            callback.expectStopped();
            ka2.stop();
            callback2.expectStopped();
            testSocket.close();
            testSocket2.close();
        }
    }
    // Check that there is no port leaked after all keepalives and sockets are closed.
    assertFalse(isUdpPortInUse(srcPort));
    assertFalse(isUdpPortInUse(srcPort2));
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#method_after
private void doTestNattSocketKeepalivesWithExecutor(Executor executor) throws Exception {
    // TODO: 1. Move this outside of ConnectivityServiceTest.
    // 2. Make test to verify that Nat-T keepalive socket is created by IpSecService.
    // 3. Mock ipsec service.
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress notMyIPv4 = InetAddress.getByName("192.0.2.35");
    final InetAddress myIPv6 = InetAddress.getByName("2001:db8::1");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final InetAddress dstIPv6 = InetAddress.getByName("2001:4860:4860::8888");
    final int validKaInterval = 15;
    final int invalidKaInterval = 9;
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket();
    final int srcPort = testSocket.getPort();
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv6, 64));
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("fe80::1234")));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network notMyNet = new Network(61234);
    Network myNet = connectKeepaliveNetwork(lp);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Invalid network.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(notMyNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
    }
    // Invalid interval.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(invalidKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_INTERVAL);
    }
    // Invalid destination.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Invalid source;
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // NAT-T is only supported for IPv4.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Sanity check before testing started keepalive.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_UNSUPPORTED);
    }
    // Check that a started keepalive can be stopped.
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
        ka.stop();
        callback.expectStopped();
        // Check that keepalive could be restarted.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
        // Check that keepalive can be restarted without waiting for callback.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        ka.start(validKaInterval);
        callback.expectStopped();
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that deleting the IP address stops the keepalive.
    LinkProperties bogusLp = new LinkProperties(lp);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        bogusLp.removeLinkAddress(new LinkAddress(myIPv4, 25));
        bogusLp.addLinkAddress(new LinkAddress(notMyIPv4, 25));
        mWiFiNetworkAgent.sendLinkProperties(bogusLp);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
        mWiFiNetworkAgent.sendLinkProperties(lp);
    }
    // Check that a started keepalive is stopped correctly when the network disconnects.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.disconnect();
        waitFor(mWiFiNetworkAgent.getDisconnectedCV());
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
        // ... and that stopping it after that has no adverse effects.
        waitForIdle();
        final Network myNetAlias = myNet;
        assertNull(mCm.getNetworkCapabilities(myNetAlias));
        ka.stop();
        callback.assertNoCallback();
    }
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    // Check that keepalive slots start from 1 and increment. The first one gets slot 1.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    int srcPort2 = 0;
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        // The second one gets slot 2.
        mWiFiNetworkAgent.setExpectedKeepaliveSlot(2);
        final UdpEncapsulationSocket testSocket2 = mIpSec.openUdpEncapsulationSocket();
        srcPort2 = testSocket2.getPort();
        TestSocketKeepaliveCallback callback2 = new TestSocketKeepaliveCallback(executor);
        try (SocketKeepalive ka2 = mCm.createSocketKeepalive(myNet, testSocket2, myIPv4, dstIPv4, executor, callback2)) {
            ka2.start(validKaInterval);
            callback2.expectStarted();
            ka.stop();
            callback.expectStopped();
            ka2.stop();
            callback2.expectStopped();
            testSocket.close();
            testSocket2.close();
        }
    }
    // Check that there is no port leaked after all keepalives and sockets are closed.
    // TODO: enable this check after ensuring a valid free port. See b/129512753#comment7.
    // assertFalse(isUdpPortInUse(srcPort));
    // assertFalse(isUdpPortInUse(srcPort2));
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#end_block

#method_before
private void doTestNattSocketKeepalivesFdWithExecutor(Executor executor) throws Exception {
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress anyIPv4 = InetAddress.getByName("0.0.0.0");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final int validKaInterval = 15;
    // Prepare the target network.
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Prepare the target file descriptor, keep only one instance.
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket();
    final int srcPort = testSocket.getPort();
    final ParcelFileDescriptor testPfd = ParcelFileDescriptor.dup(testSocket.getFileDescriptor());
    testSocket.close();
    assertTrue(isUdpPortInUse(srcPort));
    // block.
    try (SocketKeepalive ka = mCm.createNattKeepalive(myNet, testPfd, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that the ParcelFileDescriptor is still valid after keepalive stopped,
    // ErrnoException with EBADF will be thrown if the socket is closed when checking local
    // address.
    assertTrue(isUdpPortInUse(srcPort));
    final InetSocketAddress sa = (InetSocketAddress) Os.getsockname(testPfd.getFileDescriptor());
    assertEquals(anyIPv4, sa.getAddress());
    testPfd.close();
    assertFalse(isUdpPortInUse(srcPort));
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#method_after
private void doTestNattSocketKeepalivesFdWithExecutor(Executor executor) throws Exception {
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress anyIPv4 = InetAddress.getByName("0.0.0.0");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final int validKaInterval = 15;
    // Prepare the target network.
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Prepare the target file descriptor, keep only one instance.
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket();
    final int srcPort = testSocket.getPort();
    final ParcelFileDescriptor testPfd = ParcelFileDescriptor.dup(testSocket.getFileDescriptor());
    testSocket.close();
    assertTrue(isUdpPortInUse(srcPort));
    // block.
    try (SocketKeepalive ka = mCm.createNattKeepalive(myNet, testPfd, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that the ParcelFileDescriptor is still valid after keepalive stopped,
    // ErrnoException with EBADF will be thrown if the socket is closed when checking local
    // address.
    assertTrue(isUdpPortInUse(srcPort));
    final InetSocketAddress sa = (InetSocketAddress) Os.getsockname(testPfd.getFileDescriptor());
    assertEquals(anyIPv4, sa.getAddress());
    testPfd.close();
    // TODO: enable this check after ensuring a valid free port. See b/129512753#comment7.
    // assertFalse(isUdpPortInUse(srcPort));
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#end_block

#method_before
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    ArgumentCaptor<String[]> tlsServers = ArgumentCaptor.forClass(String[].class);
    // Clear any interactions that occur as a result of CS starting up.
    reset(mMockDnsResolver);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mMockDnsResolver, never()).setResolverConfiguration(anyInt(), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY), eq(EMPTY_STRING_ARRAY));
    verifyNoMoreInteractions(mMockDnsResolver);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), MOBILE_IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mMockDnsResolver, times(1)).createNetworkCache(eq(mCellNetworkAgent.getNetwork().netId));
    // CS tells dnsresolver about the empty DNS config for this network.
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(anyInt(), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY), eq(EMPTY_STRING_ARRAY));
    reset(mMockDnsResolver);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture(), eq(EMPTY_STRING_ARRAY));
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "2001:db8::1"));
    // Opportunistic mode.
    assertTrue(ArrayUtils.contains(tlsServers.getValue(), "2001:db8::1"));
    reset(mMockDnsResolver);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture(), eq(EMPTY_STRING_ARRAY));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    // Opportunistic mode.
    assertEquals(2, tlsServers.getValue().length);
    assertTrue(ArrayUtils.containsAll(tlsServers.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    final String TLS_SPECIFIER = "tls.example.com";
    final String TLS_SERVER6 = "2001:db8:53::53";
    final InetAddress[] TLS_IPS = new InetAddress[] { InetAddress.getByName(TLS_SERVER6) };
    final String[] TLS_SERVERS = new String[] { TLS_SERVER6 };
    mCellNetworkAgent.mNmCallbacks.notifyPrivateDnsConfigResolved(new PrivateDnsConfig(TLS_SPECIFIER, TLS_IPS).toParcel());
    waitForIdle();
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(TLS_SPECIFIER), eq(TLS_SERVERS), eq(EMPTY_STRING_ARRAY));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
}
#method_after
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    // Clear any interactions that occur as a result of CS starting up.
    reset(mMockDnsResolver);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mMockDnsResolver, never()).setResolverConfiguration(any());
    verifyNoMoreInteractions(mMockDnsResolver);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), MOBILE_IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mMockDnsResolver, times(1)).createNetworkCache(eq(mCellNetworkAgent.getNetwork().netId));
    // CS tells dnsresolver about the empty DNS config for this network.
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(any());
    reset(mMockDnsResolver);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(mResolverParamsParcelCaptor.capture());
    ResolverParamsParcel resolvrParams = mResolverParamsParcelCaptor.getValue();
    assertEquals(1, resolvrParams.servers.length);
    assertTrue(ArrayUtils.contains(resolvrParams.servers, "2001:db8::1"));
    // Opportunistic mode.
    assertTrue(ArrayUtils.contains(resolvrParams.tlsServers, "2001:db8::1"));
    reset(mMockDnsResolver);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(mResolverParamsParcelCaptor.capture());
    resolvrParams = mResolverParamsParcelCaptor.getValue();
    assertEquals(2, resolvrParams.servers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.servers, new String[] { "2001:db8::1", "192.0.2.1" }));
    // Opportunistic mode.
    assertEquals(2, resolvrParams.tlsServers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.tlsServers, new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    final String TLS_SPECIFIER = "tls.example.com";
    final String TLS_SERVER6 = "2001:db8:53::53";
    final InetAddress[] TLS_IPS = new InetAddress[] { InetAddress.getByName(TLS_SERVER6) };
    final String[] TLS_SERVERS = new String[] { TLS_SERVER6 };
    mCellNetworkAgent.mNmCallbacks.notifyPrivateDnsConfigResolved(new PrivateDnsConfig(TLS_SPECIFIER, TLS_IPS).toParcel());
    waitForIdle();
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(mResolverParamsParcelCaptor.capture());
    resolvrParams = mResolverParamsParcelCaptor.getValue();
    assertEquals(2, resolvrParams.servers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.servers, new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
}
#end_block

#method_before
@Test
public void testPrivateDnsSettingsChange() throws Exception {
    ArgumentCaptor<String[]> tlsServers = ArgumentCaptor.forClass(String[].class);
    // Clear any interactions that occur as a result of CS starting up.
    reset(mMockDnsResolver);
    // The default on Android is opportunistic mode ("Automatic").
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    // CS tells netd about the empty DNS config for this network.
    verify(mMockDnsResolver, never()).setResolverConfiguration(anyInt(), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY), eq(EMPTY_STRING_ARRAY));
    verifyNoMoreInteractions(mMockDnsResolver);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), MOBILE_IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), MOBILE_IFNAME));
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mMockDnsResolver, times(1)).createNetworkCache(eq(mCellNetworkAgent.getNetwork().netId));
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture(), eq(EMPTY_STRING_ARRAY));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    // Opportunistic mode.
    assertEquals(2, tlsServers.getValue().length);
    assertTrue(ArrayUtils.containsAll(tlsServers.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, mCellNetworkAgent);
    CallbackInfo cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.BLOCKED_STATUS, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OFF, "ignored.example.com");
    verify(mMockDnsResolver, times(1)).setResolverConfiguration(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY), eq(EMPTY_STRING_ARRAY));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    cellNetworkCallback.assertNoCallback();
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture(), eq(EMPTY_STRING_ARRAY));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    assertEquals(2, tlsServers.getValue().length);
    assertTrue(ArrayUtils.containsAll(tlsServers.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    cellNetworkCallback.assertNoCallback();
    setPrivateDnsSettings(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME, "strict.example.com");
    // Can't test dns configuration for strict mode without properly mocking
    // out the DNS lookups, but can test that LinkProperties is updated.
    cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertTrue(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertEquals("strict.example.com", ((LinkProperties) cbi.arg).getPrivateDnsServerName());
}
#method_after
@Test
public void testPrivateDnsSettingsChange() throws Exception {
    // Clear any interactions that occur as a result of CS starting up.
    reset(mMockDnsResolver);
    // The default on Android is opportunistic mode ("Automatic").
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    // CS tells netd about the empty DNS config for this network.
    verify(mMockDnsResolver, never()).setResolverConfiguration(any());
    verifyNoMoreInteractions(mMockDnsResolver);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), MOBILE_IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), MOBILE_IFNAME));
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mMockDnsResolver, times(1)).createNetworkCache(eq(mCellNetworkAgent.getNetwork().netId));
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(mResolverParamsParcelCaptor.capture());
    ResolverParamsParcel resolvrParams = mResolverParamsParcelCaptor.getValue();
    assertEquals(2, resolvrParams.tlsServers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.tlsServers, new String[] { "2001:db8::1", "192.0.2.1" }));
    // Opportunistic mode.
    assertEquals(2, resolvrParams.tlsServers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.tlsServers, new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, mCellNetworkAgent);
    CallbackInfo cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.BLOCKED_STATUS, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OFF, "ignored.example.com");
    verify(mMockDnsResolver, times(1)).setResolverConfiguration(mResolverParamsParcelCaptor.capture());
    resolvrParams = mResolverParamsParcelCaptor.getValue();
    assertEquals(2, resolvrParams.servers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.servers, new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    cellNetworkCallback.assertNoCallback();
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(mResolverParamsParcelCaptor.capture());
    resolvrParams = mResolverParamsParcelCaptor.getValue();
    assertEquals(2, resolvrParams.servers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.servers, new String[] { "2001:db8::1", "192.0.2.1" }));
    assertEquals(2, resolvrParams.tlsServers.length);
    assertTrue(ArrayUtils.containsAll(resolvrParams.tlsServers, new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mMockDnsResolver);
    cellNetworkCallback.assertNoCallback();
    setPrivateDnsSettings(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME, "strict.example.com");
    // Can't test dns configuration for strict mode without properly mocking
    // out the DNS lookups, but can test that LinkProperties is updated.
    cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertTrue(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertEquals("strict.example.com", ((LinkProperties) cbi.arg).getPrivateDnsServerName());
}
#end_block

#method_before
@Test
public void testStackedLinkProperties() throws UnknownHostException, RemoteException {
    final LinkAddress myIpv4 = new LinkAddress("1.2.3.4/24");
    final LinkAddress myIpv6 = new LinkAddress("2001:db8:1::1/64");
    final String kNat64PrefixString = "2001:db8:64:64:64:64::";
    final IpPrefix kNat64Prefix = new IpPrefix(InetAddress.getByName(kNat64PrefixString), 96);
    final NetworkRequest networkRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(networkRequest, networkCallback);
    // Prepare ipv6 only link properties.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    final int cellNetId = mCellNetworkAgent.getNetwork().netId;
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    cellLp.addLinkAddress(myIpv6);
    cellLp.addRoute(new RouteInfo((IpPrefix) null, myIpv6.getAddress(), MOBILE_IFNAME));
    cellLp.addRoute(new RouteInfo(myIpv6, null, MOBILE_IFNAME));
    reset(mNetworkManagementService);
    reset(mMockDnsResolver);
    reset(mMockNetd);
    when(mNetworkManagementService.getInterfaceConfig(CLAT_PREFIX + MOBILE_IFNAME)).thenReturn(getClatInterfaceConfig(myIpv4));
    // Connect with ipv6 link properties. Expect prefix discovery to be started.
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(true);
    verify(mMockNetd, times(1)).networkCreatePhysical(eq(cellNetId), anyInt());
    verify(mMockDnsResolver, times(1)).createNetworkCache(eq(cellNetId));
    networkCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).startPrefix64Discovery(cellNetId);
    // Switching default network updates TCP buffer sizes.
    verifyTcpBufferSizeChange(ConnectivityService.DEFAULT_TCP_BUFFER_SIZES);
    // Add an IPv4 address. Expect prefix discovery to be stopped. Netd doesn't tell us that
    // the NAT64 prefix was removed because one was never discovered.
    cellLp.addLinkAddress(myIpv4);
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).stopPrefix64Discovery(cellNetId);
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(eq(cellNetId), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY), eq(EMPTY_STRING_ARRAY));
    verifyNoMoreInteractions(mMockNetd);
    verifyNoMoreInteractions(mMockDnsResolver);
    reset(mMockNetd);
    reset(mMockDnsResolver);
    // Remove IPv4 address. Expect prefix discovery to be started again.
    cellLp.removeLinkAddress(myIpv4);
    cellLp.removeRoute(new RouteInfo(myIpv4, null, MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).startPrefix64Discovery(cellNetId);
    // When NAT64 prefix discovery succeeds, LinkProperties are updated and clatd is started.
    Nat464Xlat clat = mService.getNat464Xlat(mCellNetworkAgent);
    assertNull(mCm.getLinkProperties(mCellNetworkAgent.getNetwork()).getNat64Prefix());
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, true, /* added */
    kNat64PrefixString, 96);
    LinkProperties lpBeforeClat = (LinkProperties) networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent).arg;
    assertEquals(0, lpBeforeClat.getStackedLinks().size());
    assertEquals(kNat64Prefix, lpBeforeClat.getNat64Prefix());
    verify(mMockNetd, times(1)).clatdStart(MOBILE_IFNAME, kNat64Prefix.toString());
    // Clat iface comes up. Expect stacked link to be added.
    clat.interfaceLinkStateChanged(CLAT_PREFIX + MOBILE_IFNAME, true);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    List<LinkProperties> stackedLps = mCm.getLinkProperties(mCellNetworkAgent.getNetwork()).getStackedLinks();
    assertEquals(makeClatLinkProperties(myIpv4), stackedLps.get(0));
    // Change trivial linkproperties and see if stacked link is preserved.
    cellLp.addDnsServer(InetAddress.getByName("8.8.8.8"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    List<LinkProperties> stackedLpsAfterChange = mCm.getLinkProperties(mCellNetworkAgent.getNetwork()).getStackedLinks();
    assertNotEquals(stackedLpsAfterChange, Collections.EMPTY_LIST);
    assertEquals(makeClatLinkProperties(myIpv4), stackedLpsAfterChange.get(0));
    verify(mMockDnsResolver, times(1)).setResolverConfiguration(eq(cellNetId), mStringArrayCaptor.capture(), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY), eq(EMPTY_STRING_ARRAY));
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "8.8.8.8"));
    // Add ipv4 address, expect that clatd and prefix discovery are stopped and stacked
    // linkproperties are cleaned up.
    cellLp.addLinkAddress(myIpv4);
    cellLp.addRoute(new RouteInfo(myIpv4, null, MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockNetd, times(1)).clatdStop(MOBILE_IFNAME);
    verify(mMockDnsResolver, times(1)).stopPrefix64Discovery(cellNetId);
    // As soon as stop is called, the linkproperties lose the stacked interface.
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    LinkProperties actualLpAfterIpv4 = mCm.getLinkProperties(mCellNetworkAgent.getNetwork());
    LinkProperties expected = new LinkProperties(cellLp);
    expected.setNat64Prefix(kNat64Prefix);
    assertEquals(expected, actualLpAfterIpv4);
    assertEquals(0, actualLpAfterIpv4.getStackedLinks().size());
    // The interface removed callback happens but has no effect after stop is called.
    clat.interfaceRemoved(CLAT_PREFIX + MOBILE_IFNAME);
    networkCallback.assertNoCallback();
    verifyNoMoreInteractions(mMockNetd);
    verifyNoMoreInteractions(mMockDnsResolver);
    reset(mMockNetd);
    reset(mMockDnsResolver);
    // Stopping prefix discovery causes netd to tell us that the NAT64 prefix is gone.
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, false, /* added */
    kNat64PrefixString, 96);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getNat64Prefix() == null, mCellNetworkAgent);
    // Remove IPv4 address and expect prefix discovery and clatd to be started again.
    cellLp.removeLinkAddress(myIpv4);
    cellLp.removeRoute(new RouteInfo(myIpv4, null, MOBILE_IFNAME));
    cellLp.removeDnsServer(InetAddress.getByName("8.8.8.8"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).startPrefix64Discovery(cellNetId);
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, true, /* added */
    kNat64PrefixString, 96);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockNetd, times(1)).clatdStart(MOBILE_IFNAME, kNat64Prefix.toString());
    // Clat iface comes up. Expect stacked link to be added.
    clat.interfaceLinkStateChanged(CLAT_PREFIX + MOBILE_IFNAME, true);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getStackedLinks().size() == 1 && lp.getNat64Prefix() != null, mCellNetworkAgent);
    // NAT64 prefix is removed. Expect that clat is stopped.
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, false, /* added */
    kNat64PrefixString, 96);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getStackedLinks().size() == 0 && lp.getNat64Prefix() == null, mCellNetworkAgent);
    verify(mMockNetd, times(1)).clatdStop(MOBILE_IFNAME);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getStackedLinks().size() == 0, mCellNetworkAgent);
    // Clean up.
    mCellNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    networkCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(networkCallback);
}
#method_after
@Test
public void testStackedLinkProperties() throws UnknownHostException, RemoteException {
    final LinkAddress myIpv4 = new LinkAddress("1.2.3.4/24");
    final LinkAddress myIpv6 = new LinkAddress("2001:db8:1::1/64");
    final String kNat64PrefixString = "2001:db8:64:64:64:64::";
    final IpPrefix kNat64Prefix = new IpPrefix(InetAddress.getByName(kNat64PrefixString), 96);
    final NetworkRequest networkRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).addCapability(NET_CAPABILITY_INTERNET).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(networkRequest, networkCallback);
    // Prepare ipv6 only link properties.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    final int cellNetId = mCellNetworkAgent.getNetwork().netId;
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    cellLp.addLinkAddress(myIpv6);
    cellLp.addRoute(new RouteInfo((IpPrefix) null, myIpv6.getAddress(), MOBILE_IFNAME));
    cellLp.addRoute(new RouteInfo(myIpv6, null, MOBILE_IFNAME));
    reset(mNetworkManagementService);
    reset(mMockDnsResolver);
    reset(mMockNetd);
    when(mNetworkManagementService.getInterfaceConfig(CLAT_PREFIX + MOBILE_IFNAME)).thenReturn(getClatInterfaceConfig(myIpv4));
    // Connect with ipv6 link properties. Expect prefix discovery to be started.
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(true);
    verify(mMockNetd, times(1)).networkCreatePhysical(eq(cellNetId), anyInt());
    verify(mMockDnsResolver, times(1)).createNetworkCache(eq(cellNetId));
    networkCallback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).startPrefix64Discovery(cellNetId);
    // Switching default network updates TCP buffer sizes.
    verifyTcpBufferSizeChange(ConnectivityService.DEFAULT_TCP_BUFFER_SIZES);
    // Add an IPv4 address. Expect prefix discovery to be stopped. Netd doesn't tell us that
    // the NAT64 prefix was removed because one was never discovered.
    cellLp.addLinkAddress(myIpv4);
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).stopPrefix64Discovery(cellNetId);
    verify(mMockDnsResolver, atLeastOnce()).setResolverConfiguration(any());
    verifyNoMoreInteractions(mMockNetd);
    verifyNoMoreInteractions(mMockDnsResolver);
    reset(mMockNetd);
    reset(mMockDnsResolver);
    // Remove IPv4 address. Expect prefix discovery to be started again.
    cellLp.removeLinkAddress(myIpv4);
    cellLp.removeRoute(new RouteInfo(myIpv4, null, MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).startPrefix64Discovery(cellNetId);
    // When NAT64 prefix discovery succeeds, LinkProperties are updated and clatd is started.
    Nat464Xlat clat = mService.getNat464Xlat(mCellNetworkAgent);
    assertNull(mCm.getLinkProperties(mCellNetworkAgent.getNetwork()).getNat64Prefix());
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, true, /* added */
    kNat64PrefixString, 96);
    LinkProperties lpBeforeClat = (LinkProperties) networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent).arg;
    assertEquals(0, lpBeforeClat.getStackedLinks().size());
    assertEquals(kNat64Prefix, lpBeforeClat.getNat64Prefix());
    verify(mMockNetd, times(1)).clatdStart(MOBILE_IFNAME, kNat64Prefix.toString());
    // Clat iface comes up. Expect stacked link to be added.
    clat.interfaceLinkStateChanged(CLAT_PREFIX + MOBILE_IFNAME, true);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    List<LinkProperties> stackedLps = mCm.getLinkProperties(mCellNetworkAgent.getNetwork()).getStackedLinks();
    assertEquals(makeClatLinkProperties(myIpv4), stackedLps.get(0));
    // Change trivial linkproperties and see if stacked link is preserved.
    cellLp.addDnsServer(InetAddress.getByName("8.8.8.8"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    List<LinkProperties> stackedLpsAfterChange = mCm.getLinkProperties(mCellNetworkAgent.getNetwork()).getStackedLinks();
    assertNotEquals(stackedLpsAfterChange, Collections.EMPTY_LIST);
    assertEquals(makeClatLinkProperties(myIpv4), stackedLpsAfterChange.get(0));
    verify(mMockDnsResolver, times(1)).setResolverConfiguration(mResolverParamsParcelCaptor.capture());
    ResolverParamsParcel resolvrParams = mResolverParamsParcelCaptor.getValue();
    assertEquals(1, resolvrParams.servers.length);
    assertTrue(ArrayUtils.contains(resolvrParams.servers, "8.8.8.8"));
    // Add ipv4 address, expect that clatd and prefix discovery are stopped and stacked
    // linkproperties are cleaned up.
    cellLp.addLinkAddress(myIpv4);
    cellLp.addRoute(new RouteInfo(myIpv4, null, MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockNetd, times(1)).clatdStop(MOBILE_IFNAME);
    verify(mMockDnsResolver, times(1)).stopPrefix64Discovery(cellNetId);
    // As soon as stop is called, the linkproperties lose the stacked interface.
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    LinkProperties actualLpAfterIpv4 = mCm.getLinkProperties(mCellNetworkAgent.getNetwork());
    LinkProperties expected = new LinkProperties(cellLp);
    expected.setNat64Prefix(kNat64Prefix);
    assertEquals(expected, actualLpAfterIpv4);
    assertEquals(0, actualLpAfterIpv4.getStackedLinks().size());
    // The interface removed callback happens but has no effect after stop is called.
    clat.interfaceRemoved(CLAT_PREFIX + MOBILE_IFNAME);
    networkCallback.assertNoCallback();
    verifyNoMoreInteractions(mMockNetd);
    verifyNoMoreInteractions(mMockDnsResolver);
    reset(mMockNetd);
    reset(mMockDnsResolver);
    // Stopping prefix discovery causes netd to tell us that the NAT64 prefix is gone.
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, false, /* added */
    kNat64PrefixString, 96);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getNat64Prefix() == null, mCellNetworkAgent);
    // Remove IPv4 address and expect prefix discovery and clatd to be started again.
    cellLp.removeLinkAddress(myIpv4);
    cellLp.removeRoute(new RouteInfo(myIpv4, null, MOBILE_IFNAME));
    cellLp.removeDnsServer(InetAddress.getByName("8.8.8.8"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockDnsResolver, times(1)).startPrefix64Discovery(cellNetId);
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, true, /* added */
    kNat64PrefixString, 96);
    networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    verify(mMockNetd, times(1)).clatdStart(MOBILE_IFNAME, kNat64Prefix.toString());
    // Clat iface comes up. Expect stacked link to be added.
    clat.interfaceLinkStateChanged(CLAT_PREFIX + MOBILE_IFNAME, true);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getStackedLinks().size() == 1 && lp.getNat64Prefix() != null, mCellNetworkAgent);
    // NAT64 prefix is removed. Expect that clat is stopped.
    mService.mNetdEventCallback.onNat64PrefixEvent(cellNetId, false, /* added */
    kNat64PrefixString, 96);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getStackedLinks().size() == 0 && lp.getNat64Prefix() == null, mCellNetworkAgent);
    verify(mMockNetd, times(1)).clatdStop(MOBILE_IFNAME);
    networkCallback.expectLinkPropertiesLike((lp) -> lp.getStackedLinks().size() == 0, mCellNetworkAgent);
    // Clean up.
    mCellNetworkAgent.disconnect();
    networkCallback.expectCallback(CallbackState.LOST, mCellNetworkAgent);
    networkCallback.assertNoCallback();
    mCm.unregisterNetworkCallback(networkCallback);
}
#end_block

#method_before
public void add(int type, NetworkAgentInfo nai) {
    if (!isTypeSupported(type)) {
        // Invalid network type.
        return;
    }
    if (VDBG)
        log("Adding agent " + nai + " for legacy network type " + type);
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list.contains(nai)) {
        return;
    }
    synchronized (mTypeLists) {
        list.add(nai);
    }
    // Send a broadcast if this is the first network of its type or if it's the default.
    final boolean isDefaultNetwork = isDefaultNetwork(nai);
    if ((list.size() == 1) || isDefaultNetwork) {
        maybeLogBroadcast(nai, DetailedState.CONNECTED, type, isDefaultNetwork);
        sendLegacyNetworkBroadcast(nai, DetailedState.CONNECTED, type);
    }
}
#method_after
public void add(int type, NetworkAgentInfo nai) {
    if (!isTypeSupported(type)) {
        // Invalid network type.
        return;
    }
    if (VDBG)
        log("Adding agent " + nai + " for legacy network type " + type);
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list.contains(nai)) {
        return;
    }
    synchronized (mTypeLists) {
        list.add(nai);
    }
    // Send a broadcast if this is the first network of its type or if it's the default.
    final boolean isDefaultNetwork = mService.isDefaultNetwork(nai);
    if ((list.size() == 1) || isDefaultNetwork) {
        maybeLogBroadcast(nai, DetailedState.CONNECTED, type, isDefaultNetwork);
        mService.sendLegacyNetworkBroadcast(nai, DetailedState.CONNECTED, type);
    }
}
#end_block

#method_before
public void remove(int type, NetworkAgentInfo nai, boolean wasDefault) {
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list == null || list.isEmpty()) {
        return;
    }
    final boolean wasFirstNetwork = list.get(0).equals(nai);
    synchronized (mTypeLists) {
        if (!list.remove(nai)) {
            return;
        }
    }
    final DetailedState state = DetailedState.DISCONNECTED;
    if (wasFirstNetwork || wasDefault) {
        maybeLogBroadcast(nai, state, type, wasDefault);
        sendLegacyNetworkBroadcast(nai, state, type);
    }
    if (!list.isEmpty() && wasFirstNetwork) {
        if (DBG)
            log("Other network available for type " + type + ", sending connected broadcast");
        final NetworkAgentInfo replacement = list.get(0);
        maybeLogBroadcast(replacement, state, type, isDefaultNetwork(replacement));
        sendLegacyNetworkBroadcast(replacement, state, type);
    }
}
#method_after
public void remove(int type, NetworkAgentInfo nai, boolean wasDefault) {
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list == null || list.isEmpty()) {
        return;
    }
    final boolean wasFirstNetwork = list.get(0).equals(nai);
    synchronized (mTypeLists) {
        if (!list.remove(nai)) {
            return;
        }
    }
    final DetailedState state = DetailedState.DISCONNECTED;
    if (wasFirstNetwork || wasDefault) {
        maybeLogBroadcast(nai, state, type, wasDefault);
        mService.sendLegacyNetworkBroadcast(nai, state, type);
    }
    if (!list.isEmpty() && wasFirstNetwork) {
        if (DBG)
            log("Other network available for type " + type + ", sending connected broadcast");
        final NetworkAgentInfo replacement = list.get(0);
        maybeLogBroadcast(replacement, state, type, mService.isDefaultNetwork(replacement));
        mService.sendLegacyNetworkBroadcast(replacement, state, type);
    }
}
#end_block

#method_before
// send out another legacy broadcast - currently only used for suspend/unsuspend
public void update(NetworkAgentInfo nai) {
    final boolean isDefault = isDefaultNetwork(nai);
    final DetailedState state = nai.networkInfo.getDetailedState();
    for (int type = 0; type < mTypeLists.length; type++) {
        final ArrayList<NetworkAgentInfo> list = mTypeLists[type];
        final boolean contains = (list != null && list.contains(nai));
        final boolean isFirst = contains && (nai == list.get(0));
        if (isFirst || contains && isDefault) {
            maybeLogBroadcast(nai, state, type, isDefault);
            sendLegacyNetworkBroadcast(nai, state, type);
        }
    }
}
#method_after
// send out another legacy broadcast - currently only used for suspend/unsuspend
public void update(NetworkAgentInfo nai) {
    final boolean isDefault = mService.isDefaultNetwork(nai);
    final DetailedState state = nai.networkInfo.getDetailedState();
    for (int type = 0; type < mTypeLists.length; type++) {
        final ArrayList<NetworkAgentInfo> list = mTypeLists[type];
        final boolean contains = (list != null && list.contains(nai));
        final boolean isFirst = contains && (nai == list.get(0));
        if (isFirst || contains && isDefault) {
            maybeLogBroadcast(nai, state, type, isDefault);
            mService.sendLegacyNetworkBroadcast(nai, state, type);
        }
    }
}
#end_block

#method_before
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // Clear all notifications of this network.
    mNotifier.clearNotification(nai.network.netId);
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, SocketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.clatd.update();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, null);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNetd.networkDestroy(nai.network.netId);
            mDnsResolver.destroyNetworkCache(nai.network.netId);
        } catch (RemoteException | ServiceSpecificException e) {
            loge("Exception destroying network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#method_after
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // Clear all notifications of this network.
    mNotifier.clearNotification(nai.network.netId);
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, SocketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.clatd.update();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, null);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // Tell netd to clean up the configuration for this network
        // (routing rules, DNS, etc).
        // This may be slow as it requires a lot of netd shelling out to ip and
        // ip[6]tables to flush routes and remove the incoming packet mark rule, so do it
        // after we've rematched networks with requests which should make a potential
        // fallback network the default or requested a new network from the
        // NetworkFactories, so network traffic isn't interrupted for an unnecessarily
        // long time.
        destroyNativeNetwork(nai);
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#end_block

#method_before
private boolean isDefaultNetwork(NetworkAgentInfo nai) {
    return nai == getDefaultNetwork();
}
#method_after
@VisibleForTesting
protected boolean isDefaultNetwork(NetworkAgentInfo nai) {
    return nai == getDefaultNetwork();
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.networkCreateVpn(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.networkCreatePhysical(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
            mDnsResolver.createNetworkCache(networkAgent.network.netId);
        } catch (RemoteException | ServiceSpecificException e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        // NetworkMonitor, otherwise NetworkMonitor cannot determine if validation is required.
        synchronized (networkAgent) {
            networkAgent.setNetworkCapabilities(networkAgent.networkCapabilities);
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            if (networkAgent.networkMisc.acceptPartialConnectivity) {
                networkAgent.networkMonitor().setAcceptPartialConnectivity();
            }
            networkAgent.networkMonitor().notifyNetworkConnected(networkAgent.linkProperties, networkAgent.networkCapabilities);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        if (networkAgent.isVPN()) {
            updateAllVpnsCapabilities();
        }
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        if (!createNativeNetwork(networkAgent))
            return;
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        // NetworkMonitor, otherwise NetworkMonitor cannot determine if validation is required.
        synchronized (networkAgent) {
            networkAgent.setNetworkCapabilities(networkAgent.networkCapabilities);
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            if (networkAgent.networkMisc.acceptPartialConnectivity) {
                networkAgent.networkMonitor().setAcceptPartialConnectivity();
            }
            networkAgent.networkMonitor().notifyNetworkConnected(networkAgent.linkProperties, networkAgent.networkCapabilities);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        if (networkAgent.isVPN()) {
            updateAllVpnsCapabilities();
        }
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
private void sendLegacyNetworkBroadcast(NetworkAgentInfo nai, DetailedState state, int type) {
    // The NetworkInfo we actually send out has no bearing on the real
    // state of affairs. For example, if the default connection is mobile,
    // and a request for HIPRI has just gone away, we need to pretend that
    // HIPRI has just disconnected. So we need to set the type to HIPRI and
    // the state to DISCONNECTED, even though the network is of type MOBILE
    // and is still connected.
    NetworkInfo info = new NetworkInfo(nai.networkInfo);
    info.setType(type);
    if (state != DetailedState.DISCONNECTED) {
        info.setDetailedState(state, null, info.getExtraInfo());
        sendConnectedBroadcast(info);
    } else {
        info.setDetailedState(state, info.getReason(), info.getExtraInfo());
        Intent intent = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO, info);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, info.getType());
        if (info.isFailover()) {
            intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER, true);
            nai.networkInfo.setFailover(false);
        }
        if (info.getReason() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_REASON, info.getReason());
        }
        if (info.getExtraInfo() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO, info.getExtraInfo());
        }
        NetworkAgentInfo newDefaultAgent = null;
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            newDefaultAgent = getDefaultNetwork();
            if (newDefaultAgent != null) {
                intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO, newDefaultAgent.networkInfo);
            } else {
                intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, true);
            }
        }
        intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION, mDefaultInetConditionPublished);
        sendStickyBroadcast(intent);
        if (newDefaultAgent != null) {
            sendConnectedBroadcast(newDefaultAgent.networkInfo);
        }
    }
}
#method_after
@VisibleForTesting
protected void sendLegacyNetworkBroadcast(NetworkAgentInfo nai, DetailedState state, int type) {
    // The NetworkInfo we actually send out has no bearing on the real
    // state of affairs. For example, if the default connection is mobile,
    // and a request for HIPRI has just gone away, we need to pretend that
    // HIPRI has just disconnected. So we need to set the type to HIPRI and
    // the state to DISCONNECTED, even though the network is of type MOBILE
    // and is still connected.
    NetworkInfo info = new NetworkInfo(nai.networkInfo);
    info.setType(type);
    if (state != DetailedState.DISCONNECTED) {
        info.setDetailedState(state, null, info.getExtraInfo());
        sendConnectedBroadcast(info);
    } else {
        info.setDetailedState(state, info.getReason(), info.getExtraInfo());
        Intent intent = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO, info);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, info.getType());
        if (info.isFailover()) {
            intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER, true);
            nai.networkInfo.setFailover(false);
        }
        if (info.getReason() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_REASON, info.getReason());
        }
        if (info.getExtraInfo() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO, info.getExtraInfo());
        }
        NetworkAgentInfo newDefaultAgent = null;
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            newDefaultAgent = getDefaultNetwork();
            if (newDefaultAgent != null) {
                intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO, newDefaultAgent.networkInfo);
            } else {
                intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, true);
            }
        }
        intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION, mDefaultInetConditionPublished);
        sendStickyBroadcast(intent);
        if (newDefaultAgent != null) {
            sendConnectedBroadcast(newDefaultAgent.networkInfo);
        }
    }
}
#end_block

#method_before
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    final String[] assignedServers = NetworkUtils.makeStrings(lp.getDnsServers());
    final String[] domainStrs = getDomainStrings(lp.getDomains());
    updateParametersSettings();
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do not attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.getOrDefault(netId, PRIVATE_DNS_OFF);
    final boolean useTls = privateDnsCfg.useTls;
    final boolean strictMode = privateDnsCfg.inStrictMode();
    final String tlsHostname = strictMode ? privateDnsCfg.hostname : "";
    final String[] tlsServers = strictMode ? NetworkUtils.makeStrings(Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList())) : // Opportunistic
    useTls ? // Opportunistic
    assignedServers : // Off
    new String[0];
    // resolver config when private DNS is in opportunistic or strict mode.
    if (useTls) {
        if (!mPrivateDnsValidationMap.containsKey(netId)) {
            mPrivateDnsValidationMap.put(netId, new PrivateDnsValidationStatuses());
        }
        mPrivateDnsValidationMap.get(netId).updateTrackedDnses(tlsServers, tlsHostname);
    } else {
        mPrivateDnsValidationMap.remove(netId);
    }
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %s, %s, %s)", netId, Arrays.toString(assignedServers), Arrays.toString(domainStrs), Arrays.toString(params), tlsHostname, Arrays.toString(tlsServers)));
    final String[] tlsFingerprints = new String[0];
    try {
        mDnsResolver.setResolverConfiguration(netId, assignedServers, domainStrs, params, tlsHostname, tlsServers, tlsFingerprints);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#method_after
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    updateParametersSettings();
    final ResolverParamsParcel paramsParcel = new ResolverParamsParcel();
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do not attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.getOrDefault(netId, PRIVATE_DNS_OFF);
    final boolean useTls = privateDnsCfg.useTls;
    final boolean strictMode = privateDnsCfg.inStrictMode();
    paramsParcel.netId = netId;
    paramsParcel.sampleValiditySeconds = mSampleValidity;
    paramsParcel.successThreshold = mSuccessThreshold;
    paramsParcel.minSamples = mMinSamples;
    paramsParcel.maxSamples = mMaxSamples;
    paramsParcel.servers = NetworkUtils.makeStrings(lp.getDnsServers());
    paramsParcel.domains = getDomainStrings(lp.getDomains());
    paramsParcel.tlsName = strictMode ? privateDnsCfg.hostname : "";
    paramsParcel.tlsServers = strictMode ? NetworkUtils.makeStrings(Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList())) : // Opportunistic
    useTls ? // Opportunistic
    paramsParcel.servers : // Off
    new String[0];
    paramsParcel.tlsFingerprints = new String[0];
    // resolver config when private DNS is in opportunistic or strict mode.
    if (useTls) {
        if (!mPrivateDnsValidationMap.containsKey(netId)) {
            mPrivateDnsValidationMap.put(netId, new PrivateDnsValidationStatuses());
        }
        mPrivateDnsValidationMap.get(netId).updateTrackedDnses(paramsParcel.tlsServers, paramsParcel.tlsName);
    } else {
        mPrivateDnsValidationMap.remove(netId);
    }
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %d, %d, %d, %d, " + "%d, %d, %s, %s)", paramsParcel.netId, Arrays.toString(paramsParcel.servers), Arrays.toString(paramsParcel.domains), paramsParcel.sampleValiditySeconds, paramsParcel.successThreshold, paramsParcel.minSamples, paramsParcel.maxSamples, paramsParcel.baseTimeoutMsec, paramsParcel.retryCount, paramsParcel.tlsName, Arrays.toString(paramsParcel.tlsServers)));
    try {
        mDnsResolver.setResolverConfiguration(paramsParcel);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#end_block

#method_before
@Test
public void takePicture_withBufferFormatRaw10() throws InterruptedException, CameraAccessException {
    CameraCharacteristics cameraCharacteristics = CameraUtil.getCameraManager().getCameraCharacteristics(mCameraId);
    StreamConfigurationMap map = cameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    Size[] resolutions = map.getOutputSizes(ImageFormat.RAW10);
    Size resolution = resolutions[0];
    ImageCaptureConfig config = new ImageCaptureConfig.Builder().setBufferFormat(ImageFormat.RAW10).build();
    ImageCapture useCase = new ImageCapture(config);
    Map<String, Size> suggestedResolutionMap = new HashMap<>();
    suggestedResolutionMap.put(mCameraId, resolution);
    useCase.updateSuggestedResolution(suggestedResolutionMap);
    CameraUtil.openCameraWithUseCase(mCameraId, mCamera, useCase, mRepeatingUseCase);
    useCase.addStateChangeListener(mCamera);
    useCase.takePicture(mOnImageCapturedListener);
    // Wait for the signal that the image has been saved.
    mSemaphore.acquire();
    assertThat(mCapturedImage.getFormat()).isEqualTo(ImageFormat.RAW10);
}
#method_after
@Test
public void takePicture_withBufferFormatRaw10() throws InterruptedException, CameraAccessException {
    CameraCharacteristics cameraCharacteristics = CameraUtil.getCameraManager().getCameraCharacteristics(mCameraId);
    StreamConfigurationMap map = cameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
    Size[] resolutions = map.getOutputSizes(ImageFormat.RAW10);
    // Ignore this tests on devices that do not support RAW10 image format.
    Assume.assumeTrue(resolutions != null);
    Assume.assumeTrue(resolutions.length > 0);
    Size resolution = resolutions[0];
    ImageCaptureConfig config = new ImageCaptureConfig.Builder().setBufferFormat(ImageFormat.RAW10).build();
    ImageCapture useCase = new ImageCapture(config);
    Map<String, Size> suggestedResolutionMap = new HashMap<>();
    suggestedResolutionMap.put(mCameraId, resolution);
    useCase.updateSuggestedResolution(suggestedResolutionMap);
    CameraUtil.openCameraWithUseCase(mCameraId, mCamera, useCase, mRepeatingUseCase);
    useCase.addStateChangeListener(mCamera);
    useCase.takePicture(mOnImageCapturedListener);
    // Wait for the signal that the image has been saved.
    mSemaphore.acquire();
    assertThat(mCapturedImage.getFormat()).isEqualTo(ImageFormat.RAW10);
}
#end_block

#method_before
ListenableFuture<Void> issueTakePicture() {
    final List<ListenableFuture<Void>> futureList = new ArrayList<>();
    for (final CaptureStage captureStage : mCaptureBundle.getCaptureStages()) {
        final CaptureConfig.Builder builder = new CaptureConfig.Builder();
        builder.addAllCameraCaptureCallbacks(mSessionConfigBuilder.getSingleCameraCaptureCallbacks());
        builder.addSurface(new ImmediateSurface(mImageReader.getSurface()));
        builder.setTemplateType(CameraDevice.TEMPLATE_STILL_CAPTURE);
        applyPixelHdrPlusChangeForCaptureMode(mCaptureMode, builder);
        builder.addImplementationOptions(captureStage.getCaptureConfig().getImplementationOptions());
        builder.setTag(captureStage.getCaptureConfig().getTag());
        builder.addCameraCaptureCallback(mMetadataMatchingCaptureCallback);
        final CameraControl cameraControl = getCurrentCameraControl();
        ListenableFuture<Void> future = CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

            @Override
            public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
                CameraCaptureCallback completerCallback = new CameraCaptureCallback() {

                    @Override
                    public void onCaptureCompleted(@NonNull CameraCaptureResult result) {
                        completer.set(null);
                    }

                    @Override
                    public void onCaptureFailed(@NonNull CameraCaptureFailure failure) {
                        Log.e(TAG, "capture picture get onCaptureFailed with reason " + failure.getReason());
                        completer.set(null);
                    }
                };
                builder.addCameraCaptureCallback(completerCallback);
                cameraControl.submitSingleRequest(builder.build());
                return "issueTakePicture[stage=" + captureStage.getId() + "]";
            }
        });
        futureList.add(future);
    }
    return CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

        @Override
        public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
            ListenableFuture<List<Void>> combinedFuture = Futures.successfulAsList(futureList);
            Futures.addCallback(combinedFuture, new FutureCallback<List<Void>>() {

                @Override
                public void onSuccess(@Nullable List<Void> result) {
                    completer.set(null);
                }

                @Override
                public void onFailure(Throwable t) {
                    completer.setException(t);
                }
            }, CameraXExecutors.directExecutor());
            return "issueTakePicture";
        }
    });
}
#method_after
ListenableFuture<Void> issueTakePicture() {
    final List<ListenableFuture<Void>> futureList = new ArrayList<>();
    final List<CaptureConfig> captureConfigs = new ArrayList<>();
    for (final CaptureStage captureStage : mCaptureBundle.getCaptureStages()) {
        final CaptureConfig.Builder builder = new CaptureConfig.Builder();
        builder.addAllCameraCaptureCallbacks(mSessionConfigBuilder.getSingleCameraCaptureCallbacks());
        builder.addSurface(new ImmediateSurface(mImageReader.getSurface()));
        builder.setTemplateType(CameraDevice.TEMPLATE_STILL_CAPTURE);
        applyPixelHdrPlusChangeForCaptureMode(mCaptureMode, builder);
        builder.addImplementationOptions(captureStage.getCaptureConfig().getImplementationOptions());
        builder.setTag(captureStage.getCaptureConfig().getTag());
        builder.addCameraCaptureCallback(mMetadataMatchingCaptureCallback);
        ListenableFuture<Void> future = CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

            @Override
            public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
                CameraCaptureCallback completerCallback = new CameraCaptureCallback() {

                    @Override
                    public void onCaptureCompleted(@NonNull CameraCaptureResult result) {
                        completer.set(null);
                    }

                    @Override
                    public void onCaptureFailed(@NonNull CameraCaptureFailure failure) {
                        Log.e(TAG, "capture picture get onCaptureFailed with reason " + failure.getReason());
                        completer.set(null);
                    }
                };
                builder.addCameraCaptureCallback(completerCallback);
                captureConfigs.add(builder.build());
                return "issueTakePicture[stage=" + captureStage.getId() + "]";
            }
        });
        futureList.add(future);
    }
    getCurrentCameraControl().submitCaptureRequests(captureConfigs);
    return CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

        @Override
        public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
            ListenableFuture<List<Void>> combinedFuture = Futures.successfulAsList(futureList);
            Futures.addCallback(combinedFuture, new FutureCallback<List<Void>>() {

                @Override
                public void onSuccess(@Nullable List<Void> result) {
                    completer.set(null);
                }

                @Override
                public void onFailure(Throwable t) {
                    completer.setException(t);
                }
            }, CameraXExecutors.directExecutor());
            return "issueTakePicture";
        }
    });
}
#end_block

#method_before
private synchronized void onGetSlotStatusDone(AsyncResult ar) {
    if (!mIsSlotStatusSupported) {
        if (VDBG)
            log("onGetSlotStatusDone: ignoring since mIsSlotStatusSupported is false");
        return;
    }
    Throwable e = ar.exception;
    if (e != null) {
        String logStr;
        if (!(e instanceof CommandException) || ((CommandException) e).getCommandError() != CommandException.Error.REQUEST_NOT_SUPPORTED) {
            // this is not expected; there should be no exception other than
            // REQUEST_NOT_SUPPORTED
            logStr = "Unexpected error getting slot status: " + ar.exception;
            Rlog.e(LOG_TAG, logStr);
            sLocalLog.log(logStr);
        } else {
            // REQUEST_NOT_SUPPORTED
            logStr = "onGetSlotStatusDone: request not supported; marking " + "mIsSlotStatusSupported to false";
            log(logStr);
            sLocalLog.log(logStr);
            mIsSlotStatusSupported = false;
        }
        return;
    }
    ArrayList<IccSlotStatus> status = (ArrayList<IccSlotStatus>) ar.result;
    if (!slotStatusChanged(status)) {
        log("onGetSlotStatusDone: No change in slot status");
        return;
    }
    sLastSlotStatus = status;
    int numActiveSlots = 0;
    boolean isDefaultEuiccCardIdSet = false;
    boolean anyEuiccIsActive = false;
    boolean hasEuicc = false;
    boolean hasBuiltInEuicc = false;
    for (int i = 0; i < status.size(); i++) {
        IccSlotStatus iss = status.get(i);
        boolean isActive = (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE);
        if (isActive) {
            numActiveSlots++;
            // sanity check: logicalSlotIndex should be valid for an active slot
            if (!isValidPhoneIndex(iss.logicalSlotIndex)) {
                Rlog.e(LOG_TAG, "Skipping slot " + i + " as phone " + iss.logicalSlotIndex + " is not available to communicate with this slot");
            } else {
                mPhoneIdToSlotId[iss.logicalSlotIndex] = i;
            }
        }
        if (mUiccSlots[i] == null) {
            if (VDBG) {
                log("Creating mUiccSlot[" + i + "]; mUiccSlots.length = " + mUiccSlots.length);
            }
            mUiccSlots[i] = new UiccSlot(mContext, isActive);
        }
        if (!isValidPhoneIndex(iss.logicalSlotIndex)) {
            mUiccSlots[i].update(null, iss, i);
        } else {
            mUiccSlots[i].update(isActive ? mCis[iss.logicalSlotIndex] : null, iss, i);
        }
        if (mUiccSlots[i].isEuicc()) {
            hasEuicc = true;
            if (isActive) {
                anyEuiccIsActive = true;
            }
            if (!mUiccSlots[i].isRemovable()) {
                hasBuiltInEuicc = true;
            }
            String eid = iss.eid;
            if (TextUtils.isEmpty(eid)) {
                // iss.eid is not populated on HAL<1.4
                continue;
            }
            addCardId(eid);
            // with the lowest slot index.
            if (!mUiccSlots[i].isRemovable() && !isDefaultEuiccCardIdSet) {
                isDefaultEuiccCardIdSet = true;
                mDefaultEuiccCardId = convertToPublicCardId(eid);
                log("Using eid=" + eid + " in slot=" + i + " to set mDefaultEuiccCardId=" + mDefaultEuiccCardId);
            }
        }
    }
    if (hasEuicc && !anyEuiccIsActive && !isDefaultEuiccCardIdSet) {
        log("onGetSlotStatusDone: setting TEMPORARILY_UNSUPPORTED_CARD_ID");
        isDefaultEuiccCardIdSet = true;
        mDefaultEuiccCardId = TEMPORARILY_UNSUPPORTED_CARD_ID;
    }
    if (!hasBuiltInEuicc) {
        // default
        for (int i = 0; i < status.size(); i++) {
            if (mUiccSlots[i].isEuicc() && mUiccSlots[i].isRemovable()) {
                isDefaultEuiccCardIdSet = true;
                IccSlotStatus iss = status.get(i);
                mDefaultEuiccCardId = convertToPublicCardId(iss.eid);
                log("Using eid=" + iss.eid + " from removable eUICC in slot=" + i + " to set mDefaultEuiccCardId=" + mDefaultEuiccCardId);
            }
        }
    }
    if (!isDefaultEuiccCardIdSet) {
        // no eUICCs at all
        mDefaultEuiccCardId = UNINITIALIZED_CARD_ID;
    }
    if (VDBG)
        logPhoneIdToSlotIdMapping();
    // sanity check: number of active slots should be valid
    if (numActiveSlots != mPhoneIdToSlotId.length) {
        Rlog.e(LOG_TAG, "Number of active slots " + numActiveSlots + " does not match the number of Phones" + mPhoneIdToSlotId.length);
    }
    // sanity check: slotIds should be unique in mPhoneIdToSlotId
    Set<Integer> slotIds = new HashSet<>();
    for (int slotId : mPhoneIdToSlotId) {
        if (slotIds.contains(slotId)) {
            throw new RuntimeException("slotId " + slotId + " mapped to multiple phoneIds");
        }
        slotIds.add(slotId);
    }
    // broadcast slot status changed
    Intent intent = new Intent(TelephonyManager.ACTION_SIM_SLOT_STATUS_CHANGED);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    mContext.sendBroadcast(intent, android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
}
#method_after
private synchronized void onGetSlotStatusDone(AsyncResult ar) {
    if (!mIsSlotStatusSupported) {
        if (VDBG)
            log("onGetSlotStatusDone: ignoring since mIsSlotStatusSupported is false");
        return;
    }
    Throwable e = ar.exception;
    if (e != null) {
        String logStr;
        if (!(e instanceof CommandException) || ((CommandException) e).getCommandError() != CommandException.Error.REQUEST_NOT_SUPPORTED) {
            // this is not expected; there should be no exception other than
            // REQUEST_NOT_SUPPORTED
            logStr = "Unexpected error getting slot status: " + ar.exception;
            Rlog.e(LOG_TAG, logStr);
            sLocalLog.log(logStr);
        } else {
            // REQUEST_NOT_SUPPORTED
            logStr = "onGetSlotStatusDone: request not supported; marking " + "mIsSlotStatusSupported to false";
            log(logStr);
            sLocalLog.log(logStr);
            mIsSlotStatusSupported = false;
        }
        return;
    }
    ArrayList<IccSlotStatus> status = (ArrayList<IccSlotStatus>) ar.result;
    if (!slotStatusChanged(status)) {
        log("onGetSlotStatusDone: No change in slot status");
        return;
    }
    sLastSlotStatus = status;
    int numActiveSlots = 0;
    boolean isDefaultEuiccCardIdSet = false;
    boolean anyEuiccIsActive = false;
    for (int i = 0; i < status.size(); i++) {
        IccSlotStatus iss = status.get(i);
        boolean isActive = (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE);
        if (isActive) {
            numActiveSlots++;
            // sanity check: logicalSlotIndex should be valid for an active slot
            if (!isValidPhoneIndex(iss.logicalSlotIndex)) {
                Rlog.e(LOG_TAG, "Skipping slot " + i + " as phone " + iss.logicalSlotIndex + " is not available to communicate with this slot");
            } else {
                mPhoneIdToSlotId[iss.logicalSlotIndex] = i;
            }
        }
        if (mUiccSlots[i] == null) {
            if (VDBG) {
                log("Creating mUiccSlot[" + i + "]; mUiccSlots.length = " + mUiccSlots.length);
            }
            mUiccSlots[i] = new UiccSlot(mContext, isActive);
        }
        if (!isValidPhoneIndex(iss.logicalSlotIndex)) {
            mUiccSlots[i].update(null, iss, i);
        } else {
            mUiccSlots[i].update(isActive ? mCis[iss.logicalSlotIndex] : null, iss, i);
        }
        if (mUiccSlots[i].isEuicc()) {
            if (isActive) {
                anyEuiccIsActive = true;
            }
            String eid = iss.eid;
            if (TextUtils.isEmpty(eid)) {
                // iss.eid is not populated on HAL<1.4
                continue;
            }
            addCardId(eid);
            // with the lowest slot index.
            if (!mUiccSlots[i].isRemovable() && !isDefaultEuiccCardIdSet) {
                isDefaultEuiccCardIdSet = true;
                mDefaultEuiccCardId = convertToPublicCardId(eid);
                String logStr = "Using eid=" + eid + " in slot=" + i + " to set mDefaultEuiccCardId=" + mDefaultEuiccCardId;
                sLocalLog.log(logStr);
                log(logStr);
            }
        }
    }
    if (mHasBuiltInEuicc && !anyEuiccIsActive && !isDefaultEuiccCardIdSet) {
        log("onGetSlotStatusDone: setting TEMPORARILY_UNSUPPORTED_CARD_ID");
        isDefaultEuiccCardIdSet = true;
        mDefaultEuiccCardId = TEMPORARILY_UNSUPPORTED_CARD_ID;
    }
    if (!mHasBuiltInEuicc && !isDefaultEuiccCardIdSet) {
        // SlotStatus is only for HAL >= 1.2
        for (int i = 0; i < status.size(); i++) {
            if (mUiccSlots[i].isEuicc()) {
                isDefaultEuiccCardIdSet = true;
                String eid = status.get(i).eid;
                if (!TextUtils.isEmpty(eid)) {
                    mDefaultEuiccCardId = convertToPublicCardId(eid);
                    log("Using eid=" + eid + " from removable eUICC in slot=" + i + " to set mDefaultEuiccCardId=" + mDefaultEuiccCardId);
                    break;
                }
            }
        }
    }
    if (!isDefaultEuiccCardIdSet) {
        // no eUICCs at all
        mDefaultEuiccCardId = UNINITIALIZED_CARD_ID;
    }
    if (VDBG)
        logPhoneIdToSlotIdMapping();
    // sanity check: number of active slots should be valid
    if (numActiveSlots != mPhoneIdToSlotId.length) {
        Rlog.e(LOG_TAG, "Number of active slots " + numActiveSlots + " does not match the number of Phones" + mPhoneIdToSlotId.length);
    }
    // sanity check: slotIds should be unique in mPhoneIdToSlotId
    Set<Integer> slotIds = new HashSet<>();
    for (int slotId : mPhoneIdToSlotId) {
        if (slotIds.contains(slotId)) {
            throw new RuntimeException("slotId " + slotId + " mapped to multiple phoneIds");
        }
        slotIds.add(slotId);
    }
    // broadcast slot status changed
    Intent intent = new Intent(TelephonyManager.ACTION_SIM_SLOT_STATUS_CHANGED);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    mContext.sendBroadcast(intent, android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
}
#end_block

#method_before
private void onEidReady(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "onEidReady: exception: " + ar.exception);
        return;
    }
    if (!isValidPhoneIndex(index)) {
        Rlog.e(LOG_TAG, "onEidReady: invalid index: " + index);
        return;
    }
    int slotId = mPhoneIdToSlotId[index];
    UiccCard card = mUiccSlots[slotId].getUiccCard();
    if (card == null) {
        Rlog.e(LOG_TAG, "onEidReady: UiccCard in slot " + slotId + " is null");
        return;
    }
    // set mCardStrings and the defaultEuiccCardId using the now available EID
    String eid = ((EuiccCard) card).getEid();
    addCardId(eid);
    if (mDefaultEuiccCardId == UNINITIALIZED_CARD_ID || mDefaultEuiccCardId == TEMPORARILY_UNSUPPORTED_CARD_ID) {
        if (!mUiccSlots[slotId].isRemovable()) {
            mDefaultEuiccCardId = convertToPublicCardId(eid);
            log("onEidReady: eid=" + eid + " slot=" + slotId + " mDefaultEuiccCardId=" + mDefaultEuiccCardId);
        } else {
            // we only set a removable eUICC to the default if there are no non-removable eUICCs
            boolean hasNonRemovableEuicc = false;
            for (UiccSlot slot : mUiccSlots) {
                if (!slot.isRemovable() && slot.isEuicc()) {
                    hasNonRemovableEuicc = true;
                }
            }
            if (DBG)
                log("onEidReady: hasNonRemovableEuicc=" + hasNonRemovableEuicc);
            if (!hasNonRemovableEuicc) {
                mDefaultEuiccCardId = convertToPublicCardId(eid);
                log("onEidReady: eid=" + eid + " from removable eUICC in slot=" + slotId + " mDefaultEuiccCardId=" + mDefaultEuiccCardId);
            }
        }
    }
    ((EuiccCard) card).unregisterForEidReady(this);
}
#method_after
// for HAL 1.2-1.3 we register for EID ready, set mCardStrings and mDefaultEuiccCardId here.
// Note that if there are multiple eUICCs on HAL 1.2-1.3, the default eUICC is the one whose EID
private void onEidReady(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "onEidReady: exception: " + ar.exception);
        return;
    }
    if (!isValidPhoneIndex(index)) {
        Rlog.e(LOG_TAG, "onEidReady: invalid index: " + index);
        return;
    }
    int slotId = mPhoneIdToSlotId[index];
    EuiccCard card = (EuiccCard) mUiccSlots[slotId].getUiccCard();
    if (card == null) {
        Rlog.e(LOG_TAG, "onEidReady: UiccCard in slot " + slotId + " is null");
        return;
    }
    // set mCardStrings and the defaultEuiccCardId using the now available EID
    String eid = card.getEid();
    addCardId(eid);
    if (mDefaultEuiccCardId == UNINITIALIZED_CARD_ID || mDefaultEuiccCardId == TEMPORARILY_UNSUPPORTED_CARD_ID) {
        if (!mUiccSlots[slotId].isRemovable()) {
            mDefaultEuiccCardId = convertToPublicCardId(eid);
            String logStr = "onEidReady: eid=" + eid + " slot=" + slotId + " mDefaultEuiccCardId=" + mDefaultEuiccCardId;
            sLocalLog.log(logStr);
            log(logStr);
        } else if (!mHasBuiltInEuicc) {
            // we only set a removable eUICC to the default if there are no non-removable eUICCs
            mDefaultEuiccCardId = convertToPublicCardId(eid);
            String logStr = "onEidReady: eid=" + eid + " from removable eUICC in slot=" + slotId + " mDefaultEuiccCardId=" + mDefaultEuiccCardId;
            sLocalLog.log(logStr);
            log(logStr);
        }
    }
    card.unregisterForEidReady(this);
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("UiccController: " + this);
    pw.println(" mContext=" + mContext);
    pw.println(" mInstance=" + mInstance);
    pw.println(" mIccChangedRegistrants: size=" + mIccChangedRegistrants.size());
    for (int i = 0; i < mIccChangedRegistrants.size(); i++) {
        pw.println("  mIccChangedRegistrants[" + i + "]=" + ((Registrant) mIccChangedRegistrants.get(i)).getHandler());
    }
    pw.println();
    pw.flush();
    pw.println(" mIsCdmaSupported=" + isCdmaSupported(mContext));
    pw.println(" mUiccSlots: size=" + mUiccSlots.length);
    pw.println(" mCardStrings=" + mCardStrings);
    pw.println(" mDefaultEuiccCardId=" + mDefaultEuiccCardId);
    for (int i = 0; i < mUiccSlots.length; i++) {
        if (mUiccSlots[i] == null) {
            pw.println("  mUiccSlots[" + i + "]=null");
        } else {
            pw.println("  mUiccSlots[" + i + "]=" + mUiccSlots[i]);
            mUiccSlots[i].dump(fd, pw, args);
        }
    }
    pw.println(" sLocalLog= ");
    sLocalLog.dump(fd, pw, args);
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("UiccController: " + this);
    pw.println(" mContext=" + mContext);
    pw.println(" mInstance=" + mInstance);
    pw.println(" mIccChangedRegistrants: size=" + mIccChangedRegistrants.size());
    for (int i = 0; i < mIccChangedRegistrants.size(); i++) {
        pw.println("  mIccChangedRegistrants[" + i + "]=" + ((Registrant) mIccChangedRegistrants.get(i)).getHandler());
    }
    pw.println();
    pw.flush();
    pw.println(" mIsCdmaSupported=" + isCdmaSupported(mContext));
    pw.println(" mHasBuiltInEuicc=" + mHasBuiltInEuicc);
    pw.println(" mUiccSlots: size=" + mUiccSlots.length);
    pw.println(" mCardStrings=" + mCardStrings);
    pw.println(" mDefaultEuiccCardId=" + mDefaultEuiccCardId);
    for (int i = 0; i < mUiccSlots.length; i++) {
        if (mUiccSlots[i] == null) {
            pw.println("  mUiccSlots[" + i + "]=null");
        } else {
            pw.println("  mUiccSlots[" + i + "]=" + mUiccSlots[i]);
            mUiccSlots[i].dump(fd, pw, args);
        }
    }
    pw.println(" sLocalLog= ");
    sLocalLog.dump(fd, pw, args);
}
#end_block

#method_before
public void postponeEnterTransition(int milliSeconds) {
    ensureAnimationInfo().mEnterTransitionPostponed = true;
    new Handler().postDelayed(new Runnable() {

        @Override
        public void run() {
            startPostponedEnterTransition();
        }
    }, milliSeconds);
}
#method_after
public final void postponeEnterTransition(long duration, @NonNull TimeUnit timeUnit) {
    ensureAnimationInfo().mEnterTransitionPostponed = true;
    Handler handler;
    if (mFragmentManager != null) {
        handler = mFragmentManager.mHost.getHandler();
    } else {
        handler = new Handler(Looper.getMainLooper());
    }
    handler.postDelayed(new Runnable() {

        @Override
        public void run() {
            startPostponedEnterTransition();
        }
    }, timeUnit.toMillis(duration));
}
#end_block

#method_before
@WorkerThread
@NonNull
public RcsMessageQueryResult getMessages() throws RcsMessageStoreException {
    RcsMessageQueryParams queryParams = new RcsMessageQueryParams.Builder().setThread(this).build();
    return mRcsControllerCall.call(iRcs -> iRcs.getMessages(queryParams)).createRcsMessageQueryResult(mRcsControllerCall);
}
#method_after
@WorkerThread
@NonNull
public RcsMessageQueryResult getMessages() throws RcsMessageStoreException {
    RcsMessageQueryParams queryParams = new RcsMessageQueryParams.Builder().setThread(this).build();
    return new RcsMessageQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getMessages(queryParams)));
}
#end_block

#method_before
@WorkerThread
@NonNull
public RcsThreadQueryResult getRcsThreads(@Nullable RcsThreadQueryParams queryParameters) throws RcsMessageStoreException {
    return mRcsControllerCall.call(iRcs -> iRcs.getRcsThreads(queryParameters)).createRcsThreadQueryResult(mRcsControllerCall);
}
#method_after
@WorkerThread
@NonNull
public RcsThreadQueryResult getRcsThreads(@Nullable RcsThreadQueryParams queryParameters) throws RcsMessageStoreException {
    return new RcsThreadQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getRcsThreads(queryParameters)));
}
#end_block

#method_before
@WorkerThread
@NonNull
public RcsThreadQueryResult getRcsThreads(@NonNull RcsQueryContinuationToken continuationToken) throws RcsMessageStoreException {
    return mRcsControllerCall.call(iRcs -> iRcs.getRcsThreadsWithToken(continuationToken)).createRcsThreadQueryResult(mRcsControllerCall);
}
#method_after
@WorkerThread
@NonNull
public RcsThreadQueryResult getRcsThreads(@NonNull RcsQueryContinuationToken continuationToken) throws RcsMessageStoreException {
    return new RcsThreadQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getRcsThreadsWithToken(continuationToken)));
}
#end_block

#method_before
@WorkerThread
@NonNull
public RcsParticipantQueryResult getRcsParticipants(@Nullable RcsParticipantQueryParams queryParameters) throws RcsMessageStoreException {
    return mRcsControllerCall.call(iRcs -> iRcs.getParticipants(queryParameters)).createRcsParticipantQueryResult(mRcsControllerCall);
}
#method_after
@WorkerThread
@NonNull
public RcsParticipantQueryResult getRcsParticipants(@Nullable RcsParticipantQueryParams queryParameters) throws RcsMessageStoreException {
    return new RcsParticipantQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getParticipants(queryParameters)));
}
#end_block

#method_before
@WorkerThread
@NonNull
public RcsParticipantQueryResult getRcsParticipants(@NonNull RcsQueryContinuationToken continuationToken) throws RcsMessageStoreException {
    return mRcsControllerCall.call(iRcs -> iRcs.getParticipantsWithToken(continuationToken)).createRcsParticipantQueryResult(mRcsControllerCall);
}
#method_after
@WorkerThread
@NonNull
public RcsParticipantQueryResult getRcsParticipants(@NonNull RcsQueryContinuationToken continuationToken) throws RcsMessageStoreException {
    return new RcsParticipantQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getParticipantsWithToken(continuationToken)));
}
#end_block

#method_before
@WorkerThread
@NonNull
public RcsMessageQueryResult getRcsMessages(@Nullable RcsMessageQueryParams queryParams) throws RcsMessageStoreException {
    return mRcsControllerCall.call(iRcs -> iRcs.getMessages(queryParams)).createRcsMessageQueryResult(mRcsControllerCall);
}
#method_after
@WorkerThread
@NonNull
public RcsMessageQueryResult getRcsMessages(@Nullable RcsMessageQueryParams queryParams) throws RcsMessageStoreException {
    return new RcsMessageQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getMessages(queryParams)));
}
#end_block

#method_before
@WorkerThread
@NonNull
public RcsMessageQueryResult getRcsMessages(@NonNull RcsQueryContinuationToken continuationToken) throws RcsMessageStoreException {
    return mRcsControllerCall.call(iRcs -> iRcs.getMessagesWithToken(continuationToken)).createRcsMessageQueryResult(mRcsControllerCall);
}
#method_after
@WorkerThread
@NonNull
public RcsMessageQueryResult getRcsMessages(@NonNull RcsQueryContinuationToken continuationToken) throws RcsMessageStoreException {
    return new RcsMessageQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getMessagesWithToken(continuationToken)));
}
#end_block

#method_before
<R> R call(RcsServiceCall<R> serviceCall) throws RcsMessageStoreException {
    if (!isDefaultSmsApplication()) {
        throw new SecurityException("RCS message storage access is only available for the " + "default SMS application");
    }
    IRcs iRcs = IRcs.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_RCS_SERVICE));
    if (iRcs == null) {
        throw new RcsMessageStoreException("Could not connect to RCS storage service");
    }
    try {
        return serviceCall.methodOnIRcs(iRcs);
    } catch (RemoteException exception) {
        throw new RcsMessageStoreException(exception.getMessage());
    }
}
#method_after
<R> R call(RcsServiceCall<R> serviceCall) throws RcsMessageStoreException {
    IRcs iRcs = IRcs.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_RCS_SERVICE));
    if (iRcs == null) {
        throw new RcsMessageStoreException("Could not connect to RCS storage service");
    }
    try {
        return serviceCall.methodOnIRcs(iRcs);
    } catch (RemoteException exception) {
        throw new RcsMessageStoreException(exception.getMessage());
    }
}
#end_block

#method_before
@Nullable
public RcsQueryContinuationToken getContinuationToken() {
    return mContinuationToken;
}
#method_after
@Nullable
public RcsQueryContinuationToken getContinuationToken() {
    return mRcsParticipantQueryResultParcelable.mContinuationToken;
}
#end_block

#method_before
@NonNull
public List<RcsParticipant> getParticipants() {
    return mParticipants;
}
#method_after
@NonNull
public List<RcsParticipant> getParticipants() {
    return mRcsParticipantQueryResultParcelable.mParticipantIds.stream().map(participantId -> new RcsParticipant(mRcsControllerCall, participantId)).collect(Collectors.toList());
}
#end_block

#method_before
@Nullable
public RcsQueryContinuationToken getContinuationToken() {
    return mContinuationToken;
}
#method_after
@Nullable
public RcsQueryContinuationToken getContinuationToken() {
    return mRcsMessageQueryResultParcelable.mContinuationToken;
}
#end_block

#method_before
@NonNull
public List<RcsMessage> getMessages() {
    return mMessages;
}
#method_after
@NonNull
public List<RcsMessage> getMessages() {
    return mRcsMessageQueryResultParcelable.mMessageTypeIdPairs.stream().map(typeIdPair -> typeIdPair.getType() == MESSAGE_TYPE_INCOMING ? new RcsIncomingMessage(mRcsControllerCall, typeIdPair.getId()) : new RcsOutgoingMessage(mRcsControllerCall, typeIdPair.getId())).collect(Collectors.toList());
}
#end_block

#method_before
@WorkerThread
@NonNull
public Set<RcsParticipant> getParticipants() throws RcsMessageStoreException {
    RcsParticipantQueryParams queryParameters = new RcsParticipantQueryParams.Builder().setThread(this).build();
    RcsParticipantQueryResult queryResult = mRcsControllerCall.call(iRcs -> iRcs.getParticipants(queryParameters)).createRcsParticipantQueryResult(mRcsControllerCall);
    List<RcsParticipant> participantList = queryResult.getParticipants();
    Set<RcsParticipant> participantSet = new LinkedHashSet<>(participantList);
    return Collections.unmodifiableSet(participantSet);
}
#method_after
@WorkerThread
@NonNull
public Set<RcsParticipant> getParticipants() throws RcsMessageStoreException {
    RcsParticipantQueryParams queryParameters = new RcsParticipantQueryParams.Builder().setThread(this).build();
    RcsParticipantQueryResult queryResult = new RcsParticipantQueryResult(mRcsControllerCall, mRcsControllerCall.call(iRcs -> iRcs.getParticipants(queryParameters)));
    List<RcsParticipant> participantList = queryResult.getParticipants();
    Set<RcsParticipant> participantSet = new LinkedHashSet<>(participantList);
    return Collections.unmodifiableSet(participantSet);
}
#end_block

#method_before
@Nullable
public RcsQueryContinuationToken getContinuationToken() {
    return mContinuationToken;
}
#method_after
@Nullable
public RcsQueryContinuationToken getContinuationToken() {
    return mRcsThreadQueryResultParcelable.mContinuationToken;
}
#end_block

#method_before
@NonNull
public List<RcsThread> getThreads() {
    return mRcsThreads;
}
#method_after
@NonNull
public List<RcsThread> getThreads() {
    return mRcsThreadQueryResultParcelable.mRcsThreadIds.stream().map(typeIdPair -> typeIdPair.getType() == THREAD_TYPE_1_TO_1 ? new Rcs1To1Thread(mRcsControllerCall, typeIdPair.getId()) : new RcsGroupThread(mRcsControllerCall, typeIdPair.getId())).collect(Collectors.toList());
}
#end_block

#method_before
void onConnectedNotLocked(IMediaSession sessionBinder, final SessionCommandGroup allowedCommands, final int playerState, final MediaItem currentMediaItem, final long positionEventTimeMs, final long positionMs, final float playbackSpeed, final long bufferedPositionMs, final PlaybackInfo info, final int repeatMode, final int shuffleMode, final List<MediaItem> playlist, final PendingIntent sessionActivity, final int currentMediaItemIndex, final int previousMediaItemIndex, final int nextMediaItemIndex, final Bundle tokenExtras, final VideoSize videoSize) {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked sessionBinder=" + sessionBinder + ", allowedCommands=" + allowedCommands);
    }
    // 'close' is used in try-finally
    boolean close = false;
    try {
        if (sessionBinder == null || allowedCommands == null) {
            // Connection rejected.
            close = true;
            return;
        }
        synchronized (mLock) {
            if (mIsReleased) {
                return;
            }
            if (mISession != null) {
                Log.e(TAG, "Cannot be notified about the connection result many times." + " Probably a bug or malicious app.");
                close = true;
                return;
            }
            mAllowedCommands = allowedCommands;
            mPlayerState = playerState;
            mCurrentMediaItem = currentMediaItem;
            mPositionEventTimeMs = positionEventTimeMs;
            mPositionMs = positionMs;
            mPlaybackSpeed = playbackSpeed;
            mBufferedPositionMs = bufferedPositionMs;
            mPlaybackInfo = info;
            mRepeatMode = repeatMode;
            mShuffleMode = shuffleMode;
            mPlaylist = playlist;
            mSessionActivity = sessionActivity;
            mISession = sessionBinder;
            mCurrentMediaItemIndex = currentMediaItemIndex;
            mPreviousMediaItemIndex = previousMediaItemIndex;
            mNextMediaItemIndex = nextMediaItemIndex;
            mVideoSize = videoSize;
            try {
                // Implementation for the local binder is no-op,
                // so can be used without worrying about deadlock.
                mISession.asBinder().linkToDeath(mDeathRecipient, 0);
            } catch (RemoteException e) {
                if (DEBUG) {
                    Log.d(TAG, "Session died too early.", e);
                }
                close = true;
                return;
            }
            mConnectedToken = new SessionToken(new SessionTokenImplBase(mToken.getUid(), TYPE_SESSION, mToken.getPackageName(), sessionBinder, tokenExtras));
        }
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onConnected(mInstance, allowedCommands);
            }
        });
    } finally {
        if (close) {
            // Trick to call release() without holding the lock, to prevent potential deadlock
            // with the developer's custom lock within the ControllerCallback.onDisconnected().
            mInstance.close();
        }
    }
}
#method_after
void onConnectedNotLocked(IMediaSession sessionBinder, final SessionCommandGroup allowedCommands, final int playerState, final MediaItem currentMediaItem, final long positionEventTimeMs, final long positionMs, final float playbackSpeed, final long bufferedPositionMs, final PlaybackInfo info, final int repeatMode, final int shuffleMode, final List<MediaItem> playlist, final PendingIntent sessionActivity, final int currentMediaItemIndex, final int previousMediaItemIndex, final int nextMediaItemIndex, final Bundle tokenExtras) {
    if (DEBUG) {
        Log.d(TAG, "onConnectedNotLocked sessionBinder=" + sessionBinder + ", allowedCommands=" + allowedCommands);
    }
    // 'close' is used in try-finally
    boolean close = false;
    try {
        if (sessionBinder == null || allowedCommands == null) {
            // Connection rejected.
            close = true;
            return;
        }
        synchronized (mLock) {
            if (mIsReleased) {
                return;
            }
            if (mISession != null) {
                Log.e(TAG, "Cannot be notified about the connection result many times." + " Probably a bug or malicious app.");
                close = true;
                return;
            }
            mAllowedCommands = allowedCommands;
            mPlayerState = playerState;
            mCurrentMediaItem = currentMediaItem;
            mPositionEventTimeMs = positionEventTimeMs;
            mPositionMs = positionMs;
            mPlaybackSpeed = playbackSpeed;
            mBufferedPositionMs = bufferedPositionMs;
            mPlaybackInfo = info;
            mRepeatMode = repeatMode;
            mShuffleMode = shuffleMode;
            mPlaylist = playlist;
            mSessionActivity = sessionActivity;
            mISession = sessionBinder;
            mCurrentMediaItemIndex = currentMediaItemIndex;
            mPreviousMediaItemIndex = previousMediaItemIndex;
            mNextMediaItemIndex = nextMediaItemIndex;
            try {
                // Implementation for the local binder is no-op,
                // so can be used without worrying about deadlock.
                mISession.asBinder().linkToDeath(mDeathRecipient, 0);
            } catch (RemoteException e) {
                if (DEBUG) {
                    Log.d(TAG, "Session died too early.", e);
                }
                close = true;
                return;
            }
            mConnectedToken = new SessionToken(new SessionTokenImplBase(mToken.getUid(), TYPE_SESSION, mToken.getPackageName(), sessionBinder, tokenExtras));
        }
        mCallbackExecutor.execute(new Runnable() {

            @Override
            public void run() {
                mCallback.onConnected(mInstance, allowedCommands);
            }
        });
    } finally {
        if (close) {
            // Trick to call release() without holding the lock, to prevent potential deadlock
            // with the developer's custom lock within the ControllerCallback.onDisconnected().
            mInstance.close();
        }
    }
}
#end_block

#method_before
void onCustomCommand(final int seq, final SessionCommand command, final Bundle args) {
    if (DEBUG) {
        Log.d(TAG, "onCustomCommand cmd=" + command.getCustomCommand());
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            SessionResult result = mCallback.onCustomCommand(mInstance, command, args);
            if (result == null) {
                if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                    throw new RuntimeException("ControllerCallback#onCustomCommand() has" + " returned null, command=" + command.getCustomCommand());
                } else {
                    result = new SessionResult(RESULT_ERROR_UNKNOWN);
                }
            }
            sendControllerResult(seq, result);
        }
    });
}
#method_after
void onCustomCommand(final int seq, final SessionCommand command, final Bundle args) {
    if (DEBUG) {
        Log.d(TAG, "onCustomCommand cmd=" + command.getCustomAction());
    }
    mCallbackExecutor.execute(new Runnable() {

        @Override
        public void run() {
            SessionResult result = mCallback.onCustomCommand(mInstance, command, args);
            if (result == null) {
                if (THROW_EXCEPTION_FOR_NULL_RESULT) {
                    throw new RuntimeException("ControllerCallback#onCustomCommand() has" + " returned null, command=" + command.getCustomAction());
                } else {
                    result = new SessionResult(RESULT_ERROR_UNKNOWN);
                }
            }
            sendControllerResult(seq, result);
        }
    });
}
#end_block

#method_before
@Override
@NonNull
public VideoSize getVideoSize() {
    return new VideoSize(mPlayer.getVideoWidth(), mPlayer.getVideoHeight());
}
#method_after
@NonNull
public VideoSize getVideoSize() {
    return new VideoSize(mPlayer.getVideoWidth(), mPlayer.getVideoHeight());
}
#end_block

#method_before
@Override
public void onVideoSizeChanged(MediaPlayer2 mp, final MediaItem item, final int width, final int height) {
    final VideoSize size = new VideoSize(width, height);
    notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

        @Override
        public void callCallback(SessionPlayer.PlayerCallback callback) {
            callback.onVideoSizeChanged(MediaPlayer.this, item, size);
        }
    });
}
#method_after
@Override
public void onVideoSizeChanged(MediaPlayer2 mp, final MediaItem item, final int width, final int height) {
    final VideoSize size = new VideoSize(width, height);
    notifyMediaPlayerCallback(new MediaPlayerCallbackNotifier() {

        @Override
        public void callCallback(PlayerCallback callback) {
            callback.onVideoSizeChanged(MediaPlayer.this, item, size);
        }
    });
}
#end_block

#method_before
// //////////////////////////////////////////////////////////////////////////////
// MediaController methods
// //////////////////////////////////////////////////////////////////////////////
public SessionToken getConnectedSessionToken() {
    try {
        return MediaParcelUtils.fromParcelable(mBinder.getConnectedSessionToken(mControllerId));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call getConnectedSessionToken()");
        return null;
    }
}
#method_after
// //////////////////////////////////////////////////////////////////////////////
// MediaController methods
// //////////////////////////////////////////////////////////////////////////////
public SessionToken getConnectedSessionToken() {
    try {
        return MediaParcelUtils.fromParcelable(mBinder.getConnectedSessionToken(mControllerId));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call getConnectedToken()");
        return null;
    }
}
#end_block

#method_before
@Override
@NonNull
public SessionResult onCustomCommand(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller, @NonNull SessionCommand customCommand, @Nullable Bundle args) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCustomCommand() is ignored. session is already gone.");
        }
    }
    if (isRemotePlayback()) {
        // TODO: call mRoutePlayer.onCommand()
        return new SessionResult(RESULT_SUCCESS, null);
    }
    switch(customCommand.getCustomCommand()) {
        case MediaControlView.COMMAND_SHOW_SUBTITLE:
            int indexInSubtitleTrackList = args != null ? args.getInt(MediaControlView.KEY_SELECTED_SUBTITLE_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (indexInSubtitleTrackList != INVALID_TRACK_INDEX) {
                final List<TrackInfo> subtitleTracks = new ArrayList<>(mSubtitleTracks.keySet());
                TrackInfo subtitleTrack = subtitleTracks.get(indexInSubtitleTrackList);
                if (!subtitleTrack.equals(mSelectedSubtitleTrackInfo)) {
                    selectSubtitleTrack(subtitleTrack);
                }
            }
            break;
        case MediaControlView.COMMAND_HIDE_SUBTITLE:
            deselectSubtitleTrack();
            break;
        case MediaControlView.COMMAND_SELECT_AUDIO_TRACK:
            int audioIndex = (args != null) ? args.getInt(MediaControlView.KEY_SELECTED_AUDIO_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (audioIndex != INVALID_TRACK_INDEX) {
                TrackInfo audioTrackInfo = mAudioTrackInfos.get(audioIndex);
                if (!audioTrackInfo.equals(mSelectedAudioTrackInfo)) {
                    mSelectedAudioTrackInfo = audioTrackInfo;
                    mMediaPlayer.selectTrack(mSelectedAudioTrackInfo);
                }
            }
            break;
    }
    return new SessionResult(RESULT_SUCCESS, null);
}
#method_after
@Override
@NonNull
public SessionResult onCustomCommand(@NonNull MediaSession session, @NonNull MediaSession.ControllerInfo controller, @NonNull SessionCommand command, @Nullable Bundle args) {
    if (session != mMediaSession) {
        if (DEBUG) {
            Log.w(TAG, "onCustomCommand() is ignored. session is already gone.");
        }
    }
    if (isRemotePlayback()) {
        // TODO: call mRoutePlayer.onCommand()
        return new SessionResult(RESULT_SUCCESS, null);
    }
    switch(command.getCustomAction()) {
        case MediaControlView.COMMAND_SHOW_SUBTITLE:
            int indexInSubtitleTrackList = args != null ? args.getInt(MediaControlView.KEY_SELECTED_SUBTITLE_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (indexInSubtitleTrackList != INVALID_TRACK_INDEX) {
                final List<TrackInfo> subtitleTracks = new ArrayList<>(mSubtitleTracks.keySet());
                TrackInfo subtitleTrack = subtitleTracks.get(indexInSubtitleTrackList);
                if (!subtitleTrack.equals(mSelectedSubtitleTrackInfo)) {
                    selectSubtitleTrack(subtitleTrack);
                }
            }
            break;
        case MediaControlView.COMMAND_HIDE_SUBTITLE:
            deselectSubtitleTrack();
            break;
        case MediaControlView.COMMAND_SELECT_AUDIO_TRACK:
            int audioIndex = (args != null) ? args.getInt(MediaControlView.KEY_SELECTED_AUDIO_INDEX, INVALID_TRACK_INDEX) : INVALID_TRACK_INDEX;
            if (audioIndex != INVALID_TRACK_INDEX) {
                TrackInfo audioTrackInfo = mAudioTrackInfos.get(audioIndex);
                if (!audioTrackInfo.equals(mSelectedAudioTrackInfo)) {
                    mSelectedAudioTrackInfo = audioTrackInfo;
                    mMediaPlayer.selectTrack(mSelectedAudioTrackInfo);
                }
            }
            break;
    }
    return new SessionResult(RESULT_SUCCESS, null);
}
#end_block

#method_before
@Override
public ListenableFuture<LibraryResult> getLibraryRoot(@Nullable final LibraryParams params) {
    final ResolvableFuture<LibraryResult> result = ResolvableFuture.create();
    final MediaBrowserCompat browserCompat = getBrowserCompat(params);
    if (browserCompat != null) {
        // Already connected with the given extras.
        result.set(new LibraryResult(RESULT_SUCCESS, createRootMediaItem(browserCompat), null));
    } else {
        getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                // Do this on the callback executor to set the looper of MediaBrowserCompat's
                // callback handler to this looper.
                Bundle rootHints = MediaUtils.convertToRootHints(params);
                MediaBrowserCompat newBrowser = new MediaBrowserCompat(getContext(), getConnectedSessionToken().getComponentName(), new GetLibraryRootCallback(result, params), rootHints);
                synchronized (mLock) {
                    mBrowserCompats.put(params, newBrowser);
                }
                newBrowser.connect();
            }
        });
    }
    return result;
}
#method_after
@Override
public ListenableFuture<LibraryResult> getLibraryRoot(@Nullable final LibraryParams params) {
    final ResolvableFuture<LibraryResult> result = ResolvableFuture.create();
    final MediaBrowserCompat browserCompat = getBrowserCompat(params);
    if (browserCompat != null) {
        // Already connected with the given extras.
        result.set(new LibraryResult(RESULT_SUCCESS, createRootMediaItem(browserCompat), null));
    } else {
        getCallbackExecutor().execute(new Runnable() {

            @Override
            public void run() {
                // Do this on the callback executor to set the looper of MediaBrowserCompat's
                // callback handler to this looper.
                Bundle rootHints = MediaUtils.convertToRootHints(params);
                MediaBrowserCompat newBrowser = new MediaBrowserCompat(getContext(), getConnectedToken().getComponentName(), new GetLibraryRootCallback(result, params), rootHints);
                synchronized (mLock) {
                    mBrowserCompats.put(params, newBrowser);
                }
                newBrowser.connect();
            }
        });
    }
    return result;
}
#end_block

#method_before
@Test
public void testUpdateAndSelectSubtitleTrack() throws Throwable {
    Uri uri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.testvideo_with_2_subtitle_tracks);
    final int subtitleTrackCount = 2;
    final int selectedSubtitleTrackIndex = 0;
    final String subtitleTrack1Text = "Track 1";
    final MediaItem mediaItem = createTestMediaItem2(uri);
    final CountDownLatch latchForTrackUpdate = new CountDownLatch(1);
    final CountDownLatch latchForSubtitleSelect = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (TextUtils.equals(command.getCustomCommand(), MediaControlView.EVENT_UPDATE_TRACK_STATUS)) {
                List<String> list = (args != null) ? args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST) : null;
                if (list != null && list.size() == subtitleTrackCount) {
                    latchForTrackUpdate.countDown();
                }
            } else if (TextUtils.equals(command.getCustomCommand(), MediaControlView.EVENT_UPDATE_SUBTITLE_SELECTED)) {
                int subtitleIndex = args != null ? args.getInt(MediaControlView.KEY_SELECTED_SUBTITLE_INDEX) : -1;
                assertEquals(selectedSubtitleTrackIndex, subtitleIndex);
                latchForSubtitleSelect.countDown();
            }
            return new SessionResult(SessionResult.RESULT_SUCCESS, null);
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mediaItem);
        }
    });
    controller.play();
    assertTrue(latchForTrackUpdate.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.subtitle)).check(matches(isClickable()));
    onView(withId(R.id.subtitle)).perform(click());
    onView(withText(subtitleTrack1Text)).inRoot(isPlatformPopup()).check(matches(isCompletelyDisplayed()));
    onView(withText(subtitleTrack1Text)).inRoot(isPlatformPopup()).perform(click());
    assertTrue(latchForSubtitleSelect.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testUpdateAndSelectSubtitleTrack() throws Throwable {
    Uri uri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.testvideo_with_2_subtitle_tracks);
    final int subtitleTrackCount = 2;
    final int selectedSubtitleTrackIndex = 0;
    final String subtitleTrack1Text = "Track 1";
    final MediaItem mediaItem = createTestMediaItem2(uri);
    final CountDownLatch latchForTrackUpdate = new CountDownLatch(1);
    final CountDownLatch latchForSubtitleSelect = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (TextUtils.equals(command.getCustomAction(), MediaControlView.EVENT_UPDATE_TRACK_STATUS)) {
                List<String> list = (args != null) ? args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST) : null;
                if (list != null && list.size() == subtitleTrackCount) {
                    latchForTrackUpdate.countDown();
                }
            } else if (TextUtils.equals(command.getCustomAction(), MediaControlView.EVENT_UPDATE_SUBTITLE_SELECTED)) {
                int subtitleIndex = args != null ? args.getInt(MediaControlView.KEY_SELECTED_SUBTITLE_INDEX) : -1;
                assertEquals(selectedSubtitleTrackIndex, subtitleIndex);
                latchForSubtitleSelect.countDown();
            }
            return new SessionResult(SessionResult.RESULT_SUCCESS, null);
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mediaItem);
        }
    });
    controller.play();
    assertTrue(latchForTrackUpdate.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.subtitle)).check(matches(isClickable()));
    onView(withId(R.id.subtitle)).perform(click());
    onView(withText(subtitleTrack1Text)).inRoot(isPlatformPopup()).check(matches(isCompletelyDisplayed()));
    onView(withText(subtitleTrack1Text)).inRoot(isPlatformPopup()).perform(click());
    assertTrue(latchForSubtitleSelect.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
private SessionPlayer createMockPlayer(Bundle config) {
    SessionPlayer player;
    if (config.containsKey(KEY_VOLUME_CONTROL_TYPE)) {
        // Remote player
        player = new MockRemotePlayer(config.getInt(KEY_VOLUME_CONTROL_TYPE), config.getInt(KEY_MAX_VOLUME), config.getInt(KEY_CURRENT_VOLUME));
    } else {
        // Local player
        MockPlayer localPlayer = new MockPlayer(0);
        localPlayer.mLastPlayerState = config.getInt(KEY_PLAYER_STATE);
        localPlayer.mLastBufferingState = config.getInt(KEY_BUFFERING_STATE);
        localPlayer.mCurrentPosition = config.getLong(KEY_CURRENT_POSITION);
        localPlayer.mBufferedPosition = config.getLong(KEY_BUFFERED_POSITION);
        localPlayer.mPlaybackSpeed = config.getFloat(KEY_SPEED);
        ParcelImplListSlice listSlice = config.getParcelable(KEY_PLAYLIST);
        if (listSlice != null) {
            localPlayer.mPlaylist = MediaTestUtils.convertToMediaItems(listSlice.getList(), false);
        }
        ParcelImpl currentItem = config.getParcelable(KEY_MEDIA_ITEM);
        localPlayer.mCurrentMediaItem = (currentItem == null) ? null : (MediaItem) MediaParcelUtils.fromParcelable(currentItem);
        localPlayer.mMetadata = ParcelUtils.getVersionedParcelable(config, KEY_METADATA);
        ParcelImpl videoSize = config.getParcelable(KEY_VIDEO_SIZE);
        if (videoSize != null) {
            localPlayer.mVideoSize = MediaParcelUtils.fromParcelable(videoSize);
        }
        player = localPlayer;
    }
    player.setAudioAttributes(AudioAttributesCompat.fromBundle(config.getBundle(KEY_AUDIO_ATTRIBUTES)));
    return player;
}
#method_after
private SessionPlayer createMockPlayer(Bundle config) {
    SessionPlayer player;
    if (config.containsKey(KEY_VOLUME_CONTROL_TYPE)) {
        // Remote player
        player = new MockRemotePlayer(config.getInt(KEY_VOLUME_CONTROL_TYPE), config.getInt(KEY_MAX_VOLUME), config.getInt(KEY_CURRENT_VOLUME));
    } else {
        // Local player
        MockPlayer localPlayer = new MockPlayer(0);
        localPlayer.mLastPlayerState = config.getInt(KEY_PLAYER_STATE);
        localPlayer.mLastBufferingState = config.getInt(KEY_BUFFERING_STATE);
        localPlayer.mCurrentPosition = config.getLong(KEY_CURRENT_POSITION);
        localPlayer.mBufferedPosition = config.getLong(KEY_BUFFERED_POSITION);
        localPlayer.mPlaybackSpeed = config.getFloat(KEY_SPEED);
        ParcelImplListSlice listSlice = config.getParcelable(KEY_PLAYLIST);
        if (listSlice != null) {
            localPlayer.mPlaylist = MediaTestUtils.convertToMediaItems(listSlice.getList(), false);
        }
        ParcelImpl currentItem = config.getParcelable(KEY_MEDIA_ITEM);
        localPlayer.mCurrentMediaItem = (currentItem == null) ? null : (MediaItem) MediaParcelUtils.fromParcelable(currentItem);
        localPlayer.mMetadata = ParcelUtils.getVersionedParcelable(config, KEY_METADATA);
        player = localPlayer;
    }
    player.setAudioAttributes(AudioAttributesCompat.fromBundle(config.getBundle(KEY_AUDIO_ATTRIBUTES)));
    return player;
}
#end_block

#method_before
@NonNull
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    if (command.getCommandCode() != SessionCommand.COMMAND_CODE_CUSTOM) {
        throw new IllegalArgumentException("command should be a custom command");
    }
    if (isConnected()) {
        return getImpl().sendCustomCommand(command, args);
    }
    return createDisconnectedFuture();
}
#method_after
@NonNull
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    if (command == null) {
        throw new NullPointerException("command shouldn't be null");
    }
    if (command.getCommandCode() != SessionCommand.COMMAND_CODE_CUSTOM) {
        throw new IllegalArgumentException("command should be a custom command");
    }
    if (isConnected()) {
        return getImpl().sendCustomCommand(command, args);
    }
    return createDisconnectedFuture();
}
#end_block

#method_before
@NonNull
public Builder setExtras(@Nullable Bundle extras) {
    mBundle = extras;
    return this;
}
#method_after
@NonNull
@Override
public Builder setExtras(@NonNull Bundle extras) {
    return super.setExtras(extras);
}
#end_block

#method_before
@NonNull
public LibraryParams build() {
    return new LibraryParams(mBundle, mRecent, mOffline, mSuggested);
}
#method_after
@Override
@NonNull
public MediaLibrarySession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new MediaLibrarySession.MediaLibrarySessionCallback() {
        };
    }
    return new MediaLibrarySession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback, mExtras);
}
#end_block

#method_before
@Ignore
@Test
public void testGetMediaSessionTokens_hasMediaController() throws InterruptedException {
    prepareLooper();
    final MockPlayer player = (MockPlayer) mSession.getPlayer();
    player.notifyPlayerStateChanged(SessionPlayer.PLAYER_STATE_IDLE);
    MediaController controller = null;
// List<SessionToken> tokens = mManager.getActiveSessionTokens();
// assertNotNull(tokens);
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (mContext.getPackageName().equals(token.getPackageName())
// && TAG.equals(token.getSessionId())) {
// assertNull(controller);
// controller = createController(token);
// }
// }
// assertNotNull(controller);
// 
// // Test if the found controller is correct one.
// assertEquals(SessionPlayer.PLAYER_STATE_IDLE, controller.getPlayerState());
// controller.play();
// 
// assertTrue(player.mCountDownLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
// assertTrue(player.mPlayCalled);
}
#method_after
@Ignore
@Test
public void testGetMediaSessionTokens_hasMediaController() throws InterruptedException {
    prepareLooper();
    final MockPlayer player = (MockPlayer) mSession.getPlayer();
    player.notifyPlayerStateChanged(SessionPlayer.PLAYER_STATE_IDLE);
    MediaController controller = null;
// List<SessionToken> tokens = mManager.getActiveSessionTokens();
// assertNotNull(tokens);
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (mContext.getPackageName().equals(token.getPackageName())
// && TAG.equals(token.getId())) {
// assertNull(controller);
// controller = createController(token);
// }
// }
// assertNotNull(controller);
// 
// // Test if the found controller is correct one.
// assertEquals(SessionPlayer.PLAYER_STATE_IDLE, controller.getPlayerState());
// controller.play();
// 
// assertTrue(player.mCountDownLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
// assertTrue(player.mPlayCalled);
}
#end_block

#method_before
@Test
@Ignore
public void testGetSessionTokens_sessionRejected() throws InterruptedException {
    prepareLooper();
    mSession.close();
    mSession = new MediaSession.Builder(mContext, new MockPlayer(0)).setId(TAG).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(MediaSession session, ControllerInfo controller) {
            // Reject all connection request.
            return null;
        }
    }).build();
    boolean foundSession = false;
// List<SessionToken> tokens = mManager.getActiveSessionTokens();
// assertNotNull(tokens);
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (mContext.getPackageName().equals(token.getPackageName())
// && TAG.equals(token.getSessionId())) {
// assertFalse(foundSession);
// foundSession = true;
// }
// }
// assertTrue(foundSession);
}
#method_after
@Test
@Ignore
public void testGetSessionTokens_sessionRejected() throws InterruptedException {
    prepareLooper();
    mSession.close();
    mSession = new MediaSession.Builder(mContext, new MockPlayer(0)).setId(TAG).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(MediaSession session, ControllerInfo controller) {
            // Reject all connection request.
            return null;
        }
    }).build();
    boolean foundSession = false;
// List<SessionToken> tokens = mManager.getActiveSessionTokens();
// assertNotNull(tokens);
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (mContext.getPackageName().equals(token.getPackageName())
// && TAG.equals(token.getId())) {
// assertFalse(foundSession);
// foundSession = true;
// }
// }
// assertTrue(foundSession);
}
#end_block

#method_before
@Test
@Ignore
public void testGetMediaSessionTokens_sessionClosed() throws InterruptedException {
    prepareLooper();
    mSession.close();
// When a session is closed, it should lose binder connection between server immediately.
// So server will forget the session.
// List<SessionToken> tokens = mManager.getActiveSessionTokens();
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// assertFalse(mContext.getPackageName().equals(token.getPackageName())
// && TAG.equals(token.getSessionId()));
// }
}
#method_after
@Test
@Ignore
public void testGetMediaSessionTokens_sessionClosed() throws InterruptedException {
    prepareLooper();
    mSession.close();
// When a session is closed, it should lose binder connection between server immediately.
// So server will forget the session.
// List<SessionToken> tokens = mManager.getActiveSessionTokens();
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// assertFalse(mContext.getPackageName().equals(token.getPackageName())
// && TAG.equals(token.getId()));
// }
}
#end_block

#method_before
@Test
@Ignore
public void testGetMediaSessionServiceToken() throws InterruptedException {
    prepareLooper();
    boolean foundTestSessionService = false;
    boolean foundTestLibraryService = false;
// List<SessionToken> tokens = mManager.getSessionServiceTokens();
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (mContext.getPackageName().equals(token.getPackageName())
// && MockMediaSessionService.ID.equals(token.getSessionId())) {
// assertFalse(foundTestSessionService);
// assertEquals(SessionToken.TYPE_SESSION_SERVICE, token.getType());
// foundTestSessionService = true;
// } else if (mContext.getPackageName().equals(token.getPackageName())
// && MockMediaLibraryService.ID.equals(token.getSessionId())) {
// assertFalse(foundTestLibraryService);
// assertEquals(SessionToken.TYPE_LIBRARY_SERVICE, token.getType());
// foundTestLibraryService = true;
// }
// }
// assertTrue(foundTestSessionService);
// assertTrue(foundTestLibraryService);
}
#method_after
@Test
@Ignore
public void testGetMediaSessionServiceToken() throws InterruptedException {
    prepareLooper();
    boolean foundTestSessionService = false;
    boolean foundTestLibraryService = false;
// List<SessionToken> tokens = mManager.getSessionServiceTokens();
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (mContext.getPackageName().equals(token.getPackageName())
// && MockMediaSessionService.ID.equals(token.getId())) {
// assertFalse(foundTestSessionService);
// assertEquals(SessionToken.TYPE_SESSION_SERVICE, token.getType());
// foundTestSessionService = true;
// } else if (mContext.getPackageName().equals(token.getPackageName())
// && MockMediaLibraryService.ID.equals(token.getId())) {
// assertFalse(foundTestLibraryService);
// assertEquals(SessionToken.TYPE_LIBRARY_SERVICE, token.getType());
// foundTestLibraryService = true;
// }
// }
// assertTrue(foundTestSessionService);
// assertTrue(foundTestLibraryService);
}
#end_block

#method_before
@Test
@Ignore
public void testGetAllSessionTokens() throws InterruptedException {
    prepareLooper();
    boolean foundTestSession = false;
    boolean foundTestSessionService = false;
    boolean foundTestLibraryService = false;
// List<SessionToken> tokens = mManager.getAllSessionTokens();
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (!mContext.getPackageName().equals(token.getPackageName())) {
// continue;
// }
// switch (token.getSessionId()) {
// case TAG:
// assertFalse(foundTestSession);
// foundTestSession = true;
// break;
// case MockMediaSessionService.ID:
// assertFalse(foundTestSessionService);
// foundTestSessionService = true;
// assertEquals(SessionToken.TYPE_SESSION_SERVICE, token.getType());
// break;
// case MockMediaLibraryService.ID:
// assertFalse(foundTestLibraryService);
// assertEquals(SessionToken.TYPE_LIBRARY_SERVICE, token.getType());
// foundTestLibraryService = true;
// break;
// default:
// fail("Unexpected session " + token + " exists in the package");
// }
// }
// assertTrue(foundTestSession);
// assertTrue(foundTestSessionService);
// assertTrue(foundTestLibraryService);
}
#method_after
@Test
@Ignore
public void testGetAllSessionTokens() throws InterruptedException {
    prepareLooper();
    boolean foundTestSession = false;
    boolean foundTestSessionService = false;
    boolean foundTestLibraryService = false;
// List<SessionToken> tokens = mManager.getAllSessionTokens();
// for (int i = 0; i < tokens.size(); i++) {
// SessionToken token = tokens.get(i);
// if (!mContext.getPackageName().equals(token.getPackageName())) {
// continue;
// }
// switch (token.getId()) {
// case TAG:
// assertFalse(foundTestSession);
// foundTestSession = true;
// break;
// case MockMediaSessionService.ID:
// assertFalse(foundTestSessionService);
// foundTestSessionService = true;
// assertEquals(SessionToken.TYPE_SESSION_SERVICE, token.getType());
// break;
// case MockMediaLibraryService.ID:
// assertFalse(foundTestLibraryService);
// assertEquals(SessionToken.TYPE_LIBRARY_SERVICE, token.getType());
// foundTestLibraryService = true;
// break;
// default:
// fail("Unexpected session " + token + " exists in the package");
// }
// }
// assertTrue(foundTestSession);
// assertTrue(foundTestSessionService);
// assertTrue(foundTestLibraryService);
}
#end_block

#method_before
@Test
public void testSendCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final String testCommand = "test_command";
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "test_args");
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCallback callback = new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup commands = super.onConnect(session, controller);
            commands.addCommand(new SessionCommand(testCommand, null));
            return commands;
        }

        @Override
        public SessionResult onCustomCommand(MediaSession session, ControllerInfo controller, SessionCommand customCommand, Bundle args) {
            assertEquals(EXPECTED_CONTROLLER_PACKAGE_NAME, controller.getPackageName());
            assertEquals(testCommand, customCommand.getCustomCommand());
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    mSession.close();
    mSession = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, callback).setId(TAG).build();
    final RemoteMediaControllerCompat controller = new RemoteMediaControllerCompat(mContext, mSession.getSessionCompat().getSessionToken(), true);
    controller.sendCommand(testCommand, testArgs, null);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSendCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final String testCommand = "test_command";
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "test_args");
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCallback callback = new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup commands = super.onConnect(session, controller);
            SessionCommandGroup.Builder builder = new SessionCommandGroup.Builder(commands);
            builder.addCommand(new SessionCommand(testCommand, null));
            return builder.build();
        }

        @Override
        public SessionResult onCustomCommand(MediaSession session, ControllerInfo controller, SessionCommand sessionCommand, Bundle args) {
            assertEquals(EXPECTED_CONTROLLER_PACKAGE_NAME, controller.getPackageName());
            assertEquals(testCommand, sessionCommand.getCustomAction());
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    mSession.close();
    mSession = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, callback).setId(TAG).build();
    final RemoteMediaControllerCompat controller = new RemoteMediaControllerCompat(mContext, mSession.getSessionCompat().getSessionToken(), true);
    controller.sendCommand(testCommand, testArgs, null);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return createFutureWithResult(RESULT_ERROR_SESSION_DISCONNECTED);
        }
        if (mAllowedCommands.hasCommand(command)) {
            mControllerCompat.getTransportControls().sendCustomAction(command.getCustomCommand(), args);
            return createFutureWithResult(RESULT_SUCCESS);
        }
        final ResolvableFuture<SessionResult> result = ResolvableFuture.create();
        ResultReceiver cb = new ResultReceiver(mHandler) {

            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                result.set(new SessionResult(resultCode, resultData));
            }
        };
        mControllerCompat.sendCommand(command.getCustomCommand(), args, cb);
        return result;
    }
}
#method_after
@Override
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    synchronized (mLock) {
        if (!mConnected) {
            Log.w(TAG, "Session isn't active", new IllegalStateException());
            return createFutureWithResult(RESULT_ERROR_SESSION_DISCONNECTED);
        }
        if (mAllowedCommands.hasCommand(command)) {
            mControllerCompat.getTransportControls().sendCustomAction(command.getCustomAction(), args);
            return createFutureWithResult(RESULT_SUCCESS);
        }
        final ResolvableFuture<SessionResult> result = ResolvableFuture.create();
        ResultReceiver cb = new ResultReceiver(mHandler) {

            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                result.set(new SessionResult(resultCode, resultData));
            }
        };
        mControllerCompat.sendCommand(command.getCustomAction(), args, cb);
        return result;
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SessionCommand)) {
        return false;
    }
    SessionCommand other = (SessionCommand) obj;
    return mCommandCode == other.mCommandCode && TextUtils.equals(mCustomCommand, other.mCustomCommand);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SessionCommand)) {
        return false;
    }
    SessionCommand other = (SessionCommand) obj;
    return mCommandCode == other.mCommandCode && TextUtils.equals(mCustomAction, other.mCustomAction);
}
#end_block

#method_before
@Override
public int hashCode() {
    return ObjectsCompat.hash(mCustomCommand, mCommandCode);
}
#method_after
@Override
public int hashCode() {
    return ObjectsCompat.hash(mCustomAction, mCommandCode);
}
#end_block

#method_before
@Test
public void testSendCustomCommand() throws InterruptedException {
    prepareLooper();
    final SessionCommand testCommand = new SessionCommand(SessionCommand.COMMAND_CODE_PLAYER_PREPARE);
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "testSendCustomAction");
    final CountDownLatch latch = new CountDownLatch(2);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(testCommand, command);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS);
        }
    };
    final MediaController controller = createController(mSession.getToken(), true, null, callback);
    // TODO(jaewan): Test with multiple controllers
    mSession.broadcastCustomCommand(testCommand, testArgs);
    ControllerInfo controllerInfo = getTestControllerInfo();
    assertNotNull(controllerInfo);
    // TODO(jaewan): Test receivers as well.
    mSession.sendCustomCommand(controllerInfo, testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSendCustomCommand() throws InterruptedException {
    prepareLooper();
    final SessionCommand testCommand = new SessionCommand("test_command_code", null);
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "testSendCustomAction");
    final CountDownLatch latch = new CountDownLatch(2);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(testCommand, command);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS);
        }
    };
    final MediaController controller = createController(mSession.getToken(), true, null, callback);
    // TODO(jaewan): Test with multiple controllers
    mSession.broadcastCustomCommand(testCommand, testArgs);
    ControllerInfo controllerInfo = getTestControllerInfo();
    assertNotNull(controllerInfo);
    // TODO(jaewan): Test receivers as well.
    mSession.sendCustomCommand(controllerInfo, testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testSendCustomCommand_onConnect() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCommand testCommand = new SessionCommand("test", null);
    final SessionCallback testSessionCallback = new SessionCallback() {

        @Nullable
        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            session.sendCustomCommand(controller, testCommand, null);
            return super.onConnect(session, controller);
        }
    };
    final ControllerCallback testControllerCallback = new ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (TextUtils.equals(testCommand.getCustomCommand(), command.getCustomCommand())) {
                latch.countDown();
            }
            return super.onCustomCommand(controller, command, args);
        }
    };
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, testSessionCallback).build()) {
        MediaController controller = createController(session.getToken(), true, null, testControllerCallback);
        assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Test
public void testSendCustomCommand_onConnect() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCommand testCommand = new SessionCommand("test", null);
    final SessionCallback testSessionCallback = new SessionCallback() {

        @Nullable
        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            session.sendCustomCommand(controller, testCommand, null);
            return super.onConnect(session, controller);
        }
    };
    final ControllerCallback testControllerCallback = new ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (TextUtils.equals(testCommand.getCustomAction(), command.getCustomAction())) {
                latch.countDown();
            }
            return super.onCustomCommand(controller, command, args);
        }
    };
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, testSessionCallback).build()) {
        MediaController controller = createController(session.getToken(), true, null, testControllerCallback);
        assertFalse(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testSendCustomCommand_onPostConnect() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCommand testCommand = new SessionCommand("test", null);
    final SessionCallback testSessionCallback = new SessionCallback() {

        @Nullable
        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup gr = super.onConnect(session, controller);
            return gr;
        }

        @Nullable
        @Override
        public void onPostConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            session.sendCustomCommand(controller, testCommand, null);
        }
    };
    final ControllerCallback testControllerCallback = new ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (TextUtils.equals(testCommand.getCustomCommand(), command.getCustomCommand())) {
                latch.countDown();
            }
            return super.onCustomCommand(controller, command, args);
        }
    };
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, testSessionCallback).build()) {
        MediaController controller = createController(session.getToken(), true, null, testControllerCallback);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Test
public void testSendCustomCommand_onPostConnect() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCommand testCommand = new SessionCommand("test", null);
    final SessionCallback testSessionCallback = new SessionCallback() {

        @Nullable
        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup gr = super.onConnect(session, controller);
            return gr;
        }

        @Nullable
        @Override
        public void onPostConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            session.sendCustomCommand(controller, testCommand, null);
        }
    };
    final ControllerCallback testControllerCallback = new ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (TextUtils.equals(testCommand.getCustomAction(), command.getCustomAction())) {
                latch.countDown();
            }
            return super.onCustomCommand(controller, command, args);
        }
    };
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, testSessionCallback).build()) {
        MediaController controller = createController(session.getToken(), true, null, testControllerCallback);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Override
public boolean matches(SessionCommand command) {
    return mExpectedCommand.equals(command.getCustomCommand());
}
#method_after
@Override
public boolean matches(SessionCommand command) {
    return mExpectedCommand.equals(command.getCustomAction());
}
#end_block

#method_before
public void broadcastCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    mImpl.broadcastCustomCommand(command, args);
}
#method_after
public void broadcastCustomCommand(@NonNull SessionCommand command, @Nullable Bundle args) {
    if (command == null) {
        throw new NullPointerException("command shouldn't be null");
    }
    if (command.getCommandCode() != SessionCommand.COMMAND_CODE_CUSTOM) {
        throw new IllegalArgumentException("command should be a custom command");
    }
    mImpl.broadcastCustomCommand(command, args);
}
#end_block

#method_before
@NonNull
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull SessionCommand command, @Nullable Bundle args) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    return mImpl.sendCustomCommand(controller, command, args);
}
#method_after
@NonNull
public ListenableFuture<SessionResult> sendCustomCommand(@NonNull ControllerInfo controller, @NonNull SessionCommand command, @Nullable Bundle args) {
    if (controller == null) {
        throw new IllegalArgumentException("controller shouldn't be null");
    }
    if (command == null) {
        throw new IllegalArgumentException("command shouldn't be null");
    }
    if (command.getCommandCode() != SessionCommand.COMMAND_CODE_CUSTOM) {
        throw new IllegalArgumentException("command should be a custom command");
    }
    return mImpl.sendCustomCommand(controller, command, args);
}
#end_block

#method_before
@NonNull
public Builder setExtras(@Nullable Bundle extras) {
    mExtras = extras;
    return this;
}
#method_after
@NonNull
@Override
public Builder setExtras(@NonNull Bundle extras) {
    return super.setExtras(extras);
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession(mContext, mId, mPlayer, mSessionActivity, mCallbackExecutor, mCallback, mExtras);
}
#end_block

#method_before
@Test
public void testOnGetSession_rejectsConnection() throws InterruptedException {
    TestServiceRegistry.getInstance().setOnGetSessionHandler(new TestServiceRegistry.OnGetSessionHandler() {

        @Override
        public MediaSession onGetSession(ControllerInfo controllerInfo) {
            return null;
        }
    });
    final CountDownLatch latch = new CountDownLatch(1);
    MediaController controller = new MediaController.Builder(mContext).setSessionToken(mToken).setControllerCallback(sHandlerExecutor, new MediaController.ControllerCallback() {

        @Override
        public void onDisconnected(MediaController controller) {
            latch.countDown();
        }
    }).build();
    // MediaController2.ControllerCallback#onDisconnected() should be called.
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    assertNull(controller.getConnectedSessionToken());
    controller.close();
}
#method_after
@Test
public void testOnGetSession_rejectsConnection() throws InterruptedException {
    TestServiceRegistry.getInstance().setOnGetSessionHandler(new TestServiceRegistry.OnGetSessionHandler() {

        @Override
        public MediaSession onGetSession(ControllerInfo controllerInfo) {
            return null;
        }
    });
    final CountDownLatch latch = new CountDownLatch(1);
    MediaController controller = new MediaController.Builder(mContext).setSessionToken(mToken).setControllerCallback(sHandlerExecutor, new MediaController.ControllerCallback() {

        @Override
        public void onDisconnected(MediaController controller) {
            latch.countDown();
        }
    }).build();
    // MediaController2.ControllerCallback#onDisconnected() should be called.
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    assertNull(controller.getConnectedToken());
    controller.close();
}
#end_block

#method_before
private void playLoadedModularDrmVideo_Generic(final Uri file, final Integer width, final Integer height, int playTime, ModularDrmTestType testType) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    mECb = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(SessionPlayer mp, MediaItem item, VideoSize size) {
            Log.v(TAG, "VideoSizeChanged" + " w:" + size.getWidth() + " h:" + size.getHeight());
            mOnVideoSizeChangedCalled.signal();
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem item, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem item, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_MEDIA_ITEM_END) {
                Log.v(TAG, "playLoadedVideo: onInfo_PlaybackComplete");
                mOnPlaybackCompleted.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, mECb);
    Log.v(TAG, "playLoadedVideo: setMediaItem()");
    ListenableFuture<PlayerResult> future = mPlayer.setMediaItem(new UriMediaItem.Builder(file).build());
    assertEquals(PlayerResult.RESULT_SUCCESS, future.get().getResultCode());
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    surfaceHolder.setKeepScreenOn(true);
    mPlayer.setSurface(surfaceHolder.getSurface());
    try {
        switch(testType) {
            case V0_SYNC_TEST:
                preparePlayerAndDrm_V0_syncDrmSetup();
                break;
            case V1_ASYNC_TEST:
                preparePlayerAndDrm_V1_asyncDrmSetup();
                break;
            case V2_SYNC_CONFIG_TEST:
                preparePlayerAndDrm_V2_syncDrmSetupPlusConfig();
                break;
            case V3_ASYNC_DRMPREPARED_TEST:
                preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener();
                break;
        }
    } catch (IOException e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
    Log.v(TAG, "playLoadedVideo: play()");
    mPlayer.play();
    if (!mAudioOnly) {
        mOnVideoSizeChangedCalled.waitForSignal();
    }
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    if (playTime == 0) {
        Log.v(TAG, "playLoadedVideo: waiting for playback completion");
        mOnPlaybackCompleted.waitForSignal();
    } else {
        Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
        mOnPlaybackCompleted.waitForSignal(playTime);
    }
    try {
        Log.v(TAG, "playLoadedVideo: releaseDrm");
        mPlayer.releaseDrm();
    } catch (Exception e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
}
#method_after
private void playLoadedModularDrmVideo_Generic(final Uri file, final Integer width, final Integer height, int playTime, ModularDrmTestType testType) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    mECb = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem item, VideoSize size) {
            Log.v(TAG, "VideoSizeChanged" + " w:" + size.getWidth() + " h:" + size.getHeight());
            mOnVideoSizeChangedCalled.signal();
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem item, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem item, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_MEDIA_ITEM_END) {
                Log.v(TAG, "playLoadedVideo: onInfo_PlaybackComplete");
                mOnPlaybackCompleted.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, mECb);
    Log.v(TAG, "playLoadedVideo: setMediaItem()");
    ListenableFuture<PlayerResult> future = mPlayer.setMediaItem(new UriMediaItem.Builder(file).build());
    assertEquals(PlayerResult.RESULT_SUCCESS, future.get().getResultCode());
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    surfaceHolder.setKeepScreenOn(true);
    mPlayer.setSurface(surfaceHolder.getSurface());
    try {
        switch(testType) {
            case V0_SYNC_TEST:
                preparePlayerAndDrm_V0_syncDrmSetup();
                break;
            case V1_ASYNC_TEST:
                preparePlayerAndDrm_V1_asyncDrmSetup();
                break;
            case V2_SYNC_CONFIG_TEST:
                preparePlayerAndDrm_V2_syncDrmSetupPlusConfig();
                break;
            case V3_ASYNC_DRMPREPARED_TEST:
                preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener();
                break;
        }
    } catch (IOException e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
    Log.v(TAG, "playLoadedVideo: play()");
    mPlayer.play();
    if (!mAudioOnly) {
        mOnVideoSizeChangedCalled.waitForSignal();
    }
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    if (playTime == 0) {
        Log.v(TAG, "playLoadedVideo: waiting for playback completion");
        mOnPlaybackCompleted.waitForSignal();
    } else {
        Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
        mOnPlaybackCompleted.waitForSignal(playTime);
    }
    try {
        Log.v(TAG, "playLoadedVideo: releaseDrm");
        mPlayer.releaseDrm();
    } catch (Exception e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
}
#end_block

#method_before
@Override
@NonNull
public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
    if (DEBUG) {
        Log.d(TAG, "onCustomCommand(): command: " + command);
    }
    switch(command.getCustomCommand()) {
        case EVENT_UPDATE_TRACK_STATUS:
            mVideoTrackCount = (args != null) ? args.getInt(KEY_VIDEO_TRACK_COUNT) : 0;
            // If there is one or more audio tracks, and this information has not been
            // reflected into the Settings window yet, automatically check the first
            // track.
            // Otherwise, the Audio Track selection will be defaulted to "None".
            mAudioTrackCount = (args != null) ? args.getInt(KEY_AUDIO_TRACK_COUNT) : 0;
            mAudioTrackList = new ArrayList<String>();
            if (mAudioTrackCount > 0) {
                for (int i = 0; i < mAudioTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView_audio_track_number_text, i + 1);
                    mAudioTrackList.add(track);
                }
                // Change sub text inside the Settings window.
                mSettingsSubTextsList.set(SETTINGS_MODE_AUDIO_TRACK, mAudioTrackList.get(0));
            } else {
                mAudioTrackList.add(mResources.getString(R.string.MediaControlView_audio_track_none_text));
            }
            if (mVideoTrackCount == 0 && mAudioTrackCount > 0) {
                mMediaType = MEDIA_TYPE_MUSIC;
            }
            List<String> subtitleTracksList = (args != null) ? args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST) : null;
            if (subtitleTracksList != null) {
                mSubtitleDescriptionsList = new ArrayList<String>();
                mSubtitleDescriptionsList.add(mResources.getString(R.string.MediaControlView_subtitle_off_text));
                for (int i = 0; i < subtitleTracksList.size(); i++) {
                    String lang = subtitleTracksList.get(i);
                    String trackDescription;
                    if (lang.equals("und")) {
                        trackDescription = mResources.getString(R.string.MediaControlView_subtitle_track_number_text, i + 1);
                    } else {
                        trackDescription = mResources.getString(R.string.MediaControlView_subtitle_track_number_and_lang_text, i + 1, lang);
                    }
                    mSubtitleDescriptionsList.add(trackDescription);
                }
                mSubtitleButton.setAlpha(1.0f);
                mSubtitleButton.setEnabled(true);
            } else {
                if (mMediaType == MEDIA_TYPE_MUSIC) {
                    mSubtitleButton.setVisibility(View.GONE);
                } else {
                    mSubtitleButton.setAlpha(0.5f);
                    mSubtitleButton.setEnabled(false);
                }
            }
            break;
        case EVENT_UPDATE_MEDIA_TYPE_STATUS:
            boolean isAd = (args != null) && args.getBoolean(KEY_STATE_IS_ADVERTISEMENT);
            if (isAd != mIsAdvertisement) {
                mIsAdvertisement = isAd;
                updateLayoutForAd();
            }
            break;
        case EVENT_UPDATE_SUBTITLE_SELECTED:
            int selectedTrackIndex = args != null ? args.getInt(KEY_SELECTED_SUBTITLE_INDEX, -1) : -1;
            if (selectedTrackIndex < 0 || selectedTrackIndex >= mSubtitleDescriptionsList.size()) {
                Log.w(TAG, "Selected subtitle track index (" + selectedTrackIndex + ") is out of range.");
                break;
            }
            mSelectedSubtitleTrackIndex = selectedTrackIndex + 1;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            mSubtitleButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_subtitle_on));
            mSubtitleButton.setContentDescription(mResources.getString(R.string.mcv2_cc_is_on));
            break;
        case EVENT_UPDATE_SUBTITLE_DESELECTED:
            mSelectedSubtitleTrackIndex = 0;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            mSubtitleButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_subtitle_off));
            mSubtitleButton.setContentDescription(mResources.getString(R.string.mcv2_cc_is_off));
            break;
        default:
            return new SessionResult(RESULT_ERROR_NOT_SUPPORTED, null);
    }
    return new SessionResult(RESULT_SUCCESS, null);
}
#method_after
@Override
@NonNull
public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
    if (DEBUG) {
        Log.d(TAG, "onCustomCommand(): command: " + command);
    }
    switch(command.getCustomAction()) {
        case EVENT_UPDATE_TRACK_STATUS:
            mVideoTrackCount = (args != null) ? args.getInt(KEY_VIDEO_TRACK_COUNT) : 0;
            // If there is one or more audio tracks, and this information has not been
            // reflected into the Settings window yet, automatically check the first
            // track.
            // Otherwise, the Audio Track selection will be defaulted to "None".
            mAudioTrackCount = (args != null) ? args.getInt(KEY_AUDIO_TRACK_COUNT) : 0;
            mAudioTrackList = new ArrayList<String>();
            if (mAudioTrackCount > 0) {
                for (int i = 0; i < mAudioTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView_audio_track_number_text, i + 1);
                    mAudioTrackList.add(track);
                }
                // Change sub text inside the Settings window.
                mSettingsSubTextsList.set(SETTINGS_MODE_AUDIO_TRACK, mAudioTrackList.get(0));
            } else {
                mAudioTrackList.add(mResources.getString(R.string.MediaControlView_audio_track_none_text));
            }
            if (mVideoTrackCount == 0 && mAudioTrackCount > 0) {
                mMediaType = MEDIA_TYPE_MUSIC;
            }
            List<String> subtitleTracksList = (args != null) ? args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST) : null;
            if (subtitleTracksList != null) {
                mSubtitleDescriptionsList = new ArrayList<String>();
                mSubtitleDescriptionsList.add(mResources.getString(R.string.MediaControlView_subtitle_off_text));
                for (int i = 0; i < subtitleTracksList.size(); i++) {
                    String lang = subtitleTracksList.get(i);
                    String trackDescription;
                    if (lang.equals("und")) {
                        trackDescription = mResources.getString(R.string.MediaControlView_subtitle_track_number_text, i + 1);
                    } else {
                        trackDescription = mResources.getString(R.string.MediaControlView_subtitle_track_number_and_lang_text, i + 1, lang);
                    }
                    mSubtitleDescriptionsList.add(trackDescription);
                }
                mSubtitleButton.setAlpha(1.0f);
                mSubtitleButton.setEnabled(true);
            } else {
                if (mMediaType == MEDIA_TYPE_MUSIC) {
                    mSubtitleButton.setVisibility(View.GONE);
                } else {
                    mSubtitleButton.setAlpha(0.5f);
                    mSubtitleButton.setEnabled(false);
                }
            }
            break;
        case EVENT_UPDATE_MEDIA_TYPE_STATUS:
            boolean isAd = (args != null) && args.getBoolean(KEY_STATE_IS_ADVERTISEMENT);
            if (isAd != mIsAdvertisement) {
                mIsAdvertisement = isAd;
                updateLayoutForAd();
            }
            break;
        case EVENT_UPDATE_SUBTITLE_SELECTED:
            int selectedTrackIndex = args != null ? args.getInt(KEY_SELECTED_SUBTITLE_INDEX, -1) : -1;
            if (selectedTrackIndex < 0 || selectedTrackIndex >= mSubtitleDescriptionsList.size()) {
                Log.w(TAG, "Selected subtitle track index (" + selectedTrackIndex + ") is out of range.");
                break;
            }
            mSelectedSubtitleTrackIndex = selectedTrackIndex + 1;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            mSubtitleButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_subtitle_on));
            mSubtitleButton.setContentDescription(mResources.getString(R.string.mcv2_cc_is_on));
            break;
        case EVENT_UPDATE_SUBTITLE_DESELECTED:
            mSelectedSubtitleTrackIndex = 0;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            mSubtitleButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_subtitle_off));
            mSubtitleButton.setContentDescription(mResources.getString(R.string.mcv2_cc_is_off));
            break;
        default:
            return new SessionResult(RESULT_ERROR_NOT_SUPPORTED, null);
    }
    return new SessionResult(RESULT_SUCCESS, null);
}
#end_block

#method_before
// //////////////////////////////////////////////////////////////////////////////
// MediaController methods
// //////////////////////////////////////////////////////////////////////////////
@Override
public ParcelImpl getConnectedSessionToken(String controllerId) throws RemoteException {
    MediaController controller = mMediaControllerMap.get(controllerId);
    return MediaParcelUtils.toParcelable(controller.getConnectedSessionToken());
}
#method_after
// //////////////////////////////////////////////////////////////////////////////
// MediaController methods
// //////////////////////////////////////////////////////////////////////////////
@Override
public ParcelImpl getConnectedSessionToken(String controllerId) throws RemoteException {
    MediaController controller = mMediaControllerMap.get(controllerId);
    return MediaParcelUtils.toParcelable(controller.getConnectedToken());
}
#end_block

#method_before
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final SessionCommand testCommand = new SessionCommand("testCustomCommand", null);
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "testOnCustomCommand");
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaSession.SessionCallback callback = new MediaSession.SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup commands = new SessionCommandGroup.Builder().addAllPredefinedCommands(SessionCommand.COMMAND_VERSION_1).addCommand(testCommand).build();
            return commands;
        }

        @Override
        public SessionResult onCustomCommand(MediaSession session, MediaSession.ControllerInfo controller, SessionCommand customCommand, Bundle args) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            assertEquals(testCommand, customCommand);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnCustomCommand").build()) {
        RemoteMediaController controller = createRemoteController(session.getToken());
        controller.sendCustomCommand(testCommand, testArgs);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#method_after
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final SessionCommand testCommand = new SessionCommand("testCustomCommand", null);
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "testOnCustomCommand");
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaSession.SessionCallback callback = new MediaSession.SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup commands = new SessionCommandGroup.Builder().addAllPredefinedCommands(SessionCommand.COMMAND_VERSION_1).addCommand(testCommand).build();
            return commands;
        }

        @Override
        public SessionResult onCustomCommand(MediaSession session, MediaSession.ControllerInfo controller, SessionCommand sessionCommand, Bundle args) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            assertEquals(testCommand, sessionCommand);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    try (MediaSession session = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnCustomCommand").build()) {
        RemoteMediaController controller = createRemoteController(session.getToken());
        controller.sendCustomCommand(testCommand, testArgs);
        assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testGetPackageName() throws Exception {
    prepareLooper();
    MediaController controller = createController(mRemoteSession.getToken());
    assertEquals(SERVICE_PACKAGE_NAME, controller.getConnectedSessionToken().getPackageName());
}
#method_after
@Test
public void testGetPackageName() throws Exception {
    prepareLooper();
    MediaController controller = createController(mRemoteSession.getToken());
    assertEquals(SERVICE_PACKAGE_NAME, controller.getConnectedToken().getPackageName());
}
#end_block

#method_before
@Test
public void testGetTokenExtras() throws Exception {
    prepareLooper();
    Bundle testTokenExtras = TestUtils.createTestBundle();
    RemoteMediaSession session = createRemoteMediaSession("testGetExtras", testTokenExtras);
    MediaController controller = createController(session.getToken());
    SessionToken connectedToken = controller.getConnectedSessionToken();
    assertNotNull(connectedToken);
    assertTrue(TestUtils.equals(testTokenExtras, connectedToken.getExtras()));
}
#method_after
@Test
public void testGetTokenExtras() throws Exception {
    prepareLooper();
    Bundle testTokenExtras = TestUtils.createTestBundle();
    RemoteMediaSession session = createRemoteMediaSession("testGetExtras", testTokenExtras);
    MediaController controller = createController(session.getToken());
    SessionToken connectedToken = controller.getConnectedToken();
    assertNotNull(connectedToken);
    assertTrue(TestUtils.equals(testTokenExtras, connectedToken.getExtras()));
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(SessionPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // Validate media metrics from API 21 where PersistableBundle was added.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        PersistableBundle metrics = mPlayer.getMetrics();
        if (metrics == null) {
            fail("MediaPlayer.getMetrics() returned null metrics");
        } else if (metrics.isEmpty()) {
            fail("MediaPlayer.getMetrics() returned empty metrics");
        } else {
            int size = metrics.size();
            Set<String> keys = metrics.keySet();
            if (keys == null) {
                fail("MediaMetricsSet returned no keys");
            } else if (keys.size() != size) {
                fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
            }
            // we played something; so one of these should be non-null
            String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
            String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
            if (vmime == null && amime == null) {
                fail("getMetrics() returned neither video nor audio mime value");
            }
            long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
            if (duration == -2) {
                fail("getMetrics() didn't return a duration");
            }
            long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
            if (playing == -2) {
                fail("getMetrics() didn't return a playing time");
            }
            if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
                fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
            }
        }
    }
    MediaItem item = mPlayer.getCurrentMediaItem();
    mPlayer.reset();
    assertTrue(((FileMediaItem) item).isClosed());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideo() throws Exception {
    if (!loadResource(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    final float volume = 0.5f;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    while (mPlayer.getPlayerState() == MediaPlayer.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
    // Validate media metrics from API 21 where PersistableBundle was added.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        PersistableBundle metrics = mPlayer.getMetrics();
        if (metrics == null) {
            fail("MediaPlayer.getMetrics() returned null metrics");
        } else if (metrics.isEmpty()) {
            fail("MediaPlayer.getMetrics() returned empty metrics");
        } else {
            int size = metrics.size();
            Set<String> keys = metrics.keySet();
            if (keys == null) {
                fail("MediaMetricsSet returned no keys");
            } else if (keys.size() != size) {
                fail("MediaMetricsSet.keys().size() mismatch MediaMetricsSet.size()");
            }
            // we played something; so one of these should be non-null
            String vmime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_VIDEO, null);
            String amime = metrics.getString(MediaPlayer2.MetricsConstants.MIME_TYPE_AUDIO, null);
            if (vmime == null && amime == null) {
                fail("getMetrics() returned neither video nor audio mime value");
            }
            long duration = metrics.getLong(MediaPlayer2.MetricsConstants.DURATION, -2);
            if (duration == -2) {
                fail("getMetrics() didn't return a duration");
            }
            long playing = metrics.getLong(MediaPlayer2.MetricsConstants.PLAYING, -2);
            if (playing == -2) {
                fail("getMetrics() didn't return a playing time");
            }
            if (!keys.contains(MediaPlayer2.MetricsConstants.PLAYING)) {
                fail("MediaMetricsSet.keys() missing: " + MediaPlayer2.MetricsConstants.PLAYING);
            }
        }
    }
    MediaItem item = mPlayer.getCurrentMediaItem();
    mPlayer.reset();
    assertTrue(((FileMediaItem) item).isClosed());
}
#end_block

#method_before
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideoWithUri() throws Exception {
    if (!loadResourceWithUri(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(SessionPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.KITKAT)
public void testPlayVideoWithUri() throws Exception {
    if (!loadResourceWithUri(R.raw.testvideo)) {
        fail();
    }
    final int width = 352;
    final int height = 288;
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final TestUtils.Monitor onVideoSizeChangedCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onVideoRenderingStartCalled = new TestUtils.Monitor();
    MediaPlayer.PlayerCallback callback = new MediaPlayer.PlayerCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer mp, MediaItem dsd, VideoSize size) {
            if (size.getWidth() == 0 && size.getHeight() == 0) {
                // A size of 0x0 can be sent initially one time when using NuPlayer.
                assertFalse(onVideoSizeChangedCalled.isSignalled());
                return;
            }
            onVideoSizeChangedCalled.signal();
            assertEquals(width, size.getWidth());
            assertEquals(height, size.getHeight());
        }

        @Override
        public void onError(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer mp, MediaItem dsd, int what, int extra) {
            if (what == MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START) {
                onVideoRenderingStartCalled.signal();
            }
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.prepare();
    mPlayer.play();
    onVideoSizeChangedCalled.waitForSignal();
    onVideoRenderingStartCalled.waitForSignal();
}
#end_block

#method_before
@Test
public void testGetPackageName() {
    prepareLooper();
    assertEquals(mContext.getPackageName(), mController.getConnectedSessionToken().getPackageName());
}
#method_after
@Test
public void testGetPackageName() {
    prepareLooper();
    assertEquals(mContext.getPackageName(), mController.getConnectedToken().getPackageName());
}
#end_block

#method_before
@Test
public void testSendCustomCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final String command = "test_custom_command";
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "test_args");
    final SessionCommand testCommand = new SessionCommand(command, null);
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCallback callback = new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup commands = new SessionCommandGroup.Builder(super.onConnect(session, controller)).addCommand(testCommand).build();
            return commands;
        }

        @Override
        public SessionResult onCustomCommand(MediaSession session, ControllerInfo controller, SessionCommand customCommand, Bundle args) {
            assertEquals(mContext.getPackageName(), controller.getPackageName());
            assertEquals(command, customCommand.getCustomCommand());
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    mSession.close();
    mSession = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, callback).setId(TAG).build();
    final MediaController controller = createController(mSession.getToken());
    controller.sendCustomCommand(testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testSendCustomCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final String command = "test_custom_command";
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "test_args");
    final SessionCommand testCommand = new SessionCommand(command, null);
    final CountDownLatch latch = new CountDownLatch(1);
    final SessionCallback callback = new SessionCallback() {

        @Override
        public SessionCommandGroup onConnect(@NonNull MediaSession session, @NonNull ControllerInfo controller) {
            SessionCommandGroup commands = new SessionCommandGroup.Builder(super.onConnect(session, controller)).addCommand(testCommand).build();
            return commands;
        }

        @Override
        public SessionResult onCustomCommand(MediaSession session, ControllerInfo controller, SessionCommand customCommand, Bundle args) {
            assertEquals(mContext.getPackageName(), controller.getPackageName());
            assertEquals(command, customCommand.getCustomAction());
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    mSession.close();
    mSession = new MediaSession.Builder(mContext, mPlayer).setSessionCallback(sHandlerExecutor, callback).setId(TAG).build();
    final MediaController controller = createController(mSession.getToken());
    controller.sendCustomCommand(testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public void onConnected(int seq, ParcelImpl connectionResult) {
    if (connectionResult == null) {
        // disconnected
        onDisconnected(seq);
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onConnected after MediaController.close()");
            }
            return;
        }
        ConnectionResult result = MediaParcelUtils.fromParcelable(connectionResult);
        List<MediaItem> itemList = MediaUtils.convertParcelImplListSliceToMediaItemList(result.getPlaylistSlice());
        controller.onConnectedNotLocked(result.getSessionStub(), result.getAllowedCommands(), result.getPlayerState(), result.getCurrentMediaItem(), result.getPositionEventTimeMs(), result.getPositionMs(), result.getPlaybackSpeed(), result.getBufferedPositionMs(), result.getPlaybackInfo(), result.getRepeatMode(), result.getShuffleMode(), itemList, result.getSessionActivity(), result.getCurrentMediaItemIndex(), result.getPreviousMediaItemIndex(), result.getNextMediaItemIndex(), result.getTokenExtras(), result.getVideoSize());
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void onConnected(int seq, ParcelImpl connectionResult) {
    if (connectionResult == null) {
        // disconnected
        onDisconnected(seq);
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        final MediaControllerImplBase controller = mController.get();
        if (controller == null) {
            if (DEBUG) {
                Log.d(TAG, "onConnected after MediaController.close()");
            }
            return;
        }
        ConnectionResult result = MediaParcelUtils.fromParcelable(connectionResult);
        List<MediaItem> itemList = MediaUtils.convertParcelImplListSliceToMediaItemList(result.getPlaylistSlice());
        controller.onConnectedNotLocked(result.getSessionStub(), result.getAllowedCommands(), result.getPlayerState(), result.getCurrentMediaItem(), result.getPositionEventTimeMs(), result.getPositionMs(), result.getPlaybackSpeed(), result.getBufferedPositionMs(), result.getPlaybackInfo(), result.getRepeatMode(), result.getShuffleMode(), itemList, result.getSessionActivity(), result.getCurrentMediaItemIndex(), result.getPreviousMediaItemIndex(), result.getNextMediaItemIndex(), result.getTokenExtras());
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@Test
public void testOnAllowedCommandsChanged() throws InterruptedException {
    prepareLooper();
    final SessionCommandGroup commands = new SessionCommandGroup();
    commands.addCommand(SessionCommand.COMMAND_CODE_PLAYER_PLAY);
    commands.addCommand(SessionCommand.COMMAND_CODE_PLAYER_PAUSE);
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onAllowedCommandsChanged(MediaController controller, SessionCommandGroup commandsOut) {
            assertNotNull(commandsOut);
            Set<SessionCommand> expected = commands.getCommands();
            Set<SessionCommand> actual = commandsOut.getCommands();
            assertNotNull(actual);
            assertEquals(expected.size(), actual.size());
            for (SessionCommand command : expected) {
                assertTrue(actual.contains(command));
            }
            latch.countDown();
        }
    };
    MediaController controller = createController(mRemoteSession2.getToken(), true, null, callback);
    mRemoteSession2.setAllowedCommands(TEST_CONTROLLER_INFO, commands);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnAllowedCommandsChanged() throws InterruptedException {
    prepareLooper();
    final SessionCommandGroup.Builder builder = new SessionCommandGroup.Builder();
    builder.addCommand(new SessionCommand(SessionCommand.COMMAND_CODE_PLAYER_PLAY));
    builder.addCommand(new SessionCommand(SessionCommand.COMMAND_CODE_PLAYER_PAUSE));
    final SessionCommandGroup commands = builder.build();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public void onAllowedCommandsChanged(MediaController controller, SessionCommandGroup commandsOut) {
            assertNotNull(commandsOut);
            Set<SessionCommand> expected = commands.getCommands();
            Set<SessionCommand> actual = commandsOut.getCommands();
            assertNotNull(actual);
            assertEquals(expected.size(), actual.size());
            for (SessionCommand command : expected) {
                assertTrue(actual.contains(command));
            }
            latch.countDown();
        }
    };
    MediaController controller = createController(mRemoteSession2.getToken(), true, null, callback);
    mRemoteSession2.setAllowedCommands(TEST_CONTROLLER_INFO, commands);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    final SessionCommand testCommand = new SessionCommand(SessionCommand.COMMAND_CODE_PLAYER_PREPARE);
    final Bundle testArgs = TestUtils.createTestBundle();
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(testCommand, command);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    MediaController controller = createController(mRemoteSession2.getToken(), true, null, callback);
    // TODO(jaewan): Test with multiple controllers
    mRemoteSession2.broadcastCustomCommand(testCommand, testArgs);
    // TODO(jaewan): Test receivers as well.
    mRemoteSession2.sendCustomCommand(TEST_CONTROLLER_INFO, testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    final String testCommandAction = "test_action";
    final SessionCommand testCommand = new SessionCommand(testCommandAction, null);
    final Bundle testArgs = TestUtils.createTestBundle();
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController.ControllerCallback callback = new MediaController.ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(testCommand, command);
            assertTrue(TestUtils.equals(testArgs, args));
            latch.countDown();
            return new SessionResult(RESULT_SUCCESS, null);
        }
    };
    MediaController controller = createController(mRemoteSession2.getToken(), true, null, callback);
    // TODO(jaewan): Test with multiple controllers
    mRemoteSession2.broadcastCustomCommand(testCommand, testArgs);
    // TODO(jaewan): Test receivers as well.
    mRemoteSession2.sendCustomCommand(TEST_CONTROLLER_INFO, testCommand, testArgs);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public SessionCommandGroup onConnect(MediaSession session, ControllerInfo controller) {
    if (!CLIENT_PACKAGE_NAME.equals(controller.getPackageName())) {
        return null;
    }
    SessionCommandGroup group = super.onConnect(session, controller);
    group.addCommand(new SessionCommand(CUSTOM_ACTION, null));
    group.addCommand(new SessionCommand(CUSTOM_ACTION_ASSERT_PARAMS, null));
    return group;
}
#method_after
@Override
public SessionCommandGroup onConnect(MediaSession session, ControllerInfo controller) {
    if (!CLIENT_PACKAGE_NAME.equals(controller.getPackageName())) {
        return null;
    }
    SessionCommandGroup group = super.onConnect(session, controller);
    SessionCommandGroup.Builder builder = new SessionCommandGroup.Builder(group);
    builder.addCommand(new SessionCommand(CUSTOM_ACTION, null));
    builder.addCommand(new SessionCommand(CUSTOM_ACTION_ASSERT_PARAMS, null));
    return builder.build();
}
#end_block

#method_before
@Override
public SessionResult onCustomCommand(MediaSession session, ControllerInfo controller, SessionCommand customCommand, Bundle args) {
    switch(customCommand.getCustomCommand()) {
        case CUSTOM_ACTION:
            return new SessionResult(RESULT_SUCCESS, CUSTOM_ACTION_EXTRAS);
        case CUSTOM_ACTION_ASSERT_PARAMS:
            LibraryParams params = ParcelUtils.getVersionedParcelable(args, CUSTOM_ACTION_ASSERT_PARAMS);
            setAssertLibraryParams(params);
            return new SessionResult(RESULT_SUCCESS, null);
    }
    return new SessionResult(RESULT_ERROR_BAD_VALUE, null);
}
#method_after
@Override
public SessionResult onCustomCommand(MediaSession session, ControllerInfo controller, SessionCommand sessionCommand, Bundle args) {
    switch(sessionCommand.getCustomAction()) {
        case CUSTOM_ACTION:
            return new SessionResult(RESULT_SUCCESS, CUSTOM_ACTION_EXTRAS);
        case CUSTOM_ACTION_ASSERT_PARAMS:
            LibraryParams params = ParcelUtils.getVersionedParcelable(args, CUSTOM_ACTION_ASSERT_PARAMS);
            setAssertLibraryParams(params);
            return new SessionResult(RESULT_SUCCESS, null);
    }
    return new SessionResult(RESULT_ERROR_BAD_VALUE, null);
}
#end_block

#method_before
@Test
public void testGetPackageName() throws Exception {
    prepareLooper();
    mController = createController(mSession.getSessionToken());
    assertEquals(SERVICE_PACKAGE_NAME, mController.getConnectedSessionToken().getPackageName());
}
#method_after
@Test
public void testGetPackageName() throws Exception {
    prepareLooper();
    mController = createController(mSession.getSessionToken());
    assertEquals(SERVICE_PACKAGE_NAME, mController.getConnectedToken().getPackageName());
}
#end_block

#method_before
@Test
public void testControllerCallback_onCustomCommand() throws Exception {
    prepareLooper();
    final String event = "testControllerCallback_onCustomCommand";
    final Bundle extras = TestUtils.createTestBundle();
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(event, command.getCustomCommand());
            assertTrue(TestUtils.equals(extras, args));
            latch.countDown();
            return null;
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.sendSessionEvent(event, extras);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onCustomCommand() throws Exception {
    prepareLooper();
    final String event = "testControllerCallback_onCustomCommand";
    final Bundle extras = TestUtils.createTestBundle();
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(event, command.getCustomAction());
            assertTrue(TestUtils.equals(extras, args));
            latch.countDown();
            return null;
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.sendSessionEvent(event, extras);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testControllerCallback_onSetCustomLayout() throws Exception {
    prepareLooper();
    final CustomAction testCustomAction1 = new CustomAction.Builder("testCustomAction1", "testName1", 1).build();
    final CustomAction testCustomAction2 = new CustomAction.Builder("testCustomAction2", "testName2", 2).build();
    final CountDownLatch latch = new CountDownLatch(2);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public int onSetCustomLayout(MediaController controller, List<CommandButton> layout) {
            assertEquals(1, layout.size());
            CommandButton button = layout.get(0);
            switch((int) latch.getCount()) {
                case 2:
                    assertEquals(testCustomAction1.getAction(), button.getCommand().getCustomCommand());
                    assertEquals(testCustomAction1.getName(), button.getDisplayName());
                    assertEquals(testCustomAction1.getIcon(), button.getIconResId());
                    break;
                case 1:
                    assertEquals(testCustomAction2.getAction(), button.getCommand().getCustomCommand());
                    assertEquals(testCustomAction2.getName(), button.getDisplayName());
                    assertEquals(testCustomAction2.getIcon(), button.getIconResId());
                    break;
            }
            latch.countDown();
            return SessionResult.RESULT_SUCCESS;
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction1).build());
    // onSetCustomLayout will be called when its connected
    mController = createController(mSession.getSessionToken(), true, callback);
    // onSetCustomLayout will be called again when the custom action in the playback state is
    // changed.
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction2).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onSetCustomLayout() throws Exception {
    prepareLooper();
    final CustomAction testCustomAction1 = new CustomAction.Builder("testCustomAction1", "testName1", 1).build();
    final CustomAction testCustomAction2 = new CustomAction.Builder("testCustomAction2", "testName2", 2).build();
    final CountDownLatch latch = new CountDownLatch(2);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public int onSetCustomLayout(MediaController controller, List<CommandButton> layout) {
            assertEquals(1, layout.size());
            CommandButton button = layout.get(0);
            switch((int) latch.getCount()) {
                case 2:
                    assertEquals(testCustomAction1.getAction(), button.getCommand().getCustomAction());
                    assertEquals(testCustomAction1.getName(), button.getDisplayName());
                    assertEquals(testCustomAction1.getIcon(), button.getIconResId());
                    break;
                case 1:
                    assertEquals(testCustomAction2.getAction(), button.getCommand().getCustomAction());
                    assertEquals(testCustomAction2.getName(), button.getDisplayName());
                    assertEquals(testCustomAction2.getIcon(), button.getIconResId());
                    break;
            }
            latch.countDown();
            return SessionResult.RESULT_SUCCESS;
        }
    };
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction1).build());
    // onSetCustomLayout will be called when its connected
    mController = createController(mSession.getSessionToken(), true, callback);
    // onSetCustomLayout will be called again when the custom action in the playback state is
    // changed.
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().addCustomAction(testCustomAction2).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testControllerCallback_onCustomCommand_bySetCaptioningEnabled() throws Exception {
    prepareLooper();
    final String sessionCommandOnCaptioningEnabledChanged = "android.media.session.command.ON_CAPTIONING_ENALBED_CHANGED";
    final String argumentCaptioningEnabled = "androidx.media2.argument.CAPTIONING_ENABLED";
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(sessionCommandOnCaptioningEnabledChanged, command.getCustomCommand());
            assertEquals(true, args.getBoolean(argumentCaptioningEnabled, false));
            latch.countDown();
            return new SessionResult(SessionResult.RESULT_SUCCESS, null);
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.setCaptioningEnabled(true);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testControllerCallback_onCustomCommand_bySetCaptioningEnabled() throws Exception {
    prepareLooper();
    final String sessionCommandOnCaptioningEnabledChanged = "android.media.session.command.ON_CAPTIONING_ENALBED_CHANGED";
    final String argumentCaptioningEnabled = "androidx.media2.argument.CAPTIONING_ENABLED";
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public SessionResult onCustomCommand(MediaController controller, SessionCommand command, Bundle args) {
            assertEquals(sessionCommandOnCaptioningEnabledChanged, command.getCustomAction());
            assertEquals(true, args.getBoolean(argumentCaptioningEnabled, false));
            latch.countDown();
            return new SessionResult(SessionResult.RESULT_SUCCESS, null);
        }
    };
    mController = createController(mSession.getSessionToken(), true, callback);
    mSession.setCaptioningEnabled(true);
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Override
public Cursor query(/*@NonNull*/
Uri uri, /*@Nullable*/
String[] projection, /*@Nullable*/
String selection, /*@Nullable*/
String[] selectionArgs, /*@Nullable*/
String sortOrder) {
    File file = getFileForUri(uri);
    if ("/".equals(file.getAbsolutePath())) {
        // Querying the root will list all the known file (inserted)
        final MatrixCursor cursor = new MatrixCursor(COLUMNS, mFileTracker.size());
        for (Map.Entry<Uri, ContentValues> path : mFileTracker.entrySet()) {
            String metadata = path.getValue().getAsString(COLUMN_METADATA);
            cursor.addRow(new String[] { getFileForUri(path.getKey()).getAbsolutePath(), uri.toString(), getType(path.getKey()), metadata });
        }
        return cursor;
    }
    if (!file.exists()) {
        Log.e(TAG, String.format("Query - File from uri: '%s' does not exists.", uri));
        return null;
    }
    // If a particular file is requested, find it and return it.
    List<String> filePaths = new ArrayList<>();
    if (file.isDirectory()) {
        readDirectory(filePaths, file);
    } else {
        // If not a directory, return a single row - the name of the file.
        filePaths.add(file.getAbsolutePath());
    }
    // Add all the paths to the cursor.
    final MatrixCursor cursor = new MatrixCursor(COLUMNS, filePaths.size());
    for (String path : filePaths) {
        // TODO: Return a properly formed uri for each filepath
        cursor.addRow(new String[] { path, uri.toString(), getType(uri), /**
         * metadata *
         */
        null });
    }
    return cursor;
}
#method_after
@Nullable
@Override
public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
    File file = getFileForUri(uri);
    if ("/".equals(file.getAbsolutePath())) {
        // Querying the root will list all the known file (inserted)
        final MatrixCursor cursor = new MatrixCursor(COLUMNS, mFileTracker.size());
        for (Map.Entry<Uri, ContentValues> path : mFileTracker.entrySet()) {
            String metadata = path.getValue().getAsString(COLUMN_METADATA);
            cursor.addRow(new String[] { getFileForUri(path.getKey()).getAbsolutePath(), uri.toString(), getType(path.getKey()), metadata });
        }
        return cursor;
    }
    if (!file.exists()) {
        Log.e(TAG, String.format("Query - File from uri: '%s' does not exists.", uri));
        return null;
    }
    // If a particular file is requested, find it and return it.
    List<String> filePaths = new ArrayList<>();
    if (file.isDirectory()) {
        readDirectory(filePaths, file);
    } else {
        // If not a directory, return a single row - the name of the file.
        filePaths.add(file.getAbsolutePath());
    }
    // Add all the paths to the cursor.
    final MatrixCursor cursor = new MatrixCursor(COLUMNS, filePaths.size());
    for (String path : filePaths) {
        // TODO: Return a properly formed uri for each filepath
        cursor.addRow(new String[] { path, uri.toString(), getType(uri), /* metadata */
        null });
    }
    return cursor;
}
#end_block

#method_before
@Override
public String getType(/*@NonNull*/
Uri uri) {
    final File file = getFileForUri(uri);
    final int lastDot = file.getName().lastIndexOf('.');
    if (lastDot >= 0) {
        final String extension = file.getName().substring(lastDot + 1);
        final String mime = sMimeMap.getMimeTypeFromExtension(extension);
        if (mime != null) {
            return mime;
        }
    }
    return "application/octet-stream";
}
#method_after
@Nullable
@Override
public String getType(@NonNull Uri uri) {
    final File file = getFileForUri(uri);
    final int lastDot = file.getName().lastIndexOf('.');
    if (lastDot >= 0) {
        final String extension = file.getName().substring(lastDot + 1);
        final String mime = sMimeMap.getMimeTypeFromExtension(extension);
        if (mime != null) {
            return mime;
        }
    }
    return "application/octet-stream";
}
#end_block

#method_before
@Override
public Uri insert(/*@NonNull*/
Uri uri, /*@Nullable*/
ContentValues contentValues) {
    String extra = "";
    File file = getFileForUri(uri);
    if (!file.exists()) {
        Log.e(TAG, String.format("Insert - File from uri: '%s' does not exists.", uri));
        return null;
    }
    if (mFileTracker.get(uri) != null) {
        Log.e(TAG, String.format("Insert - File from uri: '%s' already exists, ignoring.", uri));
        return null;
    }
    mFileTracker.put(uri, contentValues);
    return uri;
}
#method_after
@Nullable
@Override
public Uri insert(@NonNull Uri uri, @Nullable ContentValues contentValues) {
    String extra = "";
    File file = getFileForUri(uri);
    if (!file.exists()) {
        Log.e(TAG, String.format("Insert - File from uri: '%s' does not exists.", uri));
        return null;
    }
    if (mFileTracker.get(uri) != null) {
        Log.e(TAG, String.format("Insert - File from uri: '%s' already exists, ignoring.", uri));
        return null;
    }
    mFileTracker.put(uri, contentValues);
    return uri;
}
#end_block

#method_before
@Override
public int delete(/*@NonNull*/
Uri uri, /*@Nullable*/
String selection, /*@Nullable*/
String[] selectionArgs) {
    ContentValues values = mFileTracker.remove(uri);
    if (values == null) {
        return 0;
    }
    File file = getFileForUri(uri);
    int num = recursiveDelete(file);
    return 1;
}
#method_after
@Override
public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
    ContentValues values = mFileTracker.remove(uri);
    if (values == null) {
        return 0;
    }
    File file = getFileForUri(uri);
    int num = recursiveDelete(file);
    return 1;
}
#end_block

#method_before
@Override
public int update(/*@NonNull*/
Uri uri, /*@Nullable*/
ContentValues values, /*@Nullable*/
String selection, /*@Nullable*/
String[] selectionArgs) {
    File file = getFileForUri(uri);
    if (!file.exists()) {
        Log.e(TAG, String.format("Update - File from uri: '%s' does not exists.", uri));
        return 0;
    }
    if (mFileTracker.get(uri) == null) {
        Log.e(TAG, String.format("Update - File from uri: '%s' is not tracked yet, use insert.", uri));
        return 0;
    }
    mFileTracker.put(uri, values);
    return 1;
}
#method_after
@Override
public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
    File file = getFileForUri(uri);
    if (!file.exists()) {
        Log.e(TAG, String.format("Update - File from uri: '%s' does not exists.", uri));
        return 0;
    }
    if (mFileTracker.get(uri) == null) {
        Log.e(TAG, String.format("Update - File from uri: '%s' is not tracked yet, use insert.", uri));
        return 0;
    }
    mFileTracker.put(uri, values);
    return 1;
}
#end_block

#method_before
@Override
public ParcelFileDescriptor openFile(/*@NonNull*/
Uri uri, /*@NonNull*/
String mode) throws FileNotFoundException {
    // TODO: Track the file created via this callback (content write)
    final File file = getFileForUri(uri);
    final int fileMode = modeToMode(mode);
    if ((fileMode & ParcelFileDescriptor.MODE_CREATE) == ParcelFileDescriptor.MODE_CREATE) {
        // If the file is being created, create all its parent directories that don't already
        // exist.
        file.getParentFile().mkdirs();
        if (!mFileTracker.containsKey(uri)) {
            // Track the file, if not already tracked.
            mFileTracker.put(uri, new ContentValues());
        }
    }
    return ParcelFileDescriptor.open(file, fileMode);
}
#method_after
@Override
public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {
    final File file = getFileForUri(uri);
    final int fileMode = modeToMode(mode);
    if ((fileMode & ParcelFileDescriptor.MODE_CREATE) == ParcelFileDescriptor.MODE_CREATE) {
        // If the file is being created, create all its parent directories that don't already
        // exist.
        file.getParentFile().mkdirs();
        if (!mFileTracker.containsKey(uri)) {
            // Track the file, if not already tracked.
            mFileTracker.put(uri, new ContentValues());
        }
    }
    return ParcelFileDescriptor.open(file, fileMode);
}
#end_block

#method_before
private File getFileForUri(/*@NonNull*/
Uri uri) {
    // TODO: apply the /sdcard resolution to query() too.
    String uriPath = uri.getPath();
    if (uriPath.startsWith("/sdcard/")) {
        uriPath = uriPath.replaceAll("/sdcard", Environment.getExternalStorageDirectory().getAbsolutePath());
    }
    return new File(uriPath);
}
#method_after
private File getFileForUri(@NonNull Uri uri) {
    // TODO: apply the /sdcard resolution to query() too.
    String uriPath = uri.getPath();
    if (uriPath.startsWith("/sdcard/")) {
        uriPath = uriPath.replaceAll("/sdcard", Environment.getExternalStorageDirectory().getAbsolutePath());
    }
    return new File(uriPath);
}
#end_block

#method_before
@Override
public void postInvocationTearDown() {
    // Default implementation
    if (getIDevice() instanceof StubDevice) {
        return;
    }
    try {
        ContentProviderHandler handler = getContentProvider();
        if (handler != null) {
            handler.tearDown();
        }
    } catch (DeviceNotAvailableException e) {
        CLog.e(e);
    }
}
#method_after
@Override
public void postInvocationTearDown() {
    // Default implementation
    if (getIDevice() instanceof StubDevice) {
        return;
    }
    try {
        // If we never installed it, don't even bother checking for it during tear down.
        if (mContentProvider == null) {
            return;
        }
        ContentProviderHandler handler = getContentProvider();
        if (handler != null) {
            handler.tearDown();
        }
    } catch (DeviceNotAvailableException e) {
        CLog.e(e);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    // attachBaseContext will only be called from an Activity, so make sure we switch this for
    // Dialogs, etc
    mBaseContextAttached = true;
    applyDayNight();
    // We lazily fetch the Window for Activities, to allow DayNight to apply in
    // attachBaseContext
    ensureWindow();
    if (mHost instanceof Activity) {
        String parentActivityName = null;
        try {
            parentActivityName = NavUtils.getParentActivityName((Activity) mHost);
        } catch (IllegalArgumentException iae) {
        // Ignore in this case
        }
        if (parentActivityName != null) {
            // Peek at the Action Bar and update it if it already exists
            ActionBar ab = peekSupportActionBar();
            if (ab == null) {
                mEnableDefaultActionBarUp = true;
            } else {
                ab.setDefaultDisplayHomeAsUpEnabled(true);
            }
        }
    }
    mCreated = true;
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    // attachBaseContext will only be called from an Activity, so make sure we switch this for
    // Dialogs, etc
    mBaseContextAttached = true;
    // Calling Activity.recreate() if we fail to apply the configuration during create() is
    // likely to cause a loop, especially if the Activity is touching Resources or Assets prior
    // to calling super.onCreate().
    applyDayNight(false);
    // We lazily fetch the Window for Activities, to allow DayNight to apply in
    // attachBaseContext
    ensureWindow();
    if (mHost instanceof Activity) {
        String parentActivityName = null;
        try {
            parentActivityName = NavUtils.getParentActivityName((Activity) mHost);
        } catch (IllegalArgumentException iae) {
        // Ignore in this case
        }
        if (parentActivityName != null) {
            // Peek at the Action Bar and update it if it already exists
            ActionBar ab = peekSupportActionBar();
            if (ab == null) {
                mEnableDefaultActionBarUp = true;
            } else {
                ab.setDefaultDisplayHomeAsUpEnabled(true);
            }
        }
    }
    mCreated = true;
}
#end_block

#method_before
private boolean updateForNightMode(@ApplyableNightMode final int mode, final boolean allowRecreation) {
    boolean handled = false;
    Exception exception = null;
    final int applicationNightMode = mContext.getApplicationContext().getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;
    int newNightMode;
    switch(mode) {
        case MODE_NIGHT_YES:
            newNightMode = Configuration.UI_MODE_NIGHT_YES;
            break;
        case MODE_NIGHT_NO:
            newNightMode = Configuration.UI_MODE_NIGHT_NO;
            break;
        default:
        case MODE_NIGHT_FOLLOW_SYSTEM:
            // If we're following the system, we just use the system default from the
            // application context
            newNightMode = applicationNightMode;
            break;
    }
    final boolean activityHandlingUiMode = isActivityManifestHandlingUiMode();
    if (newNightMode != applicationNightMode && !activityHandlingUiMode && Build.VERSION.SDK_INT >= 17 && !mBaseContextAttached && mHost instanceof android.view.ContextThemeWrapper) {
        // If we're here then we can try and apply an override configuration on the Context.
        final Configuration conf = new Configuration();
        conf.uiMode = newNightMode | (conf.uiMode & ~Configuration.UI_MODE_NIGHT_MASK);
        try {
            if (DEBUG) {
                Log.d(TAG, "updateForNightMode. Applying override config");
            }
            ((android.view.ContextThemeWrapper) mHost).applyOverrideConfiguration(conf);
            handled = true;
        } catch (IllegalStateException e) {
            // applyOverrideConfiguration throws an IllegalStateException if it's resources
            // have already been created. Since there's no way to check this beforehand we
            // just have to try it and catch the exception
            exception = e;
            handled = false;
        }
    }
    if (!handled && !activityHandlingUiMode) {
        final int currentNightMode = mContext.getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;
        if (currentNightMode != newNightMode) {
            if (allowRecreation && (Build.VERSION.SDK_INT >= 17 || mCreated) && mHost instanceof Activity) {
                // On < API 17 we need to use updateConfiguration before we're 'created'
                if (DEBUG) {
                    Log.d(TAG, "updateForNightMode. Recreating Activity");
                }
                ActivityCompat.recreate((Activity) mHost);
                handled = true;
            }
            if (!handled) {
                // Else we need to use the updateConfiguration path
                if (DEBUG) {
                    Log.d(TAG, "updateForNightMode. Updating resources config");
                }
                updateResourcesConfigurationForNightMode(newNightMode);
                handled = true;
            }
        } else {
            if (DEBUG) {
                Log.d(TAG, "updateForNightMode. Skipping. Night mode: " + mode);
            }
        }
    }
    // or the Activity is set to handle uiMode changes
    if ((handled || activityHandlingUiMode) && mHost instanceof AppCompatActivity) {
        ((AppCompatActivity) mHost).onNightModeChanged(mode);
    }
    if (!handled && exception != null) {
        Log.e(TAG, "updateForNightMode failed due to exception", exception);
    }
    return handled;
}
#method_after
private boolean updateForNightMode(@ApplyableNightMode final int mode, final boolean allowRecreation) {
    boolean handled = false;
    Exception exception = null;
    final int applicationNightMode = mContext.getApplicationContext().getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;
    int newNightMode;
    switch(mode) {
        case MODE_NIGHT_YES:
            newNightMode = Configuration.UI_MODE_NIGHT_YES;
            break;
        case MODE_NIGHT_NO:
            newNightMode = Configuration.UI_MODE_NIGHT_NO;
            break;
        default:
        case MODE_NIGHT_FOLLOW_SYSTEM:
            // If we're following the system, we just use the system default from the
            // application context
            newNightMode = applicationNightMode;
            break;
    }
    final boolean activityHandlingUiMode = isActivityManifestHandlingUiMode();
    if (newNightMode != applicationNightMode && !activityHandlingUiMode && Build.VERSION.SDK_INT >= 17 && !mBaseContextAttached && mHost instanceof android.view.ContextThemeWrapper) {
        // If we're here then we can try and apply an override configuration on the Context.
        final Configuration conf = new Configuration();
        conf.uiMode = newNightMode | (conf.uiMode & ~Configuration.UI_MODE_NIGHT_MASK);
        try {
            if (DEBUG) {
                Log.d(TAG, "updateForNightMode. Applying override config");
            }
            ((android.view.ContextThemeWrapper) mHost).applyOverrideConfiguration(conf);
            handled = true;
        } catch (IllegalStateException e) {
            // applyOverrideConfiguration throws an IllegalStateException if its resources
            // have already been created. Since there's no way to check this beforehand we
            // just have to try it and catch the exception.
            exception = e;
            handled = false;
        }
    }
    if (!handled && !activityHandlingUiMode) {
        final int currentNightMode = mContext.getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;
        if (currentNightMode != newNightMode) {
            if (allowRecreation && (Build.VERSION.SDK_INT >= 17 || mCreated) && mHost instanceof Activity) {
                // On < API 17 we need to use updateConfiguration before we're 'created'
                if (DEBUG) {
                    Log.d(TAG, "updateForNightMode. Recreating Activity");
                }
                ActivityCompat.recreate((Activity) mHost);
                handled = true;
            }
            if (!handled) {
                // Else we need to use the updateConfiguration path
                if (DEBUG) {
                    Log.d(TAG, "updateForNightMode. Updating resources config");
                }
                updateResourcesConfigurationForNightMode(newNightMode);
                handled = true;
            }
        } else {
            if (DEBUG) {
                Log.d(TAG, "updateForNightMode. Skipping. Night mode: " + mode);
            }
        }
    }
    // or the Activity is set to handle uiMode changes
    if ((handled || activityHandlingUiMode) && mHost instanceof AppCompatActivity) {
        ((AppCompatActivity) mHost).onNightModeChanged(mode);
    }
    if (!handled && exception != null) {
        Log.e(TAG, "updateForNightMode failed due to exception", exception);
    }
    return handled;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    // taken care of restoring the fragments we previously had instantiated.
    if (mFragments.size() > position) {
        Fragment f = mFragments.get(position);
        if (f != null) {
            return f;
        }
    }
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    Fragment fragment = getItem(position);
    if (DEBUG)
        Log.v(TAG, "Adding item #" + position + ": f=" + fragment);
    if (mSavedState.size() > position) {
        Fragment.SavedState fss = mSavedState.get(position);
        if (fss != null) {
            fragment.setInitialSavedState(fss);
        }
    }
    while (mFragments.size() <= position) {
        mFragments.add(null);
    }
    fragment.setMenuVisibility(false);
    if (mOption == USE_SET_USER_VISIBLE_HINT) {
        fragment.setUserVisibleHint(false);
    }
    mFragments.set(position, fragment);
    mCurTransaction.add(container.getId(), fragment);
    if (mOption == RESUME_ONLY_CURRENT_FRAGMENT) {
        mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED);
    }
    return fragment;
}
#method_after
@SuppressWarnings("deprecation")
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    // taken care of restoring the fragments we previously had instantiated.
    if (mFragments.size() > position) {
        Fragment f = mFragments.get(position);
        if (f != null) {
            return f;
        }
    }
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    Fragment fragment = getItem(position);
    if (DEBUG)
        Log.v(TAG, "Adding item #" + position + ": f=" + fragment);
    if (mSavedState.size() > position) {
        Fragment.SavedState fss = mSavedState.get(position);
        if (fss != null) {
            fragment.setInitialSavedState(fss);
        }
    }
    while (mFragments.size() <= position) {
        mFragments.add(null);
    }
    fragment.setMenuVisibility(false);
    if (mBehavior == USE_SET_USER_VISIBLE_HINT) {
        fragment.setUserVisibleHint(false);
    }
    mFragments.set(position, fragment);
    mCurTransaction.add(container.getId(), fragment);
    if (mBehavior == RESUME_ONLY_CURRENT_FRAGMENT) {
        mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED);
    }
    return fragment;
}
#end_block

#method_before
@Override
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mOption == RESUME_ONLY_CURRENT_FRAGMENT) {
                mCurTransaction = mCurTransaction != null ? mCurTransaction : mFragmentManager.beginTransaction();
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                mCurrentPrimaryItem.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mOption == RESUME_ONLY_CURRENT_FRAGMENT) {
            mCurTransaction = mCurTransaction != null ? mCurTransaction : mFragmentManager.beginTransaction();
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#method_after
@Override
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mBehavior == RESUME_ONLY_CURRENT_FRAGMENT) {
                if (mCurTransaction == null) {
                    mCurTransaction = mFragmentManager.beginTransaction();
                }
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                mCurrentPrimaryItem.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mBehavior == RESUME_ONLY_CURRENT_FRAGMENT) {
            if (mCurTransaction == null) {
                mCurTransaction = mFragmentManager.beginTransaction();
            }
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#end_block

#method_before
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    final long itemId = getItemId(position);
    // Do we already have this fragment?
    String name = makeFragmentName(container.getId(), itemId);
    Fragment fragment = mFragmentManager.findFragmentByTag(name);
    if (fragment != null) {
        if (DEBUG)
            Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment);
        mCurTransaction.attach(fragment);
    } else {
        fragment = getItem(position);
        if (DEBUG)
            Log.v(TAG, "Adding item #" + itemId + ": f=" + fragment);
        mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));
    }
    if (fragment != mCurrentPrimaryItem) {
        fragment.setMenuVisibility(false);
        if (mOption == RESUME_ONLY_CURRENT_FRAGMENT) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED);
        } else {
            fragment.setUserVisibleHint(false);
        }
    }
    return fragment;
}
#method_after
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    final long itemId = getItemId(position);
    // Do we already have this fragment?
    String name = makeFragmentName(container.getId(), itemId);
    Fragment fragment = mFragmentManager.findFragmentByTag(name);
    if (fragment != null) {
        if (DEBUG)
            Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment);
        mCurTransaction.attach(fragment);
    } else {
        fragment = getItem(position);
        if (DEBUG)
            Log.v(TAG, "Adding item #" + itemId + ": f=" + fragment);
        mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));
    }
    if (fragment != mCurrentPrimaryItem) {
        fragment.setMenuVisibility(false);
        if (mBehavior == RESUME_ONLY_CURRENT_FRAGMENT) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED);
        } else {
            fragment.setUserVisibleHint(false);
        }
    }
    return fragment;
}
#end_block

#method_before
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@Override
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mOption == RESUME_ONLY_CURRENT_FRAGMENT) {
                mCurTransaction = mCurTransaction != null ? mCurTransaction : mFragmentManager.beginTransaction();
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                mCurrentPrimaryItem.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mOption == RESUME_ONLY_CURRENT_FRAGMENT) {
            mCurTransaction = mCurTransaction != null ? mCurTransaction : mFragmentManager.beginTransaction();
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#method_after
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@Override
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mBehavior == RESUME_ONLY_CURRENT_FRAGMENT) {
                if (mCurTransaction == null) {
                    mCurTransaction = mFragmentManager.beginTransaction();
                }
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                mCurrentPrimaryItem.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mBehavior == RESUME_ONLY_CURRENT_FRAGMENT) {
            if (mCurTransaction == null) {
                mCurTransaction = mFragmentManager.beginTransaction();
            }
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#end_block

#method_before
ListenableFuture<Void> issueTakePicture() {
    final List<ListenableFuture<Void>> futureList = new ArrayList<>();
    final List<CaptureConfig> captureConfigs = new ArrayList<>();
    for (final CaptureStage captureStage : mCaptureBundle.getCaptureStages()) {
        final CaptureConfig.Builder builder = new CaptureConfig.Builder();
        builder.addSurface(new ImmediateSurface(mImageReader.getSurface()));
        builder.setTemplateType(CameraDevice.TEMPLATE_STILL_CAPTURE);
        applyPixelHdrPlusChangeForCaptureMode(mCaptureMode, builder);
        builder.addImplementationOptions(captureStage.getCaptureConfig().getImplementationOptions());
        builder.setTag(captureStage.getCaptureConfig().getTag());
        builder.addCameraCaptureCallback(mMetadataMatchingCaptureCallback);
        ListenableFuture<Void> future = CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

            @Override
            public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
                CameraCaptureCallback completerCallback = new CameraCaptureCallback() {

                    @Override
                    public void onCaptureCompleted(@NonNull CameraCaptureResult result) {
                        completer.set(null);
                    }

                    @Override
                    public void onCaptureFailed(@NonNull CameraCaptureFailure failure) {
                        Log.e(TAG, "capture picture get onCaptureFailed with reason " + failure.getReason());
                        completer.set(null);
                    }
                };
                builder.addCameraCaptureCallback(completerCallback);
                captureConfigs.add(builder.build());
                return "issueTakePicture[stage=" + captureStage.getId() + "]";
            }
        });
        futureList.add(future);
    }
    getCurrentCameraControl().submitCaptureRequest(captureConfigs);
    return CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

        @Override
        public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
            ListenableFuture<List<Void>> combinedFuture = Futures.successfulAsList(futureList);
            Futures.addCallback(combinedFuture, new FutureCallback<List<Void>>() {

                @Override
                public void onSuccess(@Nullable List<Void> result) {
                    completer.set(null);
                }

                @Override
                public void onFailure(Throwable t) {
                    completer.setException(t);
                }
            }, CameraXExecutors.directExecutor());
            return "issueTakePicture";
        }
    });
}
#method_after
ListenableFuture<Void> issueTakePicture() {
    final List<ListenableFuture<Void>> futureList = new ArrayList<>();
    final List<CaptureConfig> captureConfigs = new ArrayList<>();
    for (final CaptureStage captureStage : mCaptureBundle.getCaptureStages()) {
        final CaptureConfig.Builder builder = new CaptureConfig.Builder();
        builder.addSurface(new ImmediateSurface(mImageReader.getSurface()));
        builder.setTemplateType(CameraDevice.TEMPLATE_STILL_CAPTURE);
        applyPixelHdrPlusChangeForCaptureMode(mCaptureMode, builder);
        builder.addImplementationOptions(captureStage.getCaptureConfig().getImplementationOptions());
        builder.setTag(captureStage.getCaptureConfig().getTag());
        builder.addCameraCaptureCallback(mMetadataMatchingCaptureCallback);
        ListenableFuture<Void> future = CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

            @Override
            public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
                CameraCaptureCallback completerCallback = new CameraCaptureCallback() {

                    @Override
                    public void onCaptureCompleted(@NonNull CameraCaptureResult result) {
                        completer.set(null);
                    }

                    @Override
                    public void onCaptureFailed(@NonNull CameraCaptureFailure failure) {
                        Log.e(TAG, "capture picture get onCaptureFailed with reason " + failure.getReason());
                        completer.set(null);
                    }
                };
                builder.addCameraCaptureCallback(completerCallback);
                captureConfigs.add(builder.build());
                return "issueTakePicture[stage=" + captureStage.getId() + "]";
            }
        });
        futureList.add(future);
    }
    getCurrentCameraControl().submitCaptureRequests(captureConfigs);
    return CallbackToFutureAdapter.getFuture(new CallbackToFutureAdapter.Resolver<Void>() {

        @Override
        public Object attachCompleter(@NonNull final CallbackToFutureAdapter.Completer<Void> completer) {
            ListenableFuture<List<Void>> combinedFuture = Futures.successfulAsList(futureList);
            Futures.addCallback(combinedFuture, new FutureCallback<List<Void>>() {

                @Override
                public void onSuccess(@Nullable List<Void> result) {
                    completer.set(null);
                }

                @Override
                public void onFailure(Throwable t) {
                    completer.setException(t);
                }
            }, CameraXExecutors.directExecutor());
            return "issueTakePicture";
        }
    });
}
#end_block

#method_before
@VisibleForTesting
void cancelFocus() {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.cancelFocus();
            }
        });
        return;
    }
    mHandler.removeCallbacks(mHandleFocusTimeoutRunnable);
    MeteringRectangle zeroRegion = new MeteringRectangle(new Rect(), MeteringRectangle.METERING_WEIGHT_DONT_CARE);
    mAfRect = zeroRegion;
    mAeRect = zeroRegion;
    mAwbRect = zeroRegion;
    // Send a single request to cancel af process
    CaptureConfig.Builder singleRequestBuilder = createCaptureBuilderWithSharedOptions();
    singleRequestBuilder.setTemplateType(getDefaultTemplate());
    singleRequestBuilder.setUseRepeatingSurface(true);
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
    singleRequestBuilder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequest(Collections.singletonList(singleRequestBuilder.build()));
    mIsFocusLocked = false;
    updateSessionConfig();
}
#method_after
@VisibleForTesting
void cancelFocus() {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.cancelFocus();
            }
        });
        return;
    }
    mHandler.removeCallbacks(mHandleFocusTimeoutRunnable);
    MeteringRectangle zeroRegion = new MeteringRectangle(new Rect(), MeteringRectangle.METERING_WEIGHT_DONT_CARE);
    mAfRect = zeroRegion;
    mAeRect = zeroRegion;
    mAwbRect = zeroRegion;
    // Send a single request to cancel af process
    CaptureConfig.Builder singleRequestBuilder = createCaptureBuilderWithSharedOptions();
    singleRequestBuilder.setTemplateType(getDefaultTemplate());
    singleRequestBuilder.setUseRepeatingSurface(true);
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
    singleRequestBuilder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequests(Collections.singletonList(singleRequestBuilder.build()));
    mIsFocusLocked = false;
    updateSessionConfig();
}
#end_block

#method_before
void enableTorchInternal(final boolean torch) {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.enableTorchInternal(torch);
            }
        });
        return;
    }
    if (!torch) {
        CaptureConfig.Builder singleRequestBuilder = createCaptureBuilderWithSharedOptions();
        singleRequestBuilder.setTemplateType(getDefaultTemplate());
        singleRequestBuilder.setUseRepeatingSurface(true);
        Camera2Config.Builder configBuilder = new Camera2Config.Builder();
        configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON);
        singleRequestBuilder.addImplementationOptions(configBuilder.build());
        notifyCaptureRequest(Collections.singletonList(singleRequestBuilder.build()));
    }
    updateSessionConfig();
}
#method_after
void enableTorchInternal(final boolean torch) {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.enableTorchInternal(torch);
            }
        });
        return;
    }
    if (!torch) {
        CaptureConfig.Builder singleRequestBuilder = createCaptureBuilderWithSharedOptions();
        singleRequestBuilder.setTemplateType(getDefaultTemplate());
        singleRequestBuilder.setUseRepeatingSurface(true);
        Camera2Config.Builder configBuilder = new Camera2Config.Builder();
        configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON);
        singleRequestBuilder.addImplementationOptions(configBuilder.build());
        notifyCaptureRequests(Collections.singletonList(singleRequestBuilder.build()));
    }
    updateSessionConfig();
}
#end_block

#method_before
@Override
public void triggerAf() {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.triggerAf();
            }
        });
        return;
    }
    CaptureConfig.Builder builder = createCaptureBuilderWithSharedOptions();
    builder.setTemplateType(getDefaultTemplate());
    builder.setUseRepeatingSurface(true);
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_START);
    builder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequest(Collections.singletonList(builder.build()));
}
#method_after
@Override
public void triggerAf() {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.triggerAf();
            }
        });
        return;
    }
    CaptureConfig.Builder builder = createCaptureBuilderWithSharedOptions();
    builder.setTemplateType(getDefaultTemplate());
    builder.setUseRepeatingSurface(true);
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_START);
    builder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequests(Collections.singletonList(builder.build()));
}
#end_block

#method_before
@Override
public void triggerAePrecapture() {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.triggerAePrecapture();
            }
        });
        return;
    }
    CaptureConfig.Builder builder = createCaptureBuilderWithSharedOptions();
    builder.setTemplateType(getDefaultTemplate());
    builder.setUseRepeatingSurface(true);
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);
    builder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequest(Collections.singletonList(builder.build()));
}
#method_after
@Override
public void triggerAePrecapture() {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.triggerAePrecapture();
            }
        });
        return;
    }
    CaptureConfig.Builder builder = createCaptureBuilderWithSharedOptions();
    builder.setTemplateType(getDefaultTemplate());
    builder.setUseRepeatingSurface(true);
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);
    builder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequests(Collections.singletonList(builder.build()));
}
#end_block

#method_before
@Override
public void cancelAfAeTrigger(final boolean cancelAfTrigger, final boolean cancelAePrecaptureTrigger) {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.cancelAfAeTrigger(cancelAfTrigger, cancelAePrecaptureTrigger);
            }
        });
        return;
    }
    CaptureConfig.Builder builder = createCaptureBuilderWithSharedOptions();
    builder.setUseRepeatingSurface(true);
    builder.setTemplateType(getDefaultTemplate());
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    if (cancelAfTrigger) {
        configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
    }
    if (cancelAePrecaptureTrigger) {
        configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL);
    }
    builder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequest(Collections.singletonList(builder.build()));
}
#method_after
@Override
public void cancelAfAeTrigger(final boolean cancelAfTrigger, final boolean cancelAePrecaptureTrigger) {
    if (Looper.myLooper() != mHandler.getLooper()) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                Camera2CameraControl.this.cancelAfAeTrigger(cancelAfTrigger, cancelAePrecaptureTrigger);
            }
        });
        return;
    }
    CaptureConfig.Builder builder = createCaptureBuilderWithSharedOptions();
    builder.setUseRepeatingSurface(true);
    builder.setTemplateType(getDefaultTemplate());
    Camera2Config.Builder configBuilder = new Camera2Config.Builder();
    if (cancelAfTrigger) {
        configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
    }
    if (cancelAePrecaptureTrigger) {
        configBuilder.setCaptureRequestOption(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_CANCEL);
    }
    builder.addImplementationOptions(configBuilder.build());
    notifyCaptureRequests(Collections.singletonList(builder.build()));
}
#end_block

#method_before
@Override
public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {
    List<CameraCaptureCallback> cameraCaptureCallback = mCallbackMap.get(request);
    for (CameraCaptureCallback cb : cameraCaptureCallback) {
        cb.onCaptureCompleted(new Camera2CameraCaptureResult(request.getTag(), result));
    }
}
#method_after
@Override
public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {
    List<CameraCaptureCallback> cameraCaptureCallbacks = mCallbackMap.get(request);
    for (CameraCaptureCallback cb : cameraCaptureCallbacks) {
        cb.onCaptureCompleted(new Camera2CameraCaptureResult(request.getTag(), result));
    }
}
#end_block

#method_before
@Override
public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure) {
    List<CameraCaptureCallback> cameraCaptureCallback = mCallbackMap.get(request);
    CameraCaptureFailure cameraFailure = new CameraCaptureFailure(CameraCaptureFailure.Reason.ERROR);
    for (CameraCaptureCallback cb : cameraCaptureCallback) {
        cb.onCaptureFailed(cameraFailure);
    }
}
#method_after
@Override
public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure) {
    List<CameraCaptureCallback> cameraCaptureCallbacks = mCallbackMap.get(request);
    CameraCaptureFailure cameraFailure = new CameraCaptureFailure(CameraCaptureFailure.Reason.ERROR);
    for (CameraCaptureCallback cb : cameraCaptureCallbacks) {
        cb.onCaptureFailed(cameraFailure);
    }
}
#end_block

#method_before
@Test
@UiThreadTest
public void focus_focusRectSetAndRequestsExecuted() {
    Rect focusRect = new Rect(0, 0, 10, 10);
    Rect meteringRect = new Rect(20, 20, 30, 30);
    mCamera2CameraControl.focus(focusRect, meteringRect);
    verify(mControlUpdateListener, times(1)).onCameraControlUpdateSessionConfig(mSessionConfigArgumentCaptor.capture());
    SessionConfig sessionConfig = mSessionConfigArgumentCaptor.getValue();
    Camera2Config repeatingConfig = new Camera2Config(sessionConfig.getImplementationOptions());
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(focusRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    Camera2Config singleConfig = new Camera2Config(mCamera2CameraControl.getSharedOptions());
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(focusRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(mCamera2CameraControl.isFocusLocked()).isTrue();
    verify(mControlUpdateListener).onCameraControlCaptureRequest(mCaptureConfigArgumentCaptor.capture());
    CaptureConfig captureConfig = mCaptureConfigArgumentCaptor.getValue().get(0);
    Camera2Config resultCaptureConfig = new Camera2Config(captureConfig.getImplementationOptions());
    assertThat(resultCaptureConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, null)).isEqualTo(CaptureRequest.CONTROL_AF_TRIGGER_START);
}
#method_after
@Test
@UiThreadTest
public void focus_focusRectSetAndRequestsExecuted() {
    Rect focusRect = new Rect(0, 0, 10, 10);
    Rect meteringRect = new Rect(20, 20, 30, 30);
    mCamera2CameraControl.focus(focusRect, meteringRect);
    verify(mControlUpdateListener, times(1)).onCameraControlUpdateSessionConfig(mSessionConfigArgumentCaptor.capture());
    SessionConfig sessionConfig = mSessionConfigArgumentCaptor.getValue();
    Camera2Config repeatingConfig = new Camera2Config(sessionConfig.getImplementationOptions());
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(focusRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    Camera2Config singleConfig = new Camera2Config(mCamera2CameraControl.getSharedOptions());
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(focusRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { new MeteringRectangle(meteringRect, MeteringRectangle.METERING_WEIGHT_MAX) });
    assertThat(mCamera2CameraControl.isFocusLocked()).isTrue();
    verify(mControlUpdateListener).onCameraControlCaptureRequests(mCaptureConfigArgumentCaptor.capture());
    CaptureConfig captureConfig = mCaptureConfigArgumentCaptor.getValue().get(0);
    Camera2Config resultCaptureConfig = new Camera2Config(captureConfig.getImplementationOptions());
    assertThat(resultCaptureConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, null)).isEqualTo(CaptureRequest.CONTROL_AF_TRIGGER_START);
}
#end_block

#method_before
@Test
@UiThreadTest
public void cancelFocus_regionRestored() {
    Rect focusRect = new Rect(0, 0, 10, 10);
    Rect meteringRect = new Rect(20, 20, 30, 30);
    mCamera2CameraControl.focus(focusRect, meteringRect);
    mCamera2CameraControl.cancelFocus();
    verify(mControlUpdateListener, times(2)).onCameraControlUpdateSessionConfig(mSessionConfigArgumentCaptor.capture());
    SessionConfig sessionConfig = mSessionConfigArgumentCaptor.getAllValues().get(1);
    Camera2Config repeatingConfig = new Camera2Config(sessionConfig.getImplementationOptions());
    MeteringRectangle zeroRegion = new MeteringRectangle(new Rect(), MeteringRectangle.METERING_WEIGHT_DONT_CARE);
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    Camera2Config singleConfig = new Camera2Config(mCamera2CameraControl.getSharedOptions());
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(mCamera2CameraControl.isFocusLocked()).isFalse();
    verify(mControlUpdateListener, times(2)).onCameraControlCaptureRequest(mCaptureConfigArgumentCaptor.capture());
    CaptureConfig captureConfig = mCaptureConfigArgumentCaptor.getAllValues().get(1).get(0);
    Camera2Config resultCaptureConfig = new Camera2Config(captureConfig.getImplementationOptions());
    assertThat(resultCaptureConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, null)).isEqualTo(CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
}
#method_after
@Test
@UiThreadTest
public void cancelFocus_regionRestored() {
    Rect focusRect = new Rect(0, 0, 10, 10);
    Rect meteringRect = new Rect(20, 20, 30, 30);
    mCamera2CameraControl.focus(focusRect, meteringRect);
    mCamera2CameraControl.cancelFocus();
    verify(mControlUpdateListener, times(2)).onCameraControlUpdateSessionConfig(mSessionConfigArgumentCaptor.capture());
    SessionConfig sessionConfig = mSessionConfigArgumentCaptor.getAllValues().get(1);
    Camera2Config repeatingConfig = new Camera2Config(sessionConfig.getImplementationOptions());
    MeteringRectangle zeroRegion = new MeteringRectangle(new Rect(), MeteringRectangle.METERING_WEIGHT_DONT_CARE);
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(repeatingConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    Camera2Config singleConfig = new Camera2Config(mCamera2CameraControl.getSharedOptions());
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(singleConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AWB_REGIONS, null)).isEqualTo(new MeteringRectangle[] { zeroRegion });
    assertThat(mCamera2CameraControl.isFocusLocked()).isFalse();
    verify(mControlUpdateListener, times(2)).onCameraControlCaptureRequests(mCaptureConfigArgumentCaptor.capture());
    CaptureConfig captureConfig = mCaptureConfigArgumentCaptor.getAllValues().get(1).get(0);
    Camera2Config resultCaptureConfig = new Camera2Config(captureConfig.getImplementationOptions());
    assertThat(resultCaptureConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AF_TRIGGER, null)).isEqualTo(CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
}
#end_block

#method_before
@Test
@UiThreadTest
public void disableTorchFlashModeAuto_aeModeSetAndRequestUpdated() {
    mCamera2CameraControl.setFlashMode(FlashMode.AUTO);
    mCamera2CameraControl.enableTorch(false);
    verify(mControlUpdateListener, times(2)).onCameraControlUpdateSessionConfig(mSessionConfigArgumentCaptor.capture());
    SessionConfig sessionConfig = mSessionConfigArgumentCaptor.getAllValues().get(0);
    Camera2Config camera2Config = new Camera2Config(sessionConfig.getImplementationOptions());
    assertThat(camera2Config.getCaptureRequestOption(CaptureRequest.CONTROL_AE_MODE, CONTROL_AE_MODE_OFF)).isEqualTo(CONTROL_AE_MODE_ON_AUTO_FLASH);
    assertThat(camera2Config.getCaptureRequestOption(CaptureRequest.FLASH_MODE, -1)).isEqualTo(-1);
    assertThat(mCamera2CameraControl.isTorchOn()).isFalse();
    verify(mControlUpdateListener, times(1)).onCameraControlCaptureRequest(mCaptureConfigArgumentCaptor.capture());
    CaptureConfig captureConfig = mCaptureConfigArgumentCaptor.getValue().get(0);
    Camera2Config resultCaptureConfig = new Camera2Config(captureConfig.getImplementationOptions());
    assertThat(resultCaptureConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_MODE, null)).isEqualTo(CaptureRequest.CONTROL_AE_MODE_ON);
}
#method_after
@Test
@UiThreadTest
public void disableTorchFlashModeAuto_aeModeSetAndRequestUpdated() {
    mCamera2CameraControl.setFlashMode(FlashMode.AUTO);
    mCamera2CameraControl.enableTorch(false);
    verify(mControlUpdateListener, times(2)).onCameraControlUpdateSessionConfig(mSessionConfigArgumentCaptor.capture());
    SessionConfig sessionConfig = mSessionConfigArgumentCaptor.getAllValues().get(0);
    Camera2Config camera2Config = new Camera2Config(sessionConfig.getImplementationOptions());
    assertThat(camera2Config.getCaptureRequestOption(CaptureRequest.CONTROL_AE_MODE, CONTROL_AE_MODE_OFF)).isEqualTo(CONTROL_AE_MODE_ON_AUTO_FLASH);
    assertThat(camera2Config.getCaptureRequestOption(CaptureRequest.FLASH_MODE, -1)).isEqualTo(-1);
    assertThat(mCamera2CameraControl.isTorchOn()).isFalse();
    verify(mControlUpdateListener, times(1)).onCameraControlCaptureRequests(mCaptureConfigArgumentCaptor.capture());
    CaptureConfig captureConfig = mCaptureConfigArgumentCaptor.getValue().get(0);
    Camera2Config resultCaptureConfig = new Camera2Config(captureConfig.getImplementationOptions());
    assertThat(resultCaptureConfig.getCaptureRequestOption(CaptureRequest.CONTROL_AE_MODE, null)).isEqualTo(CaptureRequest.CONTROL_AE_MODE_ON);
}
#end_block

#method_before
private CameraControl getFakeCameraControl() {
    return new Camera2CameraControl(new CameraControl.ControlUpdateListener() {

        @Override
        public void onCameraControlUpdateSessionConfig(SessionConfig sessionConfig) {
        }

        @Override
        public void onCameraControlCaptureRequest(List<CaptureConfig> captureConfigs) {
        }
    }, new Handler());
}
#method_after
private CameraControl getFakeCameraControl() {
    return new Camera2CameraControl(new CameraControl.ControlUpdateListener() {

        @Override
        public void onCameraControlUpdateSessionConfig(SessionConfig sessionConfig) {
        }

        @Override
        public void onCameraControlCaptureRequests(List<CaptureConfig> captureConfigs) {
        }
    }, new Handler());
}
#end_block

#method_before
void resetCaptureSession() {
    Log.d(TAG, "Closing Capture Session");
    // Recreate an initialized (but not opened) capture session from the previous configuration
    SessionConfig previousSessionConfig = mCaptureSession.getSessionConfig();
    mCaptureSession.close();
    List<CaptureConfig> unissuedCaptureConfigs = mCaptureSession.getCaptureConfigs();
    mCaptureSession = new CaptureSession(mHandler);
    mCaptureSession.setSessionConfig(previousSessionConfig);
    // When the previous capture session has not reached the open state, the issued single
    // capture
    // requests will still be in request queue and will need to be passed to the next capture
    // session.
    mCaptureSession.issueCaptureRequest(unissuedCaptureConfigs);
}
#method_after
void resetCaptureSession() {
    Log.d(TAG, "Closing Capture Session");
    // Recreate an initialized (but not opened) capture session from the previous configuration
    SessionConfig previousSessionConfig = mCaptureSession.getSessionConfig();
    mCaptureSession.close();
    List<CaptureConfig> unissuedCaptureConfigs = mCaptureSession.getCaptureConfigs();
    mCaptureSession = new CaptureSession(mHandler);
    mCaptureSession.setSessionConfig(previousSessionConfig);
    // When the previous capture session has not reached the open state, the issued single
    // capture
    // requests will still be in request queue and will need to be passed to the next capture
    // session.
    mCaptureSession.issueCaptureRequests(unissuedCaptureConfigs);
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return INetworkStackConnector.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return INetworkMonitor.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return IIpMemoryStore.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
@Override
public boolean onStartJob(JobParameters params) {
    if (sIpMemoryStoreService == null) {
        Log.wtf("RegularMaintenanceJobService", "Can not start job because sIpMemoryStoreService is null.");
        return false;
    }
    final InterruptMaintenance im = new InterruptMaintenance(params.getJobId());
    sInterruptList.add(im);
    sIpMemoryStoreService.fullMaintenance(new IOnStatusListener() {

        @Override
        public void onComplete(final StatusParcelable statusParcelable) throws RemoteException {
            final Status result = new Status(statusParcelable);
            if (!result.isSuccess()) {
                Log.e("RegularMaintenanceJobService", "Regular maintenance failed." + " Error is " + result.resultCode);
            }
            sInterruptList.remove(im);
            jobFinished(params, !result.isSuccess());
        }

        @Override
        public int getInterfaceVersion() {
            return IOnStatusListener.VERSION;
        }

        @Override
        public IBinder asBinder() {
            return null;
        }
    }, im);
    return true;
}
#method_after
@Override
public boolean onStartJob(JobParameters params) {
    if (sIpMemoryStoreService == null) {
        Log.wtf("RegularMaintenanceJobService", "Can not start job because sIpMemoryStoreService is null.");
        return false;
    }
    final InterruptMaintenance im = new InterruptMaintenance(params.getJobId());
    sInterruptList.add(im);
    sIpMemoryStoreService.fullMaintenance(new IOnStatusListener() {

        @Override
        public void onComplete(final StatusParcelable statusParcelable) throws RemoteException {
            final Status result = new Status(statusParcelable);
            if (!result.isSuccess()) {
                Log.e("RegularMaintenanceJobService", "Regular maintenance failed." + " Error is " + result.resultCode);
            }
            sInterruptList.remove(im);
            jobFinished(params, !result.isSuccess());
        }

        @Override
        public int getInterfaceVersion() {
            return this.VERSION;
        }

        @Override
        public IBinder asBinder() {
            return null;
        }
    }, im);
    return true;
}
#end_block

#method_before
public void add(int type, NetworkAgentInfo nai) {
    if (!isTypeSupported(type)) {
        // Invalid network type.
        return;
    }
    if (VDBG)
        log("Adding agent " + nai + " for legacy network type " + type);
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list.contains(nai)) {
        return;
    }
    synchronized (mTypeLists) {
        list.add(nai);
    }
    // Send a broadcast if this is the first network of its type or if it's the default.
    final boolean isDefaultNetwork = isDefaultNetwork(nai);
    if ((list.size() == 1) || isDefaultNetwork) {
        maybeLogBroadcast(nai, DetailedState.CONNECTED, type, isDefaultNetwork);
        sendLegacyNetworkBroadcast(nai, DetailedState.CONNECTED, type);
    }
}
#method_after
public void add(int type, NetworkAgentInfo nai) {
    if (!isTypeSupported(type)) {
        // Invalid network type.
        return;
    }
    if (VDBG)
        log("Adding agent " + nai + " for legacy network type " + type);
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list.contains(nai)) {
        return;
    }
    synchronized (mTypeLists) {
        list.add(nai);
    }
    // Send a broadcast if this is the first network of its type or if it's the default.
    final boolean isDefaultNetwork = mService.isDefaultNetwork(nai);
    if ((list.size() == 1) || isDefaultNetwork) {
        maybeLogBroadcast(nai, DetailedState.CONNECTED, type, isDefaultNetwork);
        mService.sendLegacyNetworkBroadcast(nai, DetailedState.CONNECTED, type);
    }
}
#end_block

#method_before
public void remove(int type, NetworkAgentInfo nai, boolean wasDefault) {
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list == null || list.isEmpty()) {
        return;
    }
    final boolean wasFirstNetwork = list.get(0).equals(nai);
    synchronized (mTypeLists) {
        if (!list.remove(nai)) {
            return;
        }
    }
    final DetailedState state = DetailedState.DISCONNECTED;
    if (wasFirstNetwork || wasDefault) {
        maybeLogBroadcast(nai, state, type, wasDefault);
        sendLegacyNetworkBroadcast(nai, state, type);
    }
    if (!list.isEmpty() && wasFirstNetwork) {
        if (DBG)
            log("Other network available for type " + type + ", sending connected broadcast");
        final NetworkAgentInfo replacement = list.get(0);
        maybeLogBroadcast(replacement, state, type, isDefaultNetwork(replacement));
        sendLegacyNetworkBroadcast(replacement, state, type);
    }
}
#method_after
public void remove(int type, NetworkAgentInfo nai, boolean wasDefault) {
    ArrayList<NetworkAgentInfo> list = mTypeLists[type];
    if (list == null || list.isEmpty()) {
        return;
    }
    final boolean wasFirstNetwork = list.get(0).equals(nai);
    synchronized (mTypeLists) {
        if (!list.remove(nai)) {
            return;
        }
    }
    if (wasFirstNetwork || wasDefault) {
        maybeLogBroadcast(nai, DetailedState.DISCONNECTED, type, wasDefault);
        mService.sendLegacyNetworkBroadcast(nai, DetailedState.DISCONNECTED, type);
    }
    if (!list.isEmpty() && wasFirstNetwork) {
        if (DBG)
            log("Other network available for type " + type + ", sending connected broadcast");
        final NetworkAgentInfo replacement = list.get(0);
        maybeLogBroadcast(replacement, DetailedState.CONNECTED, type, mService.isDefaultNetwork(replacement));
        mService.sendLegacyNetworkBroadcast(replacement, DetailedState.CONNECTED, type);
    }
}
#end_block

#method_before
// send out another legacy broadcast - currently only used for suspend/unsuspend
public void update(NetworkAgentInfo nai) {
    final boolean isDefault = isDefaultNetwork(nai);
    final DetailedState state = nai.networkInfo.getDetailedState();
    for (int type = 0; type < mTypeLists.length; type++) {
        final ArrayList<NetworkAgentInfo> list = mTypeLists[type];
        final boolean contains = (list != null && list.contains(nai));
        final boolean isFirst = contains && (nai == list.get(0));
        if (isFirst || contains && isDefault) {
            maybeLogBroadcast(nai, state, type, isDefault);
            sendLegacyNetworkBroadcast(nai, state, type);
        }
    }
}
#method_after
// send out another legacy broadcast - currently only used for suspend/unsuspend
public void update(NetworkAgentInfo nai) {
    final boolean isDefault = mService.isDefaultNetwork(nai);
    final DetailedState state = nai.networkInfo.getDetailedState();
    for (int type = 0; type < mTypeLists.length; type++) {
        final ArrayList<NetworkAgentInfo> list = mTypeLists[type];
        final boolean contains = (list != null && list.contains(nai));
        final boolean isFirst = contains && (nai == list.get(0));
        if (isFirst || contains && isDefault) {
            maybeLogBroadcast(nai, state, type, isDefault);
            mService.sendLegacyNetworkBroadcast(nai, state, type);
        }
    }
}
#end_block

#method_before
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.println();
    pw.println("NetworkStackClient logs:");
    pw.increaseIndent();
    NetworkStackClient.getInstance().dump(pw);
}
#method_after
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.println();
    pw.println("NetworkStackClient logs:");
    pw.increaseIndent();
    NetworkStackClient.getInstance().dump(pw);
    pw.decreaseIndent();
    pw.println();
    pw.println("Permission Monitor:");
    pw.increaseIndent();
    mPermissionMonitor.dump(pw);
    pw.decreaseIndent();
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return INetworkMonitorCallbacks.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
private boolean isDefaultNetwork(NetworkAgentInfo nai) {
    return nai == getDefaultNetwork();
}
#method_after
@VisibleForTesting
protected boolean isDefaultNetwork(NetworkAgentInfo nai) {
    return nai == getDefaultNetwork();
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // The NetworkAgentInfo does not know whether clatd is running on its network or not, or
    // whether there is a NAT64 prefix. Before we do anything else, make sure its LinkProperties
    // are accurate.
    networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop DNS64 detection and 464xlat according to network state.
        networkAgent.clatd.update();
        notifyIfacesChangedForNetworkStats();
        try {
            networkAgent.networkMonitor().notifyLinkPropertiesChanged(newLp);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // The NetworkAgentInfo does not know whether clatd is running on its network or not, or
    // whether there is a NAT64 prefix. Before we do anything else, make sure its LinkProperties
    // are accurate.
    networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    // update filtering rules, need to happen after the interface update so netd knows about the
    // new interface (the interface name -> index map becomes initialized)
    updateVpnFiltering(newLp, oldLp, networkAgent);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop DNS64 detection and 464xlat according to network state.
        networkAgent.clatd.update();
        notifyIfacesChangedForNetworkStats();
        try {
            networkAgent.networkMonitor().notifyLinkPropertiesChanged(newLp);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void updateUids(NetworkAgentInfo nai, NetworkCapabilities prevNc, NetworkCapabilities newNc) {
    Set<UidRange> prevRanges = null == prevNc ? null : prevNc.getUids();
    Set<UidRange> newRanges = null == newNc ? null : newNc.getUids();
    if (null == prevRanges)
        prevRanges = new ArraySet<>();
    if (null == newRanges)
        newRanges = new ArraySet<>();
    final Set<UidRange> prevRangesCopy = new ArraySet<>(prevRanges);
    prevRanges.removeAll(newRanges);
    newRanges.removeAll(prevRangesCopy);
    try {
        if (!newRanges.isEmpty()) {
            final UidRange[] addedRangesArray = new UidRange[newRanges.size()];
            newRanges.toArray(addedRangesArray);
            mNMS.addVpnUidRanges(nai.network.netId, addedRangesArray);
        }
        if (!prevRanges.isEmpty()) {
            final UidRange[] removedRangesArray = new UidRange[prevRanges.size()];
            prevRanges.toArray(removedRangesArray);
            mNMS.removeVpnUidRanges(nai.network.netId, removedRangesArray);
        }
    } catch (Exception e) {
        // Never crash!
        loge("Exception in updateUids: " + e);
    }
}
#method_after
private void updateUids(NetworkAgentInfo nai, NetworkCapabilities prevNc, NetworkCapabilities newNc) {
    Set<UidRange> prevRanges = null == prevNc ? null : prevNc.getUids();
    Set<UidRange> newRanges = null == newNc ? null : newNc.getUids();
    if (null == prevRanges)
        prevRanges = new ArraySet<>();
    if (null == newRanges)
        newRanges = new ArraySet<>();
    final Set<UidRange> prevRangesCopy = new ArraySet<>(prevRanges);
    prevRanges.removeAll(newRanges);
    newRanges.removeAll(prevRangesCopy);
    try {
        // add duplicate UID routing rules.
        if (!newRanges.isEmpty()) {
            final UidRange[] addedRangesArray = new UidRange[newRanges.size()];
            newRanges.toArray(addedRangesArray);
            mNMS.addVpnUidRanges(nai.network.netId, addedRangesArray);
        }
        if (!prevRanges.isEmpty()) {
            final UidRange[] removedRangesArray = new UidRange[prevRanges.size()];
            prevRanges.toArray(removedRangesArray);
            mNMS.removeVpnUidRanges(nai.network.netId, removedRangesArray);
        }
        final boolean wasFiltering = requiresVpnIsolation(nai, prevNc, nai.linkProperties);
        final boolean shouldFilter = requiresVpnIsolation(nai, newNc, nai.linkProperties);
        final String iface = nai.linkProperties.getInterfaceName();
        // to be removed will never overlap with the new range to be added.
        if (wasFiltering && !prevRanges.isEmpty()) {
            mPermissionMonitor.onVpnUidRangesRemoved(iface, prevRanges, prevNc.getEstablishingVpnAppUid());
        }
        if (shouldFilter && !newRanges.isEmpty()) {
            mPermissionMonitor.onVpnUidRangesAdded(iface, newRanges, newNc.getEstablishingVpnAppUid());
        }
    } catch (Exception e) {
        // Never crash!
        loge("Exception in updateUids: ", e);
    }
}
#end_block

#method_before
private void maybeNotifyNetworkBlockedForNewUidRules(int uid, int newRules) {
    for (final NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        final boolean metered = nai.networkCapabilities.isMetered();
        final boolean oldBlocked, newBlocked;
        // Reduce the number of locking or optimize the use of lock are likely needed in future.
        synchronized (mVpns) {
            oldBlocked = isUidNetworkingWithVpnBlocked(uid, mUidRules.get(uid), metered, mRestrictBackground);
            newBlocked = isUidNetworkingWithVpnBlocked(uid, newRules, metered, mRestrictBackground);
        }
        if (oldBlocked == newBlocked) {
            return;
        }
        final int arg = encodeBool(newBlocked);
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest nr = nai.requestAt(i);
            NetworkRequestInfo nri = mNetworkRequests.get(nr);
            if (nri != null && nri.mUid == uid) {
                callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_BLK_CHANGED, arg);
            }
        }
    }
}
#method_after
private void maybeNotifyNetworkBlockedForNewUidRules(int uid, int newRules) {
    for (final NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        final boolean metered = nai.networkCapabilities.isMetered();
        final boolean oldBlocked, newBlocked;
        // Reduce the number of locking or optimize the use of lock are likely needed in future.
        synchronized (mVpns) {
            oldBlocked = isUidNetworkingWithVpnBlocked(uid, mUidRules.get(uid), metered, mRestrictBackground);
            newBlocked = isUidNetworkingWithVpnBlocked(uid, newRules, metered, mRestrictBackground);
        }
        if (oldBlocked == newBlocked) {
            continue;
        }
        final int arg = encodeBool(newBlocked);
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest nr = nai.requestAt(i);
            NetworkRequestInfo nri = mNetworkRequests.get(nr);
            if (nri != null && nri.mUid == uid) {
                callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_BLK_CHANGED, arg);
            }
        }
    }
}
#end_block

#method_before
private void sendLegacyNetworkBroadcast(NetworkAgentInfo nai, DetailedState state, int type) {
    // The NetworkInfo we actually send out has no bearing on the real
    // state of affairs. For example, if the default connection is mobile,
    // and a request for HIPRI has just gone away, we need to pretend that
    // HIPRI has just disconnected. So we need to set the type to HIPRI and
    // the state to DISCONNECTED, even though the network is of type MOBILE
    // and is still connected.
    NetworkInfo info = new NetworkInfo(nai.networkInfo);
    info.setType(type);
    if (state != DetailedState.DISCONNECTED) {
        info.setDetailedState(state, null, info.getExtraInfo());
        sendConnectedBroadcast(info);
    } else {
        info.setDetailedState(state, info.getReason(), info.getExtraInfo());
        Intent intent = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO, info);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, info.getType());
        if (info.isFailover()) {
            intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER, true);
            nai.networkInfo.setFailover(false);
        }
        if (info.getReason() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_REASON, info.getReason());
        }
        if (info.getExtraInfo() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO, info.getExtraInfo());
        }
        NetworkAgentInfo newDefaultAgent = null;
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            newDefaultAgent = getDefaultNetwork();
            if (newDefaultAgent != null) {
                intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO, newDefaultAgent.networkInfo);
            } else {
                intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, true);
            }
        }
        intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION, mDefaultInetConditionPublished);
        sendStickyBroadcast(intent);
        if (newDefaultAgent != null) {
            sendConnectedBroadcast(newDefaultAgent.networkInfo);
        }
    }
}
#method_after
@VisibleForTesting
protected void sendLegacyNetworkBroadcast(NetworkAgentInfo nai, DetailedState state, int type) {
    // The NetworkInfo we actually send out has no bearing on the real
    // state of affairs. For example, if the default connection is mobile,
    // and a request for HIPRI has just gone away, we need to pretend that
    // HIPRI has just disconnected. So we need to set the type to HIPRI and
    // the state to DISCONNECTED, even though the network is of type MOBILE
    // and is still connected.
    NetworkInfo info = new NetworkInfo(nai.networkInfo);
    info.setType(type);
    if (state != DetailedState.DISCONNECTED) {
        info.setDetailedState(state, null, info.getExtraInfo());
        sendConnectedBroadcast(info);
    } else {
        info.setDetailedState(state, info.getReason(), info.getExtraInfo());
        Intent intent = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO, info);
        intent.putExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, info.getType());
        if (info.isFailover()) {
            intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER, true);
            nai.networkInfo.setFailover(false);
        }
        if (info.getReason() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_REASON, info.getReason());
        }
        if (info.getExtraInfo() != null) {
            intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO, info.getExtraInfo());
        }
        NetworkAgentInfo newDefaultAgent = null;
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            newDefaultAgent = getDefaultNetwork();
            if (newDefaultAgent != null) {
                intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO, newDefaultAgent.networkInfo);
            } else {
                intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, true);
            }
        }
        intent.putExtra(ConnectivityManager.EXTRA_INET_CONDITION, mDefaultInetConditionPublished);
        sendStickyBroadcast(intent);
        if (newDefaultAgent != null) {
            sendConnectedBroadcast(newDefaultAgent.networkInfo);
        }
    }
}
#end_block

#method_before
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    final String defaultUrl = mContext.getResources().getString(R.string.config_networkDefaultCaptivePortalServerUrl);
    return NetworkMonitorUtils.getCaptivePortalServerHttpUrl(mContext, defaultUrl);
}
#method_after
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    String settingUrl = mContext.getResources().getString(R.string.config_networkCaptivePortalServerUrl);
    if (!TextUtils.isEmpty(settingUrl)) {
        return settingUrl;
    }
    settingUrl = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.CAPTIVE_PORTAL_HTTP_URL);
    if (!TextUtils.isEmpty(settingUrl)) {
        return settingUrl;
    }
    return DEFAULT_CAPTIVE_PORTAL_HTTP_URL;
}
#end_block

#method_before
@NonNull
static IOnL2KeyResponseListener toAIDL(final OnL2KeyResponseListener listener) {
    return new IOnL2KeyResponseListener.Stub() {

        @Override
        public void onL2KeyResponse(final StatusParcelable statusParcelable, final String l2Key) {
            listener.onL2KeyResponse(new Status(statusParcelable), l2Key);
        }

        @Override
        public int getInterfaceVersion() {
            return IOnL2KeyResponseListener.VERSION;
        }
    };
}
#method_after
@NonNull
static IOnL2KeyResponseListener toAIDL(@NonNull final OnL2KeyResponseListener listener) {
    return new IOnL2KeyResponseListener.Stub() {

        @Override
        public void onL2KeyResponse(final StatusParcelable statusParcelable, final String l2Key) {
            // NonNull, but still don't crash the system server if null
            if (null != listener) {
                listener.onL2KeyResponse(new Status(statusParcelable), l2Key);
            }
        }

        @Override
        public int getInterfaceVersion() {
            return this.VERSION;
        }
    };
}
#end_block

#method_before
@NonNull
static IOnStatusListener toAIDL(final OnStatusListener listener) {
    return new IOnStatusListener.Stub() {

        @Override
        public void onComplete(final StatusParcelable statusParcelable) {
            listener.onComplete(new Status(statusParcelable));
        }

        @Override
        public int getInterfaceVersion() {
            return IOnStatusListener.VERSION;
        }
    };
}
#method_after
@NonNull
static IOnStatusListener toAIDL(@Nullable final OnStatusListener listener) {
    return new IOnStatusListener.Stub() {

        @Override
        public void onComplete(final StatusParcelable statusParcelable) {
            if (null != listener) {
                listener.onComplete(new Status(statusParcelable));
            }
        }

        @Override
        public int getInterfaceVersion() {
            return this.VERSION;
        }
    };
}
#end_block

#method_before
@NonNull
static IOnBlobRetrievedListener toAIDL(final OnBlobRetrievedListener listener) {
    return new IOnBlobRetrievedListener.Stub() {

        @Override
        public void onBlobRetrieved(final StatusParcelable statusParcelable, final String l2Key, final String name, final Blob blob) {
            listener.onBlobRetrieved(new Status(statusParcelable), l2Key, name, blob);
        }

        @Override
        public int getInterfaceVersion() {
            return IOnBlobRetrievedListener.VERSION;
        }
    };
}
#method_after
@NonNull
static IOnBlobRetrievedListener toAIDL(@NonNull final OnBlobRetrievedListener listener) {
    return new IOnBlobRetrievedListener.Stub() {

        @Override
        public void onBlobRetrieved(final StatusParcelable statusParcelable, final String l2Key, final String name, final Blob blob) {
            // NonNull, but still don't crash the system server if null
            if (null != listener) {
                listener.onBlobRetrieved(new Status(statusParcelable), l2Key, name, blob);
            }
        }

        @Override
        public int getInterfaceVersion() {
            return this.VERSION;
        }
    };
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return IDhcpServer.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return INetworkStackStatusCallback.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return IIpClientCallbacks.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
@Override
public int getInterfaceVersion() {
    return IIpClient.VERSION;
}
#method_after
@Override
public int getInterfaceVersion() {
    return this.VERSION;
}
#end_block

#method_before
@NonNull
static IOnNetworkAttributesRetrievedListener toAIDL(final OnNetworkAttributesRetrievedListener listener) {
    return new IOnNetworkAttributesRetrievedListener.Stub() {

        @Override
        public void onNetworkAttributesRetrieved(final StatusParcelable statusParcelable, final String l2Key, final NetworkAttributesParcelable networkAttributesParcelable) {
            listener.onNetworkAttributesRetrieved(new Status(statusParcelable), l2Key, new NetworkAttributes(networkAttributesParcelable));
        }

        @Override
        public int getInterfaceVersion() {
            return IOnNetworkAttributesRetrievedListener.VERSION;
        }
    };
}
#method_after
@NonNull
static IOnNetworkAttributesRetrievedListener toAIDL(@NonNull final OnNetworkAttributesRetrievedListener listener) {
    return new IOnNetworkAttributesRetrievedListener.Stub() {

        @Override
        public void onNetworkAttributesRetrieved(final StatusParcelable statusParcelable, final String l2Key, final NetworkAttributesParcelable networkAttributesParcelable) {
            // NonNull, but still don't crash the system server if null
            if (null != listener) {
                listener.onNetworkAttributesRetrieved(new Status(statusParcelable), l2Key, new NetworkAttributes(networkAttributesParcelable));
            }
        }

        @Override
        public int getInterfaceVersion() {
            return this.VERSION;
        }
    };
}
#end_block

#method_before
@NonNull
static IOnSameL3NetworkResponseListener toAIDL(final OnSameL3NetworkResponseListener listener) {
    return new IOnSameL3NetworkResponseListener.Stub() {

        @Override
        public void onSameL3NetworkResponse(final StatusParcelable statusParcelable, final SameL3NetworkResponseParcelable sameL3NetworkResponseParcelable) {
            listener.onSameL3NetworkResponse(new Status(statusParcelable), new SameL3NetworkResponse(sameL3NetworkResponseParcelable));
        }

        @Override
        public int getInterfaceVersion() {
            return IOnSameL3NetworkResponseListener.VERSION;
        }
    };
}
#method_after
@NonNull
static IOnSameL3NetworkResponseListener toAIDL(@NonNull final OnSameL3NetworkResponseListener listener) {
    return new IOnSameL3NetworkResponseListener.Stub() {

        @Override
        public void onSameL3NetworkResponse(final StatusParcelable statusParcelable, final SameL3NetworkResponseParcelable sameL3NetworkResponseParcelable) {
            // NonNull, but still don't crash the system server if null
            if (null != listener) {
                listener.onSameL3NetworkResponse(new Status(statusParcelable), new SameL3NetworkResponse(sameL3NetworkResponseParcelable));
            }
        }

        @Override
        public int getInterfaceVersion() {
            return this.VERSION;
        }
    };
}
#end_block

#method_before
public String unescape(String string) {
    // Early exit if no escaped characters.
    final int firstPercent = string.indexOf('%');
    final int firstPlus = string.indexOf('+');
    final int firstEscape;
    if (firstPercent < 0) {
        firstEscape = firstPlus;
    } else if (firstPlus < 0) {
        firstEscape = firstPercent;
    } else {
        firstEscape = Math.min(firstPercent, firstPlus);
    }
    if (firstEscape < 0)
        return string;
    int length = string.length();
    StringBuilder stringBuilder = new StringBuilder(length);
    stringBuilder.append(string.substring(0, firstEscape));
    for (int i = firstEscape; i < length; i++) {
        char c = string.charAt(i);
        if (c == '+') {
            c = ' ';
        } else if (c == '%' && i + 2 < length) {
            char c1 = string.charAt(i + 1);
            char c2 = string.charAt(i + 2);
            if (isHexDigit(c1) && isHexDigit(c2)) {
                c = (char) (decodeHexDigit(c1) * 16 + decodeHexDigit(c2));
                i += 2;
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}
#method_after
public String unescape(String string) {
    final Matcher matcher = plusOrPercent.matcher(string);
    if (!matcher.find())
        return string;
    final int firstEscape = matcher.start();
    int length = string.length();
    StringBuilder stringBuilder = new StringBuilder(length);
    stringBuilder.append(string.substring(0, firstEscape));
    for (int i = firstEscape; i < length; i++) {
        char c = string.charAt(i);
        if (c == '+') {
            c = ' ';
        } else if (c == '%' && i + 2 < length) {
            char c1 = string.charAt(i + 1);
            char c2 = string.charAt(i + 2);
            if (isHexDigit(c1) && isHexDigit(c2)) {
                c = (char) (decodeHexDigit(c1) * 16 + decodeHexDigit(c2));
                i += 2;
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}
#end_block

#method_before
public void enableExtension() {
    CameraX.LensFacing lensFacing = mBuilder.build().getLensFacing();
    String cameraId = CameraUtil.getCameraId(lensFacing);
    CameraCharacteristics cameraCharacteristics = CameraUtil.getCameraCharacteristics(cameraId);
    mImpl.enableExtension(cameraId, cameraCharacteristics);
    CaptureProcessorImpl captureProcessor = mImpl.getCaptureProcessor();
    if (captureProcessor != null) {
        mBuilder.setCaptureProcessor(new CaptureProcessorAdaptor(captureProcessor));
    }
    List<CaptureStageImpl> captureStages = mImpl.getCaptureStages();
    if (captureStages != null && !captureStages.isEmpty()) {
        CaptureBundle captureBundle = new CaptureBundle();
        for (CaptureStageImpl captureStage : captureStages) {
            captureBundle.addCaptureStage(new CaptureStageAdaptor(captureStage));
        }
        mBuilder.setCaptureBundle(captureBundle);
    }
}
#method_after
public void enableExtension() {
    CameraX.LensFacing lensFacing = mBuilder.build().getLensFacing();
    String cameraId = CameraUtil.getCameraId(lensFacing);
    CameraCharacteristics cameraCharacteristics = CameraUtil.getCameraCharacteristics(cameraId);
    mImpl.enableExtension(cameraId, cameraCharacteristics);
    CaptureProcessorImpl captureProcessor = mImpl.getCaptureProcessor();
    if (captureProcessor != null) {
        mBuilder.setCaptureProcessor(new AdaptingCaptureProcessor(captureProcessor));
    }
    List<CaptureStageImpl> captureStages = mImpl.getCaptureStages();
    if (captureStages != null && !captureStages.isEmpty()) {
        CaptureBundle captureBundle = new CaptureBundle();
        for (CaptureStageImpl captureStage : captureStages) {
            captureBundle.addCaptureStage(new AdaptingCaptureStage(captureStage));
        }
        mBuilder.setCaptureBundle(captureBundle);
    }
}
#end_block

#method_before
public void enableExtension() {
    CameraX.LensFacing lensFacing = mBuilder.build().getLensFacing();
    String cameraId = CameraUtil.getCameraId(lensFacing);
    CameraCharacteristics cameraCharacteristics = CameraUtil.getCameraCharacteristics(cameraId);
    mImpl.enableExtension(cameraId, cameraCharacteristics);
    CaptureStageImpl captureStage = mImpl.getCaptureStage();
    Camera2Config.Builder camera2ConfigurationBuilder = new Camera2Config.Builder();
    for (Pair<CaptureRequest.Key, Object> captureParameter : captureStage.getParameters()) {
        camera2ConfigurationBuilder.setCaptureRequestOption(captureParameter.first, captureParameter.second);
    }
    Camera2Config camera2Configuration = camera2ConfigurationBuilder.build();
    for (Config.Option<?> option : camera2Configuration.listOptions()) {
        // Options/values are being copied directly
        @SuppressWarnings("unchecked")
        Config.Option<Object> objectOpt = (Config.Option<Object>) option;
        mBuilder.insertOption(objectOpt, camera2Configuration.retrieveOption(objectOpt));
    }
}
#method_after
public void enableExtension() {
    CameraX.LensFacing lensFacing = mBuilder.build().getLensFacing();
    String cameraId = CameraUtil.getCameraId(lensFacing);
    CameraCharacteristics cameraCharacteristics = CameraUtil.getCameraCharacteristics(cameraId);
    mImpl.enableExtension(cameraId, cameraCharacteristics);
    CaptureStageImpl captureStage = mImpl.getCaptureStage();
    Camera2Config.Builder camera2ConfigurationBuilder = new Camera2Config.Builder();
    for (Pair<CaptureRequest.Key, Object> captureParameter : captureStage.getParameters()) {
        camera2ConfigurationBuilder.setCaptureRequestOption(captureParameter.first, captureParameter.second);
    }
    Camera2Config camera2Config = camera2ConfigurationBuilder.build();
    for (Config.Option<?> option : camera2Config.listOptions()) {
        // Options/values are being copied directly
        @SuppressWarnings("unchecked")
        Config.Option<Object> objectOpt = (Config.Option<Object>) option;
        mBuilder.getMutableConfig().insertOption(objectOpt, camera2Config.retrieveOption(objectOpt));
    }
}
#end_block

#method_before
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@Override
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mResumeOnlyCurrentFragment) {
                mCurTransaction = mFragmentManager.beginTransaction();
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                fragment.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mResumeOnlyCurrentFragment) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#method_after
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@Override
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mResumeOnlyCurrentFragment) {
                if (mCurTransaction == null) {
                    mCurTransaction = mFragmentManager.beginTransaction();
                }
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                fragment.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mResumeOnlyCurrentFragment) {
            if (mCurTransaction == null) {
                mCurTransaction = mFragmentManager.beginTransaction();
            }
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#end_block

#method_before
@Override
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mResumeOnlyCurrentFragment) {
                mCurTransaction = mFragmentManager.beginTransaction();
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                fragment.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mCurTransaction != null && mResumeOnlyCurrentFragment) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#method_after
@Override
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mResumeOnlyCurrentFragment) {
                if (mCurTransaction == null) {
                    mCurTransaction = mFragmentManager.beginTransaction();
                }
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                fragment.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mResumeOnlyCurrentFragment) {
            if (mCurTransaction == null) {
                mCurTransaction = mFragmentManager.beginTransaction();
            }
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#end_block

#method_before
@NonNull
@SuppressWarnings("unchecked")
public static TestListenableWorkerBuilder from(@NonNull Context context, @NonNull WorkRequest workRequest) {
    WorkSpec workSpec = workRequest.getWorkSpec();
    String name = workSpec.workerClassName;
    try {
        Class<?> workerClass = Class.forName(name);
        List<String> tags = new ArrayList<>(workRequest.getTags().size());
        tags.addAll(workRequest.getTags());
        return new TestListenableWorkerBuilder(context.getApplicationContext(), workerClass).setId(workRequest.getId()).setTags(tags).setInputData(workSpec.input);
    } catch (ClassNotFoundException exception) {
        throw new RuntimeException("Can never happen", exception);
    }
}
#method_after
@NonNull
@SuppressWarnings("unchecked")
public static TestListenableWorkerBuilder from(@NonNull Context context, @NonNull WorkRequest workRequest) {
    WorkSpec workSpec = workRequest.getWorkSpec();
    String name = workSpec.workerClassName;
    try {
        Class<?> workerClass = Class.forName(name);
        List<String> tags = new ArrayList<>(workRequest.getTags().size());
        tags.addAll(workRequest.getTags());
        return new TestListenableWorkerBuilder(context.getApplicationContext(), workerClass).setId(workRequest.getId()).setTags(tags).setInputData(workSpec.input);
    } catch (ClassNotFoundException exception) {
        throw new RuntimeException("Cannot find class", exception);
    }
}
#end_block

#method_before
@NonNull
public static TestWorkerBuilder from(@NonNull Context context, @NonNull WorkRequest workRequest, @Nullable Executor executor) {
    WorkSpec workSpec = workRequest.getWorkSpec();
    String name = workSpec.workerClassName;
    Class<Worker> workerClass = getWorkerClass(name);
    if (workerClass == null) {
        throw new IllegalArgumentException(String.format("Invalid worker class name or class does not extend Worker (%s)", name));
    }
    List<String> tags = new ArrayList<>(workRequest.getTags().size());
    tags.addAll(workRequest.getTags());
    TestWorkerBuilder<Worker> builder = new TestWorkerBuilder<>(context, workerClass, executor);
    builder.setId(workRequest.getId()).setTags(tags).setInputData(workSpec.input);
    return builder;
}
#method_after
@NonNull
public static TestWorkerBuilder<? extends Worker> from(@NonNull Context context, @NonNull WorkRequest workRequest, @Nullable Executor executor) {
    WorkSpec workSpec = workRequest.getWorkSpec();
    String name = workSpec.workerClassName;
    Class<Worker> workerClass = getWorkerClass(name);
    if (workerClass == null) {
        throw new IllegalArgumentException(String.format("Invalid worker class name or class does not extend Worker (%s)", name));
    }
    List<String> tags = new ArrayList<>(workRequest.getTags().size());
    tags.addAll(workRequest.getTags());
    TestWorkerBuilder<Worker> builder = new TestWorkerBuilder<>(context, workerClass, executor);
    builder.setId(workRequest.getId()).setTags(tags).setInputData(workSpec.input);
    return builder;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj, msg.arg1);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_TIMEOUT_MSG:
            {
                mServices.serviceForegroundTimeout((ServiceRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_CRASH_MSG:
            {
                mServices.serviceForegroundCrash((ProcessRecord) msg.obj, msg.getData().getCharSequence(SERVICE_RECORD_KEY));
            }
            break;
        case DISPATCH_PENDING_INTENT_CANCEL_MSG:
            {
                RemoteCallbackList<IResultReceiver> callbacks = (RemoteCallbackList<IResultReceiver>) msg.obj;
                int N = callbacks.beginBroadcast();
                for (int i = 0; i < N; i++) {
                    try {
                        callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);
                    } catch (RemoteException e) {
                    }
                }
                callbacks.finishBroadcast();
                // We have to clean up the RemoteCallbackList here, because otherwise it will
                // needlessly hold the enclosed callbacks until the remote process dies.
                callbacks.kill();
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        // ConnectivityManager and don't have network privileges anyway.
                        if (r.pid != MY_PID && r.thread != null && !r.isolated) {
                            try {
                                r.thread.updateHttpProxy();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final int appId = msg.arg1;
                    final int userId = msg.arg2;
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appId, false, false, true, false, false, userId, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context, SystemNotificationChannels.HEAVY_WEIGHT_APP).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_POWER_USE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked();
                    removeMessages(CHECK_EXCESSIVE_POWER_USE_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
                    sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case UPDATE_TIME_PREFERENCE_MSG:
            {
                // For convenience we re-use the Intent extra values.
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build();
                try {
                    inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_DUMP_HEAP_NOTIFICATION, notification, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case IDLE_UIDS_MSG:
            {
                idleUids();
            }
            break;
        case VR_MODE_CHANGE_MSG:
            {
                if (!mVrController.onVrModeChanged((ActivityRecord) msg.obj)) {
                    return;
                }
                synchronized (ActivityManagerService.this) {
                    final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();
                    mWindowManager.disableNonVrUi(disableNonVrUi);
                    if (disableNonVrUi) {
                        // If we are in a VR mode where Picture-in-Picture mode is unsupported,
                        // then remove the pinned stack.
                        mStackSupervisor.removeStacksInWindowingModes(WINDOWING_MODE_PINNED);
                    }
                }
            }
            break;
        case DISPATCH_SCREEN_AWAKE_MSG:
            {
                final boolean isAwake = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onAwakeStateChanged(isAwake);
                }
            }
            break;
        case DISPATCH_SCREEN_KEYGUARD_MSG:
            {
                final boolean isShowing = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onKeyguardStateChanged(isShowing);
                }
            }
            break;
        case HANDLE_TRUST_STORAGE_UPDATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.handleTrustStorageUpdate();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to handle trust storage update for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj, msg.arg1);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_TIMEOUT_MSG:
            {
                mServices.serviceForegroundTimeout((ServiceRecord) msg.obj);
            }
            break;
        case SERVICE_FOREGROUND_CRASH_MSG:
            {
                mServices.serviceForegroundCrash((ProcessRecord) msg.obj, msg.getData().getCharSequence(SERVICE_RECORD_KEY));
            }
            break;
        case DISPATCH_PENDING_INTENT_CANCEL_MSG:
            {
                RemoteCallbackList<IResultReceiver> callbacks = (RemoteCallbackList<IResultReceiver>) msg.obj;
                int N = callbacks.beginBroadcast();
                for (int i = 0; i < N; i++) {
                    try {
                        callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);
                    } catch (RemoteException e) {
                    }
                }
                callbacks.finishBroadcast();
                // We have to clean up the RemoteCallbackList here, because otherwise it will
                // needlessly hold the enclosed callbacks until the remote process dies.
                callbacks.kill();
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                // Update the HTTP proxy for each application thread.
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        // deadlock with Connectivity Service.
                        if (r.pid != MY_PID && r.thread != null && !r.isolated) {
                            try {
                                r.thread.updateHttpProxy();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
                ActivityThread.updateHttpProxy(mContext);
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final int appId = msg.arg1;
                    final int userId = msg.arg2;
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appId, false, false, true, false, false, userId, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context, SystemNotificationChannels.HEAVY_WEIGHT_APP).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, notification, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, SystemMessage.NOTE_HEAVY_WEIGHT_NOTIFICATION, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_POWER_USE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked();
                    removeMessages(CHECK_EXCESSIVE_POWER_USE_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
                    sendMessageDelayed(nmsg, mConstants.POWER_CHECK_INTERVAL);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case UPDATE_TIME_PREFERENCE_MSG:
            {
                // For convenience we re-use the Intent extra values.
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    storageManager.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build();
                try {
                    inm.enqueueNotificationWithTag("android", "android", null, SystemMessage.NOTE_DUMP_HEAP_NOTIFICATION, notification, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case IDLE_UIDS_MSG:
            {
                idleUids();
            }
            break;
        case VR_MODE_CHANGE_MSG:
            {
                if (!mVrController.onVrModeChanged((ActivityRecord) msg.obj)) {
                    return;
                }
                synchronized (ActivityManagerService.this) {
                    final boolean disableNonVrUi = mVrController.shouldDisableNonVrUiLocked();
                    mWindowManager.disableNonVrUi(disableNonVrUi);
                    if (disableNonVrUi) {
                        // If we are in a VR mode where Picture-in-Picture mode is unsupported,
                        // then remove the pinned stack.
                        mStackSupervisor.removeStacksInWindowingModes(WINDOWING_MODE_PINNED);
                    }
                }
            }
            break;
        case DISPATCH_SCREEN_AWAKE_MSG:
            {
                final boolean isAwake = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onAwakeStateChanged(isAwake);
                }
            }
            break;
        case DISPATCH_SCREEN_KEYGUARD_MSG:
            {
                final boolean isShowing = msg.arg1 != 0;
                for (int i = mScreenObservers.size() - 1; i >= 0; i--) {
                    mScreenObservers.get(i).onKeyguardStateChanged(isShowing);
                }
            }
            break;
        case HANDLE_TRUST_STORAGE_UPDATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.handleTrustStorageUpdate();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to handle trust storage update for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
    }
}
#end_block

#method_before
private void initCameraX() {
    AppConfig appConfig = createFakeAppConfig();
    mSurfaceManager = new Camera2DeviceSurfaceManager(mContext, mMockCamcorderProfileHelper);
}
#method_after
private void initCameraX() {
    AppConfig appConfig = createFakeAppConfig();
    mSurfaceManager = appConfig.getDeviceSurfaceManager(null);
    CameraX.init(mContext, appConfig);
}
#end_block

#method_before
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    final long itemId = getItemId(position);
    // Do we already have this fragment?
    String name = makeFragmentName(container.getId(), itemId);
    Fragment fragment = mFragmentManager.findFragmentByTag(name);
    if (fragment != null) {
        if (DEBUG)
            Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment);
        mCurTransaction.attach(fragment);
    } else {
        fragment = getItem(position);
        if (DEBUG)
            Log.v(TAG, "Adding item #" + itemId + ": f=" + fragment);
        mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));
    }
    if (fragment != mCurrentPrimaryItem) {
        fragment.setMenuVisibility(false);
        fragment.setUserVisibleHint(false);
    }
    return fragment;
}
#method_after
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    final long itemId = getItemId(position);
    // Do we already have this fragment?
    String name = makeFragmentName(container.getId(), itemId);
    Fragment fragment = mFragmentManager.findFragmentByTag(name);
    if (fragment != null) {
        if (DEBUG)
            Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment);
        mCurTransaction.attach(fragment);
    } else {
        fragment = getItem(position);
        if (DEBUG)
            Log.v(TAG, "Adding item #" + itemId + ": f=" + fragment);
        mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));
    }
    if (fragment != mCurrentPrimaryItem) {
        fragment.setMenuVisibility(false);
        if (mResumeOnlyCurrentFragment) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED);
        } else {
            fragment.setUserVisibleHint(false);
        }
    }
    return fragment;
}
#end_block

#method_before
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@Override
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            mCurrentPrimaryItem.setUserVisibleHint(false);
        }
        fragment.setMenuVisibility(true);
        fragment.setUserVisibleHint(true);
        mCurrentPrimaryItem = fragment;
        if (mCurTransaction != null && mResumeOnlyCurrentFragment) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        }
    }
}
#method_after
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
@Override
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mResumeOnlyCurrentFragment) {
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                fragment.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mResumeOnlyCurrentFragment) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    // taken care of restoring the fragments we previously had instantiated.
    if (mFragments.size() > position) {
        Fragment f = mFragments.get(position);
        if (f != null) {
            return f;
        }
    }
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    Fragment fragment = getItem(position);
    if (DEBUG)
        Log.v(TAG, "Adding item #" + position + ": f=" + fragment);
    if (mSavedState.size() > position) {
        Fragment.SavedState fss = mSavedState.get(position);
        if (fss != null) {
            fragment.setInitialSavedState(fss);
        }
    }
    while (mFragments.size() <= position) {
        mFragments.add(null);
    }
    fragment.setMenuVisibility(false);
    fragment.setUserVisibleHint(false);
    mFragments.set(position, fragment);
    mCurTransaction.add(container.getId(), fragment);
    if (mResumeOnlyCurrentFragment) {
        mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED);
    }
    return fragment;
}
#method_after
@SuppressWarnings("deprecation")
@NonNull
@Override
public Object instantiateItem(@NonNull ViewGroup container, int position) {
    // taken care of restoring the fragments we previously had instantiated.
    if (mFragments.size() > position) {
        Fragment f = mFragments.get(position);
        if (f != null) {
            return f;
        }
    }
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    Fragment fragment = getItem(position);
    if (DEBUG)
        Log.v(TAG, "Adding item #" + position + ": f=" + fragment);
    if (mSavedState.size() > position) {
        Fragment.SavedState fss = mSavedState.get(position);
        if (fss != null) {
            fragment.setInitialSavedState(fss);
        }
    }
    while (mFragments.size() <= position) {
        mFragments.add(null);
    }
    fragment.setMenuVisibility(false);
    if (mResumeOnlyCurrentFragment) {
        mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED);
    } else {
        fragment.setUserVisibleHint(false);
    }
    mFragments.set(position, fragment);
    mCurTransaction.add(container.getId(), fragment);
    return fragment;
}
#end_block

#method_before
@Override
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            mCurrentPrimaryItem.setUserVisibleHint(false);
        }
        fragment.setMenuVisibility(true);
        fragment.setUserVisibleHint(true);
        mCurrentPrimaryItem = fragment;
        if (mCurTransaction != null && mResumeOnlyCurrentFragment) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        }
    }
}
#method_after
@Override
@SuppressWarnings({ "ReferenceEquality", "deprecation" })
public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    Fragment fragment = (Fragment) object;
    if (fragment != mCurrentPrimaryItem) {
        if (mCurrentPrimaryItem != null) {
            mCurrentPrimaryItem.setMenuVisibility(false);
            if (mResumeOnlyCurrentFragment) {
                mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);
            } else {
                fragment.setUserVisibleHint(false);
            }
        }
        fragment.setMenuVisibility(true);
        if (mCurTransaction != null && mResumeOnlyCurrentFragment) {
            mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);
        } else {
            fragment.setUserVisibleHint(true);
        }
        mCurrentPrimaryItem = fragment;
    }
}
#end_block

#method_before
@UiThread
void release() {
    if (mSurface == null && mSurfaceTexture == null) {
        return;
    }
    Resource resource;
    synchronized (mLock) {
        resource = mResourceMap.get(mSurfaceTexture);
    }
    if (resource != null) {
        releaseResourceWhenDetached(resource);
    }
    mSurfaceTexture = null;
    mSurface = null;
    if (!mSurfaceToReleaseList.isEmpty()) {
        for (Surface surface : mSurfaceToReleaseList) {
            surface.release();
        }
        mSurfaceToReleaseList.clear();
    }
}
#method_after
@UiThread
void release() {
    if (mSurface == null && mSurfaceTexture == null) {
        return;
    }
    Resource resource;
    synchronized (mLock) {
        resource = mResourceMap.get(mSurfaceTexture);
    }
    if (resource != null) {
        releaseResourceWhenDetached(resource);
    }
    mSurfaceTexture = null;
    mSurface = null;
    for (Surface surface : mSurfaceToReleaseList) {
        surface.release();
    }
    mSurfaceToReleaseList.clear();
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.BIND_NFC_SERVICE)
@NonNull
public boolean unsetOffHostForService(@NonNull ComponentName service) {
    NfcAdapter adapter = NfcAdapter.getDefaultAdapter(mContext);
    if (adapter == null) {
        return false;
    }
    try {
        return sService.unsetOffHostForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.unsetOffHostForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.NFC)
@NonNull
public boolean unsetOffHostForService(@NonNull ComponentName service) {
    NfcAdapter adapter = NfcAdapter.getDefaultAdapter(mContext);
    if (adapter == null) {
        return false;
    }
    try {
        return sService.unsetOffHostForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.unsetOffHostForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.BIND_NFC_SERVICE)
@NonNull
public boolean setOffHostForService(@NonNull ComponentName service, @NonNull String offHostSecureElement) {
    boolean validSecureElement = false;
    NfcAdapter adapter = NfcAdapter.getDefaultAdapter(mContext);
    if (adapter == null || offHostSecureElement == null) {
        return false;
    }
    List<String> validSE = adapter.getSupportedOffHostSecureElements();
    if ((offHostSecureElement.startsWith("eSE") && !validSE.contains("eSE")) || (offHostSecureElement.startsWith("SIM") && !validSE.contains("SIM"))) {
        return false;
    }
    if (!offHostSecureElement.startsWith("eSE") && !offHostSecureElement.startsWith("SIM")) {
        return false;
    }
    if (offHostSecureElement.equals("eSE")) {
        offHostSecureElement = "eSE1";
    } else if (offHostSecureElement.equals("SIM")) {
        offHostSecureElement = "SIM1";
    }
    try {
        return sService.setOffHostForService(mContext.getUserId(), service, offHostSecureElement);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setOffHostForService(mContext.getUserId(), service, offHostSecureElement);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.NFC)
@NonNull
public boolean setOffHostForService(@NonNull ComponentName service, @NonNull String offHostSecureElement) {
    boolean validSecureElement = false;
    NfcAdapter adapter = NfcAdapter.getDefaultAdapter(mContext);
    if (adapter == null || offHostSecureElement == null) {
        return false;
    }
    List<String> validSE = adapter.getSupportedOffHostSecureElements();
    if ((offHostSecureElement.startsWith("eSE") && !validSE.contains("eSE")) || (offHostSecureElement.startsWith("SIM") && !validSE.contains("SIM"))) {
        return false;
    }
    if (!offHostSecureElement.startsWith("eSE") && !offHostSecureElement.startsWith("SIM")) {
        return false;
    }
    if (offHostSecureElement.equals("eSE")) {
        offHostSecureElement = "eSE1";
    } else if (offHostSecureElement.equals("SIM")) {
        offHostSecureElement = "SIM1";
    }
    try {
        return sService.setOffHostForService(mContext.getUserId(), service, offHostSecureElement);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setOffHostForService(mContext.getUserId(), service, offHostSecureElement);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
#end_block

#method_before
private void updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        values.reset();
        return;
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        values.reset();
        return;
    }
    // TODO(123350297): automated test for this
    MarginLayoutParams margin = (firstVisibleView.getLayoutParams() instanceof MarginLayoutParams) ? (MarginLayoutParams) firstVisibleView.getLayoutParams() : ZERO_MARGIN_LAYOUT_PARAMS;
    boolean isHorizontal = mLayoutManager.getOrientation() == ORIENTATION_HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        sizePx = firstVisibleView.getWidth() + margin.leftMargin + margin.rightMargin;
        if (!isLayoutRTL()) {
            start = firstVisibleView.getLeft() - margin.leftMargin;
        } else {
            start = sizePx - firstVisibleView.getRight() - margin.rightMargin;
        }
    } else {
        sizePx = firstVisibleView.getHeight() + margin.topMargin + margin.bottomMargin;
        start = firstVisibleView.getTop() - margin.topMargin;
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        // by animateLayoutChanges and throw a descriptive exception if so
        if (new AnimateLayoutChangeDetector(mLayoutManager).mayHaveInterferingAnimations()) {
            throw new IllegalStateException("Page(s) contain a ViewGroup with a " + "LayoutTransition (or animateLayoutChanges=\"true\"), which interferes " + "with the scrolling animation. Make sure to call getLayoutTransition()" + ".setAnimateParentHierarchy(false) on all ViewGroup's with a " + "LayoutTransition before an animation is started.");
        }
        // Throw a generic exception otherwise
        throw new IllegalStateException(String.format(Locale.US, "Page can only be offset by a " + "positive amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
}
#method_after
private void updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        values.reset();
        return;
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        values.reset();
        return;
    }
    // TODO(123350297): automated test for this
    MarginLayoutParams margin = (firstVisibleView.getLayoutParams() instanceof MarginLayoutParams) ? (MarginLayoutParams) firstVisibleView.getLayoutParams() : ZERO_MARGIN_LAYOUT_PARAMS;
    boolean isHorizontal = mLayoutManager.getOrientation() == ORIENTATION_HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        sizePx = firstVisibleView.getWidth() + margin.leftMargin + margin.rightMargin;
        if (!isLayoutRTL()) {
            start = firstVisibleView.getLeft() - margin.leftMargin;
        } else {
            start = sizePx - firstVisibleView.getRight() - margin.rightMargin;
        }
    } else {
        sizePx = firstVisibleView.getHeight() + margin.topMargin + margin.bottomMargin;
        start = firstVisibleView.getTop() - margin.topMargin;
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        // by animateLayoutChanges and throw a descriptive exception if so
        if (new AnimateLayoutChangeDetector(mLayoutManager).mayHaveInterferingAnimations()) {
            throw new IllegalStateException("Page(s) contain a ViewGroup with a " + "LayoutTransition (or animateLayoutChanges=\"true\"), which interferes " + "with the scrolling animation. Make sure to call getLayoutTransition()" + ".setAnimateParentHierarchy(false) on all ViewGroups with a " + "LayoutTransition before an animation is started.");
        }
        // Throw a generic exception otherwise
        throw new IllegalStateException(String.format(Locale.US, "Page can only be offset by a " + "positive amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
}
#end_block

#method_before
public int getWidth() {
    return mWidth;
}
#method_after
@IntRange(from = 0)
public int getWidth() {
    return mWidth;
}
#end_block

#method_before
public int getHeight() {
    return mHeight;
}
#method_after
@IntRange(from = 0)
public int getHeight() {
    return mHeight;
}
#end_block

#method_before
@Nullable
public TrackInfo getSelectedTrack(@TrackInfo.MediaTrackType int trackType) {
    final int ret = mPlayer.getSelectedTrack(trackType);
    return ret < 0 ? null : mPlayer.getTrackInfo(ret);
}
#method_after
/**
 * Returns the index of the audio or video track currently selected for playback,
 * The return value is an index into the array returned by {@link #getTrackInfo()}, and can
 * be used in calls to {@link #selectTrack(TrackInfo)}.
 *
 * @param trackType should be one of {@link TrackInfo#MEDIA_TRACK_TYPE_VIDEO} or
 * {@link TrackInfo#MEDIA_TRACK_TYPE_AUDIO}
 * @return metadata corresponding to the audio or video track currently selected for
 * playback; {@code null} is returned when there is no selected track for {@code trackType} or
 * when {@code trackType} is not one of audio or video.
 * @throws IllegalStateException if called after {@link #close()}
 *
 * @see #getTrackInfo()
 * @see #selectTrack(TrackInfo)
 */
@Nullable
public TrackInfo getSelectedTrack(@TrackInfo.MediaTrackType int trackType) {
    final int ret = mPlayer.getSelectedTrack(trackType);
    return ret < 0 ? null : mPlayer.getTrackInfo(ret);
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> selectTrack(@NonNull final TrackInfo trackInfo) {
    final int trackId = trackInfo.mId;
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.selectTrack(trackId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
/**
 * Selects a track.
 * <p>
 * If the player is in invalid state,
 * {@link androidx.media2.SessionPlayer.PlayerResult#RESULT_ERROR_INVALID_STATE} will be
 * reported with {@link androidx.media2.SessionPlayer.PlayerResult}.
 * If a player is in <em>Playing</em> state, the selected track is presented immediately.
 * If a player is not in Playing state, it just marks the track to be played.
 * </p>
 * <p>
 * In any valid state, if it is called multiple times on the same type of track (ie. Video,
 * Audio), the most recent one will be chosen.
 * </p>
 * <p>
 * The first audio and video tracks are selected by default if available, even though
 * this method is not called.
 * </p>
 * <p>
 * Currently, audio tracks can be selected via this method.
 * </p>
 * @param trackInfo metadata corresponding to the track to be selected. A {@code trackInfo}
 * object can be obtained from {@link #getTrackInfo()}.
 * <p>
 * On success, a {@link androidx.media2.SessionPlayer.PlayerResult} is returned with
 * the current media item when the command completed.
 *
 * @see #getTrackInfo
 * @return a {@link ListenableFuture} which represents the pending completion of the command.
 * {@link androidx.media2.SessionPlayer.PlayerResult} will be delivered when the command
 * completed.
 */
@NonNull
public ListenableFuture<PlayerResult> selectTrack(@NonNull final TrackInfo trackInfo) {
    final int trackId = trackInfo.mId;
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.selectTrack(trackId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
@NonNull
public ListenableFuture<PlayerResult> deselectTrack(@NonNull final TrackInfo trackInfo) {
    final int trackId = trackInfo.mId;
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.deselectTrack(trackId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_DESELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public ListenableFuture<PlayerResult> deselectTrack(@NonNull final TrackInfo trackInfo) {
    final int trackId = trackInfo.mId;
    PendingFuture<PlayerResult> pendingFuture = new PendingFuture<PlayerResult>(mExecutor) {

        @Override
        List<ResolvableFuture<PlayerResult>> onExecute() {
            ArrayList<ResolvableFuture<PlayerResult>> futures = new ArrayList<>();
            ResolvableFuture<PlayerResult> future = ResolvableFuture.create();
            synchronized (mPendingCommands) {
                Object token = mPlayer.deselectTrack(trackId);
                addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_DESELECT_TRACK, future, token);
            }
            futures.add(future);
            return futures;
        }
    };
    addPendingFuture(pendingFuture);
    return pendingFuture;
}
#end_block

#method_before
public void onSubtitleData(@NonNull MediaPlayer mp, @NonNull MediaItem item, @NonNull SubtitleData data) {
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
public void onSubtitleData(@NonNull MediaPlayer mp, @NonNull MediaItem item, @NonNull SubtitleData data) {
}
#end_block

#method_before
@RestrictTo(Scope.LIBRARY_GROUP)
protected UseCaseConfig<?> applyDefaults(UseCaseConfig<?> userConfig, UseCaseConfig.Builder<?, ?, ?> defaultConfigBuilder) {
    // over all options.
    for (Option<?> opt : userConfig.listOptions()) {
        // Options/values are being copied directly
        @SuppressWarnings("unchecked")
        Option<Object> objectOpt = (Option<Object>) opt;
        defaultConfigBuilder.getMutableConfig().insertOption(objectOpt, userConfig.retrieveOption(objectOpt));
    }
    @SuppressWarnings(// Since builder is a UseCaseConfiguration.Builder, it should produce a
    "unchecked")
    UseCaseConfig<?> // UseCaseConfiguration
    defaultConfig = defaultConfigBuilder.build();
    return defaultConfig;
}
#method_after
@RestrictTo(Scope.LIBRARY_GROUP)
protected UseCaseConfig<?> applyDefaults(UseCaseConfig<?> userConfig, UseCaseConfig.Builder<?, ?, ?> defaultConfigBuilder) {
    // over all options.
    for (Option<?> opt : userConfig.listOptions()) {
        // Options/values are being copied directly
        @SuppressWarnings("unchecked")
        Option<Object> objectOpt = (Option<Object>) opt;
        defaultConfigBuilder.getMutableConfig().insertOption(objectOpt, userConfig.retrieveOption(objectOpt));
    }
    @SuppressWarnings(// Since builder is a UseCaseConfig.Builder, it should produce a
    "unchecked")
    UseCaseConfig<?> // UseCaseConfig
    defaultConfig = defaultConfigBuilder.build();
    return defaultConfig;
}
#end_block

#method_before
@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.frag_rtt_chat, container, false);
    view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR);
    editText = view.findViewById(R.id.rtt_chat_input);
    editText.setOnEditorActionListener(this);
    editText.addTextChangedListener(this);
    editText.setOnKeyListener((v, keyCode, event) -> {
        // input box is empty.
        if (keyCode == KeyEvent.KEYCODE_DEL && event.getAction() == KeyEvent.ACTION_DOWN) {
            String lastMessage = adapter.retrieveLastLocalMessage();
            if (lastMessage != null) {
                resumeInput(lastMessage);
                rttCallScreenDelegate.onLocalMessage("\b");
                return true;
            }
            return false;
        }
        return false;
    });
    recyclerView = view.findViewById(R.id.rtt_recycler_view);
    LinearLayoutManager layoutManager = new LinearLayoutManager(getContext());
    layoutManager.setStackFromEnd(true);
    recyclerView.setLayoutManager(layoutManager);
    recyclerView.setHasFixedSize(false);
    adapter = new RttChatAdapter(getContext(), this);
    recyclerView.setAdapter(adapter);
    recyclerView.addOnScrollListener(new OnScrollListener() {

        @Override
        public void onScrollStateChanged(RecyclerView recyclerView, int i) {
            if (i == RecyclerView.SCROLL_STATE_DRAGGING) {
                isUserScrolling = true;
            } else if (i == RecyclerView.SCROLL_STATE_IDLE) {
                isUserScrolling = false;
                // Auto scrolling for new messages should be resumed if it's scrolled to bottom.
                shouldAutoScrolling = !recyclerView.canScrollVertically(1);
            }
        }

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            if (dy < 0 && isUserScrolling) {
                UiUtil.hideKeyboardFrom(getContext(), editText);
            }
        }
    });
    submitButton = view.findViewById(R.id.rtt_chat_submit_button);
    submitButton.setOnClickListener(v -> {
        Logger.get(getContext()).logImpression(DialerImpression.Type.RTT_SEND_BUTTON_CLICKED);
        adapter.submitLocalMessage();
        resumeInput("");
        rttCallScreenDelegate.onLocalMessage(Constants.BUBBLE_BREAKER);
        // Auto scrolling for new messages should be resumed since user has submit current
        // message.
        shouldAutoScrolling = true;
    });
    submitButton.setEnabled(false);
    endCallButton = view.findViewById(R.id.rtt_end_call_button);
    endCallButton.setOnClickListener(v -> {
        LogUtil.i("RttChatFragment.onClick", "end call button clicked");
        inCallButtonUiDelegate.onEndCallClicked();
    });
    overflowMenu = new RttOverflowMenu(getContext(), inCallButtonUiDelegate, inCallScreenDelegate);
    view.findViewById(R.id.rtt_overflow_button).setOnClickListener(v -> {
        // Hide keyboard when opening overflow menu. This is alternative solution since hiding
        // keyboard after the menu is open or dialpad is shown doesn't work.
        UiUtil.hideKeyboardFrom(getContext(), editText);
        overflowMenu.showAtLocation(v, Gravity.TOP | Gravity.RIGHT, 0, 0);
    });
    nameTextView = view.findViewById(R.id.rtt_name_or_number);
    chronometer = view.findViewById(R.id.rtt_timer);
    statusBanner = view.findViewById(R.id.rtt_status_banner);
    return view;
}
#method_after
@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.frag_rtt_chat, container, false);
    view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR);
    editText = view.findViewById(R.id.rtt_chat_input);
    editText.setOnEditorActionListener(this);
    editText.addTextChangedListener(this);
    editText.setOnKeyListener((v, keyCode, event) -> {
        // the input box is empty.
        if (keyCode == KeyEvent.KEYCODE_DEL && event.getAction() == KeyEvent.ACTION_DOWN && TextUtils.isEmpty(editText.getText())) {
            String lastMessage = adapter.retrieveLastLocalMessage();
            if (lastMessage != null) {
                resumeInput(lastMessage);
                rttCallScreenDelegate.onLocalMessage("\b");
                return true;
            }
            return false;
        }
        return false;
    });
    recyclerView = view.findViewById(R.id.rtt_recycler_view);
    LinearLayoutManager layoutManager = new LinearLayoutManager(getContext());
    layoutManager.setStackFromEnd(true);
    recyclerView.setLayoutManager(layoutManager);
    recyclerView.setHasFixedSize(false);
    adapter = new RttChatAdapter(getContext(), this);
    recyclerView.setAdapter(adapter);
    recyclerView.addOnScrollListener(new OnScrollListener() {

        @Override
        public void onScrollStateChanged(RecyclerView recyclerView, int i) {
            if (i == RecyclerView.SCROLL_STATE_DRAGGING) {
                isUserScrolling = true;
            } else if (i == RecyclerView.SCROLL_STATE_IDLE) {
                isUserScrolling = false;
                // Auto scrolling for new messages should be resumed if it's scrolled to bottom.
                shouldAutoScrolling = !recyclerView.canScrollVertically(1);
            }
        }

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            if (dy < 0 && isUserScrolling) {
                UiUtil.hideKeyboardFrom(getContext(), editText);
            }
        }
    });
    submitButton = view.findViewById(R.id.rtt_chat_submit_button);
    submitButton.setOnClickListener(v -> {
        Logger.get(getContext()).logImpression(DialerImpression.Type.RTT_SEND_BUTTON_CLICKED);
        adapter.submitLocalMessage();
        resumeInput("");
        rttCallScreenDelegate.onLocalMessage(Constants.BUBBLE_BREAKER);
        // Auto scrolling for new messages should be resumed since user has submit current
        // message.
        shouldAutoScrolling = true;
    });
    submitButton.setEnabled(false);
    endCallButton = view.findViewById(R.id.rtt_end_call_button);
    endCallButton.setOnClickListener(v -> {
        LogUtil.i("RttChatFragment.onClick", "end call button clicked");
        inCallButtonUiDelegate.onEndCallClicked();
    });
    overflowMenu = new RttOverflowMenu(getContext(), inCallButtonUiDelegate, inCallScreenDelegate);
    view.findViewById(R.id.rtt_overflow_button).setOnClickListener(v -> {
        // Hide keyboard when opening overflow menu. This is alternative solution since hiding
        // keyboard after the menu is open or dialpad is shown doesn't work.
        UiUtil.hideKeyboardFrom(getContext(), editText);
        overflowMenu.showAtLocation(v, Gravity.TOP | Gravity.RIGHT, 0, 0);
    });
    nameTextView = view.findViewById(R.id.rtt_name_or_number);
    chronometer = view.findViewById(R.id.rtt_timer);
    statusBanner = view.findViewById(R.id.rtt_status_banner);
    return view;
}
#end_block

#method_before
@Override
public void addCallClicked() {
    Logger.get(context).logCallImpression(DialerImpression.Type.IN_CALL_ADD_CALL_BUTTON_PRESSED, call.getUniqueCallId(), call.getTimeAddedMs());
    InCallActivity activity = getActivity();
    if (activity != null) {
        if (activity.isAutomaticallyMutedByAddCall()) {
            // Otherwise, we set previous mute state wrong.
            return;
        }
        // Automatically mute the current call
        activity.setAutomaticallyMutedByAddCall(true, /* automatically mute */
        AudioModeProvider.getInstance().getAudioState().isMuted());
        // Simulate a click on the mute button
        muteClicked(true, /* checked */
        false);
    }
    TelecomAdapter.getInstance().addCall();
}
#method_after
@Override
public void addCallClicked() {
    Logger.get(context).logCallImpression(DialerImpression.Type.IN_CALL_ADD_CALL_BUTTON_PRESSED, call.getUniqueCallId(), call.getTimeAddedMs());
    InCallPresenter.getInstance().addCallClicked();
}
#end_block

#method_before
@TargetApi(VERSION_CODES.N)
// Java 8 APIs.
@SuppressWarnings(value = { "MissingPermission", "AndroidApiChecker" })
private void updateButtonsState(DialerCall call) {
    LogUtil.v("CallButtonPresenter.updateButtonsState", "");
    final boolean isVideo = call.isVideoCall();
    // Common functionality (audio, hold, etc).
    // Show either HOLD or SWAP, but not both. If neither HOLD or SWAP is available:
    // (1) If the device normally can hold, show HOLD in a disabled state.
    // (2) If the device doesn't have the concept of hold/swap, remove the button.
    final boolean showSwap = call.can(android.telecom.Call.Details.CAPABILITY_SWAP_CONFERENCE);
    final boolean showHold = !showSwap && call.can(android.telecom.Call.Details.CAPABILITY_SUPPORT_HOLD) && call.can(android.telecom.Call.Details.CAPABILITY_HOLD);
    final boolean isCallOnHold = call.getState() == DialerCallState.ONHOLD;
    final boolean showAddCall = TelecomAdapter.getInstance().canAddCall() && UserManagerCompat.isUserUnlocked(context);
    // There can only be two calls so don't show the ability to merge when one of them
    // is a speak easy call.
    final boolean showMerge = InCallPresenter.getInstance().getCallList().getAllCalls().stream().noneMatch(c -> c != null && c.isSpeakEasyCall()) && call.can(android.telecom.Call.Details.CAPABILITY_MERGE_CONFERENCE);
    final boolean showUpgradeToVideo = !isVideo && (hasVideoCallCapabilities(call));
    final boolean showDowngradeToAudio = isVideo && isDowngradeToAudioSupported(call);
    final boolean showMute = call.can(android.telecom.Call.Details.CAPABILITY_MUTE);
    final boolean hasCameraPermission = isVideo && VideoUtils.hasCameraPermissionAndShownPrivacyToast(context);
    // Disabling local video doesn't seem to work when dialing. See a bug.
    final boolean showPauseVideo = isVideo && call.getState() != DialerCallState.DIALING && call.getState() != DialerCallState.CONNECTING;
    otherAccount = TelecomUtil.getOtherAccount(getContext(), call.getAccountHandle());
    boolean showSwapSim = !call.isEmergencyCall() && otherAccount != null && !call.isVoiceMailNumber() && DialerCallState.isDialing(call.getState()) && // Most devices cannot make calls on 2 SIMs at the same time.
    InCallPresenter.getInstance().getCallList().getAllCalls().size() == 1;
    boolean showUpgradeToRtt = call.canUpgradeToRttCall();
    boolean enableUpgradeToRtt = showUpgradeToRtt && call.getState() == DialerCallState.ACTIVE;
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_AUDIO, true);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_SWAP, showSwap);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_HOLD, showHold);
    inCallButtonUi.setHold(isCallOnHold);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_MUTE, showMute);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_SWAP_SIM, showSwapSim);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_ADD_CALL, true);
    inCallButtonUi.enableButton(InCallButtonIds.BUTTON_ADD_CALL, showAddCall);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_UPGRADE_TO_VIDEO, showUpgradeToVideo);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_UPGRADE_TO_RTT, showUpgradeToRtt);
    inCallButtonUi.enableButton(InCallButtonIds.BUTTON_UPGRADE_TO_RTT, enableUpgradeToRtt);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_DOWNGRADE_TO_AUDIO, showDowngradeToAudio);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_SWITCH_CAMERA, isVideo && hasCameraPermission && call.getVideoTech().isTransmitting());
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_PAUSE_VIDEO, showPauseVideo);
    if (isVideo) {
        inCallButtonUi.setVideoPaused(!call.getVideoTech().isTransmitting() || !hasCameraPermission);
    }
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_DIALPAD, true);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_MERGE, showMerge);
    inCallButtonUi.updateButtonStates();
}
#method_after
@SuppressWarnings(value = { "MissingPermission" })
private void updateButtonsState(DialerCall call) {
    LogUtil.v("CallButtonPresenter.updateButtonsState", "");
    final boolean isVideo = call.isVideoCall();
    // Common functionality (audio, hold, etc).
    // Show either HOLD or SWAP, but not both. If neither HOLD or SWAP is available:
    // (1) If the device normally can hold, show HOLD in a disabled state.
    // (2) If the device doesn't have the concept of hold/swap, remove the button.
    final boolean showSwap = call.can(android.telecom.Call.Details.CAPABILITY_SWAP_CONFERENCE);
    final boolean showHold = !showSwap && call.can(android.telecom.Call.Details.CAPABILITY_SUPPORT_HOLD) && call.can(android.telecom.Call.Details.CAPABILITY_HOLD);
    final boolean isCallOnHold = call.getState() == DialerCallState.ONHOLD;
    final boolean showAddCall = TelecomAdapter.getInstance().canAddCall() && UserManagerCompat.isUserUnlocked(context);
    // There can only be two calls so don't show the ability to merge when one of them
    // is a speak easy call.
    final boolean showMerge = InCallPresenter.getInstance().getCallList().getAllCalls().stream().noneMatch(c -> c != null && c.isSpeakEasyCall()) && call.can(android.telecom.Call.Details.CAPABILITY_MERGE_CONFERENCE);
    final boolean showUpgradeToVideo = !isVideo && (hasVideoCallCapabilities(call));
    final boolean showDowngradeToAudio = isVideo && isDowngradeToAudioSupported(call);
    final boolean showMute = call.can(android.telecom.Call.Details.CAPABILITY_MUTE);
    final boolean hasCameraPermission = isVideo && VideoUtils.hasCameraPermissionAndShownPrivacyToast(context);
    // Disabling local video doesn't seem to work when dialing. See a bug.
    final boolean showPauseVideo = isVideo && call.getState() != DialerCallState.DIALING && call.getState() != DialerCallState.CONNECTING;
    otherAccount = TelecomUtil.getOtherAccount(getContext(), call.getAccountHandle());
    boolean showSwapSim = !call.isEmergencyCall() && otherAccount != null && !call.isVoiceMailNumber() && DialerCallState.isDialing(call.getState()) && // Most devices cannot make calls on 2 SIMs at the same time.
    InCallPresenter.getInstance().getCallList().getAllCalls().size() == 1;
    boolean showUpgradeToRtt = call.canUpgradeToRttCall();
    boolean enableUpgradeToRtt = showUpgradeToRtt && call.getState() == DialerCallState.ACTIVE;
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_AUDIO, true);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_SWAP, showSwap);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_HOLD, showHold);
    inCallButtonUi.setHold(isCallOnHold);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_MUTE, showMute);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_SWAP_SIM, showSwapSim);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_ADD_CALL, true);
    inCallButtonUi.enableButton(InCallButtonIds.BUTTON_ADD_CALL, showAddCall);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_UPGRADE_TO_VIDEO, showUpgradeToVideo);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_UPGRADE_TO_RTT, showUpgradeToRtt);
    inCallButtonUi.enableButton(InCallButtonIds.BUTTON_UPGRADE_TO_RTT, enableUpgradeToRtt);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_DOWNGRADE_TO_AUDIO, showDowngradeToAudio);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_SWITCH_CAMERA, isVideo && hasCameraPermission && call.getVideoTech().isTransmitting());
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_PAUSE_VIDEO, showPauseVideo);
    if (isVideo) {
        inCallButtonUi.setVideoPaused(!call.getVideoTech().isTransmitting() || !hasCameraPermission);
    }
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_DIALPAD, true);
    inCallButtonUi.showButton(InCallButtonIds.BUTTON_MERGE, showMerge);
    inCallButtonUi.updateButtonStates();
}
#end_block

#method_before
@Override
public void onSessionModifyResponseReceived(int status, VideoProfile requestedProfile, VideoProfile responseProfile) {
    LogUtil.i("ImsVideoCallCallback.onSessionModifyResponseReceived", "status: %d, requestedProfile: %s, responseProfile: %s, session modification state: %d", status, requestedProfile, responseProfile, videoTech.getSessionModificationState());
    // This will update the video UI to display the error message.
    boolean showErrorMessage = false;
    switch(videoTech.getSessionModificationState()) {
        case SessionModificationState.WAITING_FOR_UPGRADE_TO_VIDEO_RESPONSE:
            if (status == VideoProvider.SESSION_MODIFY_REQUEST_SUCCESS) {
                // Telecom manages audio route for us
                listener.onUpgradedToVideo(false);
            // If the other person accepted the upgrade request then this will keep the video UI up
            // until the call's video state change. Without this we would switch to the voice call
            // and then switch back to video UI.
            } else {
                showErrorMessage = true;
            }
            break;
        case SessionModificationState.RECEIVED_UPGRADE_TO_VIDEO_REQUEST:
            requestedVideoState = VideoProfile.STATE_AUDIO_ONLY;
            videoTech.setSessionModificationState(SessionModificationState.NO_REQUEST);
            break;
        case SessionModificationState.WAITING_FOR_RESPONSE:
            if (status == VideoProvider.SESSION_MODIFY_REQUEST_SUCCESS) {
                videoTech.setSessionModificationState(getSessionModificationStateFromTelecomStatus(status));
            } else {
                showErrorMessage = true;
            }
            break;
        default:
            LogUtil.i("ImsVideoCallCallback.onSessionModifyResponseReceived", "call is not waiting for response, doing nothing");
            break;
    }
    if (showErrorMessage) {
        // Clear everything
        handler.removeCallbacksAndMessages(null);
        final int newSessionModificationState = getSessionModificationStateFromTelecomStatus(status);
        videoTech.setSessionModificationState(newSessionModificationState);
        // Wait for 4 seconds and then clean the session modification state. This allows the video UI
        // to stay up so that the user can read the error message.
        handler.postDelayed(() -> {
            if (videoTech.getSessionModificationState() == newSessionModificationState) {
                LogUtil.i("ImsVideoCallCallback.onSessionModifyResponseReceived", "clearing state");
                videoTech.setSessionModificationState(SessionModificationState.NO_REQUEST);
            } else {
                LogUtil.i("ImsVideoCallCallback.onSessionModifyResponseReceived", "session modification state has changed, not clearing state");
            }
        }, CLEAR_FAILED_REQUEST_TIMEOUT_MILLIS);
    }
}
#method_after
@Override
public void onSessionModifyResponseReceived(int status, VideoProfile requestedProfile, VideoProfile responseProfile) {
    LogUtil.i("ImsVideoCallCallback.onSessionModifyResponseReceived", "status: %d, requestedProfile: %s, responseProfile: %s, session modification state: %d", status, requestedProfile, responseProfile, videoTech.getSessionModificationState());
    if (videoTech.getSessionModificationState() == SessionModificationState.WAITING_FOR_UPGRADE_TO_VIDEO_RESPONSE) {
        final int newSessionModificationState = getSessionModificationStateFromTelecomStatus(status);
        if (status == VideoProvider.SESSION_MODIFY_REQUEST_SUCCESS) {
            // Telecom manages audio route for us
            listener.onUpgradedToVideo(false);
        } else {
            // This will update the video UI to display the error message.
            videoTech.setSessionModificationState(newSessionModificationState);
        }
        // If the other person accepted the upgrade request then this will keep the video UI up until
        // the call's video state change. Without this we would switch to the voice call and then
        // switch back to video UI.
        clearFailedResponseState(newSessionModificationState);
    } else if (videoTech.getSessionModificationState() == SessionModificationState.RECEIVED_UPGRADE_TO_VIDEO_REQUEST) {
        requestedVideoState = VideoProfile.STATE_AUDIO_ONLY;
        videoTech.setSessionModificationState(SessionModificationState.NO_REQUEST);
    } else if (videoTech.getSessionModificationState() == SessionModificationState.WAITING_FOR_RESPONSE) {
        final int newSessionModificationState = getSessionModificationStateFromTelecomStatus(status);
        videoTech.setSessionModificationState(newSessionModificationState);
        if (status != VideoProvider.SESSION_MODIFY_REQUEST_SUCCESS) {
            clearFailedResponseState(newSessionModificationState);
        }
    } else {
        LogUtil.i("ImsVideoCallCallback.onSessionModifyResponseReceived", "call is not waiting for response, doing nothing");
    }
}
#end_block

#method_before
@Override
public void onStateChange(InCallState oldState, InCallState newState, CallList callList) {
    Trace.beginSection("CallButtonPresenter.onStateChange");
    DialerCall previousCall = call;
    if (newState == InCallState.OUTGOING) {
        call = callList.getOutgoingCall();
    } else if (newState == InCallState.INCALL) {
        call = callList.getActiveOrBackgroundCall();
        // the dialpad too.)
        if (oldState == InCallState.OUTGOING && call != null) {
            if (call.isVoiceMailNumber() && getActivity() != null) {
                getActivity().showDialpadFragment(true, /* show */
                true);
            }
        }
    } else if (newState == InCallState.INCOMING) {
        if (getActivity() != null) {
            getActivity().showDialpadFragment(false, /* show */
            true);
        }
        call = callList.getIncomingCall();
    } else {
        call = null;
    }
    if (!DialerCall.areSame(previousCall, call)) {
        if (previousCall != null) {
            previousCall.removeListener(this);
        }
        if (call != null) {
            call.addListener(this);
        }
    }
    updateUi(newState, call);
    Trace.endSection();
}
#method_after
@Override
public void onStateChange(InCallState oldState, InCallState newState, CallList callList) {
    Trace.beginSection("CallButtonPresenter.onStateChange");
    if (call != null) {
        call.removeListener(this);
    }
    if (newState == InCallState.OUTGOING) {
        call = callList.getOutgoingCall();
    } else if (newState == InCallState.INCALL) {
        call = callList.getActiveOrBackgroundCall();
        // the dialpad too.)
        if (oldState == InCallState.OUTGOING && call != null) {
            if (call.isVoiceMailNumber() && getActivity() != null) {
                getActivity().showDialpadFragment(true, /* show */
                true);
            }
        }
    } else if (newState == InCallState.INCOMING) {
        if (getActivity() != null) {
            getActivity().showDialpadFragment(false, /* show */
            true);
        }
        call = callList.getIncomingCall();
    } else {
        call = null;
    }
    if (call != null) {
        call.addListener(this);
    }
    updateUi(newState, call);
    Trace.endSection();
}
#end_block

#method_before
@Test
@MediumTest
public void testRegisterForVoiceRegStateOrRatChange() {
    int vrs = NetworkRegistrationInfo.REGISTRATION_STATE_HOME;
    int vrat = sst.mSS.RIL_RADIO_TECHNOLOGY_LTE;
    sst.mSS.setRilVoiceRadioTechnology(vrat);
    sst.mSS.setVoiceRegState(vrs);
    sst.registerForVoiceRegStateOrRatChanged(mTestHandler, EVENT_VOICE_RAT_CHANGED, null);
    waitForMs(100);
    // Verify if message was posted to handler and value of result
    ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mTestHandler).sendMessageAtTime(messageArgumentCaptor.capture(), anyLong());
    assertEquals(EVENT_VOICE_RAT_CHANGED, messageArgumentCaptor.getValue().what);
    assertEquals(new Pair<Integer, Integer>(vrs, vrat), ((AsyncResult) messageArgumentCaptor.getValue().obj).result);
}
#method_after
@Test
@MediumTest
public void testRegisterForVoiceRegStateOrRatChange() {
    NetworkRegistrationInfo nri = new NetworkRegistrationInfo.Builder().setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN).setDomain(NetworkRegistrationInfo.DOMAIN_CS).setAccessNetworkTechnology(TelephonyManager.NETWORK_TYPE_LTE).build();
    sst.mSS.addNetworkRegistrationInfo(nri);
    sst.registerForVoiceRegStateOrRatChanged(mTestHandler, EVENT_VOICE_RAT_CHANGED, null);
    waitForMs(100);
    // Verify if message was posted to handler and value of result
    ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
    verify(mTestHandler).sendMessageAtTime(messageArgumentCaptor.capture(), anyLong());
    assertEquals(EVENT_VOICE_RAT_CHANGED, messageArgumentCaptor.getValue().what);
    assertEquals(new Pair<Integer, Integer>(ServiceState.STATE_IN_SERVICE, ServiceState.RIL_RADIO_TECHNOLOGY_LTE), ((AsyncResult) messageArgumentCaptor.getValue().obj).result);
}
#end_block

#method_before
@Test
@SmallTest
public void testIsConcurrentVoiceAndDataAllowed() {
    doReturn(false).when(mPhone).isPhoneTypeGsm();
    sst.mSS.setCssIndicator(1);
    assertEquals(true, sst.isConcurrentVoiceAndDataAllowed());
    sst.mSS.setCssIndicator(0);
    assertEquals(false, sst.isConcurrentVoiceAndDataAllowed());
    doReturn(true).when(mPhone).isPhoneTypeGsm();
    sst.mSS.setRilDataRadioTechnology(sst.mSS.RIL_RADIO_TECHNOLOGY_HSPA);
    assertEquals(true, sst.isConcurrentVoiceAndDataAllowed());
    sst.mSS.setRilDataRadioTechnology(sst.mSS.RIL_RADIO_TECHNOLOGY_GPRS);
    assertEquals(false, sst.isConcurrentVoiceAndDataAllowed());
    sst.mSS.setCssIndicator(1);
    assertEquals(true, sst.isConcurrentVoiceAndDataAllowed());
}
#method_after
@Test
@SmallTest
public void testIsConcurrentVoiceAndDataAllowed() {
    doReturn(false).when(mPhone).isPhoneTypeGsm();
    sst.mSS.setCssIndicator(1);
    assertEquals(true, sst.isConcurrentVoiceAndDataAllowed());
    sst.mSS.setCssIndicator(0);
    assertEquals(false, sst.isConcurrentVoiceAndDataAllowed());
    doReturn(true).when(mPhone).isPhoneTypeGsm();
    NetworkRegistrationInfo nri = new NetworkRegistrationInfo.Builder().setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN).setAccessNetworkTechnology(TelephonyManager.NETWORK_TYPE_HSPA).setDomain(NetworkRegistrationInfo.DOMAIN_PS).build();
    sst.mSS.addNetworkRegistrationInfo(nri);
    assertEquals(true, sst.isConcurrentVoiceAndDataAllowed());
    nri = new NetworkRegistrationInfo.Builder().setTransportType(AccessNetworkConstants.TRANSPORT_TYPE_WWAN).setAccessNetworkTechnology(TelephonyManager.NETWORK_TYPE_GPRS).setDomain(NetworkRegistrationInfo.DOMAIN_PS).build();
    sst.mSS.addNetworkRegistrationInfo(nri);
    assertEquals(false, sst.isConcurrentVoiceAndDataAllowed());
    sst.mSS.setCssIndicator(1);
    assertEquals(true, sst.isConcurrentVoiceAndDataAllowed());
}
#end_block

#method_before
private void changeRegState(int state, CellIdentity cid, int voiceRat, int dataRat) {
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE, LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, state, dataRat, 0, false, null, cid, 1, false, false, false, lteVopsSupportInfo);
    sst.mPollingContext[0] = 2;
    // update data reg state to be in service
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, state, voiceRat, 0, false, null, cid, false, 0, 0, 0);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
}
#method_after
private void changeRegState(int state, CellIdentity cid, int voiceRat, int dataRat) {
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE, LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, state, dataRat, 0, false, null, cid, 1, false, false, false, lteVopsSupportInfo, false);
    sst.mPollingContext[0] = 2;
    // update data reg state to be in service
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, state, voiceRat, 0, false, null, cid, false, 0, 0, 0);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
}
#end_block

#method_before
private void sendRegStateUpdateForLteCellId(CellIdentityLte cellId) {
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE, LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, 1, false, false, false, lteVopsSupportInfo);
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, false, 0, 0, 0);
    sst.mPollingContext[0] = 2;
    // update data reg state to be in service
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
}
#method_after
private void sendRegStateUpdateForLteCellId(CellIdentityLte cellId) {
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE, LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, 1, false, false, false, lteVopsSupportInfo, false);
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, false, 0, 0, 0);
    sst.mPollingContext[0] = 2;
    // update data reg state to be in service
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
}
#end_block

#method_before
@Test
public void testPhyChanBandwidthResetsOnOos() throws Exception {
    testPhyChanBandwidthRatchetedOnPhyChanBandwidth();
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE, LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_NOT_REGISTERED_OR_SEARCHING, TelephonyManager.NETWORK_TYPE_UNKNOWN, 0, false, null, null, 1, false, false, false, lteVopsSupportInfo);
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_NOT_REGISTERED_OR_SEARCHING, TelephonyManager.NETWORK_TYPE_UNKNOWN, 0, false, null, null, false, 0, 0, 0);
    sst.mPollingContext[0] = 2;
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
    assertTrue(Arrays.equals(new int[0], sst.mSS.getCellBandwidths()));
}
#method_after
@Test
public void testPhyChanBandwidthResetsOnOos() throws Exception {
    testPhyChanBandwidthRatchetedOnPhyChanBandwidth();
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE, LteVopsSupportInfo.LTE_STATUS_NOT_AVAILABLE);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_NOT_REGISTERED_OR_SEARCHING, TelephonyManager.NETWORK_TYPE_UNKNOWN, 0, false, null, null, 1, false, false, false, lteVopsSupportInfo, false);
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_NOT_REGISTERED_OR_SEARCHING, TelephonyManager.NETWORK_TYPE_UNKNOWN, 0, false, null, null, false, 0, 0, 0);
    sst.mPollingContext[0] = 2;
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
    assertTrue(Arrays.equals(new int[0], sst.mSS.getCellBandwidths()));
}
#end_block

#method_before
@Test
@SmallTest
public void testOnVopsInfoChanged() {
    ServiceState ss = new ServiceState();
    ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
    ss.setDataRegState(ServiceState.STATE_IN_SERVICE);
    sst.mSS = ss;
    CellIdentityLte cellId = new CellIdentityLte(1, 1, 5, 1, 5000, "001", "01", "test", "tst");
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED, LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, 1, false, false, false, lteVopsSupportInfo);
    sst.mPollingContext[0] = 2;
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, false, 0, 0, 0);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
    assertEquals(ServiceState.STATE_IN_SERVICE, sst.getCurrentDataConnectionState());
    NetworkRegistrationInfo sSnetworkRegistrationInfo = sst.mSS.getNetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
    assertEquals(lteVopsSupportInfo, sSnetworkRegistrationInfo.getDataSpecificStates().getLteVopsSupportInfo());
    lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_SUPPORTED, LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED);
    dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, 1, false, false, false, lteVopsSupportInfo);
    sst.mPollingContext[0] = 1;
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    sSnetworkRegistrationInfo = sst.mSS.getNetworkRegistrationInfo(2, 1);
    assertEquals(lteVopsSupportInfo, sSnetworkRegistrationInfo.getDataSpecificStates().getLteVopsSupportInfo());
}
#method_after
@Test
@SmallTest
public void testOnVopsInfoChanged() {
    ServiceState ss = new ServiceState();
    ss.setVoiceRegState(ServiceState.STATE_IN_SERVICE);
    ss.setDataRegState(ServiceState.STATE_IN_SERVICE);
    sst.mSS = ss;
    CellIdentityLte cellId = new CellIdentityLte(1, 1, 5, 1, 5000, "001", "01", "test", "tst");
    LteVopsSupportInfo lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED, LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED);
    NetworkRegistrationInfo dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, 1, false, false, false, lteVopsSupportInfo, false);
    sst.mPollingContext[0] = 2;
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    NetworkRegistrationInfo voiceResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_CS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, false, 0, 0, 0);
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_CS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, voiceResult, null)));
    waitForMs(200);
    assertEquals(ServiceState.STATE_IN_SERVICE, sst.getCurrentDataConnectionState());
    NetworkRegistrationInfo sSnetworkRegistrationInfo = sst.mSS.getNetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN);
    assertEquals(lteVopsSupportInfo, sSnetworkRegistrationInfo.getDataSpecificInfo().getLteVopsSupportInfo());
    lteVopsSupportInfo = new LteVopsSupportInfo(LteVopsSupportInfo.LTE_STATUS_SUPPORTED, LteVopsSupportInfo.LTE_STATUS_NOT_SUPPORTED);
    dataResult = new NetworkRegistrationInfo(NetworkRegistrationInfo.DOMAIN_PS, AccessNetworkConstants.TRANSPORT_TYPE_WWAN, NetworkRegistrationInfo.REGISTRATION_STATE_HOME, TelephonyManager.NETWORK_TYPE_LTE, 0, false, null, cellId, 1, false, false, false, lteVopsSupportInfo, false);
    sst.mPollingContext[0] = 1;
    sst.sendMessage(sst.obtainMessage(ServiceStateTracker.EVENT_POLL_STATE_PS_CELLULAR_REGISTRATION, new AsyncResult(sst.mPollingContext, dataResult, null)));
    waitForMs(200);
    sSnetworkRegistrationInfo = sst.mSS.getNetworkRegistrationInfo(2, 1);
    assertEquals(lteVopsSupportInfo, sSnetworkRegistrationInfo.getDataSpecificInfo().getLteVopsSupportInfo());
}
#end_block

#method_before
void addRetainedFragment(@NonNull Fragment f) {
    mNonConfig.addRetainedFragment(f);
}
#method_after
void addRetainedFragment(@NonNull Fragment f) {
    if (isStateSaved()) {
        if (FragmentManagerImpl.DEBUG) {
            Log.v(TAG, "Ignoring addRetainedFragment as the state is already saved");
        }
        return;
    }
    boolean added = mNonConfig.addRetainedFragment(f);
    if (added && FragmentManagerImpl.DEBUG) {
        Log.v(TAG, "Updating retained Fragments: Added " + f);
    }
}
#end_block

#method_before
void removeRetainedFragment(@NonNull Fragment f) {
    mNonConfig.removeRetainedFragment(f);
}
#method_after
void removeRetainedFragment(@NonNull Fragment f) {
    if (isStateSaved()) {
        if (FragmentManagerImpl.DEBUG) {
            Log.v(TAG, "Ignoring removeRetainedFragment as the state is already saved");
        }
        return;
    }
    boolean removed = mNonConfig.removeRetainedFragment(f);
    if (removed && FragmentManagerImpl.DEBUG) {
        Log.v(TAG, "Updating retained Fragments: Removed " + f);
    }
}
#end_block

#method_before
@SuppressWarnings("ReferenceEquality")
void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) {
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        if (f.mState == Fragment.INITIALIZING && f.isInBackStack()) {
            // Allow the fragment to be created so that it can be saved later.
            newState = Fragment.CREATED;
        } else {
            // While removing a fragment, we can't change it to a higher state.
            newState = f.mState;
        }
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.ACTIVITY_CREATED) {
        newState = Fragment.ACTIVITY_CREATED;
    }
    if (f.mState <= newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.getAnimatingAway() != null || f.getAnimator() != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.setAnimatingAway(null);
            f.setAnimator(null);
            moveToState(f, f.getStateAfterAnimating(), 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (newState > Fragment.INITIALIZING) {
                    if (DEBUG)
                        Log.v(TAG, "moveto CREATED: " + f);
                    if (f.mSavedFragmentState != null) {
                        f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                        Fragment target = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                        f.mTargetWho = target != null ? target.mWho : null;
                        if (f.mTargetWho != null) {
                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                        }
                        if (f.mSavedUserVisibleHint != null) {
                            f.mUserVisibleHint = f.mSavedUserVisibleHint;
                            f.mSavedUserVisibleHint = null;
                        } else {
                            f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                        }
                        if (!f.mUserVisibleHint) {
                            f.mDeferStart = true;
                            if (newState > Fragment.ACTIVITY_CREATED) {
                                newState = Fragment.ACTIVITY_CREATED;
                            }
                        }
                    }
                    f.mHost = mHost;
                    f.mParentFragment = mParent;
                    f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.mFragmentManager;
                    // so that this one can rely on it as an initialized dependency.
                    if (f.mTarget != null) {
                        if (mActive.get(f.mTarget.mWho) != f.mTarget) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTarget + " that does not belong to this FragmentManager!");
                        }
                        if (f.mTarget.mState < Fragment.CREATED) {
                            moveToState(f.mTarget, Fragment.CREATED, 0, 0, true);
                        }
                        f.mTargetWho = f.mTarget.mWho;
                        f.mTarget = null;
                    }
                    if (f.mTargetWho != null) {
                        Fragment target = mActive.get(f.mTargetWho);
                        if (target == null) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTargetWho + " that does not belong to this FragmentManager!");
                        }
                        if (target.mState < Fragment.CREATED) {
                            moveToState(target, Fragment.CREATED, 0, 0, true);
                        }
                    }
                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);
                    f.mCalled = false;
                    f.onAttach(mHost.getContext());
                    if (!f.mCalled) {
                        throw new SuperNotCalledException("Fragment " + f + " did not call through to super.onAttach()");
                    }
                    if (f.mParentFragment == null) {
                        mHost.onAttachFragment(f);
                    } else {
                        f.mParentFragment.onAttachFragment(f);
                    }
                    dispatchOnFragmentAttached(f, mHost.getContext(), false);
                    if (!f.mIsCreated) {
                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false);
                        f.performCreate(f.mSavedFragmentState);
                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                    } else {
                        f.restoreChildFragmentState(f.mSavedFragmentState);
                        f.mState = Fragment.CREATED;
                    }
                }
            // fall through
            case Fragment.CREATED:
                // we move from CREATED => CREATED as part of the case fall through above.
                if (newState > Fragment.INITIALIZING) {
                    ensureInflatedFragmentView(f);
                }
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto ACTIVITY_CREATED: " + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException("Cannot create fragment " + f + " for a container view with no id"));
                            }
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (Resources.NotFoundException e) {
                                    resName = "unknown";
                                }
                                throwException(new IllegalArgumentException("No view found for id 0x" + Integer.toHexString(f.mContainerId) + " (" + resName + ") for fragment " + f));
                            }
                        }
                        f.mContainer = container;
                        f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mInnerView = f.mView;
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                container.addView(f.mView);
                            }
                            if (f.mHidden) {
                                f.mView.setVisibility(View.GONE);
                            }
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false);
                            // Only animate the view if it is visible. This is done after
                            // dispatchOnFragmentViewCreated in case visibility is changed
                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) && f.mContainer != null;
                        } else {
                            f.mInnerView = null;
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto STARTED: " + f);
                    f.performStart();
                    dispatchOnFragmentStarted(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto RESUMED: " + f);
                    f.performResume();
                    dispatchOnFragmentResumed(f, false);
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom RESUMED: " + f);
                    f.performPause();
                    dispatchOnFragmentPaused(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom STARTED: " + f);
                    f.performStop();
                    dispatchOnFragmentStopped(f, false);
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom ACTIVITY_CREATED: " + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    dispatchOnFragmentViewDestroyed(f, false);
                    if (f.mView != null && f.mContainer != null) {
                        // Stop any current animations:
                        f.mContainer.endViewTransition(f.mView);
                        f.mView.clearAnimation();
                        AnimationOrAnimator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed && f.mView.getVisibility() == View.VISIBLE && f.mPostponedAlpha >= 0) {
                            anim = loadAnimation(f, transit, false, transitionStyle);
                        }
                        f.mPostponedAlpha = 0;
                        if (anim != null) {
                            animateRemoveFragment(f, anim, newState);
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                    // Set here to ensure that Observers are called after
                    // the Fragment's view is set to null
                    f.mViewLifecycleOwner = null;
                    f.mViewLifecycleOwnerLiveData.setValue(null);
                    f.mInnerView = null;
                    f.mInLayout = false;
                }
            // fall through
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        // the fragment.
                        if (f.getAnimatingAway() != null) {
                            View v = f.getAnimatingAway();
                            f.setAnimatingAway(null);
                            v.clearAnimation();
                        } else if (f.getAnimator() != null) {
                            Animator animator = f.getAnimator();
                            f.setAnimator(null);
                            animator.cancel();
                        }
                    }
                    if (f.getAnimatingAway() != null || f.getAnimator() != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.setStateAfterAnimating(newState);
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, "movefrom CREATED: " + f);
                        boolean beingRemoved = f.mRemoving && !f.isInBackStack();
                        if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                            boolean shouldClear;
                            if (mHost instanceof ViewModelStoreOwner) {
                                shouldClear = mNonConfig.isCleared();
                            } else if (mHost.getContext() instanceof Activity) {
                                Activity activity = (Activity) mHost.getContext();
                                shouldClear = !activity.isChangingConfigurations();
                            } else {
                                shouldClear = true;
                            }
                            if (beingRemoved || shouldClear) {
                                mNonConfig.clearNonConfigState(f);
                            }
                            f.performDestroy();
                            dispatchOnFragmentDestroyed(f, false);
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        dispatchOnFragmentDetached(f, false);
                        if (!keepActive) {
                            if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                if (f.mTargetWho != null) {
                                    Fragment target = mActive.get(f.mTargetWho);
                                    if (target != null && target.getRetainInstance()) {
                                        // Only keep references to other retained Fragments
                                        // to avoid developers accessing Fragments that
                                        // are never coming back
                                        f.mTarget = target;
                                    }
                                }
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, "moveToState: Fragment state for " + f + " not updated inline; " + "expected state " + newState + " found " + f.mState);
        f.mState = newState;
    }
}
#method_after
@SuppressWarnings("ReferenceEquality")
void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) {
    // Fragments that are not currently added will sit in the onCreate() state.
    if ((!f.mAdded || f.mDetached) && newState > Fragment.CREATED) {
        newState = Fragment.CREATED;
    }
    if (f.mRemoving && newState > f.mState) {
        if (f.mState == Fragment.INITIALIZING && f.isInBackStack()) {
            // Allow the fragment to be created so that it can be saved later.
            newState = Fragment.CREATED;
        } else {
            // While removing a fragment, we can't change it to a higher state.
            newState = f.mState;
        }
    }
    // if it's not already started.
    if (f.mDeferStart && f.mState < Fragment.STARTED && newState > Fragment.ACTIVITY_CREATED) {
        newState = Fragment.ACTIVITY_CREATED;
    }
    // Don't allow the Fragment to go above its max lifecycle state
    newState = Math.min(newState, f.mMaxState.ordinal());
    if (f.mState <= newState) {
        // being reloaded from the layout.
        if (f.mFromLayout && !f.mInLayout) {
            return;
        }
        if (f.getAnimatingAway() != null || f.getAnimator() != null) {
            // The fragment is currently being animated...  but!  Now we
            // want to move our state back up.  Give up on waiting for the
            // animation, move to whatever the final state should be once
            // the animation is done, and then we can proceed from there.
            f.setAnimatingAway(null);
            f.setAnimator(null);
            moveToState(f, f.getStateAfterAnimating(), 0, 0, true);
        }
        switch(f.mState) {
            case Fragment.INITIALIZING:
                if (newState > Fragment.INITIALIZING) {
                    if (DEBUG)
                        Log.v(TAG, "moveto CREATED: " + f);
                    if (f.mSavedFragmentState != null) {
                        f.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
                        f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
                        Fragment target = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG);
                        f.mTargetWho = target != null ? target.mWho : null;
                        if (f.mTargetWho != null) {
                            f.mTargetRequestCode = f.mSavedFragmentState.getInt(FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0);
                        }
                        if (f.mSavedUserVisibleHint != null) {
                            f.mUserVisibleHint = f.mSavedUserVisibleHint;
                            f.mSavedUserVisibleHint = null;
                        } else {
                            f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true);
                        }
                        if (!f.mUserVisibleHint) {
                            f.mDeferStart = true;
                            if (newState > Fragment.ACTIVITY_CREATED) {
                                newState = Fragment.ACTIVITY_CREATED;
                            }
                        }
                    }
                    f.mHost = mHost;
                    f.mParentFragment = mParent;
                    f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.mFragmentManager;
                    // so that this one can rely on it as an initialized dependency.
                    if (f.mTarget != null) {
                        if (mActive.get(f.mTarget.mWho) != f.mTarget) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTarget + " that does not belong to this FragmentManager!");
                        }
                        if (f.mTarget.mState < Fragment.CREATED) {
                            moveToState(f.mTarget, Fragment.CREATED, 0, 0, true);
                        }
                        f.mTargetWho = f.mTarget.mWho;
                        f.mTarget = null;
                    }
                    if (f.mTargetWho != null) {
                        Fragment target = mActive.get(f.mTargetWho);
                        if (target == null) {
                            throw new IllegalStateException("Fragment " + f + " declared target fragment " + f.mTargetWho + " that does not belong to this FragmentManager!");
                        }
                        if (target.mState < Fragment.CREATED) {
                            moveToState(target, Fragment.CREATED, 0, 0, true);
                        }
                    }
                    dispatchOnFragmentPreAttached(f, mHost.getContext(), false);
                    f.mCalled = false;
                    f.onAttach(mHost.getContext());
                    if (!f.mCalled) {
                        throw new SuperNotCalledException("Fragment " + f + " did not call through to super.onAttach()");
                    }
                    if (f.mParentFragment == null) {
                        mHost.onAttachFragment(f);
                    } else {
                        f.mParentFragment.onAttachFragment(f);
                    }
                    dispatchOnFragmentAttached(f, mHost.getContext(), false);
                    if (!f.mIsCreated) {
                        dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false);
                        f.performCreate(f.mSavedFragmentState);
                        dispatchOnFragmentCreated(f, f.mSavedFragmentState, false);
                    } else {
                        f.restoreChildFragmentState(f.mSavedFragmentState);
                        f.mState = Fragment.CREATED;
                    }
                }
            // fall through
            case Fragment.CREATED:
                // we move from CREATED => CREATED as part of the case fall through above.
                if (newState > Fragment.INITIALIZING) {
                    ensureInflatedFragmentView(f);
                }
                if (newState > Fragment.CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto ACTIVITY_CREATED: " + f);
                    if (!f.mFromLayout) {
                        ViewGroup container = null;
                        if (f.mContainerId != 0) {
                            if (f.mContainerId == View.NO_ID) {
                                throwException(new IllegalArgumentException("Cannot create fragment " + f + " for a container view with no id"));
                            }
                            container = (ViewGroup) mContainer.onFindViewById(f.mContainerId);
                            if (container == null && !f.mRestored) {
                                String resName;
                                try {
                                    resName = f.getResources().getResourceName(f.mContainerId);
                                } catch (Resources.NotFoundException e) {
                                    resName = "unknown";
                                }
                                throwException(new IllegalArgumentException("No view found for id 0x" + Integer.toHexString(f.mContainerId) + " (" + resName + ") for fragment " + f));
                            }
                        }
                        f.mContainer = container;
                        f.performCreateView(f.performGetLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);
                        if (f.mView != null) {
                            f.mInnerView = f.mView;
                            f.mView.setSaveFromParentEnabled(false);
                            if (container != null) {
                                container.addView(f.mView);
                            }
                            if (f.mHidden) {
                                f.mView.setVisibility(View.GONE);
                            }
                            f.onViewCreated(f.mView, f.mSavedFragmentState);
                            dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false);
                            // Only animate the view if it is visible. This is done after
                            // dispatchOnFragmentViewCreated in case visibility is changed
                            f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) && f.mContainer != null;
                        } else {
                            f.mInnerView = null;
                        }
                    }
                    f.performActivityCreated(f.mSavedFragmentState);
                    dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false);
                    if (f.mView != null) {
                        f.restoreViewState(f.mSavedFragmentState);
                    }
                    f.mSavedFragmentState = null;
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState > Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto STARTED: " + f);
                    f.performStart();
                    dispatchOnFragmentStarted(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState > Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "moveto RESUMED: " + f);
                    f.performResume();
                    dispatchOnFragmentResumed(f, false);
                    f.mSavedFragmentState = null;
                    f.mSavedViewState = null;
                }
        }
    } else if (f.mState > newState) {
        switch(f.mState) {
            case Fragment.RESUMED:
                if (newState < Fragment.RESUMED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom RESUMED: " + f);
                    f.performPause();
                    dispatchOnFragmentPaused(f, false);
                }
            // fall through
            case Fragment.STARTED:
                if (newState < Fragment.STARTED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom STARTED: " + f);
                    f.performStop();
                    dispatchOnFragmentStopped(f, false);
                }
            // fall through
            case Fragment.ACTIVITY_CREATED:
                if (newState < Fragment.ACTIVITY_CREATED) {
                    if (DEBUG)
                        Log.v(TAG, "movefrom ACTIVITY_CREATED: " + f);
                    if (f.mView != null) {
                        // done already.
                        if (mHost.onShouldSaveFragmentState(f) && f.mSavedViewState == null) {
                            saveFragmentViewState(f);
                        }
                    }
                    f.performDestroyView();
                    dispatchOnFragmentViewDestroyed(f, false);
                    if (f.mView != null && f.mContainer != null) {
                        // Stop any current animations:
                        f.mContainer.endViewTransition(f.mView);
                        f.mView.clearAnimation();
                        AnimationOrAnimator anim = null;
                        if (mCurState > Fragment.INITIALIZING && !mDestroyed && f.mView.getVisibility() == View.VISIBLE && f.mPostponedAlpha >= 0) {
                            anim = loadAnimation(f, transit, false, transitionStyle);
                        }
                        f.mPostponedAlpha = 0;
                        if (anim != null) {
                            animateRemoveFragment(f, anim, newState);
                        }
                        f.mContainer.removeView(f.mView);
                    }
                    f.mContainer = null;
                    f.mView = null;
                    // Set here to ensure that Observers are called after
                    // the Fragment's view is set to null
                    f.mViewLifecycleOwner = null;
                    f.mViewLifecycleOwnerLiveData.setValue(null);
                    f.mInnerView = null;
                    f.mInLayout = false;
                }
            // fall through
            case Fragment.CREATED:
                if (newState < Fragment.CREATED) {
                    if (mDestroyed) {
                        // the fragment.
                        if (f.getAnimatingAway() != null) {
                            View v = f.getAnimatingAway();
                            f.setAnimatingAway(null);
                            v.clearAnimation();
                        } else if (f.getAnimator() != null) {
                            Animator animator = f.getAnimator();
                            f.setAnimator(null);
                            animator.cancel();
                        }
                    }
                    if (f.getAnimatingAway() != null || f.getAnimator() != null) {
                        // We are waiting for the fragment's view to finish
                        // animating away.  Just make a note of the state
                        // the fragment now should move to once the animation
                        // is done.
                        f.setStateAfterAnimating(newState);
                        newState = Fragment.CREATED;
                    } else {
                        if (DEBUG)
                            Log.v(TAG, "movefrom CREATED: " + f);
                        boolean beingRemoved = f.mRemoving && !f.isInBackStack();
                        if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                            boolean shouldClear;
                            if (mHost instanceof ViewModelStoreOwner) {
                                shouldClear = mNonConfig.isCleared();
                            } else if (mHost.getContext() instanceof Activity) {
                                Activity activity = (Activity) mHost.getContext();
                                shouldClear = !activity.isChangingConfigurations();
                            } else {
                                shouldClear = true;
                            }
                            if (beingRemoved || shouldClear) {
                                mNonConfig.clearNonConfigState(f);
                            }
                            f.performDestroy();
                            dispatchOnFragmentDestroyed(f, false);
                        } else {
                            f.mState = Fragment.INITIALIZING;
                        }
                        f.performDetach();
                        dispatchOnFragmentDetached(f, false);
                        if (!keepActive) {
                            if (beingRemoved || mNonConfig.shouldDestroy(f)) {
                                makeInactive(f);
                            } else {
                                f.mHost = null;
                                f.mParentFragment = null;
                                f.mFragmentManager = null;
                                if (f.mTargetWho != null) {
                                    Fragment target = mActive.get(f.mTargetWho);
                                    if (target != null && target.getRetainInstance()) {
                                        // Only keep references to other retained Fragments
                                        // to avoid developers accessing Fragments that
                                        // are never coming back
                                        f.mTarget = target;
                                    }
                                }
                            }
                        }
                    }
                }
        }
    }
    if (f.mState != newState) {
        Log.w(TAG, "moveToState: Fragment state for " + f + " not updated inline; " + "expected state " + newState + " found " + f.mState);
        f.mState = newState;
    }
}
#end_block

#method_before
void moveFragmentToExpectedState(Fragment f) {
    if (f == null) {
        return;
    }
    int nextState = mCurState;
    if (f.mRemoving) {
        if (f.isInBackStack()) {
            nextState = Math.min(nextState, Fragment.CREATED);
        } else {
            nextState = Math.min(nextState, Fragment.INITIALIZING);
        }
    }
    // so we adjust the state to ensure fragments can go to initialized.
    if (f.mMaxState == Lifecycle.State.INITIALIZED) {
        nextState = 0;
    } else {
        nextState = Math.min(nextState, f.mMaxState.ordinal());
    }
    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false);
    if (f.mView != null) {
        // Move the view if it is out of order
        Fragment underFragment = findFragmentUnder(f);
        if (underFragment != null) {
            final View underView = underFragment.mView;
            // make sure this fragment is in the right order.
            final ViewGroup container = f.mContainer;
            int underIndex = container.indexOfChild(underView);
            int viewIndex = container.indexOfChild(f.mView);
            if (viewIndex < underIndex) {
                container.removeViewAt(viewIndex);
                container.addView(f.mView, underIndex);
            }
        }
        if (f.mIsNewlyAdded && f.mContainer != null) {
            // Make it visible and run the animations
            if (f.mPostponedAlpha > 0f) {
                f.mView.setAlpha(f.mPostponedAlpha);
            }
            f.mPostponedAlpha = 0f;
            f.mIsNewlyAdded = false;
            // run animations:
            AnimationOrAnimator anim = loadAnimation(f, f.getNextTransition(), true, f.getNextTransitionStyle());
            if (anim != null) {
                if (anim.animation != null) {
                    f.mView.startAnimation(anim.animation);
                } else {
                    anim.animator.setTarget(f.mView);
                    anim.animator.start();
                }
            }
        }
    }
    if (f.mHiddenChanged) {
        completeShowHideFragment(f);
    }
}
#method_after
void moveFragmentToExpectedState(Fragment f) {
    if (f == null) {
        return;
    }
    if (!mActive.containsKey(f.mWho)) {
        if (DEBUG) {
            Log.v(TAG, "Ignoring moving " + f + " to state " + mCurState + "since it is not added to " + this);
        }
        return;
    }
    int nextState = mCurState;
    if (f.mRemoving) {
        if (f.isInBackStack()) {
            nextState = Math.min(nextState, Fragment.CREATED);
        } else {
            nextState = Math.min(nextState, Fragment.INITIALIZING);
        }
    }
    moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false);
    if (f.mView != null) {
        // Move the view if it is out of order
        Fragment underFragment = findFragmentUnder(f);
        if (underFragment != null) {
            final View underView = underFragment.mView;
            // make sure this fragment is in the right order.
            final ViewGroup container = f.mContainer;
            int underIndex = container.indexOfChild(underView);
            int viewIndex = container.indexOfChild(f.mView);
            if (viewIndex < underIndex) {
                container.removeViewAt(viewIndex);
                container.addView(f.mView, underIndex);
            }
        }
        if (f.mIsNewlyAdded && f.mContainer != null) {
            // Make it visible and run the animations
            if (f.mPostponedAlpha > 0f) {
                f.mView.setAlpha(f.mPostponedAlpha);
            }
            f.mPostponedAlpha = 0f;
            f.mIsNewlyAdded = false;
            // run animations:
            AnimationOrAnimator anim = loadAnimation(f, f.getNextTransition(), true, f.getNextTransitionStyle());
            if (anim != null) {
                if (anim.animation != null) {
                    f.mView.startAnimation(anim.animation);
                } else {
                    anim.animator.setTarget(f.mView);
                    anim.animator.start();
                }
            }
        }
    }
    if (f.mHiddenChanged) {
        completeShowHideFragment(f);
    }
}
#end_block

#method_before
void restoreSaveState(Parcelable state) {
    // If there is no saved state at all, then there's nothing else to do
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    for (Fragment f : mNonConfig.getRetainedFragments()) {
        if (DEBUG)
            Log.v(TAG, "restoreAllState: re-attaching retained " + f);
        FragmentState fs = null;
        for (FragmentState fragmentState : fms.mActive) {
            if (fragmentState.mWho.equals(f.mWho)) {
                fs = fragmentState;
                break;
            }
        }
        if (fs == null) {
            throwException(new IllegalStateException("Could not find active fragment " + "with unique id " + f.mWho));
        }
        fs.mInstance = f;
        f.mSavedViewState = null;
        f.mBackStackNesting = 0;
        f.mInLayout = false;
        f.mAdded = false;
        f.mTargetWho = f.mTarget != null ? f.mTarget.mWho : null;
        f.mTarget = null;
        if (fs.mSavedFragmentState != null) {
            fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
            f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            f.mSavedFragmentState = fs.mSavedFragmentState;
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive.clear();
    for (FragmentState fs : fms.mActive) {
        if (fs != null) {
            Fragment f = fs.instantiate(mHost.getContext().getClassLoader(), getFragmentFactory());
            f.mFragmentManager = this;
            if (DEBUG)
                Log.v(TAG, "restoreAllState: active (" + f.mWho + "): " + f);
            mActive.put(f.mWho, f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        }
    }
    // Build the list of currently added fragments.
    mAdded.clear();
    if (fms.mAdded != null) {
        for (String who : fms.mAdded) {
            Fragment f = mActive.get(who);
            if (f == null) {
                throwException(new IllegalStateException("No instantiated fragment for (" + who + ")"));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, "restoreAllState: added (" + who + "): " + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException("Already added!");
            }
            synchronized (mAdded) {
                mAdded.add(f);
            }
        }
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, "restoreAllState: back stack #" + i + " (index " + bse.mIndex + "): " + bse);
                LogWriter logw = new LogWriter(TAG);
                PrintWriter pw = new PrintWriter(logw);
                bse.dump("  ", pw, false);
                pw.close();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
    if (fms.mPrimaryNavActiveWho != null) {
        mPrimaryNav = mActive.get(fms.mPrimaryNavActiveWho);
    }
    this.mNextFragmentIndex = fms.mNextFragmentIndex;
}
#method_after
void restoreSaveState(Parcelable state) {
    // If there is no saved state at all, then there's nothing else to do
    if (state == null)
        return;
    FragmentManagerState fms = (FragmentManagerState) state;
    if (fms.mActive == null)
        return;
    // to their saved state, so we don't try to instantiate them again.
    for (Fragment f : mNonConfig.getRetainedFragments()) {
        if (DEBUG)
            Log.v(TAG, "restoreSaveState: re-attaching retained " + f);
        FragmentState fs = null;
        for (FragmentState fragmentState : fms.mActive) {
            if (fragmentState.mWho.equals(f.mWho)) {
                fs = fragmentState;
                break;
            }
        }
        if (fs == null) {
            throwException(new IllegalStateException("Could not find active fragment " + "with unique id " + f.mWho));
        }
        fs.mInstance = f;
        f.mSavedViewState = null;
        f.mBackStackNesting = 0;
        f.mInLayout = false;
        f.mAdded = false;
        f.mTargetWho = f.mTarget != null ? f.mTarget.mWho : null;
        f.mTarget = null;
        if (fs.mSavedFragmentState != null) {
            fs.mSavedFragmentState.setClassLoader(mHost.getContext().getClassLoader());
            f.mSavedViewState = fs.mSavedFragmentState.getSparseParcelableArray(FragmentManagerImpl.VIEW_STATE_TAG);
            f.mSavedFragmentState = fs.mSavedFragmentState;
        }
    }
    // Build the full list of active fragments, instantiating them from
    // their saved state.
    mActive.clear();
    for (FragmentState fs : fms.mActive) {
        if (fs != null) {
            Fragment f = fs.instantiate(mHost.getContext().getClassLoader(), getFragmentFactory());
            f.mFragmentManager = this;
            if (DEBUG)
                Log.v(TAG, "restoreAllState: active (" + f.mWho + "): " + f);
            mActive.put(f.mWho, f);
            // Now that the fragment is instantiated (or came from being
            // retained above), clear mInstance in case we end up re-restoring
            // from this FragmentState again.
            fs.mInstance = null;
        }
    }
    // Build the list of currently added fragments.
    mAdded.clear();
    if (fms.mAdded != null) {
        for (String who : fms.mAdded) {
            Fragment f = mActive.get(who);
            if (f == null) {
                throwException(new IllegalStateException("No instantiated fragment for (" + who + ")"));
            }
            f.mAdded = true;
            if (DEBUG)
                Log.v(TAG, "restoreAllState: added (" + who + "): " + f);
            if (mAdded.contains(f)) {
                throw new IllegalStateException("Already added!");
            }
            synchronized (mAdded) {
                mAdded.add(f);
            }
        }
    }
    // Build the back stack.
    if (fms.mBackStack != null) {
        mBackStack = new ArrayList<BackStackRecord>(fms.mBackStack.length);
        for (int i = 0; i < fms.mBackStack.length; i++) {
            BackStackRecord bse = fms.mBackStack[i].instantiate(this);
            if (DEBUG) {
                Log.v(TAG, "restoreAllState: back stack #" + i + " (index " + bse.mIndex + "): " + bse);
                LogWriter logw = new LogWriter(TAG);
                PrintWriter pw = new PrintWriter(logw);
                bse.dump("  ", pw, false);
                pw.close();
            }
            mBackStack.add(bse);
            if (bse.mIndex >= 0) {
                setBackStackIndex(bse.mIndex, bse);
            }
        }
    } else {
        mBackStack = null;
    }
    if (fms.mPrimaryNavActiveWho != null) {
        mPrimaryNav = mActive.get(fms.mPrimaryNavActiveWho);
    }
    this.mNextFragmentIndex = fms.mNextFragmentIndex;
}
#end_block

#method_before
public void dump(String prefix, PrintWriter writer, boolean full) {
    if (full) {
        writer.print(prefix);
        writer.print("mName=");
        writer.print(mName);
        writer.print(" mIndex=");
        writer.print(mIndex);
        writer.print(" mCommitted=");
        writer.println(mCommitted);
        if (mTransition != FragmentTransaction.TRANSIT_NONE) {
            writer.print(prefix);
            writer.print("mTransition=#");
            writer.print(Integer.toHexString(mTransition));
            writer.print(" mTransitionStyle=#");
            writer.println(Integer.toHexString(mTransitionStyle));
        }
        if (mEnterAnim != 0 || mExitAnim != 0) {
            writer.print(prefix);
            writer.print("mEnterAnim=#");
            writer.print(Integer.toHexString(mEnterAnim));
            writer.print(" mExitAnim=#");
            writer.println(Integer.toHexString(mExitAnim));
        }
        if (mPopEnterAnim != 0 || mPopExitAnim != 0) {
            writer.print(prefix);
            writer.print("mPopEnterAnim=#");
            writer.print(Integer.toHexString(mPopEnterAnim));
            writer.print(" mPopExitAnim=#");
            writer.println(Integer.toHexString(mPopExitAnim));
        }
        if (mBreadCrumbTitleRes != 0 || mBreadCrumbTitleText != null) {
            writer.print(prefix);
            writer.print("mBreadCrumbTitleRes=#");
            writer.print(Integer.toHexString(mBreadCrumbTitleRes));
            writer.print(" mBreadCrumbTitleText=");
            writer.println(mBreadCrumbTitleText);
        }
        if (mBreadCrumbShortTitleRes != 0 || mBreadCrumbShortTitleText != null) {
            writer.print(prefix);
            writer.print("mBreadCrumbShortTitleRes=#");
            writer.print(Integer.toHexString(mBreadCrumbShortTitleRes));
            writer.print(" mBreadCrumbShortTitleText=");
            writer.println(mBreadCrumbShortTitleText);
        }
    }
    if (!mOps.isEmpty()) {
        writer.print(prefix);
        writer.println("Operations:");
        final int numOps = mOps.size();
        for (int opNum = 0; opNum < numOps; opNum++) {
            final Op op = mOps.get(opNum);
            String cmdStr;
            switch(op.cmd) {
                case OP_NULL:
                    cmdStr = "NULL";
                    break;
                case OP_ADD:
                    cmdStr = "ADD";
                    break;
                case OP_REPLACE:
                    cmdStr = "REPLACE";
                    break;
                case OP_REMOVE:
                    cmdStr = "REMOVE";
                    break;
                case OP_HIDE:
                    cmdStr = "HIDE";
                    break;
                case OP_SHOW:
                    cmdStr = "SHOW";
                    break;
                case OP_DETACH:
                    cmdStr = "DETACH";
                    break;
                case OP_ATTACH:
                    cmdStr = "ATTACH";
                    break;
                case OP_SET_PRIMARY_NAV:
                    cmdStr = "SET_PRIMARY_NAV";
                    break;
                case OP_UNSET_PRIMARY_NAV:
                    cmdStr = "UNSET_PRIMARY_NAV";
                    break;
                default:
                    cmdStr = "cmd=" + op.cmd;
                    break;
            }
            writer.print(prefix);
            writer.print("  Op #");
            writer.print(opNum);
            writer.print(": ");
            writer.print(cmdStr);
            writer.print(" ");
            writer.println(op.fragment);
            if (full) {
                if (op.enterAnim != 0 || op.exitAnim != 0) {
                    writer.print(prefix);
                    writer.print("enterAnim=#");
                    writer.print(Integer.toHexString(op.enterAnim));
                    writer.print(" exitAnim=#");
                    writer.println(Integer.toHexString(op.exitAnim));
                }
                if (op.popEnterAnim != 0 || op.popExitAnim != 0) {
                    writer.print(prefix);
                    writer.print("popEnterAnim=#");
                    writer.print(Integer.toHexString(op.popEnterAnim));
                    writer.print(" popExitAnim=#");
                    writer.println(Integer.toHexString(op.popExitAnim));
                }
            }
        }
    }
}
#method_after
public void dump(String prefix, PrintWriter writer, boolean full) {
    if (full) {
        writer.print(prefix);
        writer.print("mName=");
        writer.print(mName);
        writer.print(" mIndex=");
        writer.print(mIndex);
        writer.print(" mCommitted=");
        writer.println(mCommitted);
        if (mTransition != FragmentTransaction.TRANSIT_NONE) {
            writer.print(prefix);
            writer.print("mTransition=#");
            writer.print(Integer.toHexString(mTransition));
            writer.print(" mTransitionStyle=#");
            writer.println(Integer.toHexString(mTransitionStyle));
        }
        if (mEnterAnim != 0 || mExitAnim != 0) {
            writer.print(prefix);
            writer.print("mEnterAnim=#");
            writer.print(Integer.toHexString(mEnterAnim));
            writer.print(" mExitAnim=#");
            writer.println(Integer.toHexString(mExitAnim));
        }
        if (mPopEnterAnim != 0 || mPopExitAnim != 0) {
            writer.print(prefix);
            writer.print("mPopEnterAnim=#");
            writer.print(Integer.toHexString(mPopEnterAnim));
            writer.print(" mPopExitAnim=#");
            writer.println(Integer.toHexString(mPopExitAnim));
        }
        if (mBreadCrumbTitleRes != 0 || mBreadCrumbTitleText != null) {
            writer.print(prefix);
            writer.print("mBreadCrumbTitleRes=#");
            writer.print(Integer.toHexString(mBreadCrumbTitleRes));
            writer.print(" mBreadCrumbTitleText=");
            writer.println(mBreadCrumbTitleText);
        }
        if (mBreadCrumbShortTitleRes != 0 || mBreadCrumbShortTitleText != null) {
            writer.print(prefix);
            writer.print("mBreadCrumbShortTitleRes=#");
            writer.print(Integer.toHexString(mBreadCrumbShortTitleRes));
            writer.print(" mBreadCrumbShortTitleText=");
            writer.println(mBreadCrumbShortTitleText);
        }
    }
    if (!mOps.isEmpty()) {
        writer.print(prefix);
        writer.println("Operations:");
        final int numOps = mOps.size();
        for (int opNum = 0; opNum < numOps; opNum++) {
            final Op op = mOps.get(opNum);
            String cmdStr;
            switch(op.mCmd) {
                case OP_NULL:
                    cmdStr = "NULL";
                    break;
                case OP_ADD:
                    cmdStr = "ADD";
                    break;
                case OP_REPLACE:
                    cmdStr = "REPLACE";
                    break;
                case OP_REMOVE:
                    cmdStr = "REMOVE";
                    break;
                case OP_HIDE:
                    cmdStr = "HIDE";
                    break;
                case OP_SHOW:
                    cmdStr = "SHOW";
                    break;
                case OP_DETACH:
                    cmdStr = "DETACH";
                    break;
                case OP_ATTACH:
                    cmdStr = "ATTACH";
                    break;
                case OP_SET_PRIMARY_NAV:
                    cmdStr = "SET_PRIMARY_NAV";
                    break;
                case OP_UNSET_PRIMARY_NAV:
                    cmdStr = "UNSET_PRIMARY_NAV";
                    break;
                case OP_SET_MAX_LIFECYCLE:
                    cmdStr = "OP_SET_MAX_LIFECYCLE";
                    break;
                case OP_UNSET_MAX_LIFECYCLE:
                    cmdStr = "OP_UNSET_MAX_LIFECYCLE";
                    break;
                default:
                    cmdStr = "cmd=" + op.mCmd;
                    break;
            }
            writer.print(prefix);
            writer.print("  Op #");
            writer.print(opNum);
            writer.print(": ");
            writer.print(cmdStr);
            writer.print(" ");
            writer.println(op.mFragment);
            if (full) {
                if (op.mEnterAnim != 0 || op.mExitAnim != 0) {
                    writer.print(prefix);
                    writer.print("enterAnim=#");
                    writer.print(Integer.toHexString(op.mEnterAnim));
                    writer.print(" exitAnim=#");
                    writer.println(Integer.toHexString(op.mExitAnim));
                }
                if (op.mPopEnterAnim != 0 || op.mPopExitAnim != 0) {
                    writer.print(prefix);
                    writer.print("popEnterAnim=#");
                    writer.print(Integer.toHexString(op.mPopEnterAnim));
                    writer.print(" popExitAnim=#");
                    writer.println(Integer.toHexString(op.mPopExitAnim));
                }
            }
        }
    }
}
#end_block

#method_before
private void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) {
    final Class fragmentClass = fragment.getClass();
    final int modifiers = fragmentClass.getModifiers();
    if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() && !Modifier.isStatic(modifiers))) {
        throw new IllegalStateException("Fragment " + fragmentClass.getCanonicalName() + " must be a public static class to be  properly recreated from" + " instance state.");
    }
    fragment.mFragmentManager = mManager;
    if (tag != null) {
        if (fragment.mTag != null && !tag.equals(fragment.mTag)) {
            throw new IllegalStateException("Can't change tag of fragment " + fragment + ": was " + fragment.mTag + " now " + tag);
        }
        fragment.mTag = tag;
    }
    if (containerViewId != 0) {
        if (containerViewId == View.NO_ID) {
            throw new IllegalArgumentException("Can't add fragment " + fragment + " with tag " + tag + " to container view with no id");
        }
        if (fragment.mFragmentId != 0 && fragment.mFragmentId != containerViewId) {
            throw new IllegalStateException("Can't change container ID of fragment " + fragment + ": was " + fragment.mFragmentId + " now " + containerViewId);
        }
        fragment.mContainerId = fragment.mFragmentId = containerViewId;
    }
    addOp(new Op(opcmd, fragment));
}
#method_after
@Override
void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) {
    super.doAddOp(containerViewId, fragment, tag, opcmd);
    fragment.mFragmentManager = mManager;
}
#end_block

#method_before
@NonNull
@Override
public FragmentTransaction remove(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot remove Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_REMOVE, fragment));
    return this;
}
#method_after
@NonNull
@Override
public FragmentTransaction remove(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot remove Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    return super.remove(fragment);
}
#end_block

#method_before
@NonNull
@Override
public FragmentTransaction hide(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot hide Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_HIDE, fragment));
    return this;
}
#method_after
@NonNull
@Override
public FragmentTransaction hide(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot hide Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    return super.hide(fragment);
}
#end_block

#method_before
@NonNull
@Override
public FragmentTransaction show(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot show Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_SHOW, fragment));
    return this;
}
#method_after
@NonNull
@Override
public FragmentTransaction show(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot show Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    return super.show(fragment);
}
#end_block

#method_before
@NonNull
@Override
public FragmentTransaction detach(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot detach Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_DETACH, fragment));
    return this;
}
#method_after
@NonNull
@Override
public FragmentTransaction detach(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot detach Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    return super.detach(fragment);
}
#end_block

#method_before
@NonNull
@Override
public FragmentTransaction setPrimaryNavigationFragment(@Nullable Fragment fragment) {
    if (fragment != null && fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot setPrimaryNavigation for Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_SET_PRIMARY_NAV, fragment));
    return this;
}
#method_after
@NonNull
@Override
public FragmentTransaction setPrimaryNavigationFragment(@Nullable Fragment fragment) {
    if (fragment != null && fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot setPrimaryNavigation for Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    return super.setPrimaryNavigationFragment(fragment);
}
#end_block

#method_before
@NonNull
@Override
public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment, @NonNull Lifecycle.State state) {
    if (fragment.mFragmentManager != mManager) {
        throw new IllegalArgumentException("Cannot setMaxLifecycle for Fragment not attached to" + " FragmentManager " + mManager);
    }
    if (!state.isAtLeast(Lifecycle.State.INITIALIZED)) {
        throw new IllegalArgumentException("Cannot setMaxLifecycle to " + Lifecycle.State.DESTROYED);
    }
    fragment.mMaxState = state;
    if (fragment.mState > state.ordinal()) {
        mManager.moveFragmentToExpectedState(fragment);
    }
    return this;
}
#method_after
@NonNull
@Override
public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment, @NonNull Lifecycle.State state) {
    if (fragment.mFragmentManager != mManager) {
        throw new IllegalArgumentException("Cannot setMaxLifecycle for Fragment not attached to" + " FragmentManager " + mManager);
    }
    if (!state.isAtLeast(Lifecycle.State.CREATED)) {
        throw new IllegalArgumentException("Cannot set maximum Lifecycle below " + Lifecycle.State.CREATED);
    }
    return super.setMaxLifecycle(fragment, state);
}
#end_block

#method_before
void bumpBackStackNesting(int amt) {
    if (!mAddToBackStack) {
        return;
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, "Bump nesting in " + this + " by " + amt);
    final int numOps = mOps.size();
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        if (op.fragment != null) {
            op.fragment.mBackStackNesting += amt;
            if (FragmentManagerImpl.DEBUG)
                Log.v(TAG, "Bump nesting of " + op.fragment + " to " + op.fragment.mBackStackNesting);
        }
    }
}
#method_after
void bumpBackStackNesting(int amt) {
    if (!mAddToBackStack) {
        return;
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, "Bump nesting in " + this + " by " + amt);
    final int numOps = mOps.size();
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        if (op.mFragment != null) {
            op.mFragment.mBackStackNesting += amt;
            if (FragmentManagerImpl.DEBUG)
                Log.v(TAG, "Bump nesting of " + op.mFragment + " to " + op.mFragment.mBackStackNesting);
        }
    }
}
#end_block

#method_before
public void runOnCommitRunnables() {
    if (mCommitRunnables != null) {
        for (int i = 0, N = mCommitRunnables.size(); i < N; i++) {
            mCommitRunnables.get(i).run();
        }
        mCommitRunnables = null;
    }
}
#method_after
public void runOnCommitRunnables() {
    if (mCommitRunnables != null) {
        for (int i = 0; i < mCommitRunnables.size(); i++) {
            mCommitRunnables.get(i).run();
        }
        mCommitRunnables = null;
    }
}
#end_block

#method_before
boolean interactsWith(int containerId) {
    final int numOps = mOps.size();
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        final int fragContainer = op.fragment != null ? op.fragment.mContainerId : 0;
        if (fragContainer != 0 && fragContainer == containerId) {
            return true;
        }
    }
    return false;
}
#method_after
boolean interactsWith(int containerId) {
    final int numOps = mOps.size();
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        final int fragContainer = op.mFragment != null ? op.mFragment.mContainerId : 0;
        if (fragContainer != 0 && fragContainer == containerId) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
boolean interactsWith(ArrayList<BackStackRecord> records, int startIndex, int endIndex) {
    if (endIndex == startIndex) {
        return false;
    }
    final int numOps = mOps.size();
    int lastContainer = -1;
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        final int container = op.fragment != null ? op.fragment.mContainerId : 0;
        if (container != 0 && container != lastContainer) {
            lastContainer = container;
            for (int i = startIndex; i < endIndex; i++) {
                BackStackRecord record = records.get(i);
                final int numThoseOps = record.mOps.size();
                for (int thoseOpIndex = 0; thoseOpIndex < numThoseOps; thoseOpIndex++) {
                    final Op thatOp = record.mOps.get(thoseOpIndex);
                    final int thatContainer = thatOp.fragment != null ? thatOp.fragment.mContainerId : 0;
                    if (thatContainer == container) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
#method_after
boolean interactsWith(ArrayList<BackStackRecord> records, int startIndex, int endIndex) {
    if (endIndex == startIndex) {
        return false;
    }
    final int numOps = mOps.size();
    int lastContainer = -1;
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        final int container = op.mFragment != null ? op.mFragment.mContainerId : 0;
        if (container != 0 && container != lastContainer) {
            lastContainer = container;
            for (int i = startIndex; i < endIndex; i++) {
                BackStackRecord record = records.get(i);
                final int numThoseOps = record.mOps.size();
                for (int thoseOpIndex = 0; thoseOpIndex < numThoseOps; thoseOpIndex++) {
                    final Op thatOp = record.mOps.get(thoseOpIndex);
                    final int thatContainer = thatOp.mFragment != null ? thatOp.mFragment.mContainerId : 0;
                    if (thatContainer == container) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
void executeOps() {
    final int numOps = mOps.size();
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        final Fragment f = op.fragment;
        if (f != null) {
            f.setNextTransition(mTransition, mTransitionStyle);
        }
        switch(op.cmd) {
            case OP_ADD:
                f.setNextAnim(op.enterAnim);
                mManager.addFragment(f, false);
                break;
            case OP_REMOVE:
                f.setNextAnim(op.exitAnim);
                mManager.removeFragment(f);
                break;
            case OP_HIDE:
                f.setNextAnim(op.exitAnim);
                mManager.hideFragment(f);
                break;
            case OP_SHOW:
                f.setNextAnim(op.enterAnim);
                mManager.showFragment(f);
                break;
            case OP_DETACH:
                f.setNextAnim(op.exitAnim);
                mManager.detachFragment(f);
                break;
            case OP_ATTACH:
                f.setNextAnim(op.enterAnim);
                mManager.attachFragment(f);
                break;
            case OP_SET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(f);
                break;
            case OP_UNSET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(null);
                break;
            default:
                throw new IllegalArgumentException("Unknown cmd: " + op.cmd);
        }
        if (!mReorderingAllowed && op.cmd != OP_ADD && f != null) {
            mManager.moveFragmentToExpectedState(f);
        }
    }
    if (!mReorderingAllowed) {
        // Added fragments are added at the end to comply with prior behavior.
        mManager.moveToState(mManager.mCurState, true);
    }
}
#method_after
void executeOps() {
    final int numOps = mOps.size();
    for (int opNum = 0; opNum < numOps; opNum++) {
        final Op op = mOps.get(opNum);
        final Fragment f = op.mFragment;
        if (f != null) {
            f.setNextTransition(mTransition, mTransitionStyle);
        }
        switch(op.mCmd) {
            case OP_ADD:
                f.setNextAnim(op.mEnterAnim);
                mManager.addFragment(f, false);
                break;
            case OP_REMOVE:
                f.setNextAnim(op.mExitAnim);
                mManager.removeFragment(f);
                break;
            case OP_HIDE:
                f.setNextAnim(op.mExitAnim);
                mManager.hideFragment(f);
                break;
            case OP_SHOW:
                f.setNextAnim(op.mEnterAnim);
                mManager.showFragment(f);
                break;
            case OP_DETACH:
                f.setNextAnim(op.mExitAnim);
                mManager.detachFragment(f);
                break;
            case OP_ATTACH:
                f.setNextAnim(op.mEnterAnim);
                mManager.attachFragment(f);
                break;
            case OP_SET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(f);
                break;
            case OP_UNSET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(null);
                break;
            case OP_SET_MAX_LIFECYCLE:
                mManager.setMaxLifecycle(f, op.mState);
                break;
            case OP_UNSET_MAX_LIFECYCLE:
                mManager.setMaxLifecycle(f, op.mState);
                break;
            default:
                throw new IllegalArgumentException("Unknown cmd: " + op.mCmd);
        }
        if (!mReorderingAllowed && op.mCmd != OP_ADD && f != null) {
            mManager.moveFragmentToExpectedState(f);
        }
    }
    if (!mReorderingAllowed) {
        // Added fragments are added at the end to comply with prior behavior.
        mManager.moveToState(mManager.mCurState, true);
    }
}
#end_block

#method_before
void executePopOps(boolean moveToState) {
    for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) {
        final Op op = mOps.get(opNum);
        Fragment f = op.fragment;
        if (f != null) {
            f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition), mTransitionStyle);
        }
        switch(op.cmd) {
            case OP_ADD:
                f.setNextAnim(op.popExitAnim);
                mManager.removeFragment(f);
                break;
            case OP_REMOVE:
                f.setNextAnim(op.popEnterAnim);
                mManager.addFragment(f, false);
                break;
            case OP_HIDE:
                f.setNextAnim(op.popEnterAnim);
                mManager.showFragment(f);
                break;
            case OP_SHOW:
                f.setNextAnim(op.popExitAnim);
                mManager.hideFragment(f);
                break;
            case OP_DETACH:
                f.setNextAnim(op.popEnterAnim);
                mManager.attachFragment(f);
                break;
            case OP_ATTACH:
                f.setNextAnim(op.popExitAnim);
                mManager.detachFragment(f);
                break;
            case OP_SET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(null);
                break;
            case OP_UNSET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(f);
                break;
            default:
                throw new IllegalArgumentException("Unknown cmd: " + op.cmd);
        }
        if (!mReorderingAllowed && op.cmd != OP_REMOVE && f != null) {
            mManager.moveFragmentToExpectedState(f);
        }
    }
    if (!mReorderingAllowed && moveToState) {
        mManager.moveToState(mManager.mCurState, true);
    }
}
#method_after
void executePopOps(boolean moveToState) {
    for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) {
        final Op op = mOps.get(opNum);
        Fragment f = op.mFragment;
        if (f != null) {
            f.setNextTransition(FragmentManagerImpl.reverseTransit(mTransition), mTransitionStyle);
        }
        switch(op.mCmd) {
            case OP_ADD:
                f.setNextAnim(op.mPopExitAnim);
                mManager.removeFragment(f);
                break;
            case OP_REMOVE:
                f.setNextAnim(op.mPopEnterAnim);
                mManager.addFragment(f, false);
                break;
            case OP_HIDE:
                f.setNextAnim(op.mPopEnterAnim);
                mManager.showFragment(f);
                break;
            case OP_SHOW:
                f.setNextAnim(op.mPopExitAnim);
                mManager.hideFragment(f);
                break;
            case OP_DETACH:
                f.setNextAnim(op.mPopEnterAnim);
                mManager.attachFragment(f);
                break;
            case OP_ATTACH:
                f.setNextAnim(op.mPopExitAnim);
                mManager.detachFragment(f);
                break;
            case OP_SET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(null);
                break;
            case OP_UNSET_PRIMARY_NAV:
                mManager.setPrimaryNavigationFragment(f);
                break;
            case OP_SET_MAX_LIFECYCLE:
                mManager.setMaxLifecycle(f, op.mState);
                break;
            case OP_UNSET_MAX_LIFECYCLE:
                mManager.setMaxLifecycle(f, op.mState);
                break;
            default:
                throw new IllegalArgumentException("Unknown cmd: " + op.mCmd);
        }
        if (!mReorderingAllowed && op.mCmd != OP_REMOVE && f != null) {
            mManager.moveFragmentToExpectedState(f);
        }
    }
    if (!mReorderingAllowed && moveToState) {
        mManager.moveToState(mManager.mCurState, true);
    }
}
#end_block

#method_before
@SuppressWarnings("ReferenceEquality")
Fragment expandOps(ArrayList<Fragment> added, Fragment oldPrimaryNav) {
    for (int opNum = 0; opNum < mOps.size(); opNum++) {
        final Op op = mOps.get(opNum);
        switch(op.cmd) {
            case OP_ADD:
            case OP_ATTACH:
                added.add(op.fragment);
                break;
            case OP_REMOVE:
            case OP_DETACH:
                {
                    added.remove(op.fragment);
                    if (op.fragment == oldPrimaryNav) {
                        mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, op.fragment));
                        opNum++;
                        oldPrimaryNav = null;
                    }
                }
                break;
            case OP_REPLACE:
                {
                    final Fragment f = op.fragment;
                    final int containerId = f.mContainerId;
                    boolean alreadyAdded = false;
                    for (int i = added.size() - 1; i >= 0; i--) {
                        final Fragment old = added.get(i);
                        if (old.mContainerId == containerId) {
                            if (old == f) {
                                alreadyAdded = true;
                            } else {
                                // a single pass for expanding ops. Unset any outgoing primary nav.
                                if (old == oldPrimaryNav) {
                                    mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, old));
                                    opNum++;
                                    oldPrimaryNav = null;
                                }
                                final Op removeOp = new Op(OP_REMOVE, old);
                                removeOp.enterAnim = op.enterAnim;
                                removeOp.popEnterAnim = op.popEnterAnim;
                                removeOp.exitAnim = op.exitAnim;
                                removeOp.popExitAnim = op.popExitAnim;
                                mOps.add(opNum, removeOp);
                                added.remove(old);
                                opNum++;
                            }
                        }
                    }
                    if (alreadyAdded) {
                        mOps.remove(opNum);
                        opNum--;
                    } else {
                        op.cmd = OP_ADD;
                        added.add(f);
                    }
                }
                break;
            case OP_SET_PRIMARY_NAV:
                {
                    // It's ok if this is null, that means we will restore to no active
                    // primary navigation fragment on a pop.
                    mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, oldPrimaryNav));
                    opNum++;
                    // Will be set by the OP_SET_PRIMARY_NAV we inserted before when run
                    oldPrimaryNav = op.fragment;
                }
                break;
        }
    }
    return oldPrimaryNav;
}
#method_after
@SuppressWarnings("ReferenceEquality")
Fragment expandOps(ArrayList<Fragment> added, Fragment oldPrimaryNav) {
    for (int opNum = 0; opNum < mOps.size(); opNum++) {
        final Op op = mOps.get(opNum);
        switch(op.mCmd) {
            case OP_ADD:
            case OP_ATTACH:
                added.add(op.mFragment);
                break;
            case OP_REMOVE:
            case OP_DETACH:
                {
                    added.remove(op.mFragment);
                    if (op.mFragment == oldPrimaryNav) {
                        mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, op.mFragment));
                        opNum++;
                        oldPrimaryNav = null;
                    }
                }
                break;
            case OP_REPLACE:
                {
                    final Fragment f = op.mFragment;
                    final int containerId = f.mContainerId;
                    boolean alreadyAdded = false;
                    for (int i = added.size() - 1; i >= 0; i--) {
                        final Fragment old = added.get(i);
                        if (old.mContainerId == containerId) {
                            if (old == f) {
                                alreadyAdded = true;
                            } else {
                                // a single pass for expanding ops. Unset any outgoing primary nav.
                                if (old == oldPrimaryNav) {
                                    mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, old));
                                    opNum++;
                                    oldPrimaryNav = null;
                                }
                                final Op removeOp = new Op(OP_REMOVE, old);
                                removeOp.mEnterAnim = op.mEnterAnim;
                                removeOp.mPopEnterAnim = op.mPopEnterAnim;
                                removeOp.mExitAnim = op.mExitAnim;
                                removeOp.mPopExitAnim = op.mPopExitAnim;
                                mOps.add(opNum, removeOp);
                                added.remove(old);
                                opNum++;
                            }
                        }
                    }
                    if (alreadyAdded) {
                        mOps.remove(opNum);
                        opNum--;
                    } else {
                        op.mCmd = OP_ADD;
                        added.add(f);
                    }
                }
                break;
            case OP_SET_PRIMARY_NAV:
                {
                    // It's ok if this is null, that means we will restore to no active
                    // primary navigation fragment on a pop.
                    mOps.add(opNum, new Op(OP_UNSET_PRIMARY_NAV, oldPrimaryNav));
                    opNum++;
                    // Will be set by the OP_SET_PRIMARY_NAV we inserted before when run
                    oldPrimaryNav = op.mFragment;
                }
                break;
            case OP_SET_MAX_LIFECYCLE:
                {
                    // A pop will restore the value of the current max state
                    mOps.add(opNum, new Op(OP_UNSET_MAX_LIFECYCLE, op.mFragment, op.mFragment.mMaxState));
                    opNum++;
                }
                break;
        }
    }
    return oldPrimaryNav;
}
#end_block

#method_before
Fragment trackAddedFragmentsInPop(ArrayList<Fragment> added, Fragment oldPrimaryNav) {
    for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) {
        final Op op = mOps.get(opNum);
        switch(op.cmd) {
            case OP_ADD:
            case OP_ATTACH:
                added.remove(op.fragment);
                break;
            case OP_REMOVE:
            case OP_DETACH:
                added.add(op.fragment);
                break;
            case OP_UNSET_PRIMARY_NAV:
                oldPrimaryNav = op.fragment;
                break;
            case OP_SET_PRIMARY_NAV:
                oldPrimaryNav = null;
                break;
        }
    }
    return oldPrimaryNav;
}
#method_after
Fragment trackAddedFragmentsInPop(ArrayList<Fragment> added, Fragment oldPrimaryNav) {
    for (int opNum = mOps.size() - 1; opNum >= 0; opNum--) {
        final Op op = mOps.get(opNum);
        switch(op.mCmd) {
            case OP_ADD:
            case OP_ATTACH:
                added.remove(op.mFragment);
                break;
            case OP_REMOVE:
            case OP_DETACH:
                added.add(op.mFragment);
                break;
            case OP_UNSET_PRIMARY_NAV:
                oldPrimaryNav = op.mFragment;
                break;
            case OP_SET_PRIMARY_NAV:
                oldPrimaryNav = null;
                break;
            case OP_UNSET_MAX_LIFECYCLE:
                op.mFragment.mMaxState = op.mState;
                break;
            case OP_SET_MAX_LIFECYCLE:
                op.mState = op.mFragment.mMaxState;
                break;
        }
    }
    return oldPrimaryNav;
}
#end_block

#method_before
void setOnStartPostponedListener(Fragment.OnStartEnterTransitionListener listener) {
    for (int opNum = 0; opNum < mOps.size(); opNum++) {
        final Op op = mOps.get(opNum);
        if (isFragmentPostponed(op)) {
            op.fragment.setOnStartEnterTransitionListener(listener);
        }
    }
}
#method_after
void setOnStartPostponedListener(Fragment.OnStartEnterTransitionListener listener) {
    for (int opNum = 0; opNum < mOps.size(); opNum++) {
        final Op op = mOps.get(opNum);
        if (isFragmentPostponed(op)) {
            op.mFragment.setOnStartEnterTransitionListener(listener);
        }
    }
}
#end_block

#method_before
private static boolean isFragmentPostponed(Op op) {
    final Fragment fragment = op.fragment;
    return fragment != null && fragment.mAdded && fragment.mView != null && !fragment.mDetached && !fragment.mHidden && fragment.isPostponed();
}
#method_after
private static boolean isFragmentPostponed(Op op) {
    final Fragment fragment = op.mFragment;
    return fragment != null && fragment.mAdded && fragment.mView != null && !fragment.mDetached && !fragment.mHidden && fragment.isPostponed();
}
#end_block

#method_before
@NonNull
public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment, @NonNull Lifecycle.State state) {
    throw new UnsupportedOperationException("Must override setMaxLifecycle");
}
#method_after
@NonNull
public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment, @NonNull Lifecycle.State state) {
    addOp(new Op(OP_SET_MAX_LIFECYCLE, fragment, state));
    return this;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public void navigate(@IdRes int resId, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    navigate(resId, null, args, navOptions, navigatorExtras);
}
#method_after
@SuppressWarnings("deprecation")
public void navigate(@IdRes int resId, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    NavDestination currentNode = mBackStack.isEmpty() ? mGraph : mBackStack.getLast().getDestination();
    if (currentNode == null) {
        throw new IllegalStateException("no current navigation node");
    }
    @IdRes
    int destId = resId;
    final NavAction navAction = currentNode.getAction(resId);
    Bundle combinedArgs = null;
    if (navAction != null) {
        if (navOptions == null) {
            navOptions = navAction.getNavOptions();
        }
        destId = navAction.getDestinationId();
        Bundle navActionArgs = navAction.getDefaultArguments();
        if (navActionArgs != null) {
            combinedArgs = new Bundle();
            combinedArgs.putAll(navActionArgs);
        }
    }
    if (args != null) {
        if (combinedArgs == null) {
            combinedArgs = new Bundle();
        }
        combinedArgs.putAll(args);
    }
    if (destId == 0 && navOptions != null && navOptions.getPopUpTo() != -1) {
        popBackStack(navOptions.getPopUpTo(), navOptions.isPopUpToInclusive());
        return;
    }
    if (destId == 0) {
        throw new IllegalArgumentException("Destination id == 0 can only be used" + " in conjunction with a valid navOptions.popUpTo");
    }
    NavDestination node = findDestination(destId);
    if (node == null) {
        final String dest = NavDestination.getDisplayName(mContext, destId);
        throw new IllegalArgumentException("navigation destination " + dest + (navAction != null ? " referenced from action " + NavDestination.getDisplayName(mContext, resId) : "") + " is unknown to this NavController");
    }
    navigate(node, combinedArgs, navOptions, navigatorExtras);
}
#end_block

#method_before
public void navigate(@NonNull Uri deepLink) {
    NavDestination.DeepLinkMatch deepLinkMatch = mGraph.matchDeepLink(deepLink);
    if (deepLinkMatch != null) {
        int resId = deepLinkMatch.getDestination().getId();
        Bundle args = deepLinkMatch.getMatchingArgs();
        navigate(resId, deepLinkMatch, args, null, null);
    } else {
        throw new IllegalArgumentException("navigation destination with deepLink " + deepLink + " is unknown to this NavController");
    }
}
#method_after
public void navigate(@NonNull Uri deepLink) {
    navigate(deepLink, null);
}
#end_block

#method_before
public void navigate(@NonNull NavDirections directions, @NonNull Navigator.Extras navigatorExtras) {
    navigate(directions.getActionId(), directions.getArguments(), null, navigatorExtras);
}
#method_after
public void navigate(@NonNull Uri deepLink, @Nullable NavOptions navOptions) {
    navigate(deepLink, navOptions, null);
}
#end_block

#method_before
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerViewImpl(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManagerImpl(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    // Create ScrollEventAdapter before attaching PagerSnapHelper to RecyclerView, because the
    // attach process calls PagerSnapHelperImpl.findSnapView, which uses the mScrollEventAdapter
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    // Create FakeDrag before attaching PagerSnapHelper, same reason as above
    mFakeDragger = new FakeDrag(this, mScrollEventAdapter, mRecyclerView);
    mPagerSnapHelper = new PagerSnapHelperImpl();
    mPagerSnapHelper.attachToRecyclerView(mRecyclerView);
    // Add mScrollEventAdapter after attaching mPagerSnapHelper to mRecyclerView, because we
    // don't want to respond on the events sent out during the attach process
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    mPageChangeEventDispatcher = new CompositeOnPageChangeCallback(3);
    mScrollEventAdapter.setOnPageChangeCallback(mPageChangeEventDispatcher);
    // Callback that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback() {

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }
    };
    // Add currentItemUpdater before mExternalPageChangeCallbacks, because we need to update
    // internal state first
    mPageChangeEventDispatcher.addOnPageChangeCallback(currentItemUpdater);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mExternalPageChangeCallbacks);
    // Add mPageTransformerAdapter after mExternalPageChangeCallbacks, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#method_after
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerViewImpl(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManagerImpl(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    // Create ScrollEventAdapter before attaching PagerSnapHelper to RecyclerView, because the
    // attach process calls PagerSnapHelperImpl.findSnapView, which uses the mScrollEventAdapter
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    // Create FakeDrag before attaching PagerSnapHelper, same reason as above
    mFakeDragger = new FakeDrag(this, mScrollEventAdapter, mRecyclerView);
    mPagerSnapHelper = new PagerSnapHelperImpl();
    mPagerSnapHelper.attachToRecyclerView(mRecyclerView);
    // Add mScrollEventAdapter after attaching mPagerSnapHelper to mRecyclerView, because we
    // don't want to respond on the events sent out during the attach process
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    CompositeOnPageChangeCallback pageChangeEventDispatcher = new CompositeOnPageChangeCallback(3);
    mScrollEventAdapter.setOnPageChangeCallback(pageChangeEventDispatcher);
    // Callback that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback() {

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }
    };
    // Add currentItemUpdater before mExternalPageChangeCallbacks, because we need to update
    // internal state first
    pageChangeEventDispatcher.addOnPageChangeCallback(currentItemUpdater);
    pageChangeEventDispatcher.addOnPageChangeCallback(mExternalPageChangeCallbacks);
    // Add mPageTransformerAdapter after mExternalPageChangeCallbacks, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    pageChangeEventDispatcher.addOnPageChangeCallback(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#end_block

#method_before
@Nullable
@Override
protected Parcelable onSaveInstanceState() {
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.mRecyclerViewId = mRecyclerView.getId();
    ss.mOrientation = getOrientation();
    ss.mCurrentItem = mCurrentItem;
    ss.mUserScrollable = mUserInputEnabled;
    ss.mScrollInProgress = mLayoutManager.findFirstCompletelyVisibleItemPosition() != mCurrentItem;
    Adapter adapter = mRecyclerView.getAdapter();
    if (adapter instanceof StatefulAdapter) {
        ss.mAdapterState = ((StatefulAdapter) adapter).saveState();
    }
    return ss;
}
#method_after
@Nullable
@Override
protected Parcelable onSaveInstanceState() {
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.mRecyclerViewId = mRecyclerView.getId();
    ss.mCurrentItem = mPendingCurrentItem == NO_POSITION ? mCurrentItem : mPendingCurrentItem;
    if (mPendingAdapterState != null) {
        ss.mAdapterState = mPendingAdapterState;
    } else {
        Adapter adapter = mRecyclerView.getAdapter();
        if (adapter instanceof StatefulAdapter) {
            ss.mAdapterState = ((StatefulAdapter) adapter).saveState();
        }
    }
    return ss;
}
#end_block

#method_before
@Override
protected void onRestoreInstanceState(Parcelable state) {
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    setOrientation(ss.mOrientation);
    mCurrentItem = ss.mCurrentItem;
    mUserInputEnabled = ss.mUserScrollable;
    if (ss.mScrollInProgress) {
        // A scroll was in progress, so the RecyclerView is not at mCurrentItem right now. Move
        // it to mCurrentItem instantly in the _next_ frame, as RecyclerView is not yet fired up
        // at this moment. Remove the event dispatcher during this time, as it will fire a
        // scroll event for the current position, which has already been fired before the config
        // change.
        final ScrollEventAdapter scrollEventAdapter = mScrollEventAdapter;
        final OnPageChangeCallback eventDispatcher = mPageChangeEventDispatcher;
        scrollEventAdapter.setOnPageChangeCallback(null);
        // to avoid a synthetic accessor
        final RecyclerView recyclerView = mRecyclerView;
        recyclerView.post(new Runnable() {

            @Override
            public void run() {
                scrollEventAdapter.setOnPageChangeCallback(eventDispatcher);
                scrollEventAdapter.notifyRestoreCurrentItem(mCurrentItem);
                recyclerView.scrollToPosition(mCurrentItem);
            }
        });
    } else {
        mScrollEventAdapter.notifyRestoreCurrentItem(mCurrentItem);
    }
    if (ss.mAdapterState != null) {
        Adapter adapter = mRecyclerView.getAdapter();
        if (adapter instanceof StatefulAdapter) {
            ((StatefulAdapter) adapter).restoreState(ss.mAdapterState);
        }
    }
}
#method_after
@Override
protected void onRestoreInstanceState(Parcelable state) {
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    mPendingCurrentItem = ss.mCurrentItem;
    mPendingAdapterState = ss.mAdapterState;
}
#end_block

#method_before
@Override
protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container) {
    // RecyclerView changed an id, so we need to reflect that in the saved state
    Parcelable state = container.get(getId());
    if (state instanceof SavedState) {
        final int previousRvId = ((SavedState) state).mRecyclerViewId;
        final int currentRvId = mRecyclerView.getId();
        container.put(currentRvId, container.get(previousRvId));
        container.remove(previousRvId);
    }
    super.dispatchRestoreInstanceState(container);
}
#method_after
@Override
protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container) {
    // RecyclerView changed an id, so we need to reflect that in the saved state
    Parcelable state = container.get(getId());
    if (state instanceof SavedState) {
        final int previousRvId = ((SavedState) state).mRecyclerViewId;
        final int currentRvId = mRecyclerView.getId();
        container.put(currentRvId, container.get(previousRvId));
        container.remove(previousRvId);
    }
    super.dispatchRestoreInstanceState(container);
    // State of ViewPager2 and its child (RecyclerView) has been restored now
    restorePendingState();
}
#end_block

#method_before
private void readValues(Parcel source, ClassLoader loader) {
    mRecyclerViewId = source.readInt();
    mOrientation = source.readInt();
    mCurrentItem = source.readInt();
    mUserScrollable = source.readByte() != 0;
    mScrollInProgress = source.readByte() != 0;
    mAdapterState = source.readParcelable(loader);
}
#method_after
private void readValues(Parcel source, ClassLoader loader) {
    mRecyclerViewId = source.readInt();
    mCurrentItem = source.readInt();
    mAdapterState = source.readParcelable(loader);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    super.writeToParcel(out, flags);
    out.writeInt(mRecyclerViewId);
    out.writeInt(mOrientation);
    out.writeInt(mCurrentItem);
    out.writeByte((byte) (mUserScrollable ? 1 : 0));
    out.writeByte((byte) (mScrollInProgress ? 1 : 0));
    out.writeParcelable(mAdapterState, flags);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    super.writeToParcel(out, flags);
    out.writeInt(mRecyclerViewId);
    out.writeInt(mCurrentItem);
    out.writeParcelable(mAdapterState, flags);
}
#end_block

#method_before
public void setAdapter(@Nullable Adapter adapter) {
    mRecyclerView.setAdapter(adapter);
}
#method_after
public void setAdapter(@Nullable Adapter adapter) {
    mRecyclerView.setAdapter(adapter);
    restorePendingState();
}
#end_block

#method_before
public void setCurrentItem(int item, boolean smoothScroll) {
    if (isFakeDragging()) {
        throw new IllegalStateException("Cannot change current item when ViewPager2 is fake " + "dragging");
    }
    Adapter adapter = getAdapter();
    if (adapter == null || adapter.getItemCount() <= 0) {
        return;
    }
    item = Math.max(item, 0);
    item = Math.min(item, adapter.getItemCount() - 1);
    if (item == mCurrentItem && mScrollEventAdapter.isIdle()) {
        // Already at the correct page
        return;
    }
    if (item == mCurrentItem && smoothScroll) {
        // because then we need to interrupt the current smooth scroll.
        return;
    }
    float previousItem = mCurrentItem;
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item, mRecyclerView));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#method_after
public void setCurrentItem(int item, boolean smoothScroll) {
    if (isFakeDragging()) {
        throw new IllegalStateException("Cannot change current item when ViewPager2 is fake " + "dragging");
    }
    Adapter adapter = getAdapter();
    if (adapter == null) {
        // Update the pending current item if we're still waiting for the adapter
        if (mPendingCurrentItem != NO_POSITION) {
            mPendingCurrentItem = Math.max(item, 0);
        }
        return;
    }
    if (adapter.getItemCount() <= 0) {
        // Adapter is empty
        return;
    }
    item = Math.max(item, 0);
    item = Math.min(item, adapter.getItemCount() - 1);
    if (item == mCurrentItem && mScrollEventAdapter.isIdle()) {
        // Already at the correct page
        return;
    }
    if (item == mCurrentItem && smoothScroll) {
        // because then we need to interrupt the current smooth scroll.
        return;
    }
    // 2. Update the item internally
    float previousItem = mCurrentItem;
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    // 3. Perform the necessary scroll actions on RecyclerView
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item, mRecyclerView));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#end_block

#method_before
public void setOffscreenPageLimit(int limit) {
    if (limit < 1 && limit != OFFSCREEN_PAGE_LIMIT_DISABLED) {
        throw new IllegalArgumentException("Offscreen page limit must be OFFSCREEN_PAGE_LIMIT_DISABLED or a number > 0");
    }
    mOffscreenPageLimit = limit;
    mRecyclerView.setItemViewCacheSize(limit == OFFSCREEN_PAGE_LIMIT_DISABLED ? 2 : 0);
    mLayoutManager.setItemPrefetchEnabled(limit == OFFSCREEN_PAGE_LIMIT_DISABLED);
    // Trigger layout so prefetch happens through getExtraLayoutSize()
    mRecyclerView.requestLayout();
}
#method_after
public void setOffscreenPageLimit(int limit) {
    if (limit < 1 && limit != OFFSCREEN_PAGE_LIMIT_DEFAULT) {
        throw new IllegalArgumentException("Offscreen page limit must be OFFSCREEN_PAGE_LIMIT_DEFAULT or a number > 0");
    }
    mOffscreenPageLimit = limit;
    // Trigger layout so prefetch happens through getExtraLayoutSize()
    mRecyclerView.requestLayout();
}
#end_block

#method_before
public void setPageTransformer(@Nullable PageTransformer transformer) {
    // TODO: add support for reverseDrawingOrder: b/112892792
    // TODO: add support for pageLayerType: b/112893074
    PageTransformer oldTransformer = mPageTransformerAdapter.getPageTransformer();
    mPageTransformerAdapter.setPageTransformer(transformer);
    if (transformer != null && transformer != oldTransformer) {
        requestTransform();
    }
}
#method_after
public void setPageTransformer(@Nullable PageTransformer transformer) {
    // TODO: add support for pageLayerType: b/112893074
    if (transformer == mPageTransformerAdapter.getPageTransformer()) {
        return;
    }
    mPageTransformerAdapter.setPageTransformer(transformer);
    requestTransform();
}
#end_block

#method_before
public void requestTransform() {
    if (mPageTransformerAdapter.getPageTransformer() == null) {
        return;
    }
    float relativePosition = mScrollEventAdapter.getRelativeScrollPosition();
    int position = (int) relativePosition;
    float positionOffset = relativePosition - position;
    int size;
    if (getOrientation() == ORIENTATION_HORIZONTAL) {
        size = getWidth() - getPaddingLeft() - getPaddingRight();
    } else {
        size = getHeight() - getPaddingTop() - getPaddingBottom();
    }
    int positionOffsetPx = Math.round(size * positionOffset);
    mPageTransformerAdapter.onPageScrolled(position, positionOffset, positionOffsetPx);
}
#method_after
public void requestTransform() {
    if (mPageTransformerAdapter.getPageTransformer() == null) {
        return;
    }
    float relativePosition = mScrollEventAdapter.getRelativeScrollPosition();
    int position = (int) relativePosition;
    float positionOffset = relativePosition - position;
    int positionOffsetPx = Math.round(getPageSize() * positionOffset);
    mPageTransformerAdapter.onPageScrolled(position, positionOffset, positionOffsetPx);
}
#end_block

#method_before
@Override
public void onInitializeAccessibilityNodeInfo(@NonNull RecyclerView.Recycler recycler, @NonNull RecyclerView.State state, @NonNull AccessibilityNodeInfoCompat info) {
    super.onInitializeAccessibilityNodeInfo(recycler, state, info);
    if (!isUserInputEnabled()) {
        info.removeAction(AccessibilityActionCompat.ACTION_SCROLL_BACKWARD);
        info.removeAction(AccessibilityActionCompat.ACTION_SCROLL_FORWARD);
        removeScrollableFromNodeInfo(info);
    }
}
#method_after
@Override
public void onInitializeAccessibilityNodeInfo(@NonNull RecyclerView.Recycler recycler, @NonNull RecyclerView.State state, @NonNull AccessibilityNodeInfoCompat info) {
    super.onInitializeAccessibilityNodeInfo(recycler, state, info);
    if (!isUserInputEnabled()) {
        info.removeAction(AccessibilityActionCompat.ACTION_SCROLL_BACKWARD);
        info.removeAction(AccessibilityActionCompat.ACTION_SCROLL_FORWARD);
        info.setScrollable(false);
    }
}
#end_block

#method_before
@Override
protected void calculateExtraLayoutSpace(@NonNull RecyclerView.State state, @NonNull int[] extraLayoutSpace) {
    int pageLimit = getOffscreenPageLimit();
    if (pageLimit == OFFSCREEN_PAGE_LIMIT_DISABLED) {
        // Only do custom prefetching of offscreen pages if requested
        super.calculateExtraLayoutSpace(state, extraLayoutSpace);
    }
    final ViewPager2 vp = ViewPager2.this;
    final int pageSize = getOrientation() == RecyclerView.HORIZONTAL ? vp.getWidth() - vp.getPaddingLeft() - vp.getPaddingRight() : vp.getHeight() - vp.getPaddingTop() - vp.getPaddingBottom();
    final int offscreenSpace = pageSize * pageLimit;
    extraLayoutSpace[0] = offscreenSpace;
    extraLayoutSpace[1] = offscreenSpace;
}
#method_after
@Override
protected void calculateExtraLayoutSpace(@NonNull RecyclerView.State state, @NonNull int[] extraLayoutSpace) {
    int pageLimit = getOffscreenPageLimit();
    if (pageLimit == OFFSCREEN_PAGE_LIMIT_DEFAULT) {
        // Only do custom prefetching of offscreen pages if requested
        super.calculateExtraLayoutSpace(state, extraLayoutSpace);
        return;
    }
    final int offscreenSpace = getPageSize() * pageLimit;
    extraLayoutSpace[0] = offscreenSpace;
    extraLayoutSpace[1] = offscreenSpace;
}
#end_block

#method_before
private static void checkSerialVersionUID(long expectedSUID, Class<?> clazz, boolean expectedWarning) {
    // Use reflection to access the private static computeDefaultSUID method.
    long defaultSUID;
    DefaultSUIDCompatibilityListener savedListener = ObjectStreamClass.suidCompatibilityListener;
    try {
        ObjectStreamClass.suidCompatibilityListener = (c, hash) -> {
            // Delegate to the existing listener so that the warning is logged.
            savedListener.warnDefaultSUIDTargetVersionDependent(clazz, hash);
            if (expectedWarning) {
                assertEquals(clazz, c);
                assertEquals(expectedSUID, hash);
            } else {
                fail("Unexpected warning for " + c + " with defaultSUID " + hash);
            }
        };
        Method computeDefaultSUIDMethod = ObjectStreamClass.class.getDeclaredMethod("computeDefaultSUID", Class.class);
        computeDefaultSUIDMethod.setAccessible(true);
        defaultSUID = (Long) computeDefaultSUIDMethod.invoke(null, clazz);
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        throw new IllegalStateException(e);
    } finally {
        ObjectStreamClass.suidCompatibilityListener = savedListener;
    }
    assertEquals(expectedSUID, defaultSUID);
}
#method_after
private static void checkSerialVersionUID(long expectedSUID, Class<?> clazz, boolean expectedWarning) {
    // Use reflection to call the private static computeDefaultSUID method directly to avoid the
    // caching performed by ObjectStreamClass.lookup(Class).
    long defaultSUID;
    DefaultSUIDCompatibilityListener savedListener = ObjectStreamClass.suidCompatibilityListener;
    try {
        ObjectStreamClass.suidCompatibilityListener = (c, hash) -> {
            // Delegate to the existing listener so that the warning is logged.
            savedListener.warnDefaultSUIDTargetVersionDependent(clazz, hash);
            if (expectedWarning) {
                assertEquals(clazz, c);
                assertEquals(expectedSUID, hash);
            } else {
                fail("Unexpected warning for " + c + " with defaultSUID " + hash);
            }
        };
        Method computeDefaultSUIDMethod = ObjectStreamClass.class.getDeclaredMethod("computeDefaultSUID", Class.class);
        computeDefaultSUIDMethod.setAccessible(true);
        defaultSUID = (Long) computeDefaultSUIDMethod.invoke(null, clazz);
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        throw new IllegalStateException(e);
    } finally {
        ObjectStreamClass.suidCompatibilityListener = savedListener;
    }
    assertEquals(expectedSUID, defaultSUID);
}
#end_block

#method_before
private static long computeDefaultSUID(Class<?> cl) {
    if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl)) {
        return 0L;
    }
    try {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        DataOutputStream dout = new DataOutputStream(bout);
        dout.writeUTF(cl.getName());
        int classMods = cl.getModifiers() & (Modifier.PUBLIC | Modifier.FINAL | Modifier.INTERFACE | Modifier.ABSTRACT);
        /*
             * compensate for javac bug in which ABSTRACT bit was set for an
             * interface only if the interface declared methods
             */
        Method[] methods = cl.getDeclaredMethods();
        if ((classMods & Modifier.INTERFACE) != 0) {
            classMods = (methods.length > 0) ? (classMods | Modifier.ABSTRACT) : (classMods & ~Modifier.ABSTRACT);
        }
        dout.writeInt(classMods);
        if (!cl.isArray()) {
            /*
                 * compensate for change in 1.2FCS in which
                 * Class.getInterfaces() was modified to return Cloneable and
                 * Serializable for array classes.
                 */
            Class<?>[] interfaces = cl.getInterfaces();
            String[] ifaceNames = new String[interfaces.length];
            for (int i = 0; i < interfaces.length; i++) {
                ifaceNames[i] = interfaces[i].getName();
            }
            Arrays.sort(ifaceNames);
            for (int i = 0; i < ifaceNames.length; i++) {
                dout.writeUTF(ifaceNames[i]);
            }
        }
        Field[] fields = cl.getDeclaredFields();
        MemberSignature[] fieldSigs = new MemberSignature[fields.length];
        for (int i = 0; i < fields.length; i++) {
            fieldSigs[i] = new MemberSignature(fields[i]);
        }
        Arrays.sort(fieldSigs, new Comparator<MemberSignature>() {

            public int compare(MemberSignature ms1, MemberSignature ms2) {
                return ms1.name.compareTo(ms2.name);
            }
        });
        for (int i = 0; i < fieldSigs.length; i++) {
            MemberSignature sig = fieldSigs[i];
            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE | Modifier.TRANSIENT);
            if (((mods & Modifier.PRIVATE) == 0) || ((mods & (Modifier.STATIC | Modifier.TRANSIENT)) == 0)) {
                dout.writeUTF(sig.name);
                dout.writeInt(mods);
                dout.writeUTF(sig.signature);
            }
        }
        // BEGIN Android-changed: Clinit serialization workaround b/29064453
        // Prior to SDK 24 hasStaticInitializer() would return true if the superclass had a
        // static initializer, that was contrary to the specification. In SDK 24 the default
        // behavior was corrected but the old behavior was preserved for apps that targeted 23
        // or below in order to maintain backwards compatibility.
        // 
        // if (hasStaticInitializer(cl)) {
        boolean inheritStaticInitializer = (VMRuntime.getRuntime().getTargetSdkVersion() <= MAX_SDK_TARGET_FOR_CLINIT_UIDGEN_WORKAROUND);
        boolean warnDefaultSUIDChangeWhenTargetSDKAbove23 = false;
        if (hasStaticInitializer(cl, inheritStaticInitializer)) {
            // warning.
            if (inheritStaticInitializer && !hasStaticInitializer(cl, false)) {
                // Defer until hash has been calculated so the warning message can give precise
                // instructions to the developer on how to fix the problems.
                warnDefaultSUIDChangeWhenTargetSDKAbove23 = true;
            }
            // END Android-changed: Clinit serialization workaround b/29064453
            dout.writeUTF("<clinit>");
            dout.writeInt(Modifier.STATIC);
            dout.writeUTF("()V");
        }
        Constructor<?>[] cons = cl.getDeclaredConstructors();
        MemberSignature[] consSigs = new MemberSignature[cons.length];
        for (int i = 0; i < cons.length; i++) {
            consSigs[i] = new MemberSignature(cons[i]);
        }
        Arrays.sort(consSigs, new Comparator<MemberSignature>() {

            public int compare(MemberSignature ms1, MemberSignature ms2) {
                return ms1.signature.compareTo(ms2.signature);
            }
        });
        for (int i = 0; i < consSigs.length; i++) {
            MemberSignature sig = consSigs[i];
            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT);
            if ((mods & Modifier.PRIVATE) == 0) {
                dout.writeUTF("<init>");
                dout.writeInt(mods);
                dout.writeUTF(sig.signature.replace('/', '.'));
            }
        }
        MemberSignature[] methSigs = new MemberSignature[methods.length];
        for (int i = 0; i < methods.length; i++) {
            methSigs[i] = new MemberSignature(methods[i]);
        }
        Arrays.sort(methSigs, new Comparator<MemberSignature>() {

            public int compare(MemberSignature ms1, MemberSignature ms2) {
                int comp = ms1.name.compareTo(ms2.name);
                if (comp == 0) {
                    comp = ms1.signature.compareTo(ms2.signature);
                }
                return comp;
            }
        });
        for (int i = 0; i < methSigs.length; i++) {
            MemberSignature sig = methSigs[i];
            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT);
            if ((mods & Modifier.PRIVATE) == 0) {
                dout.writeUTF(sig.name);
                dout.writeInt(mods);
                dout.writeUTF(sig.signature.replace('/', '.'));
            }
        }
        dout.flush();
        MessageDigest md = MessageDigest.getInstance("SHA");
        byte[] hashBytes = md.digest(bout.toByteArray());
        long hash = 0;
        for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {
            hash = (hash << 8) | (hashBytes[i] & 0xFF);
        }
        // irrespective of the number of times the class is serialized.
        if (warnDefaultSUIDChangeWhenTargetSDKAbove23) {
            suidCompatibilityListener.warnDefaultSUIDTargetVersionDependent(cl, hash);
        }
        // END Android-added: Log warning if default SUID will change if targetSdkVersion > 23
        return hash;
    } catch (IOException ex) {
        throw new InternalError(ex);
    } catch (NoSuchAlgorithmException ex) {
        throw new SecurityException(ex.getMessage());
    }
}
#method_after
private static long computeDefaultSUID(Class<?> cl) {
    if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl)) {
        return 0L;
    }
    try {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        DataOutputStream dout = new DataOutputStream(bout);
        dout.writeUTF(cl.getName());
        int classMods = cl.getModifiers() & (Modifier.PUBLIC | Modifier.FINAL | Modifier.INTERFACE | Modifier.ABSTRACT);
        /*
             * compensate for javac bug in which ABSTRACT bit was set for an
             * interface only if the interface declared methods
             */
        Method[] methods = cl.getDeclaredMethods();
        if ((classMods & Modifier.INTERFACE) != 0) {
            classMods = (methods.length > 0) ? (classMods | Modifier.ABSTRACT) : (classMods & ~Modifier.ABSTRACT);
        }
        dout.writeInt(classMods);
        if (!cl.isArray()) {
            /*
                 * compensate for change in 1.2FCS in which
                 * Class.getInterfaces() was modified to return Cloneable and
                 * Serializable for array classes.
                 */
            Class<?>[] interfaces = cl.getInterfaces();
            String[] ifaceNames = new String[interfaces.length];
            for (int i = 0; i < interfaces.length; i++) {
                ifaceNames[i] = interfaces[i].getName();
            }
            Arrays.sort(ifaceNames);
            for (int i = 0; i < ifaceNames.length; i++) {
                dout.writeUTF(ifaceNames[i]);
            }
        }
        Field[] fields = cl.getDeclaredFields();
        MemberSignature[] fieldSigs = new MemberSignature[fields.length];
        for (int i = 0; i < fields.length; i++) {
            fieldSigs[i] = new MemberSignature(fields[i]);
        }
        Arrays.sort(fieldSigs, new Comparator<MemberSignature>() {

            public int compare(MemberSignature ms1, MemberSignature ms2) {
                return ms1.name.compareTo(ms2.name);
            }
        });
        for (int i = 0; i < fieldSigs.length; i++) {
            MemberSignature sig = fieldSigs[i];
            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE | Modifier.TRANSIENT);
            if (((mods & Modifier.PRIVATE) == 0) || ((mods & (Modifier.STATIC | Modifier.TRANSIENT)) == 0)) {
                dout.writeUTF(sig.name);
                dout.writeInt(mods);
                dout.writeUTF(sig.signature);
            }
        }
        // BEGIN Android-changed: Fix/log clinit serialization workaround b/29064453
        // Prior to SDK 24 hasStaticInitializer() would return true if the superclass had a
        // static initializer, that was contrary to the specification. In SDK 24 the default
        // behavior was corrected but the old behavior was preserved for apps that targeted 23
        // or below in order to maintain backwards compatibility.
        // 
        // if (hasStaticInitializer(cl)) {
        boolean inheritStaticInitializer = (VMRuntime.getRuntime().getTargetSdkVersion() <= MAX_SDK_TARGET_FOR_CLINIT_UIDGEN_WORKAROUND);
        boolean warnIncompatibleSUIDChange = false;
        if (hasStaticInitializer(cl, inheritStaticInitializer)) {
            // warning.
            if (inheritStaticInitializer && !hasStaticInitializer(cl, false)) {
                // Defer until hash has been calculated so the warning message can give precise
                // instructions to the developer on how to fix the problems.
                warnIncompatibleSUIDChange = true;
            }
            // END Android-changed: Fix/log clinit serialization workaround b/29064453
            dout.writeUTF("<clinit>");
            dout.writeInt(Modifier.STATIC);
            dout.writeUTF("()V");
        }
        Constructor<?>[] cons = cl.getDeclaredConstructors();
        MemberSignature[] consSigs = new MemberSignature[cons.length];
        for (int i = 0; i < cons.length; i++) {
            consSigs[i] = new MemberSignature(cons[i]);
        }
        Arrays.sort(consSigs, new Comparator<MemberSignature>() {

            public int compare(MemberSignature ms1, MemberSignature ms2) {
                return ms1.signature.compareTo(ms2.signature);
            }
        });
        for (int i = 0; i < consSigs.length; i++) {
            MemberSignature sig = consSigs[i];
            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT);
            if ((mods & Modifier.PRIVATE) == 0) {
                dout.writeUTF("<init>");
                dout.writeInt(mods);
                dout.writeUTF(sig.signature.replace('/', '.'));
            }
        }
        MemberSignature[] methSigs = new MemberSignature[methods.length];
        for (int i = 0; i < methods.length; i++) {
            methSigs[i] = new MemberSignature(methods[i]);
        }
        Arrays.sort(methSigs, new Comparator<MemberSignature>() {

            public int compare(MemberSignature ms1, MemberSignature ms2) {
                int comp = ms1.name.compareTo(ms2.name);
                if (comp == 0) {
                    comp = ms1.signature.compareTo(ms2.signature);
                }
                return comp;
            }
        });
        for (int i = 0; i < methSigs.length; i++) {
            MemberSignature sig = methSigs[i];
            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT);
            if ((mods & Modifier.PRIVATE) == 0) {
                dout.writeUTF(sig.name);
                dout.writeInt(mods);
                dout.writeUTF(sig.signature.replace('/', '.'));
            }
        }
        dout.flush();
        MessageDigest md = MessageDigest.getInstance("SHA");
        byte[] hashBytes = md.digest(bout.toByteArray());
        long hash = 0;
        for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {
            hash = (hash << 8) | (hashBytes[i] & 0xFF);
        }
        // irrespective of the number of times the class is serialized.
        if (warnIncompatibleSUIDChange) {
            suidCompatibilityListener.warnDefaultSUIDTargetVersionDependent(cl, hash);
        }
        // END Android-added: Fix/log clinit serialization workaround b/29064453
        return hash;
    } catch (IOException ex) {
        throw new InternalError(ex);
    } catch (NoSuchAlgorithmException ex) {
        throw new SecurityException(ex.getMessage());
    }
}
#end_block

#method_before
@Override
public Bundle getSessionInfo() {
    // mSessionInfo is final so doesn't need synchronize block
    return mSessionInfo;
}
#method_after
@Override
public Bundle getSessionInfo() {
    // mSessionInfo is final so doesn't need synchronize block
    return mSessionInfo == null ? null : new Bundle(mSessionInfo);
}
#end_block

#method_before
@Override
public Bundle getSessionInfo() {
    return mSessionInfo;
}
#method_after
@Override
public Bundle getSessionInfo() {
    return mSessionInfo == null ? null : new Bundle(mSessionInfo);
}
#end_block

#method_before
@NonNull
public Bundle getSessionInfo() {
    return mImpl.getSessionInfo();
}
#method_after
@RestrictTo(LIBRARY_GROUP_PREFIX)
@NonNull
public Bundle getSessionInfo() {
    return mImpl.getSessionInfo();
}
#end_block

#method_before
@Override
public Bundle getSessionInfo() {
    if (mSessionInfo != null) {
        return mSessionInfo;
    }
    try {
        mSessionInfo = mBinder.getSessionInfo();
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in getSessionInfo.", e);
    }
    if (mSessionInfo == null) {
        mSessionInfo = Bundle.EMPTY;
    }
    return mSessionInfo;
}
#method_after
@Override
public Bundle getSessionInfo() {
    try {
        mSessionInfo = mBinder.getSessionInfo();
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in getSessionInfo.", e);
    }
    return mSessionInfo == null ? Bundle.EMPTY : new Bundle(mSessionInfo);
}
#end_block

#method_before
@Override
public Bundle getSessionInfo() {
    if (mSessionInfo != null) {
        return mSessionInfo;
    }
    // TODO(b/130282718): Use framework MediaController#getSessionInfo() from Q.
    if (mSessionToken.getExtraBinder() != null) {
        try {
            mSessionInfo = mSessionToken.getExtraBinder().getSessionInfo();
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in getSessionInfo.", e);
        }
        if (mSessionInfo == null) {
            mSessionInfo = Bundle.EMPTY;
        }
        return mSessionInfo;
    } else {
        return Bundle.EMPTY;
    }
}
#method_after
@Override
public Bundle getSessionInfo() {
    // TODO(b/130282718): Use framework MediaController#getSessionInfo() from Q.
    if (mSessionToken.getExtraBinder() != null) {
        try {
            mSessionInfo = mSessionToken.getExtraBinder().getSessionInfo();
        } catch (RemoteException e) {
            Log.e(TAG, "Dead object in getSessionInfo.", e);
        }
    }
    return mSessionInfo == null ? Bundle.EMPTY : new Bundle(mSessionInfo);
}
#end_block

#method_before
private boolean doesCellInfoCorrespondToKnownMccMnc(CellInfo ci, Set<String> knownMccMncs) {
    String mccMnc = ci.getCellIdentity().getMccString() + ci.getCellIdentity().getMncString();
    return knownMccMncs.contains(mccMnc);
}
#method_after
private static boolean doesCellInfoCorrespondToKnownMccMnc(CellInfo ci, Collection<String> knownMccMncs) {
    String mccMnc = ci.getCellIdentity().getMccString() + ci.getCellIdentity().getMncString();
    return knownMccMncs.contains(mccMnc);
}
#end_block

#method_before
private void notifyMessenger(NetworkScanRequestInfo nsri, int what, int err, List<CellInfo> result) {
    Messenger messenger = nsri.mMessenger;
    Message message = Message.obtain();
    message.what = what;
    message.arg1 = err;
    message.arg2 = nsri.mScanId;
    if (result != null) {
        if (what == TelephonyScanManager.CALLBACK_RESTRICTED_SCAN_RESULTS) {
            Set<String> allowedMccMncs = SubscriptionController.getInstance().getAllSubInfoList(nsri.mPhone.getContext().getOpPackageName()).stream().filter(subInfo -> subInfo.getMccString() != null).map(subInfo -> subInfo.getMccString() + subInfo.getMncString()).collect(Collectors.toSet());
            result = result.stream().map(CellInfo::sanitizeLocationInfo).filter(ci -> doesCellInfoCorrespondToKnownMccMnc(ci, allowedMccMncs)).collect(Collectors.toList());
        }
        CellInfo[] ci = result.toArray(new CellInfo[result.size()]);
        Bundle b = new Bundle();
        b.putParcelableArray(TelephonyScanManager.SCAN_RESULT_KEY, ci);
        message.setData(b);
    } else {
        message.obj = null;
    }
    try {
        messenger.send(message);
    } catch (RemoteException e) {
        Log.e(TAG, "Exception in notifyMessenger: " + e);
    }
}
#method_after
private void notifyMessenger(NetworkScanRequestInfo nsri, int what, int err, List<CellInfo> result) {
    Messenger messenger = nsri.mMessenger;
    Message message = Message.obtain();
    message.what = what;
    message.arg1 = err;
    message.arg2 = nsri.mScanId;
    if (result != null) {
        if (what == TelephonyScanManager.CALLBACK_RESTRICTED_SCAN_RESULTS) {
            List<String> allowedMccMncs = getAllowedMccMncsForLocationRestrictedScan(nsri.mPhone.getContext());
            result = result.stream().map(CellInfo::sanitizeLocationInfo).filter(ci -> doesCellInfoCorrespondToKnownMccMnc(ci, allowedMccMncs)).collect(Collectors.toList());
        }
        CellInfo[] ci = result.toArray(new CellInfo[result.size()]);
        Bundle b = new Bundle();
        b.putParcelableArray(TelephonyScanManager.SCAN_RESULT_KEY, ci);
        message.setData(b);
    } else {
        message.obj = null;
    }
    try {
        messenger.send(message);
    } catch (RemoteException e) {
        Log.e(TAG, "Exception in notifyMessenger: " + e);
    }
}
#end_block

#method_before
@NonNull
@Override
protected Parcelable onSaveInstanceState() {
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.mRecyclerViewId = mRecyclerView.getId();
    ss.mCurrentItem = mPendingCurrentItem == NO_POSITION ? mCurrentItem : mPendingCurrentItem;
    Adapter adapter = mRecyclerView.getAdapter();
    if (adapter instanceof StatefulAdapter) {
        ss.mAdapterState = ((StatefulAdapter) adapter).saveState();
    }
    return ss;
}
#method_after
@Nullable
@Override
protected Parcelable onSaveInstanceState() {
    Parcelable superState = super.onSaveInstanceState();
    SavedState ss = new SavedState(superState);
    ss.mRecyclerViewId = mRecyclerView.getId();
    ss.mCurrentItem = mPendingCurrentItem == NO_POSITION ? mCurrentItem : mPendingCurrentItem;
    if (mPendingAdapterState != null) {
        ss.mAdapterState = mPendingAdapterState;
    } else {
        Adapter adapter = mRecyclerView.getAdapter();
        if (adapter instanceof StatefulAdapter) {
            ss.mAdapterState = ((StatefulAdapter) adapter).saveState();
        }
    }
    return ss;
}
#end_block

#method_before
@Override
protected void onRestoreInstanceState(Parcelable state) {
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    mPendingCurrentItem = ss.mCurrentItem;
    if (ss.mAdapterState != null) {
        Adapter adapter = mRecyclerView.getAdapter();
        if (adapter instanceof StatefulAdapter) {
            ((StatefulAdapter) adapter).restoreState(ss.mAdapterState);
        }
    }
}
#method_after
@Override
protected void onRestoreInstanceState(Parcelable state) {
    if (!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
    }
    SavedState ss = (SavedState) state;
    super.onRestoreInstanceState(ss.getSuperState());
    mPendingCurrentItem = ss.mCurrentItem;
    mPendingAdapterState = ss.mAdapterState;
}
#end_block

#method_before
@Override
protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container) {
    // RecyclerView changed an id, so we need to reflect that in the saved state
    Parcelable state = container.get(getId());
    if (state instanceof SavedState) {
        final int previousRvId = ((SavedState) state).mRecyclerViewId;
        final int currentRvId = mRecyclerView.getId();
        container.put(currentRvId, container.get(previousRvId));
        container.remove(previousRvId);
    }
    super.dispatchRestoreInstanceState(container);
    // State of ViewPager2 and its child (RecyclerView) has been restored now
    restoreCurrentItem();
}
#method_after
@Override
protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container) {
    // RecyclerView changed an id, so we need to reflect that in the saved state
    Parcelable state = container.get(getId());
    if (state instanceof SavedState) {
        final int previousRvId = ((SavedState) state).mRecyclerViewId;
        final int currentRvId = mRecyclerView.getId();
        container.put(currentRvId, container.get(previousRvId));
        container.remove(previousRvId);
    }
    super.dispatchRestoreInstanceState(container);
    // State of ViewPager2 and its child (RecyclerView) has been restored now
    restorePendingState();
}
#end_block

#method_before
public void setAdapter(@Nullable Adapter adapter) {
    mRecyclerView.setAdapter(adapter);
    restoreCurrentItem();
}
#method_after
public void setAdapter(@Nullable Adapter adapter) {
    mRecyclerView.setAdapter(adapter);
    restorePendingState();
}
#end_block

#method_before
public void setCurrentItem(int item, boolean smoothScroll) {
    if (isFakeDragging()) {
        throw new IllegalStateException("Cannot change current item when ViewPager2 is fake " + "dragging");
    }
    Adapter adapter = getAdapter();
    if (adapter == null) {
        // Update the pending current item if we're still waiting for the adapter
        if (mPendingCurrentItem != NO_POSITION) {
            mPendingCurrentItem = Math.max(item, 0);
        }
        return;
    }
    item = Math.max(item, 0);
    item = Math.min(item, adapter.getItemCount() - 1);
    if (item < 0) {
        // Adapter is empty
        return;
    }
    if (item == mCurrentItem && mScrollEventAdapter.isIdle()) {
        // Already at the correct page
        return;
    }
    if (item == mCurrentItem && smoothScroll) {
        // because then we need to interrupt the current smooth scroll.
        return;
    }
    // 2. Update the item internally
    float previousItem = mCurrentItem;
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    // 3. Perform the necessary scroll actions on RecyclerView
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item, mRecyclerView));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#method_after
public void setCurrentItem(int item, boolean smoothScroll) {
    if (isFakeDragging()) {
        throw new IllegalStateException("Cannot change current item when ViewPager2 is fake " + "dragging");
    }
    Adapter adapter = getAdapter();
    if (adapter == null) {
        // Update the pending current item if we're still waiting for the adapter
        if (mPendingCurrentItem != NO_POSITION) {
            mPendingCurrentItem = Math.max(item, 0);
        }
        return;
    }
    if (adapter.getItemCount() <= 0) {
        // Adapter is empty
        return;
    }
    item = Math.max(item, 0);
    item = Math.min(item, adapter.getItemCount() - 1);
    if (item == mCurrentItem && mScrollEventAdapter.isIdle()) {
        // Already at the correct page
        return;
    }
    if (item == mCurrentItem && smoothScroll) {
        // because then we need to interrupt the current smooth scroll.
        return;
    }
    // 2. Update the item internally
    float previousItem = mCurrentItem;
    mCurrentItem = item;
    if (!mScrollEventAdapter.isIdle()) {
        // Scroll in progress, overwrite previousItem with actual current position
        previousItem = mScrollEventAdapter.getRelativeScrollPosition();
    }
    // 3. Perform the necessary scroll actions on RecyclerView
    mScrollEventAdapter.notifyProgrammaticScroll(item, smoothScroll);
    if (!smoothScroll) {
        mRecyclerView.scrollToPosition(item);
        return;
    }
    // For smooth scroll, pre-jump to nearby item for long jumps.
    if (Math.abs(item - previousItem) > 3) {
        mRecyclerView.scrollToPosition(item > previousItem ? item - 3 : item + 3);
        // TODO(b/114361680): call smoothScrollToPosition synchronously (blocked by b/114019007)
        mRecyclerView.post(new SmoothScrollToPosition(item, mRecyclerView));
    } else {
        mRecyclerView.smoothScrollToPosition(item);
    }
}
#end_block

#method_before
void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) {
    final Class fragmentClass = fragment.getClass();
    final int modifiers = fragmentClass.getModifiers();
    if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() && !Modifier.isStatic(modifiers))) {
        throw new IllegalStateException("Fragment " + fragmentClass.getCanonicalName() + " must be a public static class to be  properly recreated from" + " instance state.");
    }
    fragment.mFragmentManager = mManager;
    if (tag != null) {
        if (fragment.mTag != null && !tag.equals(fragment.mTag)) {
            throw new IllegalStateException("Can't change tag of fragment " + fragment + ": was " + fragment.mTag + " now " + tag);
        }
        fragment.mTag = tag;
    }
    if (containerViewId != 0) {
        if (containerViewId == View.NO_ID) {
            throw new IllegalArgumentException("Can't add fragment " + fragment + " with tag " + tag + " to container view with no id");
        }
        if (fragment.mFragmentId != 0 && fragment.mFragmentId != containerViewId) {
            throw new IllegalStateException("Can't change container ID of fragment " + fragment + ": was " + fragment.mFragmentId + " now " + containerViewId);
        }
        fragment.mContainerId = fragment.mFragmentId = containerViewId;
    }
    addOp(new Op(opcmd, fragment));
}
#method_after
void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) {
    final Class fragmentClass = fragment.getClass();
    final int modifiers = fragmentClass.getModifiers();
    if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() && !Modifier.isStatic(modifiers))) {
        throw new IllegalStateException("Fragment " + fragmentClass.getCanonicalName() + " must be a public static class to be  properly recreated from" + " instance state.");
    }
    if (tag != null) {
        if (fragment.mTag != null && !tag.equals(fragment.mTag)) {
            throw new IllegalStateException("Can't change tag of fragment " + fragment + ": was " + fragment.mTag + " now " + tag);
        }
        fragment.mTag = tag;
    }
    if (containerViewId != 0) {
        if (containerViewId == View.NO_ID) {
            throw new IllegalArgumentException("Can't add fragment " + fragment + " with tag " + tag + " to container view with no id");
        }
        if (fragment.mFragmentId != 0 && fragment.mFragmentId != containerViewId) {
            throw new IllegalStateException("Can't change container ID of fragment " + fragment + ": was " + fragment.mFragmentId + " now " + containerViewId);
        }
        fragment.mContainerId = fragment.mFragmentId = containerViewId;
    }
    addOp(new Op(opcmd, fragment));
}
#end_block

#method_before
@NonNull
public FragmentTransaction remove(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot remove Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_REMOVE, fragment));
    return this;
}
#method_after
@NonNull
public FragmentTransaction remove(@NonNull Fragment fragment) {
    addOp(new Op(OP_REMOVE, fragment));
    return this;
}
#end_block

#method_before
@NonNull
public FragmentTransaction hide(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot hide Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_HIDE, fragment));
    return this;
}
#method_after
@NonNull
public FragmentTransaction hide(@NonNull Fragment fragment) {
    addOp(new Op(OP_HIDE, fragment));
    return this;
}
#end_block

#method_before
@NonNull
public FragmentTransaction show(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot show Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_SHOW, fragment));
    return this;
}
#method_after
@NonNull
public FragmentTransaction show(@NonNull Fragment fragment) {
    addOp(new Op(OP_SHOW, fragment));
    return this;
}
#end_block

#method_before
@NonNull
public FragmentTransaction detach(@NonNull Fragment fragment) {
    if (fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot detach Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_DETACH, fragment));
    return this;
}
#method_after
@NonNull
public FragmentTransaction detach(@NonNull Fragment fragment) {
    addOp(new Op(OP_DETACH, fragment));
    return this;
}
#end_block

#method_before
@NonNull
public FragmentTransaction setPrimaryNavigationFragment(@Nullable Fragment fragment) {
    if (fragment != null && fragment.mFragmentManager != null && fragment.mFragmentManager != mManager) {
        throw new IllegalStateException("Cannot setPrimaryNavigation for Fragment attached to " + "a different FragmentManager. Fragment " + fragment.toString() + " is already" + " attached to a FragmentManager.");
    }
    addOp(new Op(OP_SET_PRIMARY_NAV, fragment));
    return this;
}
#method_after
@NonNull
public FragmentTransaction setPrimaryNavigationFragment(@Nullable Fragment fragment) {
    addOp(new Op(OP_SET_PRIMARY_NAV, fragment));
    return this;
}
#end_block

#method_before
private void handleAlwaysOnNetworkRequest(NetworkRequest networkRequest, String settingName, boolean defaultValue) {
    final boolean enable = toBool(Settings.Global.getInt(mContext.getContentResolver(), settingName, encodeBool(defaultValue)));
    final boolean isEnabled = (mNetworkRequests.get(networkRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, networkRequest, new Binder()));
    } else {
        handleReleaseNetworkRequest(networkRequest, Process.SYSTEM_UID);
    }
}
#method_after
private void handleAlwaysOnNetworkRequest(NetworkRequest networkRequest, String settingName, boolean defaultValue) {
    final boolean enable = toBool(Settings.Global.getInt(mContext.getContentResolver(), settingName, encodeBool(defaultValue)));
    final boolean isEnabled = (mNetworkRequests.get(networkRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, networkRequest, new Binder()));
    } else {
        handleReleaseNetworkRequest(networkRequest, Process.SYSTEM_UID, /* callOnUnavailable */
        false);
    }
}
#end_block

#method_before
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final NetworkCapabilities caps = getUnfilteredActiveNetworkState(uid).networkCapabilities;
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#method_after
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final NetworkCapabilities caps = getNetworkCapabilities(getActiveNetwork());
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#end_block

#method_before
private boolean disallowedBecauseSystemCaller() {
    // requestRouteToHost.
    if (isSystem(Binder.getCallingUid())) {
        log("This method exists only for app backwards compatibility" + " and must not be called by system services.");
        return true;
    }
    return false;
}
#method_after
private boolean disallowedBecauseSystemCaller() {
    // above must continued to be supported for few more releases.
    if (isSystem(Binder.getCallingUid()) && SystemProperties.getInt("ro.product.first_api_level", 0) > Build.VERSION_CODES.P) {
        log("This method exists only for app backwards compatibility" + " and must not be called by system services.");
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean checkAnyPermissionOf(String... permissions) {
    for (String permission : permissions) {
        if (mContext.checkCallingOrSelfPermission(permission) == PERMISSION_GRANTED) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean checkAnyPermissionOf(int pid, int uid, String... permissions) {
    for (String permission : permissions) {
        if (mContext.checkPermission(permission, pid, uid) == PERMISSION_GRANTED) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG || DDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNMS.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#method_after
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (!LinkProperties.isValidMtu(mtu, newLp.hasGlobalIpv6Address())) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG || DDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNMS.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#end_block

#method_before
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#method_after
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.println();
    pw.println("NetworkStackClient logs:");
    pw.increaseIndent();
    NetworkStackClient.getInstance().dump(pw);
    pw.decreaseIndent();
    pw.println();
    pw.println("Permission Monitor:");
    pw.increaseIndent();
    mPermissionMonitor.dump(pw);
    pw.decreaseIndent();
}
#end_block

#method_before
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                updateNetworkScore(nai, msg.arg1);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = msg.arg1 == 1;
                break;
            }
        case NetworkAgent.EVENT_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventSocketKeepalive(nai, msg);
                break;
            }
    }
}
#method_after
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasConnectivityManagedCapability()) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                updateNetworkScore(nai, msg.arg1);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = msg.arg1 == 1;
                // Mark the network as temporarily accepting partial connectivity so that it
                // will be validated (and possibly become default) even if it only provides
                // partial internet access. Note that if user connects to partial connectivity
                // and choose "don't ask again", then wifi disconnected by some reasons(maybe
                // out of wifi coverage) and if the same wifi is available again, the device
                // will auto connect to this wifi even though the wifi has "no internet".
                // TODO: Evaluate using a separate setting in IpMemoryStore.
                nai.networkMisc.acceptPartialConnectivity = msg.arg1 == 1;
                break;
            }
        case NetworkAgent.EVENT_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventSocketKeepalive(nai, msg);
                break;
            }
    }
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                if (nai.everCaptivePortalDetected && !nai.captivePortalLoginNotified && valid) {
                    nai.captivePortalLoginNotified = true;
                    showNetworkNotification(nai, NotificationType.LOGGED_IN);
                }
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid) {
                        handleFreshlyValidatedNetwork(nai);
                        // Clear NO_INTERNET and LOST_INTERNET notifications if network becomes
                        // valid.
                        mNotifier.clearNotification(nai.network.netId, NotificationType.NO_INTERNET);
                        mNotifier.clearNotification(nai.network.netId, NotificationType.LOST_INTERNET);
                    }
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (visible) {
                        nai.captivePortalLoginNotified = false;
                    }
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    // Only clear SIGN_IN and NETWORK_SWITCH notifications here, or else other
                    // notifications belong to the same network may be cleared unexpected.
                    mNotifier.clearNotification(netId, NotificationType.SIGN_IN);
                    mNotifier.clearNotification(netId, NotificationType.NETWORK_SWITCH);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean partialConnectivity = (msg.arg1 == NETWORK_TEST_RESULT_PARTIAL_CONNECTIVITY) || (nai.networkMisc.acceptPartialConnectivity && nai.partialConnectivity);
                // Once a network is determined to have partial connectivity, it cannot
                // go back to full connectivity without a disconnect. This is because
                // NetworkMonitor can only communicate either PARTIAL_CONNECTIVITY or VALID,
                // but not both.
                // TODO: Provide multi-testResult to improve the communication between
                // ConnectivityService and NetworkMonitor, so that ConnectivityService could
                // know the real status of network.
                final boolean partialConnectivityChanged = (partialConnectivity && !nai.partialConnectivity);
                final boolean valid = (msg.arg1 == NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                if (nai.everCaptivePortalDetected && !nai.captivePortalLoginNotified && valid) {
                    nai.captivePortalLoginNotified = true;
                    showNetworkNotification(nai, NotificationType.LOGGED_IN);
                }
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid) {
                        handleFreshlyValidatedNetwork(nai);
                        // Clear NO_INTERNET and LOST_INTERNET notifications if network becomes
                        // valid.
                        mNotifier.clearNotification(nai.network.netId, NotificationType.NO_INTERNET);
                        mNotifier.clearNotification(nai.network.netId, NotificationType.LOST_INTERNET);
                    }
                } else if (partialConnectivityChanged) {
                    nai.partialConnectivity = partialConnectivity;
                    updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (visible) {
                        nai.captivePortalLoginNotified = false;
                    }
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    // Only clear SIGN_IN and NETWORK_SWITCH notifications here, or else other
                    // notifications belong to the same network may be cleared unexpectedly.
                    mNotifier.clearNotification(netId, NotificationType.SIGN_IN);
                    mNotifier.clearNotification(netId, NotificationType.NETWORK_SWITCH);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (!maybeHandleAsyncChannelMessage(msg) && !maybeHandleNetworkMonitorMessage(msg) && !maybeHandleNetworkAgentInfoMessage(msg)) {
        maybeHandleNetworkAgentMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (!maybeHandleAsyncChannelMessage(msg) && !maybeHandleNetworkMonitorMessage(msg) && !maybeHandleNetworkAgentInfoMessage(msg) && !maybeHandleNetworkFactoryMessage(msg)) {
        maybeHandleNetworkAgentMessage(msg);
    }
}
#end_block

#method_before
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (nri.request.isListen())
                    continue;
                NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, (nai != null ? nai.getCurrentScore() : 0), 0, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#method_after
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // Finish setting up the full connection
            mNetworkFactoryInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (nri.request.isListen())
                    continue;
                NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
                final int score;
                final int serial;
                if (nai != null) {
                    score = nai.getCurrentScore();
                    serial = nai.factorySerialNumber;
                } else {
                    score = 0;
                    serial = NetworkFactory.SerialNumber.NONE;
                }
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, serial, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#end_block

#method_before
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, SocketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#method_after
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // Clear all notifications of this network.
    mNotifier.clearNotification(nai.network.netId);
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, SocketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.clatd.update();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, null);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNetd.networkDestroy(nai.network.netId);
        } catch (RemoteException | ServiceSpecificException e) {
            loge("Exception destroying network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#end_block

#method_before
private void handleRegisterNetworkRequestWithIntent(Message msg) {
    final NetworkRequestInfo nri = (NetworkRequestInfo) (msg.obj);
    NetworkRequestInfo existingRequest = findExistingNetworkRequestInfo(nri.mPendingIntent);
    if (existingRequest != null) {
        // remove the existing request.
        if (DBG)
            log("Replacing " + existingRequest.request + " with " + nri.request + " because their intents matched.");
        handleReleaseNetworkRequest(existingRequest.request, getCallingUid());
    }
    handleRegisterNetworkRequest(nri);
}
#method_after
private void handleRegisterNetworkRequestWithIntent(Message msg) {
    final NetworkRequestInfo nri = (NetworkRequestInfo) (msg.obj);
    NetworkRequestInfo existingRequest = findExistingNetworkRequestInfo(nri.mPendingIntent);
    if (existingRequest != null) {
        // remove the existing request.
        if (DBG)
            log("Replacing " + existingRequest.request + " with " + nri.request + " because their intents matched.");
        handleReleaseNetworkRequest(existingRequest.request, getCallingUid(), /* callOnUnavailable */
        false);
    }
    handleRegisterNetworkRequest(nri);
}
#end_block

#method_before
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (nri.request.isListen()) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.request.isRequest() && getNetworkForRequest(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, 0);
    }
}
#method_after
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (nri.request.isListen()) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.request.isRequest() && getNetworkForRequest(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, null);
    }
}
#end_block

#method_before
private void handleReleaseNetworkRequestWithIntent(PendingIntent pendingIntent, int callingUid) {
    NetworkRequestInfo nri = findExistingNetworkRequestInfo(pendingIntent);
    if (nri != null) {
        handleReleaseNetworkRequest(nri.request, callingUid);
    }
}
#method_after
private void handleReleaseNetworkRequestWithIntent(PendingIntent pendingIntent, int callingUid) {
    NetworkRequestInfo nri = findExistingNetworkRequestInfo(pendingIntent);
    if (nri != null) {
        handleReleaseNetworkRequest(nri.request, callingUid, /* callOnUnavailable */
        false);
    }
}
#end_block

#method_before
private void handleReleaseNetworkRequest(NetworkRequest request, int callingUid) {
    final NetworkRequestInfo nri = getNriForAppRequest(request, callingUid, "release NetworkRequest");
    if (nri == null) {
        return;
    }
    if (VDBG || (DBG && nri.request.isRequest())) {
        log("releasing " + nri.request + " (release request)");
    }
    handleRemoveNetworkRequest(nri);
}
#method_after
private void handleReleaseNetworkRequest(NetworkRequest request, int callingUid, boolean callOnUnavailable) {
    final NetworkRequestInfo nri = getNriForAppRequest(request, callingUid, "release NetworkRequest");
    if (nri == null) {
        return;
    }
    if (VDBG || (DBG && nri.request.isRequest())) {
        log("releasing " + nri.request + " (release request)");
    }
    handleRemoveNetworkRequest(nri);
    if (callOnUnavailable) {
        callCallbackForRequest(nri, null, ConnectivityManager.CALLBACK_UNAVAIL, 0);
    }
}
#end_block

#method_before
@Override
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    enforceConnectivityInternalPermission();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_ACCEPT_UNVALIDATED, encodeBool(accept), encodeBool(always), network));
}
#method_after
@Override
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    enforceNetworkStackSettingsOrSetup();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_ACCEPT_UNVALIDATED, encodeBool(accept), encodeBool(always), network));
}
#end_block

#method_before
@Override
public void setAvoidUnvalidated(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_AVOID_UNVALIDATED, network));
}
#method_after
@Override
public void setAvoidUnvalidated(Network network) {
    enforceNetworkStackSettingsOrSetup();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_AVOID_UNVALIDATED, network));
}
#end_block

#method_before
private void handleSetAcceptUnvalidated(Network network, boolean accept, boolean always) {
    if (DBG)
        log("handleSetAcceptUnvalidated network=" + network + " accept=" + accept + " always=" + always);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null) {
        // Nothing to do.
        return;
    }
    if (nai.everValidated) {
        // The network validated while the dialog box was up. Take no action.
        return;
    }
    if (!nai.networkMisc.explicitlySelected) {
        Slog.wtf(TAG, "BUG: setAcceptUnvalidated non non-explicitly selected network");
    }
    if (accept != nai.networkMisc.acceptUnvalidated) {
        int oldScore = nai.getCurrentScore();
        nai.networkMisc.acceptUnvalidated = accept;
        rematchAllNetworksAndRequests(nai, oldScore);
        sendUpdatedScoreToFactories(nai);
    }
    if (always) {
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_SAVE_ACCEPT_UNVALIDATED, encodeBool(accept));
    }
    if (!accept) {
        // Tell the NetworkAgent to not automatically reconnect to the network.
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
        // Teardown the network.
        teardownUnneededNetwork(nai);
    }
}
#method_after
private void handleSetAcceptUnvalidated(Network network, boolean accept, boolean always) {
    if (DBG)
        log("handleSetAcceptUnvalidated network=" + network + " accept=" + accept + " always=" + always);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null) {
        // Nothing to do.
        return;
    }
    if (nai.everValidated) {
        // The network validated while the dialog box was up. Take no action.
        return;
    }
    if (!nai.networkMisc.explicitlySelected) {
        Slog.wtf(TAG, "BUG: setAcceptUnvalidated non non-explicitly selected network");
    }
    if (accept != nai.networkMisc.acceptUnvalidated) {
        int oldScore = nai.getCurrentScore();
        nai.networkMisc.acceptUnvalidated = accept;
        // If network becomes partial connectivity and user already accepted to use this
        // network, we should respect the user's option and don't need to popup the
        // PARTIAL_CONNECTIVITY notification to user again.
        nai.networkMisc.acceptPartialConnectivity = accept;
        rematchAllNetworksAndRequests(nai, oldScore);
        sendUpdatedScoreToFactories(nai);
    }
    if (always) {
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_SAVE_ACCEPT_UNVALIDATED, encodeBool(accept));
    }
    if (!accept) {
        // Tell the NetworkAgent to not automatically reconnect to the network.
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
        // Teardown the network.
        teardownUnneededNetwork(nai);
    }
}
#end_block

#method_before
@Override
public void startCaptivePortalAppInternal(Bundle appExtras) {
    mContext.checkCallingOrSelfPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK);
    final Intent appIntent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
    appIntent.putExtras(appExtras);
    appIntent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
    Binder.withCleanCallingIdentity(() -> mContext.startActivityAsUser(appIntent, UserHandle.CURRENT));
}
#method_after
@Override
public void startCaptivePortalAppInternal(Network network, Bundle appExtras) {
    mContext.checkCallingOrSelfPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK);
    final Intent appIntent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
    appIntent.putExtras(appExtras);
    appIntent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL, new CaptivePortal(new CaptivePortalImpl(network).asBinder()));
    appIntent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
    Binder.withCleanCallingIdentity(() -> mContext.startActivityAsUser(appIntent, UserHandle.CURRENT));
}
#end_block

#method_before
private void showNetworkNotification(NetworkAgentInfo nai, NotificationType type) {
    final String action;
    switch(type) {
        case LOGGED_IN:
            action = Settings.ACTION_WIFI_SETTINGS;
            mHandler.removeMessages(EVENT_TIMEOUT_NOTIFICATION);
            mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NOTIFICATION, nai.network.netId, 0), TIMEOUT_NOTIFICATION_DELAY_MS);
            break;
        case NO_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_UNVALIDATED;
            break;
        case LOST_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_LOST_VALIDATION;
            break;
        default:
            Slog.wtf(TAG, "Unknown notification type " + type);
            return;
    }
    Intent intent = new Intent(action);
    if (type != NotificationType.LOGGED_IN) {
        intent.setData(Uri.fromParts("netId", Integer.toString(nai.network.netId), null));
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setClassName("com.android.settings", "com.android.settings.wifi.WifiNoInternetDialog");
    }
    PendingIntent pendingIntent = PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, UserHandle.CURRENT);
    mNotifier.showNotification(nai.network.netId, type, nai, null, pendingIntent, true);
}
#method_after
private void showNetworkNotification(NetworkAgentInfo nai, NotificationType type) {
    final String action;
    switch(type) {
        case LOGGED_IN:
            action = Settings.ACTION_WIFI_SETTINGS;
            mHandler.removeMessages(EVENT_TIMEOUT_NOTIFICATION);
            mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NOTIFICATION, nai.network.netId, 0), TIMEOUT_NOTIFICATION_DELAY_MS);
            break;
        case NO_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_UNVALIDATED;
            break;
        case LOST_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_LOST_VALIDATION;
            break;
        case PARTIAL_CONNECTIVITY:
            action = ConnectivityManager.ACTION_PROMPT_PARTIAL_CONNECTIVITY;
            break;
        default:
            Slog.wtf(TAG, "Unknown notification type " + type);
            return;
    }
    Intent intent = new Intent(action);
    if (type != NotificationType.LOGGED_IN) {
        intent.setData(Uri.fromParts("netId", Integer.toString(nai.network.netId), null));
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setClassName("com.android.settings", "com.android.settings.wifi.WifiNoInternetDialog");
    }
    PendingIntent pendingIntent = PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, UserHandle.CURRENT);
    mNotifier.showNotification(nai.network.netId, type, nai, null, pendingIntent, true);
}
#end_block

#method_before
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // Also don't prompt on captive portals because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated) {
        return;
    }
    showNetworkNotification(nai, NotificationType.NO_INTERNET);
}
#method_after
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated || // connected.
    nai.networkMisc.acceptPartialConnectivity) {
        return;
    }
    // popup the notification immediately when the network is partial connectivity.
    if (nai.partialConnectivity) {
        showNetworkNotification(nai, NotificationType.PARTIAL_CONNECTIVITY);
    } else {
        showNetworkNotification(nai, NotificationType.NO_INTERNET);
    }
}
#end_block

#method_before
private void handleNetworkUnvalidated(NetworkAgentInfo nai) {
    NetworkCapabilities nc = nai.networkCapabilities;
    if (DBG)
        log("handleNetworkUnvalidated " + nai.name() + " cap=" + nc);
    if (nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) && mMultinetworkPolicyTracker.shouldNotifyWifiUnvalidated()) {
        showNetworkNotification(nai, NotificationType.LOST_INTERNET);
    }
}
#method_after
private void handleNetworkUnvalidated(NetworkAgentInfo nai) {
    NetworkCapabilities nc = nai.networkCapabilities;
    if (DBG)
        log("handleNetworkUnvalidated " + nai.name() + " cap=" + nc);
    if (!nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    if (mMultinetworkPolicyTracker.shouldNotifyWifiUnvalidated()) {
        showNetworkNotification(nai, NotificationType.LOST_INTERNET);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                final Pair<NetworkAgentInfo, INetworkMonitor> arg = (Pair<NetworkAgentInfo, INetworkMonitor>) msg.obj;
                handleRegisterNetworkAgent(arg.first, arg.second);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_SOCKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    // this several times is fine.
                    try {
                        nai.networkMonitor().notifySystemReady();
                    } catch (RemoteException e) {
                        e.rethrowFromSystemServer();
                    }
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
        case EVENT_TIMEOUT_NOTIFICATION:
            mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                final Pair<NetworkAgentInfo, INetworkMonitor> arg = (Pair<NetworkAgentInfo, INetworkMonitor>) msg.obj;
                handleRegisterNetworkAgent(arg.first, arg.second);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1, /* callOnUnavailable */
                false);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_ACCEPT_PARTIAL_CONNECTIVITY:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptPartialConnectivity(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_SOCKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
        case EVENT_TIMEOUT_NOTIFICATION:
            mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
            break;
    }
}
#end_block

#method_before
@Override
public VpnInfo[] getAllVpnInfo() {
    enforceConnectivityInternalPermission();
    synchronized (mVpns) {
        if (mLockdownEnabled) {
            return new VpnInfo[0];
        }
        List<VpnInfo> infoList = new ArrayList<>();
        for (int i = 0; i < mVpns.size(); i++) {
            VpnInfo info = createVpnInfo(mVpns.valueAt(i));
            if (info != null) {
                infoList.add(info);
            }
        }
        return infoList.toArray(new VpnInfo[infoList.size()]);
    }
}
#method_after
private VpnInfo[] getAllVpnInfo() {
    ensureRunningOnConnectivityServiceThread();
    synchronized (mVpns) {
        if (mLockdownEnabled) {
            return new VpnInfo[0];
        }
        List<VpnInfo> infoList = new ArrayList<>();
        for (int i = 0; i < mVpns.size(); i++) {
            VpnInfo info = createVpnInfo(mVpns.valueAt(i));
            if (info != null) {
                infoList.add(info);
            }
        }
        return infoList.toArray(new VpnInfo[infoList.size()]);
    }
}
#end_block

#method_before
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNetwork = getDefaultNetwork();
        if (defaultNetwork != null && defaultNetwork.linkProperties != null) {
            info.primaryUnderlyingIface = getDefaultNetwork().linkProperties.getInterfaceName();
        }
    } else if (underlyingNetworks.length > 0) {
        LinkProperties linkProperties = getLinkProperties(underlyingNetworks[0]);
        if (linkProperties != null) {
            info.primaryUnderlyingIface = linkProperties.getInterfaceName();
        }
    }
    return info.primaryUnderlyingIface == null ? null : info;
}
#method_after
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNai = getDefaultNetwork();
        if (defaultNai != null && defaultNai.linkProperties != null) {
            underlyingNetworks = new Network[] { defaultNai.network };
        }
    }
    if (underlyingNetworks != null && underlyingNetworks.length > 0) {
        List<String> interfaces = new ArrayList<>();
        for (Network network : underlyingNetworks) {
            LinkProperties lp = getLinkProperties(network);
            if (lp != null) {
                interfaces.add(lp.getInterfaceName());
            }
        }
        if (!interfaces.isEmpty()) {
            info.underlyingIfaces = interfaces.toArray(new String[interfaces.size()]);
        }
    }
    return info.underlyingIfaces == null ? null : info;
}
#end_block

#method_before
private void updateAllVpnsCapabilities() {
    synchronized (mVpns) {
        for (int i = 0; i < mVpns.size(); i++) {
            final Vpn vpn = mVpns.valueAt(i);
            vpn.updateCapabilities();
        }
    }
}
#method_after
private void updateAllVpnsCapabilities() {
    Network defaultNetwork = getNetwork(getDefaultNetwork());
    synchronized (mVpns) {
        for (int i = 0; i < mVpns.size(); i++) {
            final Vpn vpn = mVpns.valueAt(i);
            NetworkCapabilities nc = vpn.updateCapabilities(defaultNetwork);
            updateVpnCapabilities(vpn, nc);
        }
    }
}
#end_block

#method_before
private void onUserAdded(int userId) {
    mPermissionMonitor.onUserAdded(userId);
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserAdded(userId);
        }
    }
}
#method_after
private void onUserAdded(int userId) {
    mPermissionMonitor.onUserAdded(userId);
    Network defaultNetwork = getNetwork(getDefaultNetwork());
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserAdded(userId);
            NetworkCapabilities nc = vpn.updateCapabilities(defaultNetwork);
            updateVpnCapabilities(vpn, nc);
        }
    }
}
#end_block

#method_before
private void onUserRemoved(int userId) {
    mPermissionMonitor.onUserRemoved(userId);
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserRemoved(userId);
        }
    }
}
#method_after
private void onUserRemoved(int userId) {
    mPermissionMonitor.onUserRemoved(userId);
    Network defaultNetwork = getNetwork(getDefaultNetwork());
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserRemoved(userId);
            NetworkCapabilities nc = vpn.updateCapabilities(defaultNetwork);
            updateVpnCapabilities(vpn, nc);
        }
    }
}
#end_block

#method_before
// This checks that the passed capabilities either do not request a specific SSID, or the
private void ensureSufficientPermissionsForRequest(NetworkCapabilities nc, int callerPid, int callerUid) {
    if (null != nc.getSSID() && !checkSettingsPermission(callerPid, callerUid)) {
        throw new SecurityException("Insufficient permissions to request a specific SSID");
    }
}
#method_after
// This checks that the passed capabilities either do not request a specific SSID/SignalStrength
private void ensureSufficientPermissionsForRequest(NetworkCapabilities nc, int callerPid, int callerUid) {
    if (null != nc.getSSID() && !checkSettingsPermission(callerPid, callerUid)) {
        throw new SecurityException("Insufficient permissions to request a specific SSID");
    }
    if (nc.hasSignalStrength() && !checkNetworkSignalStrengthWakeupPermission(callerPid, callerUid)) {
        throw new SecurityException("Insufficient permissions to request a specific signal strength");
    }
}
#end_block

#method_before
@Override
public void registerNetworkFactory(Messenger messenger, String name) {
    enforceConnectivityInternalPermission();
    NetworkFactoryInfo nfi = new NetworkFactoryInfo(name, messenger, new AsyncChannel());
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_FACTORY, nfi));
}
#method_after
@Override
public int registerNetworkFactory(Messenger messenger, String name) {
    enforceConnectivityInternalPermission();
    NetworkFactoryInfo nfi = new NetworkFactoryInfo(name, messenger, new AsyncChannel(), NetworkFactory.SerialNumber.nextSerialNumber());
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_FACTORY, nfi));
    return nfi.factorySerialNumber;
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        mContext.getSystemService(NetworkStack.class).makeNetworkMonitor(toStableParcelable(nai.network), name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#method_after
// TODO : remove this method. It's a stopgap measure to help sheperding a number of dependent
// changes that would conflict throughout the automerger graph. Having this method temporarily
// helps with the process of going through with all these dependent changes across the entire
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    return registerNetworkAgent(messenger, networkInfo, linkProperties, networkCapabilities, currentScore, networkMisc, NetworkFactory.SerialNumber.NONE);
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        mContext.getSystemService(NetworkStack.class).makeNetworkMonitor(toStableParcelable(nai.network), name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc, int factorySerialNumber) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mDnsResolver, mNMS, factorySerialNumber);
    // Make sure the network capabilities reflect what the agent info says.
    nai.setNetworkCapabilities(mixInCapabilities(nai, nc));
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        getNetworkStack().makeNetworkMonitor(nai.network, name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#end_block

#method_before
private void handleRegisterNetworkAgent(NetworkAgentInfo nai, INetworkMonitor networkMonitor) {
    nai.onNetworkMonitorCreated(networkMonitor);
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    synchronized (this) {
        if (mSystemReady) {
            try {
                networkMonitor.notifySystemReady();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
        }
    }
    try {
        networkMonitor.start();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#method_after
private void handleRegisterNetworkAgent(NetworkAgentInfo nai, INetworkMonitor networkMonitor) {
    nai.onNetworkMonitorCreated(networkMonitor);
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    try {
        networkMonitor.start();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop clat accordingly to network state.
        networkAgent.updateClat(mNMS);
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            try {
                networkAgent.networkMonitor().notifyLinkPropertiesChanged();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // The NetworkAgentInfo does not know whether clatd is running on its network or not, or
    // whether there is a NAT64 prefix. Before we do anything else, make sure its LinkProperties
    // are accurate.
    networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    // update filtering rules, need to happen after the interface update so netd knows about the
    // new interface (the interface name -> index map becomes initialized)
    updateVpnFiltering(newLp, oldLp, networkAgent);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop DNS64 detection and 464xlat according to network state.
        networkAgent.clatd.update();
        notifyIfacesChangedForNetworkStats();
        try {
            networkAgent.networkMonitor().notifyLinkPropertiesChanged(newLp);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private NetworkCapabilities mixInCapabilities(NetworkAgentInfo nai, NetworkCapabilities nc) {
    // avoid connect/teardown loops.
    if (nai.everConnected && !nai.isVPN() && !nai.networkCapabilities.satisfiedByImmutableNetworkCapabilities(nc)) {
        // TODO: consider not complaining when a network agent degrades its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(nc);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (nai.lastValidated) {
        newNc.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        newNc.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        newNc.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        newNc.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        newNc.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        newNc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (nai.isSuspended()) {
        newNc.removeCapability(NET_CAPABILITY_NOT_SUSPENDED);
    } else {
        newNc.addCapability(NET_CAPABILITY_NOT_SUSPENDED);
    }
    return newNc;
}
#method_after
private NetworkCapabilities mixInCapabilities(NetworkAgentInfo nai, NetworkCapabilities nc) {
    // avoid connect/teardown loops.
    if (nai.everConnected && !nai.isVPN() && !nai.networkCapabilities.satisfiedByImmutableNetworkCapabilities(nc)) {
        // TODO: consider not complaining when a network agent degrades its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(nc);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (nai.lastValidated) {
        newNc.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        newNc.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        newNc.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        newNc.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        newNc.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        newNc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (nai.isSuspended()) {
        newNc.removeCapability(NET_CAPABILITY_NOT_SUSPENDED);
    } else {
        newNc.addCapability(NET_CAPABILITY_NOT_SUSPENDED);
    }
    if (nai.partialConnectivity) {
        newNc.addCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    } else {
        newNc.removeCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    }
    return newNc;
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.setNetworkCapabilities(newNc);
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
private void updateUids(NetworkAgentInfo nai, NetworkCapabilities prevNc, NetworkCapabilities newNc) {
    Set<UidRange> prevRanges = null == prevNc ? null : prevNc.getUids();
    Set<UidRange> newRanges = null == newNc ? null : newNc.getUids();
    if (null == prevRanges)
        prevRanges = new ArraySet<>();
    if (null == newRanges)
        newRanges = new ArraySet<>();
    final Set<UidRange> prevRangesCopy = new ArraySet<>(prevRanges);
    prevRanges.removeAll(newRanges);
    newRanges.removeAll(prevRangesCopy);
    try {
        final boolean shouldFilter = shouldApplyInterfaceFiltering(nai);
        if (!newRanges.isEmpty()) {
            final UidRange[] addedRangesArray = new UidRange[newRanges.size()];
            newRanges.toArray(addedRangesArray);
            mNMS.addVpnUidRanges(nai.network.netId, addedRangesArray);
            if (shouldFilter) {
                mPermissionMonitor.onVpnUidRangesAdded(nai.network.netId, newRanges);
            }
        }
        if (!prevRanges.isEmpty()) {
            final UidRange[] removedRangesArray = new UidRange[prevRanges.size()];
            prevRanges.toArray(removedRangesArray);
            mNMS.removeVpnUidRanges(nai.network.netId, removedRangesArray);
            if (shouldFilter) {
                mPermissionMonitor.onVpnUidRangesRemoved(nai.network.netId, prevRanges);
            }
        }
    } catch (Exception e) {
        // Never crash!
        loge("Exception in updateUids: " + e);
    }
}
#method_after
private void updateUids(NetworkAgentInfo nai, NetworkCapabilities prevNc, NetworkCapabilities newNc) {
    Set<UidRange> prevRanges = null == prevNc ? null : prevNc.getUids();
    Set<UidRange> newRanges = null == newNc ? null : newNc.getUids();
    if (null == prevRanges)
        prevRanges = new ArraySet<>();
    if (null == newRanges)
        newRanges = new ArraySet<>();
    final Set<UidRange> prevRangesCopy = new ArraySet<>(prevRanges);
    prevRanges.removeAll(newRanges);
    newRanges.removeAll(prevRangesCopy);
    try {
        // add duplicate UID routing rules.
        if (!newRanges.isEmpty()) {
            final UidRange[] addedRangesArray = new UidRange[newRanges.size()];
            newRanges.toArray(addedRangesArray);
            mNMS.addVpnUidRanges(nai.network.netId, addedRangesArray);
        }
        if (!prevRanges.isEmpty()) {
            final UidRange[] removedRangesArray = new UidRange[prevRanges.size()];
            prevRanges.toArray(removedRangesArray);
            mNMS.removeVpnUidRanges(nai.network.netId, removedRangesArray);
        }
        final boolean wasFiltering = requiresVpnIsolation(nai, prevNc, nai.linkProperties);
        final boolean shouldFilter = requiresVpnIsolation(nai, newNc, nai.linkProperties);
        final String iface = nai.linkProperties.getInterfaceName();
        // to be removed will never overlap with the new range to be added.
        if (wasFiltering && !prevRanges.isEmpty()) {
            mPermissionMonitor.onVpnUidRangesRemoved(iface, prevRanges, prevNc.getEstablishingVpnAppUid());
        }
        if (shouldFilter && !newRanges.isEmpty()) {
            mPermissionMonitor.onVpnUidRangesAdded(iface, newRanges, newNc.getEstablishingVpnAppUid());
        }
    } catch (Exception e) {
        // Never crash!
        loge("Exception in updateUids: ", e);
    }
}
#end_block

#method_before
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    updateLinkProperties(nai, newLp, new LinkProperties(nai.linkProperties));
}
#method_after
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    ensureRunningOnConnectivityServiceThread();
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    updateLinkProperties(nai, newLp, new LinkProperties(nai.linkProperties));
}
#end_block

#method_before
private void sendUpdatedScoreToFactories(NetworkAgentInfo nai) {
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest nr = nai.requestAt(i);
        // Don't send listening requests to factories. b/17393458
        if (nr.isListen())
            continue;
        sendUpdatedScoreToFactories(nr, nai.getCurrentScore());
    }
}
#method_after
private void sendUpdatedScoreToFactories(NetworkAgentInfo nai) {
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest nr = nai.requestAt(i);
        // Don't send listening requests to factories. b/17393458
        if (nr.isListen())
            continue;
        sendUpdatedScoreToFactories(nr, nai);
    }
}
#end_block

#method_before
private void sendUpdatedScoreToFactories(NetworkRequest networkRequest, int score) {
    if (VDBG || DDBG) {
        log("sending new Min Network Score(" + score + "): " + networkRequest.toString());
    }
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, 0, networkRequest);
    }
}
#method_after
private void sendUpdatedScoreToFactories(NetworkRequest networkRequest, NetworkAgentInfo nai) {
    int score = 0;
    int serial = 0;
    if (nai != null) {
        score = nai.getCurrentScore();
        serial = nai.factorySerialNumber;
    }
    if (VDBG || DDBG) {
        log("sending new Min Network Score(" + score + "): " + networkRequest.toString());
    }
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, serial, networkRequest);
    }
}
#end_block

#method_before
private void makeDefault(NetworkAgentInfo newNetwork) {
    if (DBG)
        log("Switching to new default network: " + newNetwork);
    try {
        mNMS.setDefaultNetId(newNetwork.network.netId);
    } catch (Exception e) {
        loge("Exception setting default network :" + e);
    }
    notifyLockdownVpn(newNetwork);
    handleApplyDefaultProxy(newNetwork.linkProperties.getHttpProxy());
    updateTcpBufferSizes(newNetwork.linkProperties.getTcpBufferSizes());
    mDnsManager.setDefaultDnsSystemProperties(newNetwork.linkProperties.getDnsServers());
    notifyIfacesChangedForNetworkStats();
}
#method_after
private void makeDefault(NetworkAgentInfo newNetwork) {
    if (DBG)
        log("Switching to new default network: " + newNetwork);
    try {
        mNMS.setDefaultNetId(newNetwork.network.netId);
    } catch (Exception e) {
        loge("Exception setting default network :" + e);
    }
    notifyLockdownVpn(newNetwork);
    handleApplyDefaultProxy(newNetwork.linkProperties.getHttpProxy());
    updateTcpBufferSizes(newNetwork.linkProperties.getTcpBufferSizes());
    mDnsManager.setDefaultDnsSystemProperties(newNetwork.linkProperties.getDnsServers());
    notifyIfacesChangedForNetworkStats();
    // Fix up the NetworkCapabilities of any VPNs that don't specify underlying networks.
    updateAllVpnsCapabilities();
}
#end_block

#method_before
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#method_after
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG || DDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG || DDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG || DDBG) {
                        log("   accepting network in place of " + currentNetwork.name());
                    }
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG || DDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        updateDataActivityTracking(newNetwork, oldDefaultNetwork);
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG || DDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG || DDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG || DDBG) {
                        log("   accepting network in place of " + currentNetwork.name());
                    }
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG || DDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, newNetwork);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, null);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        updateDataActivityTracking(newNetwork, oldDefaultNetwork);
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            networkAgent.networkMonitor().notifyNetworkConnected();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        // NetworkMonitor, otherwise NetworkMonitor cannot determine if validation is required.
        synchronized (networkAgent) {
            networkAgent.setNetworkCapabilities(networkAgent.networkCapabilities);
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            if (networkAgent.networkMisc.acceptPartialConnectivity) {
                networkAgent.networkMonitor().setAcceptPartialConnectivity();
            }
            networkAgent.networkMonitor().notifyNetworkConnected(networkAgent.linkProperties, networkAgent.networkCapabilities);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        if (networkAgent.isVPN()) {
            updateAllVpnsCapabilities();
        }
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
private void maybeNotifyNetworkBlockedForNewUidRules(int uid, int newRules) {
    for (final NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        final boolean metered = nai.networkCapabilities.isMetered();
        final boolean oldBlocked, newBlocked;
        // Reduce the number of locking or optimize the use of lock are likely needed in future.
        synchronized (mVpns) {
            oldBlocked = isUidNetworkingWithVpnBlocked(uid, mUidRules.get(uid), metered, mRestrictBackground);
            newBlocked = isUidNetworkingWithVpnBlocked(uid, newRules, metered, mRestrictBackground);
        }
        if (oldBlocked == newBlocked) {
            return;
        }
        final int arg = encodeBool(newBlocked);
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest nr = nai.requestAt(i);
            NetworkRequestInfo nri = mNetworkRequests.get(nr);
            if (nri != null && nri.mUid == uid) {
                callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_BLK_CHANGED, arg);
            }
        }
    }
}
#method_after
private void maybeNotifyNetworkBlockedForNewUidRules(int uid, int newRules) {
    for (final NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        final boolean metered = nai.networkCapabilities.isMetered();
        final boolean oldBlocked, newBlocked;
        // Reduce the number of locking or optimize the use of lock are likely needed in future.
        synchronized (mVpns) {
            oldBlocked = isUidNetworkingWithVpnBlocked(uid, mUidRules.get(uid), metered, mRestrictBackground);
            newBlocked = isUidNetworkingWithVpnBlocked(uid, newRules, metered, mRestrictBackground);
        }
        if (oldBlocked == newBlocked) {
            continue;
        }
        final int arg = encodeBool(newBlocked);
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest nr = nai.requestAt(i);
            NetworkRequestInfo nri = mNetworkRequests.get(nr);
            if (nri != null && nri.mUid == uid) {
                callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_BLK_CHANGED, arg);
            }
        }
    }
}
#end_block

#method_before
private Network[] getDefaultNetworks() {
    ArrayList<Network> defaultNetworks = new ArrayList<>();
    NetworkAgentInfo defaultNetwork = getDefaultNetwork();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        if (nai.everConnected && (nai == defaultNetwork || nai.isVPN())) {
            defaultNetworks.add(nai.network);
        }
    }
    return defaultNetworks.toArray(new Network[0]);
}
#method_after
private Network[] getDefaultNetworks() {
    ensureRunningOnConnectivityServiceThread();
    ArrayList<Network> defaultNetworks = new ArrayList<>();
    NetworkAgentInfo defaultNetwork = getDefaultNetwork();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        if (nai.everConnected && (nai == defaultNetwork || nai.isVPN())) {
            defaultNetworks.add(nai.network);
        }
    }
    return defaultNetworks.toArray(new Network[0]);
}
#end_block

#method_before
private void notifyIfacesChangedForNetworkStats() {
    try {
        mStatsService.forceUpdateIfaces(getDefaultNetworks());
    } catch (Exception ignored) {
    }
}
#method_after
private void notifyIfacesChangedForNetworkStats() {
    ensureRunningOnConnectivityServiceThread();
    String activeIface = null;
    LinkProperties activeLinkProperties = getActiveLinkProperties();
    if (activeLinkProperties != null) {
        activeIface = activeLinkProperties.getInterfaceName();
    }
    try {
        mStatsService.forceUpdateIfaces(getDefaultNetworks(), getAllVpnInfo(), getAllNetworkState(), activeIface);
    } catch (Exception ignored) {
    }
}
#end_block

#method_before
@Override
public boolean setUnderlyingNetworksForVpn(Network[] networks) {
    int user = UserHandle.getUserId(Binder.getCallingUid());
    final boolean success;
    synchronized (mVpns) {
        throwIfLockdownEnabled();
        success = mVpns.get(user).setUnderlyingNetworks(networks);
    }
    if (success) {
        mHandler.post(() -> notifyIfacesChangedForNetworkStats());
    }
    return success;
}
#method_after
@Override
public boolean setUnderlyingNetworksForVpn(Network[] networks) {
    int user = UserHandle.getUserId(Binder.getCallingUid());
    final boolean success;
    synchronized (mVpns) {
        throwIfLockdownEnabled();
        success = mVpns.get(user).setUnderlyingNetworks(networks);
    }
    if (success) {
        mHandler.post(() -> {
            // Update VPN's capabilities based on updated underlying network set.
            updateAllVpnsCapabilities();
            notifyIfacesChangedForNetworkStats();
        });
    }
    return success;
}
#end_block

#method_before
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitorUtils.getCaptivePortalServerHttpUrl(mContext);
}
#method_after
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    String settingUrl = mContext.getResources().getString(R.string.config_networkCaptivePortalServerUrl);
    if (!TextUtils.isEmpty(settingUrl)) {
        return settingUrl;
    }
    settingUrl = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.CAPTIVE_PORTAL_HTTP_URL);
    if (!TextUtils.isEmpty(settingUrl)) {
        return settingUrl;
    }
    return DEFAULT_CAPTIVE_PORTAL_HTTP_URL;
}
#end_block

#method_before
@Override
public void startNattKeepalive(Network network, int intervalSeconds, Messenger messenger, IBinder binder, String srcAddr, int srcPort, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), intervalSeconds, messenger, binder, srcAddr, srcPort, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#method_after
@Override
public void startNattKeepalive(Network network, int intervalSeconds, ISocketKeepaliveCallback cb, String srcAddr, int srcPort, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), null, /* fd */
    intervalSeconds, cb, srcAddr, srcPort, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#end_block

#method_before
@Override
public void startNattKeepaliveWithFd(Network network, FileDescriptor fd, int resourceId, int intervalSeconds, Messenger messenger, IBinder binder, String srcAddr, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), fd, resourceId, intervalSeconds, messenger, binder, srcAddr, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#method_after
@Override
public void startNattKeepaliveWithFd(Network network, FileDescriptor fd, int resourceId, int intervalSeconds, ISocketKeepaliveCallback cb, String srcAddr, String dstAddr) {
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), fd, resourceId, intervalSeconds, cb, srcAddr, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#end_block

#method_before
@Override
public void startTcpKeepalive(Network network, FileDescriptor fd, int intervalSeconds, Messenger messenger, IBinder binder) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startTcpKeepalive(getNetworkAgentInfoForNetwork(network), fd, intervalSeconds, messenger, binder);
}
#method_after
@Override
public void startTcpKeepalive(Network network, FileDescriptor fd, int intervalSeconds, ISocketKeepaliveCallback cb) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startTcpKeepalive(getNetworkAgentInfoForNetwork(network), fd, intervalSeconds, cb);
}
#end_block

#method_before
@VisibleForTesting
public static void updateCapabilities(ConnectivityManager cm, Network[] underlyingNetworks, NetworkCapabilities caps, boolean isAlwaysMetered) {
    int[] transportTypes = new int[] { NetworkCapabilities.TRANSPORT_VPN };
    int downKbps = NetworkCapabilities.LINK_BANDWIDTH_UNSPECIFIED;
    int upKbps = NetworkCapabilities.LINK_BANDWIDTH_UNSPECIFIED;
    // VPN's meteredness is OR'd with isAlwaysMetered and meteredness of its underlying
    // networks.
    boolean metered = isAlwaysMetered;
    boolean roaming = false;
    boolean congested = false;
    boolean hadUnderlyingNetworks = false;
    if (null != underlyingNetworks) {
        for (Network underlying : underlyingNetworks) {
            final NetworkCapabilities underlyingCaps = cm.getNetworkCapabilities(underlying);
            if (underlyingCaps == null)
                continue;
            hadUnderlyingNetworks = true;
            for (int underlyingType : underlyingCaps.getTransportTypes()) {
                transportTypes = ArrayUtils.appendInt(transportTypes, underlyingType);
            }
            // When we have multiple networks, we have to assume the
            // worst-case link speed and restrictions.
            downKbps = NetworkCapabilities.minBandwidth(downKbps, underlyingCaps.getLinkDownstreamBandwidthKbps());
            upKbps = NetworkCapabilities.minBandwidth(upKbps, underlyingCaps.getLinkUpstreamBandwidthKbps());
            metered |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_METERED);
            roaming |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_ROAMING);
            congested |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_CONGESTED);
        }
    }
    if (!hadUnderlyingNetworks) {
        // No idea what the underlying networks are; assume sane defaults
        metered = true;
        roaming = false;
        congested = false;
    }
    caps.setTransportTypes(transportTypes);
    caps.setLinkDownstreamBandwidthKbps(downKbps);
    caps.setLinkUpstreamBandwidthKbps(upKbps);
    caps.setCapability(NET_CAPABILITY_NOT_METERED, !metered);
    caps.setCapability(NET_CAPABILITY_NOT_ROAMING, !roaming);
    caps.setCapability(NET_CAPABILITY_NOT_CONGESTED, !congested);
}
#method_after
public synchronized NetworkCapabilities updateCapabilities(@Nullable Network defaultNetwork) {
    if (mConfig == null) {
        // VPN is not running.
        return null;
    }
    Network[] underlyingNetworks = mConfig.underlyingNetworks;
    if (underlyingNetworks == null && defaultNetwork != null) {
        // null underlying networks means to track the default.
        underlyingNetworks = new Network[] { defaultNetwork };
    }
    // Only apps targeting Q and above can explicitly declare themselves as metered.
    final boolean isAlwaysMetered = mIsPackageTargetingAtLeastQ && mConfig.isMetered;
    applyUnderlyingCapabilities(mContext.getSystemService(ConnectivityManager.class), underlyingNetworks, mNetworkCapabilities, isAlwaysMetered);
    return new NetworkCapabilities(mNetworkCapabilities);
}
#end_block

#method_before
private void agentConnect() {
    LinkProperties lp = makeLinkProperties();
    if (providesRoutesToMostDestinations(lp)) {
        mNetworkCapabilities.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    } else {
        mNetworkCapabilities.removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    }
    mNetworkInfo.setDetailedState(DetailedState.CONNECTING, null, null);
    NetworkMisc networkMisc = new NetworkMisc();
    networkMisc.allowBypass = mConfig.allowBypass && !mLockdown;
    mNetworkCapabilities.setEstablishingVpnAppUid(Binder.getCallingUid());
    mNetworkCapabilities.setUids(createUserAndRestrictedProfilesRanges(mUserHandle, mConfig.allowedApplications, mConfig.disallowedApplications));
    long token = Binder.clearCallingIdentity();
    try {
        mNetworkAgent = new NetworkAgent(mLooper, mContext, NETWORKTYPE, /* logtag */
        mNetworkInfo, mNetworkCapabilities, lp, ConnectivityConstants.VPN_DEFAULT_SCORE, networkMisc) {

            @Override
            public void unwanted() {
            // We are user controlled, not driven by NetworkRequest.
            }
        };
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    mNetworkInfo.setIsAvailable(true);
    updateState(DetailedState.CONNECTED, "agentConnect");
}
#method_after
private void agentConnect() {
    LinkProperties lp = makeLinkProperties();
    if (providesRoutesToMostDestinations(lp)) {
        mNetworkCapabilities.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    } else {
        mNetworkCapabilities.removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
    }
    mNetworkInfo.setDetailedState(DetailedState.CONNECTING, null, null);
    NetworkMisc networkMisc = new NetworkMisc();
    networkMisc.allowBypass = mConfig.allowBypass && !mLockdown;
    mNetworkCapabilities.setEstablishingVpnAppUid(Binder.getCallingUid());
    mNetworkCapabilities.setUids(createUserAndRestrictedProfilesRanges(mUserHandle, mConfig.allowedApplications, mConfig.disallowedApplications));
    long token = Binder.clearCallingIdentity();
    try {
        mNetworkAgent = new NetworkAgent(mLooper, mContext, NETWORKTYPE, /* logtag */
        mNetworkInfo, mNetworkCapabilities, lp, ConnectivityConstants.VPN_DEFAULT_SCORE, networkMisc, NetworkFactory.SerialNumber.VPN) {

            @Override
            public void unwanted() {
            // We are user controlled, not driven by NetworkRequest.
            }
        };
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    mNetworkInfo.setIsAvailable(true);
    updateState(DetailedState.CONNECTED, "agentConnect");
}
#end_block

#method_before
public synchronized ParcelFileDescriptor establish(VpnConfig config) {
    // Check if the caller is already prepared.
    UserManager mgr = UserManager.get(mContext);
    if (Binder.getCallingUid() != mOwnerUID) {
        return null;
    }
    // Check to ensure consent hasn't been revoked since we were prepared.
    if (!isVpnUserPreConsented(mPackage)) {
        return null;
    }
    // Check if the service is properly declared.
    Intent intent = new Intent(VpnConfig.SERVICE_INTERFACE);
    intent.setClassName(mPackage, config.user);
    long token = Binder.clearCallingIdentity();
    try {
        // Restricted users are not allowed to create VPNs, they are tied to Owner
        UserInfo user = mgr.getUserInfo(mUserHandle);
        if (user.isRestricted()) {
            throw new SecurityException("Restricted users cannot establish VPNs");
        }
        ResolveInfo info = AppGlobals.getPackageManager().resolveService(intent, null, 0, mUserHandle);
        if (info == null) {
            throw new SecurityException("Cannot find " + config.user);
        }
        if (!BIND_VPN_SERVICE.equals(info.serviceInfo.permission)) {
            throw new SecurityException(config.user + " does not require " + BIND_VPN_SERVICE);
        }
    } catch (RemoteException e) {
        throw new SecurityException("Cannot find " + config.user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // Save the old config in case we need to go back.
    VpnConfig oldConfig = mConfig;
    String oldInterface = mInterface;
    Connection oldConnection = mConnection;
    NetworkAgent oldNetworkAgent = mNetworkAgent;
    Set<UidRange> oldUsers = mNetworkCapabilities.getUids();
    // Configure the interface. Abort if any of these steps fails.
    ParcelFileDescriptor tun = ParcelFileDescriptor.adoptFd(jniCreate(config.mtu));
    try {
        String interfaze = jniGetName(tun.getFd());
        // TEMP use the old jni calls until there is support for netd address setting
        StringBuilder builder = new StringBuilder();
        for (LinkAddress address : config.addresses) {
            builder.append(" " + address);
        }
        if (jniSetAddresses(interfaze, builder.toString()) < 1) {
            throw new IllegalArgumentException("At least one address must be specified");
        }
        Connection connection = new Connection();
        if (!mContext.bindServiceAsUser(intent, connection, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, new UserHandle(mUserHandle))) {
            throw new IllegalStateException("Cannot bind " + config.user);
        }
        mConnection = connection;
        mInterface = interfaze;
        // Fill more values.
        config.user = mPackage;
        config.interfaze = mInterface;
        config.startTime = SystemClock.elapsedRealtime();
        mConfig = config;
        // parameters. If that fails, disconnect.
        if (oldConfig != null && updateLinkPropertiesInPlaceIfPossible(mNetworkAgent, oldConfig)) {
        // Keep mNetworkAgent unchanged
        } else {
            mNetworkAgent = null;
            updateState(DetailedState.CONNECTING, "establish");
            // Set up forwarding and DNS rules.
            agentConnect();
            // Remove the old tun's user forwarding rules
            // The new tun's user rules have already been added above so they will take over
            // as rules are deleted. This prevents data leakage as the rules are moved over.
            agentDisconnect(oldNetworkAgent);
        }
        // Set up VPN's capabilities such as meteredness.
        updateCapabilities();
        if (oldConnection != null) {
            mContext.unbindService(oldConnection);
        }
        if (oldInterface != null && !oldInterface.equals(interfaze)) {
            jniReset(oldInterface);
        }
        try {
            IoUtils.setBlocking(tun.getFileDescriptor(), config.blocking);
        } catch (IOException e) {
            throw new IllegalStateException("Cannot set tunnel's fd as blocking=" + config.blocking, e);
        }
    } catch (RuntimeException e) {
        IoUtils.closeQuietly(tun);
        agentDisconnect();
        // restore old state
        mConfig = oldConfig;
        mConnection = oldConnection;
        mNetworkCapabilities.setUids(oldUsers);
        mNetworkAgent = oldNetworkAgent;
        mInterface = oldInterface;
        throw e;
    }
    Log.i(TAG, "Established by " + config.user + " on " + mInterface);
    return tun;
}
#method_after
public synchronized ParcelFileDescriptor establish(VpnConfig config) {
    // Check if the caller is already prepared.
    UserManager mgr = UserManager.get(mContext);
    if (Binder.getCallingUid() != mOwnerUID) {
        return null;
    }
    // Check to ensure consent hasn't been revoked since we were prepared.
    if (!isVpnUserPreConsented(mPackage)) {
        return null;
    }
    // Check if the service is properly declared.
    Intent intent = new Intent(VpnConfig.SERVICE_INTERFACE);
    intent.setClassName(mPackage, config.user);
    long token = Binder.clearCallingIdentity();
    try {
        // Restricted users are not allowed to create VPNs, they are tied to Owner
        UserInfo user = mgr.getUserInfo(mUserHandle);
        if (user.isRestricted()) {
            throw new SecurityException("Restricted users cannot establish VPNs");
        }
        ResolveInfo info = AppGlobals.getPackageManager().resolveService(intent, null, 0, mUserHandle);
        if (info == null) {
            throw new SecurityException("Cannot find " + config.user);
        }
        if (!BIND_VPN_SERVICE.equals(info.serviceInfo.permission)) {
            throw new SecurityException(config.user + " does not require " + BIND_VPN_SERVICE);
        }
    } catch (RemoteException e) {
        throw new SecurityException("Cannot find " + config.user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // Save the old config in case we need to go back.
    VpnConfig oldConfig = mConfig;
    String oldInterface = mInterface;
    Connection oldConnection = mConnection;
    NetworkAgent oldNetworkAgent = mNetworkAgent;
    Set<UidRange> oldUsers = mNetworkCapabilities.getUids();
    // Configure the interface. Abort if any of these steps fails.
    ParcelFileDescriptor tun = ParcelFileDescriptor.adoptFd(jniCreate(config.mtu));
    try {
        String interfaze = jniGetName(tun.getFd());
        // TEMP use the old jni calls until there is support for netd address setting
        StringBuilder builder = new StringBuilder();
        for (LinkAddress address : config.addresses) {
            builder.append(" " + address);
        }
        if (jniSetAddresses(interfaze, builder.toString()) < 1) {
            throw new IllegalArgumentException("At least one address must be specified");
        }
        Connection connection = new Connection();
        if (!mContext.bindServiceAsUser(intent, connection, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, new UserHandle(mUserHandle))) {
            throw new IllegalStateException("Cannot bind " + config.user);
        }
        mConnection = connection;
        mInterface = interfaze;
        // Fill more values.
        config.user = mPackage;
        config.interfaze = mInterface;
        config.startTime = SystemClock.elapsedRealtime();
        mConfig = config;
        // parameters. If that fails, disconnect.
        if (oldConfig != null && updateLinkPropertiesInPlaceIfPossible(mNetworkAgent, oldConfig)) {
        // Keep mNetworkAgent unchanged
        } else {
            mNetworkAgent = null;
            updateState(DetailedState.CONNECTING, "establish");
            // Set up forwarding and DNS rules.
            agentConnect();
            // Remove the old tun's user forwarding rules
            // The new tun's user rules have already been added above so they will take over
            // as rules are deleted. This prevents data leakage as the rules are moved over.
            agentDisconnect(oldNetworkAgent);
        }
        if (oldConnection != null) {
            mContext.unbindService(oldConnection);
        }
        if (oldInterface != null && !oldInterface.equals(interfaze)) {
            jniReset(oldInterface);
        }
        try {
            IoUtils.setBlocking(tun.getFileDescriptor(), config.blocking);
        } catch (IOException e) {
            throw new IllegalStateException("Cannot set tunnel's fd as blocking=" + config.blocking, e);
        }
    } catch (RuntimeException e) {
        IoUtils.closeQuietly(tun);
        agentDisconnect();
        // restore old state
        mConfig = oldConfig;
        mConnection = oldConnection;
        mNetworkCapabilities.setUids(oldUsers);
        mNetworkAgent = oldNetworkAgent;
        mInterface = oldInterface;
        throw e;
    }
    Log.i(TAG, "Established by " + config.user + " on " + mInterface);
    return tun;
}
#end_block

#method_before
public void onUserAdded(int userHandle) {
    // If the user is restricted tie them to the parent user's VPN
    UserInfo user = UserManager.get(mContext).getUserInfo(userHandle);
    if (user.isRestricted() && user.restrictedProfileParentId == mUserHandle) {
        synchronized (Vpn.this) {
            final Set<UidRange> existingRanges = mNetworkCapabilities.getUids();
            if (existingRanges != null) {
                try {
                    addUserToRanges(existingRanges, userHandle, mConfig.allowedApplications, mConfig.disallowedApplications);
                    mNetworkCapabilities.setUids(existingRanges);
                    updateCapabilities();
                } catch (Exception e) {
                    Log.wtf(TAG, "Failed to add restricted user to owner", e);
                }
            }
            setVpnForcedLocked(mLockdown);
        }
    }
}
#method_after
public void onUserAdded(int userHandle) {
    // If the user is restricted tie them to the parent user's VPN
    UserInfo user = UserManager.get(mContext).getUserInfo(userHandle);
    if (user.isRestricted() && user.restrictedProfileParentId == mUserHandle) {
        synchronized (Vpn.this) {
            final Set<UidRange> existingRanges = mNetworkCapabilities.getUids();
            if (existingRanges != null) {
                try {
                    addUserToRanges(existingRanges, userHandle, mConfig.allowedApplications, mConfig.disallowedApplications);
                    // ConnectivityService will call {@link #updateCapabilities} and apply
                    // those for VPN network.
                    mNetworkCapabilities.setUids(existingRanges);
                } catch (Exception e) {
                    Log.wtf(TAG, "Failed to add restricted user to owner", e);
                }
            }
            setVpnForcedLocked(mLockdown);
        }
    }
}
#end_block

#method_before
public void onUserRemoved(int userHandle) {
    // clean up if restricted
    UserInfo user = UserManager.get(mContext).getUserInfo(userHandle);
    if (user.isRestricted() && user.restrictedProfileParentId == mUserHandle) {
        synchronized (Vpn.this) {
            final Set<UidRange> existingRanges = mNetworkCapabilities.getUids();
            if (existingRanges != null) {
                try {
                    final List<UidRange> removedRanges = uidRangesForUser(userHandle, existingRanges);
                    existingRanges.removeAll(removedRanges);
                    mNetworkCapabilities.setUids(existingRanges);
                    updateCapabilities();
                } catch (Exception e) {
                    Log.wtf(TAG, "Failed to remove restricted user to owner", e);
                }
            }
            setVpnForcedLocked(mLockdown);
        }
    }
}
#method_after
public void onUserRemoved(int userHandle) {
    // clean up if restricted
    UserInfo user = UserManager.get(mContext).getUserInfo(userHandle);
    if (user.isRestricted() && user.restrictedProfileParentId == mUserHandle) {
        synchronized (Vpn.this) {
            final Set<UidRange> existingRanges = mNetworkCapabilities.getUids();
            if (existingRanges != null) {
                try {
                    final List<UidRange> removedRanges = uidRangesForUser(userHandle, existingRanges);
                    existingRanges.removeAll(removedRanges);
                    // ConnectivityService will call {@link #updateCapabilities} and
                    // apply those for VPN network.
                    mNetworkCapabilities.setUids(existingRanges);
                } catch (Exception e) {
                    Log.wtf(TAG, "Failed to remove restricted user to owner", e);
                }
            }
            setVpnForcedLocked(mLockdown);
        }
    }
}
#end_block

#method_before
public synchronized boolean setUnderlyingNetworks(Network[] networks) {
    if (!isCallerEstablishedOwnerLocked()) {
        return false;
    }
    if (networks == null) {
        mConfig.underlyingNetworks = null;
    } else {
        mConfig.underlyingNetworks = new Network[networks.length];
        for (int i = 0; i < networks.length; ++i) {
            if (networks[i] == null) {
                mConfig.underlyingNetworks[i] = null;
            } else {
                mConfig.underlyingNetworks[i] = new Network(networks[i].netId);
            }
        }
    }
    updateCapabilities();
    return true;
}
#method_after
public synchronized boolean setUnderlyingNetworks(Network[] networks) {
    if (!isCallerEstablishedOwnerLocked()) {
        return false;
    }
    if (networks == null) {
        mConfig.underlyingNetworks = null;
    } else {
        mConfig.underlyingNetworks = new Network[networks.length];
        for (int i = 0; i < networks.length; ++i) {
            if (networks[i] == null) {
                mConfig.underlyingNetworks[i] = null;
            } else {
                mConfig.underlyingNetworks[i] = new Network(networks[i].netId);
            }
        }
    }
    return true;
}
#end_block

#method_before
public synchronized boolean isBlockingUid(int uid) {
    if (mNetworkInfo.isConnected()) {
        return !appliesToUid(uid);
    } else {
        for (UidRange uidRange : mBlockedUsers) {
            if (uidRange.contains(uid)) {
                return true;
            }
        }
        return false;
    }
}
#method_after
public synchronized boolean isBlockingUid(int uid) {
    if (mNetworkInfo.isConnected()) {
        return !appliesToUid(uid);
    } else {
        return UidRange.containsUid(mBlockedUsers, uid);
    }
}
#end_block

#method_before
public void startLegacyVpnPrivileged(VpnProfile profile, KeyStore keyStore, LinkProperties egress) {
    UserManager mgr = UserManager.get(mContext);
    UserInfo user = mgr.getUserInfo(mUserHandle);
    if (user.isRestricted() || mgr.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN, new UserHandle(mUserHandle))) {
        throw new SecurityException("Restricted users cannot establish VPNs");
    }
    final RouteInfo ipv4DefaultRoute = findIPv4DefaultRoute(egress);
    final String gateway = ipv4DefaultRoute.getGateway().getHostAddress();
    final String iface = ipv4DefaultRoute.getInterface();
    // Load certificates.
    String privateKey = "";
    String userCert = "";
    String caCert = "";
    String serverCert = "";
    if (!profile.ipsecUserCert.isEmpty()) {
        privateKey = Credentials.USER_PRIVATE_KEY + profile.ipsecUserCert;
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecUserCert);
        userCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecCaCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.CA_CERTIFICATE + profile.ipsecCaCert);
        caCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecServerCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecServerCert);
        serverCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (privateKey == null || userCert == null || caCert == null || serverCert == null) {
        throw new IllegalStateException("Cannot load credentials");
    }
    // Prepare arguments for racoon.
    String[] racoon = null;
    switch(profile.type) {
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
            racoon = new String[] { iface, profile.server, "udppsk", profile.ipsecIdentifier, profile.ipsecSecret, "1701" };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            racoon = new String[] { iface, profile.server, "udprsa", privateKey, userCert, caCert, serverCert, "1701" };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
            racoon = new String[] { iface, profile.server, "xauthpsk", profile.ipsecIdentifier, profile.ipsecSecret, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
            racoon = new String[] { iface, profile.server, "xauthrsa", privateKey, userCert, caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
            racoon = new String[] { iface, profile.server, "hybridrsa", caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
    }
    // Prepare arguments for mtpd.
    String[] mtpd = null;
    switch(profile.type) {
        case VpnProfile.TYPE_PPTP:
            mtpd = new String[] { iface, "pptp", profile.server, "1723", "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400", (profile.mppe ? "+mppe" : "nomppe") };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            mtpd = new String[] { iface, "l2tp", profile.server, "1701", profile.l2tpSecret, "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400" };
            break;
    }
    VpnConfig config = new VpnConfig();
    config.legacy = true;
    config.user = profile.key;
    config.interfaze = iface;
    config.session = profile.name;
    config.isMetered = false;
    config.addLegacyRoutes(profile.routes);
    if (!profile.dnsServers.isEmpty()) {
        config.dnsServers = Arrays.asList(profile.dnsServers.split(" +"));
    }
    if (!profile.searchDomains.isEmpty()) {
        config.searchDomains = Arrays.asList(profile.searchDomains.split(" +"));
    }
    startLegacyVpn(config, racoon, mtpd);
}
#method_after
public void startLegacyVpnPrivileged(VpnProfile profile, KeyStore keyStore, LinkProperties egress) {
    UserManager mgr = UserManager.get(mContext);
    UserInfo user = mgr.getUserInfo(mUserHandle);
    if (user.isRestricted() || mgr.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN, new UserHandle(mUserHandle))) {
        throw new SecurityException("Restricted users cannot establish VPNs");
    }
    final RouteInfo ipv4DefaultRoute = findIPv4DefaultRoute(egress);
    final String gateway = ipv4DefaultRoute.getGateway().getHostAddress();
    final String iface = ipv4DefaultRoute.getInterface();
    // Load certificates.
    String privateKey = "";
    String userCert = "";
    String caCert = "";
    String serverCert = "";
    if (!profile.ipsecUserCert.isEmpty()) {
        privateKey = Credentials.USER_PRIVATE_KEY + profile.ipsecUserCert;
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecUserCert);
        userCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecCaCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.CA_CERTIFICATE + profile.ipsecCaCert);
        caCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecServerCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecServerCert);
        serverCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (privateKey == null || userCert == null || caCert == null || serverCert == null) {
        throw new IllegalStateException("Cannot load credentials");
    }
    // Prepare arguments for racoon.
    String[] racoon = null;
    switch(profile.type) {
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
            racoon = new String[] { iface, profile.server, "udppsk", profile.ipsecIdentifier, profile.ipsecSecret, "1701" };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            racoon = new String[] { iface, profile.server, "udprsa", privateKey, userCert, caCert, serverCert, "1701" };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
            racoon = new String[] { iface, profile.server, "xauthpsk", profile.ipsecIdentifier, profile.ipsecSecret, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
            racoon = new String[] { iface, profile.server, "xauthrsa", privateKey, userCert, caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
            racoon = new String[] { iface, profile.server, "hybridrsa", caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
    }
    // Prepare arguments for mtpd.
    String[] mtpd = null;
    switch(profile.type) {
        case VpnProfile.TYPE_PPTP:
            mtpd = new String[] { iface, "pptp", profile.server, "1723", "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400", (profile.mppe ? "+mppe" : "nomppe") };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            mtpd = new String[] { iface, "l2tp", profile.server, "1701", profile.l2tpSecret, "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400" };
            break;
    }
    VpnConfig config = new VpnConfig();
    config.legacy = true;
    config.user = profile.key;
    config.interfaze = iface;
    config.session = profile.name;
    config.isMetered = false;
    config.proxyInfo = profile.proxy;
    config.addLegacyRoutes(profile.routes);
    if (!profile.dnsServers.isEmpty()) {
        config.dnsServers = Arrays.asList(profile.dnsServers.split(" +"));
    }
    if (!profile.searchDomains.isEmpty()) {
        config.searchDomains = Arrays.asList(profile.searchDomains.split(" +"));
    }
    startLegacyVpn(config, racoon, mtpd);
}
#end_block

#method_before
// Intended to be called only once at startup, after the system is ready. Installs a broadcast
public synchronized void startMonitoring() {
    log("Monitoring");
    List<PackageInfo> apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS | MATCH_ANY_USER);
    if (apps == null) {
        loge("No apps");
        return;
    }
    for (PackageInfo app : apps) {
        log("app: " + app + " uid = " + app.applicationInfo.uid);
        int uid = app.applicationInfo != null ? app.applicationInfo.uid : INVALID_UID;
        if (uid < 0) {
            continue;
        }
        if (UserHandle.getUserId(uid) == UserHandle.USER_SYSTEM) {
            boolean isNetwork = hasNetworkPermission(app);
            boolean hasRestrictedPermission = hasRestrictedNetworkPermission(app);
            if (isNetwork || hasRestrictedPermission) {
                Boolean permission = mApps.get(uid);
                // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
                if (permission == null || permission == NETWORK) {
                    mApps.put(uid, hasRestrictedPermission);
                }
            }
        }
        mAllApps.add(UserHandle.getAppId(uid));
    }
    // exclude dying users
    List<UserInfo> users = mUserManager.getUsers(true);
    if (users != null) {
        for (UserInfo user : users) {
            mUsers.add(user.id);
        }
    }
    log("Users: " + mUsers.size() + ", Apps: " + mApps.size());
    dump();
    update(mUsers, mApps, true);
}
#method_after
// Intended to be called only once at startup, after the system is ready. Installs a broadcast
public synchronized void startMonitoring() {
    log("Monitoring");
    PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
    if (pmi != null) {
        pmi.getPackageList(new PackageListObserver());
    } else {
        loge("failed to get the PackageManagerInternal service");
    }
    List<PackageInfo> apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS | MATCH_ANY_USER);
    if (apps == null) {
        loge("No apps");
        return;
    }
    SparseIntArray netdPermsUids = new SparseIntArray();
    for (PackageInfo app : apps) {
        int uid = app.applicationInfo != null ? app.applicationInfo.uid : INVALID_UID;
        if (uid < 0) {
            continue;
        }
        mAllApps.add(UserHandle.getAppId(uid));
        boolean isNetwork = hasNetworkPermission(app);
        boolean hasRestrictedPermission = hasRestrictedNetworkPermission(app);
        if (isNetwork || hasRestrictedPermission) {
            Boolean permission = mApps.get(uid);
            // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
            if (permission == null || permission == NETWORK) {
                mApps.put(uid, hasRestrictedPermission);
            }
        }
        // TODO: unify the management of the permissions into one codepath.
        int otherNetdPerms = getNetdPermissionMask(app.requestedPermissions, app.requestedPermissionsFlags);
        netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);
    }
    // exclude dying users
    List<UserInfo> users = mUserManager.getUsers(true);
    if (users != null) {
        for (UserInfo user : users) {
            mUsers.add(user.id);
        }
    }
    final SparseArray<ArraySet<String>> systemPermission = SystemConfig.getInstance().getSystemPermissions();
    for (int i = 0; i < systemPermission.size(); i++) {
        ArraySet<String> perms = systemPermission.valueAt(i);
        int uid = systemPermission.keyAt(i);
        int netdPermission = 0;
        // Get the uids of native services that have UPDATE_DEVICE_STATS permission.
        if (perms != null) {
            netdPermission |= perms.contains(UPDATE_DEVICE_STATS) ? INetd.PERMISSION_UPDATE_DEVICE_STATS : 0;
        }
        // For internet permission, the native services have their own selinux domains and
        // sepolicy will control the socket creation during run time. netd cannot block the
        // socket creation based on the permission information here.
        netdPermission |= INetd.PERMISSION_INTERNET;
        netdPermsUids.put(uid, netdPermsUids.get(uid) | netdPermission);
    }
    log("Users: " + mUsers.size() + ", Apps: " + mApps.size());
    update(mUsers, mApps, true);
    sendPackagePermissionsToNetd(netdPermsUids);
}
#end_block

#method_before
private int[] toIntArray(List<Integer> list) {
    int[] array = new int[list.size()];
    for (int i = 0; i < list.size(); i++) {
        array[i] = list.get(i);
    }
    return array;
}
#method_after
private int[] toIntArray(Collection<Integer> list) {
    int[] array = new int[list.size()];
    int i = 0;
    for (Integer item : list) {
        array[i++] = item;
    }
    return array;
}
#end_block

#method_before
private void update(Set<Integer> users, Map<Integer, Boolean> apps, boolean add) {
    List<Integer> network = new ArrayList<>();
    List<Integer> system = new ArrayList<>();
    for (Entry<Integer, Boolean> app : apps.entrySet()) {
        List<Integer> list = app.getValue() ? system : network;
        for (int user : users) {
            list.add(UserHandle.getUid(user, app.getKey()));
        }
    }
    try {
        if (add) {
            mNetd.setPermission("NETWORK", toIntArray(network));
            mNetd.setPermission("SYSTEM", toIntArray(system));
        } else {
            mNetd.clearPermission(toIntArray(network));
            mNetd.clearPermission(toIntArray(system));
        }
    } catch (RemoteException e) {
        loge("Exception when updating permissions: " + e);
    }
}
#method_after
private void update(Set<Integer> users, Map<Integer, Boolean> apps, boolean add) {
    List<Integer> network = new ArrayList<>();
    List<Integer> system = new ArrayList<>();
    for (Entry<Integer, Boolean> app : apps.entrySet()) {
        List<Integer> list = app.getValue() ? system : network;
        for (int user : users) {
            list.add(UserHandle.getUid(user, app.getKey()));
        }
    }
    try {
        if (add) {
            mNetd.networkSetPermissionForUser(INetd.PERMISSION_NETWORK, toIntArray(network));
            mNetd.networkSetPermissionForUser(INetd.PERMISSION_SYSTEM, toIntArray(system));
        } else {
            mNetd.networkClearPermissionForUser(toIntArray(network));
            mNetd.networkClearPermissionForUser(toIntArray(system));
        }
    } catch (RemoteException e) {
        loge("Exception when updating permissions: " + e);
    }
}
#end_block

#method_before
public synchronized void onUserAdded(int user) {
    if (user < 0) {
        loge("Invalid user in onUserAdded: " + user);
        return;
    }
    log("onUserAdded: " + user);
    dump();
    mUsers.add(user);
    Set<Integer> users = new HashSet<>();
    users.add(user);
    update(users, mApps, true);
}
#method_after
public synchronized void onUserAdded(int user) {
    if (user < 0) {
        loge("Invalid user in onUserAdded: " + user);
        return;
    }
    mUsers.add(user);
    Set<Integer> users = new HashSet<>();
    users.add(user);
    update(users, mApps, true);
}
#end_block

#method_before
public synchronized void onUserRemoved(int user) {
    if (user < 0) {
        loge("Invalid user in onUserRemoved: " + user);
        return;
    }
    log("onUserRemoved: " + user);
    dump();
    mUsers.remove(user);
    Set<Integer> users = new HashSet<>();
    users.add(user);
    update(users, mApps, false);
}
#method_after
public synchronized void onUserRemoved(int user) {
    if (user < 0) {
        loge("Invalid user in onUserRemoved: " + user);
        return;
    }
    mUsers.remove(user);
    Set<Integer> users = new HashSet<>();
    users.add(user);
    update(users, mApps, false);
}
#end_block

#method_before
public synchronized void onPackageAdded(String packageName, int uid) {
    log("onPackageAdded: " + packageName + " uid: " + uid);
    dump();
    // If multiple packages share a UID (cf: android:sharedUserId) and ask for different
    // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
    final Boolean permission = highestPermissionForUid(mApps.get(uid), packageName);
    if (permission != mApps.get(uid)) {
        mApps.put(uid, permission);
        Map<Integer, Boolean> apps = new HashMap<>();
        apps.put(uid, permission);
        update(mUsers, apps, true);
    }
    // If the newly-installed package falls within some VPN's uid range, update Netd with it.
    // This needs to happen after the mApps update above, since intersectUids()  depends on information
    // in mApps.
    final Set<Integer> appIds = new HashSet<>(Collections.singletonList(UserHandle.getAppId(uid)));
    for (Map.Entry<Integer, Set<UidRange>> vpn : mVpnUidRanges.entrySet()) {
        Set<Integer> changedUids = intersectUids(vpn.getValue(), appIds);
        updateVpnUids(vpn.getKey(), changedUids, true);
    }
    mAllApps.add(UserHandle.getAppId(uid));
}
#method_after
public synchronized void onPackageAdded(String packageName, int uid) {
    // If multiple packages share a UID (cf: android:sharedUserId) and ask for different
    // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
    final Boolean permission = highestPermissionForUid(mApps.get(uid), packageName);
    if (permission != mApps.get(uid)) {
        mApps.put(uid, permission);
        Map<Integer, Boolean> apps = new HashMap<>();
        apps.put(uid, permission);
        update(mUsers, apps, true);
    }
    // on mApps to check if the package can bypass VPN.
    for (Map.Entry<String, Set<UidRange>> vpn : mVpnUidRanges.entrySet()) {
        if (UidRange.containsUid(vpn.getValue(), uid)) {
            final Set<Integer> changedUids = new HashSet<>();
            changedUids.add(uid);
            removeBypassingUids(changedUids, /* vpnAppUid */
            -1);
            updateVpnUids(vpn.getKey(), changedUids, true);
        }
    }
    mAllApps.add(UserHandle.getAppId(uid));
}
#end_block

#method_before
public synchronized void onPackageRemoved(int uid) {
    log("onPackageRemoved: uid = " + uid);
    dump();
    // If the newly-removed package falls within some VPN's uid range, update Netd with it.
    // This needs to happen after the mApps update above, since intersectUids()  depends on information
    // in mApps.
    final Set<Integer> appIds = new HashSet<>(Collections.singletonList(UserHandle.getAppId(uid)));
    for (Map.Entry<Integer, Set<UidRange>> vpn : mVpnUidRanges.entrySet()) {
        Set<Integer> changedUids = intersectUids(vpn.getValue(), appIds);
        updateVpnUids(vpn.getKey(), changedUids, false);
    }
    mAllApps.remove(UserHandle.getAppId(uid));
    Map<Integer, Boolean> apps = new HashMap<>();
    Boolean permission = null;
    String[] packages = mPackageManager.getPackagesForUid(uid);
    if (packages != null && packages.length > 0) {
        for (String name : packages) {
            permission = highestPermissionForUid(permission, name);
            if (permission == SYSTEM) {
                // Nothing to do.
                return;
            }
        }
    }
    if (permission == mApps.get(uid)) {
        // The permissions of this UID have not changed. Nothing to do.
        return;
    } else if (permission != null) {
        mApps.put(uid, permission);
        apps.put(uid, permission);
        update(mUsers, apps, true);
    } else {
        mApps.remove(uid);
        // doesn't matter which permission we pick here
        apps.put(uid, NETWORK);
        update(mUsers, apps, false);
    }
}
#method_after
public synchronized void onPackageRemoved(int uid) {
    // on mApps to check if the package can bypass VPN.
    for (Map.Entry<String, Set<UidRange>> vpn : mVpnUidRanges.entrySet()) {
        if (UidRange.containsUid(vpn.getValue(), uid)) {
            final Set<Integer> changedUids = new HashSet<>();
            changedUids.add(uid);
            removeBypassingUids(changedUids, /* vpnAppUid */
            -1);
            updateVpnUids(vpn.getKey(), changedUids, false);
        }
    }
    // If the package has been removed from all users on the device, clear it form mAllApps.
    if (mPackageManager.getNameForUid(uid) == null) {
        mAllApps.remove(UserHandle.getAppId(uid));
    }
    Map<Integer, Boolean> apps = new HashMap<>();
    Boolean permission = null;
    String[] packages = mPackageManager.getPackagesForUid(uid);
    if (packages != null && packages.length > 0) {
        for (String name : packages) {
            permission = highestPermissionForUid(permission, name);
            if (permission == SYSTEM) {
                // Nothing to do.
                return;
            }
        }
    }
    if (permission == mApps.get(uid)) {
        // The permissions of this UID have not changed. Nothing to do.
        return;
    } else if (permission != null) {
        mApps.put(uid, permission);
        apps.put(uid, permission);
        update(mUsers, apps, true);
    } else {
        mApps.remove(uid);
        // doesn't matter which permission we pick here
        apps.put(uid, NETWORK);
        update(mUsers, apps, false);
    }
}
#end_block

#method_before
public synchronized void onVpnUidRangesAdded(int netId, Set<UidRange> ranges) {
    log("onVpnUidRangesAdded: netId = " + netId);
    StringBuilder sb = new StringBuilder();
    sb.append("vpn range: ");
    for (UidRange range : ranges) {
        sb.append(range.toString() + " ");
    }
    log(sb.toString());
    // Calculate all app uids under the new VPN range and update Netd about it.
    updateVpnUids(netId, intersectUids(ranges, mAllApps), true);
    if (mVpnUidRanges.containsKey(netId)) {
        mVpnUidRanges.get(netId).addAll(ranges);
    } else {
        mVpnUidRanges.put(netId, new HashSet<UidRange>(ranges));
    }
}
#method_after
public synchronized void onVpnUidRangesAdded(@NonNull String iface, Set<UidRange> rangesToAdd, int vpnAppUid) {
    // Calculate the list of new app uids under the VPN due to the new UID ranges and update
    // Netd about them. Because mAllApps only contains appIds instead of uids, the result might
    // be an overestimation if an app is not installed on the user on which the VPN is running,
    // but that's safe.
    final Set<Integer> changedUids = intersectUids(rangesToAdd, mAllApps);
    removeBypassingUids(changedUids, vpnAppUid);
    updateVpnUids(iface, changedUids, true);
    if (mVpnUidRanges.containsKey(iface)) {
        mVpnUidRanges.get(iface).addAll(rangesToAdd);
    } else {
        mVpnUidRanges.put(iface, new HashSet<UidRange>(rangesToAdd));
    }
}
#end_block

#method_before
public synchronized void onVpnUidRangesRemoved(int netId, Set<UidRange> ranges) {
    // Calculate all app uids under the new VPN range and update Netd about it.
    updateVpnUids(netId, intersectUids(ranges, mAllApps), false);
    Set<UidRange> existingRanges = mVpnUidRanges.getOrDefault(netId, null);
    if (existingRanges != null) {
        existingRanges.removeAll(ranges);
        if (existingRanges.size() == 0) {
            mVpnUidRanges.remove(netId);
        }
    } else {
        loge("Remove unknown vpn range on net " + netId);
    }
}
#method_after
public synchronized void onVpnUidRangesRemoved(@NonNull String iface, Set<UidRange> rangesToRemove, int vpnAppUid) {
    // Calculate the list of app uids that are no longer under the VPN due to the removed UID
    // ranges and update Netd about them.
    final Set<Integer> changedUids = intersectUids(rangesToRemove, mAllApps);
    removeBypassingUids(changedUids, vpnAppUid);
    updateVpnUids(iface, changedUids, false);
    Set<UidRange> existingRanges = mVpnUidRanges.getOrDefault(iface, null);
    if (existingRanges == null) {
        loge("Attempt to remove unknown vpn uid Range iface = " + iface);
        return;
    }
    existingRanges.removeAll(rangesToRemove);
    if (existingRanges.size() == 0) {
        mVpnUidRanges.remove(iface);
    }
}
#end_block

#method_before
private Set<Integer> intersectUids(Set<UidRange> ranges, Set<Integer> appIds) {
    Set<Integer> result = new HashSet<>();
    for (UidRange range : ranges) {
        final int userId = range.getStartUser();
        for (int appId : appIds) {
            final int uid = UserHandle.getUid(userId, appId);
            if (range.contains(uid) && mApps.getOrDefault(appId, NETWORK) != SYSTEM) {
                result.add(uid);
            }
        }
    }
    return result;
}
#method_after
private Set<Integer> intersectUids(Set<UidRange> ranges, Set<Integer> appIds) {
    Set<Integer> result = new HashSet<>();
    for (UidRange range : ranges) {
        for (int userId = range.getStartUser(); userId <= range.getEndUser(); userId++) {
            for (int appId : appIds) {
                final int uid = UserHandle.getUid(userId, appId);
                if (range.contains(uid)) {
                    result.add(uid);
                }
            }
        }
    }
    return result;
}
#end_block

#method_before
private void updateVpnUids(int netId, Set<Integer> ranges, boolean add) {
    if (ranges.size() == 0) {
        return;
    }
    try {
        StringBuilder sb = new StringBuilder();
        INetd netd = NetdService.getInstance();
        int[] uids = new int[ranges.size()];
        int i = 0;
        for (int uid : ranges) {
            // SANITY CHECK ONLY: STOPSHIP
            if (netd.networkCanProtect(uid)) {
                loge("Privilleged uid " + uid + " should not be included in the filter list");
            }
            sb.append(uid);
            sb.append(", ");
            uids[i++] = uid;
        }
        if (add) {
            log("Add VPN Uid range: " + netId + " " + sb.toString());
            netd.firewallAddUidInterfaceRules(netId, uids);
        } else {
            log("Remove VPN Uid range: " + netId + " " + sb.toString());
            netd.firewallRemoveUidInterfaceRules(netId, uids);
        }
    } catch (RemoteException e) {
        loge("Exception when updating permissions: ", e);
    }
}
#method_after
private void updateVpnUids(String iface, Set<Integer> uids, boolean add) {
    if (uids.size() == 0) {
        return;
    }
    try {
        if (add) {
            mNetd.firewallAddUidInterfaceRules(iface, toIntArray(uids));
        } else {
            mNetd.firewallRemoveUidInterfaceRules(toIntArray(uids));
        }
    } catch (ServiceSpecificException e) {
        // the exception and do not crash
        if (e.errorCode != OsConstants.EOPNOTSUPP) {
            loge("Exception when updating permissions: ", e);
        }
    } catch (RemoteException e) {
        loge("Exception when updating permissions: ", e);
    }
}
#end_block

#method_before
private void dump() {
    for (Map.Entry<Integer, Set<UidRange>> vpn : mVpnUidRanges.entrySet()) {
        StringBuilder sb = new StringBuilder();
        sb.append("VPN: " + vpn.getKey() + " - uids:");
        for (UidRange range : vpn.getValue()) {
            sb.append(range.toString() + " ");
        }
        log(sb.toString());
    }
    StringBuilder sb = new StringBuilder();
    sb.append("AllApps: ");
    for (Integer range : mAllApps) {
        sb.append(range.toString() + " ");
    }
    log(sb.toString());
}
#method_after
public void dump(IndentingPrintWriter pw) {
    pw.println("Interface filtering rules:");
    pw.increaseIndent();
    for (Map.Entry<String, Set<UidRange>> vpn : mVpnUidRanges.entrySet()) {
        pw.println("Interface: " + vpn.getKey());
        pw.println("UIDs: " + vpn.getValue().toString());
        pw.println();
    }
    pw.decreaseIndent();
}
#end_block

#method_before
private static void extractZicFiles(MappedByteBuffer mappedFile, int indexOffset, int dataOffset, File outputDir) throws IOException {
    mappedFile.position(indexOffset);
    byte[] idBytes = new byte[MAXNAME];
    int indexSize = (dataOffset - indexOffset);
    if (indexSize % SIZEOF_INDEX_ENTRY != 0) {
        throw new IOException("Index size is not divisible by " + SIZEOF_INDEX_ENTRY + ", indexSize=" + indexSize);
    }
    int entryCount = indexSize / SIZEOF_INDEX_ENTRY;
    int[] byteOffsets = new int[entryCount];
    int[] lengths = new int[entryCount];
    String[] ids = new String[entryCount];
    for (int i = 0; i < entryCount; i++) {
        // Read the fixed length timezone ID.
        mappedFile.get(idBytes, 0, idBytes.length);
        // Read the offset into the file where the data for ID can be found.
        byteOffsets[i] = mappedFile.getInt();
        byteOffsets[i] += dataOffset;
        lengths[i] = mappedFile.getInt();
        if (lengths[i] < 44) {
            throw new IOException("length in index file < sizeof(tzhead)");
        }
        // Skip the unused 4 bytes that used to be the raw offset.
        mappedFile.getInt();
        // Calculate the true length of the ID.
        int len = 0;
        while (len < idBytes.length && idBytes[len] != 0) {
            len++;
        }
        if (len == 0) {
            throw new IOException("Invalid ID at index=" + i);
        }
        ids[i] = new String(idBytes, 0, len, StandardCharsets.US_ASCII);
        if (i > 0) {
            if (ids[i].compareTo(ids[i - 1]) <= 0) {
                throw new IOException("Index not sorted or contains multiple entries with the same ID" + ", index=" + i + ", ids[i]=" + ids[i] + ", ids[i - 1]=" + ids[i - 1]);
            }
        }
    }
    for (int i = 0; i < entryCount; i++) {
        String id = ids[i];
        int byteOffset = byteOffsets[i];
        int length = lengths[i];
        File subFile = new File(outputDir, id.replace('/', '_'));
        mappedFile.position(byteOffset);
        byte[] bytes = new byte[length];
        mappedFile.get(bytes, 0, length);
        writeBytesToFile(subFile, bytes);
    }
}
#method_after
private static void extractZicFiles(MappedByteBuffer mappedFile, int indexOffset, int dataOffset, File outputDir) throws IOException {
    mappedFile.position(indexOffset);
    // The index of the tzdata file is made up of entries for each time zone ID which describe
    // the location of the associated zic data in the data section of the file. The index
    // section has no padding so we can determine the number of entries from the size.
    // 
    // Each index entry consists of:
    // byte[MAXNAME] idBytes - the id string, \0 terminated. e.g. "America/New_York\0"
    // int32 byteOffset      - the offset of the start of the zic data relative to the start of
    // the tzdata data section
    // int32 length          - the length of the of the zic data
    // int32 unused          - no longer used
    final int MAXNAME = 40;
    final int SIZEOF_OFFSET = 4;
    final int SIZEOF_INDEX_ENTRY = MAXNAME + 3 * SIZEOF_OFFSET;
    int indexSize = (dataOffset - indexOffset);
    if (indexSize % SIZEOF_INDEX_ENTRY != 0) {
        throw new IOException("Index size is not divisible by " + SIZEOF_INDEX_ENTRY + ", indexSize=" + indexSize);
    }
    byte[] idBytes = new byte[MAXNAME];
    int entryCount = indexSize / SIZEOF_INDEX_ENTRY;
    int[] byteOffsets = new int[entryCount];
    int[] lengths = new int[entryCount];
    String[] ids = new String[entryCount];
    for (int i = 0; i < entryCount; i++) {
        // Read the fixed length timezone ID.
        mappedFile.get(idBytes, 0, idBytes.length);
        // Read the offset into the file where the data for ID can be found.
        byteOffsets[i] = mappedFile.getInt();
        byteOffsets[i] += dataOffset;
        lengths[i] = mappedFile.getInt();
        if (lengths[i] < 44) {
            throw new IOException("length in index file < sizeof(tzhead)");
        }
        // Skip the unused 4 bytes that used to be the raw offset.
        mappedFile.getInt();
        // Calculate the true length of the ID.
        int len = 0;
        while (len < idBytes.length && idBytes[len] != 0) {
            len++;
        }
        if (len == 0) {
            throw new IOException("Invalid ID at index=" + i);
        }
        ids[i] = new String(idBytes, 0, len, StandardCharsets.US_ASCII);
        if (i > 0) {
            if (ids[i].compareTo(ids[i - 1]) <= 0) {
                throw new IOException("Index not sorted or contains multiple entries with the same ID" + ", index=" + i + ", ids[i]=" + ids[i] + ", ids[i - 1]=" + ids[i - 1]);
            }
        }
    }
    for (int i = 0; i < entryCount; i++) {
        String id = ids[i];
        int byteOffset = byteOffsets[i];
        int length = lengths[i];
        File subFile = new File(outputDir, id.replace('/', '_'));
        mappedFile.position(byteOffset);
        byte[] bytes = new byte[length];
        mappedFile.get(bytes, 0, length);
        writeBytesToFile(subFile, bytes);
    }
}
#end_block

#method_before
@libcore.api.CorePlatformApi
public static byte[] decode(char[] encoded, boolean allowSingleChar) throws IllegalArgumentException {
    int resultLengthBytes = (encoded.length + 1) / 2;
    byte[] result = new byte[resultLengthBytes];
    int resultOffset = 0;
    int i = 0;
    if (allowSingleChar) {
        if ((encoded.length % 2) != 0) {
            // Odd number of digits -- the first digit is the lower 4 bits of the first result
            // byte.
            result[resultOffset++] = (byte) toDigit(encoded, i);
            i++;
        }
    } else {
        if ((encoded.length % 2) != 0) {
            throw new IllegalArgumentException("Invalid input length: " + encoded.length);
        }
    }
    for (; i < encoded.length; i += 2) {
        result[resultOffset++] = (byte) ((toDigit(encoded, i) << 4) | toDigit(encoded, i + 1));
    }
    return result;
}
#method_after
@libcore.api.CorePlatformApi
public static byte[] decode(char[] encoded, boolean allowSingleChar) throws IllegalArgumentException {
    int encodedLength = encoded.length;
    int resultLengthBytes = (encodedLength + 1) / 2;
    byte[] result = new byte[resultLengthBytes];
    int resultOffset = 0;
    int i = 0;
    if (allowSingleChar) {
        if ((encodedLength % 2) != 0) {
            // Odd number of digits -- the first digit is the lower 4 bits of the first result
            // byte.
            result[resultOffset++] = (byte) toDigit(encoded, i);
            i++;
        }
    } else {
        if ((encodedLength % 2) != 0) {
            throw new IllegalArgumentException("Invalid input length: " + encodedLength);
        }
    }
    for (; i < encodedLength; i += 2) {
        result[resultOffset++] = (byte) ((toDigit(encoded, i) << 4) | toDigit(encoded, i + 1));
    }
    return result;
}
#end_block

#method_before
@Test
public void testLoadJni() {
    assertEquals(0, 0x00);
}
#method_after
@Test
public void testLoadJni() {
    System.loadLibrary("networkstatsfactorytestjni");
    assertEquals(0, 0x00);
}
#end_block

#method_before
private void requestAudioFocusIfNone() {
    if (mAudioFocus == AudioManager.AUDIOFOCUS_NONE) {
        requestAudioFocus();
    }
}
#method_after
private void requestAudioFocusIfNone() {
    if (DBG)
        Log.d(TAG, "requestAudioFocusIfNone()");
    if (mAudioFocus == AudioManager.AUDIOFOCUS_NONE) {
        requestAudioFocus();
    }
    // On the off change mMediaPlayer errors out and dies, we want to make sure we retry this.
    // This function immediately exits if we have a MediaPlayer object.
    requestMediaKeyFocus();
}
#end_block

#method_before
private synchronized int requestAudioFocus() {
    // Bluetooth A2DP may carry Music, Audio Books, Navigation, or other sounds so mark content
    // type unknown.
    AudioAttributes streamAttributes = new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_MEDIA).setContentType(AudioAttributes.CONTENT_TYPE_UNKNOWN).build();
    // Bluetooth ducking is handled at the native layer so tell the Audio Manger to notify the
    // focus change listener via .setWillPauseWhenDucked().
    AudioFocusRequest focusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN).setAudioAttributes(streamAttributes).setWillPauseWhenDucked(true).setOnAudioFocusChangeListener(mAudioFocusListener, this).build();
    int focusRequestStatus = mAudioManager.requestAudioFocus(focusRequest);
    // If the request is granted begin streaming immediately and schedule an upgrade.
    if (focusRequestStatus == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
        startFluorideStreaming();
        mAudioFocus = AudioManager.AUDIOFOCUS_GAIN;
    }
    return focusRequestStatus;
}
#method_after
private synchronized int requestAudioFocus() {
    if (DBG)
        Log.d(TAG, "requestAudioFocus()");
    // Bluetooth A2DP may carry Music, Audio Books, Navigation, or other sounds so mark content
    // type unknown.
    AudioAttributes streamAttributes = new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_MEDIA).setContentType(AudioAttributes.CONTENT_TYPE_UNKNOWN).build();
    // Bluetooth ducking is handled at the native layer so tell the Audio Manger to notify the
    // focus change listener via .setWillPauseWhenDucked().
    AudioFocusRequest focusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN).setAudioAttributes(streamAttributes).setWillPauseWhenDucked(true).setOnAudioFocusChangeListener(mAudioFocusListener, this).build();
    int focusRequestStatus = mAudioManager.requestAudioFocus(focusRequest);
    // If the request is granted begin streaming immediately and schedule an upgrade.
    if (focusRequestStatus == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
        startFluorideStreaming();
        mAudioFocus = AudioManager.AUDIOFOCUS_GAIN;
    }
    return focusRequestStatus;
}
#end_block

#method_before
private synchronized void abandonAudioFocus() {
    stopFluorideStreaming();
    mAudioManager.abandonAudioFocus(mAudioFocusListener);
    mAudioFocus = AudioManager.AUDIOFOCUS_NONE;
}
#method_after
private synchronized void abandonAudioFocus() {
    if (DBG)
        Log.d(TAG, "abandonAudioFocus()");
    stopFluorideStreaming();
    releaseMediaKeyFocus();
    mAudioManager.abandonAudioFocus(mAudioFocusListener);
    mAudioFocus = AudioManager.AUDIOFOCUS_NONE;
}
#end_block

#method_before
BrowseTree.BrowseNode findNode(String parentMediaId) {
    Log.d("TAG", "FindNode");
    return mBrowseTree.findBrowseNodeByID(parentMediaId);
}
#method_after
BrowseTree.BrowseNode findNode(String parentMediaId) {
    logD("FindNode");
    return mBrowseTree.findBrowseNodeByID(parentMediaId);
}
#end_block

#method_before
@Override
public void enter() {
    logD("Enter Disconnected");
    if (mMostRecentState != BluetoothProfile.STATE_DISCONNECTED) {
        sendMessage(CLEANUP);
    }
    onConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTED);
}
#method_after
@Override
public void enter() {
    logD("Enter Disconnected");
    if (mMostRecentState != BluetoothProfile.STATE_DISCONNECTED) {
        sendMessage(CLEANUP);
    }
    broadcastConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTED);
}
#end_block

#method_before
@Override
public void enter() {
    logD("Enter Connecting");
    onConnectionStateChanged(BluetoothProfile.STATE_CONNECTING);
    transitionTo(mConnected);
}
#method_after
@Override
public void enter() {
    logD("Enter Connecting");
    broadcastConnectionStateChanged(BluetoothProfile.STATE_CONNECTING);
    transitionTo(mConnected);
}
#end_block

#method_before
@Override
public void enter() {
    if (mMostRecentState == BluetoothProfile.STATE_CONNECTING) {
        onConnectionStateChanged(BluetoothProfile.STATE_CONNECTED);
        BluetoothMediaBrowserService.addressedPlayerChanged(mSessionCallbacks);
    } else {
        Log.d(STATE_TAG, "ReEnteringConnecting");
    }
    super.enter();
}
#method_after
@Override
public void enter() {
    if (mMostRecentState == BluetoothProfile.STATE_CONNECTING) {
        broadcastConnectionStateChanged(BluetoothProfile.STATE_CONNECTED);
        BluetoothMediaBrowserService.addressedPlayerChanged(mSessionCallbacks);
    } else {
        logD("ReEnteringConnected");
    }
    super.enter();
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    Log.d(STATE_TAG, "processMessage " + msg.what);
    switch(msg.what) {
        case MESSAGE_PROCESS_SET_ABS_VOL_CMD:
            mVolumeChangedNotificationsToIgnore++;
            removeMessages(MESSAGE_INTERNAL_ABS_VOL_TIMEOUT);
            sendMessageDelayed(MESSAGE_INTERNAL_ABS_VOL_TIMEOUT, ABS_VOL_TIMEOUT_MILLIS);
            setAbsVolume(msg.arg1, msg.arg2);
            return true;
        case MESSAGE_GET_FOLDER_ITEMS:
            transitionTo(mGetFolderList);
            return true;
        case MESSAGE_PLAY_ITEM:
            // Set Addressed Player
            playItem((BrowseTree.BrowseNode) msg.obj);
            return true;
        case MSG_AVRCP_PASSTHRU:
            passThru(msg.arg1);
            return true;
        case MESSAGE_PROCESS_TRACK_CHANGED:
            mAddressedPlayer.updateCurrentTrack((MediaMetadata) msg.obj);
            BluetoothMediaBrowserService.trackChanged((MediaMetadata) msg.obj);
            return true;
        case MESSAGE_PROCESS_PLAY_STATUS_CHANGED:
            mAddressedPlayer.setPlayStatus(msg.arg1);
            BluetoothMediaBrowserService.notifyChanged(mAddressedPlayer.getPlaybackState());
            if (mAddressedPlayer.getPlaybackState().getState() == PlaybackState.STATE_PLAYING && A2dpSinkService.getFocusState() == AudioManager.AUDIOFOCUS_NONE && !shouldRequestFocus()) {
                sendMessage(MSG_AVRCP_PASSTHRU, AvrcpControllerService.PASS_THRU_CMD_ID_PAUSE);
            }
            return true;
        case MESSAGE_PROCESS_PLAY_POS_CHANGED:
            if (msg.arg2 != -1) {
                mAddressedPlayer.setPlayTime(msg.arg2);
                BluetoothMediaBrowserService.notifyChanged(mAddressedPlayer.getPlaybackState());
            }
            return true;
        case DISCONNECT:
            transitionTo(mDisconnecting);
            return true;
        default:
            return super.processMessage(msg);
    }
}
#method_after
@Override
public boolean processMessage(Message msg) {
    logD(STATE_TAG + " processMessage " + msg.what);
    switch(msg.what) {
        case MESSAGE_PROCESS_SET_ABS_VOL_CMD:
            mVolumeChangedNotificationsToIgnore++;
            removeMessages(MESSAGE_INTERNAL_ABS_VOL_TIMEOUT);
            sendMessageDelayed(MESSAGE_INTERNAL_ABS_VOL_TIMEOUT, ABS_VOL_TIMEOUT_MILLIS);
            setAbsVolume(msg.arg1, msg.arg2);
            return true;
        case MESSAGE_GET_FOLDER_ITEMS:
            transitionTo(mGetFolderList);
            return true;
        case MESSAGE_PLAY_ITEM:
            // Set Addressed Player
            playItem((BrowseTree.BrowseNode) msg.obj);
            return true;
        case MSG_AVRCP_PASSTHRU:
            passThru(msg.arg1);
            return true;
        case MESSAGE_PROCESS_TRACK_CHANGED:
            mAddressedPlayer.updateCurrentTrack((MediaMetadata) msg.obj);
            BluetoothMediaBrowserService.trackChanged((MediaMetadata) msg.obj);
            return true;
        case MESSAGE_PROCESS_PLAY_STATUS_CHANGED:
            mAddressedPlayer.setPlayStatus(msg.arg1);
            BluetoothMediaBrowserService.notifyChanged(mAddressedPlayer.getPlaybackState());
            if (mAddressedPlayer.getPlaybackState().getState() == PlaybackState.STATE_PLAYING && A2dpSinkService.getFocusState() == AudioManager.AUDIOFOCUS_NONE && !shouldRequestFocus()) {
                sendMessage(MSG_AVRCP_PASSTHRU, AvrcpControllerService.PASS_THRU_CMD_ID_PAUSE);
            }
            return true;
        case MESSAGE_PROCESS_PLAY_POS_CHANGED:
            if (msg.arg2 != -1) {
                mAddressedPlayer.setPlayTime(msg.arg2);
                BluetoothMediaBrowserService.notifyChanged(mAddressedPlayer.getPlaybackState());
            }
            return true;
        case DISCONNECT:
            transitionTo(mDisconnecting);
            return true;
        default:
            return super.processMessage(msg);
    }
}
#end_block

#method_before
@Override
public void enter() {
    Log.d(STATE_TAG, "ENTERING GETFOLDERLIST");
    // Setup the timeouts.
    sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
    super.enter();
    mAbort = false;
    Message msg = getCurrentMessage();
    if (msg.what == MESSAGE_GET_FOLDER_ITEMS) {
        {
            Log.d(STATE_TAG, "new Get Request");
            mBrowseNode = (BrowseTree.BrowseNode) msg.obj;
        }
    }
    if (mBrowseNode == null) {
        transitionTo(mConnected);
    } else {
        navigateToFolderOrRetrieve(mBrowseNode);
    }
}
#method_after
@Override
public void enter() {
    logD(STATE_TAG + " Entering GetFolderList");
    // Setup the timeouts.
    sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
    super.enter();
    mAbort = false;
    Message msg = getCurrentMessage();
    if (msg.what == MESSAGE_GET_FOLDER_ITEMS) {
        {
            logD(STATE_TAG + " new Get Request");
            mBrowseNode = (BrowseTree.BrowseNode) msg.obj;
        }
    }
    if (mBrowseNode == null) {
        transitionTo(mConnected);
    } else {
        navigateToFolderOrRetrieve(mBrowseNode);
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    if (DBG)
        Log.d(STATE_TAG, "processMessage " + msg.what);
    switch(msg.what) {
        case MESSAGE_PROCESS_GET_FOLDER_ITEMS:
            ArrayList<MediaItem> folderList = (ArrayList<MediaItem>) msg.obj;
            int endIndicator = mBrowseNode.getExpectedChildren() - 1;
            logD("GetFolderItems: End " + endIndicator + " received " + folderList.size());
            // Always update the node so that the user does not wait forever
            // for the list to populate.
            mBrowseNode.addChildren(folderList);
            notifyChanged(mBrowseNode);
            if (mBrowseNode.getChildrenCount() >= endIndicator || folderList.size() == 0 || mAbort) {
                // If we have fetched all the elements or if the remotes sends us 0 elements
                // (which can lead us into a loop since mCurrInd does not proceed) we simply
                // abort.
                mBrowseNode.setCached(true);
                transitionTo(mConnected);
            } else {
                // Fetch the next set of items.
                fetchContents(mBrowseNode);
                // Reset the timeout message since we are doing a new fetch now.
                removeMessages(MESSAGE_INTERNAL_CMD_TIMEOUT);
                sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
            }
            break;
        case MESSAGE_PROCESS_SET_BROWSED_PLAYER:
            mBrowseTree.setCurrentBrowsedPlayer(mNextStep.getID(), msg.arg1, msg.arg2);
            removeMessages(MESSAGE_INTERNAL_CMD_TIMEOUT);
            sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
            navigateToFolderOrRetrieve(mBrowseNode);
            break;
        case MESSAGE_PROCESS_FOLDER_PATH:
            mBrowseTree.setCurrentBrowsedFolder(mNextStep.getID());
            mBrowseTree.getCurrentBrowsedFolder().setExpectedChildren(msg.arg1);
            if (mAbort) {
                transitionTo(mConnected);
            } else {
                removeMessages(MESSAGE_INTERNAL_CMD_TIMEOUT);
                sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
                navigateToFolderOrRetrieve(mBrowseNode);
            }
            break;
        case MESSAGE_PROCESS_GET_PLAYER_ITEMS:
            BrowseTree.BrowseNode rootNode = mBrowseTree.mRootNode;
            if (!rootNode.isCached()) {
                List<AvrcpPlayer> playerList = (List<AvrcpPlayer>) msg.obj;
                mAvailablePlayerList.clear();
                for (AvrcpPlayer player : playerList) {
                    mAvailablePlayerList.put(player.getId(), player);
                }
                rootNode.addChildren(playerList);
                mBrowseTree.setCurrentBrowsedFolder(BrowseTree.ROOT);
                rootNode.setExpectedChildren(playerList.size());
                rootNode.setCached(true);
                notifyChanged(rootNode);
            }
            transitionTo(mConnected);
            break;
        case MESSAGE_INTERNAL_CMD_TIMEOUT:
            // We have timed out to execute the request, we should simply send
            // whatever listing we have gotten until now.
            Log.w(TAG, "TIMEOUT");
            transitionTo(mConnected);
            break;
        case MESSAGE_PROCESS_GET_FOLDER_ITEMS_OUT_OF_RANGE:
            // If we have gotten an error for OUT OF RANGE we have
            // already sent all the items to the client hence simply
            // transition to Connected state here.
            mBrowseNode.setCached(true);
            transitionTo(mConnected);
            break;
        case MESSAGE_GET_FOLDER_ITEMS:
            if (!mBrowseNode.equals(msg.obj)) {
                if (mBrowseNode.getScope() == ((BrowseTree.BrowseNode) msg.obj).getScope()) {
                    mAbort = true;
                }
                deferMessage(msg);
                logD("GetFolderItems: Go Get Another Directory");
            } else {
                logD("GetFolderItems: Get The Same Directory, ignore");
            }
            break;
        default:
            if (DBG) {
                Log.d(STATE_TAG, "deferring message " + msg.what + " to connected!");
            }
            deferMessage(msg);
    }
    return true;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    logD(STATE_TAG + " processMessage " + msg.what);
    switch(msg.what) {
        case MESSAGE_PROCESS_GET_FOLDER_ITEMS:
            ArrayList<MediaItem> folderList = (ArrayList<MediaItem>) msg.obj;
            int endIndicator = mBrowseNode.getExpectedChildren() - 1;
            logD("GetFolderItems: End " + endIndicator + " received " + folderList.size());
            // Always update the node so that the user does not wait forever
            // for the list to populate.
            mBrowseNode.addChildren(folderList);
            notifyChanged(mBrowseNode);
            if (mBrowseNode.getChildrenCount() >= endIndicator || folderList.size() == 0 || mAbort) {
                // If we have fetched all the elements or if the remotes sends us 0 elements
                // (which can lead us into a loop since mCurrInd does not proceed) we simply
                // abort.
                mBrowseNode.setCached(true);
                transitionTo(mConnected);
            } else {
                // Fetch the next set of items.
                fetchContents(mBrowseNode);
                // Reset the timeout message since we are doing a new fetch now.
                removeMessages(MESSAGE_INTERNAL_CMD_TIMEOUT);
                sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
            }
            break;
        case MESSAGE_PROCESS_SET_BROWSED_PLAYER:
            mBrowseTree.setCurrentBrowsedPlayer(mNextStep.getID(), msg.arg1, msg.arg2);
            removeMessages(MESSAGE_INTERNAL_CMD_TIMEOUT);
            sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
            navigateToFolderOrRetrieve(mBrowseNode);
            break;
        case MESSAGE_PROCESS_FOLDER_PATH:
            mBrowseTree.setCurrentBrowsedFolder(mNextStep.getID());
            mBrowseTree.getCurrentBrowsedFolder().setExpectedChildren(msg.arg1);
            if (mAbort) {
                transitionTo(mConnected);
            } else {
                removeMessages(MESSAGE_INTERNAL_CMD_TIMEOUT);
                sendMessageDelayed(MESSAGE_INTERNAL_CMD_TIMEOUT, CMD_TIMEOUT_MILLIS);
                navigateToFolderOrRetrieve(mBrowseNode);
            }
            break;
        case MESSAGE_PROCESS_GET_PLAYER_ITEMS:
            BrowseTree.BrowseNode rootNode = mBrowseTree.mRootNode;
            if (!rootNode.isCached()) {
                List<AvrcpPlayer> playerList = (List<AvrcpPlayer>) msg.obj;
                mAvailablePlayerList.clear();
                for (AvrcpPlayer player : playerList) {
                    mAvailablePlayerList.put(player.getId(), player);
                }
                rootNode.addChildren(playerList);
                mBrowseTree.setCurrentBrowsedFolder(BrowseTree.ROOT);
                rootNode.setExpectedChildren(playerList.size());
                rootNode.setCached(true);
                notifyChanged(rootNode);
            }
            transitionTo(mConnected);
            break;
        case MESSAGE_INTERNAL_CMD_TIMEOUT:
            // We have timed out to execute the request, we should simply send
            // whatever listing we have gotten until now.
            Log.w(TAG, "TIMEOUT");
            transitionTo(mConnected);
            break;
        case MESSAGE_PROCESS_GET_FOLDER_ITEMS_OUT_OF_RANGE:
            // If we have gotten an error for OUT OF RANGE we have
            // already sent all the items to the client hence simply
            // transition to Connected state here.
            mBrowseNode.setCached(true);
            transitionTo(mConnected);
            break;
        case MESSAGE_GET_FOLDER_ITEMS:
            if (!mBrowseNode.equals(msg.obj)) {
                if (mBrowseNode.getScope() == ((BrowseTree.BrowseNode) msg.obj).getScope()) {
                    mAbort = true;
                }
                deferMessage(msg);
                logD("GetFolderItems: Go Get Another Directory");
            } else {
                logD("GetFolderItems: Get The Same Directory, ignore");
            }
            break;
        default:
            logD(STATE_TAG + " deferring message " + msg.what + " to connected!");
            deferMessage(msg);
    }
    return true;
}
#end_block

#method_before
private void fetchContents(BrowseTree.BrowseNode target) {
    int start = target.getChildrenCount();
    int end = Math.min(target.getExpectedChildren(), target.getChildrenCount() + ITEM_PAGE_SIZE) - 1;
    switch(target.getScope()) {
        case AvrcpControllerService.BROWSE_SCOPE_PLAYER_LIST:
            AvrcpControllerService.getPlayerListNative(mDeviceAddress, start, end);
            break;
        case AvrcpControllerService.BROWSE_SCOPE_NOW_PLAYING:
            AvrcpControllerService.getNowPlayingListNative(mDeviceAddress, start, end);
            break;
        case AvrcpControllerService.BROWSE_SCOPE_VFS:
            AvrcpControllerService.getFolderListNative(mDeviceAddress, start, end);
            break;
        default:
            Log.e(STATE_TAG, "Scope " + target.getScope() + " cannot be handled here.");
    }
}
#method_after
private void fetchContents(BrowseTree.BrowseNode target) {
    int start = target.getChildrenCount();
    int end = Math.min(target.getExpectedChildren(), target.getChildrenCount() + ITEM_PAGE_SIZE) - 1;
    switch(target.getScope()) {
        case AvrcpControllerService.BROWSE_SCOPE_PLAYER_LIST:
            AvrcpControllerService.getPlayerListNative(mDeviceAddress, start, end);
            break;
        case AvrcpControllerService.BROWSE_SCOPE_NOW_PLAYING:
            AvrcpControllerService.getNowPlayingListNative(mDeviceAddress, start, end);
            break;
        case AvrcpControllerService.BROWSE_SCOPE_VFS:
            AvrcpControllerService.getFolderListNative(mDeviceAddress, start, end);
            break;
        default:
            Log.e(TAG, STATE_TAG + " Scope " + target.getScope() + " cannot be handled here.");
    }
}
#end_block

#method_before
@Override
public void enter() {
    onBrowsingDisconnected();
    onConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTING);
    transitionTo(mDisconnected);
}
#method_after
@Override
public void enter() {
    onBrowsingDisconnected();
    broadcastConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTING);
    transitionTo(mDisconnected);
}
#end_block

#method_before
@Override
protected boolean stop() {
    return true;
}
#method_after
@Override
protected boolean stop() {
    for (A2dpSinkStateMachine stateMachine : mDeviceStateMap.values()) {
        stateMachine.quitNow();
    }
    sService = null;
    return true;
}
#end_block

#method_before
protected synchronized A2dpSinkStateMachine getStateMachine(BluetoothDevice device) {
    return mInstanceMap.get(device);
}
#method_after
protected synchronized A2dpSinkStateMachine getStateMachine(BluetoothDevice device) {
    return mDeviceStateMap.get(device);
}
#end_block

#method_before
@Override
public boolean isA2dpPlaying(BluetoothDevice device) {
    return false;
}
#method_after
@Override
public boolean isA2dpPlaying(BluetoothDevice device) {
    A2dpSinkService service = getService();
    if (service == null) {
        return false;
    }
    return service.isA2dpPlaying(device);
}
#end_block

#method_before
@Override
public BluetoothAudioConfig getAudioConfig(BluetoothDevice device) {
    return null;
}
#method_after
@Override
public BluetoothAudioConfig getAudioConfig(BluetoothDevice device) {
    A2dpSinkService service = getService();
    if (service == null) {
        return null;
    }
    return service.getAudioConfig(device);
}
#end_block

#method_before
public synchronized boolean disconnect(BluetoothDevice device) {
    if (DBG) {
        StringBuilder sb = new StringBuilder();
        dump(sb);
        Log.d(TAG, "A2DP disconnect device: " + device + ", InstanceMap start state: " + sb.toString());
    }
    A2dpSinkStateMachine stateMachine = mInstanceMap.get(device);
    // a state machine instance doesn't exist. maybe it is already gone?
    if (stateMachine == null) {
        return false;
    }
    int connectionState = stateMachine.getState();
    if (connectionState == BluetoothProfile.STATE_DISCONNECTED || connectionState == BluetoothProfile.STATE_DISCONNECTING) {
        return false;
    }
    stateMachine.disconnect();
    return true;
}
#method_after
public synchronized boolean disconnect(BluetoothDevice device) {
    if (DBG) {
        StringBuilder sb = new StringBuilder();
        dump(sb);
        Log.d(TAG, "A2DP disconnect device: " + device + ", InstanceMap start state: " + sb.toString());
    }
    A2dpSinkStateMachine stateMachine = mDeviceStateMap.get(device);
    // a state machine instance doesn't exist. maybe it is already gone?
    if (stateMachine == null) {
        return false;
    }
    int connectionState = stateMachine.getState();
    if (connectionState == BluetoothProfile.STATE_DISCONNECTED || connectionState == BluetoothProfile.STATE_DISCONNECTING) {
        return false;
    }
    // upon completion of disconnect, the state machine will remove itself from the available
    // devices map
    stateMachine.disconnect();
    return true;
}
#end_block

#method_before
void removeStateMachine(A2dpSinkStateMachine stateMachine) {
    mInstanceMap.remove(stateMachine.getDevice());
}
#method_after
void removeStateMachine(A2dpSinkStateMachine stateMachine) {
    mDeviceStateMap.remove(stateMachine.getDevice());
}
#end_block

#method_before
protected A2dpSinkStateMachine getOrCreateStateMachine(BluetoothDevice device) {
    A2dpSinkStateMachine stateMachine = mInstanceMap.get(device);
    if (stateMachine == null) {
        stateMachine = newStateMachine(device);
        mInstanceMap.put(device, stateMachine);
        stateMachine.start();
    }
    return stateMachine;
}
#method_after
protected A2dpSinkStateMachine getOrCreateStateMachine(BluetoothDevice device) {
    A2dpSinkStateMachine stateMachine = mDeviceStateMap.get(device);
    if (stateMachine == null) {
        stateMachine = newStateMachine(device);
        mDeviceStateMap.put(device, stateMachine);
        stateMachine.start();
    }
    return stateMachine;
}
#end_block

#method_before
synchronized int getConnectionState(BluetoothDevice device) {
    A2dpSinkStateMachine stateMachine = mInstanceMap.get(device);
    return (stateMachine == null) ? BluetoothProfile.STATE_DISCONNECTED : stateMachine.getState();
}
#method_after
synchronized int getConnectionState(BluetoothDevice device) {
    A2dpSinkStateMachine stateMachine = mDeviceStateMap.get(device);
    return (stateMachine == null) ? BluetoothProfile.STATE_DISCONNECTED : stateMachine.getState();
}
#end_block

#method_before
@Override
public void dump(StringBuilder sb) {
    super.dump(sb);
    ProfileService.println(sb, "Devices Tracked = " + mInstanceMap.size());
    for (A2dpSinkStateMachine stateMachine : mInstanceMap.values()) {
        ProfileService.println(sb, "==== StateMachine for " + stateMachine.getDevice() + " ====");
        stateMachine.dump(sb);
    }
}
#method_after
@Override
public void dump(StringBuilder sb) {
    super.dump(sb);
    ProfileService.println(sb, "Devices Tracked = " + mDeviceStateMap.size());
    for (A2dpSinkStateMachine stateMachine : mDeviceStateMap.values()) {
        ProfileService.println(sb, "==== StateMachine for " + stateMachine.getDevice() + " ====");
        stateMachine.dump(sb);
    }
}
#end_block

#method_before
private void onAudioStateChanged(byte[] address, int state) {
    StackEvent event = StackEvent.audioStateChanged(getDevice(address), state);
    A2dpSinkStateMachine stateMachine = getOrCreateStateMachine(event.mDevice);
    stateMachine.sendMessage(A2dpSinkStateMachine.STACK_EVENT, event);
    if (state == StackEvent.AUDIO_STATE_STARTED) {
        mA2dpSinkStreamHandler.obtainMessage(A2dpSinkStreamHandler.SRC_STR_START).sendToTarget();
    } else if (state == StackEvent.AUDIO_STATE_STOPPED) {
        mA2dpSinkStreamHandler.obtainMessage(A2dpSinkStreamHandler.SRC_STR_STOP).sendToTarget();
    }
}
#method_after
private void onAudioStateChanged(byte[] address, int state) {
    if (state == StackEvent.AUDIO_STATE_STARTED) {
        mA2dpSinkStreamHandler.obtainMessage(A2dpSinkStreamHandler.SRC_STR_START).sendToTarget();
    } else if (state == StackEvent.AUDIO_STATE_STOPPED) {
        mA2dpSinkStreamHandler.obtainMessage(A2dpSinkStreamHandler.SRC_STR_STOP).sendToTarget();
    }
}
#end_block

#method_before
@Override
protected boolean stop() {
    return true;
}
#method_after
@Override
protected boolean stop() {
    Intent stopIntent = new Intent(this, BluetoothMediaBrowserService.class);
    stopService(stopIntent);
    for (AvrcpControllerStateMachine stateMachine : mDeviceStateMap.values()) {
        stateMachine.quitNow();
    }
    sService = null;
    sBrowseTree = null;
    return true;
}
#end_block

#method_before
/*Java API*/
public synchronized List<MediaItem> getContents(String parentMediaId) {
    Log.d(TAG, "getContents(" + parentMediaId + ")");
    BrowseTree.BrowseNode requestedNode = sBrowseTree.findBrowseNodeByID(parentMediaId);
    if (requestedNode == null) {
        for (AvrcpControllerStateMachine stateMachine : mInstanceMap.values()) {
            requestedNode = stateMachine.findNode(parentMediaId);
            if (requestedNode != null) {
                Log.d(TAG, "Found a node");
                break;
            }
        }
    }
    if (requestedNode == null) {
        Log.d(TAG, "Didn't find a node");
        return null;
    } else {
        if (!requestedNode.isCached()) {
            Log.d(TAG, "node is not cached");
            refreshContents(requestedNode);
        }
        Log.d(TAG, "Returning contents");
        return requestedNode.getContents();
    }
}
#method_after
/*Java API*/
public synchronized List<MediaItem> getContents(String parentMediaId) {
    if (DBG)
        Log.d(TAG, "getContents(" + parentMediaId + ")");
    BrowseTree.BrowseNode requestedNode = sBrowseTree.findBrowseNodeByID(parentMediaId);
    if (requestedNode == null) {
        for (AvrcpControllerStateMachine stateMachine : mDeviceStateMap.values()) {
            requestedNode = stateMachine.findNode(parentMediaId);
            if (requestedNode != null) {
                Log.d(TAG, "Found a node");
                break;
            }
        }
    }
    if (requestedNode == null) {
        if (DBG)
            Log.d(TAG, "Didn't find a node");
        return null;
    } else {
        if (!requestedNode.isCached()) {
            if (DBG)
                Log.d(TAG, "node is not cached");
            refreshContents(requestedNode);
        }
        if (DBG)
            Log.d(TAG, "Returning contents");
        return requestedNode.getContents();
    }
}
#end_block

#method_before
private AvrcpControllerService getService() {
    if (!Utils.checkCaller()) {
        Log.w(TAG, "A2dp call not allowed for non-active user");
        return null;
    }
    if (mService != null) {
        return mService;
    }
    return null;
}
#method_after
private AvrcpControllerService getService() {
    if (!Utils.checkCaller()) {
        Log.w(TAG, "AVRCP call not allowed for non-active user");
        return null;
    }
    if (mService != null) {
        return mService;
    }
    return null;
}
#end_block

#method_before
@Override
public void sendGroupNavigationCmd(BluetoothDevice device, int a, int b) {
    return;
}
#method_after
@Override
public void sendGroupNavigationCmd(BluetoothDevice device, int keyCode, int keyState) {
    Log.w(TAG, "sendGroupNavigationCmd not implemented");
    return;
}
#end_block

#method_before
@Override
public boolean setPlayerApplicationSetting(BluetoothAvrcpPlayerSettings settings) {
    return false;
}
#method_after
@Override
public boolean setPlayerApplicationSetting(BluetoothAvrcpPlayerSettings settings) {
    Log.w(TAG, "setPlayerApplicationSetting not implemented");
    return false;
}
#end_block

#method_before
@Override
public BluetoothAvrcpPlayerSettings getPlayerSettings(BluetoothDevice device) {
    return null;
}
#method_after
@Override
public BluetoothAvrcpPlayerSettings getPlayerSettings(BluetoothDevice device) {
    Log.w(TAG, "getPlayerSettings not implemented");
    return null;
}
#end_block

#method_before
/* JNI API*/
private void handlePassthroughRsp(int id, int keyState, byte[] address) {
    Log.d(TAG, "passthrough response received as: key: " + id + " state: " + keyState + "address:" + address);
}
#method_after
/* JNI API*/
private void handlePassthroughRsp(int id, int keyState, byte[] address) {
    if (DBG) {
        Log.d(TAG, "passthrough response received as: key: " + id + " state: " + keyState + "address:" + address);
    }
}
#end_block

#method_before
private void handleGroupNavigationRsp(int id, int keyState) {
    Log.d(TAG, "group navigation response received as: key: " + id + " state: " + keyState);
}
#method_after
private void handleGroupNavigationRsp(int id, int keyState) {
    if (DBG) {
        Log.d(TAG, "group navigation response received as: key: " + id + " state: " + keyState);
    }
}
#end_block

#method_before
private synchronized void onConnectionStateChanged(boolean rcConnected, boolean brConnected, byte[] address) {
    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);
    Log.d(TAG, "onConnectionStateChanged " + rcConnected + " " + brConnected + device);
    if (device == null) {
        Log.e(TAG, "onConnectionStateChanged Device is null");
        return;
    }
    StackEvent event = StackEvent.connectionStateChanged(rcConnected, brConnected);
    AvrcpControllerStateMachine stateMachine = getOrCreateStateMachine(device);
    if (rcConnected || brConnected) {
        stateMachine.connect(event);
    } else {
        stateMachine.disconnect();
    }
}
#method_after
private synchronized void onConnectionStateChanged(boolean remoteControlConnected, boolean browsingConnected, byte[] address) {
    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);
    if (DBG) {
        Log.d(TAG, "onConnectionStateChanged " + remoteControlConnected + " " + browsingConnected + device);
    }
    if (device == null) {
        Log.e(TAG, "onConnectionStateChanged Device is null");
        return;
    }
    StackEvent event = StackEvent.connectionStateChanged(remoteControlConnected, browsingConnected);
    AvrcpControllerStateMachine stateMachine = getOrCreateStateMachine(device);
    if (remoteControlConnected || browsingConnected) {
        stateMachine.connect(event);
    } else {
        stateMachine.disconnect();
    }
}
#end_block

#method_before
private void getRcFeatures(byte[] address, int features) {
    BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);
    AvrcpControllerStateMachine stateMachine = getStateMachine(device);
    if (stateMachine != null) {
        StackEvent event = StackEvent.rcFeatures(features);
        stateMachine.sendMessage(AvrcpControllerStateMachine.STACK_EVENT, event);
    }
}
#method_after
private void getRcFeatures(byte[] address, int features) {
/* Do Nothing. */
}
#end_block

#method_before
/* Generic Profile Code */
public synchronized boolean disconnect(BluetoothDevice device) {
    if (DBG) {
        StringBuilder sb = new StringBuilder();
        dump(sb);
        Log.d(TAG, "MAP disconnect device: " + device + ", InstanceMap start state: " + sb.toString());
    }
    AvrcpControllerStateMachine stateMachine = mInstanceMap.get(device);
    // a map state machine instance doesn't exist. maybe it is already gone?
    if (stateMachine == null) {
        return false;
    }
    int connectionState = stateMachine.getState();
    if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
        return false;
    }
    stateMachine.disconnect();
    if (DBG) {
        StringBuilder sb = new StringBuilder();
        dump(sb);
        Log.d(TAG, "MAP disconnect device: " + device + ", InstanceMap start state: " + sb.toString());
    }
    return true;
}
#method_after
/* Generic Profile Code */
public synchronized boolean disconnect(BluetoothDevice device) {
    if (DBG) {
        StringBuilder sb = new StringBuilder();
        dump(sb);
        Log.d(TAG, "MAP disconnect device: " + device + ", InstanceMap start state: " + sb.toString());
    }
    AvrcpControllerStateMachine stateMachine = mDeviceStateMap.get(device);
    // a map state machine instance doesn't exist. maybe it is already gone?
    if (stateMachine == null) {
        return false;
    }
    int connectionState = stateMachine.getState();
    if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
        return false;
    }
    stateMachine.disconnect();
    if (DBG) {
        StringBuilder sb = new StringBuilder();
        dump(sb);
        Log.d(TAG, "MAP disconnect device: " + device + ", InstanceMap start state: " + sb.toString());
    }
    return true;
}
#end_block

#method_before
void removeStateMachine(AvrcpControllerStateMachine stateMachine) {
    mInstanceMap.remove(stateMachine.getDevice());
}
#method_after
void removeStateMachine(AvrcpControllerStateMachine stateMachine) {
    mDeviceStateMap.remove(stateMachine.getDevice());
}
#end_block

#method_before
protected AvrcpControllerStateMachine getStateMachine(BluetoothDevice device) {
    return mInstanceMap.get(device);
}
#method_after
protected AvrcpControllerStateMachine getStateMachine(BluetoothDevice device) {
    return mDeviceStateMap.get(device);
}
#end_block

#method_before
protected AvrcpControllerStateMachine getOrCreateStateMachine(BluetoothDevice device) {
    AvrcpControllerStateMachine stateMachine = mInstanceMap.get(device);
    if (stateMachine == null) {
        stateMachine = newStateMachine(device);
        mInstanceMap.put(device, stateMachine);
        stateMachine.start();
    }
    return stateMachine;
}
#method_after
protected AvrcpControllerStateMachine getOrCreateStateMachine(BluetoothDevice device) {
    AvrcpControllerStateMachine stateMachine = mDeviceStateMap.get(device);
    if (stateMachine == null) {
        stateMachine = newStateMachine(device);
        mDeviceStateMap.put(device, stateMachine);
        stateMachine.start();
    }
    return stateMachine;
}
#end_block

#method_before
synchronized int getConnectionState(BluetoothDevice device) {
    AvrcpControllerStateMachine stateMachine = mInstanceMap.get(device);
    return (stateMachine == null) ? BluetoothProfile.STATE_DISCONNECTED : stateMachine.getState();
}
#method_after
synchronized int getConnectionState(BluetoothDevice device) {
    AvrcpControllerStateMachine stateMachine = mDeviceStateMap.get(device);
    return (stateMachine == null) ? BluetoothProfile.STATE_DISCONNECTED : stateMachine.getState();
}
#end_block

#method_before
@Override
public void dump(StringBuilder sb) {
    super.dump(sb);
    ProfileService.println(sb, "Devices Tracked = " + mInstanceMap.size());
    for (AvrcpControllerStateMachine stateMachine : mInstanceMap.values()) {
        ProfileService.println(sb, "==== StateMachine for " + stateMachine.getDevice() + " ====");
        stateMachine.dump(sb);
    }
    sb.append("\n  sBrowseTree: " + sBrowseTree.toString());
}
#method_after
@Override
public void dump(StringBuilder sb) {
    super.dump(sb);
    ProfileService.println(sb, "Devices Tracked = " + mDeviceStateMap.size());
    for (AvrcpControllerStateMachine stateMachine : mDeviceStateMap.values()) {
        ProfileService.println(sb, "==== StateMachine for " + stateMachine.getDevice() + " ====");
        stateMachine.dump(sb);
    }
    sb.append("\n  sBrowseTree: " + sBrowseTree.toString());
}
#end_block

#method_before
synchronized void removeChild(BrowseNode node) {
    mChildren.remove(node);
    mBrowseMap.remove(node);
}
#method_after
synchronized void removeChild(BrowseNode node) {
    mChildren.remove(node);
    mBrowseMap.remove(node.getID());
}
#end_block

#method_before
public synchronized void updateCurrentTrack(MediaMetadata update) {
    long trackNumber = update.getLong(MediaMetadata.METADATA_KEY_TRACK_NUMBER);
    mPlaybackState = new PlaybackState.Builder(mPlaybackState).setActiveQueueItemId(trackNumber - 1).build();
    mCurrentTrack = update;
}
#method_after
public synchronized void updateCurrentTrack(MediaMetadata update) {
    if (update != null) {
        long trackNumber = update.getLong(MediaMetadata.METADATA_KEY_TRACK_NUMBER);
        mPlaybackState = new PlaybackState.Builder(mPlaybackState).setActiveQueueItemId(trackNumber - 1).build();
    }
    mCurrentTrack = update;
}
#end_block

#method_before
@Override
public void onCreate() {
    if (DBG)
        Log.d(TAG, "onCreate");
    super.onCreate();
    mSession = new MediaSession(this, TAG);
    setSessionToken(mSession.getSessionToken());
    mSession.setFlags(MediaSession.FLAG_HANDLES_MEDIA_BUTTONS | MediaSession.FLAG_HANDLES_TRANSPORT_CONTROLS);
    mSession.setActive(true);
    mSession.setQueueTitle(getString(R.string.bluetooth_a2dp_sink_queue_name));
    mSession.setQueue(mMediaQueue);
    sBluetoothMediaBrowserService = this;
}
#method_after
@Override
public void onCreate() {
    if (DBG)
        Log.d(TAG, "onCreate");
    super.onCreate();
    // Create and configure the MediaSession
    mSession = new MediaSession(this, TAG);
    setSessionToken(mSession.getSessionToken());
    mSession.setFlags(MediaSession.FLAG_HANDLES_MEDIA_BUTTONS | MediaSession.FLAG_HANDLES_TRANSPORT_CONTROLS);
    mSession.setQueueTitle(getString(R.string.bluetooth_a2dp_sink_queue_name));
    mSession.setQueue(mMediaQueue);
    sBluetoothMediaBrowserService = this;
}
#end_block

#method_before
@Override
public synchronized void onLoadChildren(final String parentMediaId, final Result<List<MediaItem>> result) {
    if (DBG)
        Log.d(TAG, "onLoadChildren parentMediaId=" + parentMediaId);
    List<MediaItem> contents = getContents(parentMediaId);
    if (contents == null) {
        mParentIdToRequestMap.put(parentMediaId, result);
        result.detach();
    } else {
        result.sendResult(contents);
    }
}
#method_after
@Override
public synchronized void onLoadChildren(final String parentMediaId, final Result<List<MediaItem>> result) {
    if (DBG)
        Log.d(TAG, "onLoadChildren parentMediaId=" + parentMediaId);
    List<MediaItem> contents = getContents(parentMediaId);
    if (contents == null) {
        result.detach();
    } else {
        result.sendResult(contents);
    }
}
#end_block

#method_before
static synchronized void addressedPlayerChanged(MediaSession.Callback callback) {
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.setCallback(callback);
    } else {
        Log.w(TAG, "Unavailable");
    }
}
#method_after
static synchronized void addressedPlayerChanged(MediaSession.Callback callback) {
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.setCallback(callback);
    } else {
        Log.w(TAG, "addressedPlayerChanged Unavailable");
    }
}
#end_block

#method_before
static synchronized void trackChanged(MediaMetadata mediaMetadata) {
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.setMetadata(mediaMetadata);
    } else {
        Log.w(TAG, "Unavailable");
    }
}
#method_after
static synchronized void trackChanged(MediaMetadata mediaMetadata) {
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.setMetadata(mediaMetadata);
    } else {
        Log.w(TAG, "trackChanged Unavailable");
    }
}
#end_block

#method_before
static synchronized void notifyChanged(PlaybackState playbackState) {
    Log.d(TAG, "notifyChanged PlaybackState" + playbackState);
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.setPlaybackState(playbackState);
    } else {
        Log.w(TAG, "Unavailable");
    }
}
#method_after
static synchronized void notifyChanged(PlaybackState playbackState) {
    Log.d(TAG, "notifyChanged PlaybackState" + playbackState);
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.setPlaybackState(playbackState);
    } else {
        Log.w(TAG, "notifyChanged Unavailable");
    }
}
#end_block

#method_before
public static synchronized void play() {
    if (sBluetoothMediaBrowserService != null) {
        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_MEDIA_PLAY);
        sBluetoothMediaBrowserService.mSession.getController().dispatchMediaButtonEvent(event);
    } else {
        Log.w(TAG, "Unavailable");
    }
}
#method_after
public static synchronized void play() {
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.getController().getTransportControls().play();
    } else {
        Log.w(TAG, "play Unavailable");
    }
}
#end_block

#method_before
public static synchronized void pause() {
    if (sBluetoothMediaBrowserService != null) {
        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_MEDIA_PAUSE);
        sBluetoothMediaBrowserService.mSession.getController().dispatchMediaButtonEvent(event);
    } else {
        Log.w(TAG, "Unavailable");
    }
}
#method_after
public static synchronized void pause() {
    if (sBluetoothMediaBrowserService != null) {
        sBluetoothMediaBrowserService.mSession.getController().getTransportControls().pause();
    } else {
        Log.w(TAG, "pause Unavailable");
    }
}
#end_block

#method_before
@Override
public void enter() {
    logd("Enter Disconnected");
    if (mMostRecentState != BluetoothProfile.STATE_DISCONNECTED) {
        sendMessage(CLEANUP);
    }
    onConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTED);
}
#method_after
@Override
public void enter() {
    if (DBG)
        Log.d(TAG, "Enter Disconnected");
    if (mMostRecentState != BluetoothProfile.STATE_DISCONNECTED) {
        sendMessage(CLEANUP);
    }
    onConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTED);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case STACK_EVENT:
            processStackEvent((StackEvent) message.obj);
            return true;
        case CONNECT:
            logd("Connect");
            transitionTo(mConnecting);
            return true;
        case CLEANUP:
            mService.removeStateMachine(A2dpSinkStateMachine.this);
            return true;
    }
    return false;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case STACK_EVENT:
            processStackEvent((StackEvent) message.obj);
            return true;
        case CONNECT:
            if (DBG)
                Log.d(TAG, "Connect");
            transitionTo(mConnecting);
            return true;
        case CLEANUP:
            mService.removeStateMachine(A2dpSinkStateMachine.this);
            return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void enter() {
    logd("Enter Connecting");
    onConnectionStateChanged(BluetoothProfile.STATE_CONNECTING);
    sendMessageDelayed(CONNECT_TIMEOUT, CONNECT_TIMEOUT_MS);
    if (!mIncommingConnection) {
        mService.connectA2dpNative(mDeviceAddress);
    }
    super.enter();
}
#method_after
@Override
public void enter() {
    if (DBG)
        Log.d(TAG, "Enter Connecting");
    onConnectionStateChanged(BluetoothProfile.STATE_CONNECTING);
    sendMessageDelayed(CONNECT_TIMEOUT, CONNECT_TIMEOUT_MS);
    if (!mIncommingConnection) {
        mService.connectA2dpNative(mDeviceAddress);
    }
    super.enter();
}
#end_block

#method_before
@Override
public void enter() {
    logd("Enter Connected");
    onConnectionStateChanged(BluetoothProfile.STATE_CONNECTED);
}
#method_after
@Override
public void enter() {
    if (DBG)
        Log.d(TAG, "Enter Connected");
    onConnectionStateChanged(BluetoothProfile.STATE_CONNECTED);
}
#end_block

#method_before
void processStackEvent(StackEvent event) {
    switch(event.mType) {
        case StackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
            switch(event.mState) {
                case StackEvent.CONNECTION_STATE_DISCONNECTING:
                    transitionTo(mDisconnecting);
                    break;
                case StackEvent.CONNECTION_STATE_DISCONNECTED:
                    transitionTo(mDisconnected);
                    break;
            }
    }
}
#method_after
void processStackEvent(StackEvent event) {
    switch(event.mType) {
        case StackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
            switch(event.mState) {
                case StackEvent.CONNECTION_STATE_DISCONNECTING:
                    transitionTo(mDisconnecting);
                    break;
                case StackEvent.CONNECTION_STATE_DISCONNECTED:
                    transitionTo(mDisconnected);
                    break;
            }
            break;
        case StackEvent.EVENT_TYPE_AUDIO_CONFIG_CHANGED:
            mAudioConfig = new BluetoothAudioConfig(event.mSampleRate, event.mChannelCount, AudioFormat.ENCODING_PCM_16BIT);
            break;
    }
}
#end_block

#method_before
@Override
public void enter() {
    logd("Enter Disconnecting");
    onConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTING);
    transitionTo(mDisconnected);
}
#method_after
@Override
public void enter() {
    if (DBG)
        Log.d(TAG, "Enter Disconnecting");
    onConnectionStateChanged(BluetoothProfile.STATE_DISCONNECTING);
    transitionTo(mDisconnected);
}
#end_block

#method_before
protected void onConnectionStateChanged(int currentState) {
    if (mMostRecentState == currentState) {
        return;
    }
    if (currentState == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.A2DP_SINK);
    }
    logd("Connection state " + mDevice + ": " + mMostRecentState + "->" + currentState);
    Intent intent = new Intent(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, mMostRecentState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, currentState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mMostRecentState = currentState;
    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#method_after
protected void onConnectionStateChanged(int currentState) {
    if (mMostRecentState == currentState) {
        return;
    }
    if (currentState == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.A2DP_SINK);
    }
    if (DBG) {
        Log.d(TAG, "Connection state " + mDevice + ": " + mMostRecentState + "->" + currentState);
    }
    Intent intent = new Intent(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, mMostRecentState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, currentState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mMostRecentState = currentState;
    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#end_block

#method_before
@MainThread
public void onInitializeTasks() {
    // Reschedule all eligible work, as all tasks have been cleared in GCMNetworkManager.
    // This typically happens after an upgrade.
    mWorkManager.getWorkTaskExecutor().executeOnBackgroundThread(new Runnable() {

        @Override
        public void run() {
            Logger.get().debug(TAG, "onInitializeTasks(): Rescheduling work");
            mWorkManager.rescheduleEligibleWork();
        }
    });
}
#method_after
@MainThread
public void onInitializeTasks() {
    // Reschedule all eligible work, as all tasks have been cleared in GCMNetworkManager.
    // This typically happens after an upgrade.
    mWorkManagerImpl.getWorkTaskExecutor().executeOnBackgroundThread(new Runnable() {

        @Override
        public void run() {
            Logger.get().debug(TAG, "onInitializeTasks(): Rescheduling work");
            mWorkManagerImpl.rescheduleEligibleWork();
        }
    });
}
#end_block

#method_before
public int onRunTask(@NonNull TaskParams taskParams) {
    // Tasks may be executed concurrently but every Task will be executed in a unique thread
    // per tag, which in our case is a workSpecId. Therefore its safe to block here with
    // a latch because there is 1 thread per workSpecId.
    Logger.get().debug(TAG, String.format("Handling task %s", taskParams));
    String workSpecId = taskParams.getTag();
    if (workSpecId == null || workSpecId.isEmpty()) {
        // Bad request. No WorkSpec id.
        Logger.get().debug(TAG, "Bad request. No workSpecId.");
        return GcmNetworkManager.RESULT_FAILURE;
    }
    WorkSpecExecutionListener listener = new WorkSpecExecutionListener(workSpecId);
    Processor processor = mWorkManager.getProcessor();
    processor.addExecutionListener(listener);
    mWorkManager.startWork(workSpecId);
    try {
        listener.getLatch().await(AWAIT_TIME_IN_MINUTES, TimeUnit.MINUTES);
    } catch (InterruptedException exception) {
        Logger.get().debug(TAG, String.format("Rescheduling WorkSpec %s", workSpecId));
        return reschedule(workSpecId);
    } finally {
        processor.removeExecutionListener(listener);
    }
    if (listener.needsReschedule()) {
        Logger.get().debug(TAG, String.format("Rescheduling WorkSpec %s", workSpecId));
        return reschedule(workSpecId);
    }
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    WorkSpec workSpec = workDatabase.workSpecDao().getWorkSpec(workSpecId);
    WorkInfo.State state = workSpec != null ? workSpec.state : null;
    if (state == null) {
        Logger.get().debug(TAG, String.format("WorkSpec %s does not exist", workSpecId));
        return GcmNetworkManager.RESULT_FAILURE;
    } else {
        switch(state) {
            case SUCCEEDED:
            case CANCELLED:
                Logger.get().debug(TAG, String.format("Returning RESULT_SUCCESS for WorkSpec %s", workSpecId));
                return GcmNetworkManager.RESULT_SUCCESS;
            case FAILED:
                Logger.get().debug(TAG, String.format("Returning RESULT_FAILURE for WorkSpec %s", workSpecId));
                return GcmNetworkManager.RESULT_FAILURE;
            default:
                Logger.get().debug(TAG, "Rescheduling eligible work.");
                return reschedule(workSpecId);
        }
    }
}
#method_after
public int onRunTask(@NonNull TaskParams taskParams) {
    // Tasks may be executed concurrently but every Task will be executed in a unique thread
    // per tag, which in our case is a workSpecId. Therefore its safe to block here with
    // a latch because there is 1 thread per workSpecId.
    Logger.get().debug(TAG, String.format("Handling task %s", taskParams));
    String workSpecId = taskParams.getTag();
    if (workSpecId == null || workSpecId.isEmpty()) {
        // Bad request. No WorkSpec id.
        Logger.get().debug(TAG, "Bad request. No workSpecId.");
        return GcmNetworkManager.RESULT_FAILURE;
    }
    WorkSpecExecutionListener listener = new WorkSpecExecutionListener(workSpecId);
    Processor processor = mWorkManagerImpl.getProcessor();
    processor.addExecutionListener(listener);
    mWorkManagerImpl.startWork(workSpecId);
    try {
        listener.getLatch().await(AWAIT_TIME_IN_MINUTES, TimeUnit.MINUTES);
    } catch (InterruptedException exception) {
        Logger.get().debug(TAG, String.format("Rescheduling WorkSpec %s", workSpecId));
        return reschedule(workSpecId);
    } finally {
        processor.removeExecutionListener(listener);
    }
    if (listener.needsReschedule()) {
        Logger.get().debug(TAG, String.format("Rescheduling WorkSpec %s", workSpecId));
        return reschedule(workSpecId);
    }
    WorkDatabase workDatabase = mWorkManagerImpl.getWorkDatabase();
    WorkSpec workSpec = workDatabase.workSpecDao().getWorkSpec(workSpecId);
    WorkInfo.State state = workSpec != null ? workSpec.state : null;
    if (state == null) {
        Logger.get().debug(TAG, String.format("WorkSpec %s does not exist", workSpecId));
        return GcmNetworkManager.RESULT_FAILURE;
    } else {
        switch(state) {
            case SUCCEEDED:
            case CANCELLED:
                Logger.get().debug(TAG, String.format("Returning RESULT_SUCCESS for WorkSpec %s", workSpecId));
                return GcmNetworkManager.RESULT_SUCCESS;
            case FAILED:
                Logger.get().debug(TAG, String.format("Returning RESULT_FAILURE for WorkSpec %s", workSpecId));
                return GcmNetworkManager.RESULT_FAILURE;
            default:
                Logger.get().debug(TAG, "Rescheduling eligible work.");
                return reschedule(workSpecId);
        }
    }
}
#end_block

#method_before
private int reschedule(@NonNull String workSpecId) {
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    try {
        workDatabase.beginTransaction();
        // Mark the workSpec as unscheduled. We are doing this explicitly here because
        // there are many cases where WorkerWrapper may not have had a chance to update this
        // flag. For e.g. this will happen if the Worker took longer than 10 minutes.
        workDatabase.workSpecDao().markWorkSpecScheduled(workSpecId, WorkSpec.SCHEDULE_NOT_REQUESTED_YET);
        // We reschedule on our own to apply our own backoff policy.
        Schedulers.schedule(mWorkManager.getConfiguration(), mWorkManager.getWorkDatabase(), mWorkManager.getSchedulers());
        workDatabase.setTransactionSuccessful();
    } finally {
        workDatabase.endTransaction();
    }
    Logger.get().debug(TAG, String.format("Returning RESULT_SUCCESS for WorkSpec %s", workSpecId));
    return GcmNetworkManager.RESULT_SUCCESS;
}
#method_after
private int reschedule(@NonNull String workSpecId) {
    WorkDatabase workDatabase = mWorkManagerImpl.getWorkDatabase();
    try {
        workDatabase.beginTransaction();
        // Mark the workSpec as unscheduled. We are doing this explicitly here because
        // there are many cases where WorkerWrapper may not have had a chance to update this
        // flag. For e.g. this will happen if the Worker took longer than 10 minutes.
        workDatabase.workSpecDao().markWorkSpecScheduled(workSpecId, WorkSpec.SCHEDULE_NOT_REQUESTED_YET);
        // We reschedule on our own to apply our own backoff policy.
        Schedulers.schedule(mWorkManagerImpl.getConfiguration(), mWorkManagerImpl.getWorkDatabase(), mWorkManagerImpl.getSchedulers());
        workDatabase.setTransactionSuccessful();
    } finally {
        workDatabase.endTransaction();
    }
    Logger.get().debug(TAG, String.format("Returning RESULT_SUCCESS for WorkSpec %s", workSpecId));
    return GcmNetworkManager.RESULT_SUCCESS;
}
#end_block

#method_before
public void handleMessage(Message msg) {
    AsyncResult ar;
    Integer phoneId = getCiIndex(msg);
    if (mDestroyed.get()) {
        Rlog.e(LOG_TAG, "Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    loge("IsimUiccRecords: handleMessage " + msg + "[" + msg.what + "] ");
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_REFRESH:
                broadcastRefresh(phoneId);
                super.handleMessage(msg);
                break;
            case EVENT_ISIM_AUTHENTICATE_DONE:
                ar = (AsyncResult) msg.obj;
                log("EVENT_ISIM_AUTHENTICATE_DONE");
                if (ar.exception != null) {
                    log("Exception ISIM AKA: " + ar.exception);
                } else {
                    try {
                        auth_rsp = (String) ar.result;
                        log("ISIM AKA: auth_rsp = " + auth_rsp);
                    } catch (Exception e) {
                        log("Failed to parse ISIM AKA contents: " + e);
                    }
                }
                synchronized (mLock) {
                    mLock.notifyAll();
                }
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing SIM record", exc);
    }
}
#method_after
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (mDestroyed.get()) {
        Rlog.e(LOG_TAG, "Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    loge("IsimUiccRecords: handleMessage " + msg + "[" + msg.what + "] ");
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_REFRESH:
                broadcastRefresh();
                super.handleMessage(msg);
                break;
            case EVENT_ISIM_AUTHENTICATE_DONE:
                ar = (AsyncResult) msg.obj;
                log("EVENT_ISIM_AUTHENTICATE_DONE");
                if (ar.exception != null) {
                    log("Exception ISIM AKA: " + ar.exception);
                } else {
                    try {
                        auth_rsp = (String) ar.result;
                        log("ISIM AKA: auth_rsp = " + auth_rsp);
                    } catch (Exception e) {
                        log("Failed to parse ISIM AKA contents: " + e);
                    }
                }
                synchronized (mLock) {
                    mLock.notifyAll();
                }
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing SIM record", exc);
    }
}
#end_block

#method_before
private void broadcastRefresh(Integer index) {
    Intent intent = new Intent(INTENT_ISIM_REFRESH);
    log("send ISim REFRESH: " + INTENT_ISIM_REFRESH);
    intent.putExtra("PHONE_ID", index);
    mContext.sendBroadcast(intent);
}
#method_after
private void broadcastRefresh() {
    Intent intent = new Intent(INTENT_ISIM_REFRESH);
    log("send ISim REFRESH: " + INTENT_ISIM_REFRESH);
    intent.putExtra("PHONE_ID", mParentApp.getPhoneId());
    mContext.sendBroadcast(intent);
}
#end_block

#method_before
@Override
public boolean run() throws TimeoutException, IOException {
    if (mPipeAsInput != null) {
        mResult = getRunUtil().runTimedCmdWithInputRedirect(mTimeout, mPipeAsInput, mCmd);
    } else {
        mResult = getRunUtil().runTimedCmd(mTimeout, mCmd);
    }
    if (mResult.getStatus() == CommandStatus.EXCEPTION) {
        throw new IOException(mResult.getStderr());
    } else if (mResult.getStatus() == CommandStatus.TIMED_OUT) {
        throw new TimeoutException(mResult.getStderr());
    }
    // which will contain all the infos.
    return true;
}
#method_after
@Override
public boolean run() throws TimeoutException, IOException {
    if (mPipeAsInput != null) {
        mResult = getRunUtil().runTimedCmdWithInputRedirect(mTimeout, mPipeAsInput, mCmd);
    } else {
        mResult = getRunUtil().runTimedCmd(mTimeout, mPipeToOutput, /* stderr= */
        null, mCmd);
    }
    if (mResult.getStatus() == CommandStatus.EXCEPTION) {
        throw new IOException(mResult.getStderr());
    } else if (mResult.getStatus() == CommandStatus.TIMED_OUT) {
        throw new TimeoutException(mResult.getStderr());
    }
    // which will contain all the infos.
    return true;
}
#end_block

#method_before
@Override
public CommandResult executeShellV2Command(String cmd, File pipeAsInput) throws DeviceNotAvailableException {
    return executeShellV2Command(cmd, pipeAsInput, getCommandTimeout(), TimeUnit.MILLISECONDS, MAX_RETRY_ATTEMPTS);
}
#method_after
@Override
public CommandResult executeShellV2Command(String cmd, File pipeAsInput) throws DeviceNotAvailableException {
    return executeShellV2Command(cmd, pipeAsInput, null, getCommandTimeout(), TimeUnit.MILLISECONDS, MAX_RETRY_ATTEMPTS);
}
#end_block

#method_before
private CommandResult executeShellV2Command(String cmd, File pipeAsInput, final long maxTimeoutForCommand, final TimeUnit timeUnit, int retryAttempts) throws DeviceNotAvailableException {
    final String[] fullCmd = buildAdbShellCommand(cmd);
    AdbShellAction adbActionV2 = new AdbShellAction(fullCmd, pipeAsInput, timeUnit.toMillis(maxTimeoutForCommand));
    performDeviceAction(String.format("adb %s", fullCmd[4]), adbActionV2, retryAttempts);
    return adbActionV2.mResult;
}
#method_after
@Override
public CommandResult executeShellV2Command(String cmd, OutputStream pipeToOutput) throws DeviceNotAvailableException {
    return executeShellV2Command(cmd, null, pipeToOutput, getCommandTimeout(), TimeUnit.MILLISECONDS, MAX_RETRY_ATTEMPTS);
}
#end_block

#method_before
@Override
public CommandResult executeShellV2Command(String cmd, final long maxTimeoutForCommand, final TimeUnit timeUnit) throws DeviceNotAvailableException {
    return executeShellV2Command(cmd, null, maxTimeoutForCommand, timeUnit, MAX_RETRY_ATTEMPTS);
}
#method_after
@Override
public CommandResult executeShellV2Command(String cmd, final long maxTimeoutForCommand, final TimeUnit timeUnit) throws DeviceNotAvailableException {
    return executeShellV2Command(cmd, null, null, maxTimeoutForCommand, timeUnit, MAX_RETRY_ATTEMPTS);
}
#end_block

#method_before
@Override
public CommandResult executeShellV2Command(String cmd, final long maxTimeoutForCommand, final TimeUnit timeUnit, int retryAttempts) throws DeviceNotAvailableException {
    return executeShellV2Command(cmd, null, maxTimeoutForCommand, timeUnit, retryAttempts);
}
#method_after
@Override
public CommandResult executeShellV2Command(String cmd, final long maxTimeoutForCommand, final TimeUnit timeUnit, int retryAttempts) throws DeviceNotAvailableException {
    return executeShellV2Command(cmd, null, null, maxTimeoutForCommand, timeUnit, retryAttempts);
}
#end_block

#method_before
@Override
public boolean pullFile(final String remoteFilePath, final File localFile) throws DeviceNotAvailableException {
    DeviceAction pullAction = new DeviceAction() {

        @Override
        public boolean run() throws TimeoutException, IOException, AdbCommandRejectedException, SyncException {
            SyncService syncService = null;
            boolean status = false;
            try {
                syncService = getIDevice().getSyncService();
                syncService.pullFile(interpolatePathVariables(remoteFilePath), localFile.getAbsolutePath(), SyncService.getNullProgressMonitor());
                status = true;
            } catch (SyncException e) {
                CLog.w("Failed to pull %s from %s to %s. Message %s", remoteFilePath, getSerialNumber(), localFile.getAbsolutePath(), e.getMessage());
                throw e;
            } finally {
                if (syncService != null) {
                    syncService.close();
                }
            }
            return status;
        }
    };
    return performDeviceAction(String.format("pull %s to %s", remoteFilePath, localFile.getAbsolutePath()), pullAction, MAX_RETRY_ATTEMPTS);
}
#method_after
@Override
public boolean pullFile(final String remoteFilePath, final File localFile) throws DeviceNotAvailableException {
    if (remoteFilePath.startsWith(SD_CARD)) {
        ContentProviderHandler handler = getContentProvider();
        if (handler != null) {
            return handler.pullFile(remoteFilePath, localFile);
        }
    }
    DeviceAction pullAction = new DeviceAction() {

        @Override
        public boolean run() throws TimeoutException, IOException, AdbCommandRejectedException, SyncException {
            SyncService syncService = null;
            boolean status = false;
            try {
                syncService = getIDevice().getSyncService();
                syncService.pullFile(interpolatePathVariables(remoteFilePath), localFile.getAbsolutePath(), SyncService.getNullProgressMonitor());
                status = true;
            } catch (SyncException e) {
                CLog.w("Failed to pull %s from %s to %s. Message %s", remoteFilePath, getSerialNumber(), localFile.getAbsolutePath(), e.getMessage());
                throw e;
            } finally {
                if (syncService != null) {
                    syncService.close();
                }
            }
            return status;
        }
    };
    return performDeviceAction(String.format("pull %s to %s", remoteFilePath, localFile.getAbsolutePath()), pullAction, MAX_RETRY_ATTEMPTS);
}
#end_block

#method_before
@Override
public boolean pushFile(final File localFile, final String remoteFilePath) throws DeviceNotAvailableException {
    if (remoteFilePath.startsWith(SD_CARD)) {
        ContentProviderHandler handler = getContentProvider();
        if (handler != null) {
            mShouldSkipContentProviderSetup = true;
            return handler.pushFile(localFile, remoteFilePath);
        }
    }
    DeviceAction pushAction = new DeviceAction() {

        @Override
        public boolean run() throws TimeoutException, IOException, AdbCommandRejectedException, SyncException {
            SyncService syncService = null;
            boolean status = false;
            try {
                syncService = getIDevice().getSyncService();
                if (syncService == null) {
                    throw new IOException("SyncService returned null.");
                }
                syncService.pushFile(localFile.getAbsolutePath(), interpolatePathVariables(remoteFilePath), SyncService.getNullProgressMonitor());
                status = true;
            } catch (SyncException e) {
                CLog.w("Failed to push %s to %s on device %s. Message: '%s'. " + "Error code: %s", localFile.getAbsolutePath(), remoteFilePath, getSerialNumber(), e.getMessage(), e.getErrorCode());
                // TODO: check if ddmlib can report a better error
                if (SyncError.TRANSFER_PROTOCOL_ERROR.equals(e.getErrorCode())) {
                    if (e.getMessage().contains("Permission denied")) {
                        return false;
                    }
                }
                throw e;
            } finally {
                if (syncService != null) {
                    syncService.close();
                }
            }
            return status;
        }
    };
    return performDeviceAction(String.format("push %s to %s", localFile.getAbsolutePath(), remoteFilePath), pushAction, MAX_RETRY_ATTEMPTS);
}
#method_after
@Override
public boolean pushFile(final File localFile, final String remoteFilePath) throws DeviceNotAvailableException {
    if (remoteFilePath.startsWith(SD_CARD)) {
        ContentProviderHandler handler = getContentProvider();
        if (handler != null) {
            return handler.pushFile(localFile, remoteFilePath);
        }
    }
    DeviceAction pushAction = new DeviceAction() {

        @Override
        public boolean run() throws TimeoutException, IOException, AdbCommandRejectedException, SyncException {
            SyncService syncService = null;
            boolean status = false;
            try {
                syncService = getIDevice().getSyncService();
                if (syncService == null) {
                    throw new IOException("SyncService returned null.");
                }
                syncService.pushFile(localFile.getAbsolutePath(), interpolatePathVariables(remoteFilePath), SyncService.getNullProgressMonitor());
                status = true;
            } catch (SyncException e) {
                CLog.w("Failed to push %s to %s on device %s. Message: '%s'. " + "Error code: %s", localFile.getAbsolutePath(), remoteFilePath, getSerialNumber(), e.getMessage(), e.getErrorCode());
                // TODO: check if ddmlib can report a better error
                if (SyncError.TRANSFER_PROTOCOL_ERROR.equals(e.getErrorCode())) {
                    if (e.getMessage().contains("Permission denied")) {
                        return false;
                    }
                }
                throw e;
            } finally {
                if (syncService != null) {
                    syncService.close();
                }
            }
            return status;
        }
    };
    return performDeviceAction(String.format("push %s to %s", localFile.getAbsolutePath(), remoteFilePath), pushAction, MAX_RETRY_ATTEMPTS);
}
#end_block

#method_before
@Override
public void deleteFile(String deviceFilePath) throws DeviceNotAvailableException {
    if (deviceFilePath.startsWith(SD_CARD)) {
        ContentProviderHandler handler = getContentProvider();
        if (handler != null) {
            mShouldSkipContentProviderSetup = true;
            if (handler.deleteFile(deviceFilePath)) {
                return;
            }
        }
    }
    // Fallback to the direct command if content provider is unsuccessful
    executeShellCommand(String.format("rm -rf \"%s\"", deviceFilePath));
}
#method_after
@Override
public void deleteFile(String deviceFilePath) throws DeviceNotAvailableException {
    if (deviceFilePath.startsWith(SD_CARD)) {
        ContentProviderHandler handler = getContentProvider();
        if (handler != null) {
            if (handler.deleteFile(deviceFilePath)) {
                return;
            }
        }
    }
    // Fallback to the direct command if content provider is unsuccessful
    executeShellCommand(String.format("rm -rf \"%s\"", deviceFilePath));
}
#end_block

#method_before
@VisibleForTesting
void doReboot() throws DeviceNotAvailableException, UnsupportedOperationException {
    if (TestDeviceState.FASTBOOT == getDeviceState()) {
        CLog.i("device %s in fastboot. Rebooting to userspace.", getSerialNumber());
        executeFastbootCommand("reboot");
    } else {
        if (mOptions.shouldDisableReboot()) {
            CLog.i("Device reboot disabled by options, skipped.");
            return;
        }
        CLog.i("Rebooting device %s", getSerialNumber());
        doAdbReboot(null);
        // Check if device shows as unavailable (as expected after reboot).
        boolean notAvailable = waitForDeviceNotAvailable(DEFAULT_UNAVAILABLE_TIMEOUT);
        if (notAvailable) {
            postAdbReboot();
        } else {
            CLog.w("Did not detect device %s becoming unavailable after reboot", getSerialNumber());
        }
    }
}
#method_after
@VisibleForTesting
void doReboot() throws DeviceNotAvailableException, UnsupportedOperationException {
    // Track Tradefed reboot time
    mLastTradefedRebootTime = System.currentTimeMillis();
    if (TestDeviceState.FASTBOOT == getDeviceState()) {
        CLog.i("device %s in fastboot. Rebooting to userspace.", getSerialNumber());
        executeFastbootCommand("reboot");
    } else {
        if (mOptions.shouldDisableReboot()) {
            CLog.i("Device reboot disabled by options, skipped.");
            return;
        }
        CLog.i("Rebooting device %s", getSerialNumber());
        doAdbReboot(null);
        // Check if device shows as unavailable (as expected after reboot).
        boolean notAvailable = waitForDeviceNotAvailable(DEFAULT_UNAVAILABLE_TIMEOUT);
        if (notAvailable) {
            postAdbReboot();
        } else {
            CLog.w("Did not detect device %s becoming unavailable after reboot", getSerialNumber());
        }
    }
}
#end_block

#method_before
@VisibleForTesting
ContentProviderHandler getContentProvider() throws DeviceNotAvailableException {
    // Prevent usage of content provider before API 25 as it would not work well.
    if (getApiLevel() < 25) {
        return null;
    }
    if (mContentProvider == null) {
        mContentProvider = new ContentProviderHandler(this);
    }
    if (!mShouldSkipContentProviderSetup) {
        boolean res = mContentProvider.setUp();
        if (!res) {
            return null;
        }
    }
    return mContentProvider;
}
#method_after
@VisibleForTesting
ContentProviderHandler getContentProvider() throws DeviceNotAvailableException {
    // Prevent usage of content provider before API 25 as it would not work well.
    if (getApiLevel() < 25) {
        return null;
    }
    if (mContentProvider == null) {
        mContentProvider = new ContentProviderHandler(this);
    }
    if (!mShouldSkipContentProviderSetup) {
        boolean res = mContentProvider.setUp();
        if (!res) {
            // TODO: once CP becomes a requirement, throw/fail the test if CP can't be found
            return null;
        }
        mShouldSkipContentProviderSetup = true;
    }
    return mContentProvider;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mHandler = new ContentProviderHandler(getDevice());
    assertTrue(mHandler.setUp());
}
#method_after
@Before
public void setUp() throws Exception {
    mHandler = new ContentProviderHandler(getDevice());
    mCurrentUserStoragePath = String.format(EXTERNAL_STORAGE_PATH, getDevice().getCurrentUser());
    assertTrue(mHandler.setUp());
}
#end_block

#method_before
@Test
public void testPushFile() throws Exception {
    File tmpFile = FileUtil.createTempFile("tmpFileToPush", ".txt");
    try {
        String devicePath = "/sdcard/" + tmpFile.getName();
        mToBeDeleted.add(devicePath);
        boolean res = mHandler.pushFile(tmpFile, devicePath);
        assertTrue(res);
        assertTrue(getDevice().doesFileExist(devicePath));
    } finally {
        FileUtil.deleteFile(tmpFile);
    }
}
#method_after
@Test
public void testPushFile() throws Exception {
    File tmpFile = FileUtil.createTempFile("tmpFileToPush", ".txt");
    try {
        String devicePath = "/sdcard/" + tmpFile.getName();
        mToBeDeleted.add(devicePath);
        boolean res = mHandler.pushFile(tmpFile, devicePath);
        assertTrue(res);
        assertTrue(getDevice().doesFileExist(mCurrentUserStoragePath + tmpFile.getName()));
    } finally {
        FileUtil.deleteFile(tmpFile);
    }
}
#end_block

#method_before
@Test
public void testDeleteFile() throws Exception {
    File tmpFile = FileUtil.createTempFile("tmpFileToPush", ".txt");
    try {
        String devicePath = "/sdcard/" + tmpFile.getName();
        // Push the file first
        boolean res = mHandler.pushFile(tmpFile, devicePath);
        assertTrue(res);
        assertTrue(getDevice().doesFileExist(devicePath));
        // Attempt to delete it.
        assertTrue(mHandler.deleteFile(devicePath));
    } finally {
        FileUtil.deleteFile(tmpFile);
    }
}
#method_after
@Test
public void testDeleteFile() throws Exception {
    File tmpFile = FileUtil.createTempFile("tmpFileToPush", ".txt");
    try {
        String devicePath = "/sdcard/" + tmpFile.getName();
        // Push the file first
        boolean res = mHandler.pushFile(tmpFile, devicePath);
        assertTrue(res);
        assertTrue(getDevice().doesFileExist(mCurrentUserStoragePath + tmpFile.getName()));
        // Attempt to delete it.
        assertTrue(mHandler.deleteFile(devicePath));
    } finally {
        FileUtil.deleteFile(tmpFile);
    }
}
#end_block

#method_before
void handleUidChanged(int uid, int procState, long procStateSeq) {
    Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "onUidStateChanged");
    try {
        boolean updated;
        synchronized (mUidRulesFirstLock) {
            // We received a uid state change callback, add it to the history so that it
            // will be useful for debugging.
            mLogger.uidStateChanged(uid, procState, procStateSeq);
            // Now update the network policy rules as per the updated uid state.
            updated = updateUidStateUL(uid, procState);
            // Updating the network rules is done, so notify AMS about this.
            mActivityManagerInternal.notifyNetworkPolicyRulesUpdated(uid, procStateSeq);
        }
        // Do this without the lock held
        if (updated) {
            updateNetworkStats(uid, isUidStateForeground(procState));
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
    }
}
#method_after
void handleUidChanged(int uid, int procState, long procStateSeq) {
    Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "onUidStateChanged");
    try {
        boolean updated;
        synchronized (mUidRulesFirstLock) {
            // We received a uid state change callback, add it to the history so that it
            // will be useful for debugging.
            mLogger.uidStateChanged(uid, procState, procStateSeq);
            // Now update the network policy rules as per the updated uid state.
            updated = updateUidStateUL(uid, procState);
            // Updating the network rules is done, so notify AMS about this.
            mActivityManagerInternal.notifyNetworkPolicyRulesUpdated(uid, procStateSeq);
        }
        // called from the handler, so there's no multi-threading issue.
        if (updated) {
            updateNetworkStats(uid, isUidStateForeground(procState));
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
    }
}
#end_block

#method_before
void handleUidGone(int uid) {
    Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "onUidGone");
    try {
        boolean updated;
        synchronized (mUidRulesFirstLock) {
            updated = removeUidStateUL(uid);
        }
        // Do this without the lock held
        if (updated) {
            updateNetworkStats(uid, false);
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
    }
}
#method_after
void handleUidGone(int uid) {
    Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "onUidGone");
    try {
        boolean updated;
        synchronized (mUidRulesFirstLock) {
            updated = removeUidStateUL(uid);
        }
        // called from the handler, so there's no multi-threading issue.
        if (updated) {
            updateNetworkStats(uid, false);
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
    }
}
#end_block

#method_before
@Override
public NetworkStats getDetailedUidStats(String[] requiredIfaces) {
    try {
        final String[] ifacesToQuery = NetworkStatsFactory.augmentWithStackedInterfaces(requiredIfaces);
        return getNetworkStatsUidDetail(ifacesToQuery);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error compiling UID stats", e);
        return new NetworkStats(0L, 0);
    }
}
#method_after
@Override
public NetworkStats getDetailedUidStats(String[] requiredIfaces) {
    try {
        // Get the latest snapshot from NetworkStatsFactory.
        // TODO: Querying for INTERFACES_ALL may incur performance penalty. Consider restricting
        // this to limited set of ifaces.
        NetworkStats uidDetailStats = getNetworkStatsUidDetail(INTERFACES_ALL);
        // Migrate traffic from VPN UID over delta and update mTunAdjustedStats.
        NetworkStats result;
        synchronized (mStatsLock) {
            migrateTunTraffic(uidDetailStats, mVpnInfos);
            result = mTunAdjustedStats.clone();
        }
        // Apply filter based on ifacesToQuery.
        final String[] ifacesToQuery = NetworkStatsFactory.augmentWithStackedInterfaces(requiredIfaces);
        result.filter(UID_ALL, ifacesToQuery, TAG_ALL);
        return result;
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error compiling UID stats", e);
        return new NetworkStats(0L, 0);
    }
}
#end_block

#method_before
@GuardedBy("mStatsLock")
private void recordSnapshotLocked(long currentTime) throws RemoteException {
    // snapshot and record current counters; read UID stats first to
    // avoid over counting dev stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotUid");
    final NetworkStats uidSnapshot = getNetworkStatsUidDetail(INTERFACES_ALL);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotXt");
    final NetworkStats xtSnapshot = getNetworkStatsXt();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotDev");
    final NetworkStats devSnapshot = mNetworkManager.getNetworkStatsSummaryDev();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // Tethering snapshot for dev and xt stats. Counts per-interface data from tethering stats
    // providers that isn't already counted by dev and XT stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotTether");
    final NetworkStats tetherSnapshot = getNetworkStatsTethering(STATS_PER_IFACE);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    xtSnapshot.combineAllValues(tetherSnapshot);
    devSnapshot.combineAllValues(tetherSnapshot);
    // For xt/dev, we pass a null VPN array because usage is aggregated by UID, so VPN traffic
    // can't be reattributed to responsible apps.
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordDev");
    mDevRecorder.recordSnapshotLocked(devSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordXt");
    mXtRecorder.recordSnapshotLocked(xtSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // For per-UID stats, pass the VPN info so VPN traffic is reattributed to responsible apps.
    VpnInfo[] vpnArray = mVpnInfos;
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUid");
    mUidRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUidTag");
    mUidTagRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // We need to make copies of member fields that are sent to the observer to avoid
    // a race condition between the service handler thread and the observer's
    mStatsObservers.updateStats(xtSnapshot, uidSnapshot, new ArrayMap<>(mActiveIfaces), new ArrayMap<>(mActiveUidIfaces), vpnArray, currentTime);
}
#method_after
@GuardedBy("mStatsLock")
private void recordSnapshotLocked(long currentTime) throws RemoteException {
    // snapshot and record current counters; read UID stats first to
    // avoid over counting dev stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotUid");
    final NetworkStats uidSnapshot = getNetworkStatsUidDetail(INTERFACES_ALL);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotXt");
    final NetworkStats xtSnapshot = getNetworkStatsXt();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotDev");
    final NetworkStats devSnapshot = mNetworkManager.getNetworkStatsSummaryDev();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // Tethering snapshot for dev and xt stats. Counts per-interface data from tethering stats
    // providers that isn't already counted by dev and XT stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotTether");
    final NetworkStats tetherSnapshot = getNetworkStatsTethering(STATS_PER_IFACE);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    xtSnapshot.combineAllValues(tetherSnapshot);
    devSnapshot.combineAllValues(tetherSnapshot);
    // For xt/dev, we pass a null VPN array because usage is aggregated by UID, so VPN traffic
    // can't be reattributed to responsible apps.
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordDev");
    mDevRecorder.recordSnapshotLocked(devSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordXt");
    mXtRecorder.recordSnapshotLocked(xtSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // For per-UID stats, pass the VPN info so VPN traffic is reattributed to responsible apps.
    VpnInfo[] vpnArray = mVpnInfos;
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUid");
    mUidRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUidTag");
    mUidTagRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // We need to make copies of member fields that are sent to the observer to avoid
    // a race condition between the service handler thread and the observer's
    mStatsObservers.updateStats(xtSnapshot, uidSnapshot, new ArrayMap<>(mActiveIfaces), new ArrayMap<>(mActiveUidIfaces), vpnArray, currentTime);
    migrateTunTraffic(uidSnapshot, vpnArray);
}
#end_block

#method_before
public NetworkStats readNetworkStatsDetail() throws IOException {
    return readNetworkStatsDetail(UID_ALL, null, TAG_ALL, null);
}
#method_after
@Deprecated
public NetworkStats readNetworkStatsDetail() throws IOException {
    return readNetworkStatsDetail(UID_ALL, null, TAG_ALL, null);
}
#end_block

#method_before
public static NetworkManagementService create(Context context) throws InterruptedException {
    return create(context, NETD_SERVICE_NAME, new SystemServices());
}
#method_after
static NetworkManagementService create(Context context, SystemServices services) throws InterruptedException {
    final NetworkManagementService service = new NetworkManagementService(context, services);
    if (DBG)
        Slog.d(TAG, "Creating NetworkManagementService");
    if (DBG)
        Slog.d(TAG, "Connecting native netd service");
    service.connectNativeNetdService();
    if (DBG)
        Slog.d(TAG, "Connected");
    return service;
}
#end_block

#method_before
public static NetworkManagementService create(Context context) throws InterruptedException {
    return create(context, NETD_SERVICE_NAME, new SystemServices());
}
#method_after
public static NetworkManagementService create(Context context) throws InterruptedException {
    return create(context, new SystemServices());
}
#end_block

#method_before
@Override
public InterfaceConfiguration getInterfaceConfig(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final InterfaceConfigurationParcel result;
    try {
        result = mNetdService.interfaceGetCfg(iface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
    try {
        final InterfaceConfiguration cfg = InterfaceConfiguration.fromParcel(result);
        return cfg;
    } catch (IllegalArgumentException iae) {
        throw new IllegalStateException("Invalid InterfaceConfigurationParcel", iae);
    }
}
#method_after
@Override
public InterfaceConfiguration getInterfaceConfig(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final InterfaceConfigurationParcel result;
    try {
        result = mNetdService.interfaceGetCfg(iface);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
    try {
        final InterfaceConfiguration cfg = fromStableParcel(result);
        return cfg;
    } catch (IllegalArgumentException iae) {
        throw new IllegalStateException("Invalid InterfaceConfigurationParcel", iae);
    }
}
#end_block

#method_before
@Override
public void setInterfaceConfig(String iface, InterfaceConfiguration cfg) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    LinkAddress linkAddr = cfg.getLinkAddress();
    if (linkAddr == null || linkAddr.getAddress() == null) {
        throw new IllegalStateException("Null LinkAddress given");
    }
    final InterfaceConfigurationParcel cfgParcel = cfg.toParcel(iface);
    try {
        mNetdService.interfaceSetCfg(cfgParcel);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public void setInterfaceConfig(String iface, InterfaceConfiguration cfg) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    LinkAddress linkAddr = cfg.getLinkAddress();
    if (linkAddr == null || linkAddr.getAddress() == null) {
        throw new IllegalStateException("Null LinkAddress given");
    }
    final InterfaceConfigurationParcel cfgParcel = toStableParcel(cfg, iface);
    try {
        mNetdService.interfaceSetCfg(cfgParcel);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, toStableParcels(uidRanges));
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
@Override
public void addVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkAddUidRanges(netId, ranges);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public void addVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkAddUidRanges(netId, toStableParcels(ranges));
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void removeVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkRemoveUidRanges(netId, ranges);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public void removeVpnUidRanges(int netId, UidRange[] ranges) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkRemoveUidRanges(netId, toStableParcels(ranges));
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private void closeSocketsForFirewallChainLocked(int chain, String chainName) {
    // UID ranges to close sockets on.
    UidRange[] ranges;
    // UID ranges whose sockets we won't touch.
    int[] exemptUids;
    int numUids = 0;
    if (DBG)
        Slog.d(TAG, "Closing sockets after enabling chain " + chainName);
    if (getFirewallType(chain) == FIREWALL_WHITELIST) {
        // Close all sockets on all non-system UIDs...
        ranges = new UidRange[] { // specify their ranges here.
        new UidRange(Process.FIRST_APPLICATION_UID, Integer.MAX_VALUE) };
        // ... except for the UIDs that have allow rules.
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            exemptUids = new int[rules.size()];
            for (int i = 0; i < exemptUids.length; i++) {
                if (rules.valueAt(i) == FIREWALL_RULE_ALLOW) {
                    exemptUids[numUids] = rules.keyAt(i);
                    numUids++;
                }
            }
        }
        // fix setFirewallEnabled to grab mQuotaLock and clear rules.
        if (numUids != exemptUids.length) {
            exemptUids = Arrays.copyOf(exemptUids, numUids);
        }
    } else {
        // Close sockets for every UID that has a deny rule...
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            ranges = new UidRange[rules.size()];
            for (int i = 0; i < ranges.length; i++) {
                if (rules.valueAt(i) == FIREWALL_RULE_DENY) {
                    int uid = rules.keyAt(i);
                    ranges[numUids] = new UidRange(uid, uid);
                    numUids++;
                }
            }
        }
        // As above; usually numUids == ranges.length, but not always.
        if (numUids != ranges.length) {
            ranges = Arrays.copyOf(ranges, numUids);
        }
        // ... with no exceptions.
        exemptUids = new int[0];
    }
    try {
        mNetdService.socketDestroy(ranges, exemptUids);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error closing sockets after enabling chain " + chainName + ": " + e);
    }
}
#method_after
private void closeSocketsForFirewallChainLocked(int chain, String chainName) {
    // UID ranges to close sockets on.
    UidRangeParcel[] ranges;
    // UID ranges whose sockets we won't touch.
    int[] exemptUids;
    int numUids = 0;
    if (DBG)
        Slog.d(TAG, "Closing sockets after enabling chain " + chainName);
    if (getFirewallType(chain) == FIREWALL_WHITELIST) {
        // Close all sockets on all non-system UIDs...
        ranges = new UidRangeParcel[] { // specify their ranges here.
        makeUidRangeParcel(Process.FIRST_APPLICATION_UID, Integer.MAX_VALUE) };
        // ... except for the UIDs that have allow rules.
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            exemptUids = new int[rules.size()];
            for (int i = 0; i < exemptUids.length; i++) {
                if (rules.valueAt(i) == FIREWALL_RULE_ALLOW) {
                    exemptUids[numUids] = rules.keyAt(i);
                    numUids++;
                }
            }
        }
        // fix setFirewallEnabled to grab mQuotaLock and clear rules.
        if (numUids != exemptUids.length) {
            exemptUids = Arrays.copyOf(exemptUids, numUids);
        }
    } else {
        // Close sockets for every UID that has a deny rule...
        synchronized (mRulesLock) {
            final SparseIntArray rules = getUidFirewallRulesLR(chain);
            ranges = new UidRangeParcel[rules.size()];
            for (int i = 0; i < ranges.length; i++) {
                if (rules.valueAt(i) == FIREWALL_RULE_DENY) {
                    int uid = rules.keyAt(i);
                    ranges[numUids] = makeUidRangeParcel(uid, uid);
                    numUids++;
                }
            }
        }
        // As above; usually numUids == ranges.length, but not always.
        if (numUids != ranges.length) {
            ranges = Arrays.copyOf(ranges, numUids);
        }
        // ... with no exceptions.
        exemptUids = new int[0];
    }
    try {
        mNetdService.socketDestroy(ranges, exemptUids);
    } catch (RemoteException | ServiceSpecificException e) {
        Slog.e(TAG, "Error closing sockets after enabling chain " + chainName + ": " + e);
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.println("NetworkManagementService NativeDaemonConnector Log:");
    mConnector.dump(fd, pw, args);
    pw.println();
    pw.print("mMobileActivityFromRadio=");
    pw.print(mMobileActivityFromRadio);
    pw.print(" mLastPowerStateFromRadio=");
    pw.println(mLastPowerStateFromRadio);
    pw.print("mNetworkActive=");
    pw.println(mNetworkActive);
    synchronized (mQuotaLock) {
        pw.print("Active quota ifaces: ");
        pw.println(mActiveQuotas.toString());
        pw.print("Active alert ifaces: ");
        pw.println(mActiveAlerts.toString());
        pw.print("Data saver mode: ");
        pw.println(mDataSaverMode);
        synchronized (mRulesLock) {
            dumpUidRuleOnQuotaLocked(pw, "blacklist", mUidRejectOnMetered);
            dumpUidRuleOnQuotaLocked(pw, "whitelist", mUidAllowOnMetered);
        }
    }
    synchronized (mRulesLock) {
        dumpUidFirewallRule(pw, "", mUidFirewallRules);
        pw.print("UID firewall standby chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_STANDBY));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_STANDBY, mUidFirewallStandbyRules);
        pw.print("UID firewall dozable chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_DOZABLE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_DOZABLE, mUidFirewallDozableRules);
        pw.println("UID firewall powersave chain enabled: " + getFirewallChainState(FIREWALL_CHAIN_POWERSAVE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_POWERSAVE, mUidFirewallPowerSaveRules);
    }
    synchronized (mIdleTimerLock) {
        pw.println("Idle timers:");
        for (HashMap.Entry<String, IdleTimerParams> ent : mActiveIdleTimers.entrySet()) {
            pw.print("  ");
            pw.print(ent.getKey());
            pw.println(":");
            IdleTimerParams params = ent.getValue();
            pw.print("    timeout=");
            pw.print(params.timeout);
            pw.print(" type=");
            pw.print(params.type);
            pw.print(" networkCount=");
            pw.println(params.networkCount);
        }
    }
    pw.print("Firewall enabled: ");
    pw.println(mFirewallEnabled);
    pw.print("Netd service status: ");
    if (mNetdService == null) {
        pw.println("disconnected");
    } else {
        try {
            final boolean alive = mNetdService.isAlive();
            pw.println(alive ? "alive" : "dead");
        } catch (RemoteException e) {
            pw.println("unreachable");
        }
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.print("mMobileActivityFromRadio=");
    pw.print(mMobileActivityFromRadio);
    pw.print(" mLastPowerStateFromRadio=");
    pw.println(mLastPowerStateFromRadio);
    pw.print("mNetworkActive=");
    pw.println(mNetworkActive);
    synchronized (mQuotaLock) {
        pw.print("Active quota ifaces: ");
        pw.println(mActiveQuotas.toString());
        pw.print("Active alert ifaces: ");
        pw.println(mActiveAlerts.toString());
        pw.print("Data saver mode: ");
        pw.println(mDataSaverMode);
        synchronized (mRulesLock) {
            dumpUidRuleOnQuotaLocked(pw, "blacklist", mUidRejectOnMetered);
            dumpUidRuleOnQuotaLocked(pw, "whitelist", mUidAllowOnMetered);
        }
    }
    synchronized (mRulesLock) {
        dumpUidFirewallRule(pw, "", mUidFirewallRules);
        pw.print("UID firewall standby chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_STANDBY));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_STANDBY, mUidFirewallStandbyRules);
        pw.print("UID firewall dozable chain enabled: ");
        pw.println(getFirewallChainState(FIREWALL_CHAIN_DOZABLE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_DOZABLE, mUidFirewallDozableRules);
        pw.println("UID firewall powersave chain enabled: " + getFirewallChainState(FIREWALL_CHAIN_POWERSAVE));
        dumpUidFirewallRule(pw, FIREWALL_CHAIN_NAME_POWERSAVE, mUidFirewallPowerSaveRules);
    }
    synchronized (mIdleTimerLock) {
        pw.println("Idle timers:");
        for (HashMap.Entry<String, IdleTimerParams> ent : mActiveIdleTimers.entrySet()) {
            pw.print("  ");
            pw.print(ent.getKey());
            pw.println(":");
            IdleTimerParams params = ent.getValue();
            pw.print("    timeout=");
            pw.print(params.timeout);
            pw.print(" type=");
            pw.print(params.type);
            pw.print(" networkCount=");
            pw.println(params.networkCount);
        }
    }
    pw.print("Firewall enabled: ");
    pw.println(mFirewallEnabled);
    pw.print("Netd service status: ");
    if (mNetdService == null) {
        pw.println("disconnected");
    } else {
        try {
            final boolean alive = mNetdService.isAlive();
            pw.println(alive ? "alive" : "dead");
        } catch (RemoteException e) {
            pw.println("unreachable");
        }
    }
}
#end_block

#method_before
@Override
public void addInterfaceToLocalNetwork(String iface, List<RouteInfo> routes) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, iface);
    for (RouteInfo route : routes) {
        if (!route.isDefaultRoute()) {
            modifyRoute(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, route);
        }
    }
}
#method_after
@Override
public void addInterfaceToLocalNetwork(String iface, List<RouteInfo> routes) {
    modifyInterfaceInNetwork(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, iface);
    for (RouteInfo route : routes) {
        if (!route.isDefaultRoute()) {
            modifyRoute(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, route);
        }
    }
    // IPv6 link local should be activated always.
    modifyRoute(MODIFY_OPERATION_ADD, INetd.LOCAL_NET_ID, new RouteInfo(new IpPrefix("fe80::/64"), null, iface));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mTestProc = new File(InstrumentationRegistry.getContext().getFilesDir(), "proc");
    if (mTestProc.exists()) {
        IoUtils.deleteContents(mTestProc);
    }
    System.loadLibrary("networkstatsfactorytestjni");
    mFactory = new NetworkStatsFactory(mTestProc, false);
}
#method_after
@Before
public void setUp() throws Exception {
    mTestProc = new File(InstrumentationRegistry.getContext().getFilesDir(), "proc");
    if (mTestProc.exists()) {
        IoUtils.deleteContents(mTestProc);
    }
    // The libandroid_servers which have the native method is not available to
    // applications. So in order to have a test support native library, the native code
    // related to networkStatsFactory is compiled to a minimal native library and loaded here.
    System.loadLibrary("networkstatsfactorytestjni");
    mFactory = new NetworkStatsFactory(mTestProc, false);
}
#end_block

#method_before
public static void setDefaultNightMode(@NightMode int mode) {
    switch(mode) {
        case MODE_NIGHT_NO:
        case MODE_NIGHT_YES:
        case MODE_NIGHT_FOLLOW_SYSTEM:
        case MODE_NIGHT_AUTO_TIME:
        case MODE_NIGHT_AUTO_BATTERY:
            if (sDefaultNightMode != mode) {
                sDefaultNightMode = mode;
                synchronized (sActiveDelegatesLock) {
                    applyDayNightToActiveDelegates();
                }
            }
            break;
        default:
            Log.d(TAG, "setDefaultNightMode() called with an unknown mode");
            break;
    }
}
#method_after
public static void setDefaultNightMode(@NightMode int mode) {
    switch(mode) {
        case MODE_NIGHT_NO:
        case MODE_NIGHT_YES:
        case MODE_NIGHT_FOLLOW_SYSTEM:
        case MODE_NIGHT_AUTO_TIME:
        case MODE_NIGHT_AUTO_BATTERY:
            if (sDefaultNightMode != mode) {
                sDefaultNightMode = mode;
                applyDayNightToActiveDelegates();
            }
            break;
        default:
            Log.d(TAG, "setDefaultNightMode() called with an unknown mode");
            break;
    }
}
#end_block

#method_before
private static void removeDelegateFromActives(@NonNull AppCompatDelegate toRemove) {
    final Iterator<WeakReference<AppCompatDelegate>> i = sActiveDelegates.iterator();
    while (i.hasNext()) {
        final AppCompatDelegate delegate = i.next().get();
        if (delegate == toRemove || delegate == null) {
            // If the delegate is the one to remove, or it is null (because of the WeakRef),
            // remove it from the set
            i.remove();
        }
    }
}
#method_after
private static void removeDelegateFromActives(@NonNull AppCompatDelegate toRemove) {
    synchronized (sActiveDelegatesLock) {
        final Iterator<WeakReference<AppCompatDelegate>> i = sActiveDelegates.iterator();
        while (i.hasNext()) {
            final AppCompatDelegate delegate = i.next().get();
            if (delegate == toRemove || delegate == null) {
                // If the delegate is the one to remove, or it is null (because of the WeakRef),
                // remove it from the set
                i.remove();
            }
        }
    }
}
#end_block

#method_before
private static void applyDayNightToActiveDelegates() {
    for (WeakReference<AppCompatDelegate> activeDelegate : sActiveDelegates) {
        final AppCompatDelegate delegate = activeDelegate.get();
        if (delegate != null) {
            delegate.applyDayNight();
        }
    }
}
#method_after
private static void applyDayNightToActiveDelegates() {
    synchronized (sActiveDelegatesLock) {
        for (WeakReference<AppCompatDelegate> activeDelegate : sActiveDelegates) {
            final AppCompatDelegate delegate = activeDelegate.get();
            if (delegate != null) {
                delegate.applyDayNight();
            }
        }
    }
}
#end_block

#method_before
public void testGetContentHeight() throws Throwable {
    if (!NullWebViewUtils.isWebViewAvailable()) {
        return;
    }
    mOnUiThread.loadDataAndWaitForCompletion("<html><body></body></html>", "text/html", null);
    new PollingCheck() {

        @Override
        protected boolean check() {
            return mOnUiThread.getScale() != 0 && mOnUiThread.getContentHeight() != 0 && mOnUiThread.getHeight() != 0;
        }
    }.run();
    assertEquals(mOnUiThread.getHeight(), mOnUiThread.getContentHeight() * mOnUiThread.getScale(), 2f);
    // Make pageHeight a very large number so it's larger than the height of viewport.
    final int pageHeight = 60000;
    // set the margin to 0
    final String p = "<p style=\"height:" + pageHeight + "px;margin:0px auto;\">Get the height of HTML content.</p>";
    mOnUiThread.loadDataAndWaitForCompletion("<html><body>" + p + "</body></html>", "text/html", null);
    new PollingCheck() {

        @Override
        protected boolean check() {
            return mOnUiThread.getContentHeight() > pageHeight;
        }
    }.run();
    final int extraSpace = mOnUiThread.getContentHeight() - pageHeight;
    mOnUiThread.loadDataAndWaitForCompletion("<html><body>" + p + p + "</body></html>", "text/html", null);
    new PollingCheck() {

        @Override
        protected boolean check() {
            return pageHeight + pageHeight + extraSpace == mOnUiThread.getContentHeight();
        }
    }.run();
}
#method_after
public void testGetContentHeight() throws Throwable {
    if (!NullWebViewUtils.isWebViewAvailable()) {
        return;
    }
    mOnUiThread.loadDataAndWaitForCompletion("<html><body></body></html>", "text/html", null);
    new PollingCheck() {

        @Override
        protected boolean check() {
            return mOnUiThread.getScale() != 0 && mOnUiThread.getContentHeight() != 0 && mOnUiThread.getHeight() != 0;
        }
    }.run();
    assertEquals(mOnUiThread.getHeight(), mOnUiThread.getContentHeight() * mOnUiThread.getScale(), 2f);
    // Make pageHeight bigger than the larger dimension of the device, so the page is taller
    // than viewport. Because when layout_height set to match_parent, getContentHeight() will
    // give maximum value between the actual web content height and the viewport height. When
    // viewport height is bigger, |extraSpace| below is not the extra space on the web page.
    // Note that we are passing physical pixels rather than CSS pixels here, since screen
    // density scale is generally greater than 1, it only makes the page content taller.
    DisplayMetrics metrics = mOnUiThread.getDisplayMetrics();
    final int pageHeight = Math.max(metrics.widthPixels, metrics.heightPixels);
    // set the margin to 0
    final String p = "<p style=\"height:" + pageHeight + "px;margin:0px auto;\">Get the height of HTML content.</p>";
    mOnUiThread.loadDataAndWaitForCompletion("<html><body>" + p + "</body></html>", "text/html", null);
    new PollingCheck() {

        @Override
        protected boolean check() {
            return mOnUiThread.getContentHeight() > pageHeight;
        }
    }.run();
    final int extraSpace = mOnUiThread.getContentHeight() - pageHeight;
    mOnUiThread.loadDataAndWaitForCompletion("<html><body>" + p + p + "</body></html>", "text/html", null);
    new PollingCheck() {

        @Override
        protected boolean check() {
            return pageHeight + pageHeight + extraSpace == mOnUiThread.getContentHeight();
        }
    }.run();
}
#end_block

#method_before
private void createAndCacheNonBootclasspathSystemClassLoader(SharedLibraryInfo lib) {
    String path = lib.getPath();
    List<SharedLibraryInfo> dependencies = lib.getDependencies();
    // get cached classloaders for dependencies
    ArrayList<ClassLoader> sharedLibraries = null;
    if (dependencies != null) {
        sharedLibraries = new ArrayList<ClassLoader>(dependencies.size());
        for (SharedLibraryInfo dependency : dependencies) {
            String dependencyPath = dependency.getPath();
            CachedClassLoader cached = mSystemLibsCacheMap.get(dependencyPath);
            if (cached == null) {
                throw new IllegalStateException("Failed to find dependency " + dependencyPath + " of cachedlibrary " + path);
            }
            sharedLibraries.add(cached.loader);
        }
    }
    // assume cached libraries work with current sdk since they are built-in
    ClassLoader classLoader = getClassLoader(path, Build.VERSION.SDK_INT, true, /*isBundled*/
    null, /*librarySearchPath*/
    null, /*libraryPermittedPath*/
    null, /*parent*/
    null, /*cacheKey*/
    null, /*classLoaderName*/
    sharedLibraries);
    if (classLoader == null) {
        throw new IllegalStateException("Failed to cache " + path);
    }
    CachedClassLoader cached = new CachedClassLoader();
    cached.loader = classLoader;
    cached.sharedLibraries = sharedLibraries;
    Log.d(TAG, "Created zygote-cached class loader: " + path);
    mSystemLibsCacheMap.put(path, cached);
}
#method_after
private void createAndCacheNonBootclasspathSystemClassLoader(SharedLibraryInfo lib) {
    String path = lib.getPath();
    List<SharedLibraryInfo> dependencies = lib.getDependencies();
    // get cached classloaders for dependencies
    ArrayList<ClassLoader> sharedLibraries = null;
    if (dependencies != null) {
        sharedLibraries = new ArrayList<ClassLoader>(dependencies.size());
        for (SharedLibraryInfo dependency : dependencies) {
            String dependencyPath = dependency.getPath();
            CachedClassLoader cached = mSystemLibsCacheMap.get(dependencyPath);
            if (cached == null) {
                throw new IllegalStateException("Failed to find dependency " + dependencyPath + " of cachedlibrary " + path);
            }
            sharedLibraries.add(cached.loader);
        }
    }
    // assume cached libraries work with current sdk since they are built-in
    ClassLoader classLoader = getClassLoader(path, Build.VERSION.SDK_INT, true, /*isBundled*/
    null, /*librarySearchPath*/
    null, /*libraryPermittedPath*/
    null, /*parent*/
    null, /*cacheKey*/
    null, /*classLoaderName*/
    sharedLibraries);
    if (classLoader == null) {
        // bad configuration or break in classloading code
        throw new IllegalStateException("Failed to cache " + path);
    }
    CachedClassLoader cached = new CachedClassLoader();
    cached.loader = classLoader;
    cached.sharedLibraries = sharedLibraries;
    Log.d(TAG, "Created zygote-cached class loader: " + path);
    mSystemLibsCacheMap.put(path, cached);
}
#end_block

#method_before
public ClassLoader getCachedNonBootclasspathSystemLib(String zip, ClassLoader parent, String classLoaderName, List<ClassLoader> sharedLibraries) {
    if (mSystemLibsCacheMap == null) {
        return null;
    }
    // we only cache top-level libs with the default class loader
    if (parent != null || classLoaderName != null) {
        return null;
    }
    CachedClassLoader cached = mSystemLibsCacheMap.get(zip);
    if (cached == null) {
        return null;
    }
    // cached must be built and loaded in the same environment
    if (!sharedLibrariesEquals(sharedLibraries, cached.sharedLibraries)) {
        throw new IllegalStateException("Unexpected environment for cached library: (" + sharedLibraries + "|" + cached.sharedLibraries + ")");
    }
    Log.d(TAG, "Returning zygote-cached class loader: " + zip);
    return cached.loader;
}
#method_after
public ClassLoader getCachedNonBootclasspathSystemLib(String zip, ClassLoader parent, String classLoaderName, List<ClassLoader> sharedLibraries) {
    if (mSystemLibsCacheMap == null) {
        return null;
    }
    // we only cache top-level libs with the default class loader
    if (parent != null || classLoaderName != null) {
        return null;
    }
    CachedClassLoader cached = mSystemLibsCacheMap.get(zip);
    if (cached == null) {
        return null;
    }
    // cached must be built and loaded in the same environment
    if (!sharedLibrariesEquals(sharedLibraries, cached.sharedLibraries)) {
        Log.w(TAG, "Unexpected environment for cached library: (" + sharedLibraries + "|" + cached.sharedLibraries + ")");
        return null;
    }
    Log.d(TAG, "Returning zygote-cached class loader: " + zip);
    return cached.loader;
}
#end_block

#method_before
@Test(expected = IllegalStateException.class)
public void testDifferentSharedLibraries() {
    ApplicationLoaders loaders = new ApplicationLoaders();
    SharedLibraryInfo libA = createLib(LIB_A);
    // any other existant lib
    ClassLoader dep = ClassLoader.getSystemClassLoader();
    ArrayList<ClassLoader> sharedLibraries = new ArrayList<>();
    sharedLibraries.add(dep);
    loaders.createAndCacheNonBootclasspathSystemClassLoaders(new SharedLibraryInfo[] { libA });
    assertEquals(null, loaders.getCachedNonBootclasspathSystemLib(LIB_A, null, null, sharedLibraries));
}
#method_after
@Test
public void testDifferentSharedLibraries() {
    ApplicationLoaders loaders = new ApplicationLoaders();
    SharedLibraryInfo libA = createLib(LIB_A);
    // any other existent lib
    ClassLoader dep = ClassLoader.getSystemClassLoader();
    ArrayList<ClassLoader> sharedLibraries = new ArrayList<>();
    sharedLibraries.add(dep);
    loaders.createAndCacheNonBootclasspathSystemClassLoaders(new SharedLibraryInfo[] { libA });
    assertEquals(null, loaders.getCachedNonBootclasspathSystemLib(LIB_A, null, null, sharedLibraries));
}
#end_block

#method_before
@NonNull
public static AppCompatDelegate create(@NonNull Context context, @NonNull Activity activity, @Nullable AppCompatCallback callback) {
    return new AppCompatDelegateImpl(context, activity, callback);
}
#method_after
@NonNull
public static AppCompatDelegate create(@NonNull Context context, @NonNull Window window, @Nullable AppCompatCallback callback) {
    return new AppCompatDelegateImpl(context, window, callback);
}
#end_block

#method_before
@Test
public void test_blockguardOsIsNotifiedByDefault_rename() {
    String oldPath = "BlockGuardOsTest/missing/old/path";
    String newPath = "BlockGuardOsTest/missing/new/path";
    try {
        Os.getDefault().rename(oldPath, newPath);
    } catch (ErrnoException ignored) {
    }
    verify(mockThreadPolicy).onWriteToDisk();
    verify(mockVmPolicy).onPathAccess(oldPath);
    verify(mockVmPolicy).onPathAccess(newPath);
}
#method_after
@Test
public void test_blockguardOsIsNotifiedByDefault_rename() {
    String oldPath = "BlockGuardOsTest/missing/old/path";
    String newPath = "BlockGuardOsTest/missing/new/path";
    try {
        // We try not to be prescriptive about the exact default Os implementation.
        // Whatever default Os is installed, we do expect BlockGuard to be called.
        Os.getDefault().rename(oldPath, newPath);
    } catch (ErrnoException ignored) {
    }
    verify(mockThreadPolicy).onWriteToDisk();
    verify(mockVmPolicy).onPathAccess(oldPath);
    verify(mockVmPolicy).onPathAccess(newPath);
}
#end_block

#method_before
public void onProvisioningSuccess(LinkProperties newLp) {
    log("onProvisioningSuccess({" + newLp + "})");
    try {
        mCallback.onProvisioningSuccess(toStableParcelable(newLp));
    } catch (RemoteException e) {
        log("Failed to call onProvisioningSuccess", e);
    }
}
#method_after
public void onProvisioningSuccess(LinkProperties newLp) {
    log("onProvisioningSuccess({" + newLp + "})");
    try {
        mCallback.onProvisioningSuccess(newLp);
    } catch (RemoteException e) {
        log("Failed to call onProvisioningSuccess", e);
    }
}
#end_block

#method_before
public void onProvisioningFailure(LinkProperties newLp) {
    log("onProvisioningFailure({" + newLp + "})");
    try {
        mCallback.onProvisioningFailure(toStableParcelable(newLp));
    } catch (RemoteException e) {
        log("Failed to call onProvisioningFailure", e);
    }
}
#method_after
public void onProvisioningFailure(LinkProperties newLp) {
    log("onProvisioningFailure({" + newLp + "})");
    try {
        mCallback.onProvisioningFailure(newLp);
    } catch (RemoteException e) {
        log("Failed to call onProvisioningFailure", e);
    }
}
#end_block

#method_before
public void onLinkPropertiesChange(LinkProperties newLp) {
    log("onLinkPropertiesChange({" + newLp + "})");
    try {
        mCallback.onLinkPropertiesChange(toStableParcelable(newLp));
    } catch (RemoteException e) {
        log("Failed to call onLinkPropertiesChange", e);
    }
}
#method_after
public void onLinkPropertiesChange(LinkProperties newLp) {
    log("onLinkPropertiesChange({" + newLp + "})");
    try {
        mCallback.onLinkPropertiesChange(newLp);
    } catch (RemoteException e) {
        log("Failed to call onLinkPropertiesChange", e);
    }
}
#end_block

#method_before
@Override
public void setHttpProxy(ProxyInfoParcelable proxyInfo) {
    checkNetworkStackCallingPermission();
    IpClient.this.setHttpProxy(fromStableParcelable(proxyInfo));
}
#method_after
@Override
public void setHttpProxy(ProxyInfo proxyInfo) {
    checkNetworkStackCallingPermission();
    IpClient.this.setHttpProxy(proxyInfo);
}
#end_block

#method_before
@VisibleForTesting
static boolean isProvisioned(LinkProperties lp, InitialConfiguration config) {
    // an IPv4 address and nothing else.
    if (lp.hasIPv4Address() || lp.isProvisioned()) {
        return true;
    }
    if (config == null) {
        return false;
    }
    // properties and instead check if properties observed match the desired properties.
    return config.isProvisionedBy(lp.getLinkAddresses(), lp.getRoutes());
}
#method_after
@VisibleForTesting
static boolean isProvisioned(LinkProperties lp, InitialConfiguration config) {
    // an IPv4 address and nothing else.
    if (lp.hasIpv4Address() || lp.isProvisioned()) {
        return true;
    }
    if (config == null) {
        return false;
    }
    // properties and instead check if properties observed match the desired properties.
    return config.isProvisionedBy(lp.getLinkAddresses(), lp.getRoutes());
}
#end_block

#method_before
// TODO: Investigate folding all this into the existing static function
// LinkProperties.compareProvisioning() or some other single function that
// takes two LinkProperties objects and returns a ProvisioningChange
// object that is a correct and complete assessment of what changed, taking
// account of the asymmetries described in the comments in this function.
private int compareProvisioning(LinkProperties oldLp, LinkProperties newLp) {
    int delta;
    InitialConfiguration config = mConfiguration != null ? mConfiguration.mInitialConfig : null;
    final boolean wasProvisioned = isProvisioned(oldLp, config);
    final boolean isProvisioned = isProvisioned(newLp, config);
    if (!wasProvisioned && isProvisioned) {
        delta = PROV_CHANGE_GAINED_PROVISIONING;
    } else if (wasProvisioned && isProvisioned) {
        delta = PROV_CHANGE_STILL_PROVISIONED;
    } else if (!wasProvisioned && !isProvisioned) {
        delta = PROV_CHANGE_STILL_NOT_PROVISIONED;
    } else {
        // (wasProvisioned && !isProvisioned)
        // 
        // Note that this is true even if we lose a configuration element
        // (e.g., a default gateway) that would not be required to advance
        // into provisioned state. This is intended: if we have a default
        // router and we lose it, that's a sure sign of a problem, but if
        // we connect to a network with no IPv4 DNS servers, we consider
        // that to be a network without DNS servers and connect anyway.
        // 
        // See the comment below.
        delta = PROV_CHANGE_LOST_PROVISIONING;
    }
    final boolean lostIPv6 = oldLp.isIPv6Provisioned() && !newLp.isIPv6Provisioned();
    final boolean lostIPv4Address = oldLp.hasIPv4Address() && !newLp.hasIPv4Address();
    final boolean lostIPv6Router = oldLp.hasIPv6DefaultRoute() && !newLp.hasIPv6DefaultRoute();
    // If bad wifi avoidance is disabled, then ignore IPv6 loss of
    // provisioning. Otherwise, when a hotspot that loses Internet
    // access sends out a 0-lifetime RA to its clients, the clients
    // will disconnect and then reconnect, avoiding the bad hotspot,
    // instead of getting stuck on the bad hotspot. http://b/31827713 .
    // 
    // This is incorrect because if the hotspot then regains Internet
    // access with a different prefix, TCP connections on the
    // deprecated addresses will remain stuck.
    // 
    // Note that we can still be disconnected by IpReachabilityMonitor
    // if the IPv6 default gateway (but not the IPv6 DNS servers; see
    // accompanying code in IpReachabilityMonitor) is unreachable.
    final boolean ignoreIPv6ProvisioningLoss = mConfiguration != null && mConfiguration.mUsingMultinetworkPolicyTracker && mCm.getAvoidBadWifi();
    // provisioning here too.
    if (lostIPv4Address || (lostIPv6 && !ignoreIPv6ProvisioningLoss)) {
        delta = PROV_CHANGE_LOST_PROVISIONING;
    }
    // to be a loss of provisioning. See b/27962810.
    if (oldLp.hasGlobalIPv6Address() && (lostIPv6Router && !ignoreIPv6ProvisioningLoss)) {
        delta = PROV_CHANGE_LOST_PROVISIONING;
    }
    return delta;
}
#method_after
// TODO: Investigate folding all this into the existing static function
// LinkProperties.compareProvisioning() or some other single function that
// takes two LinkProperties objects and returns a ProvisioningChange
// object that is a correct and complete assessment of what changed, taking
// account of the asymmetries described in the comments in this function.
private int compareProvisioning(LinkProperties oldLp, LinkProperties newLp) {
    int delta;
    InitialConfiguration config = mConfiguration != null ? mConfiguration.mInitialConfig : null;
    final boolean wasProvisioned = isProvisioned(oldLp, config);
    final boolean isProvisioned = isProvisioned(newLp, config);
    if (!wasProvisioned && isProvisioned) {
        delta = PROV_CHANGE_GAINED_PROVISIONING;
    } else if (wasProvisioned && isProvisioned) {
        delta = PROV_CHANGE_STILL_PROVISIONED;
    } else if (!wasProvisioned && !isProvisioned) {
        delta = PROV_CHANGE_STILL_NOT_PROVISIONED;
    } else {
        // (wasProvisioned && !isProvisioned)
        // 
        // Note that this is true even if we lose a configuration element
        // (e.g., a default gateway) that would not be required to advance
        // into provisioned state. This is intended: if we have a default
        // router and we lose it, that's a sure sign of a problem, but if
        // we connect to a network with no IPv4 DNS servers, we consider
        // that to be a network without DNS servers and connect anyway.
        // 
        // See the comment below.
        delta = PROV_CHANGE_LOST_PROVISIONING;
    }
    final boolean lostIPv6 = oldLp.isIpv6Provisioned() && !newLp.isIpv6Provisioned();
    final boolean lostIPv4Address = oldLp.hasIpv4Address() && !newLp.hasIpv4Address();
    final boolean lostIPv6Router = oldLp.hasIpv6DefaultRoute() && !newLp.hasIpv6DefaultRoute();
    // If bad wifi avoidance is disabled, then ignore IPv6 loss of
    // provisioning. Otherwise, when a hotspot that loses Internet
    // access sends out a 0-lifetime RA to its clients, the clients
    // will disconnect and then reconnect, avoiding the bad hotspot,
    // instead of getting stuck on the bad hotspot. http://b/31827713 .
    // 
    // This is incorrect because if the hotspot then regains Internet
    // access with a different prefix, TCP connections on the
    // deprecated addresses will remain stuck.
    // 
    // Note that we can still be disconnected by IpReachabilityMonitor
    // if the IPv6 default gateway (but not the IPv6 DNS servers; see
    // accompanying code in IpReachabilityMonitor) is unreachable.
    final boolean ignoreIPv6ProvisioningLoss = mConfiguration != null && mConfiguration.mUsingMultinetworkPolicyTracker && mCm.shouldAvoidBadWifi();
    // provisioning here too.
    if (lostIPv4Address || (lostIPv6 && !ignoreIPv6ProvisioningLoss)) {
        delta = PROV_CHANGE_LOST_PROVISIONING;
    }
    // to be a loss of provisioning. See b/27962810.
    if (oldLp.hasGlobalIpv6Address() && (lostIPv6Router && !ignoreIPv6ProvisioningLoss)) {
        delta = PROV_CHANGE_LOST_PROVISIONING;
    }
    return delta;
}
#end_block

#method_before
private boolean handleLinkPropertiesUpdate(boolean sendCallbacks) {
    final LinkProperties newLp = assembleLinkProperties();
    if (Objects.equals(newLp, mLinkProperties)) {
        return true;
    }
    final int delta = setLinkProperties(newLp);
    if (sendCallbacks) {
        dispatchCallback(delta, newLp);
    }
    return (delta != PROV_CHANGE_LOST_PROVISIONING);
}
#method_after
private boolean handleLinkPropertiesUpdate(boolean sendCallbacks) {
    final LinkProperties newLp = assembleLinkProperties();
    if (Objects.equals(newLp, mLinkProperties)) {
        return true;
    }
    final int delta = setLinkProperties(newLp);
    // Most of the attributes stored in the memory store are deduced from
    // the link properties, therefore when the properties update the memory
    // store record should be updated too.
    maybeSaveNetworkToIpMemoryStore();
    if (sendCallbacks) {
        dispatchCallback(delta, newLp);
    }
    return (delta != PROV_CHANGE_LOST_PROVISIONING);
}
#end_block

#method_before
private boolean applyInitialConfig(InitialConfiguration config) {
    // TODO: also support specifying a static IPv4 configuration in InitialConfiguration.
    for (LinkAddress addr : findAll(config.ipAddresses, LinkAddress::isIPv6)) {
        if (!mInterfaceCtrl.addAddress(addr))
            return false;
    }
    return true;
}
#method_after
private boolean applyInitialConfig(InitialConfiguration config) {
    // TODO: also support specifying a static IPv4 configuration in InitialConfiguration.
    for (LinkAddress addr : findAll(config.ipAddresses, LinkAddress::isIpv6)) {
        if (!mInterfaceCtrl.addAddress(addr))
            return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_JUMP_STARTED_TO_RUNNING:
            transitionTo(mRunningState);
            break;
        case CMD_STOP:
            transitionTo(mStoppingState);
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            if (readyToProceed()) {
                transitionTo(mRunningState);
            }
            break;
        case CMD_UPDATE_L2KEY_GROUPHINT:
            {
                final Pair<String, String> args = (Pair<String, String>) msg.obj;
                mL2Key = args.first;
                mGroupHint = args.second;
                break;
            }
        case EVENT_PROVISIONING_TIMEOUT:
            handleProvisioningFailure();
            break;
        default:
            // It's safe to process messages out of order because the
            // only message that can both
            // a) be received at this time and
            // b) affect provisioning state
            // is EVENT_NETLINK_LINKPROPERTIES_CHANGED (handled above).
            deferMessage(msg);
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_JUMP_STARTED_TO_RUNNING:
            transitionTo(mRunningState);
            break;
        case CMD_STOP:
            transitionTo(mStoppingState);
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            handleLinkPropertiesUpdate(NO_CALLBACKS);
            if (readyToProceed()) {
                transitionTo(mRunningState);
            }
            break;
        case CMD_UPDATE_L2KEY_GROUPHINT:
            {
                final Pair<String, String> args = (Pair<String, String>) msg.obj;
                mL2Key = args.first;
                mGroupHint = args.second;
                // inputting current values for what may be a different L3 network.
                break;
            }
        case EVENT_PROVISIONING_TIMEOUT:
            handleProvisioningFailure();
            break;
        default:
            // It's safe to process messages out of order because the
            // only message that can both
            // a) be received at this time and
            // b) affect provisioning state
            // is EVENT_NETLINK_LINKPROPERTIES_CHANGED (handled above).
            deferMessage(msg);
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#end_block

#method_before
private boolean readyToProceed() {
    return (!mLinkProperties.hasIPv4Address() && !mLinkProperties.hasGlobalIPv6Address());
}
#method_after
private boolean readyToProceed() {
    return (!mLinkProperties.hasIpv4Address() && !mLinkProperties.hasGlobalIpv6Address());
}
#end_block

#method_before
@Override
public void enter() {
    ApfFilter.ApfConfiguration apfConfig = new ApfFilter.ApfConfiguration();
    apfConfig.apfCapabilities = mConfiguration.mApfCapabilities;
    apfConfig.multicastFilter = mMulticastFiltering;
    // Get the Configuration for ApfFilter from Context
    apfConfig.ieee802_3Filter = ApfCapabilities.getApfDrop8023Frames(mContext);
    apfConfig.ethTypeBlackList = ApfCapabilities.getApfEthTypeBlackList(mContext);
    mApfFilter = ApfFilter.maybeCreate(mContext, apfConfig, mInterfaceParams, mCallback);
    // rest of this IP configuration startup.
    if (mApfFilter == null) {
        mCallback.setFallbackMulticastFilter(mMulticastFiltering);
    }
    mPacketTracker = createPacketTracker();
    if (mPacketTracker != null)
        mPacketTracker.start(mConfiguration.mDisplayName);
    if (mConfiguration.mEnableIPv6 && !startIPv6()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
        enqueueJumpToStoppingState();
        return;
    }
    if (mConfiguration.mEnableIPv4 && !startIPv4()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV4);
        enqueueJumpToStoppingState();
        return;
    }
    final InitialConfiguration config = mConfiguration.mInitialConfig;
    if ((config != null) && !applyInitialConfig(config)) {
        // TODO introduce a new IpManagerEvent constant to distinguish this error case.
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        enqueueJumpToStoppingState();
        return;
    }
    if (mConfiguration.mUsingIpReachabilityMonitor && !startIpReachabilityMonitor()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPREACHABILITYMONITOR);
        enqueueJumpToStoppingState();
        return;
    }
}
#method_after
@Override
public void enter() {
    ApfFilter.ApfConfiguration apfConfig = new ApfFilter.ApfConfiguration();
    apfConfig.apfCapabilities = mConfiguration.mApfCapabilities;
    apfConfig.multicastFilter = mMulticastFiltering;
    // Get the Configuration for ApfFilter from Context
    apfConfig.ieee802_3Filter = ApfCapabilities.getApfDrop8023Frames();
    apfConfig.ethTypeBlackList = ApfCapabilities.getApfEtherTypeBlackList();
    mApfFilter = ApfFilter.maybeCreate(mContext, apfConfig, mInterfaceParams, mCallback);
    // rest of this IP configuration startup.
    if (mApfFilter == null) {
        mCallback.setFallbackMulticastFilter(mMulticastFiltering);
    }
    mPacketTracker = createPacketTracker();
    if (mPacketTracker != null)
        mPacketTracker.start(mConfiguration.mDisplayName);
    if (mConfiguration.mEnableIPv6 && !startIPv6()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
        enqueueJumpToStoppingState();
        return;
    }
    if (mConfiguration.mEnableIPv4 && !startIPv4()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV4);
        enqueueJumpToStoppingState();
        return;
    }
    final InitialConfiguration config = mConfiguration.mInitialConfig;
    if ((config != null) && !applyInitialConfig(config)) {
        // TODO introduce a new IpManagerEvent constant to distinguish this error case.
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        enqueueJumpToStoppingState();
        return;
    }
    if (mConfiguration.mUsingIpReachabilityMonitor && !startIpReachabilityMonitor()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPREACHABILITYMONITOR);
        enqueueJumpToStoppingState();
        return;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_JUMP_RUNNING_TO_STOPPING:
        case CMD_STOP:
            transitionTo(mStoppingState);
            break;
        case CMD_START:
            logError("ALERT: START received in StartedState. Please fix caller.");
            break;
        case CMD_CONFIRM:
            // roams.
            if (mIpReachabilityMonitor != null) {
                mIpReachabilityMonitor.probeAll();
            }
            break;
        case EVENT_PRE_DHCP_ACTION_COMPLETE:
            // a static IP configuration.
            if (mDhcpClient != null) {
                mDhcpClient.sendMessage(DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            if (!handleLinkPropertiesUpdate(SEND_CALLBACKS)) {
                transitionTo(mStoppingState);
            }
            maybeSaveNetworkToIpMemoryStore();
            break;
        case CMD_UPDATE_TCP_BUFFER_SIZES:
            mTcpBufferSizes = (String) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_UPDATE_HTTP_PROXY:
            mHttpProxy = (ProxyInfo) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_UPDATE_L2KEY_GROUPHINT:
            {
                final Pair<String, String> args = (Pair<String, String>) msg.obj;
                mL2Key = args.first;
                mGroupHint = args.second;
                maybeSaveNetworkToIpMemoryStore();
                break;
            }
        case CMD_SET_MULTICAST_FILTER:
            {
                mMulticastFiltering = (boolean) msg.obj;
                if (mApfFilter != null) {
                    mApfFilter.setMulticastFilter(mMulticastFiltering);
                } else {
                    mCallback.setFallbackMulticastFilter(mMulticastFiltering);
                }
                break;
            }
        case EVENT_READ_PACKET_FILTER_COMPLETE:
            {
                if (mApfFilter != null) {
                    mApfFilter.setDataSnapshot((byte[]) msg.obj);
                }
                mApfDataSnapshotComplete.open();
                break;
            }
        case CMD_ADD_KEEPALIVE_PACKET_FILTER_TO_APF:
            {
                final int slot = msg.arg1;
                if (mApfFilter != null) {
                    mApfFilter.addKeepalivePacketFilter(slot, (TcpKeepalivePacketDataParcelable) msg.obj);
                }
                break;
            }
        case CMD_REMOVE_KEEPALIVE_PACKET_FILTER_FROM_APF:
            {
                final int slot = msg.arg1;
                if (mApfFilter != null) {
                    mApfFilter.removeKeepalivePacketFilter(slot);
                }
                break;
            }
        case EVENT_DHCPACTION_TIMEOUT:
            stopDhcpAction();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            if (mConfiguration.mRequestedPreDhcpActionMs > 0) {
                ensureDhcpAction();
            } else {
                sendMessage(EVENT_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case DhcpClient.CMD_CLEAR_LINKADDRESS:
            mInterfaceCtrl.clearIPv4Address();
            break;
        case DhcpClient.CMD_CONFIGURE_LINKADDRESS:
            {
                final LinkAddress ipAddress = (LinkAddress) msg.obj;
                if (mInterfaceCtrl.setIPv4Address(ipAddress)) {
                    mDhcpClient.sendMessage(DhcpClient.EVENT_LINKADDRESS_CONFIGURED);
                } else {
                    logError("Failed to set IPv4 address.");
                    dispatchCallback(PROV_CHANGE_LOST_PROVISIONING, new LinkProperties(mLinkProperties));
                    transitionTo(mStoppingState);
                }
                break;
            }
        // condition is now governed by the provisioning timeout.
        case DhcpClient.CMD_POST_DHCP_ACTION:
            stopDhcpAction();
            switch(msg.arg1) {
                case DhcpClient.DHCP_SUCCESS:
                    handleIPv4Success((DhcpResults) msg.obj);
                    break;
                case DhcpClient.DHCP_FAILURE:
                    handleIPv4Failure();
                    break;
                default:
                    logError("Unknown CMD_POST_DHCP_ACTION status: %s", msg.arg1);
            }
            break;
        case DhcpClient.CMD_ON_QUIT:
            // DHCPv4 quit early for some reason.
            logError("Unexpected CMD_ON_QUIT.");
            mDhcpClient = null;
            break;
        default:
            return NOT_HANDLED;
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_JUMP_RUNNING_TO_STOPPING:
        case CMD_STOP:
            transitionTo(mStoppingState);
            break;
        case CMD_START:
            logError("ALERT: START received in StartedState. Please fix caller.");
            break;
        case CMD_CONFIRM:
            // roams.
            if (mIpReachabilityMonitor != null) {
                mIpReachabilityMonitor.probeAll();
            }
            break;
        case EVENT_PRE_DHCP_ACTION_COMPLETE:
            // a static IP configuration.
            if (mDhcpClient != null) {
                mDhcpClient.sendMessage(DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case EVENT_NETLINK_LINKPROPERTIES_CHANGED:
            if (!handleLinkPropertiesUpdate(SEND_CALLBACKS)) {
                transitionTo(mStoppingState);
            }
            break;
        case CMD_UPDATE_TCP_BUFFER_SIZES:
            mTcpBufferSizes = (String) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_UPDATE_HTTP_PROXY:
            mHttpProxy = (ProxyInfo) msg.obj;
            // This cannot possibly change provisioning state.
            handleLinkPropertiesUpdate(SEND_CALLBACKS);
            break;
        case CMD_SET_MULTICAST_FILTER:
            {
                mMulticastFiltering = (boolean) msg.obj;
                if (mApfFilter != null) {
                    mApfFilter.setMulticastFilter(mMulticastFiltering);
                } else {
                    mCallback.setFallbackMulticastFilter(mMulticastFiltering);
                }
                break;
            }
        case EVENT_READ_PACKET_FILTER_COMPLETE:
            {
                if (mApfFilter != null) {
                    mApfFilter.setDataSnapshot((byte[]) msg.obj);
                }
                mApfDataSnapshotComplete.open();
                break;
            }
        case CMD_ADD_KEEPALIVE_PACKET_FILTER_TO_APF:
            {
                final int slot = msg.arg1;
                if (mApfFilter != null) {
                    mApfFilter.addKeepalivePacketFilter(slot, (TcpKeepalivePacketDataParcelable) msg.obj);
                }
                break;
            }
        case CMD_REMOVE_KEEPALIVE_PACKET_FILTER_FROM_APF:
            {
                final int slot = msg.arg1;
                if (mApfFilter != null) {
                    mApfFilter.removeKeepalivePacketFilter(slot);
                }
                break;
            }
        case EVENT_DHCPACTION_TIMEOUT:
            stopDhcpAction();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            if (mConfiguration.mRequestedPreDhcpActionMs > 0) {
                ensureDhcpAction();
            } else {
                sendMessage(EVENT_PRE_DHCP_ACTION_COMPLETE);
            }
            break;
        case DhcpClient.CMD_CLEAR_LINKADDRESS:
            mInterfaceCtrl.clearIPv4Address();
            break;
        case DhcpClient.CMD_CONFIGURE_LINKADDRESS:
            {
                final LinkAddress ipAddress = (LinkAddress) msg.obj;
                if (mInterfaceCtrl.setIPv4Address(ipAddress)) {
                    mDhcpClient.sendMessage(DhcpClient.EVENT_LINKADDRESS_CONFIGURED);
                } else {
                    logError("Failed to set IPv4 address.");
                    dispatchCallback(PROV_CHANGE_LOST_PROVISIONING, new LinkProperties(mLinkProperties));
                    transitionTo(mStoppingState);
                }
                break;
            }
        // condition is now governed by the provisioning timeout.
        case DhcpClient.CMD_POST_DHCP_ACTION:
            stopDhcpAction();
            switch(msg.arg1) {
                case DhcpClient.DHCP_SUCCESS:
                    handleIPv4Success((DhcpResults) msg.obj);
                    break;
                case DhcpClient.DHCP_FAILURE:
                    handleIPv4Failure();
                    break;
                default:
                    logError("Unknown CMD_POST_DHCP_ACTION status: %s", msg.arg1);
            }
            break;
        case DhcpClient.CMD_ON_QUIT:
            // DHCPv4 quit early for some reason.
            logError("Unexpected CMD_ON_QUIT.");
            mDhcpClient = null;
            break;
        default:
            return NOT_HANDLED;
    }
    mMsgStateLogger.handled(this, getCurrentState());
    return HANDLED;
}
#end_block

#method_before
private IpClient makeIpClient(String ifname) throws Exception {
    setTestInterfaceParams(ifname);
    final IpClient ipc = new IpClient(mContext, ifname, mCb, mObserverRegistry, mDependencies);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceSetEnableIPv6(ifname, false);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceClearAddrs(ifname);
    ArgumentCaptor<NetworkObserver> arg = ArgumentCaptor.forClass(NetworkObserver.class);
    verify(mObserverRegistry, times(1)).registerObserverForNonblockingCallback(arg.capture());
    mObserver = arg.getValue();
    reset(mObserverRegistry);
    reset(mNetd);
    // Verify IpClient doesn't call onLinkPropertiesChange() when it starts.
    verify(mCb, never()).onLinkPropertiesChange(any());
    reset(mCb);
    return ipc;
}
#method_after
private IpClient makeIpClient(String ifname) throws Exception {
    setTestInterfaceParams(ifname);
    final IpClient ipc = new IpClient(mContext, ifname, mCb, mObserverRegistry, mNetworkStackServiceManager, mDependencies);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceSetEnableIPv6(ifname, false);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceClearAddrs(ifname);
    ArgumentCaptor<NetworkObserver> arg = ArgumentCaptor.forClass(NetworkObserver.class);
    verify(mObserverRegistry, times(1)).registerObserverForNonblockingCallback(arg.capture());
    mObserver = arg.getValue();
    reset(mObserverRegistry);
    reset(mNetd);
    // Verify IpClient doesn't call onLinkPropertiesChange() when it starts.
    verify(mCb, never()).onLinkPropertiesChange(any());
    reset(mCb);
    return ipc;
}
#end_block

#method_before
@Test
public void testNullInterfaceNameMostDefinitelyThrows() throws Exception {
    setTestInterfaceParams(null);
    try {
        final IpClient ipc = new IpClient(mContext, null, mCb, mObserverRegistry, mDependencies);
        ipc.shutdown();
        fail();
    } catch (NullPointerException npe) {
    // Phew; null interface names not allowed.
    }
}
#method_after
@Test
public void testNullInterfaceNameMostDefinitelyThrows() throws Exception {
    setTestInterfaceParams(null);
    try {
        final IpClient ipc = new IpClient(mContext, null, mCb, mObserverRegistry, mNetworkStackServiceManager, mDependencies);
        ipc.shutdown();
        fail();
    } catch (NullPointerException npe) {
    // Phew; null interface names not allowed.
    }
}
#end_block

#method_before
@Test
public void testNullCallbackMostDefinitelyThrows() throws Exception {
    final String ifname = "lo";
    setTestInterfaceParams(ifname);
    try {
        final IpClient ipc = new IpClient(mContext, ifname, null, mObserverRegistry, mDependencies);
        ipc.shutdown();
        fail();
    } catch (NullPointerException npe) {
    // Phew; null callbacks not allowed.
    }
}
#method_after
@Test
public void testNullCallbackMostDefinitelyThrows() throws Exception {
    final String ifname = "lo";
    setTestInterfaceParams(ifname);
    try {
        final IpClient ipc = new IpClient(mContext, ifname, null, mObserverRegistry, mNetworkStackServiceManager, mDependencies);
        ipc.shutdown();
        fail();
    } catch (NullPointerException npe) {
    // Phew; null callbacks not allowed.
    }
}
#end_block

#method_before
@Test
public void testInvalidInterfaceDoesNotThrow() throws Exception {
    setTestInterfaceParams(TEST_IFNAME);
    final IpClient ipc = new IpClient(mContext, TEST_IFNAME, mCb, mObserverRegistry, mDependencies);
    verifyNoMoreInteractions(mIpMemoryStore);
    ipc.shutdown();
}
#method_after
@Test
public void testInvalidInterfaceDoesNotThrow() throws Exception {
    setTestInterfaceParams(TEST_IFNAME);
    final IpClient ipc = new IpClient(mContext, TEST_IFNAME, mCb, mObserverRegistry, mNetworkStackServiceManager, mDependencies);
    verifyNoMoreInteractions(mIpMemoryStore);
    ipc.shutdown();
}
#end_block

#method_before
@Test
public void testInterfaceNotFoundFailsImmediately() throws Exception {
    setTestInterfaceParams(null);
    final IpClient ipc = new IpClient(mContext, TEST_IFNAME, mCb, mObserverRegistry, mDependencies);
    ipc.startProvisioning(new ProvisioningConfiguration());
    verify(mCb, times(1)).onProvisioningFailure(any());
    verify(mIpMemoryStore, never()).storeNetworkAttributes(any(), any(), any());
    ipc.shutdown();
}
#method_after
@Test
public void testInterfaceNotFoundFailsImmediately() throws Exception {
    setTestInterfaceParams(null);
    final IpClient ipc = new IpClient(mContext, TEST_IFNAME, mCb, mObserverRegistry, mNetworkStackServiceManager, mDependencies);
    ipc.startProvisioning(new ProvisioningConfiguration());
    verify(mCb, times(1)).onProvisioningFailure(any());
    verify(mIpMemoryStore, never()).storeNetworkAttributes(any(), any(), any());
    ipc.shutdown();
}
#end_block

#method_before
@Test
public void testDefaultProvisioningConfiguration() throws Exception {
    final String iface = TEST_IFNAME;
    final IpClient ipc = makeIpClient(iface);
    ProvisioningConfiguration config = new ProvisioningConfiguration.Builder().withoutIPv4().withoutIpReachabilityMonitor().build();
    ipc.startProvisioning(config);
    verify(mCb, times(1)).setNeighborDiscoveryOffload(true);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).setFallbackMulticastFilter(false);
    verify(mCb, never()).onProvisioningFailure(any());
    verify(mIpMemoryStore, never()).storeNetworkAttributes(any(), any(), any());
    ipc.shutdown();
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceSetEnableIPv6(iface, false);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceClearAddrs(iface);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).onLinkPropertiesChange(argThat(lp -> fromStableParcelable(lp).equals(makeEmptyLinkProperties(iface))));
}
#method_after
@Test
public void testDefaultProvisioningConfiguration() throws Exception {
    final String iface = TEST_IFNAME;
    final IpClient ipc = makeIpClient(iface);
    ProvisioningConfiguration config = new ProvisioningConfiguration.Builder().withoutIPv4().withoutIpReachabilityMonitor().build();
    ipc.startProvisioning(config);
    verify(mCb, times(1)).setNeighborDiscoveryOffload(true);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).setFallbackMulticastFilter(false);
    verify(mCb, never()).onProvisioningFailure(any());
    verify(mIpMemoryStore, never()).storeNetworkAttributes(any(), any(), any());
    ipc.shutdown();
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceSetEnableIPv6(iface, false);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceClearAddrs(iface);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).onLinkPropertiesChange(makeEmptyLinkProperties(iface));
}
#end_block

#method_before
@Test
public void testProvisioningWithInitialConfiguration() throws Exception {
    final String iface = TEST_IFNAME;
    final IpClient ipc = makeIpClient(iface);
    final String l2Key = TEST_L2KEY;
    final String groupHint = TEST_GROUPHINT;
    String[] addresses = { "fe80::a4be:f92:e1f7:22d1/64", "fe80::f04a:8f6:6a32:d756/64", "fd2c:4e57:8e3c:0:548d:2db2:4fcf:ef75/64" };
    String[] prefixes = { "fe80::/64", "fd2c:4e57:8e3c::/64" };
    ProvisioningConfiguration config = new ProvisioningConfiguration.Builder().withoutIPv4().withoutIpReachabilityMonitor().withInitialConfiguration(conf(links(addresses), prefixes(prefixes), ips())).build();
    ipc.startProvisioning(config);
    verify(mCb, times(1)).setNeighborDiscoveryOffload(true);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).setFallbackMulticastFilter(false);
    verify(mCb, never()).onProvisioningFailure(any());
    ipc.setL2KeyAndGroupHint(l2Key, groupHint);
    for (String addr : addresses) {
        String[] parts = addr.split("/");
        verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceAddAddress(iface, parts[0], Integer.parseInt(parts[1]));
    }
    final int lastAddr = addresses.length - 1;
    // Add N - 1 addresses
    for (int i = 0; i < lastAddr; i++) {
        mObserver.onInterfaceAddressUpdated(new LinkAddress(addresses[i]), iface);
        verify(mCb, timeout(TEST_TIMEOUT_MS)).onLinkPropertiesChange(any());
        reset(mCb);
    }
    // Add Nth address
    mObserver.onInterfaceAddressUpdated(new LinkAddress(addresses[lastAddr]), iface);
    LinkProperties want = linkproperties(links(addresses), routes(prefixes));
    want.setInterfaceName(iface);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).onProvisioningSuccess(argThat(lp -> fromStableParcelable(lp).equals(want)));
    verifyNetworkAttributesStored(l2Key, new NetworkAttributes.Builder().setGroupHint(groupHint).build());
    ipc.shutdown();
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceSetEnableIPv6(iface, false);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceClearAddrs(iface);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).onLinkPropertiesChange(argThat(lp -> fromStableParcelable(lp).equals(makeEmptyLinkProperties(iface))));
    verifyNoMoreInteractions(mIpMemoryStore);
}
#method_after
@Test
public void testProvisioningWithInitialConfiguration() throws Exception {
    final String iface = TEST_IFNAME;
    final IpClient ipc = makeIpClient(iface);
    final String l2Key = TEST_L2KEY;
    final String groupHint = TEST_GROUPHINT;
    String[] addresses = { "fe80::a4be:f92:e1f7:22d1/64", "fe80::f04a:8f6:6a32:d756/64", "fd2c:4e57:8e3c:0:548d:2db2:4fcf:ef75/64" };
    String[] prefixes = { "fe80::/64", "fd2c:4e57:8e3c::/64" };
    ProvisioningConfiguration config = new ProvisioningConfiguration.Builder().withoutIPv4().withoutIpReachabilityMonitor().withInitialConfiguration(conf(links(addresses), prefixes(prefixes), ips())).build();
    ipc.startProvisioning(config);
    verify(mCb, times(1)).setNeighborDiscoveryOffload(true);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).setFallbackMulticastFilter(false);
    verify(mCb, never()).onProvisioningFailure(any());
    ipc.setL2KeyAndGroupHint(l2Key, groupHint);
    for (String addr : addresses) {
        String[] parts = addr.split("/");
        verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceAddAddress(iface, parts[0], Integer.parseInt(parts[1]));
    }
    final int lastAddr = addresses.length - 1;
    // Add N - 1 addresses
    for (int i = 0; i < lastAddr; i++) {
        mObserver.onInterfaceAddressUpdated(new LinkAddress(addresses[i]), iface);
        verify(mCb, timeout(TEST_TIMEOUT_MS)).onLinkPropertiesChange(any());
        reset(mCb);
    }
    // Add Nth address
    mObserver.onInterfaceAddressUpdated(new LinkAddress(addresses[lastAddr]), iface);
    LinkProperties want = linkproperties(links(addresses), routes(prefixes));
    want.setInterfaceName(iface);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).onProvisioningSuccess(want);
    verifyNetworkAttributesStored(l2Key, new NetworkAttributes.Builder().setGroupHint(groupHint).build());
    ipc.shutdown();
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceSetEnableIPv6(iface, false);
    verify(mNetd, timeout(TEST_TIMEOUT_MS).times(1)).interfaceClearAddrs(iface);
    verify(mCb, timeout(TEST_TIMEOUT_MS).times(1)).onLinkPropertiesChange(makeEmptyLinkProperties(iface));
    verifyNoMoreInteractions(mIpMemoryStore);
}
#end_block

#method_before
@Override
void generateFilterLocked(ApfGenerator gen) throws IllegalInstructionException {
    final String nextFilterLabel = "keepalive_ack" + getUniqueNumberLocked();
    gen.addLoad8(Register.R0, IPV4_PROTOCOL_OFFSET);
    gen.addJumpIfR0NotEquals(IPPROTO_TCP, nextFilterLabel);
    gen.addLoadImmediate(Register.R0, ETH_HEADER_LEN + IPV4_SRC_ADDR_OFFSET);
    gen.addJumpIfBytesNotEqual(Register.R0, mSrcDstAddr, nextFilterLabel);
    // Pass the packet if it's not zero-sized :
    // Load the IP header size into R1
    gen.addLoadFromMemory(Register.R1, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
    // Load the TCP header size into R0 (it's indexed by R1)
    gen.addLoad8Indexed(Register.R0, ETH_HEADER_LEN + TCP_HEADER_SIZE_OFFSET);
    // Size offset is in the top nibble, but it must be multiplied by 4, and the two
    // top bits of the low nibble are guaranteed to be zeroes. Right-shift R0 by 2.
    gen.addRightShift(2);
    // R0 += R1 -> R0 contains TCP + IP headers lenght
    gen.addAddR1();
    // Add the Ethernet header length to R0.
    gen.addLoadImmediate(Register.R1, ETH_HEADER_LEN);
    gen.addAddR1();
    // Compare total length of headers to the size of the packet.
    gen.addLoadFromMemory(Register.R1, gen.PACKET_SIZE_MEMORY_SLOT);
    gen.addNeg(Register.R0);
    gen.addAddR1();
    gen.addJumpIfR0NotEquals(0, nextFilterLabel);
    // Add IPv4 header length
    gen.addLoadFromMemory(Register.R1, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
    gen.addLoad16Indexed(Register.R0, ETH_HEADER_LEN + IPV4_TCP_SRC_PORT_OFFSET);
    gen.addJumpIfR0NotEquals(mPacket.srcPort, nextFilterLabel);
    gen.addLoad16Indexed(Register.R0, ETH_HEADER_LEN + IPV4_TCP_DST_PORT_OFFSET);
    gen.addJumpIfR0NotEquals(mPacket.dstPort, nextFilterLabel);
    gen.addLoad32Indexed(Register.R0, ETH_HEADER_LEN + IPV4_TCP_SEQ_OFFSET);
    gen.addJumpIfR0NotEquals(mPacket.seq, nextFilterLabel);
    gen.addLoad32Indexed(Register.R0, ETH_HEADER_LEN + IPV4_TCP_ACK_OFFSET);
    gen.addJumpIfR0NotEquals(mPacket.ack, nextFilterLabel);
    maybeSetupCounter(gen, Counter.DROPPED_IPV4_KEEPALIVE_ACK);
    gen.addJump(mCountAndDropLabel);
    gen.defineLabel(nextFilterLabel);
}
#method_after
@Override
void generateFilterLocked(ApfGenerator gen) throws IllegalInstructionException {
    final String nextFilterLabel = "keepalive_ack" + getUniqueNumberLocked();
    gen.addLoadImmediate(Register.R0, ETH_HEADER_LEN + IPV4_SRC_ADDR_OFFSET);
    gen.addJumpIfBytesNotEqual(Register.R0, mSrcDstAddr, nextFilterLabel);
    // Skip to the next filter if it's not zero-sized :
    // TCP_HEADER_SIZE + IPV4_HEADER_SIZE - ipv4_total_length == 0
    // Load the IP header size into R1
    gen.addLoadFromMemory(Register.R1, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
    // Load the TCP header size into R0 (it's indexed by R1)
    gen.addLoad8Indexed(Register.R0, ETH_HEADER_LEN + TCP_HEADER_SIZE_OFFSET);
    // Size offset is in the top nibble, but it must be multiplied by 4, and the two
    // top bits of the low nibble are guaranteed to be zeroes. Right-shift R0 by 2.
    gen.addRightShift(2);
    // R0 += R1 -> R0 contains TCP + IP headers length
    gen.addAddR1();
    // Load IPv4 total length
    gen.addLoad16(Register.R1, IPV4_TOTAL_LENGTH_OFFSET);
    gen.addNeg(Register.R0);
    gen.addAddR1();
    gen.addJumpIfR0NotEquals(0, nextFilterLabel);
    // Add IPv4 header length
    gen.addLoadFromMemory(Register.R1, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
    gen.addLoadImmediate(Register.R0, ETH_HEADER_LEN);
    gen.addAddR1();
    gen.addJumpIfBytesNotEqual(Register.R0, mPortSeqAckFingerprint, nextFilterLabel);
    maybeSetupCounter(gen, Counter.DROPPED_IPV4_KEEPALIVE_ACK);
    gen.addJump(mCountAndDropLabel);
    gen.defineLabel(nextFilterLabel);
}
#end_block

#method_before
@GuardedBy("this")
private void generateIPv4FilterLocked(ApfGenerator gen) throws IllegalInstructionException {
    if (mMulticastFilter) {
        final String skipDhcpv4Filter = "skip_dhcp_v4_filter";
        // Pass DHCP addressed to us.
        // Check it's UDP.
        gen.addLoad8(Register.R0, IPV4_PROTOCOL_OFFSET);
        gen.addJumpIfR0NotEquals(IPPROTO_UDP, skipDhcpv4Filter);
        // Check it's not a fragment. This matches the BPF filter installed by the DHCP client.
        gen.addLoad16(Register.R0, IPV4_FRAGMENT_OFFSET_OFFSET);
        gen.addJumpIfR0AnyBitsSet(IPV4_FRAGMENT_OFFSET_MASK, skipDhcpv4Filter);
        // Check it's addressed to DHCP client port.
        gen.addLoadFromMemory(Register.R1, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
        gen.addLoad16Indexed(Register.R0, UDP_DESTINATION_PORT_OFFSET);
        gen.addJumpIfR0NotEquals(DHCP_CLIENT_PORT, skipDhcpv4Filter);
        // Check it's DHCP to our MAC address.
        gen.addLoadImmediate(Register.R0, DHCP_CLIENT_MAC_OFFSET);
        // NOTE: Relies on R1 containing IPv4 header offset.
        gen.addAddR1();
        gen.addJumpIfBytesNotEqual(Register.R0, mHardwareAddress, skipDhcpv4Filter);
        maybeSetupCounter(gen, Counter.PASSED_DHCP);
        gen.addJump(mCountAndPassLabel);
        // Drop all multicasts/broadcasts.
        gen.defineLabel(skipDhcpv4Filter);
        // If IPv4 destination address is in multicast range, drop.
        gen.addLoad8(Register.R0, IPV4_DEST_ADDR_OFFSET);
        gen.addAnd(0xf0);
        maybeSetupCounter(gen, Counter.DROPPED_IPV4_MULTICAST);
        gen.addJumpIfR0Equals(0xe0, mCountAndDropLabel);
        // If IPv4 broadcast packet, drop regardless of L2 (b/30231088).
        maybeSetupCounter(gen, Counter.DROPPED_IPV4_BROADCAST_ADDR);
        gen.addLoad32(Register.R0, IPV4_DEST_ADDR_OFFSET);
        gen.addJumpIfR0Equals(IPV4_BROADCAST_ADDRESS, mCountAndDropLabel);
        if (mIPv4Address != null && mIPv4PrefixLength < 31) {
            maybeSetupCounter(gen, Counter.DROPPED_IPV4_BROADCAST_NET);
            int broadcastAddr = ipv4BroadcastAddress(mIPv4Address, mIPv4PrefixLength);
            gen.addJumpIfR0Equals(broadcastAddr, mCountAndDropLabel);
        }
        // If any keepalive filters,
        generateKeepaliveFilter(gen);
        // If L2 broadcast packet, drop.
        // TODO: can we invert this condition to fall through to the common pass case below?
        maybeSetupCounter(gen, Counter.PASSED_IPV4_UNICAST);
        gen.addLoadImmediate(Register.R0, ETH_DEST_ADDR_OFFSET);
        gen.addJumpIfBytesNotEqual(Register.R0, ETH_BROADCAST_MAC_ADDRESS, mCountAndPassLabel);
        maybeSetupCounter(gen, Counter.DROPPED_IPV4_L2_BROADCAST);
        gen.addJump(mCountAndDropLabel);
    } else {
        generateKeepaliveFilter(gen);
    }
    // Otherwise, pass
    maybeSetupCounter(gen, Counter.PASSED_IPV4);
    gen.addJump(mCountAndPassLabel);
}
#method_after
@GuardedBy("this")
private void generateIPv4FilterLocked(ApfGenerator gen) throws IllegalInstructionException {
    if (mMulticastFilter) {
        final String skipDhcpv4Filter = "skip_dhcp_v4_filter";
        // Pass DHCP addressed to us.
        // Check it's UDP.
        gen.addLoad8(Register.R0, IPV4_PROTOCOL_OFFSET);
        gen.addJumpIfR0NotEquals(IPPROTO_UDP, skipDhcpv4Filter);
        // Check it's not a fragment. This matches the BPF filter installed by the DHCP client.
        gen.addLoad16(Register.R0, IPV4_FRAGMENT_OFFSET_OFFSET);
        gen.addJumpIfR0AnyBitsSet(IPV4_FRAGMENT_OFFSET_MASK, skipDhcpv4Filter);
        // Check it's addressed to DHCP client port.
        gen.addLoadFromMemory(Register.R1, gen.IPV4_HEADER_SIZE_MEMORY_SLOT);
        gen.addLoad16Indexed(Register.R0, UDP_DESTINATION_PORT_OFFSET);
        gen.addJumpIfR0NotEquals(DHCP_CLIENT_PORT, skipDhcpv4Filter);
        // Check it's DHCP to our MAC address.
        gen.addLoadImmediate(Register.R0, DHCP_CLIENT_MAC_OFFSET);
        // NOTE: Relies on R1 containing IPv4 header offset.
        gen.addAddR1();
        gen.addJumpIfBytesNotEqual(Register.R0, mHardwareAddress, skipDhcpv4Filter);
        maybeSetupCounter(gen, Counter.PASSED_DHCP);
        gen.addJump(mCountAndPassLabel);
        // Drop all multicasts/broadcasts.
        gen.defineLabel(skipDhcpv4Filter);
        // If IPv4 destination address is in multicast range, drop.
        gen.addLoad8(Register.R0, IPV4_DEST_ADDR_OFFSET);
        gen.addAnd(0xf0);
        maybeSetupCounter(gen, Counter.DROPPED_IPV4_MULTICAST);
        gen.addJumpIfR0Equals(0xe0, mCountAndDropLabel);
        // If IPv4 broadcast packet, drop regardless of L2 (b/30231088).
        maybeSetupCounter(gen, Counter.DROPPED_IPV4_BROADCAST_ADDR);
        gen.addLoad32(Register.R0, IPV4_DEST_ADDR_OFFSET);
        gen.addJumpIfR0Equals(IPV4_BROADCAST_ADDRESS, mCountAndDropLabel);
        if (mIPv4Address != null && mIPv4PrefixLength < 31) {
            maybeSetupCounter(gen, Counter.DROPPED_IPV4_BROADCAST_NET);
            int broadcastAddr = ipv4BroadcastAddress(mIPv4Address, mIPv4PrefixLength);
            gen.addJumpIfR0Equals(broadcastAddr, mCountAndDropLabel);
        }
        // If any keepalive filter matches, drop
        generateV4KeepaliveFilters(gen);
        // Otherwise, this is an IPv4 unicast, pass
        // If L2 broadcast packet, drop.
        // TODO: can we invert this condition to fall through to the common pass case below?
        maybeSetupCounter(gen, Counter.PASSED_IPV4_UNICAST);
        gen.addLoadImmediate(Register.R0, ETH_DEST_ADDR_OFFSET);
        gen.addJumpIfBytesNotEqual(Register.R0, ETH_BROADCAST_MAC_ADDRESS, mCountAndPassLabel);
        maybeSetupCounter(gen, Counter.DROPPED_IPV4_L2_BROADCAST);
        gen.addJump(mCountAndDropLabel);
    } else {
        generateV4KeepaliveFilters(gen);
    }
    // Otherwise, pass
    maybeSetupCounter(gen, Counter.PASSED_IPV4);
    gen.addJump(mCountAndPassLabel);
}
#end_block

#method_before
@GuardedBy("this")
private void generateIPv6FilterLocked(ApfGenerator gen) throws IllegalInstructionException {
    // Here's a basic summary of what the IPv6 filter program does:
    // 
    // if we're dropping multicast
    // if it's not IPCMv6 or it's ICMPv6 but we're in doze mode:
    // if it's multicast:
    // drop
    // pass
    // if it's ICMPv6 RS to any:
    // drop
    // if it's ICMPv6 NA to ff02::1:
    // drop
    // if keepalive ack
    // drop
    gen.addLoad8(Register.R0, IPV6_NEXT_HEADER_OFFSET);
    // Drop multicast if the multicast filter is enabled.
    if (mMulticastFilter) {
        final String skipIPv6MulticastFilterLabel = "skipIPv6MulticastFilter";
        final String dropAllIPv6MulticastsLabel = "dropAllIPv6Multicast";
        // While awake, let all ICMPv6 multicasts through.
        if (mInDozeMode) {
            // Not ICMPv6? -> Proceed to multicast filtering
            gen.addJumpIfR0NotEquals(IPPROTO_ICMPV6, dropAllIPv6MulticastsLabel);
            // ICMPv6 but not ECHO? -> Skip the multicast filter.
            // (ICMPv6 ECHO requests will go through the multicast filter below).
            gen.addLoad8(Register.R0, ICMP6_TYPE_OFFSET);
            gen.addJumpIfR0NotEquals(ICMPV6_ECHO_REQUEST_TYPE, skipIPv6MulticastFilterLabel);
        } else {
            gen.addJumpIfR0Equals(IPPROTO_ICMPV6, skipIPv6MulticastFilterLabel);
        }
        // Drop all other packets sent to ff00::/8 (multicast prefix).
        gen.defineLabel(dropAllIPv6MulticastsLabel);
        maybeSetupCounter(gen, Counter.DROPPED_IPV6_NON_ICMP_MULTICAST);
        gen.addLoad8(Register.R0, IPV6_DEST_ADDR_OFFSET);
        gen.addJumpIfR0Equals(0xff, mCountAndDropLabel);
        // Not multicast. Pass.
        maybeSetupCounter(gen, Counter.PASSED_IPV6_UNICAST_NON_ICMP);
        gen.addJump(mCountAndPassLabel);
        gen.defineLabel(skipIPv6MulticastFilterLabel);
    } else {
        // If not ICMPv6, pass.
        maybeSetupCounter(gen, Counter.PASSED_IPV6_NON_ICMP);
        gen.addJumpIfR0NotEquals(IPPROTO_ICMPV6, mCountAndPassLabel);
    }
    // If we got this far, the packet is ICMPv6.  Drop some specific types.
    // Add unsolicited multicast neighbor announcements filter
    String skipUnsolicitedMulticastNALabel = "skipUnsolicitedMulticastNA";
    gen.addLoad8(Register.R0, ICMP6_TYPE_OFFSET);
    // Drop all router solicitations (b/32833400)
    maybeSetupCounter(gen, Counter.DROPPED_IPV6_ROUTER_SOLICITATION);
    gen.addJumpIfR0Equals(ICMPV6_ROUTER_SOLICITATION, mCountAndDropLabel);
    // If not neighbor announcements, skip filter.
    gen.addJumpIfR0NotEquals(ICMPV6_NEIGHBOR_ADVERTISEMENT, skipUnsolicitedMulticastNALabel);
    // If to ff02::1, drop.
    // TODO: Drop only if they don't contain the address of on-link neighbours.
    gen.addLoadImmediate(Register.R0, IPV6_DEST_ADDR_OFFSET);
    gen.addJumpIfBytesNotEqual(Register.R0, IPV6_ALL_NODES_ADDRESS, skipUnsolicitedMulticastNALabel);
    maybeSetupCounter(gen, Counter.DROPPED_IPV6_MULTICAST_NA);
    gen.addJump(mCountAndDropLabel);
    gen.defineLabel(skipUnsolicitedMulticastNALabel);
    // Drop IPv6 Keepalive acks
    for (int i = 0; i < mKeepaliveAcks.size(); ++i) {
        final TcpKeepaliveAck ack = mKeepaliveAcks.valueAt(i);
        if (ack instanceof TcpKeepaliveAckV6)
            ack.generateFilterLocked(gen);
    }
}
#method_after
@GuardedBy("this")
private void generateIPv6FilterLocked(ApfGenerator gen) throws IllegalInstructionException {
    // Here's a basic summary of what the IPv6 filter program does:
    // 
    // if we're dropping multicast
    // if it's not IPCMv6 or it's ICMPv6 but we're in doze mode:
    // if it's multicast:
    // drop
    // pass
    // if it's ICMPv6 RS to any:
    // drop
    // if it's ICMPv6 NA to ff02::1:
    // drop
    // if keepalive ack
    // drop
    gen.addLoad8(Register.R0, IPV6_NEXT_HEADER_OFFSET);
    // Drop multicast if the multicast filter is enabled.
    if (mMulticastFilter) {
        final String skipIPv6MulticastFilterLabel = "skipIPv6MulticastFilter";
        final String dropAllIPv6MulticastsLabel = "dropAllIPv6Multicast";
        // While awake, let all ICMPv6 multicasts through.
        if (mInDozeMode) {
            // Not ICMPv6? -> Proceed to multicast filtering
            gen.addJumpIfR0NotEquals(IPPROTO_ICMPV6, dropAllIPv6MulticastsLabel);
            // ICMPv6 but not ECHO? -> Skip the multicast filter.
            // (ICMPv6 ECHO requests will go through the multicast filter below).
            gen.addLoad8(Register.R0, ICMP6_TYPE_OFFSET);
            gen.addJumpIfR0NotEquals(ICMPV6_ECHO_REQUEST_TYPE, skipIPv6MulticastFilterLabel);
        } else {
            gen.addJumpIfR0Equals(IPPROTO_ICMPV6, skipIPv6MulticastFilterLabel);
        }
        // Drop all other packets sent to ff00::/8 (multicast prefix).
        gen.defineLabel(dropAllIPv6MulticastsLabel);
        maybeSetupCounter(gen, Counter.DROPPED_IPV6_NON_ICMP_MULTICAST);
        gen.addLoad8(Register.R0, IPV6_DEST_ADDR_OFFSET);
        gen.addJumpIfR0Equals(0xff, mCountAndDropLabel);
        // If any keepalive filter matches, drop
        generateV6KeepaliveFilters(gen);
        // Not multicast. Pass.
        maybeSetupCounter(gen, Counter.PASSED_IPV6_UNICAST_NON_ICMP);
        gen.addJump(mCountAndPassLabel);
        gen.defineLabel(skipIPv6MulticastFilterLabel);
    } else {
        generateV6KeepaliveFilters(gen);
        // If not ICMPv6, pass.
        maybeSetupCounter(gen, Counter.PASSED_IPV6_NON_ICMP);
        gen.addJumpIfR0NotEquals(IPPROTO_ICMPV6, mCountAndPassLabel);
    }
    // If we got this far, the packet is ICMPv6.  Drop some specific types.
    // Add unsolicited multicast neighbor announcements filter
    String skipUnsolicitedMulticastNALabel = "skipUnsolicitedMulticastNA";
    gen.addLoad8(Register.R0, ICMP6_TYPE_OFFSET);
    // Drop all router solicitations (b/32833400)
    maybeSetupCounter(gen, Counter.DROPPED_IPV6_ROUTER_SOLICITATION);
    gen.addJumpIfR0Equals(ICMPV6_ROUTER_SOLICITATION, mCountAndDropLabel);
    // If not neighbor announcements, skip filter.
    gen.addJumpIfR0NotEquals(ICMPV6_NEIGHBOR_ADVERTISEMENT, skipUnsolicitedMulticastNALabel);
    // If to ff02::1, drop.
    // TODO: Drop only if they don't contain the address of on-link neighbours.
    gen.addLoadImmediate(Register.R0, IPV6_DEST_ADDR_OFFSET);
    gen.addJumpIfBytesNotEqual(Register.R0, IPV6_ALL_NODES_ADDRESS, skipUnsolicitedMulticastNALabel);
    maybeSetupCounter(gen, Counter.DROPPED_IPV6_MULTICAST_NA);
    gen.addJump(mCountAndDropLabel);
    gen.defineLabel(skipUnsolicitedMulticastNALabel);
}
#end_block

#method_before
public synchronized void dump(IndentingPrintWriter pw) {
    pw.println("Capabilities: " + mApfCapabilities);
    pw.println("Receive thread: " + (mReceiveThread != null ? "RUNNING" : "STOPPED"));
    pw.println("Multicast: " + (mMulticastFilter ? "DROP" : "ALLOW"));
    try {
        pw.println("IPv4 address: " + InetAddress.getByAddress(mIPv4Address).getHostAddress());
    } catch (UnknownHostException | NullPointerException e) {
    }
    if (mLastTimeInstalledProgram == 0) {
        pw.println("No program installed.");
        return;
    }
    pw.println("Program updates: " + mNumProgramUpdates);
    pw.println(String.format("Last program length %d, installed %ds ago, lifetime %ds", mLastInstalledProgram.length, currentTimeSeconds() - mLastTimeInstalledProgram, mLastInstalledProgramMinLifetime));
    pw.println("RA filters:");
    pw.increaseIndent();
    for (Ra ra : mRas) {
        pw.println(ra);
        pw.increaseIndent();
        pw.println(String.format("Seen: %d, last %ds ago", ra.seenCount, currentTimeSeconds() - ra.mLastSeen));
        if (DBG) {
            pw.println("Last match:");
            pw.increaseIndent();
            pw.println(ra.getLastMatchingPacket());
            pw.decreaseIndent();
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println("Keepalive filter:");
    pw.increaseIndent();
    for (int i = 0; i < mKeepaliveAcks.size(); ++i) {
        final TcpKeepaliveAck keepaliveAck = mKeepaliveAcks.valueAt(i);
        pw.print("Slot ");
        pw.print(mKeepaliveAcks.keyAt(i));
        pw.print(" : ");
        pw.println(keepaliveAck);
    }
    pw.decreaseIndent();
    if (DBG) {
        pw.println("Last program:");
        pw.increaseIndent();
        pw.println(HexDump.toHexString(mLastInstalledProgram, false));
        pw.decreaseIndent();
    }
    pw.println("APF packet counters: ");
    pw.increaseIndent();
    if (!mApfCapabilities.hasDataAccess()) {
        pw.println("APF counters not supported");
    } else if (mDataSnapshot == null) {
        pw.println("No last snapshot.");
    } else {
        try {
            Counter[] counters = Counter.class.getEnumConstants();
            for (Counter c : Arrays.asList(counters).subList(1, counters.length)) {
                long value = counterValue(mDataSnapshot, c);
                // Only print non-zero counters
                if (value != 0) {
                    pw.println(c.toString() + ": " + value);
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("Uh-oh: " + e);
        }
        if (VDBG) {
            pw.println("Raw data dump: ");
            pw.println(HexDump.dumpHexString(mDataSnapshot));
        }
    }
    pw.decreaseIndent();
}
#method_after
public synchronized void dump(IndentingPrintWriter pw) {
    pw.println("Capabilities: " + mApfCapabilities);
    pw.println("Receive thread: " + (mReceiveThread != null ? "RUNNING" : "STOPPED"));
    pw.println("Multicast: " + (mMulticastFilter ? "DROP" : "ALLOW"));
    try {
        pw.println("IPv4 address: " + InetAddress.getByAddress(mIPv4Address).getHostAddress());
    } catch (UnknownHostException | NullPointerException e) {
    }
    if (mLastTimeInstalledProgram == 0) {
        pw.println("No program installed.");
        return;
    }
    pw.println("Program updates: " + mNumProgramUpdates);
    pw.println(String.format("Last program length %d, installed %ds ago, lifetime %ds", mLastInstalledProgram.length, currentTimeSeconds() - mLastTimeInstalledProgram, mLastInstalledProgramMinLifetime));
    pw.println("RA filters:");
    pw.increaseIndent();
    for (Ra ra : mRas) {
        pw.println(ra);
        pw.increaseIndent();
        pw.println(String.format("Seen: %d, last %ds ago", ra.seenCount, currentTimeSeconds() - ra.mLastSeen));
        if (DBG) {
            pw.println("Last match:");
            pw.increaseIndent();
            pw.println(ra.getLastMatchingPacket());
            pw.decreaseIndent();
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println("Keepalive filters:");
    pw.increaseIndent();
    for (int i = 0; i < mKeepaliveAcks.size(); ++i) {
        final TcpKeepaliveAck keepaliveAck = mKeepaliveAcks.valueAt(i);
        pw.print("Slot ");
        pw.print(mKeepaliveAcks.keyAt(i));
        pw.print(" : ");
        pw.println(keepaliveAck);
    }
    pw.decreaseIndent();
    if (DBG) {
        pw.println("Last program:");
        pw.increaseIndent();
        pw.println(HexDump.toHexString(mLastInstalledProgram, false));
        pw.decreaseIndent();
    }
    pw.println("APF packet counters: ");
    pw.increaseIndent();
    if (!mApfCapabilities.hasDataAccess()) {
        pw.println("APF counters not supported");
    } else if (mDataSnapshot == null) {
        pw.println("No last snapshot.");
    } else {
        try {
            Counter[] counters = Counter.class.getEnumConstants();
            for (Counter c : Arrays.asList(counters).subList(1, counters.length)) {
                long value = counterValue(mDataSnapshot, c);
                // Only print non-zero counters
                if (value != 0) {
                    pw.println(c.toString() + ": " + value);
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("Uh-oh: " + e);
        }
        if (VDBG) {
            pw.println("Raw data dump: ");
            pw.println(HexDump.dumpHexString(mDataSnapshot));
        }
    }
    pw.decreaseIndent();
}
#end_block

#method_before
public static void addArpEntry(Inet4Address ipv4Addr, MacAddress ethAddr, String ifname, FileDescriptor fd) throws IOException {
    addArpEntry(ethAddr.toByteArray(), ipv4Addr.getAddress(), ifname, fd);
}
#method_after
public static void addArpEntry(Inet4Address ipv4Addr, android.net.MacAddress ethAddr, String ifname, FileDescriptor fd) throws IOException {
    addArpEntry(ethAddr.toByteArray(), ipv4Addr.getAddress(), ifname, fd);
}
#end_block

#method_before
public Drawable getDrawable() {
    return mDivider;
}
#method_after
@Nullable
public Drawable getDrawable() {
    return mDivider;
}
#end_block

#method_before
@Test
public void testOpenAndCloseUdpEncapsulationSocket() throws Exception {
    for (int i = 0; i < 3; i++) {
        int localport = findUnusedPort();
        IpSecUdpEncapResponse udpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
        assertNotNull(udpEncapResp);
        if (udpEncapResp.status == IpSecManager.Status.RESOURCE_UNAVAILABLE) {
            // Retry up to 3 times to reduce possibility for port-bind failures.
            continue;
        }
        assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
        assertEquals(localport, udpEncapResp.port);
        mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
        udpEncapResp.fileDescriptor.close();
        // Verify quota and RefcountedResource objects cleaned up
        IpSecService.UserRecord userRecord = mIpSecService.mUserResourceTracker.getUserRecord(Os.getuid());
        assertEquals(0, userRecord.mSocketQuotaTracker.mCurrent);
        try {
            userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(udpEncapResp.resourceId);
            fail("Expected IllegalArgumentException on attempt to access deleted resource");
        } catch (IllegalArgumentException expected) {
        }
        break;
    }
}
#method_after
@Test
public void testOpenAndCloseUdpEncapsulationSocket() throws Exception {
    int localport = -1;
    IpSecUdpEncapResponse udpEncapResp = null;
    for (int i = 0; i < IpSecService.MAX_PORT_BIND_ATTEMPTS; i++) {
        localport = findUnusedPort();
        udpEncapResp = mIpSecService.openUdpEncapsulationSocket(localport, new Binder());
        assertNotNull(udpEncapResp);
        if (udpEncapResp.status == IpSecManager.Status.OK) {
            break;
        }
    // Else retry to reduce possibility for port-bind failures.
    }
    assertNotNull(udpEncapResp);
    assertEquals(IpSecManager.Status.OK, udpEncapResp.status);
    assertEquals(localport, udpEncapResp.port);
    mIpSecService.closeUdpEncapsulationSocket(udpEncapResp.resourceId);
    udpEncapResp.fileDescriptor.close();
    // Verify quota and RefcountedResource objects cleaned up
    IpSecService.UserRecord userRecord = mIpSecService.mUserResourceTracker.getUserRecord(Os.getuid());
    assertEquals(0, userRecord.mSocketQuotaTracker.mCurrent);
    try {
        userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(udpEncapResp.resourceId);
        fail("Expected IllegalArgumentException on attempt to access deleted resource");
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
private static InetAddress[] lookupHostByName(String host, int netId) throws UnknownHostException {
    BlockGuard.getThreadPolicy().onNetwork();
    // Do we have a result cached?
    Object cachedResult = addressCache.get(host, netId);
    if (cachedResult != null) {
        if (cachedResult instanceof InetAddress[]) {
            // A cached positive result.
            return (InetAddress[]) cachedResult;
        } else {
            // A cached negative result.
            throw new UnknownHostException((String) cachedResult);
        }
    }
    try {
        StructAddrinfo hints = new StructAddrinfo();
        hints.ai_flags = AI_ADDRCONFIG;
        hints.ai_family = AF_UNSPEC;
        // If we don't specify a socket type, every address will appear twice, once
        // for SOCK_STREAM and one for SOCK_DGRAM. Since we do not return the family
        // anyway, just pick one.
        hints.ai_socktype = SOCK_STREAM;
        InetAddress[] addresses = Libcore.os.android_getaddrinfo(host, hints, netId);
        // TODO: should getaddrinfo set the hostname of the InetAddresses it returns?
        for (InetAddress address : addresses) {
            address.holder().hostName = host;
            address.holder().originalHostName = host;
        }
        addressCache.put(host, netId, addresses);
        return addresses;
    } catch (GaiException gaiException) {
        // http://code.google.com/p/android/issues/detail?id=15722
        if (gaiException.getCause() instanceof ErrnoException) {
            if (((ErrnoException) gaiException.getCause()).errno == EACCES || ((ErrnoException) gaiException.getCause()).errno == EPERM) {
                throw new SecurityException("Permission denied (missing INTERNET permission?)", gaiException);
            }
        }
        // Otherwise, throw an UnknownHostException.
        String detailMessage = "Unable to resolve host \"" + host + "\": " + Libcore.os.gai_strerror(gaiException.error);
        addressCache.putUnknownHost(host, netId, detailMessage);
        throw gaiException.rethrowAsUnknownHostException(detailMessage);
    }
}
#method_after
private static InetAddress[] lookupHostByName(String host, int netId) throws UnknownHostException {
    BlockGuard.getThreadPolicy().onNetwork();
    // Do we have a result cached?
    Object cachedResult = addressCache.get(host, netId);
    if (cachedResult != null) {
        if (cachedResult instanceof InetAddress[]) {
            // A cached positive result.
            return (InetAddress[]) cachedResult;
        } else {
            // A cached negative result.
            throw new UnknownHostException((String) cachedResult);
        }
    }
    try {
        StructAddrinfo hints = new StructAddrinfo();
        hints.ai_flags = AI_ADDRCONFIG;
        hints.ai_family = AF_UNSPEC;
        // If we don't specify a socket type, every address will appear twice, once
        // for SOCK_STREAM and one for SOCK_DGRAM. Since we do not return the family
        // anyway, just pick one.
        hints.ai_socktype = SOCK_STREAM;
        InetAddress[] addresses = Libcore.os.android_getaddrinfo(host, hints, netId);
        // TODO: should getaddrinfo set the hostname of the InetAddresses it returns?
        for (InetAddress address : addresses) {
            address.holder().hostName = host;
            address.holder().originalHostName = host;
        }
        addressCache.put(host, netId, addresses);
        return addresses;
    } catch (GaiException gaiException) {
        // http://code.google.com/p/android/issues/detail?id=15722
        if (gaiException.getCause() instanceof ErrnoException) {
            int errno = ((ErrnoException) gaiException.getCause()).errno;
            if (errno == EACCES || errno == EPERM) {
                throw new SecurityException("Permission denied (missing INTERNET permission?)", gaiException);
            }
        }
        // Otherwise, throw an UnknownHostException.
        String detailMessage = "Unable to resolve host \"" + host + "\": " + Libcore.os.gai_strerror(gaiException.error);
        addressCache.putUnknownHost(host, netId, detailMessage);
        throw gaiException.rethrowAsUnknownHostException(detailMessage);
    }
}
#end_block

#method_before
@NonNull
public Builder putByteArray(@NonNull String key, byte[] value) {
    mValues.put(key, convertPrimitiveByteArray(value));
    return this;
}
#method_after
@NonNull
public Builder putByteArray(@NonNull String key, @NonNull byte[] value) {
    mValues.put(key, convertPrimitiveByteArray(value));
    return this;
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@NonNull
public Builder put(@NonNull String key, @Nullable Object value) {
    if (value == null) {
        mValues.put(key, null);
    } else {
        Class valueType = value.getClass();
        if (valueType == Boolean.class || valueType == Byte.class || valueType == Integer.class || valueType == Long.class || valueType == Float.class || valueType == Double.class || valueType == String.class || valueType == Boolean[].class || valueType == Integer[].class || valueType == Long[].class || valueType == Float[].class || valueType == Double[].class || valueType == String[].class) {
            mValues.put(key, value);
        } else if (valueType == boolean[].class) {
            mValues.put(key, convertPrimitiveBooleanArray((boolean[]) value));
        } else if (valueType == byte[].class) {
            mValues.put(key, convertPrimitiveByteArray((byte[]) value));
        } else if (valueType == int[].class) {
            mValues.put(key, convertPrimitiveIntArray((int[]) value));
        } else if (valueType == long[].class) {
            mValues.put(key, convertPrimitiveLongArray((long[]) value));
        } else if (valueType == float[].class) {
            mValues.put(key, convertPrimitiveFloatArray((float[]) value));
        } else if (valueType == double[].class) {
            mValues.put(key, convertPrimitiveDoubleArray((double[]) value));
        } else {
            throw new IllegalArgumentException(String.format("Key %s has invalid type %s", key, valueType));
        }
    }
    return this;
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@NonNull
public Builder put(@NonNull String key, @Nullable Object value) {
    if (value == null) {
        mValues.put(key, null);
    } else {
        Class valueType = value.getClass();
        if (valueType == Boolean.class || valueType == Byte.class || valueType == Integer.class || valueType == Long.class || valueType == Float.class || valueType == Double.class || valueType == String.class || valueType == Boolean[].class || valueType == Byte[].class || valueType == Integer[].class || valueType == Long[].class || valueType == Float[].class || valueType == Double[].class || valueType == String[].class) {
            mValues.put(key, value);
        } else if (valueType == boolean[].class) {
            mValues.put(key, convertPrimitiveBooleanArray((boolean[]) value));
        } else if (valueType == byte[].class) {
            mValues.put(key, convertPrimitiveByteArray((byte[]) value));
        } else if (valueType == int[].class) {
            mValues.put(key, convertPrimitiveIntArray((int[]) value));
        } else if (valueType == long[].class) {
            mValues.put(key, convertPrimitiveLongArray((long[]) value));
        } else if (valueType == float[].class) {
            mValues.put(key, convertPrimitiveFloatArray((float[]) value));
        } else if (valueType == double[].class) {
            mValues.put(key, convertPrimitiveDoubleArray((double[]) value));
        } else {
            throw new IllegalArgumentException(String.format("Key %s has invalid type %s", key, valueType));
        }
    }
    return this;
}
#end_block

#method_before
@Override
public void onPackageAdded(String packageName, int uid) {
    final PackageInfo app = getPackageInfo(packageName);
    if (app == null) {
        Slog.wtf(TAG, "Failed to get information of installed package: " + packageName);
        return;
    }
    if (uid == INVALID_UID) {
        Slog.wtf(TAG, "Failed to get the uid of installed package: " + packageName + "uid: " + uid);
        return;
    }
    if (app.requestedPermissions == null) {
        return;
    }
    sendPackagePermissionsForUid(uid, getNetdPermissionMask(app.requestedPermissions));
}
#method_after
@Override
public void onPackageAdded(String packageName, int uid) {
    sendPackagePermissionsForUid(uid, getPermissionForUid(uid));
}
#end_block

#method_before
@Override
public void onPackageRemoved(String packageName, int uid) {
    int permission = 0;
    // If there are still packages remain under the same uid, check the permission of the
    // remaining packages. We only remove the permission for a given uid when all packages
    // for that uid no longer have that permission.
    String[] packages = mPackageManager.getPackagesForUid(uid);
    if (packages != null && packages.length > 0) {
        for (String name : packages) {
            final PackageInfo app = getPackageInfo(name);
            if (app != null && app.requestedPermissions != null) {
                permission |= getNetdPermissionMask(app.requestedPermissions);
            }
        }
    } else {
        // The last package of this uid is removed from device. Clean the package up.
        permission = INetd.PERMISSION_UNINSTALLED;
    }
    sendPackagePermissionsForUid(uid, permission);
}
#method_after
@Override
public void onPackageRemoved(String packageName, int uid) {
    sendPackagePermissionsForUid(uid, getPermissionForUid(uid));
}
#end_block

#method_before
// Intended to be called only once at startup, after the system is ready. Installs a broadcast
public synchronized void startMonitoring() {
    log("Monitoring");
    PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
    if (pmi != null) {
        pmi.getPackageList(new PackageListObserver());
    } else {
        loge("failed to get the PackageManagerInternal service");
    }
    List<PackageInfo> apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS | MATCH_ANY_USER);
    if (apps == null) {
        loge("No apps");
        return;
    }
    SparseIntArray netdPermsUids = new SparseIntArray();
    for (PackageInfo app : apps) {
        int uid = app.applicationInfo != null ? app.applicationInfo.uid : INVALID_UID;
        if (uid < 0) {
            continue;
        }
        boolean isNetwork = hasNetworkPermission(app);
        boolean hasRestrictedPermission = hasRestrictedNetworkPermission(app);
        if (isNetwork || hasRestrictedPermission) {
            Boolean permission = mApps.get(uid);
            // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
            if (permission == null || permission == NETWORK) {
                mApps.put(uid, hasRestrictedPermission);
            }
        }
        // TODO: unify the management of the permissions into one codepath.
        if (app.requestedPermissions != null) {
            int otherNetdPerms = getNetdPermissionMask(app.requestedPermissions);
            if (otherNetdPerms != 0) {
                netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);
            }
        }
    }
    // exclude dying users
    List<UserInfo> users = mUserManager.getUsers(true);
    if (users != null) {
        for (UserInfo user : users) {
            mUsers.add(user.id);
        }
    }
    log("Users: " + mUsers.size() + ", Apps: " + mApps.size());
    update(mUsers, mApps, true);
    sendPackagePermissionsToNetd(netdPermsUids);
}
#method_after
// Intended to be called only once at startup, after the system is ready. Installs a broadcast
public synchronized void startMonitoring() {
    log("Monitoring");
    PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
    if (pmi != null) {
        pmi.getPackageList(new PackageListObserver());
    } else {
        loge("failed to get the PackageManagerInternal service");
    }
    List<PackageInfo> apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS | MATCH_ANY_USER);
    if (apps == null) {
        loge("No apps");
        return;
    }
    SparseIntArray netdPermsUids = new SparseIntArray();
    for (PackageInfo app : apps) {
        int uid = app.applicationInfo != null ? app.applicationInfo.uid : INVALID_UID;
        if (uid < 0) {
            continue;
        }
        boolean isNetwork = hasNetworkPermission(app);
        boolean hasRestrictedPermission = hasRestrictedNetworkPermission(app);
        if (isNetwork || hasRestrictedPermission) {
            Boolean permission = mApps.get(uid);
            // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
            if (permission == null || permission == NETWORK) {
                mApps.put(uid, hasRestrictedPermission);
            }
        }
        // TODO: unify the management of the permissions into one codepath.
        int otherNetdPerms = getNetdPermissionMask(app.requestedPermissions, app.requestedPermissionsFlags);
        netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);
    }
    // exclude dying users
    List<UserInfo> users = mUserManager.getUsers(true);
    if (users != null) {
        for (UserInfo user : users) {
            mUsers.add(user.id);
        }
    }
    final SparseArray<ArraySet<String>> systemPermission = SystemConfig.getInstance().getSystemPermissions();
    for (int i = 0; i < systemPermission.size(); i++) {
        ArraySet<String> perms = systemPermission.valueAt(i);
        int uid = systemPermission.keyAt(i);
        int netdPermission = 0;
        // Get the uids of native services that have UPDATE_DEVICE_STATS permission.
        if (perms != null) {
            netdPermission |= perms.contains(UPDATE_DEVICE_STATS) ? INetd.PERMISSION_UPDATE_DEVICE_STATS : 0;
        }
        // For internet permission, the native services have their own selinux domains and
        // sepolicy will control the socket creation during run time. netd cannot block the
        // socket creation based on the permission information here.
        netdPermission |= INetd.PERMISSION_INTERNET;
        netdPermsUids.put(uid, netdPermsUids.get(uid) | netdPermission);
    }
    log("Users: " + mUsers.size() + ", Apps: " + mApps.size());
    update(mUsers, mApps, true);
    sendPackagePermissionsToNetd(netdPermsUids);
}
#end_block

#method_before
private static int getNetdPermissionMask(String[] requestedPermissions) {
    int permissions = 0;
    for (String permissionName : requestedPermissions) {
        if (permissionName.equals(INTERNET)) {
            permissions |= INetd.PERMISSION_INTERNET;
        }
        if (permissionName.equals(UPDATE_DEVICE_STATS)) {
            permissions |= INetd.PERMISSION_UPDATE_DEVICE_STATS;
        }
    }
    return permissions;
}
#method_after
private static int getNetdPermissionMask(String[] requestedPermissions, int[] requestedPermissionsFlags) {
    int permissions = 0;
    if (requestedPermissions == null || requestedPermissionsFlags == null)
        return permissions;
    for (int i = 0; i < requestedPermissions.length; i++) {
        if (requestedPermissions[i].equals(INTERNET) && ((requestedPermissionsFlags[i] & REQUESTED_PERMISSION_GRANTED) != 0)) {
            permissions |= INetd.PERMISSION_INTERNET;
        }
        if (requestedPermissions[i].equals(UPDATE_DEVICE_STATS) && ((requestedPermissionsFlags[i] & REQUESTED_PERMISSION_GRANTED) != 0)) {
            permissions |= INetd.PERMISSION_UPDATE_DEVICE_STATS;
        }
    }
    return permissions;
}
#end_block

#method_before
@Override
public NetworkStats getDetailedUidStats(String[] requiredIfaces) {
    try {
        // Get the latest snapshot from NetworkStatsFactory.
        NetworkStats uidDetailStats = getNetworkStatsUidDetail(INTERFACES_ALL);
        VpnInfo[] vpnArray = mConnManager.getAllVpnInfo();
        // Migrate traffic from VPN UID over delta and update mTunAdjustedStats.
        migrateTunTraffic(uidDetailStats, vpnArray);
        final String[] ifacesToQuery = NetworkStatsFactory.augmentWithStackedInterfaces(requiredIfaces);
        // Apply filter based on ifacesToQuery.
        NetworkStats result = getTunAdjustedStats();
        result.filter(UID_ALL, ifacesToQuery, TAG_ALL);
        return result;
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error compiling UID stats", e);
        return new NetworkStats(0L, 0);
    }
}
#method_after
@Override
public NetworkStats getDetailedUidStats(String[] requiredIfaces) {
    try {
        // Get the latest snapshot from NetworkStatsFactory.
        // TODO: Querying for INTERFACES_ALL may incur performance penalty. Consider restricting
        // this to limited set of ifaces.
        NetworkStats uidDetailStats = getNetworkStatsUidDetail(INTERFACES_ALL);
        // Migrate traffic from VPN UID over delta and update mTunAdjustedStats.
        NetworkStats result;
        synchronized (mStatsLock) {
            migrateTunTraffic(uidDetailStats, mVpnInfos);
            result = mTunAdjustedStats.clone();
        }
        // Apply filter based on ifacesToQuery.
        final String[] ifacesToQuery = NetworkStatsFactory.augmentWithStackedInterfaces(requiredIfaces);
        result.filter(UID_ALL, ifacesToQuery, TAG_ALL);
        return result;
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error compiling UID stats", e);
        return new NetworkStats(0L, 0);
    }
}
#end_block

#method_before
@VisibleForTesting
NetworkStats getTunAdjustedStats() {
    synchronized (mStatsLock) {
        if (mTunAdjustedStats == null) {
            // Shouldn't be null after #systemReady.
            return null;
        }
        return mTunAdjustedStats.clone();
    }
}
#method_after
@VisibleForTesting
NetworkStats getTunAdjustedStats() {
    synchronized (mStatsLock) {
        if (mTunAdjustedStats == null) {
            return null;
        }
        return mTunAdjustedStats.clone();
    }
}
#end_block

#method_before
@Override
public void forceUpdateIfaces(Network[] defaultNetworks) {
    mContext.enforceCallingOrSelfPermission(READ_NETWORK_USAGE_HISTORY, TAG);
    assertBandwidthControlEnabled();
    final long token = Binder.clearCallingIdentity();
    try {
        updateIfaces(defaultNetworks);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void forceUpdateIfaces(Network[] defaultNetworks, VpnInfo[] vpnArray, NetworkState[] networkStates, String activeIface) {
    mContext.enforceCallingOrSelfPermission(READ_NETWORK_USAGE_HISTORY, TAG);
    assertBandwidthControlEnabled();
    final long token = Binder.clearCallingIdentity();
    try {
        updateIfaces(defaultNetworks, vpnArray, networkStates, activeIface);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private void updateIfaces(Network[] defaultNetworks) {
    synchronized (mStatsLock) {
        mWakeLock.acquire();
        try {
            updateIfacesLocked(defaultNetworks);
        } finally {
            mWakeLock.release();
        }
    }
}
#method_after
private void updateIfaces(Network[] defaultNetworks, VpnInfo[] vpnArray, NetworkState[] networkStates, String activeIface) {
    synchronized (mStatsLock) {
        mWakeLock.acquire();
        try {
            mVpnInfos = vpnArray;
            mActiveIface = activeIface;
            updateIfacesLocked(defaultNetworks, networkStates);
        } finally {
            mWakeLock.release();
        }
    }
}
#end_block

#method_before
@GuardedBy("mStatsLock")
private void updateIfacesLocked(Network[] defaultNetworks) {
    if (!mSystemReady)
        return;
    if (LOGV)
        Slog.v(TAG, "updateIfacesLocked()");
    // take one last stats snapshot before updating iface mapping. this
    // isn't perfect, since the kernel may already be counting traffic from
    // the updated network.
    // poll, but only persist network stats to keep codepath fast. UID stats
    // will be persisted during next alarm poll event.
    performPollLocked(FLAG_PERSIST_NETWORK);
    final NetworkState[] states;
    final LinkProperties activeLink;
    try {
        states = mConnManager.getAllNetworkState();
        activeLink = mConnManager.getActiveLinkProperties();
    } catch (RemoteException e) {
        // ignored; service lives in system_server
        return;
    }
    mActiveIface = activeLink != null ? activeLink.getInterfaceName() : null;
    // Rebuild active interfaces based on connected networks
    mActiveIfaces.clear();
    mActiveUidIfaces.clear();
    if (defaultNetworks != null) {
        // Caller is ConnectivityService. Update the list of default networks.
        mDefaultNetworks = defaultNetworks;
    }
    final ArraySet<String> mobileIfaces = new ArraySet<>();
    for (NetworkState state : states) {
        if (state.networkInfo.isConnected()) {
            final boolean isMobile = isNetworkTypeMobile(state.networkInfo.getType());
            final boolean isDefault = ArrayUtils.contains(mDefaultNetworks, state.network);
            final NetworkIdentity ident = NetworkIdentity.buildNetworkIdentity(mContext, state, isDefault);
            // Traffic occurring on the base interface is always counted for
            // both total usage and UID details.
            final String baseIface = state.linkProperties.getInterfaceName();
            if (baseIface != null) {
                findOrCreateNetworkIdentitySet(mActiveIfaces, baseIface).add(ident);
                findOrCreateNetworkIdentitySet(mActiveUidIfaces, baseIface).add(ident);
                // per carrier's policy, modem will report 0 usage for VT calls.
                if (state.networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS) && !ident.getMetered()) {
                    // Copy the identify from IMS one but mark it as metered.
                    NetworkIdentity vtIdent = new NetworkIdentity(ident.getType(), ident.getSubType(), ident.getSubscriberId(), ident.getNetworkId(), ident.getRoaming(), true, /* metered */
                    true);
                    findOrCreateNetworkIdentitySet(mActiveIfaces, VT_INTERFACE).add(vtIdent);
                    findOrCreateNetworkIdentitySet(mActiveUidIfaces, VT_INTERFACE).add(vtIdent);
                }
                if (isMobile) {
                    mobileIfaces.add(baseIface);
                }
            }
            // Traffic occurring on stacked interfaces is usually clatd,
            // which is already accounted against its final egress interface
            // by the kernel. Thus, we only need to collect stacked
            // interface stats at the UID level.
            final List<LinkProperties> stackedLinks = state.linkProperties.getStackedLinks();
            for (LinkProperties stackedLink : stackedLinks) {
                final String stackedIface = stackedLink.getInterfaceName();
                if (stackedIface != null) {
                    findOrCreateNetworkIdentitySet(mActiveUidIfaces, stackedIface).add(ident);
                    if (isMobile) {
                        mobileIfaces.add(stackedIface);
                    }
                    NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
                }
            }
        }
    }
    mMobileIfaces = mobileIfaces.toArray(new String[mobileIfaces.size()]);
}
#method_after
@GuardedBy("mStatsLock")
private void updateIfacesLocked(Network[] defaultNetworks, NetworkState[] states) {
    if (!mSystemReady)
        return;
    if (LOGV)
        Slog.v(TAG, "updateIfacesLocked()");
    // take one last stats snapshot before updating iface mapping. this
    // isn't perfect, since the kernel may already be counting traffic from
    // the updated network.
    // poll, but only persist network stats to keep codepath fast. UID stats
    // will be persisted during next alarm poll event.
    performPollLocked(FLAG_PERSIST_NETWORK);
    // Rebuild active interfaces based on connected networks
    mActiveIfaces.clear();
    mActiveUidIfaces.clear();
    if (defaultNetworks != null) {
        // Caller is ConnectivityService. Update the list of default networks.
        mDefaultNetworks = defaultNetworks;
    }
    final ArraySet<String> mobileIfaces = new ArraySet<>();
    for (NetworkState state : states) {
        if (state.networkInfo.isConnected()) {
            final boolean isMobile = isNetworkTypeMobile(state.networkInfo.getType());
            final boolean isDefault = ArrayUtils.contains(mDefaultNetworks, state.network);
            final NetworkIdentity ident = NetworkIdentity.buildNetworkIdentity(mContext, state, isDefault);
            // Traffic occurring on the base interface is always counted for
            // both total usage and UID details.
            final String baseIface = state.linkProperties.getInterfaceName();
            if (baseIface != null) {
                findOrCreateNetworkIdentitySet(mActiveIfaces, baseIface).add(ident);
                findOrCreateNetworkIdentitySet(mActiveUidIfaces, baseIface).add(ident);
                // per carrier's policy, modem will report 0 usage for VT calls.
                if (state.networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS) && !ident.getMetered()) {
                    // Copy the identify from IMS one but mark it as metered.
                    NetworkIdentity vtIdent = new NetworkIdentity(ident.getType(), ident.getSubType(), ident.getSubscriberId(), ident.getNetworkId(), ident.getRoaming(), true, /* metered */
                    true);
                    findOrCreateNetworkIdentitySet(mActiveIfaces, VT_INTERFACE).add(vtIdent);
                    findOrCreateNetworkIdentitySet(mActiveUidIfaces, VT_INTERFACE).add(vtIdent);
                }
                if (isMobile) {
                    mobileIfaces.add(baseIface);
                }
            }
            // Traffic occurring on stacked interfaces is usually clatd,
            // which is already accounted against its final egress interface
            // by the kernel. Thus, we only need to collect stacked
            // interface stats at the UID level.
            final List<LinkProperties> stackedLinks = state.linkProperties.getStackedLinks();
            for (LinkProperties stackedLink : stackedLinks) {
                final String stackedIface = stackedLink.getInterfaceName();
                if (stackedIface != null) {
                    findOrCreateNetworkIdentitySet(mActiveUidIfaces, stackedIface).add(ident);
                    if (isMobile) {
                        mobileIfaces.add(stackedIface);
                    }
                    NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
                }
            }
        }
    }
    mMobileIfaces = mobileIfaces.toArray(new String[mobileIfaces.size()]);
}
#end_block

#method_before
@GuardedBy("mStatsLock")
private void recordSnapshotLocked(long currentTime) throws RemoteException {
    // snapshot and record current counters; read UID stats first to
    // avoid over counting dev stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotUid");
    final NetworkStats uidSnapshot = getNetworkStatsUidDetail(INTERFACES_ALL);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotXt");
    final NetworkStats xtSnapshot = getNetworkStatsXt();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotDev");
    final NetworkStats devSnapshot = mNetworkManager.getNetworkStatsSummaryDev();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // Tethering snapshot for dev and xt stats. Counts per-interface data from tethering stats
    // providers that isn't already counted by dev and XT stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotTether");
    final NetworkStats tetherSnapshot = getNetworkStatsTethering(STATS_PER_IFACE);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    xtSnapshot.combineAllValues(tetherSnapshot);
    devSnapshot.combineAllValues(tetherSnapshot);
    // For xt/dev, we pass a null VPN array because usage is aggregated by UID, so VPN traffic
    // can't be reattributed to responsible apps.
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordDev");
    mDevRecorder.recordSnapshotLocked(devSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordXt");
    mXtRecorder.recordSnapshotLocked(xtSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // For per-UID stats, pass the VPN info so VPN traffic is reattributed to responsible apps.
    VpnInfo[] vpnArray = mConnManager.getAllVpnInfo();
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUid");
    mUidRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUidTag");
    mUidTagRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // We need to make copies of member fields that are sent to the observer to avoid
    // a race condition between the service handler thread and the observer's
    mStatsObservers.updateStats(xtSnapshot, uidSnapshot, new ArrayMap<>(mActiveIfaces), new ArrayMap<>(mActiveUidIfaces), vpnArray, currentTime);
    migrateTunTraffic(uidSnapshot, vpnArray);
}
#method_after
@GuardedBy("mStatsLock")
private void recordSnapshotLocked(long currentTime) throws RemoteException {
    // snapshot and record current counters; read UID stats first to
    // avoid over counting dev stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotUid");
    final NetworkStats uidSnapshot = getNetworkStatsUidDetail(INTERFACES_ALL);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotXt");
    final NetworkStats xtSnapshot = getNetworkStatsXt();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotDev");
    final NetworkStats devSnapshot = mNetworkManager.getNetworkStatsSummaryDev();
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // Tethering snapshot for dev and xt stats. Counts per-interface data from tethering stats
    // providers that isn't already counted by dev and XT stats.
    Trace.traceBegin(TRACE_TAG_NETWORK, "snapshotTether");
    final NetworkStats tetherSnapshot = getNetworkStatsTethering(STATS_PER_IFACE);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    xtSnapshot.combineAllValues(tetherSnapshot);
    devSnapshot.combineAllValues(tetherSnapshot);
    // For xt/dev, we pass a null VPN array because usage is aggregated by UID, so VPN traffic
    // can't be reattributed to responsible apps.
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordDev");
    mDevRecorder.recordSnapshotLocked(devSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordXt");
    mXtRecorder.recordSnapshotLocked(xtSnapshot, mActiveIfaces, null, /* vpnArray */
    currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // For per-UID stats, pass the VPN info so VPN traffic is reattributed to responsible apps.
    VpnInfo[] vpnArray = mVpnInfos;
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUid");
    mUidRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    Trace.traceBegin(TRACE_TAG_NETWORK, "recordUidTag");
    mUidTagRecorder.recordSnapshotLocked(uidSnapshot, mActiveUidIfaces, vpnArray, currentTime);
    Trace.traceEnd(TRACE_TAG_NETWORK);
    // We need to make copies of member fields that are sent to the observer to avoid
    // a race condition between the service handler thread and the observer's
    mStatsObservers.updateStats(xtSnapshot, uidSnapshot, new ArrayMap<>(mActiveIfaces), new ArrayMap<>(mActiveUidIfaces), vpnArray, currentTime);
    migrateTunTraffic(uidSnapshot, vpnArray);
}
#end_block

#method_before
@GuardedBy("mStatsLock")
private void migrateTunTraffic(NetworkStats uidDetailStats, VpnInfo[] vpnInfoArray) {
    if (mTunAdjustedStats == null) {
        // Either system server crashed or device booted.
        // In either case initialize last snapshot from disk which could potentially be off by
        // [0, mPersistThreshold).
        mTunAdjustedStats = queryTunAdjustedStatsSinceBoot();
    }
    // Migrate delta traffic from VPN to other apps.
    NetworkStats delta = uidDetailStats.subtract(mTunAdjustedStats);
    for (VpnInfo info : vpnInfoArray) {
        for (String underlyingIface : info.underlyingIfaces) {
            delta.migrateTun(info.ownerUid, info.vpnIface, underlyingIface);
        }
    }
    // Add delta to last snapshot.
    mTunAdjustedStats.combineAllValues(delta);
}
#method_after
@GuardedBy("mStatsLock")
private void migrateTunTraffic(NetworkStats uidDetailStats, VpnInfo[] vpnInfoArray) {
    if (mTunAdjustedStats == null) {
        // Either device booted or system server restarted, hence traffic cannot be migrated
        // correctly without knowing the past state of VPN's underlying networks.
        mTunAdjustedStats = uidDetailStats;
        mLastUidDetailSnapshot = uidDetailStats;
        return;
    }
    // Migrate delta traffic from VPN to other apps.
    NetworkStats delta = uidDetailStats.subtract(mLastUidDetailSnapshot);
    for (VpnInfo info : vpnInfoArray) {
        delta.migrateTun(info.ownerUid, info.vpnIface, info.underlyingIfaces);
    }
    // Filter out debug entries as that may lead to over counting.
    delta.filterDebugEntries();
    // Update #mTunAdjustedStats with migrated delta.
    mTunAdjustedStats.combineAllValues(delta);
    mTunAdjustedStats.setElapsedRealtime(uidDetailStats.getElapsedRealtime());
    // Update last snapshot.
    mLastUidDetailSnapshot = uidDetailStats;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    final Context context = InstrumentationRegistry.getContext();
    mServiceContext = new BroadcastInterceptingContext(context);
    mStatsDir = context.getFilesDir();
    if (mStatsDir.exists()) {
        IoUtils.deleteContents(mStatsDir);
    }
    PowerManager powerManager = (PowerManager) mServiceContext.getSystemService(Context.POWER_SERVICE);
    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    mService = new NetworkStatsService(mServiceContext, mNetManager, mAlarmManager, wakeLock, mClock, TelephonyManager.getDefault(), mSettings, new NetworkStatsObservers(), mStatsDir, getBaseDir(mStatsDir));
    mHandlerThread = new HandlerThread("HandlerThread");
    mHandlerThread.start();
    Handler.Callback callback = new NetworkStatsService.HandlerCallback(mService);
    mHandler = new Handler(mHandlerThread.getLooper(), callback);
    mService.setHandler(mHandler, callback);
    mService.bindConnectivityManager(mConnManager);
    mElapsedRealtime = 0L;
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    assertNull(mService.getTunAdjustedStats());
    mService.systemReady();
    // Verify that system ready fetches realtime stats and initializes tun adjusted stats.
    verify(mNetManager).getNetworkStatsUidDetail(UID_ALL, INTERFACES_ALL);
    assertNotNull("failed to initialize TUN adjusted stats", mService.getTunAdjustedStats());
    assertEquals(0, mService.getTunAdjustedStats().size());
    mSession = mService.openSession();
    assertNotNull("openSession() failed", mSession);
    // catch INetworkManagementEventObserver during systemReady()
    ArgumentCaptor<INetworkManagementEventObserver> networkObserver = ArgumentCaptor.forClass(INetworkManagementEventObserver.class);
    verify(mNetManager).registerObserver(networkObserver.capture());
    mNetworkObserver = networkObserver.getValue();
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    final Context context = InstrumentationRegistry.getContext();
    mServiceContext = new BroadcastInterceptingContext(context);
    mStatsDir = context.getFilesDir();
    if (mStatsDir.exists()) {
        IoUtils.deleteContents(mStatsDir);
    }
    PowerManager powerManager = (PowerManager) mServiceContext.getSystemService(Context.POWER_SERVICE);
    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    mService = new NetworkStatsService(mServiceContext, mNetManager, mAlarmManager, wakeLock, mClock, TelephonyManager.getDefault(), mSettings, new NetworkStatsObservers(), mStatsDir, getBaseDir(mStatsDir));
    mHandlerThread = new HandlerThread("HandlerThread");
    mHandlerThread.start();
    Handler.Callback callback = new NetworkStatsService.HandlerCallback(mService);
    mHandler = new Handler(mHandlerThread.getLooper(), callback);
    mService.setHandler(mHandler, callback);
    mElapsedRealtime = 0L;
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    assertNull(mService.getTunAdjustedStats());
    mService.systemReady();
    // Verify that system ready fetches realtime stats and initializes tun adjusted stats.
    verify(mNetManager).getNetworkStatsUidDetail(UID_ALL, INTERFACES_ALL);
    assertNotNull("failed to initialize TUN adjusted stats", mService.getTunAdjustedStats());
    assertEquals(0, mService.getTunAdjustedStats().size());
    mSession = mService.openSession();
    assertNotNull("openSession() failed", mSession);
    // catch INetworkManagementEventObserver during systemReady()
    ArgumentCaptor<INetworkManagementEventObserver> networkObserver = ArgumentCaptor.forClass(INetworkManagementEventObserver.class);
    verify(mNetManager).registerObserver(networkObserver.capture());
    mNetworkObserver = networkObserver.getValue();
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    IoUtils.deleteContents(mStatsDir);
    mServiceContext = null;
    mStatsDir = null;
    mNetManager = null;
    mSettings = null;
    mConnManager = null;
    mSession.close();
    mService = null;
}
#method_after
@After
public void tearDown() throws Exception {
    IoUtils.deleteContents(mStatsDir);
    mServiceContext = null;
    mStatsDir = null;
    mNetManager = null;
    mSettings = null;
    mSession.close();
    mService = null;
}
#end_block

#method_before
@Test
public void testNetworkStatsWifi() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // and bump forward again, with counters going higher. this is
    // important, since polling should correctly subtract last snapshot.
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096L, 4L, 8192L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096L, 4L, 8192L, 8L, 0);
}
#method_after
@Test
public void testNetworkStatsWifi() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // and bump forward again, with counters going higher. this is
    // important, since polling should correctly subtract last snapshot.
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096L, 4L, 8192L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096L, 4L, 8192L, 8L, 0);
}
#end_block

#method_before
@Test
public void testStatsRebootPersist() throws Exception {
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 8L, 2048L, 16L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 0L));
    mService.setUidForeground(UID_RED, false);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 4);
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 6);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
    // graceful shutdown system, which should trigger persist of stats, and
    // clear any values in memory.
    expectDefaultSettings();
    mServiceContext.sendBroadcast(new Intent(Intent.ACTION_SHUTDOWN));
    assertStatsFilesExist(true);
    // boot through serviceReady() again
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    mService.systemReady();
    // after systemReady(), we should have historical stats loaded again
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
}
#method_after
@Test
public void testStatsRebootPersist() throws Exception {
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 8L, 2048L, 16L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 0L));
    mService.setUidForeground(UID_RED, false);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 4);
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 6);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
    // graceful shutdown system, which should trigger persist of stats, and
    // clear any values in memory.
    expectDefaultSettings();
    mServiceContext.sendBroadcast(new Intent(Intent.ACTION_SHUTDOWN));
    assertStatsFilesExist(true);
    // boot through serviceReady() again
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    mService.systemReady();
    // after systemReady(), we should have historical stats loaded again
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
}
#end_block

#method_before
@Test
@Ignore
public void testStatsBucketResize() throws Exception {
    NetworkStatsHistory history = null;
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(2 * HOUR_IN_MILLIS);
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 512L, 4L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(HOUR_IN_MILLIS, history.getBucketDuration());
    assertEquals(2, history.size());
    // now change bucket duration setting and trigger another poll with
    // exact same values, which should resize existing buckets.
    expectSettings(0L, 30 * MINUTE_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify identical stats, but spread across 4 buckets now
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(30 * MINUTE_IN_MILLIS, history.getBucketDuration());
    assertEquals(4, history.size());
}
#method_after
@Test
@Ignore
public void testStatsBucketResize() throws Exception {
    NetworkStatsHistory history = null;
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(2 * HOUR_IN_MILLIS);
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 512L, 4L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(HOUR_IN_MILLIS, history.getBucketDuration());
    assertEquals(2, history.size());
    // now change bucket duration setting and trigger another poll with
    // exact same values, which should resize existing buckets.
    expectSettings(0L, 30 * MINUTE_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify identical stats, but spread across 4 buckets now
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(30 * MINUTE_IN_MILLIS, history.getBucketDuration());
    assertEquals(4, history.size());
}
#end_block

#method_before
@Test
public void testUidStatsAcrossNetworks() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // create some traffic on first network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // now switch networks; this also tests that we're okay with interfaces
    // disappearing, to verify we don't count backwards.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_2));
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2176L, 17L, 1536L, 12L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 640L, 5L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xFAAD, 128L, 1L, 1024L, 8L, 0L));
    mService.incrementOperationCount(UID_BLUE, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify original history still intact
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // and verify new history also recorded under different template, which
    // verifies that we didn't cross the streams.
    assertNetworkTotal(sTemplateImsi2, 128L, 1L, 1024L, 8L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi2, UID_BLUE, 128L, 1L, 1024L, 8L, 10);
}
#method_after
@Test
public void testUidStatsAcrossNetworks() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic on first network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // now switch networks; this also tests that we're okay with interfaces
    // disappearing, to verify we don't count backwards.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    states = new NetworkState[] { buildMobile3gState(IMSI_2) };
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2176L, 17L, 1536L, 12L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 640L, 5L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xFAAD, 128L, 1L, 1024L, 8L, 0L));
    mService.incrementOperationCount(UID_BLUE, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify original history still intact
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // and verify new history also recorded under different template, which
    // verifies that we didn't cross the streams.
    assertNetworkTotal(sTemplateImsi2, 128L, 1L, 1024L, 8L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi2, UID_BLUE, 128L, 1L, 1024L, 8L, 10);
}
#end_block

#method_before
@Test
public void testUidRemovedIsMoved() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 16L, 1L, 16L, 1L, 10);
    assertUidTotal(sTemplateWifi, UID_BLUE, 4096L, 258L, 512L, 32L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    // now pretend two UIDs are uninstalled, which should migrate stats to
    // special "removed" bucket.
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    final Intent intent = new Intent(ACTION_UID_REMOVED);
    intent.putExtra(EXTRA_UID, UID_BLUE);
    mServiceContext.sendBroadcast(intent);
    intent.putExtra(EXTRA_UID, UID_RED);
    mServiceContext.sendBroadcast(intent);
    // existing uid and total should remain unchanged; but removed UID
    // should be gone completely.
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_BLUE, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    assertUidTotal(sTemplateWifi, UID_REMOVED, 4112L, 259L, 528L, 33L, 10);
}
#method_after
@Test
public void testUidRemovedIsMoved() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 16L, 1L, 16L, 1L, 10);
    assertUidTotal(sTemplateWifi, UID_BLUE, 4096L, 258L, 512L, 32L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    // now pretend two UIDs are uninstalled, which should migrate stats to
    // special "removed" bucket.
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    final Intent intent = new Intent(ACTION_UID_REMOVED);
    intent.putExtra(EXTRA_UID, UID_BLUE);
    mServiceContext.sendBroadcast(intent);
    intent.putExtra(EXTRA_UID, UID_RED);
    mServiceContext.sendBroadcast(intent);
    // existing uid and total should remain unchanged; but removed UID
    // should be gone completely.
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_BLUE, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    assertUidTotal(sTemplateWifi, UID_REMOVED, 4112L, 259L, 528L, 33L, 10);
}
#end_block

#method_before
@Test
public void testUid3g4gCombinedByTemplate() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 5);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 1024L, 8L, 1024L, 8L, 5);
    // now switch over to 4g network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkState(buildMobile4gState(TEST_IFACE2));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, 0xFAAD, 512L, 4L, 256L, 2L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 5);
    forcePollAndWaitForIdle();
    // verify that ALL_MOBILE template combines both
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 1280L, 10L, 10);
}
#method_after
@Test
public void testUid3g4gCombinedByTemplate() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 5);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 1024L, 8L, 1024L, 8L, 5);
    // now switch over to 4g network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    states = new NetworkState[] { buildMobile4gState(TEST_IFACE2) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, 0xFAAD, 512L, 4L, 256L, 2L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 5);
    forcePollAndWaitForIdle();
    // verify that ALL_MOBILE template combines both
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 1280L, 10L, 10);
}
#end_block

#method_before
@Test
public void testSummaryForAllUid() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some traffic for two apps
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 1024L, 8L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 50L, 5L, 50L, 5L, 1);
    assertUidTotal(sTemplateWifi, UID_BLUE, 1024L, 8L, 512L, 4L, 0);
    // now create more traffic in next hour, but only for one app
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 2048L, 16L, 1024L, 8L, 0L));
    forcePollAndWaitForIdle();
    // first verify entire history present
    NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(3, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 50L, 5L, 50L, 5L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 10L, 1L, 10L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 2048L, 16L, 1024L, 8L, 0);
    // now verify that recent history only contains one uid
    final long currentTime = currentTimeMillis();
    stats = mSession.getSummaryForAllUid(sTemplateWifi, currentTime - HOUR_IN_MILLIS, currentTime, true);
    assertEquals(1, stats.size());
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1024L, 8L, 512L, 4L, 0);
}
#method_after
@Test
public void testSummaryForAllUid() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic for two apps
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 1024L, 8L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 50L, 5L, 50L, 5L, 1);
    assertUidTotal(sTemplateWifi, UID_BLUE, 1024L, 8L, 512L, 4L, 0);
    // now create more traffic in next hour, but only for one app
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 2048L, 16L, 1024L, 8L, 0L));
    forcePollAndWaitForIdle();
    // first verify entire history present
    NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(3, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 50L, 5L, 50L, 5L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 10L, 1L, 10L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 2048L, 16L, 1024L, 8L, 0);
    // now verify that recent history only contains one uid
    final long currentTime = currentTimeMillis();
    stats = mSession.getSummaryForAllUid(sTemplateWifi, currentTime - HOUR_IN_MILLIS, currentTime, true);
    assertEquals(1, stats.size());
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1024L, 8L, 512L, 4L, 0);
}
#end_block

#method_before
@Test
public void testDetailedUidStats() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    NetworkStats.Entry entry1 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry2 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry3 = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xBEEF, 1024L, 8L, 512L, 4L, 0L);
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(entry1).addValues(entry2).addValues(entry3));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    NetworkStats stats = mService.getDetailedUidStats(INTERFACES_ALL);
    assertEquals(3, stats.size());
    entry1.operations = 1;
    assertEquals(entry1, stats.getValues(0, null));
    entry2.operations = 1;
    assertEquals(entry2, stats.getValues(1, null));
    assertEquals(entry3, stats.getValues(2, null));
}
#method_after
@Test
public void testDetailedUidStats() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    NetworkStats.Entry entry1 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry2 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry3 = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xBEEF, 1024L, 8L, 512L, 4L, 0L);
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(entry1).addValues(entry2).addValues(entry3));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    NetworkStats stats = mService.getDetailedUidStats(INTERFACES_ALL);
    assertEquals(3, stats.size());
    entry1.operations = 1;
    assertEquals(entry1, stats.getValues(0, null));
    entry2.operations = 1;
    assertEquals(entry2, stats.getValues(1, null));
    assertEquals(entry3, stats.getValues(2, null));
}
#end_block

#method_before
@Test
public void testDetailedUidStats_Filtered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    final String stackedIface = "stacked-test0";
    final LinkProperties stackedProp = new LinkProperties();
    stackedProp.setInterfaceName(stackedIface);
    final NetworkState wifiState = buildWifiState();
    wifiState.linkProperties.addStackedLink(stackedProp);
    expectNetworkState(wifiState);
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    NetworkStats.Entry uidStats = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Stacked on matching interface
    NetworkStats.Entry tetheredStats1 = new NetworkStats.Entry(stackedIface, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Different interface
    NetworkStats.Entry tetheredStats2 = new NetworkStats.Entry("otherif", UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    final String[] ifaceFilter = new String[] { TEST_IFACE };
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    when(mNetManager.getNetworkStatsUidDetail(eq(UID_ALL), any())).thenReturn(new NetworkStats(getElapsedRealtime(), 1).addValues(uidStats));
    when(mNetManager.getNetworkStatsTethering(STATS_PER_UID)).thenReturn(new NetworkStats(getElapsedRealtime(), 2).addValues(tetheredStats1).addValues(tetheredStats2));
    NetworkStats stats = mService.getDetailedUidStats(ifaceFilter);
    // mNetManager#getNetworkStatsUidDetail(UID_ALL, INTERFACES_ALL) has following invocations:
    // 1) NetworkStatsService#systemReady from #setUp.
    // 2) mService#forceUpdateIfaces in the test above.
    // 3) Finally, mService#getDetailedUidStats.
    verify(mNetManager, times(3)).getNetworkStatsUidDetail(UID_ALL, INTERFACES_ALL);
    assertTrue(ArrayUtils.contains(stats.getUniqueIfaces(), TEST_IFACE));
    assertTrue(ArrayUtils.contains(stats.getUniqueIfaces(), stackedIface));
    assertEquals(2, stats.size());
    assertEquals(uidStats, stats.getValues(0, null));
    assertEquals(tetheredStats1, stats.getValues(1, null));
}
#method_after
@Test
public void testDetailedUidStats_Filtered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    final String stackedIface = "stacked-test0";
    final LinkProperties stackedProp = new LinkProperties();
    stackedProp.setInterfaceName(stackedIface);
    final NetworkState wifiState = buildWifiState();
    wifiState.linkProperties.addStackedLink(stackedProp);
    NetworkState[] states = new NetworkState[] { wifiState };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    NetworkStats.Entry uidStats = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Stacked on matching interface
    NetworkStats.Entry tetheredStats1 = new NetworkStats.Entry(stackedIface, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Different interface
    NetworkStats.Entry tetheredStats2 = new NetworkStats.Entry("otherif", UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    final String[] ifaceFilter = new String[] { TEST_IFACE };
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    when(mNetManager.getNetworkStatsUidDetail(eq(UID_ALL), any())).thenReturn(new NetworkStats(getElapsedRealtime(), 1).addValues(uidStats));
    when(mNetManager.getNetworkStatsTethering(STATS_PER_UID)).thenReturn(new NetworkStats(getElapsedRealtime(), 2).addValues(tetheredStats1).addValues(tetheredStats2));
    NetworkStats stats = mService.getDetailedUidStats(ifaceFilter);
    // mNetManager#getNetworkStatsUidDetail(UID_ALL, INTERFACES_ALL) has following invocations:
    // 1) NetworkStatsService#systemReady from #setUp.
    // 2) mService#forceUpdateIfaces in the test above.
    // 3) Finally, mService#getDetailedUidStats.
    verify(mNetManager, times(3)).getNetworkStatsUidDetail(UID_ALL, INTERFACES_ALL);
    assertTrue(ArrayUtils.contains(stats.getUniqueIfaces(), TEST_IFACE));
    assertTrue(ArrayUtils.contains(stats.getUniqueIfaces(), stackedIface));
    assertEquals(2, stats.size());
    assertEquals(uidStats, stats.getValues(0, null));
    assertEquals(tetheredStats1, stats.getValues(1, null));
}
#end_block

#method_before
@Test
public void testForegroundBackground() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // now switch to foreground
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 32L, 2L, 32L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 1L, 1L, 1L, 1L, 0L));
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 1);
    forcePollAndWaitForIdle();
    // test that we combined correctly
    assertUidTotal(sTemplateWifi, UID_RED, 160L, 4L, 160L, 4L, 2);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(4, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 32L, 2L, 32L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, 0xFAAD, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1L, 1L, 1L, 1L, 1);
}
#method_after
@Test
public void testForegroundBackground() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // now switch to foreground
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 32L, 2L, 32L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 1L, 1L, 1L, 1L, 0L));
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 1);
    forcePollAndWaitForIdle();
    // test that we combined correctly
    assertUidTotal(sTemplateWifi, UID_RED, 160L, 4L, 160L, 4L, 2);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(4, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 32L, 2L, 32L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, 0xFAAD, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1L, 1L, 1L, 1L, 1);
}
#end_block

#method_before
@Test
public void testMetered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState(true));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO, ROAMING_NO
    // and DEFAULT_NETWORK_YES, because these three properties aren't tracked at that layer.
    // We layer them on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
}
#method_after
@Test
public void testMetered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState(true) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO, ROAMING_NO
    // and DEFAULT_NETWORK_YES, because these three properties aren't tracked at that layer.
    // We layer them on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
}
#end_block

#method_before
@Test
public void testRoaming() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1, true));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // Create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO and
    // ROAMING_NO, because metered and roaming isn't tracked at that layer. We layer it
    // on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateImsi1, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0);
}
#method_after
@Test
public void testRoaming() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1, true) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // Create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO and
    // ROAMING_NO, because metered and roaming isn't tracked at that layer. We layer it
    // on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateImsi1, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0);
}
#end_block

#method_before
@Test
public void testTethering() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // create some tethering traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    // Traffic seen by kernel counters (includes software tethering).
    final NetworkStats ifaceStats = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1536L, 12L, 384L, 3L);
    // Hardware tethering traffic, not seen by kernel counters.
    final NetworkStats tetherStatsHardware = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 128L, 1L);
    // Traffic for UID_RED.
    final NetworkStats uidStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L);
    // All tethering traffic, both hardware and software.
    final NetworkStats tetherStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_TETHERING, SET_DEFAULT, TAG_NONE, 1920L, 14L, 384L, 2L, 0L);
    expectNetworkStatsSummary(ifaceStats, tetherStatsHardware);
    expectNetworkStatsUidDetail(uidStats, tetherStats);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    assertUidTotal(sTemplateImsi1, UID_TETHERING, 1920L, 14L, 384L, 2L, 0);
}
#method_after
@Test
public void testTethering() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // create some tethering traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    // Traffic seen by kernel counters (includes software tethering).
    final NetworkStats ifaceStats = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1536L, 12L, 384L, 3L);
    // Hardware tethering traffic, not seen by kernel counters.
    final NetworkStats tetherStatsHardware = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 128L, 1L);
    // Traffic for UID_RED.
    final NetworkStats uidStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L);
    // All tethering traffic, both hardware and software.
    final NetworkStats tetherStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_TETHERING, SET_DEFAULT, TAG_NONE, 1920L, 14L, 384L, 2L, 0L);
    expectNetworkStatsSummary(ifaceStats, tetherStatsHardware);
    expectNetworkStatsUidDetail(uidStats, tetherStats);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    assertUidTotal(sTemplateImsi1, UID_TETHERING, 1920L, 14L, 384L, 2L, 0);
}
#end_block

#method_before
@Test
public void vpnWithOneUnderlyingIface() throws Exception {
    // We have WiFi and VPN network, and VPN is using WiFi (which has TEST_IFACE).
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildVpnState(false) };
    expectNetworkState(networkStates);
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    when(mConnManager.getAllVpnInfo()).thenReturn(vpnInfos);
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK });
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over WiFi.
    // Of 1100 bytes over WiFi, expect 1000 bytes attributed to UID_RED and 100 bytes attributed
    // to UID_VPN.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 1000L, 100L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_VPN, 100L, 0L, 0L, 0L, 0);
}
#method_after
@Test
public void vpnWithOneUnderlyingIface() throws Exception {
    // WiFi network is connected and VPN is using WiFi (which has TEST_IFACE).
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildVpnState() };
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK }, vpnInfos, networkStates, getActiveIface(networkStates));
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were sent/received by UID_RED over VPN.
    // 500 bytes (50 packets) were sent/received by UID_BLUE over VPN.
    // VPN sent/received 1650 bytes (150 packets) over WiFi.
    // Of 1650 bytes over WiFi, expect 1000 bytes attributed to UID_RED, 500 bytes attributed to
    // UID_BLUE, and 150 bytes attributed to UID_VPN for both rx/tx traffic.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 1000L, 100L, 1L).addValues(TUN_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 500L, 50L, 500L, 50L, 1L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1650L, 150L, 0L, 0L, 1L).addValues(TEST_IFACE, UID_VPN, SET_FOREGROUND, TAG_NONE, 0L, 0L, 1650L, 150L, 1L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 1000L, 100L, 1000L, 100L, 1);
    assertUidTotal(sTemplateWifi, UID_BLUE, 500L, 50L, 500L, 50L, 1);
    assertUidTotal(sTemplateWifi, UID_VPN, 150L, 0L, 150L, 0L, 2);
}
#end_block

#method_before
@Test
public void recordSnapshot_migratesTunTrafficAndUpdatesTunAdjustedStats() throws Exception {
    assertEquals(0, mService.getTunAdjustedStats().size());
    // VPN using WiFi (TEST_IFACE).
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    when(mConnManager.getAllVpnInfo()).thenReturn(vpnInfos);
    expectBandwidthControlCheck();
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over WiFi.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    // this should lead to NSS#recordSnapshotLocked
    forcePollAndWaitForIdle();
    // Verify TUN adjusted stats have traffic migrated correctly.
    // Of 1100 bytes VPN received over WiFi, expect 1000 bytes attributed to UID_RED and 100
    // bytes attributed to UID_VPN.
    NetworkStats tunAdjStats = mService.getTunAdjustedStats();
    assertValues(tunAdjStats, TEST_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(tunAdjStats, TEST_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 100L, 0L, 0L, 0L, 0);
}
#method_after
@Test
public void recordSnapshot_migratesTunTrafficAndUpdatesTunAdjustedStats() throws Exception {
    assertEquals(0, mService.getTunAdjustedStats().size());
    // VPN using WiFi (TEST_IFACE).
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    expectBandwidthControlCheck();
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over WiFi.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    // this should lead to NSS#recordSnapshotLocked
    mService.forceUpdateIfaces(new Network[0], vpnInfos, new NetworkState[0], null);
    // Verify TUN adjusted stats have traffic migrated correctly.
    // Of 1100 bytes VPN received over WiFi, expect 1000 bytes attributed to UID_RED and 100
    // bytes attributed to UID_VPN.
    NetworkStats tunAdjStats = mService.getTunAdjustedStats();
    assertValues(tunAdjStats, TEST_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(tunAdjStats, TEST_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 100L, 0L, 0L, 0L, 0);
}
#end_block

#method_before
@Test
public void getDetailedUidStats_migratesTunTrafficAndUpdatesTunAdjustedStats() throws Exception {
    assertEquals(0, mService.getTunAdjustedStats().size());
    // VPN using WiFi (TEST_IFACE).
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    when(mConnManager.getAllVpnInfo()).thenReturn(vpnInfos);
    expectBandwidthControlCheck();
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over WiFi.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    mService.getDetailedUidStats(INTERFACES_ALL);
    // Verify internally maintained TUN adjusted stats
    NetworkStats tunAdjStats = mService.getTunAdjustedStats();
    // Verify stats for TEST_IFACE (WiFi):
    // Of 1100 bytes VPN received over WiFi, expect 1000 bytes attributed to UID_RED and 100
    // bytes attributed to UID_VPN.
    assertValues(tunAdjStats, TEST_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(tunAdjStats, TEST_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 100L, 0L, 0L, 0L, 0);
    // Verify stats for TUN_IFACE; only UID_RED should have usage on it.
    assertValues(tunAdjStats, TUN_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(tunAdjStats, TUN_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 0L, 0L, 0L, 0L, 0);
}
#method_after
@Test
public void getDetailedUidStats_migratesTunTrafficAndUpdatesTunAdjustedStats() throws Exception {
    assertEquals(0, mService.getTunAdjustedStats().size());
    // VPN using WiFi (TEST_IFACE).
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[0], vpnInfos, new NetworkState[0], null);
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over WiFi.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    mService.getDetailedUidStats(INTERFACES_ALL);
    // Verify internally maintained TUN adjusted stats
    NetworkStats tunAdjStats = mService.getTunAdjustedStats();
    // Verify stats for TEST_IFACE (WiFi):
    // Of 1100 bytes VPN received over WiFi, expect 1000 bytes attributed to UID_RED and 100
    // bytes attributed to UID_VPN.
    assertValues(tunAdjStats, TEST_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(tunAdjStats, TEST_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 100L, 0L, 0L, 0L, 0);
    // Verify stats for TUN_IFACE; only UID_RED should have usage on it.
    assertValues(tunAdjStats, TUN_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(tunAdjStats, TUN_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 0L, 0L, 0L, 0L, 0);
    // lets assume that since last time, VPN received another 1100 bytes (same assumptions as
    // before i.e. UID_RED downloaded another 1000 bytes).
    incrementCurrentTime(HOUR_IN_MILLIS);
    // Note - NetworkStatsFactory returns counters that are monotonically increasing.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 2000L, 200L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 2200L, 200L, 0L, 0L, 0L));
    mService.getDetailedUidStats(INTERFACES_ALL);
    tunAdjStats = mService.getTunAdjustedStats();
    // verify TEST_IFACE stats:
    assertValues(tunAdjStats, TEST_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 2000L, 200L, 0L, 0L, 0);
    assertValues(tunAdjStats, TEST_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 200L, 0L, 0L, 0L, 0);
    // verify TUN_IFACE stats:
    assertValues(tunAdjStats, TUN_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 2000L, 200L, 0L, 0L, 0);
    assertValues(tunAdjStats, TUN_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 0L, 0L, 0L, 0L, 0);
}
#end_block

#method_before
@Test
public void getDetailedUidStats_returnsCorrectStatsWithVpnRunning() throws Exception {
    // VPN using WiFi (TEST_IFACE).
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    when(mConnManager.getAllVpnInfo()).thenReturn(vpnInfos);
    expectBandwidthControlCheck();
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over WiFi.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    // Query reatime stats for TEST_IFACE.
    NetworkStats queriedStats = mService.getDetailedUidStats(new String[] { TEST_IFACE });
    // verify that returned stats are only for TEST_IFACE and VPN traffic is migrated correctly.
    assertEquals(new String[] { TEST_IFACE }, queriedStats.getUniqueIfaces());
    assertValues(queriedStats, TEST_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(queriedStats, TEST_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 100L, 0L, 0L, 0L, 0);
}
#method_after
@Test
public void getDetailedUidStats_returnsCorrectStatsWithVpnRunning() throws Exception {
    // VPN using WiFi (TEST_IFACE).
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(new String[] { TEST_IFACE }) };
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[0], vpnInfos, new NetworkState[0], null);
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over WiFi.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    // Query realtime stats for TEST_IFACE.
    NetworkStats queriedStats = mService.getDetailedUidStats(new String[] { TEST_IFACE });
    assertEquals(HOUR_IN_MILLIS, queriedStats.getElapsedRealtime());
    // verify that returned stats are only for TEST_IFACE and VPN traffic is migrated correctly.
    assertEquals(new String[] { TEST_IFACE }, queriedStats.getUniqueIfaces());
    assertValues(queriedStats, TEST_IFACE, UID_RED, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 1000L, 100L, 0L, 0L, 0);
    assertValues(queriedStats, TEST_IFACE, UID_VPN, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 100L, 0L, 0L, 0L, 0);
}
#end_block

#method_before
@Test
public void testRegisterUsageCallback() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // very small; should be overriden by framework
    long thresholdInBytes = 1L;
    DataUsageRequest inputRequest = new DataUsageRequest(DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, thresholdInBytes);
    // Create a messenger that waits for callback activity
    ConditionVariable cv = new ConditionVariable(false);
    LatchedHandler latchedHandler = new LatchedHandler(Looper.getMainLooper(), cv);
    Messenger messenger = new Messenger(latchedHandler);
    // Force poll
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    // Register and verify request and that binder was called
    DataUsageRequest request = mService.registerUsageCallback(mServiceContext.getOpPackageName(), inputRequest, messenger, mBinder);
    assertTrue(request.requestId > 0);
    assertTrue(Objects.equals(sTemplateWifi, request.template));
    // 2 MB
    long minThresholdInBytes = 2 * 1024 * 1024;
    assertEquals(minThresholdInBytes, request.thresholdInBytes);
    // Send dummy message to make sure that any previous message has been handled
    mHandler.sendMessage(mHandler.obtainMessage(-1));
    waitForIdleHandler(mHandler, WAIT_TIMEOUT);
    // Make sure that the caller binder gets connected
    verify(mBinder).linkToDeath(any(IBinder.DeathRecipient.class), anyInt());
    // modify some number on wifi, and trigger poll event
    // not enough traffic to call data usage callback
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // make sure callback has not being called
    assertEquals(INVALID_TYPE, latchedHandler.lastMessageType);
    // and bump forward again, with counters going higher. this is
    // important, since it will trigger the data usage callback
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096000L, 4L, 8192000L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096000L, 4L, 8192000L, 8L, 0);
    // Wait for the caller to ack receipt of CALLBACK_LIMIT_REACHED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, latchedHandler.lastMessageType);
    cv.close();
    // Allow binder to disconnect
    when(mBinder.unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt())).thenReturn(true);
    // Unregister request
    mService.unregisterUsageRequest(request);
    // Wait for the caller to ack receipt of CALLBACK_RELEASED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_RELEASED, latchedHandler.lastMessageType);
    // Make sure that the caller binder gets disconnected
    verify(mBinder).unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt());
}
#method_after
@Test
public void testRegisterUsageCallback() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // very small; should be overriden by framework
    long thresholdInBytes = 1L;
    DataUsageRequest inputRequest = new DataUsageRequest(DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, thresholdInBytes);
    // Create a messenger that waits for callback activity
    ConditionVariable cv = new ConditionVariable(false);
    LatchedHandler latchedHandler = new LatchedHandler(Looper.getMainLooper(), cv);
    Messenger messenger = new Messenger(latchedHandler);
    // Force poll
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    // Register and verify request and that binder was called
    DataUsageRequest request = mService.registerUsageCallback(mServiceContext.getOpPackageName(), inputRequest, messenger, mBinder);
    assertTrue(request.requestId > 0);
    assertTrue(Objects.equals(sTemplateWifi, request.template));
    // 2 MB
    long minThresholdInBytes = 2 * 1024 * 1024;
    assertEquals(minThresholdInBytes, request.thresholdInBytes);
    // Send dummy message to make sure that any previous message has been handled
    mHandler.sendMessage(mHandler.obtainMessage(-1));
    waitForIdleHandler(mHandler, WAIT_TIMEOUT);
    // Make sure that the caller binder gets connected
    verify(mBinder).linkToDeath(any(IBinder.DeathRecipient.class), anyInt());
    // modify some number on wifi, and trigger poll event
    // not enough traffic to call data usage callback
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // make sure callback has not being called
    assertEquals(INVALID_TYPE, latchedHandler.lastMessageType);
    // and bump forward again, with counters going higher. this is
    // important, since it will trigger the data usage callback
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096000L, 4L, 8192000L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096000L, 4L, 8192000L, 8L, 0);
    // Wait for the caller to ack receipt of CALLBACK_LIMIT_REACHED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, latchedHandler.lastMessageType);
    cv.close();
    // Allow binder to disconnect
    when(mBinder.unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt())).thenReturn(true);
    // Unregister request
    mService.unregisterUsageRequest(request);
    // Wait for the caller to ack receipt of CALLBACK_RELEASED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_RELEASED, latchedHandler.lastMessageType);
    // Make sure that the caller binder gets disconnected
    verify(mBinder).unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt());
}
#end_block

#method_before
private void expectNetworkStatsSummary(NetworkStats summary, NetworkStats tetherStats) throws Exception {
    when(mConnManager.getAllVpnInfo()).thenReturn(new VpnInfo[0]);
    expectNetworkStatsTethering(STATS_PER_IFACE, tetherStats);
    expectNetworkStatsSummaryDev(summary.clone());
    expectNetworkStatsSummaryXt(summary.clone());
}
#method_after
private void expectNetworkStatsSummary(NetworkStats summary, NetworkStats tetherStats) throws Exception {
    expectNetworkStatsTethering(STATS_PER_IFACE, tetherStats);
    expectNetworkStatsSummaryDev(summary.clone());
    expectNetworkStatsSummaryXt(summary.clone());
}
#end_block

#method_before
private static NetworkState buildVpnState(boolean isMetered) {
    final NetworkInfo info = new NetworkInfo(TYPE_VPN, 0, null, null);
    info.setDetailedState(DetailedState.CONNECTED, null, null);
    final LinkProperties prop = new LinkProperties();
    prop.setInterfaceName(TUN_IFACE);
    final NetworkCapabilities capabilities = new NetworkCapabilities();
    capabilities.setCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED, !isMetered);
    return new NetworkState(info, prop, capabilities, VPN_NETWORK, null, null);
}
#method_after
private static NetworkState buildVpnState() {
    final NetworkInfo info = new NetworkInfo(TYPE_VPN, 0, null, null);
    info.setDetailedState(DetailedState.CONNECTED, null, null);
    final LinkProperties prop = new LinkProperties();
    prop.setInterfaceName(TUN_IFACE);
    return new NetworkState(info, prop, new NetworkCapabilities(), VPN_NETWORK, null, null);
}
#end_block

#method_before
public void notifyNetworkConnected(LinkProperties lp, NetworkCapabilities nc) {
    sendMessage(CMD_NETWORK_CONNECTED, new Pair<>(lp, nc));
}
#method_after
public void notifyNetworkConnected(LinkProperties lp, NetworkCapabilities nc) {
    sendMessage(CMD_NETWORK_CONNECTED, new Pair<>(new LinkProperties(lp), new NetworkCapabilities(nc)));
}
#end_block

#method_before
public void notifyLinkPropertiesChanged(final LinkProperties lp) {
    getHandler().post(() -> mLinkProperties = lp);
}
#method_after
public void notifyLinkPropertiesChanged(final LinkProperties lp) {
    sendMessage(EVENT_LINK_PROPERTIES_CHANGED, new LinkProperties(lp));
}
#end_block

#method_before
public void notifyNetworkCapabilitiesChanged(final NetworkCapabilities nc) {
    getHandler().post(() -> mNetworkCapabilities = nc);
}
#method_after
public void notifyNetworkCapabilitiesChanged(final NetworkCapabilities nc) {
    sendMessage(EVENT_NETWORK_CAPABILITIES_CHANGED, new NetworkCapabilities(nc));
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            updateConnectedNetworkAttributes(message);
            logNetworkEvent(NetworkEvent.NETWORK_CONNECTED);
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_NETWORK_DISCONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_DISCONNECTED);
            if (mLaunchCaptivePortalAppBroadcastReceiver != null) {
                mContext.unregisterReceiver(mLaunchCaptivePortalAppBroadcastReceiver);
                mLaunchCaptivePortalAppBroadcastReceiver = null;
            }
            quit();
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
        case CMD_CAPTIVE_PORTAL_RECHECK:
            final int dnsCount = mDnsStallDetector.getConsecutiveTimeoutCount();
            validationLog("Forcing reevaluation for UID " + message.arg1 + ". Dns signal count: " + dnsCount);
            mUidResponsibleForReeval = message.arg1;
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_CAPTIVE_PORTAL_APP_FINISHED:
            log("CaptivePortal App responded with " + message.arg1);
            // If the user has seen and acted on a captive portal notification, and the
            // captive portal app is now closed, disable HTTPS probes. This avoids the
            // following pathological situation:
            // 
            // 1. HTTP probe returns a captive portal, HTTPS probe fails or times out.
            // 2. User opens the app and logs into the captive portal.
            // 3. HTTP starts working, but HTTPS still doesn't work for some other reason -
            // perhaps due to the network blocking HTTPS?
            // 
            // In this case, we'll fail to validate the network even after the app is
            // dismissed. There is now no way to use this network, because the app is now
            // gone, so the user cannot select "Use this network as is".
            mUseHttps = false;
            switch(message.arg1) {
                case APP_RETURN_DISMISSED:
                    sendMessage(CMD_FORCE_REEVALUATION, NO_UID, 0);
                    break;
                case APP_RETURN_WANTED_AS_IS:
                    mDontDisplaySigninNotification = true;
                    // TODO: Distinguish this from a network that actually validates.
                    // Displaying the "x" on the system UI icon may still be a good idea.
                    transitionTo(mEvaluatingPrivateDnsState);
                    break;
                case APP_RETURN_UNWANTED:
                    mDontDisplaySigninNotification = true;
                    mUserDoesNotWant = true;
                    notifyNetworkTested(NETWORK_TEST_RESULT_INVALID, null);
                    // TODO: Should teardown network.
                    mUidResponsibleForReeval = 0;
                    transitionTo(mEvaluatingState);
                    break;
            }
            return HANDLED;
        case CMD_PRIVATE_DNS_SETTINGS_CHANGED:
            {
                final PrivateDnsConfig cfg = (PrivateDnsConfig) message.obj;
                if (!isValidationRequired() || cfg == null || !cfg.inStrictMode()) {
                    // No DNS resolution required.
                    // 
                    // We don't force any validation in opportunistic mode
                    // here. Opportunistic mode nameservers are validated
                    // separately within netd.
                    // 
                    // Reset Private DNS settings state.
                    mPrivateDnsProviderHostname = "";
                    break;
                }
                mPrivateDnsProviderHostname = cfg.hostname;
                // DNS resolutions via Private DNS strict mode block for a
                // few seconds (~4.2) checking for any IP addresses to
                // arrive and validate. Initiating a (re)evaluation now
                // should not significantly alter the validation outcome.
                // 
                // No matter what: enqueue a validation request; one of
                // three things can happen with this request:
                // [1] ignored (EvaluatingState or CaptivePortalState)
                // [2] transition to EvaluatingPrivateDnsState
                // (DefaultState and ValidatedState)
                // [3] handled (EvaluatingPrivateDnsState)
                // 
                // The Private DNS configuration to be evaluated will:
                // [1] be skipped (not in strict mode), or
                // [2] validate (huzzah), or
                // [3] encounter some problem (invalid hostname,
                // no resolved IP addresses, IPs unreachable,
                // port 853 unreachable, port 853 is not running a
                // DNS-over-TLS server, et cetera).
                sendMessage(CMD_EVALUATE_PRIVATE_DNS);
                break;
            }
        case EVENT_DNS_NOTIFICATION:
            mDnsStallDetector.accumulateConsecutiveDnsTimeoutCount(message.arg1);
            break;
        // disable HTTPS probe and transition to EvaluatingPrivateDnsState.
        case EVENT_ACCEPT_PARTIAL_CONNECTIVITY:
            mAcceptPartialConnectivity = true;
            break;
        default:
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            updateConnectedNetworkAttributes(message);
            logNetworkEvent(NetworkEvent.NETWORK_CONNECTED);
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_NETWORK_DISCONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_DISCONNECTED);
            if (mLaunchCaptivePortalAppBroadcastReceiver != null) {
                mContext.unregisterReceiver(mLaunchCaptivePortalAppBroadcastReceiver);
                mLaunchCaptivePortalAppBroadcastReceiver = null;
            }
            quit();
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
        case CMD_CAPTIVE_PORTAL_RECHECK:
            final int dnsCount = mDnsStallDetector.getConsecutiveTimeoutCount();
            validationLog("Forcing reevaluation for UID " + message.arg1 + ". Dns signal count: " + dnsCount);
            mUidResponsibleForReeval = message.arg1;
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_CAPTIVE_PORTAL_APP_FINISHED:
            log("CaptivePortal App responded with " + message.arg1);
            // If the user has seen and acted on a captive portal notification, and the
            // captive portal app is now closed, disable HTTPS probes. This avoids the
            // following pathological situation:
            // 
            // 1. HTTP probe returns a captive portal, HTTPS probe fails or times out.
            // 2. User opens the app and logs into the captive portal.
            // 3. HTTP starts working, but HTTPS still doesn't work for some other reason -
            // perhaps due to the network blocking HTTPS?
            // 
            // In this case, we'll fail to validate the network even after the app is
            // dismissed. There is now no way to use this network, because the app is now
            // gone, so the user cannot select "Use this network as is".
            mUseHttps = false;
            switch(message.arg1) {
                case APP_RETURN_DISMISSED:
                    sendMessage(CMD_FORCE_REEVALUATION, NO_UID, 0);
                    break;
                case APP_RETURN_WANTED_AS_IS:
                    mDontDisplaySigninNotification = true;
                    // TODO: Distinguish this from a network that actually validates.
                    // Displaying the "x" on the system UI icon may still be a good idea.
                    transitionTo(mEvaluatingPrivateDnsState);
                    break;
                case APP_RETURN_UNWANTED:
                    mDontDisplaySigninNotification = true;
                    mUserDoesNotWant = true;
                    notifyNetworkTested(NETWORK_TEST_RESULT_INVALID, null);
                    // TODO: Should teardown network.
                    mUidResponsibleForReeval = 0;
                    transitionTo(mEvaluatingState);
                    break;
            }
            return HANDLED;
        case CMD_PRIVATE_DNS_SETTINGS_CHANGED:
            {
                final PrivateDnsConfig cfg = (PrivateDnsConfig) message.obj;
                if (!isValidationRequired() || cfg == null || !cfg.inStrictMode()) {
                    // No DNS resolution required.
                    // 
                    // We don't force any validation in opportunistic mode
                    // here. Opportunistic mode nameservers are validated
                    // separately within netd.
                    // 
                    // Reset Private DNS settings state.
                    mPrivateDnsProviderHostname = "";
                    break;
                }
                mPrivateDnsProviderHostname = cfg.hostname;
                // DNS resolutions via Private DNS strict mode block for a
                // few seconds (~4.2) checking for any IP addresses to
                // arrive and validate. Initiating a (re)evaluation now
                // should not significantly alter the validation outcome.
                // 
                // No matter what: enqueue a validation request; one of
                // three things can happen with this request:
                // [1] ignored (EvaluatingState or CaptivePortalState)
                // [2] transition to EvaluatingPrivateDnsState
                // (DefaultState and ValidatedState)
                // [3] handled (EvaluatingPrivateDnsState)
                // 
                // The Private DNS configuration to be evaluated will:
                // [1] be skipped (not in strict mode), or
                // [2] validate (huzzah), or
                // [3] encounter some problem (invalid hostname,
                // no resolved IP addresses, IPs unreachable,
                // port 853 unreachable, port 853 is not running a
                // DNS-over-TLS server, et cetera).
                sendMessage(CMD_EVALUATE_PRIVATE_DNS);
                break;
            }
        case EVENT_DNS_NOTIFICATION:
            mDnsStallDetector.accumulateConsecutiveDnsTimeoutCount(message.arg1);
            break;
        // disable HTTPS probe and transition to EvaluatingPrivateDnsState.
        case EVENT_ACCEPT_PARTIAL_CONNECTIVITY:
            mAcceptPartialConnectivity = true;
            break;
        case EVENT_LINK_PROPERTIES_CHANGED:
            mLinkProperties = (LinkProperties) message.obj;
            break;
        case EVENT_NETWORK_CAPABILITIES_CHANGED:
            mNetworkCapabilities = (NetworkCapabilities) message.obj;
            break;
        default:
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNetwork = getDefaultNetwork();
        if (defaultNetwork != null && defaultNetwork.linkProperties != null) {
            info.primaryUnderlyingIface = getDefaultNetwork().linkProperties.getInterfaceName();
        }
    } else if (underlyingNetworks.length > 0) {
        LinkProperties linkProperties = getLinkProperties(underlyingNetworks[0]);
        if (linkProperties != null) {
            info.primaryUnderlyingIface = linkProperties.getInterfaceName();
        }
    }
    return info.primaryUnderlyingIface == null ? null : info;
}
#method_after
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNai = getDefaultNetwork();
        if (defaultNai != null && defaultNai.linkProperties != null) {
            underlyingNetworks = new Network[] { defaultNai.network };
        }
    }
    if (underlyingNetworks != null && underlyingNetworks.length > 0) {
        List<String> interfaces = new ArrayList<>();
        for (Network network : underlyingNetworks) {
            LinkProperties lp = getLinkProperties(network);
            if (lp != null) {
                interfaces.add(lp.getInterfaceName());
            }
        }
        if (!interfaces.isEmpty()) {
            info.underlyingIfaces = interfaces.toArray(new String[interfaces.size()]);
        }
    }
    return info.underlyingIfaces == null ? null : info;
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc, int factorySerialNumber) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS, factorySerialNumber);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        getNetworkStack().makeNetworkMonitor(nai.network, name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc, int factorySerialNumber) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS, factorySerialNumber);
    // Make sure the network capabilities reflect what the agent info says.
    nai.setNetworkCapabilities(mixInCapabilities(nai, nc));
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        getNetworkStack().makeNetworkMonitor(nai.network, name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // The NetworkAgentInfo does not know whether clatd is running on its network or not, or
    // whether there is a NAT64 prefix. Before we do anything else, make sure its LinkProperties
    // are accurate.
    networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop DNS64 detection and 464xlat according to network state.
        networkAgent.clatd.update();
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            try {
                networkAgent.networkMonitor().notifyLinkPropertiesChanged(networkAgent.linkProperties);
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // The NetworkAgentInfo does not know whether clatd is running on its network or not, or
    // whether there is a NAT64 prefix. Before we do anything else, make sure its LinkProperties
    // are accurate.
    networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop DNS64 detection and 464xlat according to network state.
        networkAgent.clatd.update();
        notifyIfacesChangedForNetworkStats();
        try {
            networkAgent.networkMonitor().notifyLinkPropertiesChanged(newLp);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged(nai.networkCapabilities);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.setNetworkCapabilities(newNc);
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged(nai.networkCapabilities);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#method_after
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#end_block

#method_before
// TODO(b/128426024): deflake and re-enable
public void testPartialConnectivity() {
    // Register network callback.
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_INTERNET).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    // Bring up validated mobile data.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Bring up wifi with partial connectivity.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connectWithPartialConnectivity();
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_PARTIAL_CONNECTIVITY, mWiFiNetworkAgent);
    // Mobile data should be the default network.
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    callback.assertNoCallback();
    // If the user chooses yes to use this partial connectivity wifi, switch the default
    // network to wifi and check if wifi becomes valid or not.
    mCm.setAcceptPartialConnectivity(mWiFiNetworkAgent.getNetwork(), true, /* accept */
    false);
    // With https probe disabled, NetworkMonitor should pass the network validation with http
    // probe.
    mWiFiNetworkAgent.setNetworkValid();
    waitForIdle();
    try {
        verify(mWiFiNetworkAgent.mNetworkMonitor, timeout(TIMEOUT_MS).times(1)).setAcceptPartialConnectivity();
    } catch (RemoteException e) {
        fail(e.getMessage());
    }
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    NetworkCapabilities nc = callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertTrue(nc.hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY));
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect and reconnect wifi with partial connectivity again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connectWithPartialConnectivity();
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_PARTIAL_CONNECTIVITY, mWiFiNetworkAgent);
    // Mobile data should be the default network.
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // If the user chooses no, disconnect wifi immediately.
    mCm.setAcceptPartialConnectivity(mWiFiNetworkAgent.getNetwork(), false, /* accept */
    false);
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // If user accepted partial connectivity before, and device reconnects to that network
    // again, but now the network has full connectivity. The network shouldn't contain
    // NET_CAPABILITY_PARTIAL_CONNECTIVITY.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // acceptUnvalidated is also used as setting for accepting partial networks.
    mWiFiNetworkAgent.explicitlySelected(true);
    mWiFiNetworkAgent.connect(true);
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    nc = callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertFalse(nc.hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY));
    // Wifi should be the default network.
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // If user accepted partial connectivity before, and now the device reconnects to the
    // partial connectivity network. The network should be valid and contain
    // NET_CAPABILITY_PARTIAL_CONNECTIVITY.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.explicitlySelected(true);
    mWiFiNetworkAgent.connectWithPartialConnectivity();
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    // TODO: If the user accepted partial connectivity, we shouldn't switch to wifi until
    // NetworkMonitor detects partial connectivity
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.setNetworkValid();
    waitForIdle();
    try {
        verify(mWiFiNetworkAgent.mNetworkMonitor, timeout(TIMEOUT_MS).times(1)).setAcceptPartialConnectivity();
    } catch (RemoteException e) {
        fail(e.getMessage());
    }
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_PARTIAL_CONNECTIVITY, mWiFiNetworkAgent);
    // Wifi should be the default network.
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
}
#method_after
@Test
public void testPartialConnectivity() {
    // Register network callback.
    NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addCapability(NET_CAPABILITY_INTERNET).build();
    TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    // Bring up validated mobile data.
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    mCellNetworkAgent.connect(true);
    callback.expectAvailableThenValidatedCallbacks(mCellNetworkAgent);
    // Bring up wifi with partial connectivity.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connectWithPartialConnectivity();
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_PARTIAL_CONNECTIVITY, mWiFiNetworkAgent);
    // Mobile data should be the default network.
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    callback.assertNoCallback();
    // With HTTPS probe disabled, NetworkMonitor should pass the network validation with http
    // probe.
    mWiFiNetworkAgent.setNetworkValid();
    // If the user chooses yes to use this partial connectivity wifi, switch the default
    // network to wifi and check if wifi becomes valid or not.
    mCm.setAcceptPartialConnectivity(mWiFiNetworkAgent.getNetwork(), true, /* accept */
    false);
    // If user accepts partial connectivity network,
    // NetworkMonitor#setAcceptPartialConnectivity() should be called too.
    waitForIdle();
    try {
        verify(mWiFiNetworkAgent.mNetworkMonitor, times(1)).setAcceptPartialConnectivity();
    } catch (RemoteException e) {
        fail(e.getMessage());
    }
    // Need a trigger point to let NetworkMonitor tell ConnectivityService that network is
    // validated.
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), true);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    NetworkCapabilities nc = callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertTrue(nc.hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY));
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // Disconnect and reconnect wifi with partial connectivity again.
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.connectWithPartialConnectivity();
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCapabilitiesWith(NET_CAPABILITY_PARTIAL_CONNECTIVITY, mWiFiNetworkAgent);
    // Mobile data should be the default network.
    assertEquals(mCellNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    // If the user chooses no, disconnect wifi immediately.
    mCm.setAcceptPartialConnectivity(mWiFiNetworkAgent.getNetwork(), false, /* accept */
    false);
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // If user accepted partial connectivity before, and device reconnects to that network
    // again, but now the network has full connectivity. The network shouldn't contain
    // NET_CAPABILITY_PARTIAL_CONNECTIVITY.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    // acceptUnvalidated is also used as setting for accepting partial networks.
    mWiFiNetworkAgent.explicitlySelected(true);
    mWiFiNetworkAgent.connect(true);
    // If user accepted partial connectivity network before,
    // NetworkMonitor#setAcceptPartialConnectivity() will be called in
    // ConnectivityService#updateNetworkInfo().
    waitForIdle();
    try {
        verify(mWiFiNetworkAgent.mNetworkMonitor, times(1)).setAcceptPartialConnectivity();
    } catch (RemoteException e) {
        fail(e.getMessage());
    }
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    nc = callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    assertFalse(nc.hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY));
    // Wifi should be the default network.
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
    // If user accepted partial connectivity before, and now the device reconnects to the
    // partial connectivity network. The network should be valid and contain
    // NET_CAPABILITY_PARTIAL_CONNECTIVITY.
    mWiFiNetworkAgent = new MockNetworkAgent(TRANSPORT_WIFI);
    mWiFiNetworkAgent.explicitlySelected(true);
    // Current design cannot send multi-testResult from NetworkMonitor to ConnectivityService.
    // So, if user accepts partial connectivity, NetworkMonitor will send PARTIAL_CONNECTIVITY
    // to ConnectivityService first then send VALID. Once NetworkMonitor support
    // multi-testResult, this test case also need to be changed to meet the new design.
    mWiFiNetworkAgent.connectWithPartialConnectivity();
    // If user accepted partial connectivity network before,
    // NetworkMonitor#setAcceptPartialConnectivity() will be called in
    // ConnectivityService#updateNetworkInfo().
    waitForIdle();
    try {
        verify(mWiFiNetworkAgent.mNetworkMonitor, times(1)).setAcceptPartialConnectivity();
    } catch (RemoteException e) {
        fail(e.getMessage());
    }
    callback.expectAvailableCallbacksUnvalidated(mWiFiNetworkAgent);
    callback.expectCallback(CallbackState.LOSING, mCellNetworkAgent);
    // TODO: If the user accepted partial connectivity, we shouldn't switch to wifi until
    // NetworkMonitor detects partial connectivity
    assertEquals(mWiFiNetworkAgent.getNetwork(), mCm.getActiveNetwork());
    callback.expectCapabilitiesWith(NET_CAPABILITY_PARTIAL_CONNECTIVITY, mWiFiNetworkAgent);
    mWiFiNetworkAgent.setNetworkValid();
    // Need a trigger point to let NetworkMonitor tell ConnectivityService that network is
    // validated.
    mCm.reportNetworkConnectivity(mWiFiNetworkAgent.getNetwork(), true);
    callback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, mWiFiNetworkAgent);
    mWiFiNetworkAgent.disconnect();
    callback.expectCallback(CallbackState.LOST, mWiFiNetworkAgent);
}
#end_block

#method_before
private void runTestWithSerialExecutors(Consumer<Executor> functor) {
    final ExecutorService executorSingleThread = Executors.newSingleThreadExecutor();
    final Executor executorInline = (Runnable r) -> r.run();
    functor.accept(executorSingleThread);
    executorSingleThread.shutdown();
    functor.accept(executorInline);
}
#method_after
private void runTestWithSerialExecutors(ThrowingConsumer<Executor> functor) throws Exception {
    final ExecutorService executorSingleThread = Executors.newSingleThreadExecutor();
    final Executor executorInline = (Runnable r) -> r.run();
    functor.accept(executorSingleThread);
    executorSingleThread.shutdown();
    functor.accept(executorInline);
}
#end_block

#method_before
@Test
public void testNattSocketKeepalives() {
    runTestWithSerialExecutors(executor -> {
        try {
            doTestNattSocketKeepalivesWithExecutor(executor);
            doTestNattSocketKeepalivesFdWithExecutor(executor);
        } catch (Exception e) {
            fail(e.getMessage());
        }
    });
}
#method_after
@Test
public void testNattSocketKeepalives() throws Exception {
    runTestWithSerialExecutors(executor -> doTestNattSocketKeepalivesWithExecutor(executor));
    runTestWithSerialExecutors(executor -> doTestNattSocketKeepalivesFdWithExecutor(executor));
}
#end_block

#method_before
private void doTestNattSocketKeepalivesWithExecutor(Executor executor) throws Exception {
    // TODO: 1. Move this outside of ConnectivityServiceTest.
    // 2. Make test to verify that Nat-T keepalive socket is created by IpSecService.
    // 3. Mock ipsec service.
    // 4. Find a free port instead of a fixed port.
    final int srcPort = 12345;
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress notMyIPv4 = InetAddress.getByName("192.0.2.35");
    final InetAddress myIPv6 = InetAddress.getByName("2001:db8::1");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final InetAddress dstIPv6 = InetAddress.getByName("2001:4860:4860::8888");
    final int validKaInterval = 15;
    final int invalidKaInterval = 9;
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket(srcPort);
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv6, 64));
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("fe80::1234")));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network notMyNet = new Network(61234);
    Network myNet = connectKeepaliveNetwork(lp);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Invalid network.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(notMyNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
    }
    // Invalid interval.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(invalidKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_INTERVAL);
    }
    // Invalid destination.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Invalid source;
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // NAT-T is only supported for IPv4.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Sanity check before testing started keepalive.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_UNSUPPORTED);
    }
    // Check that a started keepalive can be stopped.
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
        ka.stop();
        callback.expectStopped();
        // Check that keepalive could be restarted.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
        // Check that keepalive can be restarted without waiting for callback.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        ka.start(validKaInterval);
        callback.expectStopped();
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that deleting the IP address stops the keepalive.
    LinkProperties bogusLp = new LinkProperties(lp);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        bogusLp.removeLinkAddress(new LinkAddress(myIPv4, 25));
        bogusLp.addLinkAddress(new LinkAddress(notMyIPv4, 25));
        mWiFiNetworkAgent.sendLinkProperties(bogusLp);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
        mWiFiNetworkAgent.sendLinkProperties(lp);
    }
    // Check that a started keepalive is stopped correctly when the network disconnects.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.disconnect();
        waitFor(mWiFiNetworkAgent.getDisconnectedCV());
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
        // ... and that stopping it after that has no adverse effects.
        waitForIdle();
        final Network myNetAlias = myNet;
        assertNull(mCm.getNetworkCapabilities(myNetAlias));
        ka.stop();
        callback.assertNoCallback();
    }
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    // Check that keepalive slots start from 1 and increment. The first one gets slot 1.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        // The second one gets slot 2.
        mWiFiNetworkAgent.setExpectedKeepaliveSlot(2);
        final UdpEncapsulationSocket testSocket2 = mIpSec.openUdpEncapsulationSocket(6789);
        TestSocketKeepaliveCallback callback2 = new TestSocketKeepaliveCallback(executor);
        try (SocketKeepalive ka2 = mCm.createSocketKeepalive(myNet, testSocket2, myIPv4, dstIPv4, executor, callback2)) {
            ka2.start(validKaInterval);
            callback2.expectStarted();
            ka.stop();
            callback.expectStopped();
            ka2.stop();
            callback2.expectStopped();
            testSocket.close();
            testSocket2.close();
        }
    }
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#method_after
private void doTestNattSocketKeepalivesWithExecutor(Executor executor) throws Exception {
    // TODO: 1. Move this outside of ConnectivityServiceTest.
    // 2. Make test to verify that Nat-T keepalive socket is created by IpSecService.
    // 3. Mock ipsec service.
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress notMyIPv4 = InetAddress.getByName("192.0.2.35");
    final InetAddress myIPv6 = InetAddress.getByName("2001:db8::1");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final InetAddress dstIPv6 = InetAddress.getByName("2001:4860:4860::8888");
    final int validKaInterval = 15;
    final int invalidKaInterval = 9;
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket();
    final int srcPort = testSocket.getPort();
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv6, 64));
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("fe80::1234")));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network notMyNet = new Network(61234);
    Network myNet = connectKeepaliveNetwork(lp);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Invalid network.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(notMyNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
    }
    // Invalid interval.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(invalidKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_INTERVAL);
    }
    // Invalid destination.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Invalid source;
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // NAT-T is only supported for IPv4.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv6, dstIPv6, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
    }
    // Sanity check before testing started keepalive.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectError(SocketKeepalive.ERROR_UNSUPPORTED);
    }
    // Check that a started keepalive can be stopped.
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
        ka.stop();
        callback.expectStopped();
        // Check that keepalive could be restarted.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
        // Check that keepalive can be restarted without waiting for callback.
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        ka.start(validKaInterval);
        callback.expectStopped();
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that deleting the IP address stops the keepalive.
    LinkProperties bogusLp = new LinkProperties(lp);
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        bogusLp.removeLinkAddress(new LinkAddress(myIPv4, 25));
        bogusLp.addLinkAddress(new LinkAddress(notMyIPv4, 25));
        mWiFiNetworkAgent.sendLinkProperties(bogusLp);
        callback.expectError(SocketKeepalive.ERROR_INVALID_IP_ADDRESS);
        mWiFiNetworkAgent.sendLinkProperties(lp);
    }
    // Check that a started keepalive is stopped correctly when the network disconnects.
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        mWiFiNetworkAgent.disconnect();
        waitFor(mWiFiNetworkAgent.getDisconnectedCV());
        callback.expectError(SocketKeepalive.ERROR_INVALID_NETWORK);
        // ... and that stopping it after that has no adverse effects.
        waitForIdle();
        final Network myNetAlias = myNet;
        assertNull(mCm.getNetworkCapabilities(myNetAlias));
        ka.stop();
        callback.assertNoCallback();
    }
    // Reconnect.
    myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    // Check that keepalive slots start from 1 and increment. The first one gets slot 1.
    mWiFiNetworkAgent.setExpectedKeepaliveSlot(1);
    int srcPort2 = 0;
    try (SocketKeepalive ka = mCm.createSocketKeepalive(myNet, testSocket, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        // The second one gets slot 2.
        mWiFiNetworkAgent.setExpectedKeepaliveSlot(2);
        final UdpEncapsulationSocket testSocket2 = mIpSec.openUdpEncapsulationSocket();
        srcPort2 = testSocket2.getPort();
        TestSocketKeepaliveCallback callback2 = new TestSocketKeepaliveCallback(executor);
        try (SocketKeepalive ka2 = mCm.createSocketKeepalive(myNet, testSocket2, myIPv4, dstIPv4, executor, callback2)) {
            ka2.start(validKaInterval);
            callback2.expectStarted();
            ka.stop();
            callback.expectStopped();
            ka2.stop();
            callback2.expectStopped();
            testSocket.close();
            testSocket2.close();
        }
    }
    // Check that there is no port leaked after all keepalives and sockets are closed.
    assertFalse(isUdpPortInUse(srcPort));
    assertFalse(isUdpPortInUse(srcPort2));
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#end_block

#method_before
@Test
public void testTcpSocketKeepalives() {
    runTestWithSerialExecutors(executor -> {
        try {
            doTestTcpSocketKeepalivesWithExecutor(executor);
        } catch (Exception e) {
            fail(e.getMessage());
        }
    });
}
#method_after
@Test
public void testTcpSocketKeepalives() throws Exception {
    runTestWithSerialExecutors(executor -> doTestTcpSocketKeepalivesWithExecutor(executor));
}
#end_block

#method_before
private void doTestNattSocketKeepalivesFdWithExecutor(Executor executor) throws Exception {
    final int srcPort = 12345;
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress anyIPv4 = InetAddress.getByName("0.0.0.0");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final int validKaInterval = 15;
    // Prepare the target network.
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Prepare the target file descriptor, keep only one instance.
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket(srcPort);
    final ParcelFileDescriptor testPfd = ParcelFileDescriptor.dup(testSocket.getFileDescriptor());
    testSocket.close();
    assertTrue(isUdpPortInUse(srcPort));
    // block.
    try (SocketKeepalive ka = mCm.createNattKeepalive(myNet, testPfd, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that the ParcelFileDescriptor is still valid after keepalive stopped,
    // ErrnoException with EBADF will be thrown if the socket is closed when checking local
    // address.
    assertTrue(isUdpPortInUse(srcPort));
    final InetSocketAddress sa = (InetSocketAddress) Os.getsockname(testPfd.getFileDescriptor());
    assertEquals(anyIPv4, sa.getAddress());
    testPfd.close();
    assertFalse(isUdpPortInUse(srcPort));
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#method_after
private void doTestNattSocketKeepalivesFdWithExecutor(Executor executor) throws Exception {
    final InetAddress myIPv4 = InetAddress.getByName("192.0.2.129");
    final InetAddress anyIPv4 = InetAddress.getByName("0.0.0.0");
    final InetAddress dstIPv4 = InetAddress.getByName("8.8.8.8");
    final int validKaInterval = 15;
    // Prepare the target network.
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan12");
    lp.addLinkAddress(new LinkAddress(myIPv4, 25));
    lp.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    Network myNet = connectKeepaliveNetwork(lp);
    mWiFiNetworkAgent.setStartKeepaliveError(SocketKeepalive.SUCCESS);
    mWiFiNetworkAgent.setStopKeepaliveError(SocketKeepalive.SUCCESS);
    TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback(executor);
    // Prepare the target file descriptor, keep only one instance.
    final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);
    final UdpEncapsulationSocket testSocket = mIpSec.openUdpEncapsulationSocket();
    final int srcPort = testSocket.getPort();
    final ParcelFileDescriptor testPfd = ParcelFileDescriptor.dup(testSocket.getFileDescriptor());
    testSocket.close();
    assertTrue(isUdpPortInUse(srcPort));
    // block.
    try (SocketKeepalive ka = mCm.createNattKeepalive(myNet, testPfd, myIPv4, dstIPv4, executor, callback)) {
        ka.start(validKaInterval);
        callback.expectStarted();
        ka.stop();
        callback.expectStopped();
    }
    // Check that the ParcelFileDescriptor is still valid after keepalive stopped,
    // ErrnoException with EBADF will be thrown if the socket is closed when checking local
    // address.
    assertTrue(isUdpPortInUse(srcPort));
    final InetSocketAddress sa = (InetSocketAddress) Os.getsockname(testPfd.getFileDescriptor());
    assertEquals(anyIPv4, sa.getAddress());
    testPfd.close();
    assertFalse(isUdpPortInUse(srcPort));
    mWiFiNetworkAgent.disconnect();
    waitFor(mWiFiNetworkAgent.getDisconnectedCV());
    mWiFiNetworkAgent = null;
}
#end_block

