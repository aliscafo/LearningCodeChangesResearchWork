220
#method_before
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String filePath = request.getParameter("filePath");
    if (Objects.isNull(filePath)) {
        logger.log(Level.WARNING, "filePath parameter is null!");
    } else {
        logger.log(Level.INFO, "filePath parameter => " + filePath);
        Key<TestSuiteFileEntity> testSuiteFileEntityKey = Key.create(TestSuiteFileEntity.class, filePath);
        TestSuiteFileEntity testSuiteFileEntity = ofy().load().type(TestSuiteFileEntity.class).filterKey(testSuiteFileEntityKey).first().now();
        if (Objects.isNull(testSuiteFileEntity)) {
            Blob blobFile = (Blob) this.syncCache.get(filePath);
            if (Objects.isNull(blobFile)) {
                Bucket vtsReportBucket = this.storage.get(GCS_BUCKET_NAME);
                blobFile = vtsReportBucket.get(filePath);
                this.syncCache.put(filePath, blobFile);
            }
            if (blobFile.exists()) {
                TestSuiteFileEntity newTestSuiteFileEntity = new TestSuiteFileEntity(filePath);
                newTestSuiteFileEntity.save();
                TestSuiteResultMessageProto.TestSuiteResultMessage testSuiteResultMessage;
                try {
                    // String payload = blobFile.getContent().collect(Collectors.joining());
                    // byte[] value = Base64.decodeBase64(payload);
                    testSuiteResultMessage = TestSuiteResultMessageProto.TestSuiteResultMessage.parseFrom(blobFile.getContent());
                    TestSuiteResultEntity testSuiteResultEntity = new TestSuiteResultEntity(testSuiteFileEntityKey, testSuiteResultMessage.getStartTime(), testSuiteResultMessage.getEndTime(), testSuiteResultMessage.getTestType(), testSuiteResultMessage.getBootSuccess(), testSuiteResultMessage.getResultPath(), testSuiteResultMessage.getInfraLogPath(), testSuiteResultMessage.getHostName(), testSuiteResultMessage.getSuitePlan(), testSuiteResultMessage.getSuiteVersion(), testSuiteResultMessage.getSuiteName(), testSuiteResultMessage.getSuiteBuildNumber(), testSuiteResultMessage.getModulesDone(), testSuiteResultMessage.getModulesTotal(), testSuiteResultMessage.getBranch(), testSuiteResultMessage.getTarget(), testSuiteResultMessage.getBuildId(), testSuiteResultMessage.getBuildSystemFingerprint(), testSuiteResultMessage.getBuildVendorFingerprint(), testSuiteResultMessage.getPassedTestCaseCount(), testSuiteResultMessage.getFailedTestCaseCount());
                    // testSuiteResultMessage.getTestType()
                    testSuiteResultEntity.save();
                } catch (IOException e) {
                    ofy().delete().type(TestSuiteFileEntity.class).id(filePath).now();
                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                    logger.log(Level.WARNING, "Invalid proto: " + e.getLocalizedMessage());
                }
            }
        } else {
            logger.log(Level.INFO, "suite test found in datastore!");
        }
    }
}
#method_after
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String filePath = request.getParameter("filePath");
    if (Objects.isNull(filePath)) {
        logger.log(Level.WARNING, "filePath parameter is null!");
    } else {
        logger.log(Level.INFO, "filePath parameter => " + filePath);
        Key<TestSuiteFileEntity> testSuiteFileEntityKey = Key.create(TestSuiteFileEntity.class, filePath);
        TestSuiteFileEntity testSuiteFileEntity = ofy().load().type(TestSuiteFileEntity.class).filterKey(testSuiteFileEntityKey).first().now();
        if (Objects.isNull(testSuiteFileEntity)) {
            Blob blobFile = (Blob) this.syncCache.get(filePath);
            if (Objects.isNull(blobFile)) {
                Bucket vtsReportBucket = this.storage.get(GCS_BUCKET_NAME);
                blobFile = vtsReportBucket.get(filePath);
                this.syncCache.put(filePath, blobFile);
            }
            if (blobFile.exists()) {
                TestSuiteFileEntity newTestSuiteFileEntity = new TestSuiteFileEntity(filePath);
                newTestSuiteFileEntity.save();
                TestSuiteResultMessageProto.TestSuiteResultMessage testSuiteResultMessage;
                try {
                    // String payload = blobFile.getContent().collect(Collectors.joining());
                    // byte[] value = Base64.decodeBase64(payload);
                    testSuiteResultMessage = TestSuiteResultMessageProto.TestSuiteResultMessage.parseFrom(blobFile.getContent());
                    TestSuiteResultEntity testSuiteResultEntity = new TestSuiteResultEntity(testSuiteFileEntityKey, testSuiteResultMessage.getStartTime(), testSuiteResultMessage.getEndTime(), testSuiteResultMessage.getTestType(), testSuiteResultMessage.getBootSuccess(), testSuiteResultMessage.getResultPath(), testSuiteResultMessage.getInfraLogPath(), testSuiteResultMessage.getHostName(), testSuiteResultMessage.getSuitePlan(), testSuiteResultMessage.getSuiteVersion(), testSuiteResultMessage.getSuiteName(), testSuiteResultMessage.getSuiteBuildNumber(), testSuiteResultMessage.getModulesDone(), testSuiteResultMessage.getModulesTotal(), testSuiteResultMessage.getBranch(), testSuiteResultMessage.getTarget(), testSuiteResultMessage.getBuildId(), testSuiteResultMessage.getBuildSystemFingerprint(), testSuiteResultMessage.getBuildVendorFingerprint(), testSuiteResultMessage.getPassedTestCaseCount(), testSuiteResultMessage.getFailedTestCaseCount());
                    testSuiteResultEntity.save();
                } catch (IOException e) {
                    ofy().delete().type(TestSuiteFileEntity.class).id(filePath).now();
                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                    logger.log(Level.WARNING, "Invalid proto: " + e.getLocalizedMessage());
                }
            }
        } else {
            logger.log(Level.INFO, "suite test found in datastore!");
        }
    }
}
#end_block

#method_before
private int runUninstall() throws RemoteException {
    final PrintWriter pw = getOutPrintWriter();
    int flags = 0;
    int userId = UserHandle.USER_ALL;
    int versionCode = PackageManager.VERSION_CODE_HIGHEST;
    String opt;
    while ((opt = getNextOption()) != null) {
        switch(opt) {
            case "-k":
                flags |= PackageManager.DELETE_KEEP_DATA;
                break;
            case "--user":
                userId = UserHandle.parseUserArg(getNextArgRequired());
                break;
            case "--versionCode":
                versionCode = Integer.parseInt(getNextArgRequired());
                break;
            default:
                pw.println("Error: Unknown option: " + opt);
                return 1;
        }
    }
    final String packageName = getNextArg();
    if (packageName == null) {
        pw.println("Error: package name not specified");
        return 1;
    }
    // if a split is specified, just remove it and not the whole package
    final String splitName = getNextArg();
    if (splitName != null) {
        return runRemoveSplit(packageName, splitName);
    }
    userId = translateUserId(userId, "runUninstall");
    if (userId == UserHandle.USER_ALL) {
        userId = UserHandle.USER_SYSTEM;
        flags |= PackageManager.DELETE_ALL_USERS;
    } else {
        final PackageInfo info = mInterface.getPackageInfo(packageName, PackageManager.MATCH_STATIC_SHARED_LIBRARIES, userId);
        if (info == null) {
            pw.println("Failure [not installed for " + userId + "]");
            return 1;
        }
        final boolean isSystem = (info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
        // version of the app.
        if (isSystem) {
            flags |= PackageManager.DELETE_SYSTEM_APP;
        }
    }
    final LocalIntentReceiver receiver = new LocalIntentReceiver();
    final VersionedPackage uninstallPkg = new VersionedPackage(packageName, versionCode);
    final int uninstallFlags = flags;
    final int uninstallForUserId = userId;
    new Thread(() -> {
        try {
            mInterface.getPackageInstaller().uninstall(uninstallPkg, null, /*callerPackageName*/
            uninstallFlags, receiver.getIntentSender(), uninstallForUserId);
        } catch (Exception e) {
            Intent intent = new Intent();
            intent.putExtra(PackageInstaller.EXTRA_PACKAGE_NAME, packageName);
            intent.putExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);
            try {
                receiver.mResult.offer(intent, 5, TimeUnit.SECONDS);
            } catch (InterruptedException e1) {
            }
        }
    }).start();
    final Intent result = receiver.getResult();
    final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);
    if (status == PackageInstaller.STATUS_SUCCESS) {
        pw.println("Success");
        return 0;
    } else {
        pw.println("Failure [" + result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + "]");
        return 1;
    }
}
#method_after
private int runUninstall() throws RemoteException {
    final PrintWriter pw = getOutPrintWriter();
    int flags = 0;
    int userId = UserHandle.USER_ALL;
    int versionCode = PackageManager.VERSION_CODE_HIGHEST;
    String opt;
    while ((opt = getNextOption()) != null) {
        switch(opt) {
            case "-k":
                flags |= PackageManager.DELETE_KEEP_DATA;
                break;
            case "--user":
                userId = UserHandle.parseUserArg(getNextArgRequired());
                break;
            case "--versionCode":
                versionCode = Integer.parseInt(getNextArgRequired());
                break;
            default:
                pw.println("Error: Unknown option: " + opt);
                return 1;
        }
    }
    final String packageName = getNextArg();
    if (packageName == null) {
        pw.println("Error: package name not specified");
        return 1;
    }
    // if a split is specified, just remove it and not the whole package
    final String splitName = getNextArg();
    if (splitName != null) {
        return runRemoveSplit(packageName, splitName);
    }
    userId = translateUserId(userId, "runUninstall");
    if (userId == UserHandle.USER_ALL) {
        userId = UserHandle.USER_SYSTEM;
        flags |= PackageManager.DELETE_ALL_USERS;
    } else {
        final PackageInfo info = mInterface.getPackageInfo(packageName, PackageManager.MATCH_STATIC_SHARED_LIBRARIES, userId);
        if (info == null) {
            pw.println("Failure [not installed for " + userId + "]");
            return 1;
        }
        final boolean isSystem = (info.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
        // version of the app.
        if (isSystem) {
            flags |= PackageManager.DELETE_SYSTEM_APP;
        }
    }
    final LocalIntentReceiver receiver = new LocalIntentReceiver();
    mInterface.getPackageInstaller().uninstall(new VersionedPackage(packageName, versionCode), null, /*callerPackageName*/
    flags, receiver.getIntentSender(), userId);
    final Intent result = receiver.getResult();
    final int status = result.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);
    if (status == PackageInstaller.STATUS_SUCCESS) {
        pw.println("Success");
        return 0;
    } else {
        pw.println("Failure [" + result.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) + "]");
        return 1;
    }
}
#end_block

#method_before
public NetworkStats readNetworkStatsSummaryDev() throws IOException {
    // Return the stats get from /proc/net/dev if switched to bpf module.
    if (mUseBpfStats)
        return readBpfNetworkStatsDev();
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskReads();
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), 6);
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    ProcFileReader reader = null;
    try {
        reader = new ProcFileReader(new FileInputStream(mStatsXtIfaceAll));
        while (reader.hasMoreData()) {
            entry.iface = reader.nextString();
            entry.uid = UID_ALL;
            entry.set = SET_ALL;
            entry.tag = TAG_NONE;
            final boolean active = reader.nextInt() != 0;
            // always include snapshot values
            entry.rxBytes = reader.nextLong();
            entry.rxPackets = reader.nextLong();
            entry.txBytes = reader.nextLong();
            entry.txPackets = reader.nextLong();
            // fold in active numbers, but only when active
            if (active) {
                entry.rxBytes += reader.nextLong();
                entry.rxPackets += reader.nextLong();
                entry.txBytes += reader.nextLong();
                entry.txPackets += reader.nextLong();
            }
            stats.addValues(entry);
            reader.finishLine();
        }
    } catch (NullPointerException | NumberFormatException e) {
        throw new ProtocolException("problem parsing stats", e);
    } finally {
        IoUtils.closeQuietly(reader);
        StrictMode.setThreadPolicy(savedPolicy);
    }
    return stats;
}
#method_after
public NetworkStats readNetworkStatsSummaryDev() throws IOException {
    // Return xt_bpf stats if switched to bpf module.
    if (mUseBpfStats)
        return readBpfNetworkStatsDev();
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskReads();
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), 6);
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    ProcFileReader reader = null;
    try {
        reader = new ProcFileReader(new FileInputStream(mStatsXtIfaceAll));
        while (reader.hasMoreData()) {
            entry.iface = reader.nextString();
            entry.uid = UID_ALL;
            entry.set = SET_ALL;
            entry.tag = TAG_NONE;
            final boolean active = reader.nextInt() != 0;
            // always include snapshot values
            entry.rxBytes = reader.nextLong();
            entry.rxPackets = reader.nextLong();
            entry.txBytes = reader.nextLong();
            entry.txPackets = reader.nextLong();
            // fold in active numbers, but only when active
            if (active) {
                entry.rxBytes += reader.nextLong();
                entry.rxPackets += reader.nextLong();
                entry.txBytes += reader.nextLong();
                entry.txPackets += reader.nextLong();
            }
            stats.addValues(entry);
            reader.finishLine();
        }
    } catch (NullPointerException | NumberFormatException e) {
        throw new ProtocolException("problem parsing stats", e);
    } finally {
        IoUtils.closeQuietly(reader);
        StrictMode.setThreadPolicy(savedPolicy);
    }
    return stats;
}
#end_block

#method_before
public NetworkStats readNetworkStatsSummaryXt() throws IOException {
    // Return the stats get from /proc/net/dev if qtaguid  module is replaced.
    if (mUseBpfStats)
        return readBpfNetworkStatsDev();
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskReads();
    // return null when kernel doesn't support
    if (!mStatsXtIfaceFmt.exists())
        return null;
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), 6);
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    ProcFileReader reader = null;
    try {
        // open and consume header line
        reader = new ProcFileReader(new FileInputStream(mStatsXtIfaceFmt));
        reader.finishLine();
        while (reader.hasMoreData()) {
            entry.iface = reader.nextString();
            entry.uid = UID_ALL;
            entry.set = SET_ALL;
            entry.tag = TAG_NONE;
            entry.rxBytes = reader.nextLong();
            entry.rxPackets = reader.nextLong();
            entry.txBytes = reader.nextLong();
            entry.txPackets = reader.nextLong();
            stats.addValues(entry);
            reader.finishLine();
        }
    } catch (NullPointerException | NumberFormatException e) {
        throw new ProtocolException("problem parsing stats", e);
    } finally {
        IoUtils.closeQuietly(reader);
        StrictMode.setThreadPolicy(savedPolicy);
    }
    return stats;
}
#method_after
public NetworkStats readNetworkStatsSummaryXt() throws IOException {
    // Return xt_bpf stats if qtaguid  module is replaced.
    if (mUseBpfStats)
        return readBpfNetworkStatsDev();
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskReads();
    // return null when kernel doesn't support
    if (!mStatsXtIfaceFmt.exists())
        return null;
    final NetworkStats stats = new NetworkStats(SystemClock.elapsedRealtime(), 6);
    final NetworkStats.Entry entry = new NetworkStats.Entry();
    ProcFileReader reader = null;
    try {
        // open and consume header line
        reader = new ProcFileReader(new FileInputStream(mStatsXtIfaceFmt));
        reader.finishLine();
        while (reader.hasMoreData()) {
            entry.iface = reader.nextString();
            entry.uid = UID_ALL;
            entry.set = SET_ALL;
            entry.tag = TAG_NONE;
            entry.rxBytes = reader.nextLong();
            entry.rxPackets = reader.nextLong();
            entry.txBytes = reader.nextLong();
            entry.txPackets = reader.nextLong();
            stats.addValues(entry);
            reader.finishLine();
        }
    } catch (NullPointerException | NumberFormatException e) {
        throw new ProtocolException("problem parsing stats", e);
    } finally {
        IoUtils.closeQuietly(reader);
        StrictMode.setThreadPolicy(savedPolicy);
    }
    return stats;
}
#end_block

#method_before
public NetworkStats readNetworkStatsDetail(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException {
    final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats);
    // Total 464xlat traffic to subtract from uid 0 on all base interfaces.
    // sStackedIfaces may grow afterwards, but NetworkStats will just be resized automatically.
    final NetworkStats adjustments = new NetworkStats(0, sStackedIfaces.size());
    // For recycling
    NetworkStats.Entry entry = null;
    // and rx traffic (http://b/12249687, http:/b/33681750).
    for (int i = 0; i < stats.size(); i++) {
        entry = stats.getValues(i, entry);
        if (entry.iface == null || !entry.iface.startsWith(CLATD_INTERFACE_PREFIX)) {
            continue;
        }
        final String baseIface = sStackedIfaces.get(entry.iface);
        if (baseIface == null) {
            continue;
        }
        NetworkStats.Entry adjust = new NetworkStats.Entry(baseIface, 0, 0, 0, 0, 0, 0, 0L, 0L, 0L, 0L, 0L);
        // Subtract any 464lat traffic seen for the root UID on the current base interface.
        adjust.rxBytes -= (entry.rxBytes + entry.rxPackets * IPV4V6_HEADER_DELTA);
        adjust.txBytes -= (entry.txBytes + entry.txPackets * IPV4V6_HEADER_DELTA);
        adjust.rxPackets -= entry.rxPackets;
        adjust.txPackets -= entry.txPackets;
        adjustments.combineValues(adjust);
        // For 464xlat traffic, xt_qtaguid only counts the bytes of the native IPv4 packet sent
        // on the stacked interface with prefix "v4-" and drops the IPv6 header size after
        // unwrapping. To account correctly for on-the-wire traffic, add the 20 additional bytes
        // difference for all packets (http://b/12249687, http:/b/33681750).
        entry.rxBytes = entry.rxPackets * IPV4V6_HEADER_DELTA;
        entry.txBytes = entry.txPackets * IPV4V6_HEADER_DELTA;
        entry.rxPackets = 0;
        entry.txPackets = 0;
        stats.combineValues(entry);
    }
    stats.combineAllValues(adjustments);
    return stats;
}
#method_after
public NetworkStats readNetworkStatsDetail(int limitUid, String[] limitIfaces, int limitTag, NetworkStats lastStats) throws IOException {
    final NetworkStats stats = readNetworkStatsDetailInternal(limitUid, limitIfaces, limitTag, lastStats);
    // No locking here: apply464xlatAdjustments behaves fine with an add-only ConcurrentHashMap.
    // TODO: remove this and only apply adjustments in NetworkStatsService.
    stats.apply464xlatAdjustments(sStackedIfaces);
    return stats;
}
#end_block

#method_before
protected void updateVtsRunnerTestConfig(JSONObject jsonObject) throws IOException, JSONException, RuntimeException {
    configReader = new VtsVendorConfigFileUtil();
    if (configReader.LoadVendorConfig(mBuildInfo)) {
        JSONObject vendorConfigJson = configReader.GetVendorConfigJson();
        if (vendorConfigJson != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, vendorConfigJson);
        }
    }
    CLog.i("Load original test config %s %s", mTestCaseDataDir, mTestConfigPath);
    String content = null;
    if (mTestConfigPath != null) {
        content = FileUtil.readStringFromFile(new File(Paths.get(mTestCaseDataDir, mTestConfigPath).toString()));
        CLog.i("Loaded original test config %s", content);
        if (content != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, new JSONObject(content));
        }
    }
    populateDefaultJsonFields(jsonObject, mTestCaseDataDir);
    CLog.i("Built a Json object using the loaded original test config");
    JSONArray deviceArray = new JSONArray();
    boolean coverageBuild = false;
    boolean sancovBuild = false;
    boolean first_device = true;
    for (ITestDevice device : mInvocationContext.getDevices()) {
        JSONObject deviceJson = generateJsonDeviceItem(device);
        try {
            String coverageProperty = device.getProperty(COVERAGE_PROPERTY);
            boolean enable_coverage_for_device = coverageProperty != null && coverageProperty.equals("1");
            if (first_device) {
                coverageBuild = enable_coverage_for_device;
                first_device = false;
            } else {
                if (coverageBuild && (!enable_coverage_for_device)) {
                    CLog.e("Device %s is not coverage build while others are.", device.getSerialNumber());
                    throw new RuntimeException("Device build not the same.");
                }
            }
        } catch (DeviceNotAvailableException e) {
            CLog.e("Device %s not available.", device.getSerialNumber());
            throw new RuntimeException("Failed to get device information");
        }
        File sancovDir = mBuildInfo.getFile(VtsCoveragePreparer.getSancovResourceDirKey(device));
        if (sancovDir != null) {
            deviceJson.put("sancov_resources_path", sancovDir.getAbsolutePath());
            sancovBuild = true;
        }
        File gcovDir = mBuildInfo.getFile(VtsCoveragePreparer.getGcovResourceDirKey(device));
        if (gcovDir != null) {
            deviceJson.put("gcov_resources_path", gcovDir.getAbsolutePath());
            coverageBuild = true;
        }
        deviceArray.put(deviceJson);
    }
    JSONArray testBedArray = (JSONArray) jsonObject.get(TEST_BED);
    if (testBedArray.length() == 0) {
        JSONObject testBedItemObject = new JSONObject();
        String testName;
        if (mTestModuleName != null) {
            testName = mTestModuleName;
        } else {
            CLog.w("--test-module-name not set (not recommended); deriving automatically");
            if (mTestConfigPath != null) {
                testName = new File(mTestConfigPath).getName();
                testName = testName.replace(CONFIG_FILE_EXTENSION, "");
            } else if (mTestCasePath != null) {
                testName = new File(mTestCasePath).getName();
            } else {
                throw new RuntimeException("Failed to derive test module name; use --test-module-name option");
            }
        }
        CLog.logAndDisplay(LogLevel.INFO, "Setting test name as %s", testName);
        testBedItemObject.put(NAME, testName);
        testBedItemObject.put(ANDROIDDEVICE, deviceArray);
        testBedArray.put(testBedItemObject);
    } else if (testBedArray.length() == 1) {
        JSONObject testBedItemObject = (JSONObject) testBedArray.get(0);
        JSONArray androidDeviceArray = (JSONArray) testBedItemObject.get(ANDROIDDEVICE);
        int length;
        length = (androidDeviceArray.length() > deviceArray.length()) ? androidDeviceArray.length() : deviceArray.length();
        for (int index = 0; index < length; index++) {
            if (index < androidDeviceArray.length()) {
                if (index < deviceArray.length()) {
                    JsonUtil.deepMergeJsonObjects((JSONObject) androidDeviceArray.get(index), (JSONObject) deviceArray.get(index));
                }
            } else if (index < deviceArray.length()) {
                androidDeviceArray.put(index, deviceArray.get(index));
            }
        }
    } else {
        CLog.e("Multi-device not yet supported: %d devices requested", testBedArray.length());
        throw new RuntimeException("Failed to produce VTS runner test config");
    }
    jsonObject.put(DATA_FILE_PATH, mTestCaseDataDir);
    CLog.i("Added %s = %s to the Json object", DATA_FILE_PATH, mTestCaseDataDir);
    JSONObject build = new JSONObject();
    build.put(BUILD_ID, mBuildInfo.getBuildId());
    build.put(BUILD_TARGET, mBuildInfo.getBuildTargetName());
    jsonObject.put(BUILD, build);
    CLog.i("Added %s to the Json object", BUILD);
    JSONObject suite = new JSONObject();
    suite.put(NAME, mBuildInfo.getTestTag());
    suite.put(INCLUDE_FILTER, new JSONArray(mIncludeFilters));
    CLog.i("Added include filter to test suite: %s", mIncludeFilters);
    suite.put(EXCLUDE_FILTER, new JSONArray(mExcludeFilters));
    CLog.i("Added exclude filter to test suite: %s", mExcludeFilters);
    String coverageReportPath = mBuildInfo.getBuildAttributes().get("coverage_report_path");
    if (coverageReportPath != null) {
        jsonObject.put(OUTPUT_COVERAGE_REPORT, true);
        CLog.i("Added %s to the Json object", OUTPUT_COVERAGE_REPORT);
        jsonObject.put(COVERAGE_REPORT_PATH, coverageReportPath);
        CLog.i("Added %s to the Json object", COVERAGE_REPORT_PATH);
    }
    if (mExcludeOverInclude) {
        jsonObject.put(EXCLUDE_OVER_INCLUDE, mExcludeOverInclude);
        CLog.i("Added %s to the Json object", EXCLUDE_OVER_INCLUDE);
    }
    jsonObject.put(TEST_SUITE, suite);
    CLog.i("Added %s to the Json object", TEST_SUITE);
    if (!mLogSeverity.isEmpty()) {
        String logSeverity = mLogSeverity.toUpperCase();
        ArrayList<String> severityList = new ArrayList<String>(Arrays.asList("ERROR", "WARNING", "INFO", "DEBUG"));
        if (!severityList.contains(logSeverity)) {
            CLog.w("Unsupported log severity %s, use default log_severity:INFO instead.", logSeverity);
            logSeverity = "INFO";
        }
        jsonObject.put(LOG_SEVERITY, logSeverity);
        CLog.i("Added %s to the Json object: %s", LOG_SEVERITY, logSeverity);
    }
    if (mAbi != null) {
        jsonObject.put(ABI_NAME, mAbi.getName());
        CLog.i("Added %s to the Json object", ABI_NAME);
        jsonObject.put(ABI_BITNESS, mAbi.getBitness());
        CLog.i("Added %s to the Json object", ABI_BITNESS);
    }
    if (mSkipOn32BitAbi) {
        jsonObject.put(SKIP_ON_32BIT_ABI, mSkipOn32BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_32BIT_ABI);
    }
    if (mSkipOn64BitAbi) {
        jsonObject.put(SKIP_ON_64BIT_ABI, mSkipOn64BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_64BIT_ABI);
    } else if (mRun32bBitOn64BitAbi) {
        jsonObject.put(RUN_32BIT_ON_64BIT_ABI, mRun32bBitOn64BitAbi);
        CLog.i("Added %s to the Json object", RUN_32BIT_ON_64BIT_ABI);
    }
    if (mSkipIfThermalThrottling) {
        jsonObject.put(SKIP_IF_THERMAL_THROTTLING, mSkipIfThermalThrottling);
        CLog.i("Added %s to the Json object", SKIP_IF_THERMAL_THROTTLING);
    }
    jsonObject.put(DISABLE_CPU_FREQUENCY_SCALING, mDisableCpuFrequencyScaling);
    CLog.i("Added %s to the Json object, value: %s", DISABLE_CPU_FREQUENCY_SCALING, mDisableCpuFrequencyScaling);
    if (!mBinaryTestSource.isEmpty()) {
        jsonObject.put(BINARY_TEST_SOURCE, new JSONArray(mBinaryTestSource));
        CLog.i("Added %s to the Json object", BINARY_TEST_SOURCE);
    }
    if (!mBinaryTestWorkingDirectory.isEmpty()) {
        jsonObject.put(BINARY_TEST_WORKING_DIRECTORY, new JSONArray(mBinaryTestWorkingDirectory));
        CLog.i("Added %s to the Json object", BINARY_TEST_WORKING_DIRECTORY);
    }
    if (!mBinaryTestEnvp.isEmpty()) {
        jsonObject.put(BINARY_TEST_ENVP, new JSONArray(mBinaryTestEnvp));
        CLog.i("Added %s to the Json object", BINARY_TEST_ENVP);
    }
    if (!mBinaryTestArgs.isEmpty()) {
        jsonObject.put(BINARY_TEST_ARGS, new JSONArray(mBinaryTestArgs));
        CLog.i("Added %s to the Json object", BINARY_TEST_ARGS);
    }
    if (!mBinaryTestLdLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_LD_LIBRARY_PATH, new JSONArray(mBinaryTestLdLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_LD_LIBRARY_PATH);
    }
    if (mBugReportOnFailure) {
        jsonObject.put(BUG_REPORT_ON_FAILURE, mBugReportOnFailure);
        CLog.i("Added %s to the Json object", BUG_REPORT_ON_FAILURE);
    }
    if (!mLogcatOnFailure) {
        jsonObject.put(LOGCAT_ON_FAILURE, mLogcatOnFailure);
        CLog.i("Added %s to the Json object", LOGCAT_ON_FAILURE);
    }
    if (mEnableProfiling) {
        jsonObject.put(ENABLE_PROFILING, mEnableProfiling);
        CLog.i("Added %s to the Json object", ENABLE_PROFILING);
    }
    if (mSaveTraceFileRemote) {
        jsonObject.put(SAVE_TRACE_FIEL_REMOTE, mSaveTraceFileRemote);
        CLog.i("Added %s to the Json object", SAVE_TRACE_FIEL_REMOTE);
    }
    if (mEnableSystrace) {
        jsonObject.put(ENABLE_SYSTRACE, mEnableSystrace);
        CLog.i("Added %s to the Json object", ENABLE_SYSTRACE);
    }
    if (mEnableCoverage) {
        jsonObject.put(GLOBAL_COVERAGE, mGlobalCoverage);
        if (!mExcludeCoveragePath.isEmpty()) {
            jsonObject.put(EXCLUDE_COVERAGE_PATH, new JSONArray(mExcludeCoveragePath));
            CLog.i("Added %s to the Json object", EXCLUDE_COVERAGE_PATH);
        }
        if (coverageBuild) {
            jsonObject.put(ENABLE_COVERAGE, mEnableCoverage);
            CLog.i("Added %s to the Json object", ENABLE_COVERAGE);
        } else {
            CLog.i("Device build has coverage disabled");
        }
    }
    if (mEnableSancov) {
        if (sancovBuild) {
            jsonObject.put(ENABLE_SANCOV, mEnableSancov);
            CLog.i("Added %s to the Json object", ENABLE_SANCOV);
        } else {
            CLog.i("Device build has sancov disabled");
        }
    }
    if (mPreconditionHwBinderServiceName != null) {
        jsonObject.put(PRECONDITION_HWBINDER_SERVICE, mPreconditionHwBinderServiceName);
        CLog.i("Added %s to the Json object", PRECONDITION_HWBINDER_SERVICE);
    }
    if (mPreconditionFeature != null) {
        jsonObject.put(PRECONDITION_FEATURE, mPreconditionFeature);
        CLog.i("Added %s to the Json object", PRECONDITION_FEATURE);
    }
    if (!mPreconditionFilePathPrefix.isEmpty()) {
        jsonObject.put(PRECONDITION_FILE_PATH_PREFIX, new JSONArray(mPreconditionFilePathPrefix));
        CLog.i("Added %s to the Json object", PRECONDITION_FILE_PATH_PREFIX);
    }
    if (mPreconditionLshal != null) {
        jsonObject.put(PRECONDITION_LSHAL, mPreconditionLshal);
        CLog.i("Added %s to the Json object", PRECONDITION_LSHAL);
    }
    if (mPreconditionVintf != null) {
        jsonObject.put(PRECONDITION_VINTF, mPreconditionVintf);
        CLog.i("Added %s to the Json object", PRECONDITION_VINTF);
    }
    if (mPreconditionSysProp != null) {
        jsonObject.put(PRECONDITION_SYSPROP, mPreconditionSysProp);
        CLog.i("Added %s to the Json object", PRECONDITION_SYSPROP);
    }
    if (!mBinaryTestProfilingLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH);
    }
    if (mBinaryTestDisableFramework) {
        jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework);
        CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK);
    }
    if (mBinaryTestStopNativeServers) {
        jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers);
        CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS);
    }
    if (!mNativeServerProcessName.isEmpty()) {
        jsonObject.put(NATIVE_SERVER_PROCESS_NAME, new JSONArray(mNativeServerProcessName));
        CLog.i("Added %s to the Json object", NATIVE_SERVER_PROCESS_NAME);
    }
    if (!mHalHidlReplayTestTracePaths.isEmpty()) {
        jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
        CLog.i("Added %s to the Json object", HAL_HIDL_REPLAY_TEST_TRACE_PATHS);
    }
    if (mHalHidlPackageName != null) {
        jsonObject.put(HAL_HIDL_PACKAGE_NAME, mHalHidlPackageName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mSystraceProcessName != null) {
        jsonObject.put(SYSTRACE_PROCESS_NAME, mSystraceProcessName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mPassthroughMode) {
        jsonObject.put(PASSTHROUGH_MODE, mPassthroughMode);
        CLog.i("Added %s to the Json object", PASSTHROUGH_MODE);
    }
    if (mCollectTestsOnly) {
        jsonObject.put(COLLECT_TESTS_ONLY, mCollectTestsOnly);
        CLog.i("Added %s to the Json object", COLLECT_TESTS_ONLY);
    }
    if (mGtestBatchMode) {
        jsonObject.put(GTEST_BATCH_MODE, mGtestBatchMode);
        CLog.i("Added %s to the Json object", GTEST_BATCH_MODE);
    }
    if (mLtpNumberOfThreads >= 0) {
        jsonObject.put(LTP_NUMBER_OF_THREADS, mLtpNumberOfThreads);
        CLog.i("Added %s to the Json object", LTP_NUMBER_OF_THREADS);
    }
    if (mRunAsVtsSelfTest) {
        jsonObject.put(RUN_AS_VTS_SELF_TEST, mRunAsVtsSelfTest);
        CLog.i("Added %s to the Json object", RUN_AS_VTS_SELF_TEST);
    }
    if ("vts".equals(mBuildInfo.getTestTag())) {
        jsonObject.put(RUN_AS_COMPLIANCE_TEST, true);
        CLog.i("Added %s to the Json object", RUN_AS_COMPLIANCE_TEST);
    }
    if (!mMoblyTestModule.isEmpty()) {
        jsonObject.put(MOBLY_TEST_MODULE, new JSONArray(mMoblyTestModule));
        CLog.i("Added %s to the Json object", MOBLY_TEST_MODULE);
    }
    if (mActsTestModule != null) {
        jsonObject.put(ACTS_TEST_MODULE, mActsTestModule);
        CLog.i("Added %s to the Json object", ACTS_TEST_MODULE);
    }
    if (mBuildInfo.getFile(VIRTUALENVPATH) != null) {
        jsonObject.put(VIRTUALENVPATH, mBuildInfo.getFile(VIRTUALENVPATH).getAbsolutePath());
    }
    if (mBuildInfo.getFile(VIRTUALENVPATH_V3) != null) {
        jsonObject.put(VIRTUALENVPATH_V3, mBuildInfo.getFile(VIRTUALENVPATH_V3).getAbsolutePath());
    }
}
#method_after
protected void updateVtsRunnerTestConfig(JSONObject jsonObject) throws IOException, JSONException, RuntimeException {
    configReader = new VtsVendorConfigFileUtil();
    if (configReader.LoadVendorConfig(mBuildInfo)) {
        JSONObject vendorConfigJson = configReader.GetVendorConfigJson();
        if (vendorConfigJson != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, vendorConfigJson);
        }
    }
    CLog.i("Load original test config %s %s", mTestCaseDataDir, mTestConfigPath);
    String content = null;
    if (mTestConfigPath != null) {
        content = FileUtil.readStringFromFile(new File(Paths.get(mTestCaseDataDir, mTestConfigPath).toString()));
        CLog.i("Loaded original test config %s", content);
        if (content != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, new JSONObject(content));
        }
    }
    populateDefaultJsonFields(jsonObject, mTestCaseDataDir);
    CLog.i("Built a Json object using the loaded original test config");
    JSONArray deviceArray = new JSONArray();
    boolean coverageBuild = false;
    boolean sancovBuild = false;
    boolean first_device = true;
    for (ITestDevice device : mInvocationContext.getDevices()) {
        JSONObject deviceJson = generateJsonDeviceItem(device);
        try {
            String coverageProperty = device.getProperty(COVERAGE_PROPERTY);
            boolean enable_coverage_for_device = coverageProperty != null && coverageProperty.equals("1");
            if (first_device) {
                coverageBuild = enable_coverage_for_device;
                first_device = false;
            } else {
                if (coverageBuild && (!enable_coverage_for_device)) {
                    CLog.e("Device %s is not coverage build while others are.", device.getSerialNumber());
                    throw new RuntimeException("Device build not the same.");
                }
            }
        } catch (DeviceNotAvailableException e) {
            CLog.e("Device %s not available.", device.getSerialNumber());
            throw new RuntimeException("Failed to get device information");
        }
        File sancovDir = mBuildInfo.getFile(VtsCoveragePreparer.getSancovResourceDirKey(device));
        if (sancovDir != null) {
            deviceJson.put("sancov_resources_path", sancovDir.getAbsolutePath());
            sancovBuild = true;
        }
        File gcovDir = mBuildInfo.getFile(VtsCoveragePreparer.getGcovResourceDirKey(device));
        if (gcovDir != null) {
            deviceJson.put("gcov_resources_path", gcovDir.getAbsolutePath());
            coverageBuild = true;
        }
        deviceArray.put(deviceJson);
    }
    JSONArray testBedArray = (JSONArray) jsonObject.get(TEST_BED);
    if (testBedArray.length() == 0) {
        JSONObject testBedItemObject = new JSONObject();
        String testName;
        if (mTestModuleName != null) {
            testName = mTestModuleName;
        } else {
            CLog.w("--test-module-name not set (not recommended); deriving automatically");
            if (mTestConfigPath != null) {
                testName = new File(mTestConfigPath).getName();
                testName = testName.replace(CONFIG_FILE_EXTENSION, "");
            } else if (mTestCasePath != null) {
                testName = new File(mTestCasePath).getName();
            } else {
                throw new RuntimeException("Failed to derive test module name; use --test-module-name option");
            }
        }
        CLog.logAndDisplay(LogLevel.INFO, "Setting test name as %s", testName);
        testBedItemObject.put(NAME, testName);
        testBedItemObject.put(ANDROIDDEVICE, deviceArray);
        testBedArray.put(testBedItemObject);
    } else if (testBedArray.length() == 1) {
        JSONObject testBedItemObject = (JSONObject) testBedArray.get(0);
        JSONArray androidDeviceArray = (JSONArray) testBedItemObject.get(ANDROIDDEVICE);
        int length;
        length = (androidDeviceArray.length() > deviceArray.length()) ? androidDeviceArray.length() : deviceArray.length();
        for (int index = 0; index < length; index++) {
            if (index < androidDeviceArray.length()) {
                if (index < deviceArray.length()) {
                    JsonUtil.deepMergeJsonObjects((JSONObject) androidDeviceArray.get(index), (JSONObject) deviceArray.get(index));
                }
            } else if (index < deviceArray.length()) {
                androidDeviceArray.put(index, deviceArray.get(index));
            }
        }
    } else {
        CLog.e("Multi-device not yet supported: %d devices requested", testBedArray.length());
        throw new RuntimeException("Failed to produce VTS runner test config");
    }
    jsonObject.put(DATA_FILE_PATH, mTestCaseDataDir);
    CLog.i("Added %s = %s to the Json object", DATA_FILE_PATH, mTestCaseDataDir);
    JSONObject build = new JSONObject();
    build.put(BUILD_ID, mBuildInfo.getBuildId());
    build.put(BUILD_TARGET, mBuildInfo.getBuildTargetName());
    jsonObject.put(BUILD, build);
    CLog.i("Added %s to the Json object", BUILD);
    JSONObject suite = new JSONObject();
    suite.put(NAME, mBuildInfo.getTestTag());
    suite.put(INCLUDE_FILTER, new JSONArray(mIncludeFilters));
    CLog.i("Added include filter to test suite: %s", mIncludeFilters);
    suite.put(EXCLUDE_FILTER, new JSONArray(mExcludeFilters));
    CLog.i("Added exclude filter to test suite: %s", mExcludeFilters);
    String coverageReportPath = mBuildInfo.getBuildAttributes().get("coverage_report_path");
    if (coverageReportPath != null) {
        jsonObject.put(OUTPUT_COVERAGE_REPORT, true);
        CLog.i("Added %s to the Json object", OUTPUT_COVERAGE_REPORT);
        jsonObject.put(COVERAGE_REPORT_PATH, coverageReportPath);
        CLog.i("Added %s to the Json object", COVERAGE_REPORT_PATH);
    }
    if (mExcludeOverInclude) {
        jsonObject.put(EXCLUDE_OVER_INCLUDE, mExcludeOverInclude);
        CLog.i("Added %s to the Json object", EXCLUDE_OVER_INCLUDE);
    }
    jsonObject.put(TEST_SUITE, suite);
    CLog.i("Added %s to the Json object", TEST_SUITE);
    if (!mLogSeverity.isEmpty()) {
        String logSeverity = mLogSeverity.toUpperCase();
        ArrayList<String> severityList = new ArrayList<String>(Arrays.asList("ERROR", "WARNING", "INFO", "DEBUG"));
        if (!severityList.contains(logSeverity)) {
            CLog.w("Unsupported log severity %s, use default log_severity:INFO instead.", logSeverity);
            logSeverity = "INFO";
        }
        jsonObject.put(LOG_SEVERITY, logSeverity);
        CLog.i("Added %s to the Json object: %s", LOG_SEVERITY, logSeverity);
    }
    if (mAbi != null) {
        jsonObject.put(ABI_NAME, mAbi.getName());
        CLog.i("Added %s to the Json object", ABI_NAME);
        jsonObject.put(ABI_BITNESS, mAbi.getBitness());
        CLog.i("Added %s to the Json object", ABI_BITNESS);
    }
    if (mSkipOn32BitAbi) {
        jsonObject.put(SKIP_ON_32BIT_ABI, mSkipOn32BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_32BIT_ABI);
    }
    if (mSkipOn64BitAbi) {
        jsonObject.put(SKIP_ON_64BIT_ABI, mSkipOn64BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_64BIT_ABI);
    } else if (mRun32bBitOn64BitAbi) {
        jsonObject.put(RUN_32BIT_ON_64BIT_ABI, mRun32bBitOn64BitAbi);
        CLog.i("Added %s to the Json object", RUN_32BIT_ON_64BIT_ABI);
    }
    if (mSkipIfThermalThrottling) {
        jsonObject.put(SKIP_IF_THERMAL_THROTTLING, mSkipIfThermalThrottling);
        CLog.i("Added %s to the Json object", SKIP_IF_THERMAL_THROTTLING);
    }
    jsonObject.put(DISABLE_CPU_FREQUENCY_SCALING, mDisableCpuFrequencyScaling);
    CLog.i("Added %s to the Json object, value: %s", DISABLE_CPU_FREQUENCY_SCALING, mDisableCpuFrequencyScaling);
    if (!mBinaryTestSource.isEmpty()) {
        jsonObject.put(BINARY_TEST_SOURCE, new JSONArray(mBinaryTestSource));
        CLog.i("Added %s to the Json object", BINARY_TEST_SOURCE);
    }
    if (!mBinaryTestWorkingDirectory.isEmpty()) {
        jsonObject.put(BINARY_TEST_WORKING_DIRECTORY, new JSONArray(mBinaryTestWorkingDirectory));
        CLog.i("Added %s to the Json object", BINARY_TEST_WORKING_DIRECTORY);
    }
    if (!mBinaryTestEnvp.isEmpty()) {
        jsonObject.put(BINARY_TEST_ENVP, new JSONArray(mBinaryTestEnvp));
        CLog.i("Added %s to the Json object", BINARY_TEST_ENVP);
    }
    if (!mBinaryTestArgs.isEmpty()) {
        jsonObject.put(BINARY_TEST_ARGS, new JSONArray(mBinaryTestArgs));
        CLog.i("Added %s to the Json object", BINARY_TEST_ARGS);
    }
    if (!mBinaryTestLdLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_LD_LIBRARY_PATH, new JSONArray(mBinaryTestLdLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_LD_LIBRARY_PATH);
    }
    if (mBugReportOnFailure) {
        jsonObject.put(BUG_REPORT_ON_FAILURE, mBugReportOnFailure);
        CLog.i("Added %s to the Json object", BUG_REPORT_ON_FAILURE);
    }
    if (!mLogcatOnFailure) {
        jsonObject.put(LOGCAT_ON_FAILURE, mLogcatOnFailure);
        CLog.i("Added %s to the Json object", LOGCAT_ON_FAILURE);
    }
    if (mEnableProfiling) {
        jsonObject.put(ENABLE_PROFILING, mEnableProfiling);
        CLog.i("Added %s to the Json object", ENABLE_PROFILING);
    }
    if (mSaveTraceFileRemote) {
        jsonObject.put(SAVE_TRACE_FIEL_REMOTE, mSaveTraceFileRemote);
        CLog.i("Added %s to the Json object", SAVE_TRACE_FIEL_REMOTE);
    }
    if (mEnableSystrace) {
        jsonObject.put(ENABLE_SYSTRACE, mEnableSystrace);
        CLog.i("Added %s to the Json object", ENABLE_SYSTRACE);
    }
    if (mEnableCoverage) {
        jsonObject.put(GLOBAL_COVERAGE, mGlobalCoverage);
        if (!mExcludeCoveragePath.isEmpty()) {
            jsonObject.put(EXCLUDE_COVERAGE_PATH, new JSONArray(mExcludeCoveragePath));
            CLog.i("Added %s to the Json object", EXCLUDE_COVERAGE_PATH);
        }
        if (coverageBuild) {
            jsonObject.put(ENABLE_COVERAGE, mEnableCoverage);
            CLog.i("Added %s to the Json object", ENABLE_COVERAGE);
        } else {
            CLog.i("Device build has coverage disabled");
        }
    }
    if (mEnableSancov) {
        if (sancovBuild) {
            jsonObject.put(ENABLE_SANCOV, mEnableSancov);
            CLog.i("Added %s to the Json object", ENABLE_SANCOV);
        } else {
            CLog.i("Device build has sancov disabled");
        }
    }
    if (mPreconditionHwBinderServiceName != null) {
        jsonObject.put(PRECONDITION_HWBINDER_SERVICE, mPreconditionHwBinderServiceName);
        CLog.i("Added %s to the Json object", PRECONDITION_HWBINDER_SERVICE);
    }
    if (mPreconditionFeature != null) {
        jsonObject.put(PRECONDITION_FEATURE, mPreconditionFeature);
        CLog.i("Added %s to the Json object", PRECONDITION_FEATURE);
    }
    if (!mPreconditionFilePathPrefix.isEmpty()) {
        jsonObject.put(PRECONDITION_FILE_PATH_PREFIX, new JSONArray(mPreconditionFilePathPrefix));
        CLog.i("Added %s to the Json object", PRECONDITION_FILE_PATH_PREFIX);
    }
    if (mPreconditionFirstApiLevel != 0) {
        jsonObject.put(PRECONDITION_FIRST_API_LEVEL, mPreconditionFirstApiLevel);
        CLog.i("Added %s to the Json object", PRECONDITION_FIRST_API_LEVEL);
    }
    if (mPreconditionLshal != null) {
        jsonObject.put(PRECONDITION_LSHAL, mPreconditionLshal);
        CLog.i("Added %s to the Json object", PRECONDITION_LSHAL);
    }
    if (mPreconditionVintf != null) {
        jsonObject.put(PRECONDITION_VINTF, mPreconditionVintf);
        CLog.i("Added %s to the Json object", PRECONDITION_VINTF);
    }
    if (mPreconditionSysProp != null) {
        jsonObject.put(PRECONDITION_SYSPROP, mPreconditionSysProp);
        CLog.i("Added %s to the Json object", PRECONDITION_SYSPROP);
    }
    if (!mBinaryTestProfilingLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH);
    }
    if (mDisableFramework) {
        jsonObject.put(DISABLE_FRAMEWORK, mDisableFramework);
        CLog.i("Added %s to the Json object", DISABLE_FRAMEWORK);
    }
    if (mStopNativeServers) {
        jsonObject.put(STOP_NATIVE_SERVERS, mStopNativeServers);
        CLog.i("Added %s to the Json object", STOP_NATIVE_SERVERS);
    }
    if (mBinaryTestDisableFramework) {
        jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework);
        CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK);
    }
    if (mBinaryTestStopNativeServers) {
        jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers);
        CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS);
    }
    if (!mNativeServerProcessName.isEmpty()) {
        jsonObject.put(NATIVE_SERVER_PROCESS_NAME, new JSONArray(mNativeServerProcessName));
        CLog.i("Added %s to the Json object", NATIVE_SERVER_PROCESS_NAME);
    }
    if (!mHalHidlReplayTestTracePaths.isEmpty()) {
        jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
        CLog.i("Added %s to the Json object", HAL_HIDL_REPLAY_TEST_TRACE_PATHS);
    }
    if (mHalHidlPackageName != null) {
        jsonObject.put(HAL_HIDL_PACKAGE_NAME, mHalHidlPackageName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mSystraceProcessName != null) {
        jsonObject.put(SYSTRACE_PROCESS_NAME, mSystraceProcessName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mPassthroughMode) {
        jsonObject.put(PASSTHROUGH_MODE, mPassthroughMode);
        CLog.i("Added %s to the Json object", PASSTHROUGH_MODE);
    }
    if (mCollectTestsOnly) {
        jsonObject.put(COLLECT_TESTS_ONLY, mCollectTestsOnly);
        CLog.i("Added %s to the Json object", COLLECT_TESTS_ONLY);
    }
    if (mGtestBatchMode) {
        jsonObject.put(GTEST_BATCH_MODE, mGtestBatchMode);
        CLog.i("Added %s to the Json object", GTEST_BATCH_MODE);
    }
    if (mLtpNumberOfThreads >= 0) {
        jsonObject.put(LTP_NUMBER_OF_THREADS, mLtpNumberOfThreads);
        CLog.i("Added %s to the Json object", LTP_NUMBER_OF_THREADS);
    }
    if (mRunAsVtsSelfTest) {
        jsonObject.put(RUN_AS_VTS_SELF_TEST, mRunAsVtsSelfTest);
        CLog.i("Added %s to the Json object", RUN_AS_VTS_SELF_TEST);
    }
    if ("vts".equals(mBuildInfo.getTestTag())) {
        jsonObject.put(RUN_AS_COMPLIANCE_TEST, true);
        CLog.i("Added %s to the Json object", RUN_AS_COMPLIANCE_TEST);
    }
    if (!mMoblyTestModule.isEmpty()) {
        jsonObject.put(MOBLY_TEST_MODULE, new JSONArray(mMoblyTestModule));
        CLog.i("Added %s to the Json object", MOBLY_TEST_MODULE);
    }
    if (mActsTestModule != null) {
        jsonObject.put(ACTS_TEST_MODULE, mActsTestModule);
        CLog.i("Added %s to the Json object", ACTS_TEST_MODULE);
    }
    if (mBuildInfo.getFile(VtsPythonVirtualenvPreparer.VIRTUAL_ENV) != null) {
        jsonObject.put(VtsPythonVirtualenvPreparer.VIRTUAL_ENV, mBuildInfo.getFile(VtsPythonVirtualenvPreparer.VIRTUAL_ENV).getAbsolutePath());
    }
    if (mBuildInfo.getFile(VtsPythonVirtualenvPreparer.VIRTUAL_ENV_V3) != null) {
        jsonObject.put(VtsPythonVirtualenvPreparer.VIRTUAL_ENV_V3, mBuildInfo.getFile(VtsPythonVirtualenvPreparer.VIRTUAL_ENV_V3).getAbsolutePath());
    }
}
#end_block

#method_before
protected VtsPythonRunnerHelper createVtsPythonRunnerHelper() {
    return new VtsPythonRunnerHelper(mBuildInfo.getFile(VIRTUALENVPATH));
}
#method_after
protected VtsPythonRunnerHelper createVtsPythonRunnerHelper() {
    return new VtsPythonRunnerHelper(mBuildInfo);
}
#end_block

#method_before
public String runPythonRunner(String[] cmd, CommandResult commandResult, long timeout) {
    ProcessHelper process;
    try {
        process = startProcessHelper(cmd);
    } catch (IOException e) {
        CLog.e(e);
        commandResult.setStatus(CommandStatus.EXCEPTION);
        commandResult.setStdout("");
        commandResult.setStderr("");
        return null;
    }
    String interruptMessage;
    try {
        CommandStatus commandStatus;
        try {
            commandStatus = process.waitForProcess(timeout);
            interruptMessage = null;
        } catch (RunInterruptedException e) {
            CLog.e("Python process is interrupted.");
            commandStatus = CommandStatus.TIMED_OUT;
            interruptMessage = (e.getMessage() != null ? e.getMessage() : "");
        }
        if (process.isRunning()) {
            CLog.e("Cancel Python process and wait %d seconds.", TEST_ABORT_TIMEOUT_MSECS / 1000);
            try {
                process.closeStdin();
                // Wait for the process to clean up and ignore the CommandStatus.
                // Propagate RunInterruptedException if this is interrupted again.
                process.waitForProcess(TEST_ABORT_TIMEOUT_MSECS);
            } catch (IOException e) {
                CLog.e("Fail to cancel Python process.");
            }
        }
        commandResult.setStatus(commandStatus);
    } finally {
        process.cleanUp();
    }
    commandResult.setStdout(process.getStdout());
    commandResult.setStderr(process.getStderr());
    return interruptMessage;
}
#method_after
public String runPythonRunner(String[] cmd, CommandResult commandResult, long timeout) {
    ProcessHelper process;
    try {
        process = createProcessHelper(cmd);
    } catch (IOException e) {
        CLog.e(e);
        commandResult.setStatus(CommandStatus.EXCEPTION);
        commandResult.setStdout("");
        commandResult.setStderr("");
        return null;
    }
    String interruptMessage;
    try {
        CommandStatus commandStatus;
        try {
            commandStatus = process.waitForProcess(timeout);
            interruptMessage = null;
        } catch (RunInterruptedException e) {
            CLog.e("Python process is interrupted.");
            commandStatus = CommandStatus.TIMED_OUT;
            interruptMessage = (e.getMessage() != null ? e.getMessage() : "");
        }
        if (process.isRunning()) {
            CLog.e("Cancel Python process and wait %d seconds.", TEST_ABORT_TIMEOUT_MSECS / 1000);
            try {
                process.closeStdin();
                // Wait for the process to clean up and ignore the CommandStatus.
                // Propagate RunInterruptedException if this is interrupted again.
                process.waitForProcess(TEST_ABORT_TIMEOUT_MSECS);
            } catch (IOException e) {
                CLog.e("Fail to cancel Python process.");
            }
        }
        commandResult.setStatus(commandStatus);
    } finally {
        process.cleanUp();
    }
    commandResult.setStdout(process.getStdout());
    commandResult.setStderr(process.getStderr());
    return interruptMessage;
}
#end_block

#method_before
public static String getPythonBinDir(String virtualenvPath) {
    if (virtualenvPath == null) {
        return null;
    }
    String binDirName = isOnWindows() ? "Scripts" : "bin";
    File res = new File(virtualenvPath, binDirName);
    if (!res.exists()) {
        return null;
    }
    return res.getAbsolutePath();
}
#method_after
public static String getPythonBinDir(String virtualenvPath) {
    if (virtualenvPath == null) {
        return null;
    }
    String binDirName = EnvUtil.isOnWindows() ? "Scripts" : "bin";
    File res = new File(virtualenvPath, binDirName);
    if (!res.exists()) {
        return null;
    }
    return res.getAbsolutePath();
}
#end_block

#method_before
public static void activateVirtualenv(IRunUtil runUtil, String virtualenvPath) {
    String pythonBinDir = getPythonBinDir(virtualenvPath);
    if (pythonBinDir == null || !new File(pythonBinDir).exists()) {
        CLog.e("Invalid python virtualenv path. Using python from system path.");
    } else {
        String separater = isOnWindows() ? ";" : ":";
        runUtil.setEnvVariable(PATH, pythonBinDir + separater + System.getenv().get(PATH));
        runUtil.setEnvVariable(VIRTUAL_ENV, virtualenvPath);
        runUtil.unsetEnvVariable(PYTHONHOME);
    }
}
#method_after
public static void activateVirtualenv(IRunUtil runUtil, String virtualenvPath) {
    String pythonBinDir = getPythonBinDir(virtualenvPath);
    if (pythonBinDir == null || !new File(pythonBinDir).exists()) {
        CLog.e("Invalid python virtualenv path. Using python from system path.");
    } else {
        String separater = EnvUtil.isOnWindows() ? ";" : ":";
        runUtil.setEnvVariable(PATH, pythonBinDir + separater + System.getenv().get(PATH));
        runUtil.setEnvVariable(VtsPythonVirtualenvPreparer.VIRTUAL_ENV, virtualenvPath);
        runUtil.unsetEnvVariable(PYTHONHOME);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    IFolderBuildInfo buildInfo = EasyMock.createNiceMock(IFolderBuildInfo.class);
    EasyMock.replay(buildInfo);
    mVtsPythonRunnerHelper = new VtsPythonRunnerHelper(new File(mVirtualenvPath)) {

        @Override
        protected ProcessHelper startProcessHelper(String[] cmd) {
            return mProcessHelper;
        }
    };
}
#method_after
@Before
public void setUp() throws Exception {
    IFolderBuildInfo buildInfo = EasyMock.createNiceMock(IFolderBuildInfo.class);
    EasyMock.replay(buildInfo);
    mVtsPythonRunnerHelper = new VtsPythonRunnerHelper(new File(mVirtualenvPath)) {

        @Override
        protected ProcessHelper createProcessHelper(String[] cmd) {
            return mProcessHelper;
        }
    };
}
#end_block

#method_before
@Test
public void testActivateVirtualEnvExist() {
    IRunUtil runUtil = createMockRunUtil();
    String binDirName = VtsPythonRunnerHelper.isOnWindows() ? "Scripts" : "bin";
    File envDir = new File(mVirtualenvPath);
    File binDir = new File(mVirtualenvPath, binDirName);
    try {
        System.out.println(envDir.mkdir());
        System.out.println(binDir.mkdir());
        System.out.println(binDir.exists());
        assertEquals(binDir.getAbsolutePath(), VtsPythonRunnerHelper.getPythonBinDir(mVirtualenvPath));
        VtsPythonRunnerHelper.activateVirtualenv(runUtil, mVirtualenvPath);
        String pythonBinary = runUtil.runTimedCmd(1000, "which", "python").getStdout();
        assertEquals(pythonBinary, new File(binDir, "python").getAbsolutePath());
    } finally {
        binDir.delete();
        envDir.delete();
    }
}
#method_after
@Test
public void testActivateVirtualEnvExist() {
    IRunUtil runUtil = createMockRunUtil();
    String binDirName = EnvUtil.isOnWindows() ? "Scripts" : "bin";
    File envDir = new File(mVirtualenvPath);
    File binDir = new File(mVirtualenvPath, binDirName);
    try {
        System.out.println(envDir.mkdir());
        System.out.println(binDir.mkdir());
        System.out.println(binDir.exists());
        assertEquals(binDir.getAbsolutePath(), VtsPythonRunnerHelper.getPythonBinDir(mVirtualenvPath));
        VtsPythonRunnerHelper.activateVirtualenv(runUtil, mVirtualenvPath);
        String pythonBinary = runUtil.runTimedCmd(1000, "which", "python").getStdout();
        assertEquals(pythonBinary, new File(binDir, "python").getAbsolutePath());
    } finally {
        binDir.delete();
        envDir.delete();
    }
}
#end_block

#method_before
private boolean dirExistsAndHaveReadAccess(String path) {
    File pathDir = new File(path);
    if (!pathDir.exists() || !pathDir.isDirectory()) {
        CLog.i("Directory %s does not exist.", pathDir);
        return false;
    }
    if (!VtsPythonRunnerHelper.isOnWindows()) {
        CommandResult c = getRunUtil().runTimedCmd(BASE_TIMEOUT * 5, "ls", path);
        if (c.getStatus() != CommandStatus.SUCCESS) {
            CLog.i(String.format("Failed to read dir: %s. Result %s. stdout: %s, stderr: %s", path, c.getStatus(), c.getStdout(), c.getStderr()));
            return false;
        }
        return true;
    } else {
        try {
            String[] pathDirList = pathDir.list();
            if (pathDirList == null) {
                CLog.i("Failed to read dir: %s. Please check access permission.", pathDir);
                return false;
            }
        } catch (SecurityException e) {
            CLog.i(String.format("Failed to read dir %s with SecurityException %s", pathDir, e));
            return false;
        }
        return true;
    }
}
#method_after
private boolean dirExistsAndHaveReadAccess(String path) {
    File pathDir = new File(path);
    if (!pathDir.exists() || !pathDir.isDirectory()) {
        CLog.i("Directory %s does not exist.", pathDir);
        return false;
    }
    if (!EnvUtil.isOnWindows()) {
        CommandResult c = getRunUtil().runTimedCmd(BASE_TIMEOUT * 5, "ls", path);
        if (c.getStatus() != CommandStatus.SUCCESS) {
            CLog.i(String.format("Failed to read dir: %s. Result %s. stdout: %s, stderr: %s", path, c.getStatus(), c.getStdout(), c.getStderr()));
            return false;
        }
        return true;
    } else {
        try {
            String[] pathDirList = pathDir.list();
            if (pathDirList == null) {
                CLog.i("Failed to read dir: %s. Please check access permission.", pathDir);
                return false;
            }
        } catch (SecurityException e) {
            CLog.i(String.format("Failed to read dir %s with SecurityException %s", pathDir, e));
            return false;
        }
        return true;
    }
}
#end_block

#method_before
public String getPipPath() {
    String virtualenvPath = mVenvDir.getAbsolutePath();
    if (virtualenvPath == null) {
        return null;
    }
    return new File(VtsPythonRunnerHelper.getPythonBinDir(virtualenvPath), "pip").getAbsolutePath();
}
#method_after
public String getPipPath() {
    if (mPipPath != null) {
        return mPipPath;
    }
    String virtualenvPath = mVenvDir.getAbsolutePath();
    if (virtualenvPath == null) {
        return null;
    }
    mPipPath = new File(VtsPythonRunnerHelper.getPythonBinDir(virtualenvPath), "pip").getAbsolutePath();
    return mPipPath;
}
#end_block

#method_before
protected void addPathToBuild(IBuildInfo buildInfo) {
    String target = VIRTUALENVPATH;
    if (mPythonVersion.startsWith("3")) {
        target = VIRTUALENVPATH_V3;
    }
    if (buildInfo.getFile(target) == null) {
        buildInfo.setFile(target, new File(mVenvDir.getAbsolutePath()), buildInfo.getBuildId());
    }
}
#method_after
protected void addPathToBuild(IBuildInfo buildInfo) throws TargetSetupError {
    String target = null;
    switch(getConfiguredPythonVersionMajor()) {
        case 2:
            target = VtsPythonVirtualenvPreparer.VIRTUAL_ENV;
            break;
        case 3:
            target = VtsPythonVirtualenvPreparer.VIRTUAL_ENV_V3;
            break;
    }
    if (buildInfo.getFile(target) == null) {
        buildInfo.setFile(target, new File(mVenvDir.getAbsolutePath()), buildInfo.getBuildId());
    }
}
#end_block

#method_before
protected void createVirtualenv(IBuildInfo buildInfo) throws TargetSetupError {
    if (mVenvDir == null) {
        mVenvDir = buildInfo.getFile(VIRTUALENVPATH);
    }
    if (mVenvDir == null) {
        CLog.i("Creating virtualenv for version " + mPythonVersion);
        try {
            mVenvDir = FileUtil.createTempDir("vts-virtualenv-" + VtsFileUtil.normalizeFileName(buildInfo.getTestTag()) + "_");
            mIsDirCreator = true;
            String virtualEnvPath = mVenvDir.getAbsolutePath();
            String[] cmd = new String[] { "virtualenv", "-p", "python" + mPythonVersion, virtualEnvPath };
            CommandResult c = getRunUtil().runTimedCmd(BASE_TIMEOUT, cmd);
            if (c.getStatus() != CommandStatus.SUCCESS) {
                CLog.e(String.format("Failed to create virtualenv with : %s.", virtualEnvPath));
                throw new TargetSetupError("Failed to create virtualenv", mDescriptor);
            }
        } catch (IOException | RuntimeException e) {
            CLog.e("Failed to create temp directory for virtualenv");
            throw new TargetSetupError("Error creating virtualenv", e, mDescriptor);
        }
    }
    CLog.i("Python virtualenv path is: " + mVenvDir);
}
#method_after
protected void createVirtualenv(IBuildInfo buildInfo) throws TargetSetupError {
    if (mVenvDir == null) {
        switch(getConfiguredPythonVersionMajor()) {
            case 2:
                mVenvDir = buildInfo.getFile(VtsPythonVirtualenvPreparer.VIRTUAL_ENV);
                break;
            case 3:
                mVenvDir = buildInfo.getFile(VtsPythonVirtualenvPreparer.VIRTUAL_ENV_V3);
                break;
        }
    }
    if (mVenvDir == null) {
        CLog.i("Creating virtualenv for version " + mPythonVersion);
        try {
            mVenvDir = FileUtil.createTempDir("vts-virtualenv-" + mPythonVersion + "-" + VtsFileUtil.normalizeFileName(buildInfo.getTestTag()) + "_");
            mIsDirCreator = true;
            String virtualEnvPath = mVenvDir.getAbsolutePath();
            String[] cmd = new String[] { "virtualenv", "-p", "python" + mPythonVersion, virtualEnvPath };
            CommandResult c = getRunUtil().runTimedCmd(BASE_TIMEOUT, cmd);
            if (c.getStatus() != CommandStatus.SUCCESS) {
                CLog.e(String.format("Failed to create virtualenv with : %s.", virtualEnvPath));
                throw new TargetSetupError("Failed to create virtualenv", mDescriptor);
            }
        } catch (IOException | RuntimeException e) {
            CLog.e("Failed to create temp directory for virtualenv");
            throw new TargetSetupError("Error creating virtualenv", e, mDescriptor);
        }
    }
    CLog.i("Python virtualenv path is: " + mVenvDir);
}
#end_block

#method_before
// Android-removed: legacyMergeSort(Object[]) (unused on Android)
public static void sort(Object[] a, int fromIndex, int toIndex) {
    rangeCheck(a.length, fromIndex, toIndex);
    // Android-removed: LegacyMergeSort support
    // if (LegacyMergeSort.userRequested)
    // legacyMergeSort(a, fromIndex, toIndex);
    // else
    ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);
}
#method_after
// Android-removed: legacyMergeSort() (unused on Android)
public static void sort(Object[] a, int fromIndex, int toIndex) {
    rangeCheck(a.length, fromIndex, toIndex);
    // Android-removed: LegacyMergeSort support
    // if (LegacyMergeSort.userRequested)
    // legacyMergeSort(a, fromIndex, toIndex);
    // else
    ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);
}
#end_block

#method_before
// Android-removed: legacyMergeSort(T[], Comparator) (unused on Android)
public static <T> void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c) {
    if (c == null) {
        sort(a, fromIndex, toIndex);
    } else {
        rangeCheck(a.length, fromIndex, toIndex);
        // Android-removed: LegacyMergeSort support
        // if (LegacyMergeSort.userRequested)
        // legacyMergeSort(a, fromIndex, toIndex, c);
        // else
        TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);
    }
}
#method_after
// Android-removed: legacyMergeSort() (unused on Android)
public static <T> void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c) {
    if (c == null) {
        sort(a, fromIndex, toIndex);
    } else {
        rangeCheck(a.length, fromIndex, toIndex);
        // Android-removed: LegacyMergeSort support
        // if (LegacyMergeSort.userRequested)
        // legacyMergeSort(a, fromIndex, toIndex, c);
        // else
        TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);
    }
}
#end_block

#method_before
// Android-removed: legacyMergeSort(T[], int, int, Comparator) (unused on Android)
// Android-removed: mergeSort(Object[], Object[], int, int, int, Comparator) (unused on Android)
// Parallel prefix
public static <T> void parallelPrefix(T[] array, BinaryOperator<T> op) {
    Objects.requireNonNull(op);
    if (array.length > 0)
        new ArrayPrefixHelpers.CumulateTask<>(null, op, array, 0, array.length).invoke();
}
#method_after
// Android-removed: legacyMergeSort() (unused on Android)
// Android-removed: mergeSort() (unused on Android)
// Parallel prefix
public static <T> void parallelPrefix(T[] array, BinaryOperator<T> op) {
    Objects.requireNonNull(op);
    if (array.length > 0)
        new ArrayPrefixHelpers.CumulateTask<>(null, op, array, 0, array.length).invoke();
}
#end_block

#method_before
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, infraLogPath_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt64(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeInt64(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeInt32(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeInt32(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(43, modulesDone_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeInt32(44, modulesTotal_);
    }
    unknownFields.writeTo(output);
}
#method_after
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeInt64(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeInt64(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeInt32(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeInt32(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(43, modulesDone_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeInt32(44, modulesTotal_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 51, infraLogPath_);
    }
    unknownFields.writeTo(output);
}
#end_block

#method_before
public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, infraLogPath_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(43, modulesDone_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(44, modulesTotal_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
}
#method_after
public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, accessToken_);
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, resultPath_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream.computeBoolSize(3, bootSuccess_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(11, branch_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, target_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(13, buildId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(21, suitePlan_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(22, suiteVersion_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, suiteBuildNumber_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(24, startTime_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream.computeInt64Size(25, endTime_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(26, hostName_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(27, suiteName_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(31, buildSystemFingerprint_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(32, buildVendorFingerprint_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(41, passedTestCaseCount_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(42, failedTestCaseCount_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(43, modulesDone_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream.computeInt32Size(44, modulesTotal_);
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(51, infraLogPath_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
}
#end_block

#method_before
@Test
public void testImmediateEncoding() throws IllegalInstructionException {
    final int LI_OPCODE = 13 << 3;
    ApfGenerator gen;
    // 0-byte immediate: li R0, 0
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0);
    assertProgramEquals(new byte[] { LI_OPCODE | (0 << 1) }, gen.generate());
    // 1-byte immediate: li R0, 42
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 42);
    assertProgramEquals(new byte[] { LI_OPCODE | (1 << 1), 42 }, gen.generate());
    // 2-byte immediate: li R0, 0x1234
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0x1234);
    assertProgramEquals(new byte[] { LI_OPCODE | (2 << 1), 0x12, 0x34 }, gen.generate());
    // 4-byte immediate: li R0, 0x12345678
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0x12345678);
    assertProgramEquals(new byte[] { LI_OPCODE | (3 << 1), 0x12, 0x34, 0x56, 0x78 }, gen.generate());
}
#method_after
@Test
public void testImmediateEncoding() throws IllegalInstructionException {
    final int LI_OPCODE = 13 << 3;
    ApfGenerator gen;
    // 0-byte immediate: li R0, 0
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0);
    assertProgramEquals(new byte[] { LI_OPCODE | (0 << 1) }, gen.generate());
    // 1-byte immediate: li R0, 42
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 42);
    assertProgramEquals(new byte[] { LI_OPCODE | (1 << 1), 42 }, gen.generate());
    // 2-byte immediate: li R1, 0x1234
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R1, 0x1234);
    assertProgramEquals(new byte[] { LI_OPCODE | (2 << 1) | 1, 0x12, 0x34 }, gen.generate());
    // 4-byte immediate: li R0, 0x12345678
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, 0x12345678);
    assertProgramEquals(new byte[] { LI_OPCODE | (3 << 1), 0x12, 0x34, 0x56, 0x78 }, gen.generate());
}
#end_block

#method_before
@Test
public void testNegativeImmediateEncoding() throws IllegalInstructionException {
    final int LI_OPCODE = 13 << 3;
    ApfGenerator gen;
    // 1-byte negative immediate: li R0, -42
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -42);
    assertProgramEquals(new byte[] { LI_OPCODE | (1 << 1), -42 }, gen.generate());
    // 2-byte negative immediate: li R0, -0x1234
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -0x1122);
    assertProgramEquals(new byte[] { LI_OPCODE | (2 << 1), (byte) 0xEE, (byte) 0xDE }, gen.generate());
    // 4-byte negative immediate: li R0, -0x11223344
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -0x11223344);
    assertProgramEquals(new byte[] { LI_OPCODE | (3 << 1), (byte) 0xEE, (byte) 0xDD, (byte) 0xCC, (byte) 0xBC }, gen.generate());
}
#method_after
@Test
public void testNegativeImmediateEncoding() throws IllegalInstructionException {
    final int LI_OPCODE = 13 << 3;
    ApfGenerator gen;
    // 1-byte negative immediate: li R0, -42
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -42);
    assertProgramEquals(new byte[] { LI_OPCODE | (1 << 1), -42 }, gen.generate());
    // 2-byte negative immediate: li R1, -0x1234
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R1, -0x1122);
    assertProgramEquals(new byte[] { LI_OPCODE | (2 << 1) | 1, (byte) 0xEE, (byte) 0xDE }, gen.generate());
    // 4-byte negative immediate: li R0, -0x11223344
    gen = new ApfGenerator(3);
    gen.addLoadImmediate(Register.R0, -0x11223344);
    assertProgramEquals(new byte[] { LI_OPCODE | (3 << 1), (byte) 0xEE, (byte) 0xDD, (byte) 0xCC, (byte) 0xBC }, gen.generate());
}
#end_block

#method_before
@Test
@TestInfo(id = "d7f5673a-a3d0-4f50-856a-dfa10ce5c21c")
public void loginGoogleChrome() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (api < 24 || !testFramework.isGoogleApiImage()) {
        return;
    }
    UiObject inputPasswordField = device.findObject(new UiSelector().resourceId("password"));
    final String email = "pstester1980@gmail.com";
    final String password = "pst4lif3";
    AppLauncher.launch(instrumentation, "Chrome");
    new AddGoogleAccountWatcher(device).checkForCondition();
    final UiObject signInButton = device.findObject(new UiSelector().text("SIGN IN"));
    boolean hasSignInButton = new Wait(5L).until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            return signInButton.exists();
        }
    });
    if (!hasSignInButton) {
        return;
    }
    signInButton.clickAndWaitForNewWindow();
    boolean needsEmail = new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            if (api == 24) {
                return device.findObject(new UiSelector().description("Email or phone")).exists();
            } else {
                return device.findObject(new UiSelector().text("Email or phone")).exists();
            }
        }
    });
    if (!needsEmail) {
        boolean needsPassword = new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws UiObjectNotFoundException {
                if (api == 24) {
                    return device.findObject(new UiSelector().description("Sign in " + email)).exists();
                } else {
                    return device.findObject(new UiSelector().text("Sign in " + email)).exists();
                }
            }
        });
        if (!needsPassword) {
            device.pressHome();
            return;
        }
        inputPasswordField.clearTextField();
        inputPasswordField.setText(password);
        new GoogleChromeConfirmationWatcher(device).checkForCondition();
        if (api == 24) {
            inputPasswordField = device.findObject(new UiSelector().text("password"));
        } else {
            inputPasswordField = device.findObject(new UiSelector().className("android.widget.EditText"));
        }
        inputPasswordField.clearTextField();
        inputPasswordField.setText(password);
    } else {
        UiObject inputEmailField;
        if (api == 24) {
            inputEmailField = device.findObject(new UiSelector().description("Email or phone"));
        } else {
            inputEmailField = device.findObject(new UiSelector().text("Email or phone"));
        }
        inputEmailField.clearTextField();
        inputEmailField.setText(email);
        new GoogleChromeConfirmationWatcher(device).checkForCondition();
        if (api == 24) {
            inputPasswordField = device.findObject(new UiSelector().text("password"));
        } else {
            inputPasswordField = device.findObject(new UiSelector().className("android.widget.EditText"));
        }
        inputPasswordField.clearTextField();
        inputPasswordField.setText(password);
    }
    new GoogleChromeConfirmationWatcher(device).checkForCondition();
    device.pressHome();
    AppLauncher.launch(instrumentation, "Chrome");
    final UiObject gotItButton = device.findObject(new UiSelector().text("OK, GOT IT"));
    final UiObject undoButton = device.findObject(new UiSelector().text("UNDO"));
    assertTrue("Google log in was unsuccessful", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            return gotItButton.exists() && undoButton.exists();
        }
    }));
    undoButton.clickAndWaitForNewWindow();
    final UiObject noThanksButton = device.findObject(new UiSelector().text("NO THANKS"));
    assertTrue("Google log out was unsuccessful", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            return noThanksButton.exists();
        }
    }));
    noThanksButton.clickAndWaitForNewWindow();
}
#method_after
@Test
@TestInfo(id = "d7f5673a-a3d0-4f50-856a-dfa10ce5c21c")
public void loginGoogleChrome() throws Exception {
    Instrumentation instrumentation = testFramework.getInstrumentation();
    final UiDevice device = UiDevice.getInstance(instrumentation);
    if (api < 24 || !testFramework.isGoogleApiImage()) {
        return;
    }
    UiObject inputPasswordField = device.findObject(new UiSelector().resourceId("password"));
    final String email = "pstester1980@gmail.com";
    final String password = "pst4lif3";
    AppLauncher.launch(instrumentation, "Chrome");
    new AddGoogleAccountWatcher(device).checkForCondition();
    final UiObject signInButton = device.findObject(new UiSelector().text("SIGN IN"));
    boolean hasSignInButton = new Wait(5L).until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            return signInButton.exists();
        }
    });
    if (!hasSignInButton) {
        return;
    }
    signInButton.clickAndWaitForNewWindow();
    boolean needsEmail = new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            if (api == 24) {
                return device.findObject(new UiSelector().description("Email or phone")).exists();
            } else {
                return device.findObject(new UiSelector().text("Email or phone")).exists();
            }
        }
    });
    if (!needsEmail) {
        boolean needsPassword = new Wait().until(new Wait.ExpectedCondition() {

            @Override
            public boolean isTrue() throws UiObjectNotFoundException {
                if (api == 24) {
                    return device.findObject(new UiSelector().description("Sign in " + email)).exists();
                } else {
                    return device.findObject(new UiSelector().text("Sign in " + email)).exists();
                }
            }
        });
        if (!needsPassword) {
            device.pressHome();
            return;
        }
        new GoogleChromeConfirmationWatcher(device).checkForCondition();
        if (api == 24) {
            inputPasswordField = device.findObject(new UiSelector().text("password"));
        } else {
            inputPasswordField = device.findObject(new UiSelector().className("android.widget.EditText"));
        }
        inputPasswordField.clearTextField();
        inputPasswordField.setText(password);
    } else {
        UiObject inputEmailField;
        if (api == 24) {
            inputEmailField = device.findObject(new UiSelector().description("Email or phone"));
        } else {
            inputEmailField = device.findObject(new UiSelector().text("Email or phone"));
        }
        inputEmailField.clearTextField();
        inputEmailField.setText(email);
        new GoogleChromeConfirmationWatcher(device).checkForCondition();
        if (api == 24) {
            inputPasswordField = device.findObject(new UiSelector().text("password"));
        } else {
            inputPasswordField = device.findObject(new UiSelector().className("android.widget.EditText"));
        }
        inputPasswordField.clearTextField();
        inputPasswordField.setText(password);
    }
    new GoogleChromeConfirmationWatcher(device).checkForCondition();
    device.pressHome();
    AppLauncher.launch(instrumentation, "Chrome");
    final UiObject gotItButton = device.findObject(new UiSelector().text("OK, GOT IT"));
    final UiObject undoButton = device.findObject(new UiSelector().text("UNDO"));
    assertTrue("Google log in was unsuccessful", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            return gotItButton.exists() && undoButton.exists();
        }
    }));
    undoButton.clickAndWaitForNewWindow();
    final UiObject noThanksButton = device.findObject(new UiSelector().text("NO THANKS"));
    assertTrue("Google log out was unsuccessful", new Wait().until(new Wait.ExpectedCondition() {

        @Override
        public boolean isTrue() throws UiObjectNotFoundException {
            return noThanksButton.exists();
        }
    }));
    noThanksButton.clickAndWaitForNewWindow();
}
#end_block

#method_before
@MediumTest
public void testWindowDockAndUndock_dividerWindowAppearsAndDisappears() throws Exception {
    ActivityManager mactivityManager = (ActivityManager) getInstrumentation().getContext().getSystemService(Context.ACTIVITY_SERVICE);
    if (getInstrumentation().getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
        // Android TV doesn't support the divider window
        return;
    }
    // Get com.android.internal.R.bool.config_supportsSplitScreenMultiWindow
    try {
        if (!getInstrumentation().getContext().getResources().getBoolean(Resources.getSystem().getIdentifier("config_supportsSplitScreenMultiWindow", "bool", "android"))) {
            // Check if split screen multi window is not supported.
            return;
        }
    } catch (Resources.NotFoundException e) {
    // Do nothing, assume split screen multi window is supported.
    }
    // getting lowRamDevice status
    if (!getInstrumentation().getContext().getResources().getBoolean(Resources.getSystem().getIdentifier("config_supportsMultiWindow", "bool", "android")) || mactivityManager.isLowRamDevice()) {
        // Check if multiWindow is supported.
        return;
    }
    setAccessInteractiveWindowsFlag();
    final UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
    assertFalse(isDividerWindowPresent(uiAutomation));
    Runnable toggleSplitScreenRunnable = new Runnable() {

        @Override
        public void run() {
            assertTrue(uiAutomation.performGlobalAction(AccessibilityService.GLOBAL_ACTION_TOGGLE_SPLIT_SCREEN));
        }
    };
    UiAutomation.AccessibilityEventFilter windowsChangedFilter = new UiAutomation.AccessibilityEventFilter() {

        @Override
        public boolean accept(AccessibilityEvent event) {
            return (event.getEventType() == AccessibilityEvent.TYPE_WINDOWS_CHANGED);
        }
    };
    uiAutomation.executeAndWaitForEvent(toggleSplitScreenRunnable, windowsChangedFilter, TIMEOUT_ASYNC_PROCESSING);
    waitForIdle();
    assertTrue(isDividerWindowPresent(uiAutomation));
    uiAutomation.executeAndWaitForEvent(toggleSplitScreenRunnable, windowsChangedFilter, TIMEOUT_ASYNC_PROCESSING);
    waitForIdle();
    assertFalse(isDividerWindowPresent(uiAutomation));
}
#method_after
@MediumTest
public void testWindowDockAndUndock_dividerWindowAppearsAndDisappears() throws Exception {
    ActivityManager activityManager = (ActivityManager) getInstrumentation().getContext().getSystemService(Context.ACTIVITY_SERVICE);
    if (getInstrumentation().getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
        // Android TV doesn't support the divider window
        return;
    }
    // Get com.android.internal.R.bool.config_supportsSplitScreenMultiWindow
    try {
        if (!getInstrumentation().getContext().getResources().getBoolean(Resources.getSystem().getIdentifier("config_supportsSplitScreenMultiWindow", "bool", "android"))) {
            // Check if split screen multi window is not supported.
            return;
        }
    } catch (Resources.NotFoundException e) {
    // Do nothing, assume split screen multi window is supported.
    }
    // and isLowRam.
    if (!getInstrumentation().getContext().getResources().getBoolean(Resources.getSystem().getIdentifier("config_supportsMultiWindow", "bool", "android")) || activityManager.isLowRamDevice()) {
        // Check if multiWindow is supported.
        return;
    }
    setAccessInteractiveWindowsFlag();
    final UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
    assertFalse(isDividerWindowPresent(uiAutomation));
    Runnable toggleSplitScreenRunnable = new Runnable() {

        @Override
        public void run() {
            assertTrue(uiAutomation.performGlobalAction(AccessibilityService.GLOBAL_ACTION_TOGGLE_SPLIT_SCREEN));
        }
    };
    UiAutomation.AccessibilityEventFilter windowsChangedFilter = new UiAutomation.AccessibilityEventFilter() {

        @Override
        public boolean accept(AccessibilityEvent event) {
            return (event.getEventType() == AccessibilityEvent.TYPE_WINDOWS_CHANGED);
        }
    };
    uiAutomation.executeAndWaitForEvent(toggleSplitScreenRunnable, windowsChangedFilter, TIMEOUT_ASYNC_PROCESSING);
    waitForIdle();
    assertTrue(isDividerWindowPresent(uiAutomation));
    uiAutomation.executeAndWaitForEvent(toggleSplitScreenRunnable, windowsChangedFilter, TIMEOUT_ASYNC_PROCESSING);
    waitForIdle();
    assertFalse(isDividerWindowPresent(uiAutomation));
}
#end_block

#method_before
@Override
public List<Page> getBreadcrumbLinks(HttpServletRequest request) {
    List<Page> links = new ArrayList<>();
    String planName = request.getParameter("plan");
    links.add(new Page(PageType.PLAN_RELEASE, planName, "?plan=" + planName));
    return links;
}
#method_after
@Override
public List<Page> getBreadcrumbLinks(HttpServletRequest request) {
    String testType = request.getParameter("type") == null ? "plan" : request.getParameter("type");
    List<Page> links = new ArrayList<>();
    String planName = request.getParameter("plan");
    if (testType.equals("plan")) {
        links.add(new Page(PageType.RELEASE, "TEST PLANS", "?type=" + testType, true));
        links.add(new Page(PageType.PLAN_RELEASE, planName, "?plan=" + planName));
    } else {
        links.add(new Page(PageType.RELEASE, "SUITE TEST PLANS", "?type=" + testType, true));
        links.add(new Page(PageType.PLAN_RELEASE, planName, "?plan=" + planName + "&type=" + testType));
    }
    return links;
}
#end_block

#method_before
private RequestDispatcher getTestSuiteDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String PLAN_RELEASE_JSP = "WEB-INF/jsp/show_suite_release.jsp";
    String testPlan = request.getParameter("plan");
    String groupType = request.getParameter("groupType") == null ? "TOT" : request.getParameter("groupType");
    int page = request.getParameter("page") == null ? 1 : Integer.valueOf(request.getParameter("page"));
    String nextPageToken = request.getParameter("nextPageToken") == null ? "" : request.getParameter("nextPageToken");
    com.googlecode.objectify.cmd.Query<TestSuiteResultEntity> testSuiteResultEntityQuery = ofy().load().type(TestSuiteResultEntity.class).filter("suitePlan", testPlan).filter("groupType", groupType).orderKey(true);
    Pagination<TestSuiteResultEntity> testSuiteResultEntityPagination = new Pagination(testSuiteResultEntityQuery, page, Pagination.DEFAULT_PAGE_SIZE, nextPageToken, pageCountTokenSet);
    String nextPageTokenPagination = testSuiteResultEntityPagination.getNextPageCountToken();
    if (nextPageTokenPagination == "") {
    } else {
        this.pageCountTokenSet.add(nextPageTokenPagination);
    }
    logger.log(Level.INFO, "pageCountTokenSet => " + pageCountTokenSet);
    logger.log(Level.INFO, "list => " + testSuiteResultEntityPagination.getList());
    logger.log(Level.INFO, "next page count token => " + testSuiteResultEntityPagination.getNextPageCountToken());
    logger.log(Level.INFO, "page min range => " + testSuiteResultEntityPagination.getMinPageRange());
    logger.log(Level.INFO, "page max range => " + testSuiteResultEntityPagination.getMaxPageRange());
    logger.log(Level.INFO, "page size => " + testSuiteResultEntityPagination.getPageSize());
    logger.log(Level.INFO, "total count => " + testSuiteResultEntityPagination.getTotalCount());
    request.setAttribute("page", page);
    request.setAttribute("testType", "suite");
    request.setAttribute("groupType", groupType);
    request.setAttribute("plan", testPlan);
    request.setAttribute("testSuiteResultEntityPagination", testSuiteResultEntityPagination);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    return dispatcher;
}
#method_after
private RequestDispatcher getTestSuiteDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String PLAN_RELEASE_JSP = "WEB-INF/jsp/show_suite_release.jsp";
    String testPlan = request.getParameter("plan");
    String groupType = request.getParameter("groupType") == null ? "OTA" : request.getParameter("groupType");
    int page = request.getParameter("page") == null ? 1 : Integer.valueOf(request.getParameter("page"));
    String nextPageToken = request.getParameter("nextPageToken") == null ? "" : request.getParameter("nextPageToken");
    com.googlecode.objectify.cmd.Query<TestSuiteResultEntity> testSuiteResultEntityQuery = ofy().load().type(TestSuiteResultEntity.class).filter("suitePlan", testPlan).filter("groupType", groupType).orderKey(true);
    Pagination<TestSuiteResultEntity> testSuiteResultEntityPagination = new Pagination(testSuiteResultEntityQuery, page, Pagination.DEFAULT_PAGE_SIZE, nextPageToken, pageCountTokenSet);
    String nextPageTokenPagination = testSuiteResultEntityPagination.getNextPageCountToken();
    if (!nextPageTokenPagination.trim().isEmpty()) {
        this.pageCountTokenSet.add(nextPageTokenPagination);
    }
    logger.log(Level.INFO, "pageCountTokenSet => " + pageCountTokenSet);
    logger.log(Level.INFO, "list => " + testSuiteResultEntityPagination.getList());
    logger.log(Level.INFO, "next page count token => " + testSuiteResultEntityPagination.getNextPageCountToken());
    logger.log(Level.INFO, "page min range => " + testSuiteResultEntityPagination.getMinPageRange());
    logger.log(Level.INFO, "page max range => " + testSuiteResultEntityPagination.getMaxPageRange());
    logger.log(Level.INFO, "page size => " + testSuiteResultEntityPagination.getPageSize());
    logger.log(Level.INFO, "total count => " + testSuiteResultEntityPagination.getTotalCount());
    request.setAttribute("page", page);
    request.setAttribute("testType", "suite");
    request.setAttribute("groupType", groupType);
    request.setAttribute("plan", testPlan);
    request.setAttribute("testSuiteResultEntityPagination", testSuiteResultEntityPagination);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    return dispatcher;
}
#end_block

#method_before
private String getNormalizedVersion(String fingerprint) {
    Map<String, Pattern> partternMap = new HashMap<String, Pattern>() {

        {
            put("9", Pattern.compile("(:9(\\.\\d\\.\\d|\\.\\d|)|:P[A-Z]/)", Pattern.CASE_INSENSITIVE));
            put("8.1", Pattern.compile("(:8\\.1\\.\\d\\/|:O[A-Z]-MR1/)", Pattern.CASE_INSENSITIVE));
            put("8", Pattern.compile("(:8\\.0\\.\\d\\/|:O[A-Z]/)", Pattern.CASE_INSENSITIVE));
        }
    };
    for (Map.Entry<String, Pattern> entry : partternMap.entrySet()) {
        Matcher systemMatcher = entry.getValue().matcher(fingerprint);
        if (systemMatcher.find()) {
            return entry.getKey();
        }
    }
    return "unknown-version-" + Instant.now().toEpochMilli();
}
#method_after
private String getNormalizedVersion(String fingerprint) {
    Map<String, Pattern> partternMap = new HashMap<String, Pattern>() {

        {
            put("9", Pattern.compile("(:9(\\.\\d\\.\\d|\\.\\d|)|:P\\w*/)", Pattern.CASE_INSENSITIVE));
            put("8.1", Pattern.compile("(:8\\.1\\.\\d\\/|:O\\w+-MR1/)", Pattern.CASE_INSENSITIVE));
            put("8", Pattern.compile("(:8\\.0\\.\\d\\/|:O\\w*/)", Pattern.CASE_INSENSITIVE));
        }
    };
    for (Map.Entry<String, Pattern> entry : partternMap.entrySet()) {
        Matcher systemMatcher = entry.getValue().matcher(fingerprint);
        if (systemMatcher.find()) {
            return entry.getKey();
        }
    }
    return "unknown-version-" + Instant.now().toEpochMilli();
}
#end_block

#method_before
public GROUP_TYPE getGroupType() {
    if (this.getNormalizedVersion(this.buildSystemFingerprint) == this.getNormalizedVersion(this.buildVendorFingerprint)) {
        return GROUP_TYPE.OTA;
    } else if (this.buildVendorFingerprint.endsWith("release-keys")) {
        return GROUP_TYPE.SIGNED;
    } else {
        return GROUP_TYPE.TOT;
    }
}
#method_after
public GROUP_TYPE getGroupType() {
    if (this.getNormalizedVersion(this.buildSystemFingerprint) != this.getNormalizedVersion(this.buildVendorFingerprint)) {
        return GROUP_TYPE.OTA;
    } else if (this.buildVendorFingerprint.endsWith("release-keys")) {
        return GROUP_TYPE.SIGNED;
    } else {
        return GROUP_TYPE.TOT;
    }
}
#end_block

#method_before
protected void playInCallNotification() {
    new Thread() {

        @Override
        public void run() {
            final long identity = Binder.clearCallingIdentity();
            try {
                final IRingtonePlayer player = mAudioManager.getRingtonePlayer();
                if (player != null) {
                    if (mLasteToken != null) {
                        player.stop(mLasteToken);
                    }
                    mLasteToken = new Binder();
                    player.play(mLasteToken, mInCallNotificationUri, mInCallNotificationAudioAttributes, mInCallNotificationVolume, false);
                }
            } catch (RemoteException e) {
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }.start();
}
#method_after
protected void playInCallNotification() {
    new Thread() {

        @Override
        public void run() {
            final long identity = Binder.clearCallingIdentity();
            try {
                final IRingtonePlayer player = mAudioManager.getRingtonePlayer();
                if (player != null) {
                    if (mCallNotificationToken != null) {
                        player.stop(mCallNotificationToken);
                    }
                    mCallNotificationToken = new Binder();
                    player.play(mCallNotificationToken, mInCallNotificationUri, mInCallNotificationAudioAttributes, mInCallNotificationVolume, false);
                }
            } catch (RemoteException e) {
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }.start();
}
#end_block

#method_before
@Override
public void queryVersion(final Callback1<Integer> callback) {
    RunMessageParams message = new RunMessageParams();
    message.input = new RunInput();
    message.input.setQueryVersion(new QueryVersion());
    InterfaceControlMessagesHelper.sendRunMessage(getCore(), mMessageReceiver, message, new Callback1<RunResponseMessageParams>() {

        @Override
        public void call(RunResponseMessageParams response) {
            if (response.output != null && response.output.which() == RunOutput.Tag.QueryVersionResult) {
                mVersion = response.output.getQueryVersionResult().version;
            }
            callback.call(mVersion);
        }
    });
}
#method_after
@Override
public void queryVersion(final Callback1<Integer> callback) {
    RunMessageParams message = new RunMessageParams();
    message.input = new RunInput();
    message.input.setQueryVersion(new QueryVersion());
    InterfaceControlMessagesHelper.sendRunMessage(getCore(), mMessageReceiver, message, new Callback1<RunResponseMessageParams>() {

        @Override
        public void call(RunResponseMessageParams response) {
            if (response.output != null && response.output.which() == RunOutput.Tag.QueryVersionResult) {
                mVersion = response.output.getQueryVersionResult().version;
            }
            try {
                callback.call(mVersion);
            } catch (RuntimeException e) {
                // TODO(lhchavez): Remove this hack. See b/28986534 for details.
                android.util.Log.wtf("org.chromium.mojo.bindings.Interface", "Uncaught runtime exception", e);
            }
        }
    });
}
#end_block

#method_before
private RequestDispatcher getTestSuiteDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String PLAN_RELEASE_JSP = "WEB-INF/jsp/show_suite_release.jsp";
    String testPlan = request.getParameter("plan");
    int page = request.getParameter("page") == null ? 1 : Integer.valueOf(request.getParameter("page"));
    String nextPageToken = request.getParameter("nextPageToken") == null ? "" : request.getParameter("nextPageToken");
    com.googlecode.objectify.cmd.Query<TestSuiteResultEntity> testSuiteResultEntityQuery = ofy().load().type(TestSuiteResultEntity.class).filter("suitePlan", testPlan).limit(105);
    Pagination<TestSuiteResultEntity> testSuiteResultEntityPagination = new Pagination(testSuiteResultEntityQuery, page, Pagination.DEFAULT_PAGE_SIZE, nextPageToken);
    logger.log(Level.INFO, "list => " + testSuiteResultEntityPagination.getList());
    logger.log(Level.INFO, "next page count token => " + testSuiteResultEntityPagination.getNextPageCountToken());
    logger.log(Level.INFO, "page min range => " + testSuiteResultEntityPagination.getMinPageRange());
    logger.log(Level.INFO, "page max range => " + testSuiteResultEntityPagination.getMaxPageRange());
    logger.log(Level.INFO, "page size => " + testSuiteResultEntityPagination.getPageSize());
    logger.log(Level.INFO, "total count => " + testSuiteResultEntityPagination.getTotalCount());
    request.setAttribute("plan", request.getParameter("plan"));
    request.setAttribute("testSuiteResultEntityPagination", testSuiteResultEntityPagination);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    return dispatcher;
}
#method_after
private RequestDispatcher getTestSuiteDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String PLAN_RELEASE_JSP = "WEB-INF/jsp/show_suite_release.jsp";
    String testPlan = request.getParameter("plan");
    int page = request.getParameter("page") == null ? 1 : Integer.valueOf(request.getParameter("page"));
    String nextPageToken = request.getParameter("nextPageToken") == null ? "" : request.getParameter("nextPageToken");
    com.googlecode.objectify.cmd.Query<TestSuiteResultEntity> testSuiteResultEntityQuery = ofy().load().type(TestSuiteResultEntity.class).filter("suitePlan", testPlan).limit(105);
    Pagination<TestSuiteResultEntity> testSuiteResultEntityPagination = new Pagination(testSuiteResultEntityQuery, page, Pagination.DEFAULT_PAGE_SIZE, nextPageToken, pageCountTokenSet);
    String nextPageTokenPagination = testSuiteResultEntityPagination.getNextPageCountToken();
    if (nextPageTokenPagination == "") {
    } else {
        this.pageCountTokenSet.add(nextPageTokenPagination);
    }
    logger.log(Level.INFO, "pageCountTokenSet => " + pageCountTokenSet);
    logger.log(Level.INFO, "list => " + testSuiteResultEntityPagination.getList());
    logger.log(Level.INFO, "next page count token => " + testSuiteResultEntityPagination.getNextPageCountToken());
    logger.log(Level.INFO, "page min range => " + testSuiteResultEntityPagination.getMinPageRange());
    logger.log(Level.INFO, "page max range => " + testSuiteResultEntityPagination.getMaxPageRange());
    logger.log(Level.INFO, "page size => " + testSuiteResultEntityPagination.getPageSize());
    logger.log(Level.INFO, "total count => " + testSuiteResultEntityPagination.getTotalCount());
    request.setAttribute("page", page);
    request.setAttribute("testType", "suite");
    request.setAttribute("plan", testPlan);
    request.setAttribute("testSuiteResultEntityPagination", testSuiteResultEntityPagination);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    return dispatcher;
}
#end_block

#method_before
private Map<String, Object> generateSuiteTestData(HttpServletRequest request, HttpServletResponse response) {
    Map<String, Object> resultMap = new HashMap<>();
    String fileSeparator = FileSystems.getDefault().getSeparator();
    Random rand = new Random();
    List<String> branchList = Arrays.asList("master", "oc_mr", "oc");
    List<String> targetList = Arrays.asList("sailfish-userdebug", "marlin-userdebug", "taimen-userdebug", "walleye-userdebug", "aosp_arm_a-userdebug");
    branchList.forEach(branch -> targetList.forEach(target -> IntStream.range(0, 10).forEach(idx -> {
        String year = String.format("%04d", 2010 + idx);
        String month = String.format("%02d", rand.nextInt(12));
        String day = String.format("%02d", rand.nextInt(30));
        String fileName = String.format("%02d%02d%02d.bin", rand.nextInt(23) + 1, rand.nextInt(59) + 1, rand.nextInt(59) + 1);
        List<String> pathList = Arrays.asList(GCS_SUITE_TEST_FOLDER_NAME == "" ? "suite_result" : GCS_SUITE_TEST_FOLDER_NAME, year, month, day, fileName);
        Path pathInfo = Paths.get(String.join(fileSeparator, pathList));
        TestSuiteFileEntity newTestSuiteFileEntity = new TestSuiteFileEntity(pathInfo.toString());
        newTestSuiteFileEntity.save();
        com.googlecode.objectify.Key<TestSuiteFileEntity> testSuiteFileParent = com.googlecode.objectify.Key.create(TestSuiteFileEntity.class, newTestSuiteFileEntity.getFilePath());
        TestSuiteResultEntity testSuiteResultEntity = new TestSuiteResultEntity(testSuiteFileParent, Instant.now().minus(rand.nextInt(100), ChronoUnit.DAYS).getEpochSecond(), Instant.now().minus(rand.nextInt(100), ChronoUnit.DAYS).getEpochSecond(), pathInfo.toString(), "GFC-" + idx, "Suite Test Plan", "Suite Version " + idx, "Suite Test Name", "Suite Build Number " + idx, rand.nextInt(), rand.nextInt(), branch, target, Long.toString(Math.abs(rand.nextLong())), "Build System Fingerprint " + idx, "Build Vendor Fingerprint " + idx, rand.nextInt(), rand.nextInt());
        testSuiteResultEntity.save();
    })));
    resultMap.put("result", "successfully generated!");
    return resultMap;
}
#method_after
private Map<String, Object> generateSuiteTestData(HttpServletRequest request, HttpServletResponse response) {
    Map<String, Object> resultMap = new HashMap<>();
    String fileSeparator = FileSystems.getDefault().getSeparator();
    Random rand = new Random();
    List<String> branchList = Arrays.asList("master", "oc_mr", "oc");
    List<String> targetList = Arrays.asList("sailfish-userdebug", "marlin-userdebug", "taimen-userdebug", "walleye-userdebug", "aosp_arm_a-userdebug");
    branchList.forEach(branch -> targetList.forEach(target -> IntStream.range(0, 10).forEach(idx -> {
        String year = String.format("%04d", 2010 + idx);
        String month = String.format("%02d", rand.nextInt(12));
        String day = String.format("%02d", rand.nextInt(30));
        String fileName = String.format("%02d%02d%02d.bin", rand.nextInt(23) + 1, rand.nextInt(59) + 1, rand.nextInt(59) + 1);
        List<String> pathList = Arrays.asList(GCS_SUITE_TEST_FOLDER_NAME == "" ? "suite_result" : GCS_SUITE_TEST_FOLDER_NAME, year, month, day, fileName);
        Path pathInfo = Paths.get(String.join(fileSeparator, pathList));
        TestSuiteFileEntity newTestSuiteFileEntity = new TestSuiteFileEntity(pathInfo.toString());
        newTestSuiteFileEntity.save();
        com.googlecode.objectify.Key<TestSuiteFileEntity> testSuiteFileParent = com.googlecode.objectify.Key.create(TestSuiteFileEntity.class, newTestSuiteFileEntity.getFilePath());
        TestSuiteResultEntity testSuiteResultEntity = new TestSuiteResultEntity(testSuiteFileParent, Instant.now().minus(rand.nextInt(100), ChronoUnit.DAYS).getEpochSecond(), Instant.now().minus(rand.nextInt(100), ChronoUnit.DAYS).getEpochSecond(), pathInfo.toString(), "Test Place Name -" + idx, "Suite Test Plan", "Suite Version " + idx, "Suite Test Name", "Suite Build Number " + idx, rand.nextInt(), rand.nextInt(), branch, target, Long.toString(Math.abs(rand.nextLong())), "Build System Fingerprint " + idx, "Build Vendor Fingerprint " + idx, rand.nextInt(), rand.nextInt());
        testSuiteResultEntity.save();
    })));
    resultMap.put("result", "successfully generated!");
    return resultMap;
}
#end_block

#method_before
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    logger.log(Level.INFO, "Job Started!!!!!!!!!!!!!");
    Queue queue = QueueFactory.getQueue(QUEUE);
    List<TaskOptions> tasks = new ArrayList<>();
    String fileSeparator = FileSystems.getDefault().getSeparator();
    Date today = new Date();
    String year = new SimpleDateFormat("yyyy").format(today);
    String month = new SimpleDateFormat("MM").format(today);
    String day = new SimpleDateFormat("dd").format(today);
    List<String> pathList = Arrays.asList(GCS_SUITE_TEST_FOLDER_NAME, year, month, day);
    Path pathInfo = Paths.get(String.join(fileSeparator, pathList));
    List<TestSuiteFileEntity> testSuiteFileEntityList = ofy().load().type(TestSuiteFileEntity.class).filter("year", Integer.parseInt(year)).filter("month", Integer.parseInt(month)).filter("day", Integer.parseInt(day)).list();
    List<String> filePathList = testSuiteFileEntityList.stream().map(testSuiteFile -> testSuiteFile.getFilePath()).collect(Collectors.toList());
    Bucket vtsReportBucket = this.storage.get(GCS_BUCKET_NAME);
    Storage.BlobListOption[] listOptions = new Storage.BlobListOption[] { Storage.BlobListOption.prefix(pathInfo.toString() + fileSeparator) };
    Iterable<Blob> blobIterable = vtsReportBucket.list(listOptions).iterateAll();
    Iterator<Blob> blobIterator = blobIterable.iterator();
    while (blobIterator.hasNext()) {
        Blob blob = blobIterator.next();
        if (blob.isDirectory()) {
            logger.log(Level.INFO, blob.getName() + " directory will be skipped!");
        } else {
            if (filePathList.contains(blob.getName())) {
                logger.log(Level.INFO, "filePathList contain => " + blob.getName());
            } else if (blob.getName().endsWith(fileSeparator)) {
                logger.log(Level.INFO, blob.getName() + " endswith slash!");
            } else {
                TaskOptions task = TaskOptions.Builder.withUrl(SUITE_TEST_URL).param("filePath", blob.getName()).method(TaskOptions.Method.POST);
                tasks.add(task);
            }
        }
    }
    TaskQueueHelper.addToQueue(queue, tasks);
}
#method_after
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    logger.log(Level.INFO, "Job Started!!!!!!!!!!!!!");
    long currentMicroSecond = TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis());
    String todayDateString = TimeUtil.getDateString(currentMicroSecond);
    String[] dateArray = todayDateString.split("-");
    if (dateArray.length == 3) {
        Queue queue = QueueFactory.getQueue(QUEUE);
        List<TaskOptions> tasks = new ArrayList<>();
        String fileSeparator = FileSystems.getDefault().getSeparator();
        String year = dateArray[0];
        String month = dateArray[1];
        String day = dateArray[2];
        List<String> pathList = Arrays.asList(GCS_SUITE_TEST_FOLDER_NAME, year, month, day);
        Path pathInfo = Paths.get(String.join(fileSeparator, pathList));
        List<TestSuiteFileEntity> testSuiteFileEntityList = ofy().load().type(TestSuiteFileEntity.class).filter("year", Integer.parseInt(year)).filter("month", Integer.parseInt(month)).filter("day", Integer.parseInt(day)).list();
        List<String> filePathList = testSuiteFileEntityList.stream().map(testSuiteFile -> testSuiteFile.getFilePath()).collect(Collectors.toList());
        Bucket vtsReportBucket = this.storage.get(GCS_BUCKET_NAME);
        Storage.BlobListOption[] listOptions = new Storage.BlobListOption[] { Storage.BlobListOption.prefix(pathInfo.toString() + fileSeparator) };
        Iterable<Blob> blobIterable = vtsReportBucket.list(listOptions).iterateAll();
        Iterator<Blob> blobIterator = blobIterable.iterator();
        while (blobIterator.hasNext()) {
            Blob blob = blobIterator.next();
            if (blob.isDirectory()) {
                logger.log(Level.INFO, blob.getName() + " directory will be skipped!");
            } else {
                if (filePathList.contains(blob.getName())) {
                    logger.log(Level.INFO, "filePathList contain => " + blob.getName());
                } else if (blob.getName().endsWith(fileSeparator)) {
                    logger.log(Level.INFO, blob.getName() + " endswith slash!");
                } else {
                    TaskOptions task = TaskOptions.Builder.withUrl(SUITE_TEST_URL).param("filePath", blob.getName()).method(TaskOptions.Method.POST);
                    tasks.add(task);
                }
            }
        }
        TaskQueueHelper.addToQueue(queue, tasks);
    } else {
        throw new IllegalArgumentException(todayDateString + " date string not in correct format");
    }
}
#end_block

#method_before
static void resetSerial() {
    // Use a positive random number so that on recovery we probably don't mix old requests
    // with new. Positive numbers are used to make sure the serial number is always increasing
    // even if they are truncated.
    sNextSerial.set(sRandom.nextInt(Integer.MAX_VALUE));
}
#method_after
static void resetSerial() {
    // Use a non-negative random number so that on recovery we probably don't mix old requests
    // with new.
    sNextSerial.set(sRandom.nextInt(Integer.MAX_VALUE));
}
#end_block

#method_before
private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
    if (prevState != state && state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.A2DP_SINK);
    }
    Intent intent = new Intent(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    // FIXME            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
    log("Connection state " + device + ": " + prevState + "->" + state);
}
#method_after
private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
    if (prevState != state && state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.A2DP_SINK);
    }
    Intent intent = new Intent(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    // FIXME            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
    log("Connection state " + device + ": " + prevState + "->" + state);
}
#end_block

#method_before
public static void logProfileConnectionEvent(BluetoothProfileId profileId) {
    synchronized (sProfileConnectionCounts) {
        sProfileConnectionCounts.merge(profileId, 1, Integer::sum);
    }
}
#method_after
public static void logProfileConnectionEvent(ProfileId profileId) {
    synchronized (sProfileConnectionCounts) {
        sProfileConnectionCounts.merge(profileId, 1, Integer::sum);
    }
}
#end_block

#method_before
public static void dumpProto(BluetoothLog.Builder metricsBuilder) {
    synchronized (sProfileConnectionCounts) {
        sProfileConnectionCounts.forEach((key, value) -> metricsBuilder.addProfileUsageStats(ProfileUsageStats.newBuilder().setProfileId(key).setNumTimesConnected(value).build()));
        sProfileConnectionCounts.clear();
    }
}
#method_after
public static void dumpProto(BluetoothLog.Builder metricsBuilder) {
    synchronized (sProfileConnectionCounts) {
        sProfileConnectionCounts.forEach((key, value) -> metricsBuilder.addProfileConnectionStats(ProfileConnectionStats.newBuilder().setProfileId(key).setNumTimesConnected(value).build()));
        sProfileConnectionCounts.clear();
    }
}
#end_block

#method_before
@Override
protected void setUserUnlocked(int userId) {
    Log.i(TAG, "User unlocked, initializing the service");
    if (!SystemProperties.getBoolean(AVRCP_ENABLE_PROPERTY, false)) {
        Log.w(TAG, "Skipping initialization of the new AVRCP Target Service");
        sInstance = null;
        return;
    }
    init();
    // Only allow the service to be used once it is initialized
    sInstance = this;
}
#method_after
@Override
protected void setUserUnlocked(int userId) {
    Log.i(TAG, "User unlocked, initializing the service");
    if (!SystemProperties.getBoolean(AVRCP_ENABLE_PROPERTY, false)) {
        Log.w(TAG, "Skipping initialization of the new AVRCP Target Player List");
        sInstance = null;
        return;
    }
    if (mMediaPlayerList != null) {
        mMediaPlayerList.init(new ListCallback());
    }
}
#end_block

#method_before
@Override
protected boolean start() {
    Log.i(TAG, "Starting the AVRCP Target Service");
    mCurrentData = new MediaData(null, null, null);
    mReceiver = new AvrcpBroadcastReceiver();
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothA2dp.ACTION_ACTIVE_DEVICE_CHANGED);
    registerReceiver(mReceiver, filter);
    return true;
}
#method_after
@Override
protected boolean start() {
    if (sInstance != null) {
        Log.wtfStack(TAG, "The service has already been initialized");
        return false;
    }
    Log.i(TAG, "Starting the AVRCP Target Service");
    mCurrentData = new MediaData(null, null, null);
    mReceiver = new AvrcpBroadcastReceiver();
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothA2dp.ACTION_ACTIVE_DEVICE_CHANGED);
    registerReceiver(mReceiver, filter);
    if (!SystemProperties.getBoolean(AVRCP_ENABLE_PROPERTY, false)) {
        Log.w(TAG, "Skipping initialization of the new AVRCP Target Service");
        sInstance = null;
        return true;
    }
    mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    sDeviceMaxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
    mMediaPlayerList = new MediaPlayerList(Looper.myLooper(), this);
    UserManager userManager = UserManager.get(getApplicationContext());
    if (userManager.isUserUnlocked()) {
        mMediaPlayerList.init(new ListCallback());
    }
    mNativeInterface = AvrcpNativeInterface.getInterface();
    mNativeInterface.init(AvrcpTargetService.this);
    // Only allow the service to be used once it is initialized
    sInstance = this;
    return true;
}
#end_block

#method_before
private void init() {
    if (mMediaPlayerList != null) {
        Log.wtfStack(TAG, "init: The service has already been initialized");
        return;
    }
    mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    sDeviceMaxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
    mMediaPlayerList = new MediaPlayerList();
    mMediaPlayerList.init(Looper.myLooper(), this, new ListCallback());
    mNativeInterface = AvrcpNativeInterface.getInterface();
    mNativeInterface.init(AvrcpTargetService.this);
}
#method_after
private void init() {
}
#end_block

#method_before
void deviceConnected(String bdaddr, boolean absoluteVolume) {
    Log.i(TAG, "deviceConnected: bdaddr=" + bdaddr + " absoluteVolume=" + absoluteVolume);
    mAudioManager.avrcpSupportsAbsoluteVolume(bdaddr, absoluteVolume);
    MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.AVRCP);
}
#method_after
void deviceConnected(String bdaddr, boolean absoluteVolume) {
    Log.i(TAG, "deviceConnected: bdaddr=" + bdaddr + " absoluteVolume=" + absoluteVolume);
    mAudioManager.avrcpSupportsAbsoluteVolume(bdaddr, absoluteVolume);
    MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.AVRCP);
}
#end_block

#method_before
private void setAndBroadcastConnectionState(BluetoothDevice device, int newState) {
    if (DBG) {
        Log.d(TAG, "setAndBroadcastConnectionState(): device=" + device.getAddress() + " oldState=" + mHidDeviceState + " newState=" + newState);
    }
    if (mHidDevice != null && !mHidDevice.equals(device)) {
        Log.w(TAG, "Connection state changed for unknown device, ignoring");
        return;
    }
    int prevState = mHidDeviceState;
    mHidDeviceState = newState;
    if (prevState == newState) {
        Log.w(TAG, "Connection state is unchanged, ignoring");
        return;
    }
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.HID_DEVICE);
    }
    Intent intent = new Intent(BluetoothHidDevice.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
}
#method_after
private void setAndBroadcastConnectionState(BluetoothDevice device, int newState) {
    if (DBG) {
        Log.d(TAG, "setAndBroadcastConnectionState(): device=" + device.getAddress() + " oldState=" + mHidDeviceState + " newState=" + newState);
    }
    if (mHidDevice != null && !mHidDevice.equals(device)) {
        Log.w(TAG, "Connection state changed for unknown device, ignoring");
        return;
    }
    int prevState = mHidDeviceState;
    mHidDeviceState = newState;
    if (prevState == newState) {
        Log.w(TAG, "Connection state is unchanged, ignoring");
        return;
    }
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.HID_DEVICE);
    }
    Intent intent = new Intent(BluetoothHidDevice.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
}
#end_block

#method_before
public void setActiveDevice(BluetoothDevice device) {
    if (DBG) {
        Log.d(TAG, "setActiveDevice:" + device);
    }
    if (device == null) {
        if (mActiveDeviceHiSyncId != BluetoothHearingAid.HI_SYNC_ID_INVALID) {
            reportActiveDevice(null);
            mActiveDeviceHiSyncId = BluetoothHearingAid.HI_SYNC_ID_INVALID;
        }
        return;
    }
    Long deviceHiSyncId = mDeviceHiSyncIdMap.getOrDefault(device, BluetoothHearingAid.HI_SYNC_ID_INVALID);
    if (deviceHiSyncId != mActiveDeviceHiSyncId) {
        reportActiveDevice(device);
        mActiveDeviceHiSyncId = deviceHiSyncId;
    }
}
#method_after
public boolean setActiveDevice(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    if (DBG) {
        Log.d(TAG, "setActiveDevice:" + device);
    }
    synchronized (mStateMachines) {
        if (device == null) {
            if (mActiveDeviceHiSyncId != BluetoothHearingAid.HI_SYNC_ID_INVALID) {
                reportActiveDevice(null);
                mActiveDeviceHiSyncId = BluetoothHearingAid.HI_SYNC_ID_INVALID;
            }
            return true;
        }
        if (getConnectionState(device) != BluetoothProfile.STATE_CONNECTED) {
            Log.e(TAG, "setActiveDevice(" + device + "): failed because device not connected");
            return false;
        }
        Long deviceHiSyncId = mDeviceHiSyncIdMap.getOrDefault(device, BluetoothHearingAid.HI_SYNC_ID_INVALID);
        if (deviceHiSyncId != mActiveDeviceHiSyncId) {
            mActiveDeviceHiSyncId = deviceHiSyncId;
            reportActiveDevice(device);
        }
    }
    return true;
}
#end_block

#method_before
@VisibleForTesting
synchronized void connectionStateChanged(BluetoothDevice device, int fromState, int toState) {
    if ((device == null) || (fromState == toState)) {
        Log.e(TAG, "connectionStateChanged: unexpected invocation. device=" + device + " fromState=" + fromState + " toState=" + toState);
        return;
    }
    if (toState == BluetoothProfile.STATE_CONNECTED) {
        setActiveDevice(device);
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.HEARING_AID);
    }
    if (fromState == BluetoothProfile.STATE_CONNECTED && getConnectedDevices().isEmpty()) {
        setActiveDevice(null);
    }
    // Check if the device is disconnected - if unbond, remove the state machine
    if (toState == BluetoothProfile.STATE_DISCONNECTED) {
        int bondState = mAdapterService.getBondState(device);
        if (bondState == BluetoothDevice.BOND_NONE) {
            if (DBG) {
                Log.d(TAG, device + " is unbond. Remove state machine");
            }
            removeStateMachine(device);
        }
    }
}
#method_after
@VisibleForTesting
synchronized void connectionStateChanged(BluetoothDevice device, int fromState, int toState) {
    if ((device == null) || (fromState == toState)) {
        Log.e(TAG, "connectionStateChanged: unexpected invocation. device=" + device + " fromState=" + fromState + " toState=" + toState);
        return;
    }
    if (toState == BluetoothProfile.STATE_CONNECTED) {
        long myHiSyncId = getHiSyncId(device);
        if (myHiSyncId == BluetoothHearingAid.HI_SYNC_ID_INVALID || getConnectedPeerDevices(myHiSyncId).size() == 1) {
            // Log hearing aid connection event if we are the first device in a set
            // Or when the hiSyncId has not been found
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.HEARING_AID);
        }
        setActiveDevice(device);
    }
    if (fromState == BluetoothProfile.STATE_CONNECTED && getConnectedDevices().isEmpty()) {
        setActiveDevice(null);
    }
    // Check if the device is disconnected - if unbond, remove the state machine
    if (toState == BluetoothProfile.STATE_DISCONNECTED) {
        int bondState = mAdapterService.getBondState(device);
        if (bondState == BluetoothDevice.BOND_NONE) {
            if (DBG) {
                Log.d(TAG, device + " is unbond. Remove state machine");
            }
            removeStateMachine(device);
        }
    }
}
#end_block

#method_before
@Override
public void setActiveDevice(BluetoothDevice device) {
    HearingAidService service = getService();
    if (service == null) {
        return;
    }
    service.setActiveDevice(device);
}
#method_after
@Override
public boolean setActiveDevice(BluetoothDevice device) {
    HearingAidService service = getService();
    if (service == null) {
        return false;
    }
    return service.setActiveDevice(device);
}
#end_block

#method_before
@Test
public void testLogProfileConnectionEvent() {
    MetricsLogger.logProfileConnectionEvent(BluetoothProfileId.AVRCP);
    BluetoothLog.Builder metricsBuilder = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilder);
    BluetoothLog metricsProto = metricsBuilder.build();
    Assert.assertEquals(1, metricsProto.getProfileUsageStatsCount());
    ProfileUsageStats profileUsageStatsAvrcp = metricsProto.getProfileUsageStats(0);
    Assert.assertEquals(BluetoothProfileId.AVRCP, profileUsageStatsAvrcp.getProfileId());
    Assert.assertEquals(1, profileUsageStatsAvrcp.getNumTimesConnected());
    // Verify that MetricsLogger's internal state is cleared after a dump
    BluetoothLog.Builder metricsBuilderAfterDump = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilderAfterDump);
    BluetoothLog metricsProtoAfterDump = metricsBuilderAfterDump.build();
    Assert.assertEquals(0, metricsProtoAfterDump.getProfileUsageStatsCount());
}
#method_after
@Test
public void testLogProfileConnectionEvent() {
    MetricsLogger.logProfileConnectionEvent(ProfileId.AVRCP);
    BluetoothLog.Builder metricsBuilder = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilder);
    BluetoothLog metricsProto = metricsBuilder.build();
    Assert.assertEquals(1, metricsProto.getProfileConnectionStatsCount());
    ProfileConnectionStats profileUsageStatsAvrcp = metricsProto.getProfileConnectionStats(0);
    Assert.assertEquals(ProfileId.AVRCP, profileUsageStatsAvrcp.getProfileId());
    Assert.assertEquals(1, profileUsageStatsAvrcp.getNumTimesConnected());
    // Verify that MetricsLogger's internal state is cleared after a dump
    BluetoothLog.Builder metricsBuilderAfterDump = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilderAfterDump);
    BluetoothLog metricsProtoAfterDump = metricsBuilderAfterDump.build();
    Assert.assertEquals(0, metricsProtoAfterDump.getProfileConnectionStatsCount());
}
#end_block

#method_before
@Test
public void testLogProfileConnectionEventMultipleProfile() {
    MetricsLogger.logProfileConnectionEvent(BluetoothProfileId.AVRCP);
    MetricsLogger.logProfileConnectionEvent(BluetoothProfileId.HEADSET);
    MetricsLogger.logProfileConnectionEvent(BluetoothProfileId.AVRCP);
    BluetoothLog.Builder metricsBuilder = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilder);
    BluetoothLog metricsProto = metricsBuilder.build();
    Assert.assertEquals(2, metricsProto.getProfileUsageStatsCount());
    HashMap<BluetoothProfileId, ProfileUsageStats> profileConnectionCountMap = getProfileUsageStatsMap(metricsProto.getProfileUsageStatsList());
    Assert.assertTrue(profileConnectionCountMap.containsKey(BluetoothProfileId.AVRCP));
    Assert.assertEquals(2, profileConnectionCountMap.get(BluetoothProfileId.AVRCP).getNumTimesConnected());
    Assert.assertTrue(profileConnectionCountMap.containsKey(BluetoothProfileId.HEADSET));
    Assert.assertEquals(1, profileConnectionCountMap.get(BluetoothProfileId.HEADSET).getNumTimesConnected());
    // Verify that MetricsLogger's internal state is cleared after a dump
    BluetoothLog.Builder metricsBuilderAfterDump = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilderAfterDump);
    BluetoothLog metricsProtoAfterDump = metricsBuilderAfterDump.build();
    Assert.assertEquals(0, metricsProtoAfterDump.getProfileUsageStatsCount());
}
#method_after
@Test
public void testLogProfileConnectionEventMultipleProfile() {
    MetricsLogger.logProfileConnectionEvent(ProfileId.AVRCP);
    MetricsLogger.logProfileConnectionEvent(ProfileId.HEADSET);
    MetricsLogger.logProfileConnectionEvent(ProfileId.AVRCP);
    BluetoothLog.Builder metricsBuilder = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilder);
    BluetoothLog metricsProto = metricsBuilder.build();
    Assert.assertEquals(2, metricsProto.getProfileConnectionStatsCount());
    HashMap<ProfileId, ProfileConnectionStats> profileConnectionCountMap = getProfileUsageStatsMap(metricsProto.getProfileConnectionStatsList());
    Assert.assertTrue(profileConnectionCountMap.containsKey(ProfileId.AVRCP));
    Assert.assertEquals(2, profileConnectionCountMap.get(ProfileId.AVRCP).getNumTimesConnected());
    Assert.assertTrue(profileConnectionCountMap.containsKey(ProfileId.HEADSET));
    Assert.assertEquals(1, profileConnectionCountMap.get(ProfileId.HEADSET).getNumTimesConnected());
    // Verify that MetricsLogger's internal state is cleared after a dump
    BluetoothLog.Builder metricsBuilderAfterDump = BluetoothLog.newBuilder();
    MetricsLogger.dumpProto(metricsBuilderAfterDump);
    BluetoothLog metricsProtoAfterDump = metricsBuilderAfterDump.build();
    Assert.assertEquals(0, metricsProtoAfterDump.getProfileConnectionStatsCount());
}
#end_block

#method_before
private static HashMap<BluetoothProfileId, ProfileUsageStats> getProfileUsageStatsMap(List<ProfileUsageStats> profileUsageStats) {
    HashMap<BluetoothProfileId, ProfileUsageStats> profileUsageStatsMap = new HashMap<>();
    profileUsageStats.forEach(item -> profileUsageStatsMap.put(item.getProfileId(), item));
    return profileUsageStatsMap;
}
#method_after
private static HashMap<ProfileId, ProfileConnectionStats> getProfileUsageStatsMap(List<ProfileConnectionStats> profileUsageStats) {
    HashMap<ProfileId, ProfileConnectionStats> profileUsageStatsMap = new HashMap<>();
    profileUsageStats.forEach(item -> profileUsageStatsMap.put(item.getProfileId(), item));
    return profileUsageStatsMap;
}
#end_block

#method_before
private void updateAndSendIntent(BluetoothDevice device, int newDeviceState, int prevDeviceState) {
    if (newDeviceState == BluetoothHealth.STATE_DISCONNECTED) {
        mHealthDevices.remove(device);
    } else {
        mHealthDevices.put(device, newDeviceState);
    }
    if (newDeviceState != prevDeviceState && newDeviceState == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.HEALTH);
    }
}
#method_after
private void updateAndSendIntent(BluetoothDevice device, int newDeviceState, int prevDeviceState) {
    if (newDeviceState == BluetoothHealth.STATE_DISCONNECTED) {
        mHealthDevices.remove(device);
    } else {
        mHealthDevices.put(device, newDeviceState);
    }
    if (newDeviceState != prevDeviceState && newDeviceState == BluetoothHealth.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.HEALTH);
    }
}
#end_block

#method_before
private void broadcastConnectionState(BluetoothDevice device, int newState) {
    Integer prevStateInteger = mInputDevices.get(device);
    int prevState = (prevStateInteger == null) ? BluetoothHidHost.STATE_DISCONNECTED : prevStateInteger;
    if (prevState == newState) {
        Log.w(TAG, "no state change: " + newState);
        return;
    }
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.HID_HOST);
    }
    mInputDevices.put(device, newState);
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    Log.d(TAG, "Connection state " + device + ": " + prevState + "->" + newState);
    Intent intent = new Intent(BluetoothHidHost.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
}
#method_after
private void broadcastConnectionState(BluetoothDevice device, int newState) {
    Integer prevStateInteger = mInputDevices.get(device);
    int prevState = (prevStateInteger == null) ? BluetoothHidHost.STATE_DISCONNECTED : prevStateInteger;
    if (prevState == newState) {
        Log.w(TAG, "no state change: " + newState);
        return;
    }
    if (newState == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.HID_HOST);
    }
    mInputDevices.put(device, newState);
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    Log.d(TAG, "Connection state " + device + ": " + prevState + "->" + newState);
    Intent intent = new Intent(BluetoothHidHost.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
}
#end_block

#method_before
@Override
public void enter() {
    try {
        startObexServerSession();
    } catch (IOException ex) {
        Log.e(TAG, "Caught exception starting OBEX server session" + ex.toString());
    }
    broadcastStateTransitions();
    MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.PBAP);
}
#method_after
@Override
public void enter() {
    try {
        startObexServerSession();
    } catch (IOException ex) {
        Log.e(TAG, "Caught exception starting OBEX server session" + ex.toString());
    }
    broadcastStateTransitions();
    MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.PBAP);
}
#end_block

#method_before
private synchronized void setState(int state, int result) {
    if (state != mState) {
        if (DEBUG) {
            Log.d(TAG, "Sap state " + mState + " -> " + state + ", result = " + result);
        }
        if (state == BluetoothProfile.STATE_CONNECTED) {
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.SAP);
        }
        int prevState = mState;
        mState = state;
        Intent intent = new Intent(BluetoothSap.ACTION_CONNECTION_STATE_CHANGED);
        intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothProfile.EXTRA_STATE, mState);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        sendBroadcast(intent, BLUETOOTH_PERM);
    }
}
#method_after
private synchronized void setState(int state, int result) {
    if (state != mState) {
        if (DEBUG) {
            Log.d(TAG, "Sap state " + mState + " -> " + state + ", result = " + result);
        }
        if (state == BluetoothProfile.STATE_CONNECTED) {
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.SAP);
        }
        int prevState = mState;
        mState = state;
        Intent intent = new Intent(BluetoothSap.ACTION_CONNECTION_STATE_CHANGED);
        intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothProfile.EXTRA_STATE, mState);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        sendBroadcast(intent, BLUETOOTH_PERM);
    }
}
#end_block

#method_before
Looper getStateMachinesThreadLooper() {
    return mStateMachinesThread.getLooper();
}
#method_after
@VisibleForTesting
public Looper getStateMachinesThreadLooper() {
    return mStateMachinesThread.getLooper();
}
#end_block

#method_before
boolean disconnect(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    synchronized (mStateMachines) {
        Log.i(TAG, "disconnect: device=" + device);
        HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "disconnect: device " + device + " not ever connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "disconnect: device " + device + " not connected/connecting, connectionState=" + connectionState);
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.DISCONNECT, device);
    }
    return true;
}
#method_after
boolean disconnect(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    synchronized (mStateMachines) {
        Log.i(TAG, "disconnect: device=" + device);
        HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "disconnect: device " + device + " not ever connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "disconnect: device " + device + " not connected/connecting, connectionState=" + connectionState);
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.DISCONNECT, device);
    }
    return true;
}
#end_block

#method_before
public BluetoothDevice getActiveDevice() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH_PERM permission");
    synchronized (mStateMachines) {
        return mActiveDevice;
    }
}
#method_after
public BluetoothDevice getActiveDevice() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        return mActiveDevice;
    }
}
#end_block

#method_before
boolean startScoUsingVirtualVoiceCall(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "startScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_START, device);
    }
    return true;
}
#method_after
boolean startScoUsingVirtualVoiceCall(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "startScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_START, device);
    }
    return true;
}
#end_block

#method_before
boolean stopScoUsingVirtualVoiceCall(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " is neither connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_STOP, device);
    }
    return true;
}
#method_after
boolean stopScoUsingVirtualVoiceCall(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " is neither connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_STOP, device);
    }
    return true;
}
#end_block

#method_before
@VisibleForTesting
public void onConnectionStateChangedFromStateMachine(BluetoothDevice device, int fromState, int toState) {
    synchronized (mStateMachines) {
        List<BluetoothDevice> audioConnectableDevices = getDevicesMatchingConnectionStates(CONNECTING_CONNECTED_STATES);
        if (fromState != BluetoothProfile.STATE_CONNECTED && toState == BluetoothProfile.STATE_CONNECTED) {
            if (audioConnectableDevices.size() > 1) {
                mInbandRingingRuntimeDisable = true;
                doForEachConnectedStateMachine(stateMachine -> stateMachine.sendMessage(HeadsetStateMachine.SEND_BSIR, 0));
            }
            if (mActiveDevice == null) {
                setActiveDevice(device);
            }
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.HEADSET);
        }
        if (fromState == BluetoothProfile.STATE_CONNECTED && toState != BluetoothProfile.STATE_CONNECTED) {
            if (audioConnectableDevices.size() <= 1) {
                mInbandRingingRuntimeDisable = false;
                doForEachConnectedStateMachine(stateMachine -> stateMachine.sendMessage(HeadsetStateMachine.SEND_BSIR, 1));
            }
            if (device.equals(mActiveDevice)) {
                setActiveDevice(null);
            }
        }
    }
}
#method_after
@VisibleForTesting
public void onConnectionStateChangedFromStateMachine(BluetoothDevice device, int fromState, int toState) {
    synchronized (mStateMachines) {
        List<BluetoothDevice> audioConnectableDevices = getDevicesMatchingConnectionStates(CONNECTING_CONNECTED_STATES);
        if (fromState != BluetoothProfile.STATE_CONNECTED && toState == BluetoothProfile.STATE_CONNECTED) {
            if (audioConnectableDevices.size() > 1) {
                mInbandRingingRuntimeDisable = true;
                doForEachConnectedStateMachine(stateMachine -> stateMachine.sendMessage(HeadsetStateMachine.SEND_BSIR, 0));
            }
            if (mActiveDevice == null) {
                setActiveDevice(device);
            }
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.HEADSET);
        }
        if (fromState == BluetoothProfile.STATE_CONNECTED && toState != BluetoothProfile.STATE_CONNECTED) {
            if (audioConnectableDevices.size() <= 1) {
                mInbandRingingRuntimeDisable = false;
                doForEachConnectedStateMachine(stateMachine -> stateMachine.sendMessage(HeadsetStateMachine.SEND_BSIR, 1));
            }
            if (device.equals(mActiveDevice)) {
                setActiveDevice(null);
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    if (DBG)
        Log.d(TAG, " HandleMessage: " + dumpMessageString(msg.what));
    switch(msg.what) {
        case MESSAGE_PROCESS_CONNECTION_CHANGE:
            if (msg.arg1 == BluetoothProfile.STATE_CONNECTED) {
                mBrowseTree.init();
                transitionTo(mConnected);
                BluetoothDevice rtDevice = (BluetoothDevice) msg.obj;
                synchronized (mLock) {
                    mRemoteDevice = new RemoteDevice(rtDevice);
                    mAddressedPlayer = new AvrcpPlayer();
                    mIsConnected = true;
                }
                MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.AVRCP_CONTROLLER);
                Intent intent = new Intent(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
                intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, BluetoothProfile.STATE_DISCONNECTED);
                intent.putExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_CONNECTED);
                intent.putExtra(BluetoothDevice.EXTRA_DEVICE, rtDevice);
                mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
            }
            break;
        default:
            Log.w(TAG, "Currently Disconnected not handling " + dumpMessageString(msg.what));
            return false;
    }
    return true;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    if (DBG)
        Log.d(TAG, " HandleMessage: " + dumpMessageString(msg.what));
    switch(msg.what) {
        case MESSAGE_PROCESS_CONNECTION_CHANGE:
            if (msg.arg1 == BluetoothProfile.STATE_CONNECTED) {
                mBrowseTree.init();
                transitionTo(mConnected);
                BluetoothDevice rtDevice = (BluetoothDevice) msg.obj;
                synchronized (mLock) {
                    mRemoteDevice = new RemoteDevice(rtDevice);
                    mAddressedPlayer = new AvrcpPlayer();
                    mIsConnected = true;
                }
                MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.AVRCP_CONTROLLER);
                Intent intent = new Intent(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
                intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, BluetoothProfile.STATE_DISCONNECTED);
                intent.putExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_CONNECTED);
                intent.putExtra(BluetoothDevice.EXTRA_DEVICE, rtDevice);
                mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
            }
            break;
        default:
            Log.w(TAG, "Currently Disconnected not handling " + dumpMessageString(msg.what));
            return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void enter() {
    if (DBG) {
        Log.d(TAG, "Enter Connected: " + getCurrentMessage().what);
    }
    mAudioWbs = false;
    mCommandedSpeakerVolume = -1;
    if (mPrevState == mConnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.HEADSET_CLIENT);
    } else if (mPrevState != mAudioOn) {
        String prevStateName = mPrevState == null ? "null" : mPrevState.getName();
        Log.e(TAG, "Connected: Illegal state transition from " + prevStateName + " to Connecting, mCurrentDevice=" + mCurrentDevice);
    }
}
#method_after
@Override
public void enter() {
    if (DBG) {
        Log.d(TAG, "Enter Connected: " + getCurrentMessage().what);
    }
    mAudioWbs = false;
    mCommandedSpeakerVolume = -1;
    if (mPrevState == mConnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.HEADSET_CLIENT);
    } else if (mPrevState != mAudioOn) {
        String prevStateName = mPrevState == null ? "null" : mPrevState.getName();
        Log.e(TAG, "Connected: Illegal state transition from " + prevStateName + " to Connecting, mCurrentDevice=" + mCurrentDevice);
    }
}
#end_block

#method_before
private void onConnectionStateChanged(int prevState, int state) {
    // mDevice == null only at setInitialState
    if (mDevice == null) {
        return;
    }
    if (DBG) {
        Log.d(TAG, "Connection state " + mDevice + ": " + prevState + "->" + state);
    }
    if (prevState != state && state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.MAP_CLIENT);
    }
    Intent intent = new Intent(BluetoothMapClient.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#method_after
private void onConnectionStateChanged(int prevState, int state) {
    // mDevice == null only at setInitialState
    if (mDevice == null) {
        return;
    }
    if (DBG) {
        Log.d(TAG, "Connection state " + mDevice + ": " + prevState + "->" + state);
    }
    if (prevState != state && state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.MAP_CLIENT);
    }
    Intent intent = new Intent(BluetoothMapClient.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mDevice);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#end_block

#method_before
void handlePanDeviceStateChange(BluetoothDevice device, String iface, int state, int localRole, int remoteRole) {
    if (DBG) {
        Log.d(TAG, "handlePanDeviceStateChange: device: " + device + ", iface: " + iface + ", state: " + state + ", localRole:" + localRole + ", remoteRole:" + remoteRole);
    }
    int prevState;
    BluetoothPanDevice panDevice = mPanDevices.get(device);
    if (panDevice == null) {
        Log.i(TAG, "state " + state + " Num of connected pan devices: " + mPanDevices.size());
        prevState = BluetoothProfile.STATE_DISCONNECTED;
        panDevice = new BluetoothPanDevice(state, iface, localRole, remoteRole);
        mPanDevices.put(device, panDevice);
    } else {
        prevState = panDevice.mState;
        panDevice.mState = state;
        panDevice.mLocalRole = localRole;
        panDevice.mRemoteRole = remoteRole;
        panDevice.mIface = iface;
    }
    // will fail until the caller explicitly calls BluetoothPan#disconnect.
    if (prevState == BluetoothProfile.STATE_DISCONNECTED && state == BluetoothProfile.STATE_DISCONNECTING) {
        Log.d(TAG, "Ignoring state change from " + prevState + " to " + state);
        mPanDevices.remove(device);
        return;
    }
    Log.d(TAG, "handlePanDeviceStateChange preState: " + prevState + " state: " + state);
    if (prevState == state) {
        return;
    }
    if (remoteRole == BluetoothPan.LOCAL_PANU_ROLE) {
        if (state == BluetoothProfile.STATE_CONNECTED) {
            if ((!mTetherOn) || (localRole == BluetoothPan.LOCAL_PANU_ROLE)) {
                Log.d(TAG, "handlePanDeviceStateChange BT tethering is off/Local role" + " is PANU drop the connection");
                mPanDevices.remove(device);
                disconnectPanNative(Utils.getByteAddress(device));
                return;
            }
            Log.d(TAG, "handlePanDeviceStateChange LOCAL_NAP_ROLE:REMOTE_PANU_ROLE");
            if (mNapIfaceAddr == null) {
                mNapIfaceAddr = startTethering(iface);
                if (mNapIfaceAddr == null) {
                    Log.e(TAG, "Error seting up tether interface");
                    mPanDevices.remove(device);
                    disconnectPanNative(Utils.getByteAddress(device));
                    return;
                }
            }
        } else if (state == BluetoothProfile.STATE_DISCONNECTED) {
            mPanDevices.remove(device);
            Log.i(TAG, "remote(PANU) is disconnected, Remaining connected PANU devices: " + mPanDevices.size());
            if (mNapIfaceAddr != null && mPanDevices.size() == 0) {
                stopTethering(iface);
                mNapIfaceAddr = null;
            }
        }
    } else if (mNetworkFactory != null) {
        // PANU Role = reverse Tether
        Log.d(TAG, "handlePanDeviceStateChange LOCAL_PANU_ROLE:REMOTE_NAP_ROLE state = " + state + ", prevState = " + prevState);
        if (state == BluetoothProfile.STATE_CONNECTED) {
            mNetworkFactory.startReverseTether(iface);
        } else if (state == BluetoothProfile.STATE_DISCONNECTED) {
            mNetworkFactory.stopReverseTether();
            mPanDevices.remove(device);
        }
    }
    if (state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.PAN);
    }
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    Log.d(TAG, "Pan Device state : device: " + device + " State:" + prevState + "->" + state);
    Intent intent = new Intent(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothPan.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothPan.EXTRA_STATE, state);
    intent.putExtra(BluetoothPan.EXTRA_LOCAL_ROLE, localRole);
    sendBroadcast(intent, BLUETOOTH_PERM);
}
#method_after
void handlePanDeviceStateChange(BluetoothDevice device, String iface, int state, int localRole, int remoteRole) {
    if (DBG) {
        Log.d(TAG, "handlePanDeviceStateChange: device: " + device + ", iface: " + iface + ", state: " + state + ", localRole:" + localRole + ", remoteRole:" + remoteRole);
    }
    int prevState;
    BluetoothPanDevice panDevice = mPanDevices.get(device);
    if (panDevice == null) {
        Log.i(TAG, "state " + state + " Num of connected pan devices: " + mPanDevices.size());
        prevState = BluetoothProfile.STATE_DISCONNECTED;
        panDevice = new BluetoothPanDevice(state, iface, localRole, remoteRole);
        mPanDevices.put(device, panDevice);
    } else {
        prevState = panDevice.mState;
        panDevice.mState = state;
        panDevice.mLocalRole = localRole;
        panDevice.mRemoteRole = remoteRole;
        panDevice.mIface = iface;
    }
    // will fail until the caller explicitly calls BluetoothPan#disconnect.
    if (prevState == BluetoothProfile.STATE_DISCONNECTED && state == BluetoothProfile.STATE_DISCONNECTING) {
        Log.d(TAG, "Ignoring state change from " + prevState + " to " + state);
        mPanDevices.remove(device);
        return;
    }
    Log.d(TAG, "handlePanDeviceStateChange preState: " + prevState + " state: " + state);
    if (prevState == state) {
        return;
    }
    if (remoteRole == BluetoothPan.LOCAL_PANU_ROLE) {
        if (state == BluetoothProfile.STATE_CONNECTED) {
            if ((!mTetherOn) || (localRole == BluetoothPan.LOCAL_PANU_ROLE)) {
                Log.d(TAG, "handlePanDeviceStateChange BT tethering is off/Local role" + " is PANU drop the connection");
                mPanDevices.remove(device);
                disconnectPanNative(Utils.getByteAddress(device));
                return;
            }
            Log.d(TAG, "handlePanDeviceStateChange LOCAL_NAP_ROLE:REMOTE_PANU_ROLE");
            if (mNapIfaceAddr == null) {
                mNapIfaceAddr = startTethering(iface);
                if (mNapIfaceAddr == null) {
                    Log.e(TAG, "Error seting up tether interface");
                    mPanDevices.remove(device);
                    disconnectPanNative(Utils.getByteAddress(device));
                    return;
                }
            }
        } else if (state == BluetoothProfile.STATE_DISCONNECTED) {
            mPanDevices.remove(device);
            Log.i(TAG, "remote(PANU) is disconnected, Remaining connected PANU devices: " + mPanDevices.size());
            if (mNapIfaceAddr != null && mPanDevices.size() == 0) {
                stopTethering(iface);
                mNapIfaceAddr = null;
            }
        }
    } else if (mNetworkFactory != null) {
        // PANU Role = reverse Tether
        Log.d(TAG, "handlePanDeviceStateChange LOCAL_PANU_ROLE:REMOTE_NAP_ROLE state = " + state + ", prevState = " + prevState);
        if (state == BluetoothProfile.STATE_CONNECTED) {
            mNetworkFactory.startReverseTether(iface);
        } else if (state == BluetoothProfile.STATE_DISCONNECTED) {
            mNetworkFactory.stopReverseTether();
            mPanDevices.remove(device);
        }
    }
    if (state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.PAN);
    }
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    Log.d(TAG, "Pan Device state : device: " + device + " State:" + prevState + "->" + state);
    Intent intent = new Intent(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.putExtra(BluetoothPan.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothPan.EXTRA_STATE, state);
    intent.putExtra(BluetoothPan.EXTRA_LOCAL_ROLE, localRole);
    sendBroadcast(intent, BLUETOOTH_PERM);
}
#end_block

#method_before
private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
    if (device == null) {
        Log.w(TAG, "onConnectionStateChanged with invalid device");
        return;
    }
    if (prevState != state && state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.PBAP_CLIENT);
    }
    Log.d(TAG, "Connection state " + device + ": " + prevState + "->" + state);
    Intent intent = new Intent(BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#method_after
private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
    if (device == null) {
        Log.w(TAG, "onConnectionStateChanged with invalid device");
        return;
    }
    if (prevState != state && state == BluetoothProfile.STATE_CONNECTED) {
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.PBAP_CLIENT);
    }
    Log.d(TAG, "Connection state " + device + ": " + prevState + "->" + state);
    Intent intent = new Intent(BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mService.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
}
#end_block

#method_before
private void connectionStateChanged(BluetoothDevice device, int fromState, int toState) {
    if ((device == null) || (fromState == toState)) {
        return;
    }
    synchronized (mStateMachines) {
        if (toState == BluetoothProfile.STATE_CONNECTED) {
            // Each time a device connects, we want to re-check if it supports optional
            // codecs (perhaps it's had a firmware update, etc.) and save that state if
            // it differs from what we had saved before.
            updateOptionalCodecsSupport(device);
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.A2DP);
        }
        // Set the active device if only one connected device is supported and it was connected
        if (toState == BluetoothProfile.STATE_CONNECTED && (mMaxConnectedAudioDevices == 1)) {
            setActiveDevice(device);
        }
        // Check if the active device is not connected anymore
        if (isActiveDevice(device) && (fromState == BluetoothProfile.STATE_CONNECTED)) {
            setActiveDevice(null);
        }
        // Check if the device is disconnected - if unbond, remove the state machine
        if (toState == BluetoothProfile.STATE_DISCONNECTED) {
            int bondState = mAdapterService.getBondState(device);
            if (bondState == BluetoothDevice.BOND_NONE) {
                removeStateMachine(device);
            }
        }
    }
}
#method_after
private void connectionStateChanged(BluetoothDevice device, int fromState, int toState) {
    if ((device == null) || (fromState == toState)) {
        return;
    }
    synchronized (mStateMachines) {
        if (toState == BluetoothProfile.STATE_CONNECTED) {
            // Each time a device connects, we want to re-check if it supports optional
            // codecs (perhaps it's had a firmware update, etc.) and save that state if
            // it differs from what we had saved before.
            updateOptionalCodecsSupport(device);
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.A2DP);
        }
        // Set the active device if only one connected device is supported and it was connected
        if (toState == BluetoothProfile.STATE_CONNECTED && (mMaxConnectedAudioDevices == 1)) {
            setActiveDevice(device);
        }
        // Check if the active device is not connected anymore
        if (isActiveDevice(device) && (fromState == BluetoothProfile.STATE_CONNECTED)) {
            setActiveDevice(null);
        }
        // Check if the device is disconnected - if unbond, remove the state machine
        if (toState == BluetoothProfile.STATE_DISCONNECTED) {
            int bondState = mAdapterService.getBondState(device);
            if (bondState == BluetoothDevice.BOND_NONE) {
                removeStateMachine(device);
            }
        }
    }
}
#end_block

#method_before
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothMapMasInstance masInst) {
    boolean sendIntent = false;
    boolean cancelConnection = false;
    // As this can be called from each MasInstance, we need to lock access to member variables
    synchronized (this) {
        if (sRemoteDevice == null) {
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.BluetoothProfileId.MAP);
            sRemoteDevice = remoteDevice;
            sRemoteDeviceName = sRemoteDevice.getName();
            // In case getRemoteName failed and return null
            if (TextUtils.isEmpty(sRemoteDeviceName)) {
                sRemoteDeviceName = getString(R.string.defaultname);
            }
            mPermission = sRemoteDevice.getMessageAccessPermission();
            if (mPermission == BluetoothDevice.ACCESS_UNKNOWN) {
                sendIntent = true;
                mIsWaitingAuthorization = true;
                setUserTimeoutAlarm();
            } else if (mPermission == BluetoothDevice.ACCESS_REJECTED) {
                cancelConnection = true;
            } else if (mPermission == BluetoothDevice.ACCESS_ALLOWED) {
                sRemoteDevice.sdpSearch(BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS);
                mSdpSearchInitiated = true;
            }
        } else if (!sRemoteDevice.equals(remoteDevice)) {
            Log.w(TAG, "Unexpected connection from a second Remote Device received. name: " + ((remoteDevice == null) ? "unknown" : remoteDevice.getName()));
            return false;
        }
    // Else second connection to same device, just continue
    }
    if (sendIntent) {
        // This will trigger Settings app's dialog.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setPackage(getString(R.string.pairing_ui_package));
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_MESSAGE_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, sRemoteDevice);
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE) {
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        }
    // Queue USER_TIMEOUT to disconnect MAP OBEX session. If user doesn't
    // accept or reject authorization request
    } else if (cancelConnection) {
        sendConnectCancelMessage();
    } else if (mPermission == BluetoothDevice.ACCESS_ALLOWED) {
        // Signal to the service that we have a incoming connection.
        sendConnectMessage(masInst.getMasId());
    }
    return true;
}
#method_after
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothMapMasInstance masInst) {
    boolean sendIntent = false;
    boolean cancelConnection = false;
    // As this can be called from each MasInstance, we need to lock access to member variables
    synchronized (this) {
        if (sRemoteDevice == null) {
            sRemoteDevice = remoteDevice;
            sRemoteDeviceName = sRemoteDevice.getName();
            // In case getRemoteName failed and return null
            if (TextUtils.isEmpty(sRemoteDeviceName)) {
                sRemoteDeviceName = getString(R.string.defaultname);
            }
            mPermission = sRemoteDevice.getMessageAccessPermission();
            if (mPermission == BluetoothDevice.ACCESS_UNKNOWN) {
                sendIntent = true;
                mIsWaitingAuthorization = true;
                setUserTimeoutAlarm();
            } else if (mPermission == BluetoothDevice.ACCESS_REJECTED) {
                cancelConnection = true;
            } else if (mPermission == BluetoothDevice.ACCESS_ALLOWED) {
                sRemoteDevice.sdpSearch(BluetoothMnsObexClient.BLUETOOTH_UUID_OBEX_MNS);
                mSdpSearchInitiated = true;
            }
        } else if (!sRemoteDevice.equals(remoteDevice)) {
            Log.w(TAG, "Unexpected connection from a second Remote Device received. name: " + ((remoteDevice == null) ? "unknown" : remoteDevice.getName()));
            return false;
        }
    // Else second connection to same device, just continue
    }
    if (sendIntent) {
        // This will trigger Settings app's dialog.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setPackage(getString(R.string.pairing_ui_package));
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_MESSAGE_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, sRemoteDevice);
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE) {
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        }
    // Queue USER_TIMEOUT to disconnect MAP OBEX session. If user doesn't
    // accept or reject authorization request
    } else if (cancelConnection) {
        sendConnectCancelMessage();
    } else if (mPermission == BluetoothDevice.ACCESS_ALLOWED) {
        // Signal to the service that we have a incoming connection.
        sendConnectMessage(masInst.getMasId());
        MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.MAP);
    }
    return true;
}
#end_block

#method_before
public void save() {
    this.updated = new Date();
    ofy().defer().save().entity(this);
}
#method_after
public void save() {
    this.updated = new Date();
    ofy().save().entity(this).now();
}
#end_block

#method_before
public void save() {
    this.updated = new Date();
    ofy().defer().save().entity(this);
}
#method_after
public void save() {
    this.updated = new Date();
    ofy().save().entity(this).now();
}
#end_block

#method_before
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    this.keyFileInputStream = this.getServletContext().getResourceAsStream("/WEB-INF/keys/" + GCS_KEY_FILE);
    Optional<Storage> optionalStorage = GcsHelper.getStorage(this.keyFileInputStream);
    if (optionalStorage.isPresent()) {
        this.storage = optionalStorage.get();
        String datePath = new SimpleDateFormat("yyyy/MM/dd").format(new Date());
        String rootFolder = "suite_result";
        Path pathInfo = Paths.get(rootFolder + "/" + datePath);
        Bucket vtsReportBucket = this.storage.get(GCS_BUCKET_NAME);
        Storage.BlobListOption[] listOptions = new Storage.BlobListOption[] { Storage.BlobListOption.currentDirectory(), Storage.BlobListOption.prefix(pathInfo.toString() + "/") };
        Iterable<Blob> blobIterable = vtsReportBucket.list(listOptions).iterateAll();
        Iterator<Blob> blobIterator = blobIterable.iterator();
        while (blobIterator.hasNext()) {
            Blob blob = blobIterator.next();
            if (blob.isDirectory()) {
                logger.log(Level.INFO, blob.getName() + " directory will be skipped!");
            } else {
                // parsing proto buff file logic start here.
                InputStream blobInputStream = new ByteArrayInputStream(blob.getContent());
            }
        }
    } else {
        logger.log(Level.SEVERE, "Error on getting storage instance!");
    }
}
#method_after
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    logger.log(Level.INFO, "Job Started!!!!!!!!!!!!!");
    Queue queue = QueueFactory.getQueue(QUEUE);
    List<TaskOptions> tasks = new ArrayList<>();
    String fileSeparator = FileSystems.getDefault().getSeparator();
    Date today = new Date();
    String year = new SimpleDateFormat("yyyy").format(today);
    String month = new SimpleDateFormat("MM").format(today);
    String day = new SimpleDateFormat("dd").format(today);
    List<String> pathList = Arrays.asList(GCS_SUITE_TEST_FOLDER_NAME, year, month, day);
    Path pathInfo = Paths.get(String.join(fileSeparator, pathList));
    List<TestSuiteFileEntity> testSuiteFileEntityList = ofy().load().type(TestSuiteFileEntity.class).filter("year", Integer.parseInt(year)).filter("month", Integer.parseInt(month)).filter("day", Integer.parseInt(day)).list();
    List<String> filePathList = testSuiteFileEntityList.stream().map(testSuiteFile -> testSuiteFile.getFilePath()).collect(Collectors.toList());
    Bucket vtsReportBucket = this.storage.get(GCS_BUCKET_NAME);
    Storage.BlobListOption[] listOptions = new Storage.BlobListOption[] { Storage.BlobListOption.prefix(pathInfo.toString() + fileSeparator) };
    Iterable<Blob> blobIterable = vtsReportBucket.list(listOptions).iterateAll();
    Iterator<Blob> blobIterator = blobIterable.iterator();
    while (blobIterator.hasNext()) {
        Blob blob = blobIterator.next();
        if (blob.isDirectory()) {
            logger.log(Level.INFO, blob.getName() + " directory will be skipped!");
        } else {
            if (filePathList.contains(blob.getName())) {
                logger.log(Level.INFO, "filePathList contain => " + blob.getName());
            } else if (blob.getName().endsWith(fileSeparator)) {
                logger.log(Level.INFO, blob.getName() + " endswith slash!");
            } else {
                TaskOptions task = TaskOptions.Builder.withUrl(SUITE_TEST_URL).param("filePath", blob.getName()).method(TaskOptions.Method.POST);
                tasks.add(task);
            }
        }
    }
    TaskQueueHelper.addToQueue(queue, tasks);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mContext = InstrumentationRegistry.getContext();
    MockitoAnnotations.initMocks(this);
    when(mMetricsService.defaultNetworkMetrics()).thenReturn(mDefaultNetworkMetrics);
    // http://b/25897652 .
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mServiceContext = new MockContext(InstrumentationRegistry.getContext());
    LocalServices.removeServiceForTest(NetworkPolicyManagerInternal.class);
    LocalServices.addService(NetworkPolicyManagerInternal.class, mock(NetworkPolicyManagerInternal.class));
    mService = new WrappedConnectivityService(mServiceContext, mNetworkManagementService, mStatsService, mock(INetworkPolicyManager.class), mock(IpConnectivityLog.class));
    mService.systemReady();
    mCm = new WrappedConnectivityManager(InstrumentationRegistry.getContext(), mService);
    mCm.bindProcessToNetwork(null);
    // Ensure that the default setting for Captive Portals is used for most tests
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT);
    setMobileDataAlwaysOn(false);
}
#method_after
@Before
public void setUp() throws Exception {
    mContext = InstrumentationRegistry.getContext();
    MockitoAnnotations.initMocks(this);
    when(mMetricsService.defaultNetworkMetrics()).thenReturn(mDefaultNetworkMetrics);
    // http://b/25897652 .
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mServiceContext = new MockContext(InstrumentationRegistry.getContext());
    LocalServices.removeServiceForTest(NetworkPolicyManagerInternal.class);
    LocalServices.addService(NetworkPolicyManagerInternal.class, mock(NetworkPolicyManagerInternal.class));
    mService = new WrappedConnectivityService(mServiceContext, mNetworkManagementService, mStatsService, mock(INetworkPolicyManager.class), mock(IpConnectivityLog.class));
    mService.systemReady();
    mCm = new WrappedConnectivityManager(InstrumentationRegistry.getContext(), mService);
    mCm.bindProcessToNetwork(null);
    // Ensure that the default setting for Captive Portals is used for most tests
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT);
    setMobileDataAlwaysOn(false);
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OFF, "ignored.example.com");
}
#end_block

#method_before
@Test
public void testLinkPropertiesEnsuresDirectlyConnectedRoutes() {
    final NetworkRequest networkRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(networkRequest, networkCallback);
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan0");
    LinkAddress myIpv4Address = new LinkAddress("192.168.12.3/24");
    RouteInfo myIpv4DefaultRoute = new RouteInfo((IpPrefix) null, NetworkUtils.numericToInetAddress("192.168.12.1"), lp.getInterfaceName());
    lp.addLinkAddress(myIpv4Address);
    lp.addRoute(myIpv4DefaultRoute);
    // Verify direct routes are added when network agent is first registered in
    // ConnectivityService.
    MockNetworkAgent networkAgent = new MockNetworkAgent(TRANSPORT_WIFI, lp);
    networkAgent.connect(true);
    networkCallback.expectCallback(CallbackState.AVAILABLE, networkAgent);
    networkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, networkAgent);
    CallbackInfo cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    checkDirectlyConnectedRoutes(mCm.getLinkProperties(networkAgent.getNetwork()), Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    // Verify direct routes are added during subsequent link properties updates.
    LinkProperties newLp = new LinkProperties(lp);
    LinkAddress myIpv6Address1 = new LinkAddress("fe80::cafe/64");
    LinkAddress myIpv6Address2 = new LinkAddress("2001:db8::2/64");
    newLp.addLinkAddress(myIpv6Address1);
    newLp.addLinkAddress(myIpv6Address2);
    networkAgent.sendLinkProperties(newLp);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address, myIpv6Address1, myIpv6Address2), Arrays.asList(myIpv4DefaultRoute));
    mCm.unregisterNetworkCallback(networkCallback);
}
#method_after
@Test
public void testLinkPropertiesEnsuresDirectlyConnectedRoutes() {
    final NetworkRequest networkRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(networkRequest, networkCallback);
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(WIFI_IFNAME);
    LinkAddress myIpv4Address = new LinkAddress("192.168.12.3/24");
    RouteInfo myIpv4DefaultRoute = new RouteInfo((IpPrefix) null, NetworkUtils.numericToInetAddress("192.168.12.1"), lp.getInterfaceName());
    lp.addLinkAddress(myIpv4Address);
    lp.addRoute(myIpv4DefaultRoute);
    // Verify direct routes are added when network agent is first registered in
    // ConnectivityService.
    MockNetworkAgent networkAgent = new MockNetworkAgent(TRANSPORT_WIFI, lp);
    networkAgent.connect(true);
    networkCallback.expectCallback(CallbackState.AVAILABLE, networkAgent);
    networkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, networkAgent);
    CallbackInfo cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    checkDirectlyConnectedRoutes(mCm.getLinkProperties(networkAgent.getNetwork()), Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    // Verify direct routes are added during subsequent link properties updates.
    LinkProperties newLp = new LinkProperties(lp);
    LinkAddress myIpv6Address1 = new LinkAddress("fe80::cafe/64");
    LinkAddress myIpv6Address2 = new LinkAddress("2001:db8::2/64");
    newLp.addLinkAddress(myIpv6Address1);
    newLp.addLinkAddress(myIpv6Address2);
    networkAgent.sendLinkProperties(newLp);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address, myIpv6Address1, myIpv6Address2), Arrays.asList(myIpv4DefaultRoute));
    mCm.unregisterNetworkCallback(networkCallback);
}
#end_block

#method_before
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mNetworkManagementService, never()).setDnsConfigurationForNetwork(anyInt(), any(), any(), any(), anyBoolean(), anyString());
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName("test_rmnet_data0");
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyBoolean(), anyString());
    // CS tells netd about the empty DNS config for this network.
    assertEmpty(mStringArrayCaptor.getValue());
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyBoolean(), anyString());
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "2001:db8::1"));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, times(1)).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), anyBoolean(), anyString());
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
}
#method_after
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    ArgumentCaptor<String[]> tlsServers = ArgumentCaptor.forClass(String[].class);
    // Clear any interactions that occur as a result of CS starting up.
    reset(mNetworkManagementService);
    final String[] EMPTY_STRING_ARRAY = new String[0];
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mNetworkManagementService, never()).setDnsConfigurationForNetwork(anyInt(), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY));
    verifyNoMoreInteractions(mNetworkManagementService);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), MOBILE_IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    // CS tells netd about the empty DNS config for this network.
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture());
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "2001:db8::1"));
    // Opportunistic mode.
    assertTrue(ArrayUtils.contains(tlsServers.getValue(), "2001:db8::1"));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture());
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    // Opportunistic mode.
    assertEquals(2, tlsServers.getValue().length);
    assertTrue(ArrayUtils.containsAll(tlsServers.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
    final String TLS_SPECIFIER = "tls.example.com";
    final String TLS_SERVER6 = "2001:db8:53::53";
    final InetAddress[] TLS_IPS = new InetAddress[] { InetAddress.getByName(TLS_SERVER6) };
    final String[] TLS_SERVERS = new String[] { TLS_SERVER6 };
    final Handler h = mCellNetworkAgent.getWrappedNetworkMonitor().connectivityHandler;
    h.sendMessage(h.obtainMessage(NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED, 0, mCellNetworkAgent.getNetwork().netId, new DnsManager.PrivateDnsConfig(TLS_SPECIFIER, TLS_IPS)));
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(TLS_SPECIFIER), eq(TLS_SERVERS));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
}
#end_block

#method_before
@Test
public void testLinkPropertiesWithPrivateDnsValidationEvents() throws Exception {
    final NetworkRequest networkRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(networkRequest, networkCallback);
    LinkProperties lp = new LinkProperties();
    MockNetworkAgent networkAgent = new MockNetworkAgent(TRANSPORT_WIFI, lp);
    networkAgent.connect(true);
    networkCallback.expectCallback(CallbackState.AVAILABLE, networkAgent);
    networkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, networkAgent);
    CallbackInfo cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, networkAgent);
    networkCallback.assertNoCallback();
    // The private dns fields in LinkProperties should reflect that we
    // are in the default opportunistic mode and have no validated servers.
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    Set<InetAddress> dnsServers = new HashSet<>();
    checkDnsServers(cbi.arg, dnsServers);
    // Send a validation event for a server that is not part of the current
    // resolver config. The validation event should be ignored.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(networkAgent.getNetwork().netId, "", "145.100.185.18", true);
    networkCallback.assertNoCallback();
    // Add a dns server to the LinkProperties.
    LinkProperties lp2 = new LinkProperties(lp);
    lp2.addDnsServer(InetAddress.getByName("145.100.185.16"));
    networkAgent.sendLinkProperties(lp2);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    dnsServers.add(InetAddress.getByName("145.100.185.16"));
    checkDnsServers(cbi.arg, dnsServers);
    // Send a validation event containing a hostname that is not part of
    // the current resolver config. The validation event should be ignored.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(networkAgent.getNetwork().netId, "145.100.185.16", "hostname", true);
    networkCallback.assertNoCallback();
    // Send a validation event where validation failed.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(networkAgent.getNetwork().netId, "145.100.185.16", "", false);
    networkCallback.assertNoCallback();
    // Send a validation event where validation succeeded for a server in
    // the current resolver config. A LinkProperties callback with updated
    // private dns fields should be sent.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(networkAgent.getNetwork().netId, "145.100.185.16", "", true);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    assertTrue(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    checkDnsServers(cbi.arg, dnsServers);
    // The private dns fields in LinkProperties should be preserved when
    // the network agent sends unrelated changes.
    LinkProperties lp3 = new LinkProperties(lp2);
    lp3.setMtu(1300);
    networkAgent.sendLinkProperties(lp3);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    assertTrue(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    checkDnsServers(cbi.arg, dnsServers);
    assertEquals(1300, ((LinkProperties) cbi.arg).getMtu());
    // Removing the only validated server should affect the private dns
    // fields in LinkProperties.
    LinkProperties lp4 = new LinkProperties(lp3);
    lp4.removeDnsServer(InetAddress.getByName("145.100.185.16"));
    networkAgent.sendLinkProperties(lp4);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    dnsServers.remove(InetAddress.getByName("145.100.185.16"));
    checkDnsServers(cbi.arg, dnsServers);
    assertEquals(1300, ((LinkProperties) cbi.arg).getMtu());
}
#method_after
@Test
public void testLinkPropertiesWithPrivateDnsValidationEvents() throws Exception {
    // The default on Android is opportunistic mode ("Automatic").
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    final TestNetworkCallback cellNetworkCallback = new TestNetworkCallback();
    final NetworkRequest cellRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_CELLULAR).build();
    mCm.requestNetwork(cellRequest, cellNetworkCallback);
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    LinkProperties lp = new LinkProperties();
    mCellNetworkAgent.sendLinkProperties(lp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    cellNetworkCallback.expectCallback(CallbackState.AVAILABLE, mCellNetworkAgent);
    cellNetworkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, mCellNetworkAgent);
    CallbackInfo cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    Set<InetAddress> dnsServers = new HashSet<>();
    checkDnsServers(cbi.arg, dnsServers);
    // Send a validation event for a server that is not part of the current
    // resolver config. The validation event should be ignored.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(mCellNetworkAgent.getNetwork().netId, "", "145.100.185.18", true);
    cellNetworkCallback.assertNoCallback();
    // Add a dns server to the LinkProperties.
    LinkProperties lp2 = new LinkProperties(lp);
    lp2.addDnsServer(InetAddress.getByName("145.100.185.16"));
    mCellNetworkAgent.sendLinkProperties(lp2);
    cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    dnsServers.add(InetAddress.getByName("145.100.185.16"));
    checkDnsServers(cbi.arg, dnsServers);
    // Send a validation event containing a hostname that is not part of
    // the current resolver config. The validation event should be ignored.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(mCellNetworkAgent.getNetwork().netId, "145.100.185.16", "hostname", true);
    cellNetworkCallback.assertNoCallback();
    // Send a validation event where validation failed.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(mCellNetworkAgent.getNetwork().netId, "145.100.185.16", "", false);
    cellNetworkCallback.assertNoCallback();
    // Send a validation event where validation succeeded for a server in
    // the current resolver config. A LinkProperties callback with updated
    // private dns fields should be sent.
    mService.mNetdEventCallback.onPrivateDnsValidationEvent(mCellNetworkAgent.getNetwork().netId, "145.100.185.16", "", true);
    cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertTrue(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    checkDnsServers(cbi.arg, dnsServers);
    // The private dns fields in LinkProperties should be preserved when
    // the network agent sends unrelated changes.
    LinkProperties lp3 = new LinkProperties(lp2);
    lp3.setMtu(1300);
    mCellNetworkAgent.sendLinkProperties(lp3);
    cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertTrue(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    checkDnsServers(cbi.arg, dnsServers);
    assertEquals(1300, ((LinkProperties) cbi.arg).getMtu());
    // Removing the only validated server should affect the private dns
    // fields in LinkProperties.
    LinkProperties lp4 = new LinkProperties(lp3);
    lp4.removeDnsServer(InetAddress.getByName("145.100.185.16"));
    mCellNetworkAgent.sendLinkProperties(lp4);
    cbi = cellNetworkCallback.expectCallback(CallbackState.LINK_PROPERTIES, mCellNetworkAgent);
    cellNetworkCallback.assertNoCallback();
    assertFalse(((LinkProperties) cbi.arg).isPrivateDnsActive());
    assertNull(((LinkProperties) cbi.arg).getPrivateDnsServerName());
    dnsServers.remove(InetAddress.getByName("145.100.185.16"));
    checkDnsServers(cbi.arg, dnsServers);
    assertEquals(1300, ((LinkProperties) cbi.arg).getMtu());
}
#end_block

#method_before
public static PrivateDnsConfig tryBlockingResolveOf(Network network, String name) {
    final StructAddrinfo hints = new StructAddrinfo();
    // Unnecessary, but expressly no AI_ADDRCONFIG.
    hints.ai_flags = 0;
    // Fetch all IP addresses at once to minimize re-resolution.
    hints.ai_family = OsConstants.AF_UNSPEC;
    hints.ai_socktype = OsConstants.SOCK_DGRAM;
    try {
        final InetAddress[] ips = Libcore.os.android_getaddrinfo(name, hints, network.netId);
        if (ips != null && ips.length > 0) {
            return new PrivateDnsConfig(name, ips);
        }
    } catch (GaiException ignored) {
    }
    return null;
}
#method_after
public static PrivateDnsConfig tryBlockingResolveOf(Network network, String name) {
    try {
        final InetAddress[] ips = ResolvUtil.blockingResolveAllLocally(network, name);
        return new PrivateDnsConfig(name, ips);
    } catch (UnknownHostException uhe) {
        return new PrivateDnsConfig(name, null);
    }
}
#end_block

#method_before
public static Uri[] getPrivateDnsSettingsUris() {
    final Uri[] uris = new Uri[2];
    uris[0] = Settings.Global.getUriFor(PRIVATE_DNS_MODE);
    uris[1] = Settings.Global.getUriFor(PRIVATE_DNS_SPECIFIER);
    return uris;
}
#method_after
public static Uri[] getPrivateDnsSettingsUris() {
    return new Uri[] { Settings.Global.getUriFor(PRIVATE_DNS_MODE), Settings.Global.getUriFor(PRIVATE_DNS_SPECIFIER) };
}
#end_block

#method_before
private void updateStatus(InetAddress ipAddress, String hostname, boolean validated) {
    Pair<String, InetAddress> p = new Pair(hostname, ipAddress);
    if (!mValidationMap.containsKey(p)) {
        return;
    }
    if (validated) {
        mValidationMap.put(p, ValidationStatus.SUCCEEDED);
    } else {
        mValidationMap.put(p, ValidationStatus.FAILED);
    }
}
#method_after
private void updateStatus(PrivateDnsValidationUpdate update) {
    Pair<String, InetAddress> p = new Pair(update.hostname, update.ipAddress);
    if (!mValidationMap.containsKey(p)) {
        return;
    }
    if (update.validated) {
        mValidationMap.put(p, ValidationStatus.SUCCEEDED);
    } else {
        mValidationMap.put(p, ValidationStatus.FAILED);
    }
}
#end_block

#method_before
public PrivateDnsConfig updatePrivateDns(Network network, PrivateDnsConfig cfg) {
    Slog.w(TAG, "updatePrivateDns(" + network + ", " + cfg + ")");
    return (cfg != null) ? mPrivateDnsMap.put(network.netId, cfg) : mPrivateDnsMap.remove(network);
}
#method_after
public PrivateDnsConfig updatePrivateDns(Network network, PrivateDnsConfig cfg) {
    Slog.w(TAG, "updatePrivateDns(" + network + ", " + cfg + ")");
    return (cfg != null) ? mPrivateDnsMap.put(network.netId, cfg) : mPrivateDnsMap.remove(network.netId);
}
#end_block

#method_before
public void updatePrivateDnsValidation(PrivateDnsValidationUpdate update) {
    if (!mPrivateDnsValidationMap.containsKey(update.netId)) {
        // Ignore validation updates for netIds that are not being tracked.
        return;
    }
    mPrivateDnsValidationMap.get(update.netId).updateStatus(update.ipAddress, update.hostname, update.validated);
}
#method_after
public void updatePrivateDnsValidation(PrivateDnsValidationUpdate update) {
    final PrivateDnsValidationStatuses statuses = mPrivateDnsValidationMap.get(update.netId);
    if (statuses == null)
        return;
    statuses.updateStatus(update);
}
#end_block

#method_before
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.get(netId);
    final boolean useTls = (privateDnsCfg != null) && privateDnsCfg.useTls;
    final boolean strictMode = (privateDnsCfg != null) && privateDnsCfg.inStrictMode();
    final String tlsHostname = strictMode ? privateDnsCfg.hostname : "";
    final String[] serverStrs = NetworkUtils.makeStrings(strictMode ? Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList()) : lp.getDnsServers());
    // resolver config when private DNS is in opportunistic or strict mode.
    if (useTls) {
        if (!mPrivateDnsValidationMap.containsKey(netId)) {
            mPrivateDnsValidationMap.put(netId, new PrivateDnsValidationStatuses());
        }
        mPrivateDnsValidationMap.get(netId).updateTrackedDnses(serverStrs, tlsHostname);
    } else {
        mPrivateDnsValidationMap.remove(netId);
    }
    final String[] domainStrs = getDomainStrings(lp.getDomains());
    updateParametersSettings();
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %s, %s, %s)", netId, Arrays.toString(serverStrs), Arrays.toString(domainStrs), Arrays.toString(params), useTls, tlsHostname));
    try {
        mNMS.setDnsConfigurationForNetwork(netId, serverStrs, domainStrs, params, useTls, tlsHostname);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#method_after
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    final String[] assignedServers = NetworkUtils.makeStrings(lp.getDnsServers());
    final String[] domainStrs = getDomainStrings(lp.getDomains());
    updateParametersSettings();
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do not attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.getOrDefault(netId, PRIVATE_DNS_OFF);
    final boolean useTls = privateDnsCfg.useTls;
    final boolean strictMode = privateDnsCfg.inStrictMode();
    final String tlsHostname = strictMode ? privateDnsCfg.hostname : "";
    final String[] tlsServers = strictMode ? NetworkUtils.makeStrings(Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList())) : // Opportunistic
    useTls ? // Opportunistic
    assignedServers : // Off
    new String[0];
    // resolver config when private DNS is in opportunistic or strict mode.
    if (useTls) {
        if (!mPrivateDnsValidationMap.containsKey(netId)) {
            mPrivateDnsValidationMap.put(netId, new PrivateDnsValidationStatuses());
        }
        mPrivateDnsValidationMap.get(netId).updateTrackedDnses(tlsServers, tlsHostname);
    } else {
        mPrivateDnsValidationMap.remove(netId);
    }
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %s, %s, %s)", netId, Arrays.toString(assignedServers), Arrays.toString(domainStrs), Arrays.toString(params), tlsHostname, Arrays.toString(tlsServers)));
    try {
        mNMS.setDnsConfigurationForNetwork(netId, assignedServers, domainStrs, params, tlsHostname, tlsServers);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#end_block

#method_before
@Test
public void testTrackedValidationUpdates() throws Exception {
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.updatePrivateDns(new Network(TEST_NETID_ALTERNATE), mDnsManager.getPrivateDnsConfig());
    LinkProperties lp = new LinkProperties();
    lp.addDnsServer(InetAddress.getByName("3.3.3.3"));
    lp.addDnsServer(InetAddress.getByName("4.4.4.4"));
    // Send a validation event that is tracked on the alternate netId
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, true);
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID_ALTERNATE, lp, true);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID_ALTERNATE, InetAddress.parseNumericAddress("4.4.4.4"), "", true));
    LinkProperties fixedLp = new LinkProperties(lp);
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, fixedLp));
    assertFalse(fixedLp.isPrivateDnsActive());
    assertNull(fixedLp.getPrivateDnsServerName());
    fixedLp = new LinkProperties(lp);
    assertTrue(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID_ALTERNATE, fixedLp));
    assertTrue(fixedLp.isPrivateDnsActive());
    assertNull(fixedLp.getPrivateDnsServerName());
    // Switch to strict mode
    Settings.Global.putString(mContentResolver, Settings.Global.PRIVATE_DNS_MODE, PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
    Settings.Global.putString(mContentResolver, Settings.Global.PRIVATE_DNS_SPECIFIER, "strictmode.com");
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, true);
    fixedLp = new LinkProperties(lp);
    assertTrue(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, fixedLp));
    assertTrue(fixedLp.isPrivateDnsActive());
    assertEquals("strictmode.com", fixedLp.getPrivateDnsServerName());
    fixedLp = new LinkProperties(lp);
}
#method_after
@Test
public void testTrackedValidationUpdates() throws Exception {
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.updatePrivateDns(new Network(TEST_NETID_ALTERNATE), mDnsManager.getPrivateDnsConfig());
    LinkProperties lp = new LinkProperties();
    lp.addDnsServer(InetAddress.getByName("3.3.3.3"));
    lp.addDnsServer(InetAddress.getByName("4.4.4.4"));
    // Send a validation event that is tracked on the alternate netId
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, IS_DEFAULT);
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID_ALTERNATE, lp, NOT_DEFAULT);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID_ALTERNATE, InetAddress.parseNumericAddress("4.4.4.4"), "", true));
    LinkProperties fixedLp = new LinkProperties(lp);
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, fixedLp);
    assertFalse(fixedLp.isPrivateDnsActive());
    assertNull(fixedLp.getPrivateDnsServerName());
    fixedLp = new LinkProperties(lp);
    mDnsManager.updatePrivateDnsStatus(TEST_NETID_ALTERNATE, fixedLp);
    assertTrue(fixedLp.isPrivateDnsActive());
    assertNull(fixedLp.getPrivateDnsServerName());
    // Switch to strict mode
    Settings.Global.putString(mContentResolver, Settings.Global.PRIVATE_DNS_MODE, PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
    Settings.Global.putString(mContentResolver, Settings.Global.PRIVATE_DNS_SPECIFIER, "strictmode.com");
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, IS_DEFAULT);
    fixedLp = new LinkProperties(lp);
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, fixedLp);
    assertTrue(fixedLp.isPrivateDnsActive());
    assertEquals("strictmode.com", fixedLp.getPrivateDnsServerName());
    fixedLp = new LinkProperties(lp);
}
#end_block

#method_before
@Test
public void testIgnoreUntrackedValidationUpdates() throws Exception {
    // The PrivateDnsConfig map is empty, so no validation events will
    // be tracked.
    LinkProperties lp = new LinkProperties();
    lp.addDnsServer(InetAddress.getByName("3.3.3.3"));
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, true);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, lp));
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event has untracked netId
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, true);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID_UNTRACKED, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, lp));
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event has untracked ipAddress
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("4.4.4.4"), "", true));
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, lp));
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event has untracked hostname
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "hostname", true));
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, lp));
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event failed
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", false));
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, lp));
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Network removed
    mDnsManager.removeNetwork(new Network(TEST_NETID));
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, lp));
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Turn private DNS mode off
    Settings.Global.putString(mContentResolver, Settings.Global.PRIVATE_DNS_MODE, PRIVATE_DNS_MODE_OFF);
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, true);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    assertFalse(mDnsManager.maybeFixLinkPropertiesPrivateDns(TEST_NETID, lp));
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
}
#method_after
@Test
public void testIgnoreUntrackedValidationUpdates() throws Exception {
    // The PrivateDnsConfig map is empty, so no validation events will
    // be tracked.
    LinkProperties lp = new LinkProperties();
    lp.addDnsServer(InetAddress.getByName("3.3.3.3"));
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, IS_DEFAULT);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, lp);
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event has untracked netId
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, IS_DEFAULT);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID_UNTRACKED, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, lp);
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event has untracked ipAddress
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("4.4.4.4"), "", true));
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, lp);
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event has untracked hostname
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "hostname", true));
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, lp);
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Validation event failed
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", false));
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, lp);
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Network removed
    mDnsManager.removeNetwork(new Network(TEST_NETID));
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, lp);
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
    // Turn private DNS mode off
    Settings.Global.putString(mContentResolver, Settings.Global.PRIVATE_DNS_MODE, PRIVATE_DNS_MODE_OFF);
    mDnsManager.updatePrivateDns(new Network(TEST_NETID), mDnsManager.getPrivateDnsConfig());
    mDnsManager.setDnsConfigurationForNetwork(TEST_NETID, lp, IS_DEFAULT);
    mDnsManager.updatePrivateDnsValidation(new DnsManager.PrivateDnsValidationUpdate(TEST_NETID, InetAddress.parseNumericAddress("3.3.3.3"), "", true));
    mDnsManager.updatePrivateDnsStatus(TEST_NETID, lp);
    assertFalse(lp.isPrivateDnsActive());
    assertNull(lp.getPrivateDnsServerName());
}
#end_block

#method_before
private Tethering makeTethering() {
    // TODO: Move other elements into @Overridden getters.
    final TetheringDependencies deps = new TetheringDependencies();
    return new Tethering(mContext, mNetd, mStatsService, mPolicyManager, IoThread.get().getLooper(), new MockableSystemProperties(), deps);
}
#method_after
private Tethering makeTethering() {
    // TODO: Move other elements into @Overridden getters.
    final TetheringDependencies deps = new TetheringDependencies() {

        @Override
        public boolean isTetheringSupported() {
            return ConnectivityService.this.isTetheringSupported();
        }
    };
    return new Tethering(mContext, mNetd, mStatsService, mPolicyManager, IoThread.get().getLooper(), new MockableSystemProperties(), deps);
}
#end_block

#method_before
// Used only for testing.
// TODO: Delete this and either:
// 1. Give Fake SettingsProvider the ability to send settings change notifications (requires
// changing ContentResolver to make registerContentObserver non-final).
// 2. Give FakeSettingsProvider an alternative notification mechanism and have the test use it
@VisibleForTesting
void updateMobileDataAlwaysOn() {
    mHandler.sendEmptyMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON);
}
#method_after
// Used only for testing.
// TODO: Delete this and either:
// 1. Give FakeSettingsProvider the ability to send settings change notifications (requires
// changing ContentResolver to make registerContentObserver non-final).
// 2. Give FakeSettingsProvider an alternative notification mechanism and have the test use it
@VisibleForTesting
void updateMobileDataAlwaysOn() {
    mHandler.sendEmptyMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON);
}
#end_block

#method_before
private void registerPrivateDnsSettingsCallbacks() {
    for (Uri u : DnsManager.getPrivateDnsSettingsUris()) {
        mSettingsObserver.observe(u, EVENT_PRIVATE_DNS_SETTINGS_CHANGED);
    }
}
#method_after
private void registerPrivateDnsSettingsCallbacks() {
    for (Uri uri : DnsManager.getPrivateDnsSettingsUris()) {
        mSettingsObserver.observe(uri, EVENT_PRIVATE_DNS_SETTINGS_CHANGED);
    }
}
#end_block

#method_before
private NetworkAgentInfo getNetworkAgentInfoForNetwork(Network network) {
    if (network == null) {
        return null;
    }
    synchronized (mNetworkForNetId) {
        return mNetworkForNetId.get(network.netId);
    }
}
#method_after
private NetworkAgentInfo getNetworkAgentInfoForNetwork(Network network) {
    if (network == null) {
        return null;
    }
    return getNetworkAgentInfoForNetId(network.netId);
}
#end_block

#method_before
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        synchronized (mNetworkForNetId) {
            nai = mNetworkForNetId.get(vpnNetId);
        }
        if (nai != null)
            return nai.network;
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#method_after
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        nai = getNetworkAgentInfoForNetId(vpnNetId);
        if (nai != null)
            return nai.network;
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#end_block

#method_before
@VisibleForTesting
protected void registerNetdEventCallback() {
    mIpConnectivityMetrics = checkNotNull((IIpConnectivityMetrics) IIpConnectivityMetrics.Stub.asInterface(ServiceManager.getService(IpConnectivityLog.SERVICE_NAME)), "missing IIpConnectivityMetrics");
    try {
        mIpConnectivityMetrics.addNetdEventCallback(INetdEventCallback.CALLBACK_CALLER_CONNECTIVITY_SERVICE, mNetdEventCallback);
    } catch (RemoteException e) {
        loge("Error registering netd callback :" + e);
    }
}
#method_after
@VisibleForTesting
protected void registerNetdEventCallback() {
    mIpConnectivityMetrics = (IIpConnectivityMetrics) IIpConnectivityMetrics.Stub.asInterface(ServiceManager.getService(IpConnectivityLog.SERVICE_NAME));
    if (mIpConnectivityMetrics == null) {
        Slog.wtf(TAG, "Missing IIpConnectivityMetrics");
    }
    try {
        mIpConnectivityMetrics.addNetdEventCallback(INetdEventCallback.CALLBACK_CALLER_CONNECTIVITY_SERVICE, mNetdEventCallback);
    } catch (Exception e) {
        loge("Error registering netd callback: " + e);
    }
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(msg.arg2);
                }
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final PrivateDnsConfig privateDnsCfg = (msg.obj instanceof PrivateDnsConfig) ? (PrivateDnsConfig) msg.obj : null;
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                final boolean reevaluationRequired;
                final String logMsg;
                if (valid) {
                    reevaluationRequired = updatePrivateDns(nai, privateDnsCfg);
                    logMsg = (DBG && (privateDnsCfg != null)) ? " with " + privateDnsCfg.toString() : "";
                } else {
                    reevaluationRequired = false;
                    logMsg = (DBG && !TextUtils.isEmpty(redirectUrl)) ? " with redirect to " + redirectUrl : "";
                }
                if (DBG) {
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                // trigger reevaluation of the network to test it.
                if (reevaluationRequired) {
                    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, Process.SYSTEM_UID);
                    break;
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(netId);
                }
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(msg.arg2);
                }
                if (nai == null)
                    break;
                final PrivateDnsConfig cfg = (PrivateDnsConfig) msg.obj;
                final boolean reevaluationRequired = updatePrivateDns(nai, cfg);
                if (nai.lastValidated && reevaluationRequired) {
                    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, Process.SYSTEM_UID);
                }
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#end_block

#method_before
@VisibleForTesting
protected void handlePrivateDnsSettingsChanged() {
    final PrivateDnsConfig cfg = mDnsManager.getPrivateDnsConfig();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        // Internet access and therefore also require validation.
        if (!NetworkMonitor.isValidationRequired(mDefaultRequest.networkCapabilities, nai.networkCapabilities)) {
            continue;
        }
        // Notify the NetworkMonitor thread in case it needs to cancel or
        // schedule DNS resolutions. If a DNS resolution is required the
        // result will be sent back to us.
        nai.networkMonitor.notifyPrivateDnsSettingsChanged(cfg);
        if (!cfg.inStrictMode()) {
            // No strict mode hostname DNS resolution needed, so just update
            // DNS settings directly. In opportunistic and "off" modes this
            // just reprograms netd with the network-supplied DNS servers
            // (and of course the boolean of whether or not to attempt TLS).
            // 
            // TODO: Consider code flow parity with strict mode, i.e. having
            // NetworkMonitor relay the PrivateDnsConfig back to us and then
            // performing this call at that time.
            updatePrivateDns(nai, cfg);
        }
    }
}
#method_after
private void handlePrivateDnsSettingsChanged() {
    final PrivateDnsConfig cfg = mDnsManager.getPrivateDnsConfig();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        handlePerNetworkPrivateDnsConfig(nai, cfg);
        if (networkRequiresValidation(nai)) {
            handleUpdateLinkProperties(nai, new LinkProperties(nai.linkProperties));
        }
    }
}
#end_block

#method_before
private boolean updatePrivateDns(NetworkAgentInfo nai, PrivateDnsConfig newCfg) {
    final boolean reevaluationRequired = true;
    final boolean dontReevaluate = false;
    final PrivateDnsConfig oldCfg = mDnsManager.updatePrivateDns(nai.network, newCfg);
    // Both the dns and private dns fields in LinkProperties may need to be
    // updated. The dns update needs to be forced by using null as the old
    // LinkProperties in case the dns servers don't actually change but the
    // private dns settings do. We can't use null for handleUpdateLinkProperties
    // because we need to be able to pull in old clatd settings.
    updateDnses(nai.linkProperties, null, nai.network.netId);
    if (mDnsManager.maybeFixLinkPropertiesPrivateDns(nai.network.netId, new LinkProperties(nai.linkProperties))) {
        handleUpdateLinkProperties(nai, new LinkProperties(nai.linkProperties));
    }
    if (newCfg == null) {
        if (oldCfg == null)
            return dontReevaluate;
        return oldCfg.useTls ? reevaluationRequired : dontReevaluate;
    }
    if (oldCfg == null) {
        return newCfg.useTls ? reevaluationRequired : dontReevaluate;
    }
    if (oldCfg.useTls != newCfg.useTls) {
        return reevaluationRequired;
    }
    if (newCfg.inStrictMode() && !Objects.equals(oldCfg.hostname, newCfg.hostname)) {
        return reevaluationRequired;
    }
    return dontReevaluate;
}
#method_after
private void updatePrivateDns(NetworkAgentInfo nai, PrivateDnsConfig newCfg) {
    mDnsManager.updatePrivateDns(nai.network, newCfg);
    updateDnses(nai.linkProperties, null, nai.network.netId);
}
#end_block

#method_before
private void handlePrivateDnsValidationUpdate(DnsManager.PrivateDnsValidationUpdate update) {
    mDnsManager.updatePrivateDnsValidation(update);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(new Network(update.netId));
    if (nai == null) {
        return;
    }
    // the validation update, do a proper LinkProperties update.
    if (mDnsManager.maybeFixLinkPropertiesPrivateDns(nai.network.netId, new LinkProperties(nai.linkProperties))) {
        handleUpdateLinkProperties(nai, new LinkProperties(nai.linkProperties));
    }
}
#method_after
private void handlePrivateDnsValidationUpdate(PrivateDnsValidationUpdate update) {
    NetworkAgentInfo nai = getNetworkAgentInfoForNetId(update.netId);
    if (nai == null) {
        return;
    }
    mDnsManager.updatePrivateDnsValidation(update);
    handleUpdateLinkProperties(nai, new LinkProperties(nai.linkProperties));
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((DnsManager.PrivateDnsValidationUpdate) msg.obj);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
    }
}
#end_block

#method_before
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, uid);
}
#method_after
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    nai.networkMonitor.forceReevaluation(uid);
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
    // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
    // onLost and onAvailable callbacks when networks move in and out of the background.
    // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
    // can't request networks.
    restrictBackgroundRequestForCaller(nc);
    ensureValidNetworkSpecifier(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
private void handleRegisterNetworkAgent(NetworkAgentInfo na) {
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(na.messenger, na);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(na.network.netId, na);
    }
    // Initialize the private DNS settings in DnsManager.
    mDnsManager.updatePrivateDns(na.network, mDnsManager.getPrivateDnsConfig());
    na.asyncChannel.connect(mContext, mTrackerHandler, na.messenger);
    NetworkInfo networkInfo = na.networkInfo;
    na.networkInfo = null;
    updateNetworkInfo(na, networkInfo);
    updateUids(na, null, na.networkCapabilities);
}
#method_after
private void handleRegisterNetworkAgent(NetworkAgentInfo nai) {
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    mDnsManager.maybeFixLinkPropertiesPrivateDns(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp, networkAgent);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties oldLp) {
    LinkProperties newLp = networkAgent.linkProperties;
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // TODO - figure out what to do for clat
    // for (LinkProperties lp : newLp.getStackedLinks()) {
    // updateMtu(lp, null);
    // }
    updateTcpBufferSizes(networkAgent);
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    // Start or stop clat accordingly to network state.
    networkAgent.updateClat(mNetd);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp, networkAgent);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        notifyIfacesChangedForNetworkStats();
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (mNetworkForNetId.get(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    LinkProperties oldLp = nai.linkProperties;
    synchronized (nai) {
        nai.linkProperties = newLp;
    }
    if (nai.everConnected) {
        updateLinkProperties(nai, oldLp);
    }
}
#method_after
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    LinkProperties oldLp = nai.linkProperties;
    synchronized (nai) {
        nai.linkProperties = newLp;
    }
    if (nai.everConnected) {
        updateLinkProperties(nai, oldLp);
    }
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        updateLinkProperties(networkAgent, null);
        notifyIfacesChangedForNetworkStats();
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNetd.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNetd.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            synchronized (mProxyLock) {
                if (!mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = true;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(null);
                    }
                }
            }
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            synchronized (mProxyLock) {
                if (mDefaultProxyDisabled) {
                    mDefaultProxyDisabled = false;
                    if (mGlobalProxy == null && mDefaultProxy != null) {
                        sendProxyBroadcast(mDefaultProxy);
                    }
                }
            }
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: rescore and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
public void test_setgroups() throws Exception {
    try {
        Libcore.os.setgroups(new int[] { -1 });
        fail();
    } catch (ErrnoException expected) {
    }
}
#method_after
public void test_setgroups() throws Exception {
    try {
        Libcore.os.setgroups(new int[] { -1 });
        fail();
    } catch (ErrnoException expected) {
        assertEquals(EPERM, expected.errno);
    }
}
#end_block

#method_before
@Test
public void testApfFilterIPv4() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    LinkAddress link = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 19);
    LinkProperties lp = new LinkProperties();
    lp.addLinkAddress(link);
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    TestApfFilter apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty packet of 100 zero bytes is passed
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    assertPass(program, packet.array());
    // Verify unicast IPv4 packet is passed
    put(packet, ETH_DEST_ADDR_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_IPV4_ADDR);
    assertPass(program, packet.array());
    // Verify L2 unicast to IPv4 broadcast addresses is dropped (b/30231088)
    put(packet, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_BROADCAST_IPV4_ADDR);
    assertDrop(program, packet.array());
    // Verify multicast/broadcast IPv4, not DHCP to us, is dropped
    put(packet, ETH_DEST_ADDR_OFFSET, ETH_BROADCAST_MAC_ADDRESS);
    assertDrop(program, packet.array());
    packet.put(IPV4_VERSION_IHL_OFFSET, (byte) 0x45);
    assertDrop(program, packet.array());
    packet.put(IPV4_PROTOCOL_OFFSET, (byte) IPPROTO_UDP);
    assertDrop(program, packet.array());
    packet.putShort(UDP_DESTINATION_PORT_OFFSET, (short) DHCP_CLIENT_PORT);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_MULTICAST_IPV4_ADDR);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_BROADCAST_IPV4_ADDR);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
    assertDrop(program, packet.array());
    // Verify broadcast IPv4 DHCP to us is passed
    put(packet, DHCP_CLIENT_MAC_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
    assertPass(program, packet.array());
    // Verify unicast IPv4 DHCP to us is passed
    put(packet, ETH_DEST_ADDR_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
    assertPass(program, packet.array());
    apfFilter.shutdown();
}
#method_after
@Test
public void testApfFilterIPv4() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    LinkAddress link = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 19);
    LinkProperties lp = new LinkProperties();
    lp.addLinkAddress(link);
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    TestApfFilter apfFilter = new TestApfFilter(mContext, config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty packet of 100 zero bytes is passed
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    assertPass(program, packet.array());
    // Verify unicast IPv4 packet is passed
    put(packet, ETH_DEST_ADDR_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_IPV4_ADDR);
    assertPass(program, packet.array());
    // Verify L2 unicast to IPv4 broadcast addresses is dropped (b/30231088)
    put(packet, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_BROADCAST_IPV4_ADDR);
    assertDrop(program, packet.array());
    // Verify multicast/broadcast IPv4, not DHCP to us, is dropped
    put(packet, ETH_DEST_ADDR_OFFSET, ETH_BROADCAST_MAC_ADDRESS);
    assertDrop(program, packet.array());
    packet.put(IPV4_VERSION_IHL_OFFSET, (byte) 0x45);
    assertDrop(program, packet.array());
    packet.put(IPV4_PROTOCOL_OFFSET, (byte) IPPROTO_UDP);
    assertDrop(program, packet.array());
    packet.putShort(UDP_DESTINATION_PORT_OFFSET, (short) DHCP_CLIENT_PORT);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_MULTICAST_IPV4_ADDR);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, MOCK_BROADCAST_IPV4_ADDR);
    assertDrop(program, packet.array());
    put(packet, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
    assertDrop(program, packet.array());
    // Verify broadcast IPv4 DHCP to us is passed
    put(packet, DHCP_CLIENT_MAC_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
    assertPass(program, packet.array());
    // Verify unicast IPv4 DHCP to us is passed
    put(packet, ETH_DEST_ADDR_OFFSET, TestApfFilter.MOCK_MAC_ADDR);
    assertPass(program, packet.array());
    apfFilter.shutdown();
}
#end_block

#method_before
@Test
public void testApfFilterIPv6() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    TestApfFilter apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty IPv6 packet is passed
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Verify empty ICMPv6 packet is passed
    packet.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_ICMPV6);
    assertPass(program, packet.array());
    // Verify empty ICMPv6 NA packet is passed
    packet.put(ICMP6_TYPE_OFFSET, (byte) ICMP6_NEIGHBOR_ANNOUNCEMENT);
    assertPass(program, packet.array());
    // Verify ICMPv6 NA to ff02::1 is dropped
    put(packet, IPV6_DEST_ADDR_OFFSET, IPV6_ALL_NODES_ADDRESS);
    assertDrop(program, packet.array());
    // Verify ICMPv6 RS to any is dropped
    packet.put(ICMP6_TYPE_OFFSET, (byte) ICMP6_ROUTER_SOLICITATION);
    assertDrop(program, packet.array());
    put(packet, IPV6_DEST_ADDR_OFFSET, IPV6_ALL_ROUTERS_ADDRESS);
    assertDrop(program, packet.array());
    apfFilter.shutdown();
}
#method_after
@Test
public void testApfFilterIPv6() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    TestApfFilter apfFilter = new TestApfFilter(mContext, config, ipClientCallback, mLog);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty IPv6 packet is passed
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Verify empty ICMPv6 packet is passed
    packet.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_ICMPV6);
    assertPass(program, packet.array());
    // Verify empty ICMPv6 NA packet is passed
    packet.put(ICMP6_TYPE_OFFSET, (byte) ICMP6_NEIGHBOR_ANNOUNCEMENT);
    assertPass(program, packet.array());
    // Verify ICMPv6 NA to ff02::1 is dropped
    put(packet, IPV6_DEST_ADDR_OFFSET, IPV6_ALL_NODES_ADDRESS);
    assertDrop(program, packet.array());
    // Verify ICMPv6 RS to any is dropped
    packet.put(ICMP6_TYPE_OFFSET, (byte) ICMP6_ROUTER_SOLICITATION);
    assertDrop(program, packet.array());
    put(packet, IPV6_DEST_ADDR_OFFSET, IPV6_ALL_ROUTERS_ADDRESS);
    assertDrop(program, packet.array());
    apfFilter.shutdown();
}
#end_block

#method_before
@Test
public void testApfFilterMulticast() throws Exception {
    final byte[] unicastIpv4Addr = { (byte) 192, 0, 2, 63 };
    final byte[] broadcastIpv4Addr = { (byte) 192, 0, 2, (byte) 255 };
    final byte[] multicastIpv4Addr = { (byte) 224, 0, 0, 1 };
    final byte[] multicastIpv6Addr = { (byte) 0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0xfb };
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    LinkAddress link = new LinkAddress(InetAddress.getByAddress(unicastIpv4Addr), 24);
    LinkProperties lp = new LinkProperties();
    lp.addLinkAddress(link);
    ApfConfiguration config = getDefaultConfig();
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    byte[] program = ipClientCallback.getApfProgram();
    // Construct IPv4 and IPv6 multicast packets.
    ByteBuffer mcastv4packet = ByteBuffer.wrap(new byte[100]);
    mcastv4packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(mcastv4packet, IPV4_DEST_ADDR_OFFSET, multicastIpv4Addr);
    ByteBuffer mcastv6packet = ByteBuffer.wrap(new byte[100]);
    mcastv6packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    mcastv6packet.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_UDP);
    put(mcastv6packet, IPV6_DEST_ADDR_OFFSET, multicastIpv6Addr);
    // Construct IPv4 broadcast packet.
    ByteBuffer bcastv4packet1 = ByteBuffer.wrap(new byte[100]);
    bcastv4packet1.put(ETH_BROADCAST_MAC_ADDRESS);
    bcastv4packet1.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(bcastv4packet1, IPV4_DEST_ADDR_OFFSET, multicastIpv4Addr);
    ByteBuffer bcastv4packet2 = ByteBuffer.wrap(new byte[100]);
    bcastv4packet2.put(ETH_BROADCAST_MAC_ADDRESS);
    bcastv4packet2.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(bcastv4packet2, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
    // Construct IPv4 broadcast with L2 unicast address packet (b/30231088).
    ByteBuffer bcastv4unicastl2packet = ByteBuffer.wrap(new byte[100]);
    bcastv4unicastl2packet.put(TestApfFilter.MOCK_MAC_ADDR);
    bcastv4unicastl2packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(bcastv4unicastl2packet, IPV4_DEST_ADDR_OFFSET, broadcastIpv4Addr);
    // Verify initially disabled multicast filter is off
    assertPass(program, mcastv4packet.array());
    assertPass(program, mcastv6packet.array());
    assertPass(program, bcastv4packet1.array());
    assertPass(program, bcastv4packet2.array());
    assertPass(program, bcastv4unicastl2packet.array());
    // Turn on multicast filter and verify it works
    ipClientCallback.resetApfProgramWait();
    apfFilter.setMulticastFilter(true);
    program = ipClientCallback.getApfProgram();
    assertDrop(program, mcastv4packet.array());
    assertDrop(program, mcastv6packet.array());
    assertDrop(program, bcastv4packet1.array());
    assertDrop(program, bcastv4packet2.array());
    assertDrop(program, bcastv4unicastl2packet.array());
    // Turn off multicast filter and verify it's off
    ipClientCallback.resetApfProgramWait();
    apfFilter.setMulticastFilter(false);
    program = ipClientCallback.getApfProgram();
    assertPass(program, mcastv4packet.array());
    assertPass(program, mcastv6packet.array());
    assertPass(program, bcastv4packet1.array());
    assertPass(program, bcastv4packet2.array());
    assertPass(program, bcastv4unicastl2packet.array());
    // Verify it can be initialized to on
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    program = ipClientCallback.getApfProgram();
    assertDrop(program, mcastv4packet.array());
    assertDrop(program, mcastv6packet.array());
    assertDrop(program, bcastv4packet1.array());
    assertDrop(program, bcastv4unicastl2packet.array());
    // Verify that ICMPv6 multicast is not dropped.
    mcastv6packet.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_ICMPV6);
    assertPass(program, mcastv6packet.array());
    apfFilter.shutdown();
}
#method_after
@Test
public void testApfFilterMulticast() throws Exception {
    final byte[] unicastIpv4Addr = { (byte) 192, 0, 2, 63 };
    final byte[] broadcastIpv4Addr = { (byte) 192, 0, 2, (byte) 255 };
    final byte[] multicastIpv4Addr = { (byte) 224, 0, 0, 1 };
    final byte[] multicastIpv6Addr = { (byte) 0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0xfb };
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    LinkAddress link = new LinkAddress(InetAddress.getByAddress(unicastIpv4Addr), 24);
    LinkProperties lp = new LinkProperties();
    lp.addLinkAddress(link);
    ApfConfiguration config = getDefaultConfig();
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(mContext, config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    byte[] program = ipClientCallback.getApfProgram();
    // Construct IPv4 and IPv6 multicast packets.
    ByteBuffer mcastv4packet = ByteBuffer.wrap(new byte[100]);
    mcastv4packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(mcastv4packet, IPV4_DEST_ADDR_OFFSET, multicastIpv4Addr);
    ByteBuffer mcastv6packet = ByteBuffer.wrap(new byte[100]);
    mcastv6packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    mcastv6packet.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_UDP);
    put(mcastv6packet, IPV6_DEST_ADDR_OFFSET, multicastIpv6Addr);
    // Construct IPv4 broadcast packet.
    ByteBuffer bcastv4packet1 = ByteBuffer.wrap(new byte[100]);
    bcastv4packet1.put(ETH_BROADCAST_MAC_ADDRESS);
    bcastv4packet1.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(bcastv4packet1, IPV4_DEST_ADDR_OFFSET, multicastIpv4Addr);
    ByteBuffer bcastv4packet2 = ByteBuffer.wrap(new byte[100]);
    bcastv4packet2.put(ETH_BROADCAST_MAC_ADDRESS);
    bcastv4packet2.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(bcastv4packet2, IPV4_DEST_ADDR_OFFSET, IPV4_BROADCAST_ADDRESS);
    // Construct IPv4 broadcast with L2 unicast address packet (b/30231088).
    ByteBuffer bcastv4unicastl2packet = ByteBuffer.wrap(new byte[100]);
    bcastv4unicastl2packet.put(TestApfFilter.MOCK_MAC_ADDR);
    bcastv4unicastl2packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    put(bcastv4unicastl2packet, IPV4_DEST_ADDR_OFFSET, broadcastIpv4Addr);
    // Verify initially disabled multicast filter is off
    assertPass(program, mcastv4packet.array());
    assertPass(program, mcastv6packet.array());
    assertPass(program, bcastv4packet1.array());
    assertPass(program, bcastv4packet2.array());
    assertPass(program, bcastv4unicastl2packet.array());
    // Turn on multicast filter and verify it works
    ipClientCallback.resetApfProgramWait();
    apfFilter.setMulticastFilter(true);
    program = ipClientCallback.getApfProgram();
    assertDrop(program, mcastv4packet.array());
    assertDrop(program, mcastv6packet.array());
    assertDrop(program, bcastv4packet1.array());
    assertDrop(program, bcastv4packet2.array());
    assertDrop(program, bcastv4unicastl2packet.array());
    // Turn off multicast filter and verify it's off
    ipClientCallback.resetApfProgramWait();
    apfFilter.setMulticastFilter(false);
    program = ipClientCallback.getApfProgram();
    assertPass(program, mcastv4packet.array());
    assertPass(program, mcastv6packet.array());
    assertPass(program, bcastv4packet1.array());
    assertPass(program, bcastv4packet2.array());
    assertPass(program, bcastv4unicastl2packet.array());
    // Verify it can be initialized to on
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    apfFilter = new TestApfFilter(mContext, config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    program = ipClientCallback.getApfProgram();
    assertDrop(program, mcastv4packet.array());
    assertDrop(program, mcastv6packet.array());
    assertDrop(program, bcastv4packet1.array());
    assertDrop(program, bcastv4unicastl2packet.array());
    // Verify that ICMPv6 multicast is not dropped.
    mcastv6packet.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_ICMPV6);
    assertPass(program, mcastv6packet.array());
    apfFilter.shutdown();
}
#end_block

#method_before
@Test
public void testApfFilter802_3() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    LinkAddress link = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 19);
    LinkProperties lp = new LinkProperties();
    lp.addLinkAddress(link);
    ApfConfiguration config = getDefaultConfig();
    TestApfFilter apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty packet of 100 zero bytes is passed
    // Note that eth-type = 0 makes it an IEEE802.3 frame
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    assertPass(program, packet.array());
    // Verify empty packet with IPv4 is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertPass(program, packet.array());
    // Verify empty IPv6 packet is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Now turn on the filter
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    program = ipClientCallback.getApfProgram();
    // Verify that IEEE802.3 frame is dropped
    // In this case ethtype is used for payload length
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) (100 - 14));
    assertDrop(program, packet.array());
    // Verify that IPv4 (as example of Ethernet II) frame will pass
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertPass(program, packet.array());
    // Verify that IPv6 (as example of Ethernet II) frame will pass
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    apfFilter.shutdown();
}
#method_after
@Test
public void testApfFilter802_3() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    ApfFilter apfFilter = setupApfFilter(ipClientCallback, config);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty packet of 100 zero bytes is passed
    // Note that eth-type = 0 makes it an IEEE802.3 frame
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    assertPass(program, packet.array());
    // Verify empty packet with IPv4 is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertPass(program, packet.array());
    // Verify empty IPv6 packet is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Now turn on the filter
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    apfFilter = setupApfFilter(ipClientCallback, config);
    program = ipClientCallback.getApfProgram();
    // Verify that IEEE802.3 frame is dropped
    // In this case ethtype is used for payload length
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) (100 - 14));
    assertDrop(program, packet.array());
    // Verify that IPv4 (as example of Ethernet II) frame will pass
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertPass(program, packet.array());
    // Verify that IPv6 (as example of Ethernet II) frame will pass
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    apfFilter.shutdown();
}
#end_block

#method_before
@Test
public void testApfFilterEthTypeBL() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    LinkAddress link = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 19);
    LinkProperties lp = new LinkProperties();
    lp.addLinkAddress(link);
    final int[] emptyBlackList = {};
    final int[] ipv4BlackList = { ETH_P_IP };
    final int[] ipv4Ipv6BlackList = { ETH_P_IP, ETH_P_IPV6 };
    ApfConfiguration config = getDefaultConfig();
    TestApfFilter apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty packet of 100 zero bytes is passed
    // Note that eth-type = 0 makes it an IEEE802.3 frame
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    assertPass(program, packet.array());
    // Verify empty packet with IPv4 is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertPass(program, packet.array());
    // Verify empty IPv6 packet is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Now add IPv4 to the black list
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.ethTypeBlackList = ipv4BlackList;
    apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    program = ipClientCallback.getApfProgram();
    // Verify that IPv4 frame will be dropped
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertDrop(program, packet.array());
    // Verify that IPv6 frame will pass
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Now let us have both IPv4 and IPv6 in the black list
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.ethTypeBlackList = ipv4Ipv6BlackList;
    apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    apfFilter.setLinkProperties(lp);
    program = ipClientCallback.getApfProgram();
    // Verify that IPv4 frame will be dropped
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertDrop(program, packet.array());
    // Verify that IPv6 frame will be dropped
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertDrop(program, packet.array());
    apfFilter.shutdown();
}
#method_after
@Test
public void testApfFilterEthTypeBL() throws Exception {
    final int[] emptyBlackList = {};
    final int[] ipv4BlackList = { ETH_P_IP };
    final int[] ipv4Ipv6BlackList = { ETH_P_IP, ETH_P_IPV6 };
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    ApfFilter apfFilter = setupApfFilter(ipClientCallback, config);
    byte[] program = ipClientCallback.getApfProgram();
    // Verify empty packet of 100 zero bytes is passed
    // Note that eth-type = 0 makes it an IEEE802.3 frame
    ByteBuffer packet = ByteBuffer.wrap(new byte[100]);
    assertPass(program, packet.array());
    // Verify empty packet with IPv4 is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertPass(program, packet.array());
    // Verify empty IPv6 packet is passed
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Now add IPv4 to the black list
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.ethTypeBlackList = ipv4BlackList;
    apfFilter = setupApfFilter(ipClientCallback, config);
    program = ipClientCallback.getApfProgram();
    // Verify that IPv4 frame will be dropped
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertDrop(program, packet.array());
    // Verify that IPv6 frame will pass
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertPass(program, packet.array());
    // Now let us have both IPv4 and IPv6 in the black list
    ipClientCallback.resetApfProgramWait();
    apfFilter.shutdown();
    config.ethTypeBlackList = ipv4Ipv6BlackList;
    apfFilter = setupApfFilter(ipClientCallback, config);
    program = ipClientCallback.getApfProgram();
    // Verify that IPv4 frame will be dropped
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IP);
    assertDrop(program, packet.array());
    // Verify that IPv6 frame will be dropped
    packet.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    assertDrop(program, packet.array());
    apfFilter.shutdown();
}
#end_block

#method_before
@Test
public void testApfFilterArp() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    // Verify initially ARP request filter is off, and GARP filter is on.
    verifyArpFilter(ipClientCallback.getApfProgram(), PASS);
    // Inform ApfFilter of our address and verify ARP filtering is on
    LinkAddress linkAddress = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 24);
    LinkProperties lp = new LinkProperties();
    assertTrue(lp.addLinkAddress(linkAddress));
    verifyArpFilter(getProgram(ipClientCallback, apfFilter, lp), DROP);
    // Inform ApfFilter of loss of IP and verify ARP filtering is off
    verifyArpFilter(getProgram(ipClientCallback, apfFilter, new LinkProperties()), PASS);
    apfFilter.shutdown();
}
#method_after
@Test
public void testApfFilterArp() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(mContext, config, ipClientCallback, mLog);
    // Verify initially ARP request filter is off, and GARP filter is on.
    verifyArpFilter(ipClientCallback.getApfProgram(), PASS);
    // Inform ApfFilter of our address and verify ARP filtering is on
    LinkAddress linkAddress = new LinkAddress(InetAddress.getByAddress(MOCK_IPV4_ADDR), 24);
    LinkProperties lp = new LinkProperties();
    assertTrue(lp.addLinkAddress(linkAddress));
    verifyArpFilter(getProgram(ipClientCallback, apfFilter, lp), DROP);
    // Inform ApfFilter of loss of IP and verify ARP filtering is off
    verifyArpFilter(getProgram(ipClientCallback, apfFilter, new LinkProperties()), PASS);
    apfFilter.shutdown();
}
#end_block

#method_before
// Verify that the last program pushed to the IpManager.Callback properly filters the
private void verifyRaLifetime(byte[] program, ByteBuffer packet, int lifetime) {
    final int FRACTION_OF_LIFETIME = 6;
    final int ageLimit = lifetime / FRACTION_OF_LIFETIME;
    // Verify new program should drop RA for 1/6th its lifetime and pass afterwards.
    assertDrop(program, packet.array());
    assertDrop(program, packet.array(), ageLimit);
    assertPass(program, packet.array(), ageLimit + 1);
    assertPass(program, packet.array(), lifetime);
    // Verify RA checksum is ignored
    final short originalChecksum = packet.getShort(ICMP6_RA_CHECKSUM_OFFSET);
    packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, (short) 12345);
    assertDrop(program, packet.array());
    packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, (short) -12345);
    assertDrop(program, packet.array());
    packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, originalChecksum);
    // Verify other changes to RA make it not match filter
    final byte originalFirstByte = packet.get(0);
    packet.put(0, (byte) -1);
    assertPass(program, packet.array());
    packet.put(0, (byte) 0);
    assertDrop(program, packet.array());
    packet.put(0, originalFirstByte);
}
#method_after
// Verify that the last program pushed to the IpClient.Callback properly filters the
private void verifyRaLifetime(byte[] program, ByteBuffer packet, int lifetime) {
    final int FRACTION_OF_LIFETIME = 6;
    final int ageLimit = lifetime / FRACTION_OF_LIFETIME;
    // Verify new program should drop RA for 1/6th its lifetime and pass afterwards.
    assertDrop(program, packet.array());
    assertDrop(program, packet.array(), ageLimit);
    assertPass(program, packet.array(), ageLimit + 1);
    assertPass(program, packet.array(), lifetime);
    // Verify RA checksum is ignored
    final short originalChecksum = packet.getShort(ICMP6_RA_CHECKSUM_OFFSET);
    packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, (short) 12345);
    assertDrop(program, packet.array());
    packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, (short) -12345);
    assertDrop(program, packet.array());
    packet.putShort(ICMP6_RA_CHECKSUM_OFFSET, originalChecksum);
    // Verify other changes to RA make it not match filter
    final byte originalFirstByte = packet.get(0);
    packet.put(0, (byte) -1);
    assertPass(program, packet.array());
    packet.put(0, (byte) 0);
    assertDrop(program, packet.array());
    packet.put(0, originalFirstByte);
}
#end_block

#method_before
@Test
public void testApfFilterRa() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(config, ipClientCallback, mLog);
    byte[] program = ipClientCallback.getApfProgram();
    final int ROUTER_LIFETIME = 1000;
    final int PREFIX_VALID_LIFETIME = 200;
    final int PREFIX_PREFERRED_LIFETIME = 100;
    final int RDNSS_LIFETIME = 300;
    final int ROUTE_LIFETIME = 400;
    // Note that lifetime of 2000 will be ignored in favor of shorter route lifetime of 1000.
    final int DNSSL_LIFETIME = 2000;
    final int VERSION_TRAFFIC_CLASS_FLOW_LABEL_OFFSET = ETH_HEADER_LEN;
    // IPv6, traffic class = 0, flow label = 0x12345
    final int VERSION_TRAFFIC_CLASS_FLOW_LABEL = 0x60012345;
    // Verify RA is passed the first time
    ByteBuffer basePacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET]);
    basePacket.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    basePacket.putInt(VERSION_TRAFFIC_CLASS_FLOW_LABEL_OFFSET, VERSION_TRAFFIC_CLASS_FLOW_LABEL);
    basePacket.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_ICMPV6);
    basePacket.put(ICMP6_TYPE_OFFSET, (byte) ICMP6_ROUTER_ADVERTISEMENT);
    basePacket.putShort(ICMP6_RA_ROUTER_LIFETIME_OFFSET, (short) ROUTER_LIFETIME);
    basePacket.position(IPV6_DEST_ADDR_OFFSET);
    basePacket.put(IPV6_ALL_NODES_ADDRESS);
    assertPass(program, basePacket.array());
    verifyRaLifetime(apfFilter, ipClientCallback, basePacket, ROUTER_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, -1, -1, -1));
    ByteBuffer newFlowLabelPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET]);
    basePacket.clear();
    newFlowLabelPacket.put(basePacket);
    // Check that changes are ignored in every byte of the flow label.
    newFlowLabelPacket.putInt(VERSION_TRAFFIC_CLASS_FLOW_LABEL_OFFSET, VERSION_TRAFFIC_CLASS_FLOW_LABEL + 0x11111);
    // Ensure zero-length options cause the packet to be silently skipped.
    // Do this before we test other packets. http://b/29586253
    ByteBuffer zeroLengthOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    zeroLengthOptionPacket.put(basePacket);
    zeroLengthOptionPacket.put((byte) ICMP6_PREFIX_OPTION_TYPE);
    zeroLengthOptionPacket.put((byte) 0);
    assertInvalidRa(apfFilter, ipClientCallback, zeroLengthOptionPacket);
    // Generate several RAs with different options and lifetimes, and verify when
    // ApfFilter is shown these packets, it generates programs to filter them for the
    // appropriate lifetime.
    ByteBuffer prefixOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_LEN]);
    basePacket.clear();
    prefixOptionPacket.put(basePacket);
    prefixOptionPacket.put((byte) ICMP6_PREFIX_OPTION_TYPE);
    prefixOptionPacket.put((byte) (ICMP6_PREFIX_OPTION_LEN / 8));
    prefixOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_PREFERRED_LIFETIME_OFFSET, PREFIX_PREFERRED_LIFETIME);
    prefixOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_VALID_LIFETIME_OFFSET, PREFIX_VALID_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, prefixOptionPacket, PREFIX_PREFERRED_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, PREFIX_VALID_LIFETIME, PREFIX_PREFERRED_LIFETIME, -1, -1, -1));
    ByteBuffer rdnssOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    rdnssOptionPacket.put(basePacket);
    rdnssOptionPacket.put((byte) ICMP6_RDNSS_OPTION_TYPE);
    rdnssOptionPacket.put((byte) (ICMP6_4_BYTE_OPTION_LEN / 8));
    rdnssOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, RDNSS_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, rdnssOptionPacket, RDNSS_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, -1, RDNSS_LIFETIME, -1));
    ByteBuffer routeInfoOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    routeInfoOptionPacket.put(basePacket);
    routeInfoOptionPacket.put((byte) ICMP6_ROUTE_INFO_OPTION_TYPE);
    routeInfoOptionPacket.put((byte) (ICMP6_4_BYTE_OPTION_LEN / 8));
    routeInfoOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, ROUTE_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, routeInfoOptionPacket, ROUTE_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, ROUTE_LIFETIME, -1, -1));
    ByteBuffer dnsslOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    dnsslOptionPacket.put(basePacket);
    dnsslOptionPacket.put((byte) ICMP6_DNSSL_OPTION_TYPE);
    dnsslOptionPacket.put((byte) (ICMP6_4_BYTE_OPTION_LEN / 8));
    dnsslOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, DNSSL_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, dnsslOptionPacket, ROUTER_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, -1, -1, DNSSL_LIFETIME));
    // Verify that current program filters all five RAs:
    program = ipClientCallback.getApfProgram();
    verifyRaLifetime(program, basePacket, ROUTER_LIFETIME);
    verifyRaLifetime(program, newFlowLabelPacket, ROUTER_LIFETIME);
    verifyRaLifetime(program, prefixOptionPacket, PREFIX_PREFERRED_LIFETIME);
    verifyRaLifetime(program, rdnssOptionPacket, RDNSS_LIFETIME);
    verifyRaLifetime(program, routeInfoOptionPacket, ROUTE_LIFETIME);
    verifyRaLifetime(program, dnsslOptionPacket, ROUTER_LIFETIME);
    apfFilter.shutdown();
}
#method_after
@Test
public void testApfFilterRa() throws Exception {
    MockIpClientCallback ipClientCallback = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(mContext, config, ipClientCallback, mLog);
    byte[] program = ipClientCallback.getApfProgram();
    final int ROUTER_LIFETIME = 1000;
    final int PREFIX_VALID_LIFETIME = 200;
    final int PREFIX_PREFERRED_LIFETIME = 100;
    final int RDNSS_LIFETIME = 300;
    final int ROUTE_LIFETIME = 400;
    // Note that lifetime of 2000 will be ignored in favor of shorter route lifetime of 1000.
    final int DNSSL_LIFETIME = 2000;
    final int VERSION_TRAFFIC_CLASS_FLOW_LABEL_OFFSET = ETH_HEADER_LEN;
    // IPv6, traffic class = 0, flow label = 0x12345
    final int VERSION_TRAFFIC_CLASS_FLOW_LABEL = 0x60012345;
    // Verify RA is passed the first time
    ByteBuffer basePacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET]);
    basePacket.putShort(ETH_ETHERTYPE_OFFSET, (short) ETH_P_IPV6);
    basePacket.putInt(VERSION_TRAFFIC_CLASS_FLOW_LABEL_OFFSET, VERSION_TRAFFIC_CLASS_FLOW_LABEL);
    basePacket.put(IPV6_NEXT_HEADER_OFFSET, (byte) IPPROTO_ICMPV6);
    basePacket.put(ICMP6_TYPE_OFFSET, (byte) ICMP6_ROUTER_ADVERTISEMENT);
    basePacket.putShort(ICMP6_RA_ROUTER_LIFETIME_OFFSET, (short) ROUTER_LIFETIME);
    basePacket.position(IPV6_DEST_ADDR_OFFSET);
    basePacket.put(IPV6_ALL_NODES_ADDRESS);
    assertPass(program, basePacket.array());
    verifyRaLifetime(apfFilter, ipClientCallback, basePacket, ROUTER_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, -1, -1, -1));
    ByteBuffer newFlowLabelPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET]);
    basePacket.clear();
    newFlowLabelPacket.put(basePacket);
    // Check that changes are ignored in every byte of the flow label.
    newFlowLabelPacket.putInt(VERSION_TRAFFIC_CLASS_FLOW_LABEL_OFFSET, VERSION_TRAFFIC_CLASS_FLOW_LABEL + 0x11111);
    // Ensure zero-length options cause the packet to be silently skipped.
    // Do this before we test other packets. http://b/29586253
    ByteBuffer zeroLengthOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    zeroLengthOptionPacket.put(basePacket);
    zeroLengthOptionPacket.put((byte) ICMP6_PREFIX_OPTION_TYPE);
    zeroLengthOptionPacket.put((byte) 0);
    assertInvalidRa(apfFilter, ipClientCallback, zeroLengthOptionPacket);
    // Generate several RAs with different options and lifetimes, and verify when
    // ApfFilter is shown these packets, it generates programs to filter them for the
    // appropriate lifetime.
    ByteBuffer prefixOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_LEN]);
    basePacket.clear();
    prefixOptionPacket.put(basePacket);
    prefixOptionPacket.put((byte) ICMP6_PREFIX_OPTION_TYPE);
    prefixOptionPacket.put((byte) (ICMP6_PREFIX_OPTION_LEN / 8));
    prefixOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_PREFERRED_LIFETIME_OFFSET, PREFIX_PREFERRED_LIFETIME);
    prefixOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_PREFIX_OPTION_VALID_LIFETIME_OFFSET, PREFIX_VALID_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, prefixOptionPacket, PREFIX_PREFERRED_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, PREFIX_VALID_LIFETIME, PREFIX_PREFERRED_LIFETIME, -1, -1, -1));
    ByteBuffer rdnssOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    rdnssOptionPacket.put(basePacket);
    rdnssOptionPacket.put((byte) ICMP6_RDNSS_OPTION_TYPE);
    rdnssOptionPacket.put((byte) (ICMP6_4_BYTE_OPTION_LEN / 8));
    rdnssOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, RDNSS_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, rdnssOptionPacket, RDNSS_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, -1, RDNSS_LIFETIME, -1));
    ByteBuffer routeInfoOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    routeInfoOptionPacket.put(basePacket);
    routeInfoOptionPacket.put((byte) ICMP6_ROUTE_INFO_OPTION_TYPE);
    routeInfoOptionPacket.put((byte) (ICMP6_4_BYTE_OPTION_LEN / 8));
    routeInfoOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, ROUTE_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, routeInfoOptionPacket, ROUTE_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, ROUTE_LIFETIME, -1, -1));
    ByteBuffer dnsslOptionPacket = ByteBuffer.wrap(new byte[ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_OPTION_LEN]);
    basePacket.clear();
    dnsslOptionPacket.put(basePacket);
    dnsslOptionPacket.put((byte) ICMP6_DNSSL_OPTION_TYPE);
    dnsslOptionPacket.put((byte) (ICMP6_4_BYTE_OPTION_LEN / 8));
    dnsslOptionPacket.putInt(ICMP6_RA_OPTION_OFFSET + ICMP6_4_BYTE_LIFETIME_OFFSET, DNSSL_LIFETIME);
    verifyRaLifetime(apfFilter, ipClientCallback, dnsslOptionPacket, ROUTER_LIFETIME);
    verifyRaEvent(new RaEvent(ROUTER_LIFETIME, -1, -1, -1, -1, DNSSL_LIFETIME));
    // Verify that current program filters all five RAs:
    program = ipClientCallback.getApfProgram();
    verifyRaLifetime(program, basePacket, ROUTER_LIFETIME);
    verifyRaLifetime(program, newFlowLabelPacket, ROUTER_LIFETIME);
    verifyRaLifetime(program, prefixOptionPacket, PREFIX_PREFERRED_LIFETIME);
    verifyRaLifetime(program, rdnssOptionPacket, RDNSS_LIFETIME);
    verifyRaLifetime(program, routeInfoOptionPacket, ROUTE_LIFETIME);
    verifyRaLifetime(program, dnsslOptionPacket, ROUTER_LIFETIME);
    apfFilter.shutdown();
}
#end_block

#method_before
@Test
public void testRaParsing() throws Exception {
    final int maxRandomPacketSize = 512;
    final Random r = new Random();
    MockIpClientCallback cb = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(config, cb, mLog);
    for (int i = 0; i < 1000; i++) {
        byte[] packet = new byte[r.nextInt(maxRandomPacketSize + 1)];
        r.nextBytes(packet);
        try {
            apfFilter.new Ra(packet, packet.length);
        } catch (ApfFilter.InvalidRaException e) {
        } catch (Exception e) {
            throw new Exception("bad packet: " + HexDump.toHexString(packet), e);
        }
    }
}
#method_after
@Test
public void testRaParsing() throws Exception {
    final int maxRandomPacketSize = 512;
    final Random r = new Random();
    MockIpClientCallback cb = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(mContext, config, cb, mLog);
    for (int i = 0; i < 1000; i++) {
        byte[] packet = new byte[r.nextInt(maxRandomPacketSize + 1)];
        r.nextBytes(packet);
        try {
            apfFilter.new Ra(packet, packet.length);
        } catch (ApfFilter.InvalidRaException e) {
        } catch (Exception e) {
            throw new Exception("bad packet: " + HexDump.toHexString(packet), e);
        }
    }
}
#end_block

#method_before
@Test
public void testRaProcessing() throws Exception {
    final int maxRandomPacketSize = 512;
    final Random r = new Random();
    MockIpClientCallback cb = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(config, cb, mLog);
    for (int i = 0; i < 1000; i++) {
        byte[] packet = new byte[r.nextInt(maxRandomPacketSize + 1)];
        r.nextBytes(packet);
        try {
            apfFilter.processRa(packet, packet.length);
        } catch (Exception e) {
            throw new Exception("bad packet: " + HexDump.toHexString(packet), e);
        }
    }
}
#method_after
@Test
public void testRaProcessing() throws Exception {
    final int maxRandomPacketSize = 512;
    final Random r = new Random();
    MockIpClientCallback cb = new MockIpClientCallback();
    ApfConfiguration config = getDefaultConfig();
    config.multicastFilter = DROP_MULTICAST;
    config.ieee802_3Filter = DROP_802_3_FRAMES;
    TestApfFilter apfFilter = new TestApfFilter(mContext, config, cb, mLog);
    for (int i = 0; i < 1000; i++) {
        byte[] packet = new byte[r.nextInt(maxRandomPacketSize + 1)];
        r.nextBytes(packet);
        try {
            apfFilter.processRa(packet, packet.length);
        } catch (Exception e) {
            throw new Exception("bad packet: " + HexDump.toHexString(packet), e);
        }
    }
}
#end_block

#method_before
public LinkProperties waitForProvisioning() {
    synchronized (this) {
        try {
            wait();
        } catch (InterruptedException e) {
        }
        return mCallbackLinkProperties;
    }
}
#method_after
public LinkProperties waitForProvisioning() {
    mCV.block();
    return mCallbackLinkProperties;
}
#end_block

#method_before
@Override
public void onProvisioningSuccess(LinkProperties newLp) {
    synchronized (this) {
        mCallbackLinkProperties = newLp;
        notify();
    }
}
#method_after
@Override
public void onProvisioningSuccess(LinkProperties newLp) {
    mCallbackLinkProperties = newLp;
    mCV.open();
}
#end_block

#method_before
@Override
public void onProvisioningFailure(LinkProperties newLp) {
    synchronized (this) {
        mCallbackLinkProperties = null;
        notify();
    }
}
#method_after
@Override
public void onProvisioningFailure(LinkProperties newLp) {
    mCallbackLinkProperties = null;
    mCV.open();
}
#end_block

#method_before
@Override
public void enter() {
    ApfFilter.ApfConfiguration apfConfig = new ApfFilter.ApfConfiguration();
    apfConfig.apfCapabilities = mConfiguration.mApfCapabilities;
    apfConfig.multicastFilter = mMulticastFiltering;
    // Get the Configuration for ApfFilter from Context
    apfConfig.ieee802_3Filter = mContext.getResources().getBoolean(R.bool.config_apfDrop802_3Frames);
    apfConfig.ethTypeBlackList = mContext.getResources().getIntArray(R.array.config_apfEthTypeBlackList);
    mApfFilter = ApfFilter.maybeCreate(apfConfig, mInterfaceParams, mCallback);
    // rest of this IP configuration startup.
    if (mApfFilter == null) {
        mCallback.setFallbackMulticastFilter(mMulticastFiltering);
    }
    mPacketTracker = createPacketTracker();
    if (mPacketTracker != null)
        mPacketTracker.start(mConfiguration.mDisplayName);
    if (mConfiguration.mEnableIPv6 && !startIPv6()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mEnableIPv4 && !startIPv4()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV4);
        transitionTo(mStoppingState);
        return;
    }
    final InitialConfiguration config = mConfiguration.mInitialConfig;
    if ((config != null) && !applyInitialConfig(config)) {
        // TODO introduce a new IpManagerEvent constant to distinguish this error case.
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mUsingMultinetworkPolicyTracker) {
        mMultinetworkPolicyTracker = new MultinetworkPolicyTracker(mContext, getHandler(), () -> {
            mLog.log("OBSERVED AvoidBadWifi changed");
        });
        mMultinetworkPolicyTracker.start();
    }
    if (mConfiguration.mUsingIpReachabilityMonitor && !startIpReachabilityMonitor()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPREACHABILITYMONITOR);
        transitionTo(mStoppingState);
        return;
    }
}
#method_after
@Override
public void enter() {
    ApfFilter.ApfConfiguration apfConfig = new ApfFilter.ApfConfiguration();
    apfConfig.apfCapabilities = mConfiguration.mApfCapabilities;
    apfConfig.multicastFilter = mMulticastFiltering;
    // Get the Configuration for ApfFilter from Context
    apfConfig.ieee802_3Filter = mContext.getResources().getBoolean(R.bool.config_apfDrop802_3Frames);
    apfConfig.ethTypeBlackList = mContext.getResources().getIntArray(R.array.config_apfEthTypeBlackList);
    mApfFilter = ApfFilter.maybeCreate(mContext, apfConfig, mInterfaceParams, mCallback);
    // rest of this IP configuration startup.
    if (mApfFilter == null) {
        mCallback.setFallbackMulticastFilter(mMulticastFiltering);
    }
    mPacketTracker = createPacketTracker();
    if (mPacketTracker != null)
        mPacketTracker.start(mConfiguration.mDisplayName);
    if (mConfiguration.mEnableIPv6 && !startIPv6()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV6);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mEnableIPv4 && !startIPv4()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPV4);
        transitionTo(mStoppingState);
        return;
    }
    final InitialConfiguration config = mConfiguration.mInitialConfig;
    if ((config != null) && !applyInitialConfig(config)) {
        // TODO introduce a new IpManagerEvent constant to distinguish this error case.
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        transitionTo(mStoppingState);
        return;
    }
    if (mConfiguration.mUsingMultinetworkPolicyTracker) {
        mMultinetworkPolicyTracker = new MultinetworkPolicyTracker(mContext, getHandler(), () -> {
            mLog.log("OBSERVED AvoidBadWifi changed");
        });
        mMultinetworkPolicyTracker.start();
    }
    if (mConfiguration.mUsingIpReachabilityMonitor && !startIpReachabilityMonitor()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_STARTING_IPREACHABILITYMONITOR);
        transitionTo(mStoppingState);
        return;
    }
}
#end_block

#method_before
private void updateImsRegistrationState() {
    boolean isImsRegistered = mTelephonyManager.isImsRegistered(mSir.getSubscriptionId());
    setSummaryText(KEY_IMS_REGISTRATION_STATE, mRes.getString(isImsRegistered ? R.string.ims_reg_status_registered : R.string.ims_reg_status_not_registered));
}
#method_after
@VisibleForTesting
void updateImsRegistrationState() {
    boolean isImsRegistered = mTelephonyManager.isImsRegistered(mSir.getSubscriptionId());
    setSummaryText(KEY_IMS_REGISTRATION_STATE, mRes.getString(isImsRegistered ? R.string.ims_reg_status_registered : R.string.ims_reg_status_not_registered));
}
#end_block

#method_before
private void updatePreference(boolean isTabChanged) {
    if (isTabChanged) {
        PreferenceScreen preferenceScreen = getPreferenceScreen();
        if (preferenceScreen != null) {
            preferenceScreen.removeAll();
            addPreferencesFromResource(R.xml.device_info_sim_status);
        }
    }
    if (mPhone.getPhoneType() != TelephonyManager.PHONE_TYPE_CDMA) {
        mShowLatestAreaInfo = Resources.getSystem().getBoolean(com.android.internal.R.bool.config_showAreaUpdateInfoSettings);
    }
    PersistableBundle carrierConfig = mCarrierConfigManager.getConfigForSubId(mSir.getSubscriptionId());
    mShowICCID = carrierConfig.getBoolean(CarrierConfigManager.KEY_SHOW_ICCID_IN_SIM_STATUS_BOOL);
    mShowImsRegState = carrierConfig.getBoolean(CarrierConfigManager.KEY_SHOW_IMS_REGISTRATION_STATUS_BOOL);
    // If formattedNumber is null or empty, it'll display as "Unknown".
    setSummaryText(KEY_PHONE_NUMBER, DeviceInfoUtils.getFormattedPhoneNumber(getContext(), mSir));
    setSummaryText(KEY_IMEI, mPhone.getImei());
    setSummaryText(KEY_IMEI_SV, mPhone.getDeviceSvn());
    if (!mShowICCID) {
        removePreferenceFromScreen(KEY_ICCID);
    } else {
        // Get ICCID, which is SIM serial number
        String iccid = mTelephonyManager.getSimSerialNumber(mSir.getSubscriptionId());
        setSummaryText(KEY_ICCID, iccid);
    }
    if (!mShowLatestAreaInfo) {
        removePreferenceFromScreen(KEY_LATEST_AREA_INFO);
    }
    boolean hideSignalStrength = carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_SIGNAL_STRENGTH_IN_SIM_STATUS_BOOL);
    if (hideSignalStrength) {
        removePreferenceFromScreen(KEY_SIGNAL_STRENGTH);
    }
    if (!mShowImsRegState) {
        removePreferenceFromScreen(KEY_IMS_REGISTRATION_STATE);
    }
}
#method_after
@VisibleForTesting
void updatePreference(boolean isTabChanged) {
    if (isTabChanged) {
        PreferenceScreen preferenceScreen = getPreferenceScreen();
        if (preferenceScreen != null) {
            preferenceScreen.removeAll();
            addPreferencesFromResource(R.xml.device_info_sim_status);
        }
    }
    if (mPhone.getPhoneType() != TelephonyManager.PHONE_TYPE_CDMA) {
        mShowLatestAreaInfo = Resources.getSystem().getBoolean(com.android.internal.R.bool.config_showAreaUpdateInfoSettings);
    }
    PersistableBundle carrierConfig = mCarrierConfigManager.getConfigForSubId(mSir.getSubscriptionId());
    mShowICCID = carrierConfig.getBoolean(CarrierConfigManager.KEY_SHOW_ICCID_IN_SIM_STATUS_BOOL);
    mShowImsRegState = carrierConfig.getBoolean(CarrierConfigManager.KEY_SHOW_IMS_REGISTRATION_STATUS_BOOL);
    // If formattedNumber is null or empty, it'll display as "Unknown".
    setSummaryText(KEY_PHONE_NUMBER, DeviceInfoUtils.getFormattedPhoneNumber(getContext(), mSir));
    setSummaryText(KEY_IMEI, mPhone.getImei());
    setSummaryText(KEY_IMEI_SV, mPhone.getDeviceSvn());
    if (!mShowICCID) {
        removePreferenceFromScreen(KEY_ICCID);
    } else {
        // Get ICCID, which is SIM serial number
        String iccid = mTelephonyManager.getSimSerialNumber(mSir.getSubscriptionId());
        setSummaryText(KEY_ICCID, iccid);
    }
    if (!mShowLatestAreaInfo) {
        removePreferenceFromScreen(KEY_LATEST_AREA_INFO);
    }
    boolean hideSignalStrength = carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_SIGNAL_STRENGTH_IN_SIM_STATUS_BOOL);
    if (hideSignalStrength) {
        removePreferenceFromScreen(KEY_SIGNAL_STRENGTH);
    }
    if (!mShowImsRegState) {
        removePreferenceFromScreen(KEY_IMS_REGISTRATION_STATE);
    }
}
#end_block

#method_before
private Tethering makeTethering() {
    // TODO: Move other elements into @Overridden getters.
    final TetheringDependencies deps = new TetheringDependencies();
    return new Tethering(mContext, mNetd, mStatsService, mPolicyManager, IoThread.get().getLooper(), new MockableSystemProperties(), deps);
}
#method_after
private Tethering makeTethering() {
    // TODO: Move other elements into @Overridden getters.
    final TetheringDependencies deps = new TetheringDependencies() {

        @Override
        public boolean isTetheringSupported() {
            return ConnectivityService.this.isTetheringSupported();
        }
    };
    return new Tethering(mContext, mNetd, mStatsService, mPolicyManager, IoThread.get().getLooper(), new MockableSystemProperties(), deps);
}
#end_block

#method_before
// Used only for testing.
// TODO: Delete this and either:
// 1. Give Fake SettingsProvider the ability to send settings change notifications (requires
// changing ContentResolver to make registerContentObserver non-final).
// 2. Give FakeSettingsProvider an alternative notification mechanism and have the test use it
@VisibleForTesting
void updateMobileDataAlwaysOn() {
    mHandler.sendEmptyMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON);
}
#method_after
// Used only for testing.
// TODO: Delete this and either:
// 1. Give FakeSettingsProvider the ability to send settings change notifications (requires
// changing ContentResolver to make registerContentObserver non-final).
// 2. Give FakeSettingsProvider an alternative notification mechanism and have the test use it
@VisibleForTesting
void updateMobileDataAlwaysOn() {
    mHandler.sendEmptyMessage(EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON);
}
#end_block

#method_before
private NetworkAgentInfo getNetworkAgentInfoForNetwork(Network network) {
    if (network == null) {
        return null;
    }
    synchronized (mNetworkForNetId) {
        return mNetworkForNetId.get(network.netId);
    }
}
#method_after
private NetworkAgentInfo getNetworkAgentInfoForNetwork(Network network) {
    if (network == null) {
        return null;
    }
    return getNetworkAgentInfoForNetId(network.netId);
}
#end_block

#method_before
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        synchronized (mNetworkForNetId) {
            nai = mNetworkForNetId.get(vpnNetId);
        }
        if (nai != null)
            return nai.network;
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#method_after
private Network getActiveNetworkForUidInternal(final int uid, boolean ignoreBlocked) {
    final int user = UserHandle.getUserId(uid);
    int vpnNetId = NETID_UNSET;
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(user);
        if (vpn != null && vpn.appliesToUid(uid))
            vpnNetId = vpn.getNetId();
    }
    NetworkAgentInfo nai;
    if (vpnNetId != NETID_UNSET) {
        nai = getNetworkAgentInfoForNetId(vpnNetId);
        if (nai != null)
            return nai.network;
    }
    nai = getDefaultNetwork();
    if (nai != null && isNetworkWithLinkPropertiesBlocked(nai.linkProperties, uid, ignoreBlocked)) {
        nai = null;
    }
    return nai != null ? nai.network : null;
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(msg.arg2);
                }
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(netId);
                }
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final Network n = new Network(msg.arg2);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(n);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#end_block

#method_before
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (mNetworkForNetId.get(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    LinkProperties oldLp = nai.linkProperties;
    synchronized (nai) {
        nai.linkProperties = newLp;
    }
    if (nai.everConnected) {
        updateLinkProperties(nai, oldLp);
    }
}
#method_after
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    LinkProperties oldLp = nai.linkProperties;
    synchronized (nai) {
        nai.linkProperties = newLp;
    }
    if (nai.everConnected) {
        updateLinkProperties(nai, oldLp);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mContext = InstrumentationRegistry.getContext();
    MockitoAnnotations.initMocks(this);
    when(mMetricsService.defaultNetworkMetrics()).thenReturn(mDefaultNetworkMetrics);
    // http://b/25897652 .
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mServiceContext = new MockContext(InstrumentationRegistry.getContext());
    LocalServices.removeServiceForTest(NetworkPolicyManagerInternal.class);
    LocalServices.addService(NetworkPolicyManagerInternal.class, mock(NetworkPolicyManagerInternal.class));
    mService = new WrappedConnectivityService(mServiceContext, mNetworkManagementService, mStatsService, mock(INetworkPolicyManager.class), mock(IpConnectivityLog.class));
    mService.systemReady();
    mCm = new WrappedConnectivityManager(InstrumentationRegistry.getContext(), mService);
    mCm.bindProcessToNetwork(null);
    // Ensure that the default setting for Captive Portals is used for most tests
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT);
    setMobileDataAlwaysOn(false);
}
#method_after
@Before
public void setUp() throws Exception {
    mContext = InstrumentationRegistry.getContext();
    MockitoAnnotations.initMocks(this);
    when(mMetricsService.defaultNetworkMetrics()).thenReturn(mDefaultNetworkMetrics);
    // http://b/25897652 .
    if (Looper.myLooper() == null) {
        Looper.prepare();
    }
    mServiceContext = new MockContext(InstrumentationRegistry.getContext());
    LocalServices.removeServiceForTest(NetworkPolicyManagerInternal.class);
    LocalServices.addService(NetworkPolicyManagerInternal.class, mock(NetworkPolicyManagerInternal.class));
    mService = new WrappedConnectivityService(mServiceContext, mNetworkManagementService, mStatsService, mock(INetworkPolicyManager.class), mock(IpConnectivityLog.class));
    mService.systemReady();
    mCm = new WrappedConnectivityManager(InstrumentationRegistry.getContext(), mService);
    mCm.bindProcessToNetwork(null);
    // Ensure that the default setting for Captive Portals is used for most tests
    setCaptivePortalMode(Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT);
    setMobileDataAlwaysOn(false);
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OFF, "ignored.example.com");
}
#end_block

#method_before
@Test
public void testLinkPropertiesEnsuresDirectlyConnectedRoutes() {
    final NetworkRequest networkRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(networkRequest, networkCallback);
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName("wlan0");
    LinkAddress myIpv4Address = new LinkAddress("192.168.12.3/24");
    RouteInfo myIpv4DefaultRoute = new RouteInfo((IpPrefix) null, NetworkUtils.numericToInetAddress("192.168.12.1"), lp.getInterfaceName());
    lp.addLinkAddress(myIpv4Address);
    lp.addRoute(myIpv4DefaultRoute);
    // Verify direct routes are added when network agent is first registered in
    // ConnectivityService.
    MockNetworkAgent networkAgent = new MockNetworkAgent(TRANSPORT_WIFI, lp);
    networkAgent.connect(true);
    networkCallback.expectCallback(CallbackState.AVAILABLE, networkAgent);
    networkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, networkAgent);
    CallbackInfo cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    checkDirectlyConnectedRoutes(mCm.getLinkProperties(networkAgent.getNetwork()), Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    // Verify direct routes are added during subsequent link properties updates.
    LinkProperties newLp = new LinkProperties(lp);
    LinkAddress myIpv6Address1 = new LinkAddress("fe80::cafe/64");
    LinkAddress myIpv6Address2 = new LinkAddress("2001:db8::2/64");
    newLp.addLinkAddress(myIpv6Address1);
    newLp.addLinkAddress(myIpv6Address2);
    networkAgent.sendLinkProperties(newLp);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address, myIpv6Address1, myIpv6Address2), Arrays.asList(myIpv4DefaultRoute));
    mCm.unregisterNetworkCallback(networkCallback);
}
#method_after
@Test
public void testLinkPropertiesEnsuresDirectlyConnectedRoutes() {
    final NetworkRequest networkRequest = new NetworkRequest.Builder().addTransportType(TRANSPORT_WIFI).build();
    final TestNetworkCallback networkCallback = new TestNetworkCallback();
    mCm.registerNetworkCallback(networkRequest, networkCallback);
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(WIFI_IFNAME);
    LinkAddress myIpv4Address = new LinkAddress("192.168.12.3/24");
    RouteInfo myIpv4DefaultRoute = new RouteInfo((IpPrefix) null, NetworkUtils.numericToInetAddress("192.168.12.1"), lp.getInterfaceName());
    lp.addLinkAddress(myIpv4Address);
    lp.addRoute(myIpv4DefaultRoute);
    // Verify direct routes are added when network agent is first registered in
    // ConnectivityService.
    MockNetworkAgent networkAgent = new MockNetworkAgent(TRANSPORT_WIFI, lp);
    networkAgent.connect(true);
    networkCallback.expectCallback(CallbackState.AVAILABLE, networkAgent);
    networkCallback.expectCallback(CallbackState.NETWORK_CAPABILITIES, networkAgent);
    CallbackInfo cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.expectCapabilitiesWith(NET_CAPABILITY_VALIDATED, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    checkDirectlyConnectedRoutes(mCm.getLinkProperties(networkAgent.getNetwork()), Arrays.asList(myIpv4Address), Arrays.asList(myIpv4DefaultRoute));
    // Verify direct routes are added during subsequent link properties updates.
    LinkProperties newLp = new LinkProperties(lp);
    LinkAddress myIpv6Address1 = new LinkAddress("fe80::cafe/64");
    LinkAddress myIpv6Address2 = new LinkAddress("2001:db8::2/64");
    newLp.addLinkAddress(myIpv6Address1);
    newLp.addLinkAddress(myIpv6Address2);
    networkAgent.sendLinkProperties(newLp);
    cbi = networkCallback.expectCallback(CallbackState.LINK_PROPERTIES, networkAgent);
    networkCallback.assertNoCallback();
    checkDirectlyConnectedRoutes(cbi.arg, Arrays.asList(myIpv4Address, myIpv6Address1, myIpv6Address2), Arrays.asList(myIpv4DefaultRoute));
    mCm.unregisterNetworkCallback(networkCallback);
}
#end_block

#method_before
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    ArgumentCaptor<String[]> tlsServers = ArgumentCaptor.forClass(String[].class);
    // Clear any interactions that occur as a result of CS starting up.
    reset(mNetworkManagementService);
    final String IFNAME = "test_rmnet_data0";
    final String[] EMPTY_TLS_SERVERS = new String[0];
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mNetworkManagementService, never()).setDnsConfigurationForNetwork(anyInt(), any(), any(), any(), eq(""), eq(EMPTY_TLS_SERVERS));
    verifyNoMoreInteractions(mNetworkManagementService);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), eq(EMPTY_TLS_SERVERS));
    // CS tells netd about the empty DNS config for this network.
    assertEmpty(mStringArrayCaptor.getValue());
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture());
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "2001:db8::1"));
    // Opportunistic mode.
    assertTrue(ArrayUtils.contains(tlsServers.getValue(), "2001:db8::1"));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture());
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    // Opportunistic mode.
    assertEquals(2, tlsServers.getValue().length);
    assertTrue(ArrayUtils.containsAll(tlsServers.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
    final String TLS_SPECIFIER = "tls.example.com";
    final String TLS_SERVER6 = "2001:db8:53::53";
    final InetAddress[] TLS_IPS = new InetAddress[] { InetAddress.getByName(TLS_SERVER6) };
    final String[] TLS_SERVERS = new String[] { TLS_SERVER6 };
    final Handler h = mCellNetworkAgent.getWrappedNetworkMonitor().connectivityHandler;
    h.sendMessage(h.obtainMessage(NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED, 0, mCellNetworkAgent.getNetwork().netId, new DnsManager.PrivateDnsConfig(TLS_SPECIFIER, TLS_IPS)));
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(TLS_SPECIFIER), eq(TLS_SERVERS));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
}
#method_after
@Test
public void testBasicDnsConfigurationPushed() throws Exception {
    setPrivateDnsSettings(PRIVATE_DNS_MODE_OPPORTUNISTIC, "ignored.example.com");
    ArgumentCaptor<String[]> tlsServers = ArgumentCaptor.forClass(String[].class);
    // Clear any interactions that occur as a result of CS starting up.
    reset(mNetworkManagementService);
    final String[] EMPTY_STRING_ARRAY = new String[0];
    mCellNetworkAgent = new MockNetworkAgent(TRANSPORT_CELLULAR);
    waitForIdle();
    verify(mNetworkManagementService, never()).setDnsConfigurationForNetwork(anyInt(), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY));
    verifyNoMoreInteractions(mNetworkManagementService);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName(MOBILE_IFNAME);
    // Add IPv4 and IPv6 default routes, because DNS-over-TLS code does
    // "is-reachable" testing in order to not program netd with unreachable
    // nameservers that it might try repeated to validate.
    cellLp.addLinkAddress(new LinkAddress("192.0.2.4/24"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("192.0.2.4"), MOBILE_IFNAME));
    cellLp.addLinkAddress(new LinkAddress("2001:db8:1::1/64"));
    cellLp.addRoute(new RouteInfo((IpPrefix) null, InetAddress.getByName("2001:db8:1::1"), MOBILE_IFNAME));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    mCellNetworkAgent.connect(false);
    waitForIdle();
    // CS tells netd about the empty DNS config for this network.
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), eq(EMPTY_STRING_ARRAY), any(), any(), eq(""), eq(EMPTY_STRING_ARRAY));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("2001:db8::1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture());
    assertEquals(1, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.contains(mStringArrayCaptor.getValue(), "2001:db8::1"));
    // Opportunistic mode.
    assertTrue(ArrayUtils.contains(tlsServers.getValue(), "2001:db8::1"));
    reset(mNetworkManagementService);
    cellLp.addDnsServer(InetAddress.getByName("192.0.2.1"));
    mCellNetworkAgent.sendLinkProperties(cellLp);
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(""), tlsServers.capture());
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    // Opportunistic mode.
    assertEquals(2, tlsServers.getValue().length);
    assertTrue(ArrayUtils.containsAll(tlsServers.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
    final String TLS_SPECIFIER = "tls.example.com";
    final String TLS_SERVER6 = "2001:db8:53::53";
    final InetAddress[] TLS_IPS = new InetAddress[] { InetAddress.getByName(TLS_SERVER6) };
    final String[] TLS_SERVERS = new String[] { TLS_SERVER6 };
    final Handler h = mCellNetworkAgent.getWrappedNetworkMonitor().connectivityHandler;
    h.sendMessage(h.obtainMessage(NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED, 0, mCellNetworkAgent.getNetwork().netId, new DnsManager.PrivateDnsConfig(TLS_SPECIFIER, TLS_IPS)));
    waitForIdle();
    verify(mNetworkManagementService, atLeastOnce()).setDnsConfigurationForNetwork(anyInt(), mStringArrayCaptor.capture(), any(), any(), eq(TLS_SPECIFIER), eq(TLS_SERVERS));
    assertEquals(2, mStringArrayCaptor.getValue().length);
    assertTrue(ArrayUtils.containsAll(mStringArrayCaptor.getValue(), new String[] { "2001:db8::1", "192.0.2.1" }));
    reset(mNetworkManagementService);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_CONNECTED);
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_NETWORK_DISCONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_DISCONNECTED);
            if (mLaunchCaptivePortalAppBroadcastReceiver != null) {
                mContext.unregisterReceiver(mLaunchCaptivePortalAppBroadcastReceiver);
                mLaunchCaptivePortalAppBroadcastReceiver = null;
            }
            quit();
            return HANDLED;
        case CMD_REEVALUATE_USING_PRIVATE_DNS:
            mBypassPrivateDns = false;
        case CMD_FORCE_REEVALUATION:
        case CMD_CAPTIVE_PORTAL_RECHECK:
            log("Forcing reevaluation for UID " + message.arg1);
            mUidResponsibleForReeval = message.arg1;
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_CAPTIVE_PORTAL_APP_FINISHED:
            log("CaptivePortal App responded with " + message.arg1);
            // If the user has seen and acted on a captive portal notification, and the
            // captive portal app is now closed, disable HTTPS probes. This avoids the
            // following pathological situation:
            // 
            // 1. HTTP probe returns a captive portal, HTTPS probe fails or times out.
            // 2. User opens the app and logs into the captive portal.
            // 3. HTTP starts working, but HTTPS still doesn't work for some other reason -
            // perhaps due to the network blocking HTTPS?
            // 
            // In this case, we'll fail to validate the network even after the app is
            // dismissed. There is now no way to use this network, because the app is now
            // gone, so the user cannot select "Use this network as is".
            mUseHttps = false;
            switch(message.arg1) {
                case APP_RETURN_DISMISSED:
                    sendMessage(CMD_FORCE_REEVALUATION, NO_UID, 0);
                    break;
                case APP_RETURN_WANTED_AS_IS:
                    mDontDisplaySigninNotification = true;
                    // TODO: Distinguish this from a network that actually validates.
                    // Displaying the "x" on the system UI icon may still be a good idea.
                    transitionTo(mValidatedState);
                    break;
                case APP_RETURN_UNWANTED:
                    mDontDisplaySigninNotification = true;
                    mUserDoesNotWant = true;
                    mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, null));
                    // TODO: Should teardown network.
                    mUidResponsibleForReeval = 0;
                    transitionTo(mEvaluatingState);
                    break;
            }
            return HANDLED;
        case CMD_PRIVATE_DNS_SETTINGS_CHANGED:
            {
                if (!isValidationRequired())
                    break;
                PrivateDnsConfig cfg = (PrivateDnsConfig) message.obj;
                // mode nameservers are validated separately within netd.
                if (cfg == null || !cfg.inStrictMode()) {
                    mPrivateDnsStrictMode = false;
                    break;
                }
                mPrivateDnsStrictMode = true;
                // This performs a blocking DNS resolution using the
                // network-assigned nameservers.
                cfg = DnsManager.tryBlockingResolveOf(mNetwork, cfg.hostname);
                if (cfg.ips.length > 0) {
                    // We resolved the strict mode hostname. Relay this to
                    // ConnectivityService so it make its way to netd.
                    mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_PRIVATE_DNS_CONFIG_RESOLVED, 0, mNetId, cfg));
                    // Reset the re-resolve backoff calculation.
                    mReresolveDelayMs = INITIAL_RERESOLVE_DELAY_MS;
                } else if (hasMessages(CMD_PRIVATE_DNS_SETTINGS_CHANGED)) {
                    // No need to continue processing this one.
                    break;
                } else {
                    // Queue up a re-resolution with backoff.
                    final Message msg = obtainMessage(CMD_PRIVATE_DNS_SETTINGS_CHANGED, cfg);
                    sendMessageDelayed(msg, mReresolveDelayMs);
                    mReresolveDelayMs *= 2;
                    if (mReresolveDelayMs > MAX_REEVALUATE_DELAY_MS) {
                        mReresolveDelayMs = MAX_REEVALUATE_DELAY_MS;
                    }
                }
                // DNS resolutions via Private DNS strict mode block for
                // a few seconds (~4.2) checking for any IP addresses to
                // arrive and validate. Initiating this (re)evaluation now
                // should not significantly alter the validation outcome.
                // 
                // Regardless: enqueue a (re)validation attempt; either the
                // the Private DNS configuration will validate (huzzah) or
                // there's some problem (no resolved IP addresses, port 853
                // is blocked, et cetera) and an "x" needs to be shown in
                // the system UI.
                removeMessages(CMD_REEVALUATE_USING_PRIVATE_DNS);
                sendMessage(CMD_REEVALUATE_USING_PRIVATE_DNS, NO_UID, 0);
                break;
            }
        default:
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_CONNECTED);
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_NETWORK_DISCONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_DISCONNECTED);
            if (mLaunchCaptivePortalAppBroadcastReceiver != null) {
                mContext.unregisterReceiver(mLaunchCaptivePortalAppBroadcastReceiver);
                mLaunchCaptivePortalAppBroadcastReceiver = null;
            }
            quit();
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
        case CMD_CAPTIVE_PORTAL_RECHECK:
            log("Forcing reevaluation for UID " + message.arg1);
            mUidResponsibleForReeval = message.arg1;
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_CAPTIVE_PORTAL_APP_FINISHED:
            log("CaptivePortal App responded with " + message.arg1);
            // If the user has seen and acted on a captive portal notification, and the
            // captive portal app is now closed, disable HTTPS probes. This avoids the
            // following pathological situation:
            // 
            // 1. HTTP probe returns a captive portal, HTTPS probe fails or times out.
            // 2. User opens the app and logs into the captive portal.
            // 3. HTTP starts working, but HTTPS still doesn't work for some other reason -
            // perhaps due to the network blocking HTTPS?
            // 
            // In this case, we'll fail to validate the network even after the app is
            // dismissed. There is now no way to use this network, because the app is now
            // gone, so the user cannot select "Use this network as is".
            mUseHttps = false;
            switch(message.arg1) {
                case APP_RETURN_DISMISSED:
                    sendMessage(CMD_FORCE_REEVALUATION, NO_UID, 0);
                    break;
                case APP_RETURN_WANTED_AS_IS:
                    mDontDisplaySigninNotification = true;
                    // TODO: Distinguish this from a network that actually validates.
                    // Displaying the "x" on the system UI icon may still be a good idea.
                    transitionTo(mEvaluatingPrivateDnsState);
                    break;
                case APP_RETURN_UNWANTED:
                    mDontDisplaySigninNotification = true;
                    mUserDoesNotWant = true;
                    notifyNetworkTestResultInvalid(null);
                    // TODO: Should teardown network.
                    mUidResponsibleForReeval = 0;
                    transitionTo(mEvaluatingState);
                    break;
            }
            return HANDLED;
        case CMD_PRIVATE_DNS_SETTINGS_CHANGED:
            {
                final PrivateDnsConfig cfg = (PrivateDnsConfig) message.obj;
                if (!isValidationRequired() || cfg == null || !cfg.inStrictMode()) {
                    // No DNS resolution required.
                    // 
                    // We don't force any validation in opportunistic mode
                    // here. Opportunistic mode nameservers are validated
                    // separately within netd.
                    // 
                    // Reset Private DNS settings state.
                    mPrivateDnsProviderHostname = "";
                    break;
                }
                mPrivateDnsProviderHostname = cfg.hostname;
                // DNS resolutions via Private DNS strict mode block for a
                // few seconds (~4.2) checking for any IP addresses to
                // arrive and validate. Initiating a (re)evaluation now
                // should not significantly alter the validation outcome.
                // 
                // No matter what: enqueue a validation request; one of
                // three things can happen with this request:
                // [1] ignored (EvaluatingState or CaptivePortalState)
                // [2] transition to EvaluatingPrivateDnsState
                // (DefaultState and ValidatedState)
                // [3] handled (EvaluatingPrivateDnsState)
                // 
                // The Private DNS configuration to be evaluated will:
                // [1] be skipped (not in strict mode), or
                // [2] validate (huzzah), or
                // [3] encounter some problem (invalid hostname,
                // no resolved IP addresses, IPs unreachable,
                // port 853 unreachable, port 853 is not running a
                // DNS-over-TLS server, et cetera).
                sendMessage(CMD_EVALUATE_PRIVATE_DNS);
                break;
            }
        default:
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            transitionTo(mValidatedState);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            transitionTo(mValidatedState);
            break;
        case CMD_EVALUATE_PRIVATE_DNS:
            transitionTo(mEvaluatingPrivateDnsState);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_REEVALUATE_USING_PRIVATE_DNS:
            deferMessage(message);
            return HANDLED;
        case CMD_LAUNCH_CAPTIVE_PORTAL_APP:
            final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
            // OneAddressPerFamilyNetwork is not parcelable across processes.
            intent.putExtra(ConnectivityManager.EXTRA_NETWORK, new Network(mNetwork));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL, new CaptivePortal(new ICaptivePortal.Stub() {

                @Override
                public void appResponse(int response) {
                    if (response == APP_RETURN_WANTED_AS_IS) {
                        mContext.enforceCallingPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "CaptivePortal");
                    }
                    sendMessage(CMD_CAPTIVE_PORTAL_APP_FINISHED, response);
                }
            }));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_URL, mLastPortalProbeResult.detectUrl);
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT, mCaptivePortalUserAgent);
            intent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_LAUNCH_CAPTIVE_PORTAL_APP:
            final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
            // OneAddressPerFamilyNetwork is not parcelable across processes.
            intent.putExtra(ConnectivityManager.EXTRA_NETWORK, new Network(mNetwork));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL, new CaptivePortal(new ICaptivePortal.Stub() {

                @Override
                public void appResponse(int response) {
                    if (response == APP_RETURN_WANTED_AS_IS) {
                        mContext.enforceCallingPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "CaptivePortal");
                    }
                    sendMessage(CMD_CAPTIVE_PORTAL_APP_FINISHED, response);
                }
            }));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_URL, mLastPortalProbeResult.detectUrl);
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT, mCaptivePortalUserAgent);
            intent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#end_block

#method_before
@Override
public void exit() {
    Message message = obtainMessage(EVENT_PROVISIONING_NOTIFICATION, 0, mNetId, null);
    mConnectivityServiceHandler.sendMessage(message);
    mBypassPrivateDns = true;
}
#method_after
@Override
public void exit() {
    Message message = obtainMessage(EVENT_PROVISIONING_NOTIFICATION, 0, mNetId, null);
    mConnectivityServiceHandler.sendMessage(message);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_REEVALUATE:
            if (message.arg1 != mReevaluateToken || mUserDoesNotWant)
                return HANDLED;
            // expensive metered network, or unwanted leaking of the User Agent string.
            if (!isValidationRequired()) {
                validationLog("Network would not satisfy default request, not validating");
                transitionTo(mValidatedState);
                return HANDLED;
            }
            mAttempts++;
            // Note: This call to isCaptivePortal() could take up to a minute. Resolving the
            // server's IP addresses could hit the DNS timeout, and attempting connections
            // to each of the server's several IP addresses (currently one IPv4 and one
            // IPv6) could each take SOCKET_TIMEOUT_MS.  During this time this StateMachine
            // will be unresponsive. isCaptivePortal() could be executed on another Thread
            // if this is found to cause problems.
            CaptivePortalProbeResult probeResult = isCaptivePortal();
            if (probeResult.isSuccessful()) {
                if (hasPrivateDnsUpdatePending()) {
                    // Jump back up to the starting state, and let the
                    // Private DNS command/event trigger a revalidation.
                    transitionTo(mDefaultState);
                } else if (mBypassPrivateDns && mPrivateDnsStrictMode) {
                    // It's possible that the strict mode service became
                    // unavailable for some reason and an app requested
                    // revalidation. If we're in Private DNS strict mode
                    // enqueue another validation, explicitly without
                    // Private DNS bypass.
                    mBypassPrivateDns = false;
                    transitionTo(mEvaluatingState);
                } else {
                    transitionTo(mValidatedState);
                }
            } else if (probeResult.isPortal()) {
                mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));
                mLastPortalProbeResult = probeResult;
                transitionTo(mCaptivePortalState);
            } else {
                final Message msg = obtainMessage(CMD_REEVALUATE, ++mReevaluateToken, 0);
                sendMessageDelayed(msg, mReevaluateDelayMs);
                logNetworkEvent(NetworkEvent.NETWORK_VALIDATION_FAILED);
                mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));
                if (mAttempts >= BLAME_FOR_EVALUATION_ATTEMPTS) {
                    // Don't continue to blame UID forever.
                    TrafficStats.clearThreadStatsUid();
                }
                mReevaluateDelayMs *= 2;
                if (mReevaluateDelayMs > MAX_REEVALUATE_DELAY_MS) {
                    mReevaluateDelayMs = MAX_REEVALUATE_DELAY_MS;
                }
            }
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
            // evaluation process via EvaluatingState#enter.
            return (mAttempts < IGNORE_REEVALUATE_ATTEMPTS) ? HANDLED : NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_REEVALUATE:
            if (message.arg1 != mReevaluateToken || mUserDoesNotWant)
                return HANDLED;
            // expensive metered network, or unwanted leaking of the User Agent string.
            if (!isValidationRequired()) {
                validationLog("Network would not satisfy default request, not validating");
                transitionTo(mValidatedState);
                return HANDLED;
            }
            mAttempts++;
            // Note: This call to isCaptivePortal() could take up to a minute. Resolving the
            // server's IP addresses could hit the DNS timeout, and attempting connections
            // to each of the server's several IP addresses (currently one IPv4 and one
            // IPv6) could each take SOCKET_TIMEOUT_MS.  During this time this StateMachine
            // will be unresponsive. isCaptivePortal() could be executed on another Thread
            // if this is found to cause problems.
            CaptivePortalProbeResult probeResult = isCaptivePortal();
            if (probeResult.isSuccessful()) {
                // Transit EvaluatingPrivateDnsState to get to Validated
                // state (even if no Private DNS validation required).
                transitionTo(mEvaluatingPrivateDnsState);
            } else if (probeResult.isPortal()) {
                notifyNetworkTestResultInvalid(probeResult.redirectUrl);
                mLastPortalProbeResult = probeResult;
                transitionTo(mCaptivePortalState);
            } else {
                final Message msg = obtainMessage(CMD_REEVALUATE, ++mReevaluateToken, 0);
                sendMessageDelayed(msg, mReevaluateDelayMs);
                logNetworkEvent(NetworkEvent.NETWORK_VALIDATION_FAILED);
                notifyNetworkTestResultInvalid(probeResult.redirectUrl);
                if (mAttempts >= BLAME_FOR_EVALUATION_ATTEMPTS) {
                    // Don't continue to blame UID forever.
                    TrafficStats.clearThreadStatsUid();
                }
                mReevaluateDelayMs *= 2;
                if (mReevaluateDelayMs > MAX_REEVALUATE_DELAY_MS) {
                    mReevaluateDelayMs = MAX_REEVALUATE_DELAY_MS;
                }
            }
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
            // evaluation process via EvaluatingState#enter.
            return (mAttempts < IGNORE_REEVALUATE_ATTEMPTS) ? HANDLED : NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#end_block

#method_before
@Override
public void exit() {
}
#method_after
@Override
public void exit() {
    TrafficStats.clearThreadStatsUid();
}
#end_block

#method_before
@Override
public InetAddress[] getAllByName(String host) throws UnknownHostException {
    List<InetAddress> addrs = Arrays.asList(bypassPrivateDns() ? ResolvUtil.blockingResolveAllLocally(this, host) : super.getAllByName(host));
    // Ensure the address family of the first address is tried first.
    LinkedHashMap<Class, InetAddress> addressByFamily = new LinkedHashMap<>();
    addressByFamily.put(addrs.get(0).getClass(), addrs.get(0));
    Collections.shuffle(addrs);
    for (InetAddress addr : addrs) {
        addressByFamily.put(addr.getClass(), addr);
    }
    return addressByFamily.values().toArray(new InetAddress[addressByFamily.size()]);
}
#method_after
@Override
public InetAddress[] getAllByName(String host) throws UnknownHostException {
    // Always bypass Private DNS.
    final List<InetAddress> addrs = Arrays.asList(ResolvUtil.blockingResolveAllLocally(this, host));
    // Ensure the address family of the first address is tried first.
    LinkedHashMap<Class, InetAddress> addressByFamily = new LinkedHashMap<>();
    addressByFamily.put(addrs.get(0).getClass(), addrs.get(0));
    Collections.shuffle(addrs);
    for (InetAddress addr : addrs) {
        addressByFamily.put(addr.getClass(), addr);
    }
    return addressByFamily.values().toArray(new InetAddress[addressByFamily.size()]);
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerCapabilities build() {
    return new SignerCapabilities(mFlags);
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mPrivateKey, mCertificate);
}
#end_block

#method_before
@Test
public void testCountryWithPriority() throws Exception {
    // This is a country that has two zones which were distinct initially but then became the
    // same. The CountryZoneTree needs a priority on one to indicate which "merged into" the
    // other. In this test one zone has the priority.
    String countryText = "  isoCode:\"de\"\n" + "  defaultTimeZoneId:\"Europe/Berlin\"\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"1:00\"\n" + "    id:\"Europe/Berlin\"\n" + "    priority: 10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"1:00\"\n" + "    id:\"Europe/Busingen\"\n" + "  >\n";
    Country country = parseCountry(countryText);
    CountryZoneTree zoneTree = CountryZoneTree.create(country, RULES_START_INSTANT, RULES_END_INSTANT);
    assertTrue(zoneTree.validateNoPriorityClashes().isEmpty());
    CountryZoneUsage countryZoneUsage = zoneTree.calculateCountryZoneUsage(NOT_USED_AFTER_CUT_OFF);
    assertNull(countryZoneUsage.getNotUsedAfterInstant("Europe/Berlin"));
    Instant expectedNotUsedAfterInstant = Instant.ofEpochSecond(354675600);
    /* 1981-03-29T01:00:00Z */
    assertEquals(expectedNotUsedAfterInstant, countryZoneUsage.getNotUsedAfterInstant("Europe/Busingen"));
}
#method_after
@Test
public void testCountryWithPriority() throws Exception {
    // This is a country that has two zones which were distinct initially but then became the
    // same. The CountryZoneTree needs a priority on one to indicate which "merged into" the
    // other. In this test one zone has the priority.
    String countryText = "  isoCode:\"de\"\n" + "  defaultTimeZoneId:\"Europe/Berlin\"\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"1:00\"\n" + "    id:\"Europe/Berlin\"\n" + "    priority: 10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"1:00\"\n" + "    id:\"Europe/Busingen\"\n" + "  >\n";
    Country country = parseCountry(countryText);
    CountryZoneTree zoneTree = CountryZoneTree.create(country, RULES_START_INSTANT, RULES_END_INSTANT);
    assertTrue(zoneTree.validateNoPriorityClashes().isEmpty());
    CountryZoneUsage countryZoneUsage = zoneTree.calculateCountryZoneUsage(NOT_USED_AFTER_CUT_OFF);
    assertNull(countryZoneUsage.getNotUsedAfterInstant("Europe/Berlin"));
    Instant expectedNotUsedAfterInstant = Instant.ofEpochSecond(338950800);
    /* 1980-09-28T01:00:00Z */
    assertEquals(expectedNotUsedAfterInstant, countryZoneUsage.getNotUsedAfterInstant("Europe/Busingen"));
}
#end_block

#method_before
@Test
public void notAfter() throws Exception {
    CountryZonesFile.Country country = createValidCountryUs();
    List<ZoneTabFile.CountryEntry> zoneTabEntries = createValidZoneTabEntriesUs();
    String tzLookupXml = generateTzLookupXml(country, zoneTabEntries);
    String expectedOutput = "<id>America/New_York</id>\n" + "<id notafter=\"183535200000\">America/Detroit</id>\n" + "<id notafter=\"162370800000\">America/Kentucky/Louisville</id>\n" + "<id notafter=\"986108400000\">America/Kentucky/Monticello</id>\n" + "<id notafter=\"1143961200000\">America/Indiana/Indianapolis</id>\n" + "<id notafter=\"1205046000000\">America/Indiana/Vincennes</id>\n" + "<id notafter=\"1194156000000\">America/Indiana/Winamac</id>\n" + "<id notafter=\"1143961200000\">America/Indiana/Marengo</id>\n" + "<id notafter=\"1143961200000\">America/Indiana/Petersburg</id>\n" + "<id notafter=\"1143961200000\">America/Indiana/Vevay</id>\n" + "<id>America/Chicago</id>\n" + "<id notafter=\"1143961200000\">America/Indiana/Knox</id>\n" + "<id notafter=\"120639600000\">America/Menominee</id>\n" + "<id notafter=\"733910400000\">America/North_Dakota/Center</id>\n" + "<id notafter=\"1081065600000\">America/North_Dakota/New_Salem</id>\n" + "<id notafter=\"1162105200000\">America/Indiana/Tell_City</id>\n" + "<id notafter=\"1300003200000\">America/North_Dakota/Beulah</id>\n" + "<id>America/Denver</id>\n" + "<id notafter=\"152092800000\">America/Boise</id>\n" + "<id>America/Phoenix</id>\n" + "<id>America/Los_Angeles</id>\n" + "<id>America/Anchorage</id>\n" + "<id notafter=\"452084400000\">America/Juneau</id>\n" + "<id notafter=\"452084400000\">America/Yakutat</id>\n" + "<id notafter=\"452084400000\">America/Nome</id>\n" + "<id notafter=\"1446372000000\">America/Metlakatla</id>\n" + "<id notafter=\"357127200000\">America/Sitka</id>\n" + "<id>Pacific/Honolulu</id>\n" + "<id>America/Adak</id>\n";
    String[] expectedLines = expectedOutput.split("\\n");
    for (String expectedLine : expectedLines) {
        assertContains(tzLookupXml, expectedLine);
    }
}
#method_after
@Test
public void notAfter() throws Exception {
    CountryZonesFile.Country country = createValidCountryUs();
    List<ZoneTabFile.CountryEntry> zoneTabEntries = createValidZoneTabEntriesUs();
    String tzLookupXml = generateTzLookupXml(country, zoneTabEntries);
    String expectedOutput = "<id>America/New_York</id>\n" + "<id notafter=\"167814000000\">America/Detroit</id>\n" + "<id notafter=\"152089200000\">America/Kentucky/Louisville</id>\n" + "<id notafter=\"972802800000\">America/Kentucky/Monticello</id>\n" + "<id notafter=\"1130652000000\">America/Indiana/Indianapolis</id>\n" + "<id notafter=\"1194159600000\">America/Indiana/Vincennes</id>\n" + "<id notafter=\"1173600000000\">America/Indiana/Winamac</id>\n" + "<id notafter=\"183535200000\">America/Indiana/Marengo</id>\n" + "<id notafter=\"247042800000\">America/Indiana/Petersburg</id>\n" + "<id notafter=\"89186400000\">America/Indiana/Vevay</id>\n" + "<id>America/Chicago</id>\n" + "<id notafter=\"688546800000\">America/Indiana/Knox</id>\n" + "<id notafter=\"104918400000\">America/Menominee</id>\n" + "<id notafter=\"720000000000\">America/North_Dakota/Center</id>\n" + "<id notafter=\"1067155200000\">America/North_Dakota/New_Salem</id>\n" + "<id notafter=\"1143964800000\">America/Indiana/Tell_City</id>\n" + "<id notafter=\"1289116800000\">America/North_Dakota/Beulah</id>\n" + "<id>America/Denver</id>\n" + "<id notafter=\"129114000000\">America/Boise</id>\n" + "<id>America/Phoenix</id>\n" + "<id>America/Los_Angeles</id>\n" + "<id>America/Anchorage</id>\n" + "<id notafter=\"436359600000\">America/Juneau</id>\n" + "<id notafter=\"436356000000\">America/Yakutat</id>\n" + "<id notafter=\"436363200000\">America/Nome</id>\n" + "<id notafter=\"1446372000000\">America/Metlakatla</id>\n" + "<id notafter=\"341402400000\">America/Sitka</id>\n" + "<id>Pacific/Honolulu</id>\n" + "<id>America/Adak</id>\n";
    String[] expectedLines = expectedOutput.split("\\n");
    for (String expectedLine : expectedLines) {
        assertContains(tzLookupXml, expectedLine);
    }
}
#end_block

#method_before
private static CountryZonesFile.Country createValidCountryUs() throws Exception {
    // This country demonstrates most interesting algorithm behavior. This is copied verbatim
    // from countryzones.txt.
    String usText = "  isoCode:\"us\"\n" + "  defaultTimeZoneId:\"America/New_York\"\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/New_York\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Detroit\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Kentucky/Louisville\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Kentucky/Monticello\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Indianapolis\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Vincennes\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Winamac\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Marengo\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Petersburg\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Vevay\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Chicago\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Indiana/Knox\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Menominee\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/North_Dakota/Center\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/North_Dakota/New_Salem\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Indiana/Tell_City\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/North_Dakota/Beulah\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-7:00\"\n" + "    id:\"America/Denver\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-7:00\"\n" + "    id:\"America/Boise\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-7:00\"\n" + "    id:\"America/Phoenix\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-8:00\"\n" + "    id:\"America/Los_Angeles\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Anchorage\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Juneau\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Yakutat\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Nome\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Metlakatla\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Sitka\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-10:00\"\n" + "    id:\"Pacific/Honolulu\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-10:00\"\n" + "    id:\"America/Adak\"\n" + "  >\n";
    return parseCountry(usText);
}
#method_after
private static CountryZonesFile.Country createValidCountryUs() throws Exception {
    // This country demonstrates most interesting algorithm behavior. This is copied verbatim
    // from countryzones.txt.
    String usText = "  isoCode:\"us\"\n" + "  defaultTimeZoneId:\"America/New_York\"\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/New_York\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Detroit\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Kentucky/Louisville\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Kentucky/Monticello\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Indianapolis\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Vincennes\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Winamac\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Marengo\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Petersburg\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-5:00\"\n" + "    id:\"America/Indiana/Vevay\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Chicago\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Indiana/Knox\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Menominee\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/North_Dakota/Center\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/North_Dakota/New_Salem\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/Indiana/Tell_City\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-6:00\"\n" + "    id:\"America/North_Dakota/Beulah\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-7:00\"\n" + "    id:\"America/Denver\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-7:00\"\n" + "    id:\"America/Boise\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-7:00\"\n" + "    id:\"America/Phoenix\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-8:00\"\n" + "    id:\"America/Los_Angeles\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Anchorage\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Juneau\"\n" + "    priority:9\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Yakutat\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Nome\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Metlakatla\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-9:00\"\n" + "    id:\"America/Sitka\"\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-10:00\"\n" + "    id:\"Pacific/Honolulu\"\n" + "    priority:10\n" + "  >\n" + "  timeZoneMappings:<\n" + "    utcOffset:\"-10:00\"\n" + "    id:\"America/Adak\"\n" + "  >\n";
    return parseCountry(usText);
}
#end_block

#method_before
private static void addExtraPeriodSplits(TimeZoneNames timeZoneNames, List<ZoneInfo> zoneInfos) {
    // This algorithm works backwards through the all the zone info periods. It finds periods
    // that would match if it were not for different start times and it splits the longer ones
    // in two. It keeps going backwards through the periods until no splits are made.
    // True if a split has been made in the offsetFromEnd loop.
    boolean splitMade;
    // The offset into the periods. Since we work in reverse (from the end of time), offset = 1
    // means "the last period" offset = 2 means "the last but one period", etc.
    // We initialize at 0; it is incremented at the start of the do-while loop.
    int offsetFromEnd = 0;
    // offset.
    do {
        splitMade = false;
        offsetFromEnd += 1;
        // Keep track of which zoneinfos have been processed for the current offset.
        boolean[] processed = new boolean[zoneInfos.size()];
        // be split.
        for (int i = 0; i < zoneInfos.size(); i++) {
            if (processed[i]) {
                // zoneinfo[i] has already been processed by a prior round. Skip.
                continue;
            }
            // Get zoneinfo[i] so we can use its zone properties to find all other similar
            // zones.
            ZoneInfo iZoneInfo = zoneInfos.get(i);
            ZoneOffsetPeriod iPeriod = getOffsetPeriodAtOffsetFromEndOrNull(iZoneInfo, offsetFromEnd);
            if (iPeriod == null) {
                // We've run out of periods for this zoneinfo. Skip.
                processed[i] = true;
                continue;
            }
            // Pass 1: Find the all zoneinfos that have the same zone properties as zoneinfo[i]
            // at offsetFromEnd and also work out the instant that they would need to be split
            // at to be (likely) the same.
            boolean[] samePropertiesAtOffsetFromEnd = new boolean[zoneInfos.size()];
            // zoneinfo[i] has the same properties as itself.
            samePropertiesAtOffsetFromEnd[i] = true;
            Instant toSplitInstant = iPeriod.getStartInstant();
            for (int j = 0; j < zoneInfos.size(); j++) {
                if (j == i || processed[j]) {
                    // processed.
                    continue;
                }
                ZoneInfo jZoneInfo = zoneInfos.get(j);
                ZoneOffsetPeriod jPeriod = getOffsetPeriodAtOffsetFromEndOrNull(jZoneInfo, offsetFromEnd);
                if (jPeriod == null) {
                    // We've run out of periods for this zoneinfo. Skip.
                    processed[j] = true;
                    continue;
                }
                if (wouldLikelyEqualIfSplit(iPeriod, jPeriod)) {
                    samePropertiesAtOffsetFromEnd[j] = true;
                    if (toSplitInstant == null || jPeriod.getStartInstant().isAfter(toSplitInstant)) {
                        // Keep track of the latest start instant.
                        toSplitInstant = jPeriod.getStartInstant();
                    }
                }
            }
            // toSplitInstant.
            for (int j = 0; j < zoneInfos.size(); j++) {
                if (!samePropertiesAtOffsetFromEnd[j]) {
                    continue;
                }
                ZoneInfo jZoneInfo = zoneInfos.get(j);
                int jIndex = jZoneInfo.getZoneOffsetPeriodCount() - offsetFromEnd;
                ZoneOffsetPeriod jPeriod = jZoneInfo.getZoneOffsetPeriod(jIndex);
                if (!jPeriod.getStartInstant().equals(toSplitInstant)) {
                    ZoneInfo.splitZoneOffsetPeriodAtTime(timeZoneNames, jZoneInfo, jIndex, toSplitInstant);
                    splitMade = true;
                }
                processed[j] = true;
            }
        }
    } while (splitMade);
}
#method_after
private static void addExtraPeriodSplits(TimeZoneNames timeZoneNames, List<ZoneInfo> zoneInfos) {
    // This algorithm works backwards through all the zone info periods by incrementing an
    // "offset from the end". It looks for periods that "match". In this case "match" means
    // "have the same zone properties, or *could* have the same zone properties if it were not
    // for different start times". If two or more matching zone offset periods are found with
    // different start times it splits the longer ones in two so that periods then exist with
    // the same offset with the same start and end times. It keeps going backwards through the
    // periods for all the zoneinfos until no two periods with the same offset match.
    // True if any of the zones have the matching properties. When false this is the stopping
    // condition for the loop that steps backwards through the zone offset periods.
    boolean anyZonesMatch;
    // The offset into the zone offset periods. Since we work in reverse (from the end of time),
    // offset = 1 means "the last period" offset = 2 means "the last but one period", etc.
    // We initialize at 0; it is incremented at the start of the do-while loop.
    int offsetFromEnd = 0;
    // at that offset.
    do {
        offsetFromEnd += 1;
        // Reset our stopping condition. The offsetFromEnd loop will stop if this stays false.
        anyZonesMatch = false;
        // Keep track of which zoneinfos have been processed for the current offsetFromEnd so
        // we don't process them again.
        boolean[] processed = new boolean[zoneInfos.size()];
        // splits the matching periods as needed.
        for (int i = 0; i < zoneInfos.size(); i++) {
            if (processed[i]) {
                // loop. Skip.
                continue;
            }
            processed[i] = true;
            // Get zoneinfo[i] so we can use its zone properties to find all matching periods.
            ZoneInfo iZoneInfo = zoneInfos.get(i);
            ZoneOffsetPeriod iPeriod = getOffsetPeriodAtOffsetFromEndOrNull(iZoneInfo, offsetFromEnd);
            if (iPeriod == null) {
                // We've run out of periods for this zoneinfo. Skip.
                continue;
            }
            // Pass 1: Find all zoneinfos that have a period at offsetFromEnd that matches the
            // same period at offsetFromEnd from zoneinfo[i]. Also work out the instant that
            // they would need to be split at.
            boolean[] matchAtOffsetFromEnd = new boolean[zoneInfos.size()];
            // zoneinfo[i] matches itself.
            matchAtOffsetFromEnd[i] = true;
            Instant toSplitInstant = iPeriod.getStartInstant();
            for (int j = i + 1; j < zoneInfos.size(); j++) {
                if (processed[j]) {
                    // processed.
                    continue;
                }
                ZoneInfo jZoneInfo = zoneInfos.get(j);
                ZoneOffsetPeriod jPeriod = getOffsetPeriodAtOffsetFromEndOrNull(jZoneInfo, offsetFromEnd);
                if (jPeriod == null) {
                    // We've run out of periods for this zoneinfo. Skip and make sure we don't
                    // look at it again.
                    processed[j] = true;
                    continue;
                }
                if (isMatch(iPeriod, jPeriod)) {
                    // At least one pair of zones have similar properties so we get to loop
                    // around the outer loop at least once more.
                    anyZonesMatch = true;
                    // Mark zoneinfo[j] as being a match for zoneinfo[i] at offset.
                    matchAtOffsetFromEnd[j] = true;
                    if (jPeriod.getStartInstant().isAfter(toSplitInstant)) {
                        // Keep track of the max start instant for pass 2.
                        toSplitInstant = jPeriod.getStartInstant();
                    }
                }
            }
            // (if needed).
            for (int j = i; j < zoneInfos.size(); j++) {
                if (!matchAtOffsetFromEnd[j]) {
                    continue;
                }
                ZoneInfo jZoneInfo = zoneInfos.get(j);
                int jIndex = jZoneInfo.getZoneOffsetPeriodCount() - offsetFromEnd;
                ZoneOffsetPeriod jPeriod = jZoneInfo.getZoneOffsetPeriod(jIndex);
                if (!jPeriod.getStartInstant().equals(toSplitInstant)) {
                    ZoneInfo.splitZoneOffsetPeriodAtTime(timeZoneNames, jZoneInfo, jIndex, toSplitInstant);
                }
                processed[j] = true;
            }
        }
    } while (anyZonesMatch);
}
#end_block

#method_before
public static InetAddress[] blockingResolveAllLocally(Network network, String name) throws UnknownHostException {
    final StructAddrinfo hints = new StructAddrinfo();
    // Unnecessary, but expressly no AI_ADDRCONFIG.
    hints.ai_flags = 0;
    // Fetch all IP addresses at once to minimize re-resolution.
    hints.ai_family = OsConstants.AF_UNSPEC;
    hints.ai_socktype = OsConstants.SOCK_DGRAM;
    final Network networkForResolv = getNetworkWithUseLocalNameserversFlag(network);
    try {
        return Libcore.os.android_getaddrinfo(name, hints, (int) networkForResolv.netId);
    } catch (GaiException gai) {
        gai.rethrowAsUnknownHostException("TLS-bypass resolution failed");
        // keep compiler quiet
        return null;
    }
}
#method_after
public static InetAddress[] blockingResolveAllLocally(Network network, String name) throws UnknownHostException {
    final StructAddrinfo hints = new StructAddrinfo();
    // Unnecessary, but expressly no AI_ADDRCONFIG.
    hints.ai_flags = 0;
    // Fetch all IP addresses at once to minimize re-resolution.
    hints.ai_family = OsConstants.AF_UNSPEC;
    hints.ai_socktype = OsConstants.SOCK_DGRAM;
    final Network networkForResolv = getNetworkWithUseLocalNameserversFlag(network);
    try {
        return Libcore.os.android_getaddrinfo(name, hints, (int) networkForResolv.netId);
    } catch (GaiException gai) {
        gai.rethrowAsUnknownHostException(name + ": TLS-bypass resolution failed");
        // keep compiler quiet
        return null;
    }
}
#end_block

#method_before
@Override
public void uncaughtException(Thread t, Throwable e) {
    if (loggingHandler != null && !loggingHandler.mTriggered) {
        try {
            loggingHandler.uncaughtException(t, e);
        } catch (Throwable loggingThrowable) {
        // Ignored.
        }
    }
    try {
        // Don't re-enter -- avoid infinite loops if crash-reporting crashes.
        if (mCrashing)
            return;
        mCrashing = true;
        // flush the buffer. (This makes method trace profiling useful to debug crashes.)
        if (ActivityThread.currentActivityThread() != null) {
            ActivityThread.currentActivityThread().stopProfiling();
        }
        // Bring up crash dialog, wait for it to be dismissed
        ActivityManager.getService().handleApplicationCrash(mApplicationObject, new ApplicationErrorReport.ParcelableCrashInfo(e));
    } catch (Throwable t2) {
        if (t2 instanceof DeadObjectException) {
        // System process is dead; ignore
        } else {
            try {
                Clog_e(TAG, "Error reporting crash", t2);
            } catch (Throwable t3) {
            // Even Clog_e() fails!  Oh well.
            }
        }
    } finally {
        // Try everything to make sure this process goes away.
        Process.killProcess(Process.myPid());
        System.exit(10);
    }
}
#method_after
@Override
public void uncaughtException(Thread t, Throwable e) {
    try {
        ensureLogging(t, e);
        // Don't re-enter -- avoid infinite loops if crash-reporting crashes.
        if (mCrashing)
            return;
        mCrashing = true;
        // flush the buffer. (This makes method trace profiling useful to debug crashes.)
        if (ActivityThread.currentActivityThread() != null) {
            ActivityThread.currentActivityThread().stopProfiling();
        }
        // Bring up crash dialog, wait for it to be dismissed
        ActivityManager.getService().handleApplicationCrash(mApplicationObject, new ApplicationErrorReport.ParcelableCrashInfo(e));
    } catch (Throwable t2) {
        if (t2 instanceof DeadObjectException) {
        // System process is dead; ignore
        } else {
            try {
                Clog_e(TAG, "Error reporting crash", t2);
            } catch (Throwable t3) {
            // Even Clog_e() fails!  Oh well.
            }
        }
    } finally {
        // Try everything to make sure this process goes away.
        Process.killProcess(Process.myPid());
        System.exit(10);
    }
}
#end_block

#method_before
public int read(ByteBuffer dst) throws IOException {
    ensureOpen();
    if (!readable)
        throw new NonReadableChannelException();
    synchronized (positionLock) {
        int n = 0;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return 0;
            do {
                n = IOUtil.read(fd, dst, -1, nd);
            } while ((n == IOStatus.INTERRUPTED) && isOpen());
            return IOStatus.normalize(n);
        } finally {
            threads.remove(ti);
            end(n > 0);
            assert IOStatus.check(n);
        }
    }
}
#method_after
// END Android-added: CloseGuard support.
public int read(ByteBuffer dst) throws IOException {
    ensureOpen();
    if (!readable)
        throw new NonReadableChannelException();
    synchronized (positionLock) {
        int n = 0;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return 0;
            do {
                n = IOUtil.read(fd, dst, -1, nd);
            } while ((n == IOStatus.INTERRUPTED) && isOpen());
            return IOStatus.normalize(n);
        } finally {
            threads.remove(ti);
            end(n > 0);
            assert IOStatus.check(n);
        }
    }
}
#end_block

#method_before
// -- Other operations --
public long position() throws IOException {
    ensureOpen();
    synchronized (positionLock) {
        long p = -1;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return 0;
            // when position() is not followed by a read/write operation.
            if (append) {
                BlockGuard.getThreadPolicy().onWriteToDisk();
            }
            do {
                // in append-mode then position is advanced to end before writing
                p = (append) ? nd.size(fd) : position0(fd, -1);
            } while ((p == IOStatus.INTERRUPTED) && isOpen());
            return IOStatus.normalize(p);
        } finally {
            threads.remove(ti);
            end(p > -1);
            assert IOStatus.check(p);
        }
    }
}
#method_after
// -- Other operations --
public long position() throws IOException {
    ensureOpen();
    synchronized (positionLock) {
        long p = -1;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return 0;
            // when position() is not followed by a read/write operation. http://b/77263638
            if (append) {
                BlockGuard.getThreadPolicy().onWriteToDisk();
            }
            // END Android-added: BlockGuard support.
            do {
                // in append-mode then position is advanced to end before writing
                p = (append) ? nd.size(fd) : position0(fd, -1);
            } while ((p == IOStatus.INTERRUPTED) && isOpen());
            return IOStatus.normalize(p);
        } finally {
            threads.remove(ti);
            end(p > -1);
            assert IOStatus.check(p);
        }
    }
}
#end_block

#method_before
public FileChannel position(long newPosition) throws IOException {
    ensureOpen();
    if (newPosition < 0)
        throw new IllegalArgumentException();
    synchronized (positionLock) {
        long p = -1;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return null;
            // Android-added: BlockGuard support.
            // Note: position() itself doesn't seem to block, so this may be overzealous
            // when position() is not followed by a read/write operation.
            BlockGuard.getThreadPolicy().onReadFromDisk();
            do {
                p = position0(fd, newPosition);
            } while ((p == IOStatus.INTERRUPTED) && isOpen());
            return this;
        } finally {
            threads.remove(ti);
            end(p > -1);
            assert IOStatus.check(p);
        }
    }
}
#method_after
public FileChannel position(long newPosition) throws IOException {
    ensureOpen();
    if (newPosition < 0)
        throw new IllegalArgumentException();
    synchronized (positionLock) {
        long p = -1;
        int ti = -1;
        try {
            begin();
            ti = threads.add();
            if (!isOpen())
                return null;
            // Android-added: BlockGuard support.
            // Note: position() itself doesn't seem to block, so this may be overzealous
            // when position() is not followed by a read/write operation. http://b/77263638
            BlockGuard.getThreadPolicy().onReadFromDisk();
            do {
                p = position0(fd, newPosition);
            } while ((p == IOStatus.INTERRUPTED) && isOpen());
            return this;
        } finally {
            threads.remove(ti);
            end(p > -1);
            assert IOStatus.check(p);
        }
    }
}
#end_block

#method_before
public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
    ensureOpen();
    if (mode == null)
        throw new NullPointerException("Mode is null");
    if (position < 0L)
        throw new IllegalArgumentException("Negative position");
    if (size < 0L)
        throw new IllegalArgumentException("Negative size");
    if (position + size < 0)
        throw new IllegalArgumentException("Position + size overflow");
    if (size > Integer.MAX_VALUE)
        throw new IllegalArgumentException("Size exceeds Integer.MAX_VALUE");
    int imode = -1;
    if (mode == MapMode.READ_ONLY)
        imode = MAP_RO;
    else if (mode == MapMode.READ_WRITE)
        imode = MAP_RW;
    else if (mode == MapMode.PRIVATE)
        imode = MAP_PV;
    assert (imode >= 0);
    if ((mode != MapMode.READ_ONLY) && !writable)
        throw new NonWritableChannelException();
    if (!readable)
        throw new NonReadableChannelException();
    long addr = -1;
    int ti = -1;
    try {
        begin();
        ti = threads.add();
        if (!isOpen())
            return null;
        long filesize;
        do {
            filesize = nd.size(fd);
        } while ((filesize == IOStatus.INTERRUPTED) && isOpen());
        if (!isOpen())
            return null;
        if (filesize < position + size) {
            // Extend file size
            // BEGIN Android-changed
            /*
                if (!writable) {
                    throw new IOException("Channel not open for writing " +
                        "- cannot extend file to required size");
                }
                */
            // END Android-changed
            int rv;
            do {
                // rv = nd.truncate(fd, position + size);
                try {
                    rv = nd.truncate(fd, position + size);
                } catch (IOException r) {
                    try {
                        if (android.system.OsConstants.S_ISREG(Libcore.os.fstat(fd).st_mode)) {
                            throw r;
                        }
                    } catch (ErrnoException e) {
                        e.rethrowAsIOException();
                    }
                    break;
                }
            // END Android-changed: Ignore failed truncation for non-regular files.
            } while ((rv == IOStatus.INTERRUPTED) && isOpen());
            if (!isOpen())
                return null;
        }
        if (size == 0) {
            addr = 0;
            // a valid file descriptor is not required
            FileDescriptor dummy = new FileDescriptor();
            /*
                if ((!writable) || (imode == MAP_RO))
                    return Util.newMappedByteBufferR(0, 0, dummy, null);
                else
                    return Util.newMappedByteBuffer(0, 0, dummy, null);
                */
            return new DirectByteBuffer(0, 0, dummy, null, (!writable) || (imode == MAP_RO));
        }
        int pagePosition = (int) (position % allocationGranularity);
        long mapPosition = position - pagePosition;
        long mapSize = size + pagePosition;
        try {
            // Android-added: BlockGuard support.
            BlockGuard.getThreadPolicy().onReadFromDisk();
            // If no exception was thrown from map0, the address is valid
            addr = map0(imode, mapPosition, mapSize);
        } catch (OutOfMemoryError x) {
            // An OutOfMemoryError may indicate that we've exhausted memory
            // so force gc and re-attempt map
            System.gc();
            try {
                Thread.sleep(100);
            } catch (InterruptedException y) {
                Thread.currentThread().interrupt();
            }
            try {
                addr = map0(imode, mapPosition, mapSize);
            } catch (OutOfMemoryError y) {
                // After a second OOME, fail
                throw new IOException("Map failed", y);
            }
        }
        // On Windows, and potentially other platforms, we need an open
        // file descriptor for some mapping operations.
        FileDescriptor mfd;
        try {
            mfd = nd.duplicateForMapping(fd);
        } catch (IOException ioe) {
            unmap0(addr, mapSize);
            throw ioe;
        }
        assert (IOStatus.checkAll(addr));
        assert (addr % allocationGranularity == 0);
        int isize = (int) size;
        Unmapper um = new Unmapper(addr, mapSize, isize, mfd);
        /*
            if ((!writable) || (imode == MAP_RO)) {
                return Util.newMappedByteBufferR(isize,
                                                 addr + pagePosition,
                                                 mfd,
                                                 um);
            } else {
                return Util.newMappedByteBuffer(isize,
                                                addr + pagePosition,
                                                mfd,
                                                um);
            }
            */
        return new DirectByteBuffer(isize, addr + pagePosition, mfd, um, (!writable) || (imode == MAP_RO));
    } finally {
        threads.remove(ti);
        end(IOStatus.checkAll(addr));
    }
}
#method_after
public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
    ensureOpen();
    if (mode == null)
        throw new NullPointerException("Mode is null");
    if (position < 0L)
        throw new IllegalArgumentException("Negative position");
    if (size < 0L)
        throw new IllegalArgumentException("Negative size");
    if (position + size < 0)
        throw new IllegalArgumentException("Position + size overflow");
    if (size > Integer.MAX_VALUE)
        throw new IllegalArgumentException("Size exceeds Integer.MAX_VALUE");
    int imode = -1;
    if (mode == MapMode.READ_ONLY)
        imode = MAP_RO;
    else if (mode == MapMode.READ_WRITE)
        imode = MAP_RW;
    else if (mode == MapMode.PRIVATE)
        imode = MAP_PV;
    assert (imode >= 0);
    if ((mode != MapMode.READ_ONLY) && !writable)
        throw new NonWritableChannelException();
    if (!readable)
        throw new NonReadableChannelException();
    long addr = -1;
    int ti = -1;
    try {
        begin();
        ti = threads.add();
        if (!isOpen())
            return null;
        long filesize;
        do {
            filesize = nd.size(fd);
        } while ((filesize == IOStatus.INTERRUPTED) && isOpen());
        if (!isOpen())
            return null;
        if (filesize < position + size) {
            // Extend file size
            // BEGIN Android-changed: Unexplained, needs investigation. http://b/77513071
            /*
                if (!writable) {
                    throw new IOException("Channel not open for writing " +
                        "- cannot extend file to required size");
                }
                */
            // END Android-changed: Unexplained, needs investigation. http://b/77513071
            int rv;
            do {
                // rv = nd.truncate(fd, position + size);
                try {
                    rv = nd.truncate(fd, position + size);
                } catch (IOException r) {
                    try {
                        if (android.system.OsConstants.S_ISREG(Libcore.os.fstat(fd).st_mode)) {
                            throw r;
                        }
                    } catch (ErrnoException e) {
                        e.rethrowAsIOException();
                    }
                    break;
                }
            // END Android-changed: Ignore failed truncation for non-regular files.
            } while ((rv == IOStatus.INTERRUPTED) && isOpen());
            if (!isOpen())
                return null;
        }
        if (size == 0) {
            addr = 0;
            // a valid file descriptor is not required
            FileDescriptor dummy = new FileDescriptor();
            /*
                if ((!writable) || (imode == MAP_RO))
                    return Util.newMappedByteBufferR(0, 0, dummy, null);
                else
                    return Util.newMappedByteBuffer(0, 0, dummy, null);
                */
            return new DirectByteBuffer(0, 0, dummy, null, (!writable) || (imode == MAP_RO));
        }
        int pagePosition = (int) (position % allocationGranularity);
        long mapPosition = position - pagePosition;
        long mapSize = size + pagePosition;
        try {
            // Android-added: BlockGuard support.
            BlockGuard.getThreadPolicy().onReadFromDisk();
            // If no exception was thrown from map0, the address is valid
            addr = map0(imode, mapPosition, mapSize);
        } catch (OutOfMemoryError x) {
            // An OutOfMemoryError may indicate that we've exhausted memory
            // so force gc and re-attempt map
            System.gc();
            try {
                Thread.sleep(100);
            } catch (InterruptedException y) {
                Thread.currentThread().interrupt();
            }
            try {
                addr = map0(imode, mapPosition, mapSize);
            } catch (OutOfMemoryError y) {
                // After a second OOME, fail
                throw new IOException("Map failed", y);
            }
        }
        // On Windows, and potentially other platforms, we need an open
        // file descriptor for some mapping operations.
        FileDescriptor mfd;
        try {
            mfd = nd.duplicateForMapping(fd);
        } catch (IOException ioe) {
            unmap0(addr, mapSize);
            throw ioe;
        }
        assert (IOStatus.checkAll(addr));
        assert (addr % allocationGranularity == 0);
        int isize = (int) size;
        Unmapper um = new Unmapper(addr, mapSize, isize, mfd);
        /*
            if ((!writable) || (imode == MAP_RO)) {
                return Util.newMappedByteBufferR(isize,
                                                 addr + pagePosition,
                                                 mfd,
                                                 um);
            } else {
                return Util.newMappedByteBuffer(isize,
                                                addr + pagePosition,
                                                mfd,
                                                um);
            }
            */
        return new DirectByteBuffer(isize, addr + pagePosition, mfd, um, (!writable) || (imode == MAP_RO));
    } finally {
        threads.remove(ti);
        end(IOStatus.checkAll(addr));
    }
}
#end_block

#method_before
@Override
public void interfaceStatusChanged(String iface, boolean up) {
    // See NetlinkHandler.cpp:71.
    if (VDBG)
        Log.d(TAG, "interfaceStatusChanged " + iface + ", " + up);
    synchronized (mPublicSync) {
        if (up) {
            maybeTrackNewInterfaceLocked(iface);
        } else {
            if (ifaceNameToType(iface) == ConnectivityManager.TETHERING_BLUETOOTH) {
                stopTrackingInterfaceLocked(iface);
            } else {
                // through the WifiManager.WIFI_AP_STATE_CHANGED_ACTION intent.
                if (VDBG)
                    Log.d(TAG, "ignore interface down for " + iface);
            }
        }
    }
}
#method_after
@Override
public void interfaceStatusChanged(String iface, boolean up) {
    // See NetlinkHandler.cpp:71.
    if (VDBG)
        Log.d(TAG, "interfaceStatusChanged " + iface + ", " + up);
    synchronized (mPublicSync) {
        if (up) {
            maybeTrackNewInterfaceLocked(iface);
        } else {
            if (ifaceNameToType(iface) == TETHERING_BLUETOOTH) {
                stopTrackingInterfaceLocked(iface);
            } else {
                // through the WifiManager.WIFI_AP_STATE_CHANGED_ACTION intent.
                if (VDBG)
                    Log.d(TAG, "ignore interface down for " + iface);
            }
        }
    }
}
#end_block

#method_before
private int ifaceNameToType(String iface) {
    final TetheringConfiguration cfg = mConfig;
    if (cfg.isWifi(iface)) {
        return ConnectivityManager.TETHERING_WIFI;
    } else if (cfg.isUsb(iface)) {
        return ConnectivityManager.TETHERING_USB;
    } else if (cfg.isBluetooth(iface)) {
        return ConnectivityManager.TETHERING_BLUETOOTH;
    }
    return ConnectivityManager.TETHERING_INVALID;
}
#method_after
private int ifaceNameToType(String iface) {
    final TetheringConfiguration cfg = mConfig;
    if (cfg.isWifi(iface)) {
        return TETHERING_WIFI;
    } else if (cfg.isUsb(iface)) {
        return TETHERING_USB;
    } else if (cfg.isBluetooth(iface)) {
        return TETHERING_BLUETOOTH;
    }
    return TETHERING_INVALID;
}
#end_block

#method_before
private void enableTetheringInternal(int type, boolean enable, ResultReceiver receiver) {
    boolean isProvisioningRequired = enable && isTetherProvisioningRequired();
    int result;
    switch(type) {
        case ConnectivityManager.TETHERING_WIFI:
            result = setWifiTethering(enable);
            if (isProvisioningRequired && result == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case ConnectivityManager.TETHERING_USB:
            result = setUsbTethering(enable);
            if (isProvisioningRequired && result == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case ConnectivityManager.TETHERING_BLUETOOTH:
            setBluetoothTethering(enable, receiver);
            break;
        default:
            Log.w(TAG, "Invalid tether type.");
            sendTetherResult(receiver, ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE);
    }
}
#method_after
private void enableTetheringInternal(int type, boolean enable, ResultReceiver receiver) {
    boolean isProvisioningRequired = enable && isTetherProvisioningRequired();
    int result;
    switch(type) {
        case TETHERING_WIFI:
            result = setWifiTethering(enable);
            if (isProvisioningRequired && result == TETHER_ERROR_NO_ERROR) {
                scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case TETHERING_USB:
            result = setUsbTethering(enable);
            if (isProvisioningRequired && result == TETHER_ERROR_NO_ERROR) {
                scheduleProvisioningRechecks(type);
            }
            sendTetherResult(receiver, result);
            break;
        case TETHERING_BLUETOOTH:
            setBluetoothTethering(enable, receiver);
            break;
        default:
            Log.w(TAG, "Invalid tether type.");
            sendTetherResult(receiver, TETHER_ERROR_UNKNOWN_IFACE);
    }
}
#end_block

#method_before
private int setWifiTethering(final boolean enable) {
    int rval = ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
    final long ident = Binder.clearCallingIdentity();
    try {
        synchronized (mPublicSync) {
            mWifiTetherRequested = enable;
            final WifiManager mgr = getWifiManager();
            if ((enable && mgr.startSoftAp(null)) || (!enable && mgr.stopSoftAp())) {
                rval = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return rval;
}
#method_after
private int setWifiTethering(final boolean enable) {
    int rval = TETHER_ERROR_MASTER_ERROR;
    final long ident = Binder.clearCallingIdentity();
    try {
        synchronized (mPublicSync) {
            mWifiTetherRequested = enable;
            final WifiManager mgr = getWifiManager();
            if ((enable && mgr.startSoftAp(null)) || (!enable && mgr.stopSoftAp())) {
                rval = TETHER_ERROR_NO_ERROR;
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return rval;
}
#end_block

#method_before
private void setBluetoothTethering(final boolean enable, final ResultReceiver receiver) {
    final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter == null || !adapter.isEnabled()) {
        Log.w(TAG, "Tried to enable bluetooth tethering with null or disabled adapter. null: " + (adapter == null));
        sendTetherResult(receiver, ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL);
        return;
    }
    adapter.getProfileProxy(mContext, new ServiceListener() {

        @Override
        public void onServiceDisconnected(int profile) {
        }

        @Override
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            ((BluetoothPan) proxy).setBluetoothTethering(enable);
            // TODO: Enabling bluetooth tethering can fail asynchronously here.
            // We should figure out a way to bubble up that failure instead of sending success.
            int result = ((BluetoothPan) proxy).isTetheringOn() == enable ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
            sendTetherResult(receiver, result);
            if (enable && isTetherProvisioningRequired()) {
                scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
            }
            adapter.closeProfileProxy(BluetoothProfile.PAN, proxy);
        }
    }, BluetoothProfile.PAN);
}
#method_after
private void setBluetoothTethering(final boolean enable, final ResultReceiver receiver) {
    final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter == null || !adapter.isEnabled()) {
        Log.w(TAG, "Tried to enable bluetooth tethering with null or disabled adapter. null: " + (adapter == null));
        sendTetherResult(receiver, TETHER_ERROR_SERVICE_UNAVAIL);
        return;
    }
    adapter.getProfileProxy(mContext, new ServiceListener() {

        @Override
        public void onServiceDisconnected(int profile) {
        }

        @Override
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            ((BluetoothPan) proxy).setBluetoothTethering(enable);
            // TODO: Enabling bluetooth tethering can fail asynchronously here.
            // We should figure out a way to bubble up that failure instead of sending success.
            final int result = (((BluetoothPan) proxy).isTetheringOn() == enable) ? TETHER_ERROR_NO_ERROR : TETHER_ERROR_MASTER_ERROR;
            sendTetherResult(receiver, result);
            if (enable && isTetherProvisioningRequired()) {
                scheduleProvisioningRechecks(TETHERING_BLUETOOTH);
            }
            adapter.closeProfileProxy(BluetoothProfile.PAN, proxy);
        }
    }, BluetoothProfile.PAN);
}
#end_block

#method_before
private void sendUiTetherProvisionIntent(int type, ResultReceiver receiver) {
    Intent intent = new Intent(Settings.ACTION_TETHER_PROVISIONING);
    intent.putExtra(ConnectivityManager.EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(ConnectivityManager.EXTRA_PROVISION_CALLBACK, receiver);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startActivityAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
private void sendUiTetherProvisionIntent(int type, ResultReceiver receiver) {
    Intent intent = new Intent(Settings.ACTION_TETHER_PROVISIONING);
    intent.putExtra(EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(EXTRA_PROVISION_CALLBACK, receiver);
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startActivityAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
private ResultReceiver getProxyReceiver(final int type, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(null) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            // If provisioning is successful, enable tethering, otherwise just send the error.
            if (resultCode == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                enableTetheringInternal(type, true, receiver);
            } else {
                sendTetherResult(receiver, resultCode);
            }
        }
    };
    // The following is necessary to avoid unmarshalling issues when sending the receiver
    // across processes.
    Parcel parcel = Parcel.obtain();
    rr.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    ResultReceiver receiverForSending = ResultReceiver.CREATOR.createFromParcel(parcel);
    parcel.recycle();
    return receiverForSending;
}
#method_after
private ResultReceiver getProxyReceiver(final int type, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(null) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            // If provisioning is successful, enable tethering, otherwise just send the error.
            if (resultCode == TETHER_ERROR_NO_ERROR) {
                enableTetheringInternal(type, true, receiver);
            } else {
                sendTetherResult(receiver, resultCode);
            }
        }
    };
    // The following is necessary to avoid unmarshalling issues when sending the receiver
    // across processes.
    Parcel parcel = Parcel.obtain();
    rr.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    ResultReceiver receiverForSending = ResultReceiver.CREATOR.createFromParcel(parcel);
    parcel.recycle();
    return receiverForSending;
}
#end_block

#method_before
private void scheduleProvisioningRechecks(int type) {
    Intent intent = new Intent();
    intent.putExtra(ConnectivityManager.EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(ConnectivityManager.EXTRA_SET_ALARM, true);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
private void scheduleProvisioningRechecks(int type) {
    Intent intent = new Intent();
    intent.putExtra(EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(EXTRA_SET_ALARM, true);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
private void sendSilentTetherProvisionIntent(int type, ResultReceiver receiver) {
    Intent intent = new Intent();
    intent.putExtra(ConnectivityManager.EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(ConnectivityManager.EXTRA_RUN_PROVISION, true);
    intent.putExtra(ConnectivityManager.EXTRA_PROVISION_CALLBACK, receiver);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
private void sendSilentTetherProvisionIntent(int type, ResultReceiver receiver) {
    Intent intent = new Intent();
    intent.putExtra(EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(EXTRA_RUN_PROVISION, true);
    intent.putExtra(EXTRA_PROVISION_CALLBACK, receiver);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
private void cancelTetherProvisioningRechecks(int type) {
    if (mDependencies.isTetheringSupported()) {
        Intent intent = new Intent();
        intent.putExtra(ConnectivityManager.EXTRA_REM_TETHER_TYPE, type);
        intent.setComponent(TETHER_SERVICE);
        final long ident = Binder.clearCallingIdentity();
        try {
            mContext.startServiceAsUser(intent, UserHandle.CURRENT);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
private void cancelTetherProvisioningRechecks(int type) {
    if (mDeps.isTetheringSupported()) {
        Intent intent = new Intent();
        intent.putExtra(EXTRA_REM_TETHER_TYPE, type);
        intent.setComponent(TETHER_SERVICE);
        final long ident = Binder.clearCallingIdentity();
        try {
            mContext.startServiceAsUser(intent, UserHandle.CURRENT);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
// Used by the SIM card change observation code.
private void startProvisionIntent(int tetherType) {
    final Intent startProvIntent = new Intent();
    startProvIntent.putExtra(ConnectivityManager.EXTRA_ADD_TETHER_TYPE, tetherType);
    startProvIntent.putExtra(ConnectivityManager.EXTRA_RUN_PROVISION, true);
    startProvIntent.setComponent(TETHER_SERVICE);
    mContext.startServiceAsUser(startProvIntent, UserHandle.CURRENT);
}
#method_after
// Used by the SIM card change observation code.
private void startProvisionIntent(int tetherType) {
    final Intent startProvIntent = new Intent();
    startProvIntent.putExtra(EXTRA_ADD_TETHER_TYPE, tetherType);
    startProvIntent.putExtra(EXTRA_RUN_PROVISION, true);
    startProvIntent.setComponent(TETHER_SERVICE);
    mContext.startServiceAsUser(startProvIntent, UserHandle.CURRENT);
}
#end_block

#method_before
private int tether(String iface, int requestedState) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        // NOTE: If a CMD_TETHER_REQUESTED message is already in the TISM's
        // queue but not yet processed, this will be a no-op and it will not
        // return an error.
        // 
        // TODO: reexamine the threading and messaging model.
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, requestedState);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#method_after
private int tether(String iface, int requestedState) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return TETHER_ERROR_UNAVAIL_IFACE;
        }
        // NOTE: If a CMD_TETHER_REQUESTED message is already in the TISM's
        // queue but not yet processed, this will be a no-op and it will not
        // return an error.
        // 
        // TODO: reexamine the threading and messaging model.
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, requestedState);
        return TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (!tetherState.isCurrentlyServing()) {
            Log.e(TAG, "Tried to untether an inactive iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#method_after
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (!tetherState.isCurrentlyServing()) {
            Log.e(TAG, "Tried to untether an inactive iface :" + iface + ", ignoring");
            return TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
        return TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
public void untetherAll() {
    stopTethering(ConnectivityManager.TETHERING_WIFI);
    stopTethering(ConnectivityManager.TETHERING_USB);
    stopTethering(ConnectivityManager.TETHERING_BLUETOOTH);
}
#method_after
public void untetherAll() {
    stopTethering(TETHERING_WIFI);
    stopTethering(TETHERING_USB);
    stopTethering(TETHERING_BLUETOOTH);
}
#end_block

#method_before
public int getLastTetherError(String iface) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to getLastTetherError on an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        return tetherState.lastError;
    }
}
#method_after
public int getLastTetherError(String iface) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to getLastTetherError on an unknown iface :" + iface + ", ignoring");
            return TETHER_ERROR_UNKNOWN_IFACE;
        }
        return tetherState.lastError;
    }
}
#end_block

#method_before
private void sendTetherStateChangedBroadcast() {
    if (!mDependencies.isTetheringSupported())
        return;
    final ArrayList<String> availableList = new ArrayList<>();
    final ArrayList<String> tetherList = new ArrayList<>();
    final ArrayList<String> localOnlyList = new ArrayList<>();
    final ArrayList<String> erroredList = new ArrayList<>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_ONLY) {
                localOnlyList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                tetherList.add(iface);
            }
        }
    }
    final Intent bcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    bcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER, availableList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_LOCAL_ONLY, localOnlyList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, tetherList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(bcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast %s=[%s] %s=[%s] %s=[%s] %s=[%s]", "avail", TextUtils.join(",", availableList), "local_only", TextUtils.join(",", localOnlyList), "tether", TextUtils.join(",", tetherList), "error", TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            showTetheredNotification(SystemMessage.NOTE_TETHER_USB);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(SystemMessage.NOTE_TETHER_BLUETOOTH);
    } else {
        clearTetheredNotification();
    }
}
#method_after
private void sendTetherStateChangedBroadcast() {
    if (!mDeps.isTetheringSupported())
        return;
    final ArrayList<String> availableList = new ArrayList<>();
    final ArrayList<String> tetherList = new ArrayList<>();
    final ArrayList<String> localOnlyList = new ArrayList<>();
    final ArrayList<String> erroredList = new ArrayList<>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.lastError != TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_ONLY) {
                localOnlyList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                tetherList.add(iface);
            }
        }
    }
    final Intent bcast = new Intent(ACTION_TETHER_STATE_CHANGED);
    bcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    bcast.putStringArrayListExtra(EXTRA_AVAILABLE_TETHER, availableList);
    bcast.putStringArrayListExtra(EXTRA_ACTIVE_LOCAL_ONLY, localOnlyList);
    bcast.putStringArrayListExtra(EXTRA_ACTIVE_TETHER, tetherList);
    bcast.putStringArrayListExtra(EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(bcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast %s=[%s] %s=[%s] %s=[%s] %s=[%s]", "avail", TextUtils.join(",", availableList), "local_only", TextUtils.join(",", localOnlyList), "tether", TextUtils.join(",", tetherList), "error", TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            showTetheredNotification(SystemMessage.NOTE_TETHER_USB);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(SystemMessage.NOTE_TETHER_GENERAL);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(SystemMessage.NOTE_TETHER_BLUETOOTH);
    } else {
        clearTetheredNotification();
    }
}
#end_block

#method_before
@Override
public void onReceive(Context content, Intent intent) {
    final String action = intent.getAction();
    if (action == null)
        return;
    if (action.equals(UsbManager.ACTION_USB_STATE)) {
        handleUsbAction(intent);
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
        handleConnectivityAction(intent);
    } else if (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) {
        handleWifiApAction(intent);
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        mLog.log("OBSERVED configuration changed");
        updateConfiguration();
    }
}
#method_after
@Override
public void onReceive(Context content, Intent intent) {
    final String action = intent.getAction();
    if (action == null)
        return;
    if (action.equals(UsbManager.ACTION_USB_STATE)) {
        handleUsbAction(intent);
    } else if (action.equals(CONNECTIVITY_ACTION)) {
        handleConnectivityAction(intent);
    } else if (action.equals(WifiManager.WIFI_AP_STATE_CHANGED_ACTION)) {
        handleWifiApAction(intent);
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        mLog.log("OBSERVED configuration changed");
        updateConfiguration();
    }
}
#end_block

#method_before
private void handleConnectivityAction(Intent intent) {
    final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(ConnectivityManager.EXTRA_NETWORK_INFO);
    if (networkInfo == null || networkInfo.getDetailedState() == NetworkInfo.DetailedState.FAILED) {
        return;
    }
    if (VDBG)
        Log.d(TAG, "Tethering got CONNECTIVITY_ACTION: " + networkInfo.toString());
    mTetherMasterSM.sendMessage(TetherMasterSM.CMD_UPSTREAM_CHANGED);
}
#method_after
private void handleConnectivityAction(Intent intent) {
    final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(EXTRA_NETWORK_INFO);
    if (networkInfo == null || networkInfo.getDetailedState() == NetworkInfo.DetailedState.FAILED) {
        return;
    }
    if (VDBG)
        Log.d(TAG, "Tethering got CONNECTIVITY_ACTION: " + networkInfo.toString());
    mTetherMasterSM.sendMessage(TetherMasterSM.CMD_UPSTREAM_CHANGED);
}
#end_block

#method_before
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean usbConfigured = intent.getBooleanExtra(USB_CONFIGURED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    mLog.log(String.format("USB bcast connected:%s configured:%s rndis:%s", usbConnected, usbConfigured, rndisEnabled));
    // For more explanation, see b/62552150 .
    synchronized (Tethering.this.mPublicSync) {
        if (!usbConnected && mRndisEnabled) {
            // Turn off tethering if it was enabled and there is a disconnect.
            tetherMatchingInterfaces(IControlsTethering.STATE_AVAILABLE, ConnectivityManager.TETHERING_USB);
        } else if (usbConfigured && rndisEnabled) {
            // Tether if rndis is enabled and usb is configured.
            tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED, ConnectivityManager.TETHERING_USB);
        }
        mRndisEnabled = usbConfigured && rndisEnabled;
    }
}
#method_after
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean usbConfigured = intent.getBooleanExtra(USB_CONFIGURED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    mLog.log(String.format("USB bcast connected:%s configured:%s rndis:%s", usbConnected, usbConfigured, rndisEnabled));
    // For more explanation, see b/62552150 .
    synchronized (Tethering.this.mPublicSync) {
        if (!usbConnected && mRndisEnabled) {
            // Turn off tethering if it was enabled and there is a disconnect.
            tetherMatchingInterfaces(IControlsTethering.STATE_AVAILABLE, TETHERING_USB);
        } else if (usbConfigured && rndisEnabled) {
            // Tether if rndis is enabled and usb is configured.
            tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED, TETHERING_USB);
        }
        mRndisEnabled = usbConfigured && rndisEnabled;
    }
}
#end_block

#method_before
private void disableWifiIpServingLocked(String ifname, int apState) {
    mLog.log("Canceling WiFi tethering request - AP_STATE=" + apState);
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    // TODO: Remove this altogether, once Wi-Fi reliably gives us an
    // interface name with every broadcast.
    mWifiTetherRequested = false;
    if (!TextUtils.isEmpty(ifname)) {
        final TetherState ts = mTetherStates.get(ifname);
        if (ts != null) {
            ts.stateMachine.unwanted();
            return;
        }
    }
    for (int i = 0; i < mTetherStates.size(); i++) {
        TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
        if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
            tism.unwanted();
            return;
        }
    }
    mLog.log("Error disabling Wi-Fi IP serving; " + (TextUtils.isEmpty(ifname) ? "no interface name specified" : "specified interface: " + ifname));
}
#method_after
private void disableWifiIpServingLocked(String ifname, int apState) {
    mLog.log("Canceling WiFi tethering request - AP_STATE=" + apState);
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    // TODO: Remove this altogether, once Wi-Fi reliably gives us an
    // interface name with every broadcast.
    mWifiTetherRequested = false;
    if (!TextUtils.isEmpty(ifname)) {
        final TetherState ts = mTetherStates.get(ifname);
        if (ts != null) {
            ts.stateMachine.unwanted();
            return;
        }
    }
    for (int i = 0; i < mTetherStates.size(); i++) {
        TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
        if (tism.interfaceType() == TETHERING_WIFI) {
            tism.unwanted();
            return;
        }
    }
    mLog.log("Error disabling Wi-Fi IP serving; " + (TextUtils.isEmpty(ifname) ? "no interface name specified" : "specified interface: " + ifname));
}
#end_block

#method_before
private void enableWifiIpServingLocked(String ifname, int wifiIpMode) {
    // Map wifiIpMode values to IControlsTethering serving states, inferring
    // from mWifiTetherRequested as a final "best guess".
    final int ipServingMode;
    switch(wifiIpMode) {
        case IFACE_IP_MODE_TETHERED:
            ipServingMode = IControlsTethering.STATE_TETHERED;
            break;
        case IFACE_IP_MODE_LOCAL_ONLY:
            ipServingMode = IControlsTethering.STATE_LOCAL_ONLY;
            break;
        default:
            mLog.e("Cannot enable IP serving in unknown WiFi mode: " + wifiIpMode);
            return;
    }
    if (!TextUtils.isEmpty(ifname)) {
        maybeTrackNewInterfaceLocked(ifname, ConnectivityManager.TETHERING_WIFI);
        changeInterfaceState(ifname, ipServingMode);
    } else {
        mLog.e(String.format("Cannot enable IP serving in mode %s on missing interface name", ipServingMode));
    }
}
#method_after
private void enableWifiIpServingLocked(String ifname, int wifiIpMode) {
    // Map wifiIpMode values to IControlsTethering serving states, inferring
    // from mWifiTetherRequested as a final "best guess".
    final int ipServingMode;
    switch(wifiIpMode) {
        case IFACE_IP_MODE_TETHERED:
            ipServingMode = IControlsTethering.STATE_TETHERED;
            break;
        case IFACE_IP_MODE_LOCAL_ONLY:
            ipServingMode = IControlsTethering.STATE_LOCAL_ONLY;
            break;
        default:
            mLog.e("Cannot enable IP serving in unknown WiFi mode: " + wifiIpMode);
            return;
    }
    if (!TextUtils.isEmpty(ifname)) {
        maybeTrackNewInterfaceLocked(ifname, TETHERING_WIFI);
        changeInterfaceState(ifname, ipServingMode);
    } else {
        mLog.e(String.format("Cannot enable IP serving in mode %s on missing interface name", ipServingMode));
    }
}
#end_block

#method_before
private void changeInterfaceState(String ifname, int requestedState) {
    final int result;
    switch(requestedState) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            result = untether(ifname);
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            result = tether(ifname, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + ifname);
        return;
    }
}
#method_after
private void changeInterfaceState(String ifname, int requestedState) {
    final int result;
    switch(requestedState) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            result = untether(ifname);
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            result = tether(ifname, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + ifname);
        return;
    }
}
#end_block

#method_before
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = (UsbManager) mContext.getSystemService(Context.USB_SERVICE);
    synchronized (mPublicSync) {
        usbManager.setCurrentFunction(enable ? UsbManager.USB_FUNCTION_RNDIS : null, false);
    }
    return ConnectivityManager.TETHER_ERROR_NO_ERROR;
}
#method_after
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = (UsbManager) mContext.getSystemService(Context.USB_SERVICE);
    synchronized (mPublicSync) {
        usbManager.setCurrentFunction(enable ? UsbManager.USB_FUNCTION_RNDIS : null, false);
    }
    return TETHER_ERROR_NO_ERROR;
}
#end_block

#method_before
public String[] getErroredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#method_after
public String[] getErroredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastError != TETHER_ERROR_NO_ERROR) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
// Needed because the canonical source of upstream truth is just the
// upstream interface name, |mCurrentUpstreamIface|.  This is ripe for
private boolean pertainsToCurrentUpstream(NetworkState ns) {
    if (ns != null && ns.linkProperties != null && mCurrentUpstreamIface != null) {
        for (String ifname : ns.linkProperties.getAllInterfaceNames()) {
            if (mCurrentUpstreamIface.equals(ifname)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
// Needed because the canonical source of upstream truth is just the
private boolean pertainsToCurrentUpstream(NetworkState ns) {
    if (ns != null && ns.linkProperties != null && mCurrentUpstreamIfaceSet != null) {
        for (String ifname : ns.linkProperties.getAllInterfaceNames()) {
            if (mCurrentUpstreamIfaceSet.ifnames.contains(ifname)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private void reevaluateSimCardProvisioning() {
    if (!hasMobileHotspotProvisionApp())
        return;
    if (carrierConfigAffirmsEntitlementCheckNotRequired())
        return;
    ArrayList<Integer> tethered = new ArrayList<>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState != IControlsTethering.STATE_TETHERED) {
                // Skip interfaces that aren't tethered.
                continue;
            }
            String iface = mTetherStates.keyAt(i);
            int interfaceType = ifaceNameToType(iface);
            if (interfaceType != ConnectivityManager.TETHERING_INVALID) {
                tethered.add(interfaceType);
            }
        }
    }
    for (int tetherType : tethered) {
        startProvisionIntent(tetherType);
    }
}
#method_after
private void reevaluateSimCardProvisioning() {
    if (!hasMobileHotspotProvisionApp())
        return;
    if (carrierConfigAffirmsEntitlementCheckNotRequired())
        return;
    ArrayList<Integer> tethered = new ArrayList<>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState != IControlsTethering.STATE_TETHERED) {
                // Skip interfaces that aren't tethered.
                continue;
            }
            String iface = mTetherStates.keyAt(i);
            int interfaceType = ifaceNameToType(iface);
            if (interfaceType != TETHERING_INVALID) {
                tethered.add(interfaceType);
            }
        }
    }
    for (int tetherType : tethered) {
        startProvisionIntent(tetherType);
    }
}
#end_block

#method_before
protected void setUpstreamNetwork(NetworkState ns) {
    String iface = null;
    if (ns != null) {
        // Find the interface with the default IPv4 route. It may be the
        // interface described by linkProperties, or one of the interfaces
        // stacked on top of it.
        mLog.i("Looking for default routes on: " + ns.linkProperties);
        final String iface4 = getIPv4DefaultRouteInterface(ns);
        final String iface6 = getIPv6DefaultRouteInterface(ns);
        mLog.i("IPv4/IPv6 upstream interface(s): " + iface4 + "/" + iface6);
        iface = (iface4 != null) ? iface4 : null;
    }
    if (iface != null) {
        setDnsForwarders(ns.network, ns.linkProperties);
    }
    notifyDownstreamsOfNewUpstreamIface(iface);
    if (ns != null && pertainsToCurrentUpstream(ns)) {
        // If we already have NetworkState for this network examine
        // it immediately, because there likely will be no second
        // EVENT_ON_AVAILABLE (it was already received).
        handleNewUpstreamNetworkState(ns);
    } else if (mCurrentUpstreamIface == null) {
        // There are no available upstream networks, or none that
        // have an IPv4 default route (current metric for success).
        handleNewUpstreamNetworkState(null);
    }
}
#method_after
protected void setUpstreamNetwork(NetworkState ns) {
    InterfaceSet ifaces = null;
    if (ns != null) {
        // Find the interface with the default IPv4 route. It may be the
        // interface described by linkProperties, or one of the interfaces
        // stacked on top of it.
        mLog.i("Looking for default routes on: " + ns.linkProperties);
        ifaces = TetheringInterfaceUtils.getTetheringInterfaces(ns);
        mLog.i("Found upstream interface(s): " + ifaces);
    }
    if (ifaces != null) {
        setDnsForwarders(ns.network, ns.linkProperties);
    }
    notifyDownstreamsOfNewUpstreamIface(ifaces);
    if (ns != null && pertainsToCurrentUpstream(ns)) {
        // If we already have NetworkState for this network examine
        // it immediately, because there likely will be no second
        // EVENT_ON_AVAILABLE (it was already received).
        handleNewUpstreamNetworkState(ns);
    } else if (mCurrentUpstreamIfaceSet == null) {
        // There are no available upstream networks.
        handleNewUpstreamNetworkState(null);
    }
}
#end_block

#method_before
protected void notifyDownstreamsOfNewUpstreamIface(String ifaceName) {
    mLog.log("Notifying downstreams of upstream=" + ifaceName);
    mCurrentUpstreamIface = ifaceName;
    for (TetherInterfaceStateMachine sm : mNotifyList) {
        sm.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, ifaceName);
    }
}
#method_after
protected void notifyDownstreamsOfNewUpstreamIface(InterfaceSet ifaces) {
    mCurrentUpstreamIfaceSet = ifaces;
    for (TetherInterfaceStateMachine sm : mNotifyList) {
        sm.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, ifaces);
    }
}
#end_block

#method_before
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        // No need to notify OffloadController just yet as there are no
        // "offload-able" prefixes to pass along. This will handled
        // when the TISM informs Tethering of its LinkProperties.
        mForwardedDownstreams.add(who);
    } else {
        mOffload.excludeDownstreamInterface(who.interfaceName());
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_TETHERED);
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#method_after
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        // No need to notify OffloadController just yet as there are no
        // "offload-able" prefixes to pass along. This will handled
        // when the TISM informs Tethering of its LinkProperties.
        mForwardedDownstreams.add(who);
    } else {
        mOffload.excludeDownstreamInterface(who.interfaceName());
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_TETHERED);
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#end_block

#method_before
private void handleInterfaceServingStateInactive(TetherInterfaceStateMachine who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mOffload.excludeDownstreamInterface(who.interfaceName());
    mForwardedDownstreams.remove(who);
    // If this is a Wi-Fi interface, tell WifiManager of any errors.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        if (who.lastError() != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), IFACE_IP_MODE_CONFIGURATION_ERROR);
        }
    }
}
#method_after
private void handleInterfaceServingStateInactive(TetherInterfaceStateMachine who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mOffload.excludeDownstreamInterface(who.interfaceName());
    mForwardedDownstreams.remove(who);
    // If this is a Wi-Fi interface, tell WifiManager of any errors.
    if (who.interfaceType() == TETHERING_WIFI) {
        if (who.lastError() != TETHER_ERROR_NO_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), IFACE_IP_MODE_CONFIGURATION_ERROR);
        }
    }
}
#end_block

#method_before
private void handleUpstreamNetworkMonitorCallback(int arg1, Object o) {
    if (arg1 == UpstreamNetworkMonitor.NOTIFY_LOCAL_PREFIXES) {
        mOffload.sendOffloadExemptPrefixes((Set<IpPrefix>) o);
        return;
    }
    final NetworkState ns = (NetworkState) o;
    if (ns == null || !pertainsToCurrentUpstream(ns)) {
        // passing validation.
        if (mCurrentUpstreamIface == null) {
            // If we have no upstream interface, try to run through upstream
            // selection again.  If, for example, IPv4 connectivity has shown up
            // after IPv6 (e.g., 464xlat became available) we want the chance to
            // notice and act accordingly.
            chooseUpstreamType(false);
        }
        return;
    }
    switch(arg1) {
        case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
            // arrive there's nothing to do.
            break;
        case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
            handleNewUpstreamNetworkState(ns);
            break;
        case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
            setDnsForwarders(ns.network, ns.linkProperties);
            handleNewUpstreamNetworkState(ns);
            break;
        case UpstreamNetworkMonitor.EVENT_ON_LOST:
            // TODO: Re-evaluate possible upstreams. Currently upstream
            // reevaluation is triggered via received CONNECTIVITY_ACTION
            // broadcasts that result in being passed a
            // TetherMasterSM.CMD_UPSTREAM_CHANGED.
            handleNewUpstreamNetworkState(null);
            break;
        default:
            mLog.e("Unknown arg1 value: " + arg1);
            break;
    }
}
#method_after
private void handleUpstreamNetworkMonitorCallback(int arg1, Object o) {
    if (arg1 == UpstreamNetworkMonitor.NOTIFY_LOCAL_PREFIXES) {
        mOffload.sendOffloadExemptPrefixes((Set<IpPrefix>) o);
        return;
    }
    final NetworkState ns = (NetworkState) o;
    if (ns == null || !pertainsToCurrentUpstream(ns)) {
        // passing validation.
        if (mCurrentUpstreamIfaceSet == null) {
            // If we have no upstream interface, try to run through upstream
            // selection again.  If, for example, IPv4 connectivity has shown up
            // after IPv6 (e.g., 464xlat became available) we want the chance to
            // notice and act accordingly.
            chooseUpstreamType(false);
        }
        return;
    }
    switch(arg1) {
        case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
            // arrive there's nothing to do.
            break;
        case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
            handleNewUpstreamNetworkState(ns);
            break;
        case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
            chooseUpstreamType(false);
            break;
        case UpstreamNetworkMonitor.EVENT_ON_LOST:
            // TODO: Re-evaluate possible upstreams. Currently upstream
            // reevaluation is triggered via received CONNECTIVITY_ACTION
            // broadcasts that result in being passed a
            // TetherMasterSM.CMD_UPSTREAM_CHANGED.
            handleNewUpstreamNetworkState(null);
            break;
        default:
            mLog.e("Unknown arg1 value: " + arg1);
            break;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            {
                final LinkProperties newLp = (LinkProperties) message.obj;
                if (message.arg1 == IControlsTethering.STATE_TETHERED) {
                    mOffload.updateDownstreamLinkProperties(newLp);
                } else {
                    mOffload.excludeDownstreamInterface(newLp.getInterfaceName());
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (mUpstreamWanted) {
                    handleUpstreamNetworkMonitorCallback(message.arg1, message.obj);
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIfaceSet);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            {
                final LinkProperties newLp = (LinkProperties) message.obj;
                if (message.arg1 == IControlsTethering.STATE_TETHERED) {
                    mOffload.updateDownstreamLinkProperties(newLp);
                } else {
                    mOffload.excludeDownstreamInterface(newLp.getInterfaceName());
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (mUpstreamWanted) {
                    handleUpstreamNetworkMonitorCallback(message.arg1, message.obj);
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        case CMD_CLEAR_ERROR:
            mErrorNotification = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        case CMD_CLEAR_ERROR:
            mErrorNotification = TETHER_ERROR_NO_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.println("Current upstream interface: " + mCurrentUpstreamIface);
        pw.decreaseIndent();
    }
    pw.println("Hardware offload:");
    pw.increaseIndent();
    mOffloadController.dump(pw);
    pw.decreaseIndent();
    pw.println("Log:");
    pw.increaseIndent();
    if (argsContain(args, SHORT_ARG)) {
        pw.println("<log removed for brevity>");
    } else {
        mLog.dump(fd, pw, args);
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.println("Current upstream interface(s): " + mCurrentUpstreamIfaceSet);
        pw.decreaseIndent();
    }
    pw.println("Hardware offload:");
    pw.increaseIndent();
    mOffloadController.dump(pw);
    pw.decreaseIndent();
    pw.println("Log:");
    pw.increaseIndent();
    if (argsContain(args, SHORT_ARG)) {
        pw.println("<log removed for brevity>");
    } else {
        mLog.dump(fd, pw, args);
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#end_block

#method_before
private void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    mLog.log(String.format("OBSERVED iface=%s state=%s error=%s", iface, state, error));
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#method_after
private void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    mLog.log(String.format("OBSERVED iface=%s state=%s error=%s", iface, state, error));
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
private void maybeTrackNewInterfaceLocked(final String iface) {
    // If we don't care about this type of interface, ignore.
    final int interfaceType = ifaceNameToType(iface);
    if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
        mLog.log(iface + " is not a tetherable iface, ignoring");
        return;
    }
    maybeTrackNewInterfaceLocked(iface, interfaceType);
}
#method_after
private void maybeTrackNewInterfaceLocked(final String iface) {
    // If we don't care about this type of interface, ignore.
    final int interfaceType = ifaceNameToType(iface);
    if (interfaceType == TETHERING_INVALID) {
        mLog.log(iface + " is not a tetherable iface, ignoring");
        return;
    }
    maybeTrackNewInterfaceLocked(iface, interfaceType);
}
#end_block

#method_before
private void maybeTrackNewInterfaceLocked(final String iface, int interfaceType) {
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, makeControlCallback(iface)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#method_after
private void maybeTrackNewInterfaceLocked(final String iface, int interfaceType) {
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, makeControlCallback(iface), mDeps));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    ensureValidNetworkSpecifier(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    restrictRequestUidsForCaller(nc);
    // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
    // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
    // onLost and onAvailable callbacks when networks move in and out of the background.
    // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
    // can't request networks.
    restrictBackgroundRequestForCaller(nc);
    ensureValidNetworkSpecifier(nc);
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
private void handleRegisterNetworkAgent(NetworkAgentInfo na) {
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(na.messenger, na);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(na.network.netId, na);
    }
    na.asyncChannel.connect(mContext, mTrackerHandler, na.messenger);
    NetworkInfo networkInfo = na.networkInfo;
    na.networkInfo = null;
    updateNetworkInfo(na, networkInfo);
    updateUids(na, null, na.networkCapabilities);
}
#method_after
private void handleRegisterNetworkAgent(NetworkAgentInfo nai) {
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public Object getSystemService(String name) {
    if (Context.CONNECTIVITY_SERVICE.equals(name))
        return mConnectivityManager;
    if (Context.WIFI_SERVICE.equals(name))
        return mWifiManager;
    if (Context.USB_SERVICE.equals(name))
        return mUsbManager;
    return super.getSystemService(name);
}
#method_after
@Override
public Object getSystemService(String name) {
    if (Context.WIFI_SERVICE.equals(name))
        return mWifiManager;
    if (Context.USB_SERVICE.equals(name))
        return mUsbManager;
    return super.getSystemService(name);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d", "test_rndis\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mNMService.listInterfaces()).thenReturn(new String[] { "test_rmnet_data0", mTestIfname });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    mServiceContext = new MockContext(mContext);
    mContentResolver = new MockContentResolver(mServiceContext);
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    mIntents = new Vector<>();
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    };
    mServiceContext.registerReceiver(mBroadcastReceiver, new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
    when(mTetheringDependencies.getOffloadHardwareInterface(any(Handler.class), any(SharedLog.class))).thenReturn(mOffloadHardwareInterface);
    when(mTetheringDependencies.isTetheringSupported()).thenReturn(true);
    mTethering = new Tethering(mServiceContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties, mTetheringDependencies);
    verify(mNMService).registerTetheringStatsProvider(any(), anyString());
    verify(mTetheringDependencies).getOffloadHardwareInterface(any(), any());
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[] { "test_rndis\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mNMService.listInterfaces()).thenReturn(new String[] { TEST_MOBILE_IFNAME, TEST_WLAN_IFNAME, TEST_USB_IFNAME });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    when(mRouterAdvertisementDaemon.start()).thenReturn(true);
    mServiceContext = new MockContext(mContext);
    mContentResolver = new MockContentResolver(mServiceContext);
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    mIntents = new Vector<>();
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    };
    mServiceContext.registerReceiver(mBroadcastReceiver, new IntentFilter(ACTION_TETHER_STATE_CHANGED));
    mTetheringDependencies.reset();
    mTethering = new Tethering(mServiceContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties, mTetheringDependencies);
    verify(mNMService).registerTetheringStatsProvider(any(), anyString());
}
#end_block

#method_before
private void verifyInterfaceServingModeStarted() throws Exception {
    verify(mNMService, times(1)).getInterfaceConfig(mTestIfname);
    verify(mNMService, times(1)).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(mTestIfname);
}
#method_after
private void verifyInterfaceServingModeStarted() throws Exception {
    verify(mNMService, times(1)).getInterfaceConfig(TEST_WLAN_IFNAME);
    verify(mNMService, times(1)).setInterfaceConfig(eq(TEST_WLAN_IFNAME), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(TEST_WLAN_IFNAME);
}
#end_block

#method_before
private void verifyTetheringBroadcast(String ifname, String whichExtra) {
    // Verify that ifname is in the whichExtra array of the tether state changed broadcast.
    final Intent bcast = mIntents.get(0);
    assertEquals(ConnectivityManager.ACTION_TETHER_STATE_CHANGED, bcast.getAction());
    final ArrayList<String> ifnames = bcast.getStringArrayListExtra(whichExtra);
    assertTrue(ifnames.contains(ifname));
    mIntents.remove(bcast);
}
#method_after
private void verifyTetheringBroadcast(String ifname, String whichExtra) {
    // Verify that ifname is in the whichExtra array of the tether state changed broadcast.
    final Intent bcast = mIntents.get(0);
    assertEquals(ACTION_TETHER_STATE_CHANGED, bcast.getAction());
    final ArrayList<String> ifnames = bcast.getStringArrayListExtra(whichExtra);
    assertTrue(ifnames.contains(ifname));
    mIntents.remove(bcast);
}
#end_block

#method_before
public void failingLocalOnlyHotspotLegacyApBroadcast(boolean emulateInterfaceStatusChanged) throws Exception {
    // hotspot mode is to be started.
    if (emulateInterfaceStatusChanged) {
        mTethering.interfaceStatusChanged(mTestIfname, true);
    }
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    // broadcast indicating that the interface is "available".
    if (emulateInterfaceStatusChanged) {
        verify(mTetheringDependencies, atLeastOnce()).isTetheringSupported();
        verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    }
    verifyNoMoreInteractions(mTetheringDependencies);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
}
#method_after
public void failingLocalOnlyHotspotLegacyApBroadcast(boolean emulateInterfaceStatusChanged) throws Exception {
    // hotspot mode is to be started.
    if (emulateInterfaceStatusChanged) {
        mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    }
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    // broadcast indicating that the interface is "available".
    if (emulateInterfaceStatusChanged) {
        assertEquals(1, mTetheringDependencies.isTetheringSupportedCalls);
        verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    }
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
}
#end_block

#method_before
@Test
public void testUsbConfiguredBroadcastStartsTethering() throws Exception {
    // Emulate pressing the USB tethering button in Settings UI.
    mTethering.startTethering(TETHERING_USB, null, false);
    mLooper.dispatchAll();
    verify(mUsbManager, times(1)).setCurrentFunction(UsbManager.USB_FUNCTION_RNDIS, false);
    // Pretend we receive a USB connected broadcast. Here we also pretend
    // that the RNDIS function is somehow enabled, so that we see if we
    // might trip ourselves up.
    sendUsbBroadcast(true, false, true);
    mLooper.dispatchAll();
    // This should produce no activity of any kind.
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Pretend we then receive USB configured broadcast.
    sendUsbBroadcast(true, true, true);
    mLooper.dispatchAll();
    // Now we should see the start of tethering mechanics (in this case:
    // tetherMatchingInterfaces() which starts by fetching all interfaces).
    verify(mNMService, times(1)).listInterfaces();
}
#method_after
@Test
public void testUsbConfiguredBroadcastStartsTethering() throws Exception {
    NetworkState upstreamState = buildMobileIPv4UpstreamState();
    prepareUsbTethering(upstreamState);
    // This should produce no activity of any kind.
    verifyNoMoreInteractions(mNMService);
    // Pretend we then receive USB configured broadcast.
    sendUsbBroadcast(true, true, true);
    mLooper.dispatchAll();
    // Now we should see the start of tethering mechanics (in this case:
    // tetherMatchingInterfaces() which starts by fetching all interfaces).
    verify(mNMService, times(1)).listInterfaces();
    // UpstreamNetworkMonitor should receive selected upstream
    verify(mUpstreamNetworkMonitor, times(1)).selectPreferredUpstreamType(any());
    verify(mUpstreamNetworkMonitor, times(1)).setCurrentUpstream(upstreamState.network);
}
#end_block

#method_before
public void workingLocalOnlyHotspotEnrichedApBroadcast(boolean emulateInterfaceStatusChanged) throws Exception {
    // hotspot mode is to be started.
    if (emulateInterfaceStatusChanged) {
        mTethering.interfaceStatusChanged(mTestIfname, true);
    }
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, mTestIfname, IFACE_IP_MODE_LOCAL_ONLY);
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted();
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verify(mWifiManager).updateInterfaceIpState(mTestIfname, WifiManager.IFACE_IP_MODE_LOCAL_ONLY);
    verifyNoMoreInteractions(mWifiManager);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_ACTIVE_LOCAL_ONLY);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    verifyNoMoreInteractions(mConnectivityManager);
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mTetheringDependencies, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mTetheringDependencies);
    // Emulate externally-visible WifiManager effects, when hotspot mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#method_after
public void workingLocalOnlyHotspotEnrichedApBroadcast(boolean emulateInterfaceStatusChanged) throws Exception {
    // hotspot mode is to be started.
    if (emulateInterfaceStatusChanged) {
        mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    }
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, TEST_WLAN_IFNAME, IFACE_IP_MODE_LOCAL_ONLY);
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted();
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_LOCAL_ONLY);
    verifyNoMoreInteractions(mWifiManager);
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_ACTIVE_LOCAL_ONLY);
    verify(mUpstreamNetworkMonitor, times(1)).start();
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    assertTrue(1 <= mTetheringDependencies.isTetheringSupportedCalls);
    // Emulate externally-visible WifiManager effects, when hotspot mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(TEST_WLAN_IFNAME);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(TEST_WLAN_IFNAME);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(TEST_WLAN_IFNAME);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(TEST_WLAN_IFNAME), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(TEST_WLAN_IFNAME));
}
#end_block

#method_before
@Test
public void failingWifiTetheringLegacyApBroadcast() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    verify(mTetheringDependencies, atLeastOnce()).isTetheringSupported();
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    verifyNoMoreInteractions(mTetheringDependencies);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
}
#method_after
@Test
public void failingWifiTetheringLegacyApBroadcast() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    assertEquals(1, mTetheringDependencies.isTetheringSupportedCalls);
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
}
#end_block

#method_before
@Test
public void workingWifiTetheringEnrichedApBroadcast() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, mTestIfname, IFACE_IP_MODE_TETHERED);
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted();
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verify(mWifiManager).updateInterfaceIpState(mTestIfname, WifiManager.IFACE_IP_MODE_TETHERED);
    verifyNoMoreInteractions(mWifiManager);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_ACTIVE_TETHER);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    // In tethering mode, in the default configuration, an explicit request
    // for a mobile network is also made.
    verify(mConnectivityManager, times(1)).requestNetwork(any(NetworkRequest.class), any(NetworkCallback.class), eq(0), anyInt(), any(Handler.class));
    verifyNoMoreInteractions(mConnectivityManager);
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mTetheringDependencies, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mTetheringDependencies);
    // ///
    // We do not currently emulate any upstream being found.
    // 
    // This is why there are no calls to verify mNMService.enableNat() or
    // mNMService.startInterfaceForwarding().
    // ///
    // Emulate pressing the WiFi tethering button.
    mTethering.stopTethering(TETHERING_WIFI);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).stopSoftAp();
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, when tethering mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#method_after
@Test
public void workingWifiTetheringEnrichedApBroadcast() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, TEST_WLAN_IFNAME, IFACE_IP_MODE_TETHERED);
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted();
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_TETHERED);
    verifyNoMoreInteractions(mWifiManager);
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_ACTIVE_TETHER);
    verify(mUpstreamNetworkMonitor, times(1)).start();
    // In tethering mode, in the default configuration, an explicit request
    // for a mobile network is also made.
    verify(mUpstreamNetworkMonitor, times(1)).registerMobileNetworkRequest();
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    assertTrue(1 <= mTetheringDependencies.isTetheringSupportedCalls);
    // ///
    // We do not currently emulate any upstream being found.
    // 
    // This is why there are no calls to verify mNMService.enableNat() or
    // mNMService.startInterfaceForwarding().
    // ///
    // Emulate pressing the WiFi tethering button.
    mTethering.stopTethering(TETHERING_WIFI);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).stopSoftAp();
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, when tethering mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(TEST_WLAN_IFNAME);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(TEST_WLAN_IFNAME);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(TEST_WLAN_IFNAME);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(TEST_WLAN_IFNAME), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(TEST_WLAN_IFNAME));
}
#end_block

#method_before
@Test
public void failureEnablingIpForwarding() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    doThrow(new RemoteException()).when(mNMService).setIpForwardingEnabled(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, mTestIfname, IFACE_IP_MODE_TETHERED);
    mLooper.dispatchAll();
    // We verify get/set called twice here: once for setup and once during
    // teardown because all events happen over the course of the single
    // dispatchAll() above.
    verify(mNMService, times(2)).getInterfaceConfig(mTestIfname);
    verify(mNMService, times(2)).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(mTestIfname);
    verify(mWifiManager).updateInterfaceIpState(mTestIfname, WifiManager.IFACE_IP_MODE_TETHERED);
    verify(mTetheringDependencies, atLeastOnce()).isTetheringSupported();
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    // This is called, but will throw.
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    // This never gets called because of the exception thrown above.
    verify(mNMService, times(0)).startTethering(any(String[].class));
    // When the master state machine transitions to an error state it tells
    // downstream interfaces, which causes us to tell Wi-Fi about the error
    // so it can take down AP mode.
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    verify(mWifiManager).updateInterfaceIpState(mTestIfname, WifiManager.IFACE_IP_MODE_CONFIGURATION_ERROR);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mTetheringDependencies);
    verifyNoMoreInteractions(mNMService);
}
#method_after
@Test
public void failureEnablingIpForwarding() throws Exception {
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    doThrow(new RemoteException()).when(mNMService).setIpForwardingEnabled(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(TEST_WLAN_IFNAME, true);
    sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, TEST_WLAN_IFNAME, IFACE_IP_MODE_TETHERED);
    mLooper.dispatchAll();
    // We verify get/set called twice here: once for setup and once during
    // teardown because all events happen over the course of the single
    // dispatchAll() above.
    verify(mNMService, times(2)).getInterfaceConfig(TEST_WLAN_IFNAME);
    verify(mNMService, times(2)).setInterfaceConfig(eq(TEST_WLAN_IFNAME), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(TEST_WLAN_IFNAME);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_TETHERED);
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    assertTrue(1 <= mTetheringDependencies.isTetheringSupportedCalls);
    verifyTetheringBroadcast(TEST_WLAN_IFNAME, EXTRA_AVAILABLE_TETHER);
    // This is called, but will throw.
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    // This never gets called because of the exception thrown above.
    verify(mNMService, times(0)).startTethering(any(String[].class));
    // When the master state machine transitions to an error state it tells
    // downstream interfaces, which causes us to tell Wi-Fi about the error
    // so it can take down AP mode.
    verify(mNMService, times(1)).untetherInterface(TEST_WLAN_IFNAME);
    verify(mWifiManager).updateInterfaceIpState(TEST_WLAN_IFNAME, WifiManager.IFACE_IP_MODE_CONFIGURATION_ERROR);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mNMService);
}
#end_block

#method_before
@Test
public void testDisallowTetheringWhenAtLeastOneTetheringInterfaceIsActive() throws Exception {
    final String[] nonEmptyActiveIfacesList = new String[] { mTestIfname };
    final boolean currDisallow = false;
    final boolean nextDisallow = true;
    final int expectedInteractionsWithShowNotification = 1;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
}
#method_after
@Test
public void testDisallowTetheringWhenAtLeastOneTetheringInterfaceIsActive() throws Exception {
    final String[] nonEmptyActiveIfacesList = new String[] { TEST_WLAN_IFNAME };
    final boolean currDisallow = false;
    final boolean nextDisallow = true;
    final int expectedInteractionsWithShowNotification = 1;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
}
#end_block

#method_before
@Test
public void testAllowTetheringWhenAtLeastOneTetheringInterfaceIsActive() throws Exception {
    final String[] nonEmptyActiveIfacesList = new String[] { mTestIfname };
    final boolean currDisallow = true;
    final boolean nextDisallow = false;
    final int expectedInteractionsWithShowNotification = 0;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
}
#method_after
@Test
public void testAllowTetheringWhenAtLeastOneTetheringInterfaceIsActive() throws Exception {
    final String[] nonEmptyActiveIfacesList = new String[] { TEST_WLAN_IFNAME };
    final boolean currDisallow = true;
    final boolean nextDisallow = false;
    final int expectedInteractionsWithShowNotification = 0;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
}
#end_block

#method_before
@Test
public void testDisallowTetheringUnchanged() throws Exception {
    final String[] nonEmptyActiveIfacesList = new String[] { mTestIfname };
    final int expectedInteractionsWithShowNotification = 0;
    boolean currDisallow = true;
    boolean nextDisallow = true;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
    currDisallow = false;
    nextDisallow = false;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
}
#method_after
@Test
public void testDisallowTetheringUnchanged() throws Exception {
    final String[] nonEmptyActiveIfacesList = new String[] { TEST_WLAN_IFNAME };
    final int expectedInteractionsWithShowNotification = 0;
    boolean currDisallow = true;
    boolean nextDisallow = true;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
    currDisallow = false;
    nextDisallow = false;
    userRestrictionsListenerBehaviour(currDisallow, nextDisallow, nonEmptyActiveIfacesList, expectedInteractionsWithShowNotification);
}
#end_block

#method_before
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                boolean isRoamingBetweenOperators = isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS);
                if (isRoamingBetweenOperators != mNewSS.getVoiceRoaming()) {
                    log("isRoamingBetweenOperators=" + isRoamingBetweenOperators + ". Override CDMA voice roaming to " + isRoamingBetweenOperators);
                    mNewSS.setVoiceRoaming(isRoamingBetweenOperators);
                }
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    boolean isVoiceRoaming = mNewSS.getVoiceRoaming();
                    if (mNewSS.getDataRoaming() != isVoiceRoaming) {
                        log("Data roaming != Voice roaming. Override data roaming to " + isVoiceRoaming);
                        mNewSS.setDataRoaming(isVoiceRoaming);
                    }
                } else {
                    /**
                     * As per VoiceRegStateResult from radio types.hal the TSB58
                     * Roaming Indicator shall be sent if device is registered
                     * on a CDMA or EVDO system.
                     */
                    boolean isRoamIndForHomeSystem = isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator));
                    if (mNewSS.getDataRoaming() == isRoamIndForHomeSystem) {
                        log("isRoamIndForHomeSystem=" + isRoamIndForHomeSystem + ", override data roaming to " + !isRoamIndForHomeSystem);
                        mNewSS.setDataRoaming(!isRoamIndForHomeSystem);
                    }
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#method_after
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getCdmaSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                boolean isRoamingBetweenOperators = isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS);
                if (isRoamingBetweenOperators != mNewSS.getVoiceRoaming()) {
                    log("isRoamingBetweenOperators=" + isRoamingBetweenOperators + ". Override CDMA voice roaming to " + isRoamingBetweenOperators);
                    mNewSS.setVoiceRoaming(isRoamingBetweenOperators);
                }
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    boolean isVoiceRoaming = mNewSS.getVoiceRoaming();
                    if (mNewSS.getDataRoaming() != isVoiceRoaming) {
                        log("Data roaming != Voice roaming. Override data roaming to " + isVoiceRoaming);
                        mNewSS.setDataRoaming(isVoiceRoaming);
                    }
                } else {
                    /**
                     * As per VoiceRegStateResult from radio types.hal the TSB58
                     * Roaming Indicator shall be sent if device is registered
                     * on a CDMA or EVDO system.
                     */
                    boolean isRoamIndForHomeSystem = isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator));
                    if (mNewSS.getDataRoaming() == isRoamIndForHomeSystem) {
                        log("isRoamIndForHomeSystem=" + isRoamIndForHomeSystem + ", override data roaming to " + !isRoamIndForHomeSystem);
                        mNewSS.setDataRoaming(!isRoamIndForHomeSystem);
                    }
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                VoiceSpecificRegistrationStates voiceSpecificStates = networkRegState.getVoiceSpecificStates();
                int registrationState = networkRegState.getRegState();
                int cssIndicator = voiceSpecificStates.cssSupported ? 1 : 0;
                int newVoiceRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(newVoiceRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                setChannelNumberFromCellIdentity(mNewSS, networkRegState.getCellIdentity());
                // Denial reason if registrationState = 3
                int reasonForDenial = networkRegState.getReasonForDenial();
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    mEmergencyOnly = networkRegState.isEmergencyEnabled();
                } else {
                    int roamingIndicator = voiceSpecificStates.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceSpecificStates.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceSpecificStates.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    CellIdentity cellIdentity = networkRegState.getCellIdentity();
                    if (cellIdentity != null && cellIdentity.getType() == CellInfoType.CDMA) {
                        systemId = ((CellIdentityCdma) cellIdentity).getSystemId();
                        networkId = ((CellIdentityCdma) cellIdentity).getNetworkId();
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, networkRegState.getCellIdentity());
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + newVoiceRat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                DataSpecificRegistrationStates dataSpecificStates = networkRegState.getDataSpecificStates();
                int registrationState = networkRegState.getRegState();
                int serviceState = regCodeToServiceState(registrationState);
                int newDataRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setDataRegState(serviceState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                setChannelNumberFromCellIdentity(mNewSS, networkRegState.getCellIdentity());
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = networkRegState.getReasonForDenial();
                    mNewMaxDataCalls = dataSpecificStates.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(registrationState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST dataServiceState=" + serviceState + " registrationState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(networkRegState.getCellIdentity()));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                VoiceSpecificRegistrationStates voiceSpecificStates = networkRegState.getVoiceSpecificStates();
                int registrationState = networkRegState.getRegState();
                int cssIndicator = voiceSpecificStates.cssSupported ? 1 : 0;
                int newVoiceRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(newVoiceRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                setChannelNumberFromCellIdentity(mNewSS, networkRegState.getCellIdentity());
                // Denial reason if registrationState = 3
                int reasonForDenial = networkRegState.getReasonForDenial();
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    mEmergencyOnly = networkRegState.isEmergencyEnabled();
                } else {
                    int roamingIndicator = voiceSpecificStates.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceSpecificStates.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceSpecificStates.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    CellIdentity cellIdentity = networkRegState.getCellIdentity();
                    if (cellIdentity != null && cellIdentity.getType() == CellInfoType.CDMA) {
                        systemId = ((CellIdentityCdma) cellIdentity).getSystemId();
                        networkId = ((CellIdentityCdma) cellIdentity).getNetworkId();
                    }
                    mNewSS.setCdmaSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, networkRegState.getCellIdentity());
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + newVoiceRat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                NetworkRegistrationState networkRegState = (NetworkRegistrationState) ar.result;
                DataSpecificRegistrationStates dataSpecificStates = networkRegState.getDataSpecificStates();
                int registrationState = networkRegState.getRegState();
                int serviceState = regCodeToServiceState(registrationState);
                int newDataRat = ServiceState.networkTypeToRilRadioTechnology(networkRegState.getAccessNetworkTechnology());
                mNewSS.setDataRegState(serviceState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                mNewSS.addNetworkRegistrationState(networkRegState);
                setChannelNumberFromCellIdentity(mNewSS, networkRegState.getCellIdentity());
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = networkRegState.getReasonForDenial();
                    mNewMaxDataCalls = dataSpecificStates.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(registrationState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma dataServiceState=" + serviceState + " regState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(registrationState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST dataServiceState=" + serviceState + " registrationState=" + registrationState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(networkRegState.getCellIdentity()));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (mPhone.shouldForceAutoNetworkSelect())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            log("updateRoamingState: resource override set non roaming.isSameNamedOperators=" + isSameNamedOperators(mNewSS) + ",isOperatorConsideredNonRoaming=" + isOperatorConsideredNonRoaming(mNewSS));
            roaming = false;
        }
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#method_after
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            log("updateRoamingState: resource override set non roaming.isSameNamedOperators=" + isSameNamedOperators(mNewSS) + ",isOperatorConsideredNonRoaming=" + isOperatorConsideredNonRoaming(mNewSS));
            roaming = false;
        }
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getCdmaSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through its rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (!hasLocationChanged && isDataInService) {
        mRatRatcheter.ratchet(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkAvailable();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkUnavailable();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String prevCountryIsoCode = tm.getNetworkCountryIso(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.handleNetworkUnavailable();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update IDD.
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            // Update ISO.
            String countryIsoCode = "";
            try {
                String mcc = operatorNumeric.substring(0, 3);
                countryIsoCode = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), countryIsoCode);
            // Update Time Zone.
            boolean iccCardExists = iccCardExists();
            boolean networkIsoChanged = networkCountryIsoChanged(countryIsoCode, prevCountryIsoCode);
            // Determine countryChanged: networkIso is only reliable if there's an ICC card.
            boolean countryChanged = iccCardExists && networkIsoChanged;
            if (DBG) {
                long ctm = System.currentTimeMillis();
                log("Before handleNetworkCountryCodeKnown:" + " countryChanged=" + countryChanged + " iccCardExist=" + iccCardExists + " countryIsoChanged=" + networkIsoChanged + " operatorNumeric=" + operatorNumeric + " prevOperatorNumeric=" + prevOperatorNumeric + " countryIsoCode=" + countryIsoCode + " prevCountryIsoCode=" + prevCountryIsoCode + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            mNitzState.handleNetworkCountryCodeSet(countryChanged);
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through its rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (isDataInService) {
        mRatRatcheter.ratchet(mSS, mNewSS, hasLocationChanged);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkAvailable();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkUnavailable();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String prevCountryIsoCode = tm.getNetworkCountryIso(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getCdmaSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.handleNetworkUnavailable();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update IDD.
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            // Update ISO.
            String countryIsoCode = "";
            try {
                String mcc = operatorNumeric.substring(0, 3);
                countryIsoCode = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), countryIsoCode);
            // Update Time Zone.
            boolean iccCardExists = iccCardExists();
            boolean networkIsoChanged = networkCountryIsoChanged(countryIsoCode, prevCountryIsoCode);
            // Determine countryChanged: networkIso is only reliable if there's an ICC card.
            boolean countryChanged = iccCardExists && networkIsoChanged;
            if (DBG) {
                long ctm = System.currentTimeMillis();
                log("Before handleNetworkCountryCodeKnown:" + " countryChanged=" + countryChanged + " iccCardExist=" + iccCardExists + " countryIsoChanged=" + networkIsoChanged + " operatorNumeric=" + operatorNumeric + " prevOperatorNumeric=" + prevOperatorNumeric + " countryIsoCode=" + countryIsoCode + " prevCountryIsoCode=" + prevCountryIsoCode + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            mNitzState.handleNetworkCountryCodeSet(countryChanged);
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name)) && (!mIsSubscriptionFromRuim)) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#method_after
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name)) && (!mIsSubscriptionFromRuim)) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getCdmaSystemId(), mSS.getCdmaNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#end_block

#method_before
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    if (!SubscriptionManager.isValidSubscriptionId(mSubId)) {
        // notifications are posted per-sub-id, so return if current sub-id is invalid
        loge("cannot setNotification on invalid subid mSubId=" + mSubId);
        return;
    }
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    final boolean multipleSubscriptions = (mSubscriptionManager.getActiveSubscriptionInfoCount() > 1);
    final int simNumber = mSubscriptionController.getSlotIndex(mSubId) + 1;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode, multipleSubscriptions);
            if (0 == resId) {
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                // if using the single SIM resource, mSubId will be ignored
                title = context.getString(resId, mSubId);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details + ", subId: " + mSubId);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setStyle(new Notification.BigTextStyle().bigText(details)).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(Integer.toString(mSubId), notificationId);
    } else {
        // update restricted state notification for this subId
        notificationManager.notify(Integer.toString(mSubId), notificationId, mNotification);
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    if (!SubscriptionManager.isValidSubscriptionId(mSubId)) {
        // notifications are posted per-sub-id, so return if current sub-id is invalid
        loge("cannot setNotification on invalid subid mSubId=" + mSubId);
        return;
    }
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    final boolean multipleSubscriptions = (((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getPhoneCount() > 1);
    final int simNumber = mSubscriptionController.getSlotIndex(mSubId) + 1;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode, multipleSubscriptions);
            if (0 == resId) {
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                // if using the single SIM resource, mSubId will be ignored
                title = context.getString(resId, mSubId);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details + ", subId: " + mSubId);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setStyle(new Notification.BigTextStyle().bigText(details)).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(Integer.toString(mSubId), notificationId);
    } else {
        // update restricted state notification for this subId
        notificationManager.notify(Integer.toString(mSubId), notificationId, mNotification);
    }
}
#end_block

#method_before
private void updateLteEarfcnLists() {
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle b = configManager.getConfigForSubId(mPhone.getSubId());
    synchronized (mLteRsrpBoostLock) {
        mLteRsrpBoost = b.getInt(CarrierConfigManager.KEY_LTE_EARFCNS_RSRP_BOOST_INT, 0);
        String[] earfcnsStringArrayForRsrpBoost = b.getStringArray(CarrierConfigManager.KEY_BOOSTED_LTE_EARFCNS_STRING_ARRAY);
        mEarfcnPairListForRsrpBoost = convertEarfcnStringArrayToPairList(earfcnsStringArrayForRsrpBoost);
    }
}
#method_after
private void updateLteEarfcnLists(PersistableBundle config) {
    synchronized (mLteRsrpBoostLock) {
        mLteRsrpBoost = config.getInt(CarrierConfigManager.KEY_LTE_EARFCNS_RSRP_BOOST_INT, 0);
        String[] earfcnsStringArrayForRsrpBoost = config.getStringArray(CarrierConfigManager.KEY_BOOSTED_LTE_EARFCNS_STRING_ARRAY);
        mEarfcnPairListForRsrpBoost = convertEarfcnStringArrayToPairList(earfcnsStringArrayForRsrpBoost);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    logd("ServiceStateTrackerTest +Setup!");
    super.setUp("ServiceStateTrackerTest");
    mContextFixture.putResource(R.string.config_wwan_network_service_package, "com.android.phone");
    addNetworkService();
    doReturn(true).when(mDct).isDisconnected();
    mPhone.mDcTracker = mDct;
    replaceInstance(ProxyController.class, "sProxyController", null, mProxyController);
    mBundle = mContextFixture.getCarrierConfigBundle();
    mBundle.putStringArray(CarrierConfigManager.KEY_ROAMING_OPERATOR_STRING_ARRAY, new String[] { "123456" });
    mBundle.putStringArray(CarrierConfigManager.KEY_NON_ROAMING_OPERATOR_STRING_ARRAY, new String[] { "123456" });
    mSimulatedCommands.setVoiceRegState(NetworkRegistrationState.REG_STATE_HOME);
    mSimulatedCommands.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_HSPA);
    mSimulatedCommands.setDataRegState(NetworkRegistrationState.REG_STATE_HOME);
    mSimulatedCommands.setDataRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_HSPA);
    int dds = SubscriptionManager.getDefaultDataSubscriptionId();
    doReturn(dds).when(mPhone).getSubId();
    mSSTTestHandler = new ServiceStateTrackerTestHandler(getClass().getSimpleName());
    mSSTTestHandler.start();
    waitUntilReady();
    waitForMs(600);
    logd("ServiceStateTrackerTest -Setup!");
}
#method_after
@Before
public void setUp() throws Exception {
    logd("ServiceStateTrackerTest +Setup!");
    super.setUp("ServiceStateTrackerTest");
    mContextFixture.putResource(R.string.config_wwan_network_service_package, "com.android.phone");
    addNetworkService();
    doReturn(true).when(mDct).isDisconnected();
    mPhone.mDcTracker = mDct;
    replaceInstance(ProxyController.class, "sProxyController", null, mProxyController);
    mBundle = mContextFixture.getCarrierConfigBundle();
    mBundle.putStringArray(CarrierConfigManager.KEY_ROAMING_OPERATOR_STRING_ARRAY, new String[] { "123456" });
    mBundle.putStringArray(CarrierConfigManager.KEY_NON_ROAMING_OPERATOR_STRING_ARRAY, new String[] { "123456" });
    mBundle.putStringArray(CarrierConfigManager.KEY_RATCHET_RAT_FAMILIES, // UMTS < GPRS < EDGE
    new String[] { "3,1,2" });
    mSimulatedCommands.setVoiceRegState(NetworkRegistrationState.REG_STATE_HOME);
    mSimulatedCommands.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_HSPA);
    mSimulatedCommands.setDataRegState(NetworkRegistrationState.REG_STATE_HOME);
    mSimulatedCommands.setDataRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_HSPA);
    int dds = SubscriptionManager.getDefaultDataSubscriptionId();
    doReturn(dds).when(mPhone).getSubId();
    mSSTTestHandler = new ServiceStateTrackerTestHandler(getClass().getSimpleName());
    mSSTTestHandler.start();
    waitUntilReady();
    waitForMs(600);
    logd("ServiceStateTrackerTest -Setup!");
}
#end_block

#method_before
private boolean notificationHasTitleSet(Notification n) {
    return n.toString().contains("tick");
}
#method_after
private boolean notificationHasTitleSet(Notification n) {
    // word "tick" if the title is set so we check this as a workaround
    return n.toString().contains("tick");
}
#end_block

#method_before
@Test
@SmallTest
public void testSetPsNotifications() {
    ServiceStateTracker spySst = spy(sst);
    NotificationManager nm = mock(NotificationManager.class);
    doReturn(nm).when(mContext).getSystemService(eq(Context.NOTIFICATION_SERVICE));
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnDataTitle, "X");
    spySst.setNotification(ServiceStateTracker.PS_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    spySst.setNotification(ServiceStateTracker.PS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
}
#method_after
@Test
@SmallTest
public void testSetPsNotifications() {
    sst.mSubId = 1;
    final NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnDataTitle, "test1");
    sst.setNotification(ServiceStateTracker.PS_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    assertEquals("test1", getNotificationTitle(postedNotification));
    sst.setNotification(ServiceStateTracker.PS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetCsNotifications() {
    ServiceStateTracker spySst = spy(sst);
    NotificationManager nm = mock(NotificationManager.class);
    doReturn(nm).when(mContext).getSystemService(eq(Context.NOTIFICATION_SERVICE));
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnAllVoiceTitle, "X");
    spySst.setNotification(ServiceStateTracker.CS_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    spySst.setNotification(ServiceStateTracker.CS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
}
#method_after
@Test
@SmallTest
public void testSetCsNotifications() {
    sst.mSubId = 1;
    final NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnAllVoiceTitle, "test2");
    sst.setNotification(ServiceStateTracker.CS_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    assertEquals("test2", getNotificationTitle(postedNotification));
    sst.setNotification(ServiceStateTracker.CS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetCsNormalNotifications() {
    ServiceStateTracker spySst = spy(sst);
    NotificationManager nm = mock(NotificationManager.class);
    doReturn(nm).when(mContext).getSystemService(eq(Context.NOTIFICATION_SERVICE));
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnNormalTitle, "X");
    spySst.setNotification(ServiceStateTracker.CS_NORMAL_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    spySst.setNotification(ServiceStateTracker.CS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
}
#method_after
@Test
@SmallTest
public void testSetCsNormalNotifications() {
    sst.mSubId = 1;
    final NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnNormalTitle, "test3");
    sst.setNotification(ServiceStateTracker.CS_NORMAL_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    assertEquals("test3", getNotificationTitle(postedNotification));
    sst.setNotification(ServiceStateTracker.CS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetCsEmergencyNotifications() {
    ServiceStateTracker spySst = spy(sst);
    NotificationManager nm = mock(NotificationManager.class);
    doReturn(nm).when(mContext).getSystemService(eq(Context.NOTIFICATION_SERVICE));
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnEmergencyTitle, "X");
    spySst.setNotification(ServiceStateTracker.CS_EMERGENCY_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    spySst.setNotification(ServiceStateTracker.CS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
    spySst.setNotification(ServiceStateTracker.CS_REJECT_CAUSE_ENABLED);
}
#method_after
@Test
@SmallTest
public void testSetCsEmergencyNotifications() {
    sst.mSubId = 1;
    final NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    mContextFixture.putBooleanResource(R.bool.config_user_notification_of_restrictied_mobile_access, true);
    doReturn(new ApplicationInfo()).when(mContext).getApplicationInfo();
    Drawable mockDrawable = mock(Drawable.class);
    Resources mockResources = mContext.getResources();
    when(mockResources.getDrawable(anyInt(), any())).thenReturn(mockDrawable);
    mContextFixture.putResource(com.android.internal.R.string.RestrictedOnEmergencyTitle, "test4");
    sst.setNotification(ServiceStateTracker.CS_EMERGENCY_ENABLED);
    ArgumentCaptor<Notification> notificationArgumentCaptor = ArgumentCaptor.forClass(Notification.class);
    verify(nm).notify(anyString(), anyInt(), notificationArgumentCaptor.capture());
    // if the postedNotification has title set then it must have been the correct notification
    Notification postedNotification = notificationArgumentCaptor.getValue();
    assertTrue(notificationHasTitleSet(postedNotification));
    assertEquals("test4", getNotificationTitle(postedNotification));
    sst.setNotification(ServiceStateTracker.CS_DISABLED);
    verify(nm).cancel(anyString(), anyInt());
    sst.setNotification(ServiceStateTracker.CS_REJECT_CAUSE_ENABLED);
}
#end_block

#method_before
public void maybeMarkCapabilitiesRestricted() {
    // Verify there aren't any unrestricted capabilities.  If there are we say
    // the whole thing is unrestricted.
    final boolean hasUnrestrictedCapabilities = ((mNetworkCapabilities & UNRESTRICTED_CAPABILITIES) != 0);
    // Must have at least some restricted capabilities.
    final boolean hasRestrictedCapabilities = ((mNetworkCapabilities & RESTRICTED_CAPABILITIES) != 0);
    if (hasRestrictedCapabilities && !hasUnrestrictedCapabilities) {
        removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    }
}
#method_after
public void maybeMarkCapabilitiesRestricted() {
    // Check if we have any capability that forces the network to be restricted.
    final boolean forceRestrictedCapability = (mNetworkCapabilities & FORCE_RESTRICTED_CAPABILITIES) != 0;
    // Verify there aren't any unrestricted capabilities.  If there are we say
    // the whole thing is unrestricted unless it is forced to be restricted.
    final boolean hasUnrestrictedCapabilities = (mNetworkCapabilities & UNRESTRICTED_CAPABILITIES) != 0;
    // Must have at least some restricted capabilities.
    final boolean hasRestrictedCapabilities = (mNetworkCapabilities & RESTRICTED_CAPABILITIES) != 0;
    if (forceRestrictedCapability || (hasRestrictedCapabilities && !hasUnrestrictedCapabilities)) {
        removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    }
}
#end_block

#method_before
@Test
public void testOemPaid() {
    NetworkCapabilities nc = new NetworkCapabilities();
    assertTrue(nc.hasUnwantedCapability(NET_CAPABILITY_OEM_PAID));
    assertFalse(nc.hasCapability(NET_CAPABILITY_OEM_PAID));
    // Having OEM_PAID in unwanted list shouldn't make it restricted network.
    nc.maybeMarkCapabilitiesRestricted();
    assertTrue(nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Adding OEM_PAID to capability list should make network restricted.
    nc.addCapability(NET_CAPABILITY_OEM_PAID);
    nc.maybeMarkCapabilitiesRestricted();
    assertTrue(nc.hasCapability(NET_CAPABILITY_OEM_PAID));
    assertFalse(nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
}
#method_after
@Test
public void testOemPaid() {
    NetworkCapabilities nc = new NetworkCapabilities();
    // By default OEM_PAID is neither in the unwanted or required lists and the network is not
    // restricted.
    assertFalse(nc.hasUnwantedCapability(NET_CAPABILITY_OEM_PAID));
    assertFalse(nc.hasCapability(NET_CAPABILITY_OEM_PAID));
    nc.maybeMarkCapabilitiesRestricted();
    assertTrue(nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Adding OEM_PAID to capability list should make network restricted.
    nc.addCapability(NET_CAPABILITY_OEM_PAID);
    // Combine with unrestricted capability.
    nc.addCapability(NET_CAPABILITY_INTERNET);
    nc.maybeMarkCapabilitiesRestricted();
    assertTrue(nc.hasCapability(NET_CAPABILITY_OEM_PAID));
    assertFalse(nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Now let's make request for OEM_PAID network.
    NetworkCapabilities nr = new NetworkCapabilities();
    nr.addCapability(NET_CAPABILITY_OEM_PAID);
    nr.maybeMarkCapabilitiesRestricted();
    assertTrue(nr.satisfiedByNetworkCapabilities(nc));
    // Request fails for network with the default capabilities.
    assertFalse(nr.satisfiedByNetworkCapabilities(new NetworkCapabilities()));
}
#end_block

#method_before
@Test
public void testUnwantedCapabilities() {
    NetworkCapabilities network = new NetworkCapabilities();
    NetworkCapabilities request = new NetworkCapabilities();
    assertTrue("Request: " + request + ", Network:" + network, request.satisfiedByNetworkCapabilities(network));
    // Adding capabilities that doesn't exist in the network anyway
    request.addUnwantedCapability(NET_CAPABILITY_WIFI_P2P);
    request.addUnwantedCapability(NET_CAPABILITY_NOT_METERED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    assertArrayEquals(new int[] { NET_CAPABILITY_WIFI_P2P, NET_CAPABILITY_NOT_METERED, NET_CAPABILITY_OEM_PAID }, request.getUnwantedCapabilities());
    // This is a default capability, just want to make sure its there because we use it below.
    assertTrue(network.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Verify that adding unwanted capability will effectively remove it from capability list.
    request.addUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.hasUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Now this request won't be satisfied because network contains NOT_RESTRICTED.
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    // Verify that adding capability will effectively remove it from unwanted list
    request.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.hasUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
}
#method_after
@Test
public void testUnwantedCapabilities() {
    NetworkCapabilities network = new NetworkCapabilities();
    NetworkCapabilities request = new NetworkCapabilities();
    assertTrue("Request: " + request + ", Network:" + network, request.satisfiedByNetworkCapabilities(network));
    // Adding capabilities that doesn't exist in the network anyway
    request.addUnwantedCapability(NET_CAPABILITY_WIFI_P2P);
    request.addUnwantedCapability(NET_CAPABILITY_NOT_METERED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    assertArrayEquals(new int[] { NET_CAPABILITY_WIFI_P2P, NET_CAPABILITY_NOT_METERED }, request.getUnwantedCapabilities());
    // This is a default capability, just want to make sure its there because we use it below.
    assertTrue(network.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Verify that adding unwanted capability will effectively remove it from capability list.
    request.addUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.hasUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    // Now this request won't be satisfied because network contains NOT_RESTRICTED.
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.removeCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
    // Verify that adding capability will effectively remove it from unwanted list
    request.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.hasCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.hasUnwantedCapability(NET_CAPABILITY_NOT_RESTRICTED));
    assertFalse(request.satisfiedByNetworkCapabilities(network));
    network.addCapability(NET_CAPABILITY_NOT_RESTRICTED);
    assertTrue(request.satisfiedByNetworkCapabilities(network));
}
#end_block

#method_before
@Test
public void testNoTruncLen() throws Exception {
    String[] authAndAeadList = new String[] { IpSecAlgorithm.AUTH_HMAC_MD5, IpSecAlgorithm.AUTH_HMAC_SHA1, IpSecAlgorithm.AUTH_HMAC_SHA256, IpSecAlgorithm.AUTH_HMAC_SHA384, IpSecAlgorithm.AUTH_HMAC_SHA512, IpSecAlgorithm.AUTH_CRYPT_AES_GCM };
    // Expect auth and aead algorithms to throw errors if trunclen is omitted.
    for (String algName : authAndAeadList) {
        try {
            new IpSecAlgorithm(algName, Arrays.copyOf(KEY_MATERIAL, 256 / 8));
            fail("Expected exception on unprovided auth trunclen");
        } catch (IllegalArgumentException expected) {
        }
    }
    // Ensure crypt works with no truncation length supplied.
    new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, Arrays.copyOf(KEY_MATERIAL, 256 / 8));
}
#method_after
@Test
public void testNoTruncLen() throws Exception {
    Entry<String, Integer>[] authAndAeadList = new Entry[] { new SimpleEntry<>(IpSecAlgorithm.AUTH_HMAC_MD5, 128), new SimpleEntry<>(IpSecAlgorithm.AUTH_HMAC_SHA1, 160), new SimpleEntry<>(IpSecAlgorithm.AUTH_HMAC_SHA256, 256), new SimpleEntry<>(IpSecAlgorithm.AUTH_HMAC_SHA384, 384), new SimpleEntry<>(IpSecAlgorithm.AUTH_HMAC_SHA512, 512), new SimpleEntry<>(IpSecAlgorithm.AUTH_CRYPT_AES_GCM, 224) };
    // Expect auth and aead algorithms to throw errors if trunclen is omitted.
    for (Entry<String, Integer> algData : authAndAeadList) {
        try {
            new IpSecAlgorithm(algData.getKey(), Arrays.copyOf(KEY_MATERIAL, algData.getValue() / 8));
            fail("Expected exception on unprovided auth trunclen");
        } catch (IllegalArgumentException expected) {
        }
    }
    // Ensure crypt works with no truncation length supplied.
    new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, Arrays.copyOf(KEY_MATERIAL, 256 / 8));
}
#end_block

#method_before
protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws IllegalBlockSizeException, BadPaddingException, ShortBufferException {
    // BEGIN Android-added: Throw ShortBufferException when given a short buffer.
    if (outputOffset + engineGetOutputSize(inputLen) > output.length) {
        throw new ShortBufferException("output buffer too short for input.");
    }
    // END Android-added: Throw ShortBufferException when given a short buffer.
    if (input != null) {
        bOut.write(input, inputOffset, inputLen);
    }
    if (cipher instanceof RSABlindedEngine) {
        if (bOut.size() > cipher.getInputBlockSize() + 1) {
            throw new ArrayIndexOutOfBoundsException("too much data for RSA block");
        }
    } else {
        if (bOut.size() > cipher.getInputBlockSize()) {
            throw new ArrayIndexOutOfBoundsException("too much data for RSA block");
        }
    }
    byte[] out = getOutput();
    for (int i = 0; i != out.length; i++) {
        output[outputOffset + i] = out[i];
    }
    return out.length;
}
#method_after
protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws IllegalBlockSizeException, BadPaddingException, ShortBufferException {
    // BEGIN Android-added: Throw ShortBufferException when given a short buffer.
    if (engineGetOutputSize(inputLen) > output.length - outputOffset) {
        throw new ShortBufferException("output buffer too short for input.");
    }
    // END Android-added: Throw ShortBufferException when given a short buffer.
    if (input != null) {
        bOut.write(input, inputOffset, inputLen);
    }
    if (cipher instanceof RSABlindedEngine) {
        if (bOut.size() > cipher.getInputBlockSize() + 1) {
            throw new ArrayIndexOutOfBoundsException("too much data for RSA block");
        }
    } else {
        if (bOut.size() > cipher.getInputBlockSize()) {
            throw new ArrayIndexOutOfBoundsException("too much data for RSA block");
        }
    }
    byte[] out = getOutput();
    for (int i = 0; i != out.length; i++) {
        output[outputOffset + i] = out[i];
    }
    return out.length;
}
#end_block

#method_before
private void inferCaller() {
    needToInferCaller = false;
    // BEGIN Android-changed: Use VMStack.getThreadStackTrace.
    /*
        JavaLangAccess access = SharedSecrets.getJavaLangAccess();
        Throwable throwable = new Throwable();
        int depth = access.getStackTraceDepth(throwable);
        */
    StackTraceElement[] stack = VMStack.getThreadStackTrace(Thread.currentThread());
    int depth = stack.length;
    // END Android-changed: Use VMStack.getThreadStackTrace.
    boolean lookingForLogger = true;
    for (int ix = 0; ix < depth; ix++) {
        // Calling getStackTraceElement directly prevents the VM
        // from paying the cost of building the entire stack frame.
        // 
        // Android-changed: Use value from getThreadStackTrace.
        // StackTraceElement frame =
        // access.getStackTraceElement(throwable, ix);
        StackTraceElement frame = stack[ix];
        String cname = frame.getClassName();
        boolean isLoggerImpl = isLoggerImplFrame(cname);
        if (lookingForLogger) {
            // Skip all frames until we have found the first logger frame.
            if (isLoggerImpl) {
                lookingForLogger = false;
            }
        } else {
            if (!isLoggerImpl) {
                // skip reflection call
                if (!cname.startsWith("java.lang.reflect.") && !cname.startsWith("sun.reflect.")) {
                    // We've found the relevant frame.
                    setSourceClassName(cname);
                    setSourceMethodName(frame.getMethodName());
                    return;
                }
            }
        }
    }
// We haven't found a suitable frame, so just punt.  This is
// OK as we are only committed to making a "best effort" here.
}
#method_after
private void inferCaller() {
    needToInferCaller = false;
    // BEGIN Android-changed: Use VMStack.getThreadStackTrace.
    /*
        JavaLangAccess access = SharedSecrets.getJavaLangAccess();
        Throwable throwable = new Throwable();
        int depth = access.getStackTraceDepth(throwable);
        */
    StackTraceElement[] stack = VMStack.getThreadStackTrace(Thread.currentThread());
    int depth = stack.length;
    // END Android-changed: Use VMStack.getThreadStackTrace.
    boolean lookingForLogger = true;
    for (int ix = 0; ix < depth; ix++) {
        // Calling getStackTraceElement directly prevents the VM
        // from paying the cost of building the entire stack frame.
        // 
        // Android-changed: Use value from previous getThreadStackTrace call.
        // StackTraceElement frame =
        // access.getStackTraceElement(throwable, ix);
        StackTraceElement frame = stack[ix];
        String cname = frame.getClassName();
        boolean isLoggerImpl = isLoggerImplFrame(cname);
        if (lookingForLogger) {
            // Skip all frames until we have found the first logger frame.
            if (isLoggerImpl) {
                lookingForLogger = false;
            }
        } else {
            if (!isLoggerImpl) {
                // skip reflection call
                if (!cname.startsWith("java.lang.reflect.") && !cname.startsWith("sun.reflect.")) {
                    // We've found the relevant frame.
                    setSourceClassName(cname);
                    setSourceMethodName(frame.getMethodName());
                    return;
                }
            }
        }
    }
// We haven't found a suitable frame, so just punt.  This is
// OK as we are only committed to making a "best effort" here.
}
#end_block

#method_before
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // Retrieve the params
    TestSuiteResultMessage testSuiteResultMessage;
    try {
        String payload = request.getReader().lines().collect(Collectors.joining());
        byte[] value = Base64.decodeBase64(payload);
        testSuiteResultMessage = TestSuiteResultMessage.parseFrom(value);
    } catch (IOException e) {
        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
        logger.log(Level.WARNING, "Invalid proto: " + e.getLocalizedMessage());
        return;
    }
    Map<String, Object> resultMap = new HashMap<>();
    // Verify service account access token.
    if (testSuiteResultMessage.hasAccessToken()) {
        String accessToken = testSuiteResultMessage.getAccessToken();
        logger.log(Level.INFO, "accessToken => " + accessToken);
        // TODO : This code will be deleted after API testing completed.
        // This code is for generating 100 sample data in Test Suite Entity in datastore.
        IntStream.range(0, 100).forEach(idx -> {
            TestSuiteResultEntity ttestSuiteResultEntity = new TestSuiteResultEntity(System.currentTimeMillis() + // testSuiteResultMessage.getStartTime(),
            idx, testSuiteResultMessage.getEndTime(), testSuiteResultMessage.getAbout() + " " + idx, testSuiteResultMessage.getSuitePlan() + " " + idx, testSuiteResultMessage.getSuiteVersion() + " " + idx, testSuiteResultMessage.getSuiteBuildNumber() + " " + idx, testSuiteResultMessage.getModulesDone(), testSuiteResultMessage.getModulesTotal(), testSuiteResultMessage.getBranch() + " " + idx, testSuiteResultMessage.getTarget() + " " + idx, testSuiteResultMessage.getBuildId() + " " + idx, testSuiteResultMessage.getBuildSystemFingerprint() + " " + idx, testSuiteResultMessage.getBuildVendorFingerprint() + " " + idx, testSuiteResultMessage.getPassedTestCaseCount(), testSuiteResultMessage.getFailedTestCaseCount());
            ttestSuiteResultEntity.save();
        });
        GoogleCredential credential = new GoogleCredential().setAccessToken(accessToken);
        if (Objects.isNull(credential.getExpirationTimeMilliseconds())) {
            resultMap.put("result", "token expired!");
        } else {
            Oauth2 oauth2 = new Oauth2.Builder(new NetHttpTransport(), new JacksonFactory(), credential).setApplicationName(SERVICE_NAME).build();
            Tokeninfo tokenInfo = oauth2.tokeninfo().setAccessToken(accessToken).execute();
            if (tokenInfo.getIssuedTo().equals(SERVICE_CLIENT_ID)) {
                TestSuiteResultEntity testSuiteResultEntity = new TestSuiteResultEntity(testSuiteResultMessage.getStartTime(), testSuiteResultMessage.getEndTime(), testSuiteResultMessage.getAbout(), testSuiteResultMessage.getSuitePlan(), testSuiteResultMessage.getSuiteVersion(), testSuiteResultMessage.getSuiteBuildNumber(), testSuiteResultMessage.getModulesDone(), testSuiteResultMessage.getModulesTotal(), testSuiteResultMessage.getBranch(), testSuiteResultMessage.getTarget(), testSuiteResultMessage.getBuildId(), testSuiteResultMessage.getBuildSystemFingerprint(), testSuiteResultMessage.getBuildVendorFingerprint(), testSuiteResultMessage.getPassedTestCaseCount(), testSuiteResultMessage.getFailedTestCaseCount());
                testSuiteResultEntity.save();
                resultMap.put("result", "successfully saved!");
            } else {
                logger.log(Level.WARNING, "service_client_id didn't match!");
                logger.log(Level.INFO, "SERVICE_CLIENT_ID => " + tokenInfo.getIssuedTo());
                resultMap.put("result", "Wrong Service Client ID!");
            }
        }
    } else {
        logger.log(Level.WARNING, "postMessage do not contain any accessToken!");
        resultMap.put("result", "Access Token Missing!");
    }
    String json = new Gson().toJson(resultMap);
    response.setStatus(HttpServletResponse.SC_OK);
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");
    response.getWriter().write(json);
}
#method_after
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // Retrieve the params
    TestSuiteResultMessage testSuiteResultMessage;
    try {
        String payload = request.getReader().lines().collect(Collectors.joining());
        byte[] value = Base64.decodeBase64(payload);
        testSuiteResultMessage = TestSuiteResultMessage.parseFrom(value);
    } catch (IOException e) {
        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
        logger.log(Level.WARNING, "Invalid proto: " + e.getLocalizedMessage());
        return;
    }
    Map<String, Object> resultMap = new HashMap<>();
    // Verify service account access token.
    if (testSuiteResultMessage.hasAccessToken()) {
        String accessToken = testSuiteResultMessage.getAccessToken();
        logger.log(Level.INFO, "accessToken => " + accessToken);
        GoogleCredential credential = new GoogleCredential().setAccessToken(accessToken);
        Oauth2 oauth2 = new Oauth2.Builder(new NetHttpTransport(), new JacksonFactory(), credential).setApplicationName(SERVICE_NAME).build();
        Tokeninfo tokenInfo = oauth2.tokeninfo().setAccessToken(accessToken).execute();
        if (tokenInfo.getIssuedTo().equals(SERVICE_CLIENT_ID)) {
            TestSuiteResultEntity testSuiteResultEntity = new TestSuiteResultEntity(testSuiteResultMessage.getStartTime(), testSuiteResultMessage.getEndTime(), testSuiteResultMessage.getSuitePlan(), testSuiteResultMessage.getSuiteVersion(), testSuiteResultMessage.getSuiteBuildNumber(), testSuiteResultMessage.getModulesDone(), testSuiteResultMessage.getModulesTotal(), testSuiteResultMessage.getBranch(), testSuiteResultMessage.getTarget(), testSuiteResultMessage.getBuildId(), testSuiteResultMessage.getBuildSystemFingerprint(), testSuiteResultMessage.getBuildVendorFingerprint(), testSuiteResultMessage.getPassedTestCaseCount(), testSuiteResultMessage.getFailedTestCaseCount());
            testSuiteResultEntity.save();
            resultMap.put("result", "successfully saved!");
        } else {
            logger.log(Level.WARNING, "service_client_id didn't match!");
            logger.log(Level.INFO, "SERVICE_CLIENT_ID => " + tokenInfo.getIssuedTo());
            resultMap.put("result", "Wrong Service Client ID!");
        }
    } else {
        logger.log(Level.WARNING, "postMessage do not contain any accessToken!");
        resultMap.put("result", "Access Token Missing!");
    }
    String json = new Gson().toJson(resultMap);
    response.setStatus(HttpServletResponse.SC_OK);
    response.setContentType("application/json");
    response.setCharacterEncoding("UTF-8");
    response.getWriter().write(json);
}
#end_block

#method_before
public String getConnectionSummary() {
    // at least one profile is connected
    boolean profileConnected = false;
    // A2DP is preferred but not connected
    boolean a2dpNotConnected = false;
    // HFP is preferred but not connected
    boolean hfpNotConnected = false;
    // Hearing Aid is preferred but not connected
    boolean hearingAidNotConnected = false;
    for (LocalBluetoothProfile profile : getProfiles()) {
        int connectionStatus = getProfileConnectionState(profile);
        switch(connectionStatus) {
            case BluetoothProfile.STATE_CONNECTING:
            case BluetoothProfile.STATE_DISCONNECTING:
                return mContext.getString(Utils.getConnectionStateSummary(connectionStatus));
            case BluetoothProfile.STATE_CONNECTED:
                profileConnected = true;
                break;
            case BluetoothProfile.STATE_DISCONNECTED:
                if (profile.isProfileReady()) {
                    if ((profile instanceof A2dpProfile) || (profile instanceof A2dpSinkProfile)) {
                        a2dpNotConnected = true;
                    } else if ((profile instanceof HeadsetProfile) || (profile instanceof HfpClientProfile)) {
                        hfpNotConnected = true;
                    } else if (profile instanceof HearingAidProfile) {
                        hfpNotConnected = true;
                    }
                }
                break;
        }
    }
    String batteryLevelPercentageString = null;
    // Android framework should only set mBatteryLevel to valid range [0-100] or
    // BluetoothDevice.BATTERY_LEVEL_UNKNOWN, any other value should be a framework bug.
    // Thus assume here that if value is not BluetoothDevice.BATTERY_LEVEL_UNKNOWN, it must
    // be valid
    final int batteryLevel = getBatteryLevel();
    if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
        // TODO: name com.android.settingslib.bluetooth.Utils something different
        batteryLevelPercentageString = com.android.settingslib.Utils.formatPercentage(batteryLevel);
    }
    // Prepare the string for the Active Device summary
    String[] activeDeviceStringsArray = mContext.getResources().getStringArray(R.array.bluetooth_audio_active_device_summaries);
    // Default value: not active
    String activeDeviceString = activeDeviceStringsArray[0];
    if (mIsActiveDeviceA2dp && mIsActiveDeviceHeadset) {
        // Active for Media and Phone
        activeDeviceString = activeDeviceStringsArray[1];
    } else {
        if (mIsActiveDeviceA2dp) {
            // Active for Media only
            activeDeviceString = activeDeviceStringsArray[2];
        }
        if (mIsActiveDeviceHeadset) {
            // Active for Phone only
            activeDeviceString = activeDeviceStringsArray[3];
        }
    }
    if (mIsActiveDeviceHearingAid) {
        activeDeviceString = activeDeviceStringsArray[1];
        return mContext.getString(R.string.bluetooth_connected, activeDeviceString);
    }
    if (profileConnected) {
        if (a2dpNotConnected && hfpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_headset_no_a2dp_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_headset_no_a2dp, activeDeviceString);
            }
        } else if (a2dpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_a2dp_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_a2dp, activeDeviceString);
            }
        } else if (hfpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_headset_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_headset, activeDeviceString);
            }
        } else {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected, activeDeviceString);
            }
        }
    }
    return getBondState() == BluetoothDevice.BOND_BONDING ? mContext.getString(R.string.bluetooth_pairing) : null;
}
#method_after
public String getConnectionSummary() {
    // at least one profile is connected
    boolean profileConnected = false;
    // A2DP is preferred but not connected
    boolean a2dpNotConnected = false;
    // HFP is preferred but not connected
    boolean hfpNotConnected = false;
    // Hearing Aid is preferred but not connected
    boolean hearingAidNotConnected = false;
    for (LocalBluetoothProfile profile : getProfiles()) {
        int connectionStatus = getProfileConnectionState(profile);
        switch(connectionStatus) {
            case BluetoothProfile.STATE_CONNECTING:
            case BluetoothProfile.STATE_DISCONNECTING:
                return mContext.getString(Utils.getConnectionStateSummary(connectionStatus));
            case BluetoothProfile.STATE_CONNECTED:
                profileConnected = true;
                break;
            case BluetoothProfile.STATE_DISCONNECTED:
                if (profile.isProfileReady()) {
                    if ((profile instanceof A2dpProfile) || (profile instanceof A2dpSinkProfile)) {
                        a2dpNotConnected = true;
                    } else if ((profile instanceof HeadsetProfile) || (profile instanceof HfpClientProfile)) {
                        hfpNotConnected = true;
                    } else if (profile instanceof HearingAidProfile) {
                        hearingAidNotConnected = true;
                    }
                }
                break;
        }
    }
    String batteryLevelPercentageString = null;
    // Android framework should only set mBatteryLevel to valid range [0-100] or
    // BluetoothDevice.BATTERY_LEVEL_UNKNOWN, any other value should be a framework bug.
    // Thus assume here that if value is not BluetoothDevice.BATTERY_LEVEL_UNKNOWN, it must
    // be valid
    final int batteryLevel = getBatteryLevel();
    if (batteryLevel != BluetoothDevice.BATTERY_LEVEL_UNKNOWN) {
        // TODO: name com.android.settingslib.bluetooth.Utils something different
        batteryLevelPercentageString = com.android.settingslib.Utils.formatPercentage(batteryLevel);
    }
    // Prepare the string for the Active Device summary
    String[] activeDeviceStringsArray = mContext.getResources().getStringArray(R.array.bluetooth_audio_active_device_summaries);
    // Default value: not active
    String activeDeviceString = activeDeviceStringsArray[0];
    if (mIsActiveDeviceA2dp && mIsActiveDeviceHeadset) {
        // Active for Media and Phone
        activeDeviceString = activeDeviceStringsArray[1];
    } else {
        if (mIsActiveDeviceA2dp) {
            // Active for Media only
            activeDeviceString = activeDeviceStringsArray[2];
        }
        if (mIsActiveDeviceHeadset) {
            // Active for Phone only
            activeDeviceString = activeDeviceStringsArray[3];
        }
    }
    if (!hearingAidNotConnected && mIsActiveDeviceHearingAid) {
        activeDeviceString = activeDeviceStringsArray[1];
        return mContext.getString(R.string.bluetooth_connected, activeDeviceString);
    }
    if (profileConnected) {
        if (a2dpNotConnected && hfpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_headset_no_a2dp_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_headset_no_a2dp, activeDeviceString);
            }
        } else if (a2dpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_a2dp_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_a2dp, activeDeviceString);
            }
        } else if (hfpNotConnected) {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_no_headset_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected_no_headset, activeDeviceString);
            }
        } else {
            if (batteryLevelPercentageString != null) {
                return mContext.getString(R.string.bluetooth_connected_battery_level, batteryLevelPercentageString, activeDeviceString);
            } else {
                return mContext.getString(R.string.bluetooth_connected, activeDeviceString);
            }
        }
    }
    return getBondState() == BluetoothDevice.BOND_BONDING ? mContext.getString(R.string.bluetooth_pairing) : null;
}
#end_block

#method_before
void updateAdapterState(int prevState, int newState) {
    mAdapterProperties.setState(newState);
    if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {
        mSnoopLogSettingAtEnable = SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false);
    }
    if (mCallbacks != null) {
        int n = mCallbacks.beginBroadcast();
        debugLog("updateAdapterState() - Broadcasting state " + BluetoothAdapter.nameForState(newState) + " to " + n + " receivers.");
        for (int i = 0; i < n; i++) {
            try {
                mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);
            } catch (RemoteException e) {
                debugLog("updateAdapterState() - Callback #" + i + " failed (" + e + ")");
            }
        }
        mCallbacks.finishBroadcast();
    }
    // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.
    if (newState == BluetoothAdapter.STATE_BLE_ON && prevState != BluetoothAdapter.STATE_OFF) {
        boolean snoopLogSetting = SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false);
        if (mSnoopLogSettingAtEnable != snoopLogSetting) {
            mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);
        }
    }
}
#method_after
void updateAdapterState(int prevState, int newState) {
    mAdapterProperties.setState(newState);
    if (mCallbacks != null) {
        int n = mCallbacks.beginBroadcast();
        debugLog("updateAdapterState() - Broadcasting state " + BluetoothAdapter.nameForState(newState) + " to " + n + " receivers.");
        for (int i = 0; i < n; i++) {
            try {
                mCallbacks.getBroadcastItem(i).onBluetoothStateChange(prevState, newState);
            } catch (RemoteException e) {
                debugLog("updateAdapterState() - Callback #" + i + " failed (" + e + ")");
            }
        }
        mCallbacks.finishBroadcast();
    }
    // Turn the Adapter all the way off if we are disabling and the snoop log setting changed.
    if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON) {
        mSnoopLogSettingAtEnable = SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false);
    } else if (newState == BluetoothAdapter.STATE_BLE_ON && prevState != BluetoothAdapter.STATE_OFF) {
        boolean snoopLogSetting = SystemProperties.getBoolean(BLUETOOTH_BTSNOOP_ENABLE_PROPERTY, false);
        if (mSnoopLogSettingAtEnable != snoopLogSetting) {
            mAdapterStateMachine.sendMessage(AdapterState.BLE_TURN_OFF);
        }
    }
}
#end_block

#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    Map<String, List<String>> paramInfoMap = new HashMap<String, List<String>>() {

        {
            put("master", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
            put("oc-mr1", Arrays.asList("sailfish-userdebug", "marlin-userdebug", "taimen-userdebug", "walleye-userdebug", "aosp_arm_a-userdebug"));
            put("oc", Arrays.asList("sailfish-userdebug", "marlin-userdebug"));
        }
    };
    String testPlan = request.getParameter("plan");
    Map<String, List<DeviceBuildInfo>> baseParamMap = getBasicParamMap(paramInfoMap);
    baseParamMap.forEach((branchKey, deviceBuildInfoList) -> {
        List<List<String>> allPassIdLists = new ArrayList<>();
        Map<String, List<TestPlanRunEntity>> allTestPlanRunEntityMap = new HashMap<>();
        deviceBuildInfoList.forEach(deviceBuildInfo -> {
            Map<String, String[]> paramMap = new HashMap<String, String[]>() {

                {
                    put("branch", new String[] { branchKey });
                    put("device", new String[] { deviceBuildInfo.getDeviceBuildTarget() });
                }
            };
            Calendar cal = Calendar.getInstance();
            cal.add(Calendar.DATE, -7);
            Long startTime = cal.getTime().getTime() * 1000;
            Long endTime = Calendar.getInstance().getTime().getTime() * 1000;
            SortDirection dir = SortDirection.DESCENDING;
            boolean unfiltered = false;
            boolean showPresubmit = false;
            boolean showPostsubmit = true;
            Filter typeFilter = FilterUtil.getTestTypeFilter(showPresubmit, showPostsubmit, unfiltered);
            Key testPlanKey = KeyFactory.createKey(TestPlanEntity.KIND, testPlan);
            Filter testPlanRunFilter = FilterUtil.getTimeFilter(testPlanKey, TestPlanRunEntity.KIND, startTime, endTime, typeFilter);
            List<Filter> userTestFilters = FilterUtil.getUserTestFilters(paramMap);
            userTestFilters.add(0, testPlanRunFilter);
            Filter userDeviceFilter = FilterUtil.getUserDeviceFilter(paramMap);
            List<Key> matchingKeyList = FilterUtil.getMatchingKeys(testPlanKey, TestPlanRunEntity.KIND, userTestFilters, userDeviceFilter, dir, MAX_RUNS_PER_PAGE);
            logger.log(Level.INFO, "the number of matching key => " + matchingKeyList.size());
            if (matchingKeyList.size() > 0) {
                Map<Key, Entity> entityMap = datastore.get(matchingKeyList);
                List<TestPlanRunEntity> testPlanRunEntityList = entityMap.values().stream().map(entity -> TestPlanRunEntity.fromEntity(entity)).collect(Collectors.toList());
                allTestPlanRunEntityMap.put(branchKey + "-" + deviceBuildInfo.getDeviceBuildTarget(), testPlanRunEntityList);
                // The passBuildIdList containing all passed buildId List for
                // device
                List<String> passBuildIdList = testPlanRunEntityList.stream().filter(entity -> entity.failCount == 0L).map(entity -> entity.testBuildId).collect(Collectors.toList());
                allPassIdLists.add(passBuildIdList);
                logger.log(Level.INFO, "passBuildIdList => " + passBuildIdList);
                // The logic for candidate build ID is starting from here
                Comparator<TestPlanRunEntity> byPassing = Comparator.comparingLong(elemFirst -> elemFirst.passCount);
                Comparator<TestPlanRunEntity> byNonPassing = Comparator.comparingLong(elemFirst -> elemFirst.failCount);
                // This will get the TestPlanRunEntity having maximum number of
                // passing and minimum number of fail
                Optional<TestPlanRunEntity> testPlanRunEntity = testPlanRunEntityList.stream().sorted(byPassing.reversed().thenComparing(byNonPassing)).findFirst();
                String buildId = testPlanRunEntity.map(entity -> entity.testBuildId).orElse("");
                deviceBuildInfo.setCandidateBuildId(buildId);
                Long buildIdTimestamp = testPlanRunEntity.map(entity -> {
                    return entity.startTimestamp;
                }).orElse(0L);
                deviceBuildInfo.setCandidateBuildIdTimestamp(buildIdTimestamp);
            } else {
                allPassIdLists.add(new ArrayList<>());
                deviceBuildInfo.setCandidateBuildId("No Test Results");
            }
        });
        Set<String> greenBuildIdList = FilterUtil.getCommonElements(allPassIdLists);
        if (greenBuildIdList.size() > 0) {
            String greenBuildId = greenBuildIdList.iterator().next();
            deviceBuildInfoList.forEach(deviceBuildInfo -> {
                // This is to get the timestamp for greenBuildId
                Optional<TestPlanRunEntity> testPlanRunEntity = allTestPlanRunEntityMap.get(branchKey + "-" + deviceBuildInfo.getDeviceBuildTarget()).stream().filter(entity -> entity.testBuildId.equalsIgnoreCase(greenBuildId)).findFirst();
                // Setting the greenBuildId value and timestamp to
                // deviceBuildInfo object
                deviceBuildInfo.setGreenBuildId(greenBuildId);
                Long buildIdTimestamp = testPlanRunEntity.map(entity -> entity.startTimestamp).orElse(0L);
                deviceBuildInfo.setGreenBuildIdTimestamp(buildIdTimestamp);
            });
        }
    });
    List<TestSuiteResultEntity> testSuiteResultEntityList = ofy().load().type(TestSuiteResultEntity.class).filter("suitePlan", testPlan).list();
    request.setAttribute("plan", request.getParameter("plan"));
    request.setAttribute("greenBuildInfo", baseParamMap);
    request.setAttribute("testSuiteResultEntityList", testSuiteResultEntityList);
    response.setStatus(HttpServletResponse.SC_OK);
    RequestDispatcher dispatcher = request.getRequestDispatcher(PLAN_RELEASE_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    String testType = request.getParameter("type") == null ? "plan" : request.getParameter("type");
    RequestDispatcher dispatcher;
    if (testType.equalsIgnoreCase("plan")) {
        dispatcher = this.getTestPlanDispatcher(request, response);
    } else {
        dispatcher = this.getTestSuiteDispatcher(request, response);
    }
    try {
        request.setAttribute("testType", testType);
        response.setStatus(HttpServletResponse.SC_OK);
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
    }
}
#end_block

