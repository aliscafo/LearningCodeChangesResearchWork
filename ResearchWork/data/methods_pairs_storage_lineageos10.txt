46
#method_before
@Override
public void onChange(boolean selfChange, Uri uri) {
    if (uri.getPath() != null) {
        List<String> pathSegments = uri.getPathSegments();
        if (pathSegments.size() == 2) {
            if (pathSegments.get(0).equals("delete")) {
                String pkg = pathSegments.get(1);
                StatusBarNotification[] activeNotifications = getActiveNotifications(pkg);
                for (StatusBarNotification notification : activeNotifications) {
                    int idx = indexOfNotificationLocked(pkg, notification.getTag(), notification.getId(), notification.getUserId());
                    if (idx < 0) {
                    // great!
                    } else {
                        // remove this manually
                        synchronized (mNotificationList) {
                            mNotificationList.remove(idx);
                        }
                    }
                }
                // we need to rebuild our spam cache
                mSpamCache.evictAll();
            }
        }
    }
}
#method_after
@Override
public void onChange(boolean selfChange, Uri uri) {
    if (uri.getPath() != null) {
        List<String> pathSegments = uri.getPathSegments();
        if (pathSegments.size() >= 2) {
            if (pathSegments.get(0).equals("delete")) {
                String pkg = pathSegments.get(1);
                StatusBarNotification[] activeNotifications = getActiveNotifications(pkg);
                for (StatusBarNotification notification : activeNotifications) {
                    int idx = indexOfNotificationLocked(pkg, notification.getTag(), notification.getId(), notification.getUserId());
                    if (idx < 0) {
                    // great!
                    } else {
                        // remove this manually
                        synchronized (mNotificationList) {
                            mNotificationList.remove(idx);
                        }
                    }
                }
                // we need to rebuild our spam cache
                mSpamCache.evictAll();
            }
        }
    }
}
#end_block

#method_before
private String getPackageName(long packageId) {
    String packageName = null;
    Cursor pkgCursor = mDbHelper.getReadableDatabase().query(PackageTable.TABLE_NAME, new String[] { PackageTable.PACKAGE_NAME }, PackageTable.ID + "=?", new String[] { String.valueOf(packageId) }, null, null, null);
    if (pkgCursor != null) {
        if (pkgCursor.moveToFirst()) {
            packageName = pkgCursor.getString(0);
        }
        pkgCursor.close();
    }
    return packageName;
}
#method_after
private String getPackageName(long packageId) {
    String packageName = null;
    Cursor pkgCursor = null;
    try {
        pkgCursor = mDbHelper.getReadableDatabase().query(PackageTable.TABLE_NAME, new String[] { PackageTable.PACKAGE_NAME }, PackageTable.ID + "=?", new String[] { String.valueOf(packageId) }, null, null, null);
        if (pkgCursor != null) {
            if (pkgCursor.moveToFirst()) {
                packageName = pkgCursor.getString(0);
            }
            pkgCursor.close();
        }
    } finally {
        if (pkgCursor != null) {
            pkgCursor.close();
        }
    }
    return packageName;
}
#end_block

#method_before
/**
 * * View.OnLongClickListener Implementation ***
 */
@Override
public boolean onLongClick(View v) {
    if (v == mHeaderView.mApplicationIcon) {
        if (mCb != null) {
            boolean showDevShortcuts = Settings.Secure.getInt(v.getContext().getContentResolver(), Settings.Secure.DEVELOPMENT_SHORTCUT, 0) != 0;
            if (showDevShortcuts) {
                mCb.onTaskViewLongClicked(this);
            } else {
                mCb.onTaskViewAppInfoClicked(this);
            }
            return true;
        }
    }
    return false;
}
#method_after
/**
 * * View.OnLongClickListener Implementation ***
 */
@Override
public boolean onLongClick(View v) {
    if (v == mHeaderView.mApplicationIcon) {
        if (mCb != null) {
            boolean showDevShortcuts = CMSettings.Secure.getInt(v.getContext().getContentResolver(), CMSettings.Secure.DEVELOPMENT_SHORTCUT, 0) != 0;
            if (showDevShortcuts) {
                mCb.onTaskViewLongClicked(this);
            } else {
                mCb.onTaskViewAppInfoClicked(this);
            }
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("unused")
public final void dumpLocked(PrintWriter pw, String prefix, final int which, int reqUid) {
    final long rawUptime = SystemClock.uptimeMillis() * 1000;
    final long rawRealtime = SystemClock.elapsedRealtime() * 1000;
    final long batteryUptime = getBatteryUptime(rawUptime);
    final long batteryRealtime = getBatteryRealtime(rawRealtime);
    final long whichBatteryUptime = computeBatteryUptime(rawUptime, which);
    final long whichBatteryRealtime = computeBatteryRealtime(rawRealtime, which);
    final long totalRealtime = computeRealtime(rawRealtime, which);
    final long totalUptime = computeUptime(rawUptime, which);
    StringBuilder sb = new StringBuilder(128);
    SparseArray<? extends Uid> uidStats = getUidStats();
    final int NU = uidStats.size();
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Time on battery: ");
    formatTimeMs(sb, whichBatteryRealtime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(whichBatteryRealtime, totalRealtime));
    sb.append(") realtime, ");
    formatTimeMs(sb, whichBatteryUptime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(whichBatteryUptime, totalRealtime));
    sb.append(") uptime");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Total run time: ");
    formatTimeMs(sb, totalRealtime / 1000);
    sb.append("realtime, ");
    formatTimeMs(sb, totalUptime / 1000);
    sb.append("uptime, ");
    pw.println(sb.toString());
    final long screenOnTime = getScreenOnTime(batteryRealtime, which);
    final long phoneOnTime = getPhoneOnTime(batteryRealtime, which);
    final long wifiRunningTime = getGlobalWifiRunningTime(batteryRealtime, which);
    final long wifiOnTime = getWifiOnTime(batteryRealtime, which);
    final long bluetoothOnTime = getBluetoothOnTime(batteryRealtime, which);
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Screen on: ");
    formatTimeMs(sb, screenOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(screenOnTime, whichBatteryRealtime));
    sb.append("), Input events: ");
    sb.append(getInputEventCount(which));
    sb.append(", Active phone call: ");
    formatTimeMs(sb, phoneOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(phoneOnTime, whichBatteryRealtime));
    sb.append(")");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Screen brightnesses: ");
    boolean didOne = false;
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        final long time = getScreenBrightnessTime(i, batteryRealtime, which);
        if (time == 0) {
            continue;
        }
        if (didOne)
            sb.append(", ");
        didOne = true;
        sb.append(SCREEN_BRIGHTNESS_NAMES[i]);
        sb.append(" ");
        formatTimeMs(sb, time / 1000);
        sb.append("(");
        sb.append(formatRatioLocked(time, screenOnTime));
        sb.append(")");
    }
    if (!didOne)
        sb.append("No activity");
    pw.println(sb.toString());
    // Calculate total network and wakelock times across all uids.
    long mobileRxTotal = 0;
    long mobileTxTotal = 0;
    long wifiRxTotal = 0;
    long wifiTxTotal = 0;
    long fullWakeLockTimeTotalMicros = 0;
    long partialWakeLockTimeTotalMicros = 0;
    final Comparator<TimerEntry> timerComparator = new Comparator<TimerEntry>() {

        @Override
        public int compare(TimerEntry lhs, TimerEntry rhs) {
            long lhsTime = lhs.mTime;
            long rhsTime = rhs.mTime;
            if (lhsTime < rhsTime) {
                return 1;
            }
            if (lhsTime > rhsTime) {
                return -1;
            }
            return 0;
        }
    };
    if (reqUid < 0) {
        Map<String, ? extends BatteryStats.Timer> kernelWakelocks = getKernelWakelockStats();
        if (kernelWakelocks.size() > 0) {
            final ArrayList<TimerEntry> timers = new ArrayList<TimerEntry>();
            for (Map.Entry<String, ? extends BatteryStats.Timer> ent : kernelWakelocks.entrySet()) {
                BatteryStats.Timer timer = ent.getValue();
                long totalTimeMillis = computeWakeLock(timer, batteryRealtime, which);
                if (totalTimeMillis > 0) {
                    timers.add(new TimerEntry(ent.getKey(), 0, timer, totalTimeMillis));
                }
            }
            Collections.sort(timers, timerComparator);
            for (int i = 0; i < timers.size(); i++) {
                TimerEntry timer = timers.get(i);
                String linePrefix = ": ";
                sb.setLength(0);
                sb.append(prefix);
                sb.append("  Kernel Wake lock ");
                sb.append(timer.mName);
                linePrefix = printWakeLock(sb, timer.mTimer, batteryRealtime, null, which, linePrefix);
                if (!linePrefix.equals(": ")) {
                    sb.append(" realtime");
                    // Only print out wake locks that were held
                    pw.println(sb.toString());
                }
            }
        }
    }
    final ArrayList<TimerEntry> timers = new ArrayList<TimerEntry>();
    for (int iu = 0; iu < NU; iu++) {
        Uid u = uidStats.valueAt(iu);
        mobileRxTotal += u.getNetworkActivityCount(NETWORK_MOBILE_RX_BYTES, which);
        mobileTxTotal += u.getNetworkActivityCount(NETWORK_MOBILE_TX_BYTES, which);
        wifiRxTotal += u.getNetworkActivityCount(NETWORK_WIFI_RX_BYTES, which);
        wifiTxTotal += u.getNetworkActivityCount(NETWORK_WIFI_TX_BYTES, which);
        Map<String, ? extends BatteryStats.Uid.Wakelock> wakelocks = u.getWakelockStats();
        if (wakelocks.size() > 0) {
            for (Map.Entry<String, ? extends BatteryStats.Uid.Wakelock> ent : wakelocks.entrySet()) {
                Uid.Wakelock wl = ent.getValue();
                Timer fullWakeTimer = wl.getWakeTime(WAKE_TYPE_FULL);
                if (fullWakeTimer != null) {
                    fullWakeLockTimeTotalMicros += fullWakeTimer.getTotalTimeLocked(batteryRealtime, which);
                }
                Timer partialWakeTimer = wl.getWakeTime(WAKE_TYPE_PARTIAL);
                if (partialWakeTimer != null) {
                    long totalTimeMicros = partialWakeTimer.getTotalTimeLocked(batteryRealtime, which);
                    if (totalTimeMicros > 0) {
                        if (reqUid < 0) {
                            // Only show the ordered list of all wake
                            // locks if the caller is not asking for data
                            // about a specific uid.
                            timers.add(new TimerEntry(ent.getKey(), u.getUid(), partialWakeTimer, totalTimeMicros));
                        }
                        partialWakeLockTimeTotalMicros += totalTimeMicros;
                    }
                }
            }
        }
    }
    pw.print(prefix);
    pw.print("  Mobile total received: ");
    pw.print(formatBytesLocked(mobileRxTotal));
    pw.print(", Total sent: ");
    pw.println(formatBytesLocked(mobileTxTotal));
    pw.print(prefix);
    pw.print("  Wi-Fi total received: ");
    pw.print(formatBytesLocked(wifiRxTotal));
    pw.print(", Total sent: ");
    pw.println(formatBytesLocked(wifiTxTotal));
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Total full wakelock time: ");
    formatTimeMs(sb, (fullWakeLockTimeTotalMicros + 500) / 1000);
    sb.append(", Total partial wakelock time: ");
    formatTimeMs(sb, (partialWakeLockTimeTotalMicros + 500) / 1000);
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Signal levels: ");
    didOne = false;
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        final long time = getPhoneSignalStrengthTime(i, batteryRealtime, which);
        if (time == 0) {
            continue;
        }
        if (didOne)
            sb.append(", ");
        didOne = true;
        sb.append(SignalStrength.SIGNAL_STRENGTH_NAMES[i]);
        sb.append(" ");
        formatTimeMs(sb, time / 1000);
        sb.append("(");
        sb.append(formatRatioLocked(time, whichBatteryRealtime));
        sb.append(") ");
        sb.append(getPhoneSignalStrengthCount(i, which));
        sb.append("x");
    }
    if (!didOne)
        sb.append("No activity");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Signal scanning time: ");
    formatTimeMs(sb, getPhoneSignalScanningTime(batteryRealtime, which) / 1000);
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Radio types: ");
    didOne = false;
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        final long time = getPhoneDataConnectionTime(i, batteryRealtime, which);
        if (time == 0) {
            continue;
        }
        if (didOne)
            sb.append(", ");
        didOne = true;
        sb.append(DATA_CONNECTION_NAMES[i]);
        sb.append(" ");
        formatTimeMs(sb, time / 1000);
        sb.append("(");
        sb.append(formatRatioLocked(time, whichBatteryRealtime));
        sb.append(") ");
        sb.append(getPhoneDataConnectionCount(i, which));
        sb.append("x");
    }
    if (!didOne)
        sb.append("No activity");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Radio data uptime when unplugged: ");
    sb.append(getRadioDataUptime() / 1000);
    sb.append(" ms");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Wifi on: ");
    formatTimeMs(sb, wifiOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(wifiOnTime, whichBatteryRealtime));
    sb.append("), Wifi running: ");
    formatTimeMs(sb, wifiRunningTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(wifiRunningTime, whichBatteryRealtime));
    sb.append("), Bluetooth on: ");
    formatTimeMs(sb, bluetoothOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(bluetoothOnTime, whichBatteryRealtime));
    sb.append(")");
    pw.println(sb.toString());
    pw.println(" ");
    if (which == STATS_SINCE_UNPLUGGED) {
        if (getIsOnBattery()) {
            pw.print(prefix);
            pw.println("  Device is currently unplugged");
            pw.print(prefix);
            pw.print("    Discharge cycle start level: ");
            pw.println(getDischargeStartLevel());
            pw.print(prefix);
            pw.print("    Discharge cycle current level: ");
            pw.println(getDischargeCurrentLevel());
        } else {
            pw.print(prefix);
            pw.println("  Device is currently plugged into power");
            pw.print(prefix);
            pw.print("    Last discharge cycle start level: ");
            pw.println(getDischargeStartLevel());
            pw.print(prefix);
            pw.print("    Last discharge cycle end level: ");
            pw.println(getDischargeCurrentLevel());
        }
        pw.print(prefix);
        pw.print("    Amount discharged while screen on: ");
        pw.println(getDischargeAmountScreenOn());
        pw.print(prefix);
        pw.print("    Amount discharged while screen off: ");
        pw.println(getDischargeAmountScreenOff());
        pw.println(" ");
    } else {
        pw.print(prefix);
        pw.println("  Device battery use since last full charge");
        pw.print(prefix);
        pw.print("    Amount discharged (lower bound): ");
        pw.println(getLowDischargeAmountSinceCharge());
        pw.print(prefix);
        pw.print("    Amount discharged (upper bound): ");
        pw.println(getHighDischargeAmountSinceCharge());
        pw.print(prefix);
        pw.print("    Amount discharged while screen on: ");
        pw.println(getDischargeAmountScreenOnSinceCharge());
        pw.print(prefix);
        pw.print("    Amount discharged while screen off: ");
        pw.println(getDischargeAmountScreenOffSinceCharge());
        pw.println();
    }
    if (timers.size() > 0) {
        Collections.sort(timers, timerComparator);
        pw.print(prefix);
        pw.println("  All partial wake locks:");
        for (int i = 0; i < timers.size(); i++) {
            TimerEntry timer = timers.get(i);
            sb.setLength(0);
            sb.append("  Wake lock ");
            UserHandle.formatUid(sb, timer.mId);
            sb.append(" ");
            sb.append(timer.mName);
            printWakeLock(sb, timer.mTimer, batteryRealtime, null, which, ": ");
            sb.append(" realtime");
            pw.println(sb.toString());
        }
        timers.clear();
        pw.println();
    }
    for (int iu = 0; iu < NU; iu++) {
        final int uid = uidStats.keyAt(iu);
        if (reqUid >= 0 && uid != reqUid && uid != Process.SYSTEM_UID) {
            continue;
        }
        Uid u = uidStats.valueAt(iu);
        pw.print(prefix);
        pw.print("  ");
        UserHandle.formatUid(pw, uid);
        pw.println(":");
        boolean uidActivity = false;
        long mobileRxBytes = u.getNetworkActivityCount(NETWORK_MOBILE_RX_BYTES, which);
        long mobileTxBytes = u.getNetworkActivityCount(NETWORK_MOBILE_TX_BYTES, which);
        long wifiRxBytes = u.getNetworkActivityCount(NETWORK_WIFI_RX_BYTES, which);
        long wifiTxBytes = u.getNetworkActivityCount(NETWORK_WIFI_TX_BYTES, which);
        long fullWifiLockOnTime = u.getFullWifiLockTime(batteryRealtime, which);
        long wifiScanTime = u.getWifiScanTime(batteryRealtime, which);
        long uidWifiRunningTime = u.getWifiRunningTime(batteryRealtime, which);
        if (mobileRxBytes > 0 || mobileTxBytes > 0) {
            pw.print(prefix);
            pw.print("    Mobile network: ");
            pw.print(formatBytesLocked(mobileRxBytes));
            pw.print(" received, ");
            pw.print(formatBytesLocked(mobileTxBytes));
            pw.println(" sent");
        }
        if (wifiRxBytes > 0 || wifiTxBytes > 0) {
            pw.print(prefix);
            pw.print("    Wi-Fi network: ");
            pw.print(formatBytesLocked(wifiRxBytes));
            pw.print(" received, ");
            pw.print(formatBytesLocked(wifiTxBytes));
            pw.println(" sent");
        }
        if (u.hasUserActivity()) {
            boolean hasData = false;
            for (int i = 0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
                int val = u.getUserActivityCount(i, which);
                if (val != 0) {
                    if (!hasData) {
                        sb.setLength(0);
                        sb.append("    User activity: ");
                        hasData = true;
                    } else {
                        sb.append(", ");
                    }
                    sb.append(val);
                    sb.append(" ");
                    sb.append(Uid.USER_ACTIVITY_TYPES[i]);
                }
            }
            if (hasData) {
                pw.println(sb.toString());
            }
        }
        if (fullWifiLockOnTime != 0 || wifiScanTime != 0 || uidWifiRunningTime != 0) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append("    Wifi Running: ");
            formatTimeMs(sb, uidWifiRunningTime / 1000);
            sb.append("(");
            sb.append(formatRatioLocked(uidWifiRunningTime, whichBatteryRealtime));
            sb.append(")\n");
            sb.append(prefix);
            sb.append("    Full Wifi Lock: ");
            formatTimeMs(sb, fullWifiLockOnTime / 1000);
            sb.append("(");
            sb.append(formatRatioLocked(fullWifiLockOnTime, whichBatteryRealtime));
            sb.append(")\n");
            sb.append(prefix);
            sb.append("    Wifi Scan: ");
            formatTimeMs(sb, wifiScanTime / 1000);
            sb.append("(");
            sb.append(formatRatioLocked(wifiScanTime, whichBatteryRealtime));
            sb.append(")");
            pw.println(sb.toString());
        }
        Map<String, ? extends BatteryStats.Uid.Wakelock> wakelocks = u.getWakelockStats();
        if (wakelocks.size() > 0) {
            long totalFull = 0, totalPartial = 0, totalWindow = 0;
            int count = 0;
            for (Map.Entry<String, ? extends BatteryStats.Uid.Wakelock> ent : wakelocks.entrySet()) {
                Uid.Wakelock wl = ent.getValue();
                String linePrefix = ": ";
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Wake lock ");
                sb.append(ent.getKey());
                linePrefix = printWakeLock(sb, wl.getWakeTime(WAKE_TYPE_FULL), batteryRealtime, "full", which, linePrefix);
                linePrefix = printWakeLock(sb, wl.getWakeTime(WAKE_TYPE_PARTIAL), batteryRealtime, "partial", which, linePrefix);
                linePrefix = printWakeLock(sb, wl.getWakeTime(WAKE_TYPE_WINDOW), batteryRealtime, "window", which, linePrefix);
                if (!linePrefix.equals(": ")) {
                    sb.append(" realtime");
                    // Only print out wake locks that were held
                    pw.println(sb.toString());
                    uidActivity = true;
                    count++;
                }
                totalFull += computeWakeLock(wl.getWakeTime(WAKE_TYPE_FULL), batteryRealtime, which);
                totalPartial += computeWakeLock(wl.getWakeTime(WAKE_TYPE_PARTIAL), batteryRealtime, which);
                totalWindow += computeWakeLock(wl.getWakeTime(WAKE_TYPE_WINDOW), batteryRealtime, which);
            }
            if (count > 1) {
                if (totalFull != 0 || totalPartial != 0 || totalWindow != 0) {
                    sb.setLength(0);
                    sb.append(prefix);
                    sb.append("    TOTAL wake: ");
                    boolean needComma = false;
                    if (totalFull != 0) {
                        needComma = true;
                        formatTimeMs(sb, totalFull);
                        sb.append("full");
                    }
                    if (totalPartial != 0) {
                        if (needComma) {
                            sb.append(", ");
                        }
                        needComma = true;
                        formatTimeMs(sb, totalPartial);
                        sb.append("partial");
                    }
                    if (totalWindow != 0) {
                        if (needComma) {
                            sb.append(", ");
                        }
                        needComma = true;
                        formatTimeMs(sb, totalWindow);
                        sb.append("window");
                    }
                    sb.append(" realtime");
                    pw.println(sb.toString());
                }
            }
        }
        Map<Integer, ? extends BatteryStats.Uid.Sensor> sensors = u.getSensorStats();
        if (sensors.size() > 0) {
            for (Map.Entry<Integer, ? extends BatteryStats.Uid.Sensor> ent : sensors.entrySet()) {
                Uid.Sensor se = ent.getValue();
                int sensorNumber = ent.getKey();
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Sensor ");
                int handle = se.getHandle();
                if (handle == Uid.Sensor.GPS) {
                    sb.append("GPS");
                } else {
                    sb.append(handle);
                }
                sb.append(": ");
                Timer timer = se.getSensorTime();
                if (timer != null) {
                    // Convert from microseconds to milliseconds with rounding
                    long totalTime = (timer.getTotalTimeLocked(batteryRealtime, which) + 500) / 1000;
                    int count = timer.getCountLocked(which);
                    // timer.logState();
                    if (totalTime != 0) {
                        formatTimeMs(sb, totalTime);
                        sb.append("realtime (");
                        sb.append(count);
                        sb.append(" times)");
                    } else {
                        sb.append("(not used)");
                    }
                } else {
                    sb.append("(not used)");
                }
                pw.println(sb.toString());
                uidActivity = true;
            }
        }
        Timer vibTimer = u.getVibratorOnTimer();
        if (vibTimer != null) {
            // Convert from microseconds to milliseconds with rounding
            long totalTime = (vibTimer.getTotalTimeLocked(batteryRealtime, which) + 500) / 1000;
            int count = vibTimer.getCountLocked(which);
            // timer.logState();
            if (totalTime != 0) {
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Vibrator: ");
                formatTimeMs(sb, totalTime);
                sb.append("realtime (");
                sb.append(count);
                sb.append(" times)");
                pw.println(sb.toString());
                uidActivity = true;
            }
        }
        Timer fgTimer = u.getForegroundActivityTimer();
        if (fgTimer != null) {
            // Convert from microseconds to milliseconds with rounding
            long totalTime = (fgTimer.getTotalTimeLocked(batteryRealtime, which) + 500) / 1000;
            int count = fgTimer.getCountLocked(which);
            if (totalTime != 0) {
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Foreground activities: ");
                formatTimeMs(sb, totalTime);
                sb.append("realtime (");
                sb.append(count);
                sb.append(" times)");
                pw.println(sb.toString());
                uidActivity = true;
            }
        }
        Map<String, ? extends BatteryStats.Uid.Proc> processStats = u.getProcessStats();
        if (processStats.size() > 0) {
            for (Map.Entry<String, ? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
                Uid.Proc ps = ent.getValue();
                long userTime;
                long systemTime;
                long foregroundTime;
                int starts;
                int numExcessive;
                userTime = ps.getUserTime(which);
                systemTime = ps.getSystemTime(which);
                foregroundTime = ps.getForegroundTime(which);
                starts = ps.getStarts(which);
                numExcessive = which == STATS_SINCE_CHARGED ? ps.countExcessivePowers() : 0;
                if (userTime != 0 || systemTime != 0 || foregroundTime != 0 || starts != 0 || numExcessive != 0) {
                    sb.setLength(0);
                    sb.append(prefix);
                    sb.append("    Proc ");
                    sb.append(ent.getKey());
                    sb.append(":\n");
                    sb.append(prefix);
                    sb.append("      CPU: ");
                    formatTime(sb, userTime);
                    sb.append("usr + ");
                    formatTime(sb, systemTime);
                    sb.append("krn ; ");
                    formatTime(sb, foregroundTime);
                    sb.append("fg");
                    if (starts != 0) {
                        sb.append("\n");
                        sb.append(prefix);
                        sb.append("      ");
                        sb.append(starts);
                        sb.append(" proc starts");
                    }
                    pw.println(sb.toString());
                    for (int e = 0; e < numExcessive; e++) {
                        Uid.Proc.ExcessivePower ew = ps.getExcessivePower(e);
                        if (ew != null) {
                            pw.print(prefix);
                            pw.print("      * Killed for ");
                            if (ew.type == Uid.Proc.ExcessivePower.TYPE_WAKE) {
                                pw.print("wake lock");
                            } else if (ew.type == Uid.Proc.ExcessivePower.TYPE_CPU) {
                                pw.print("cpu");
                            } else {
                                pw.print("unknown");
                            }
                            pw.print(" use: ");
                            TimeUtils.formatDuration(ew.usedTime, pw);
                            pw.print(" over ");
                            TimeUtils.formatDuration(ew.overTime, pw);
                            pw.print(" (");
                            pw.print((ew.usedTime * 100) / ew.overTime);
                            pw.println("%)");
                        }
                    }
                    uidActivity = true;
                }
            }
        }
        Map<String, ? extends BatteryStats.Uid.Pkg> packageStats = u.getPackageStats();
        if (packageStats.size() > 0) {
            for (Map.Entry<String, ? extends BatteryStats.Uid.Pkg> ent : packageStats.entrySet()) {
                pw.print(prefix);
                pw.print("    Apk ");
                pw.print(ent.getKey());
                pw.println(":");
                boolean apkActivity = false;
                Uid.Pkg ps = ent.getValue();
                int wakeups = ps.getWakeups(which);
                if (wakeups != 0) {
                    pw.print(prefix);
                    pw.print("      ");
                    pw.print(wakeups);
                    pw.println(" wakeup alarms");
                    apkActivity = true;
                }
                Map<String, ? extends Uid.Pkg.Serv> serviceStats = ps.getServiceStats();
                if (serviceStats.size() > 0) {
                    for (Map.Entry<String, ? extends BatteryStats.Uid.Pkg.Serv> sent : serviceStats.entrySet()) {
                        BatteryStats.Uid.Pkg.Serv ss = sent.getValue();
                        long startTime = ss.getStartTime(batteryUptime, which);
                        int starts = ss.getStarts(which);
                        int launches = ss.getLaunches(which);
                        if (startTime != 0 || starts != 0 || launches != 0) {
                            sb.setLength(0);
                            sb.append(prefix);
                            sb.append("      Service ");
                            sb.append(sent.getKey());
                            sb.append(":\n");
                            sb.append(prefix);
                            sb.append("        Created for: ");
                            formatTimeMs(sb, startTime / 1000);
                            sb.append("uptime\n");
                            sb.append(prefix);
                            sb.append("        Starts: ");
                            sb.append(starts);
                            sb.append(", launches: ");
                            sb.append(launches);
                            pw.println(sb.toString());
                            apkActivity = true;
                        }
                    }
                }
                if (!apkActivity) {
                    pw.print(prefix);
                    pw.println("      (nothing executed)");
                }
                uidActivity = true;
            }
        }
        if (!uidActivity) {
            pw.print(prefix);
            pw.println("    (nothing executed)");
        }
    }
}
#method_after
@SuppressWarnings("unused")
public final void dumpLocked(PrintWriter pw, String prefix, final int which, int reqUid) {
    final long rawUptime = SystemClock.uptimeMillis() * 1000;
    final long rawRealtime = SystemClock.elapsedRealtime() * 1000;
    final long batteryUptime = getBatteryUptime(rawUptime);
    final long batteryRealtime = getBatteryRealtime(rawRealtime);
    final long whichBatteryUptime = computeBatteryUptime(rawUptime, which);
    final long whichBatteryRealtime = computeBatteryRealtime(rawRealtime, which);
    final long totalRealtime = computeRealtime(rawRealtime, which);
    final long totalUptime = computeUptime(rawUptime, which);
    StringBuilder sb = new StringBuilder(128);
    SparseArray<? extends Uid> uidStats = getUidStats();
    final int NU = uidStats.size();
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Time on battery: ");
    formatTimeMs(sb, whichBatteryRealtime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(whichBatteryRealtime, totalRealtime));
    sb.append(") realtime, ");
    formatTimeMs(sb, whichBatteryUptime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(whichBatteryUptime, totalRealtime));
    sb.append(") uptime");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Total run time: ");
    formatTimeMs(sb, totalRealtime / 1000);
    sb.append("realtime, ");
    formatTimeMs(sb, totalUptime / 1000);
    sb.append("uptime, ");
    pw.println(sb.toString());
    final long screenOnTime = getScreenOnTime(batteryRealtime, which);
    final long phoneOnTime = getPhoneOnTime(batteryRealtime, which);
    final long wifiRunningTime = getGlobalWifiRunningTime(batteryRealtime, which);
    final long wifiOnTime = getWifiOnTime(batteryRealtime, which);
    final long bluetoothOnTime = getBluetoothOnTime(batteryRealtime, which);
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Screen on: ");
    formatTimeMs(sb, screenOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(screenOnTime, whichBatteryRealtime));
    sb.append("), Input events: ");
    sb.append(getInputEventCount(which));
    sb.append(", Active phone call: ");
    formatTimeMs(sb, phoneOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(phoneOnTime, whichBatteryRealtime));
    sb.append(")");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Screen brightnesses: ");
    boolean didOne = false;
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        final long time = getScreenBrightnessTime(i, batteryRealtime, which);
        if (time == 0) {
            continue;
        }
        if (didOne)
            sb.append(", ");
        didOne = true;
        sb.append(SCREEN_BRIGHTNESS_NAMES[i]);
        sb.append(" ");
        formatTimeMs(sb, time / 1000);
        sb.append("(");
        sb.append(formatRatioLocked(time, screenOnTime));
        sb.append(")");
    }
    if (!didOne)
        sb.append("No activity");
    pw.println(sb.toString());
    // Calculate total network and wakelock times across all uids.
    long mobileRxTotal = 0;
    long mobileTxTotal = 0;
    long wifiRxTotal = 0;
    long wifiTxTotal = 0;
    long fullWakeLockTimeTotalMicros = 0;
    long partialWakeLockTimeTotalMicros = 0;
    final Comparator<TimerEntry> timerComparator = new Comparator<TimerEntry>() {

        @Override
        public int compare(TimerEntry lhs, TimerEntry rhs) {
            long lhsTime = lhs.mTime;
            long rhsTime = rhs.mTime;
            if (lhsTime < rhsTime) {
                return 1;
            }
            if (lhsTime > rhsTime) {
                return -1;
            }
            return 0;
        }
    };
    if (reqUid < 0) {
        Map<String, ? extends BatteryStats.Timer> kernelWakelocks = getKernelWakelockStats();
        if (kernelWakelocks.size() > 0) {
            final ArrayList<TimerEntry> timers = new ArrayList<TimerEntry>();
            for (Map.Entry<String, ? extends BatteryStats.Timer> ent : kernelWakelocks.entrySet()) {
                BatteryStats.Timer timer = ent.getValue();
                long totalTimeMillis = computeWakeLock(timer, batteryRealtime, which);
                if (totalTimeMillis > 0) {
                    timers.add(new TimerEntry(ent.getKey(), 0, timer, totalTimeMillis));
                }
            }
            Collections.sort(timers, timerComparator);
            for (int i = 0; i < timers.size(); i++) {
                TimerEntry timer = timers.get(i);
                String linePrefix = ": ";
                sb.setLength(0);
                sb.append(prefix);
                sb.append("  Kernel Wake lock ");
                sb.append(timer.mName);
                linePrefix = printWakeLock(sb, timer.mTimer, batteryRealtime, null, which, linePrefix);
                if (!linePrefix.equals(": ")) {
                    sb.append(" realtime");
                    // Only print out wake locks that were held
                    pw.println(sb.toString());
                }
            }
        }
    }
    final ArrayList<TimerEntry> timers = new ArrayList<TimerEntry>();
    for (int iu = 0; iu < NU; iu++) {
        Uid u = uidStats.valueAt(iu);
        mobileRxTotal += u.getNetworkActivityCount(NETWORK_MOBILE_RX_BYTES, which);
        mobileTxTotal += u.getNetworkActivityCount(NETWORK_MOBILE_TX_BYTES, which);
        wifiRxTotal += u.getNetworkActivityCount(NETWORK_WIFI_RX_BYTES, which);
        wifiTxTotal += u.getNetworkActivityCount(NETWORK_WIFI_TX_BYTES, which);
        Map<String, ? extends BatteryStats.Uid.Wakelock> wakelocks = u.getWakelockStats();
        if (wakelocks.size() > 0) {
            for (Map.Entry<String, ? extends BatteryStats.Uid.Wakelock> ent : wakelocks.entrySet()) {
                Uid.Wakelock wl = ent.getValue();
                Timer fullWakeTimer = wl.getWakeTime(WAKE_TYPE_FULL);
                if (fullWakeTimer != null) {
                    fullWakeLockTimeTotalMicros += fullWakeTimer.getTotalTimeLocked(batteryRealtime, which);
                }
                Timer partialWakeTimer = wl.getWakeTime(WAKE_TYPE_PARTIAL);
                if (partialWakeTimer != null) {
                    long totalTimeMicros = partialWakeTimer.getTotalTimeLocked(batteryRealtime, which);
                    if (totalTimeMicros > 0) {
                        if (reqUid < 0) {
                            // Only show the ordered list of all wake
                            // locks if the caller is not asking for data
                            // about a specific uid.
                            timers.add(new TimerEntry(ent.getKey(), u.getUid(), partialWakeTimer, totalTimeMicros));
                        }
                        partialWakeLockTimeTotalMicros += totalTimeMicros;
                    }
                }
            }
        }
    }
    pw.print(prefix);
    pw.print("  Mobile total received: ");
    pw.print(formatBytesLocked(mobileRxTotal));
    pw.print(", Total sent: ");
    pw.println(formatBytesLocked(mobileTxTotal));
    pw.print(prefix);
    pw.print("  Wi-Fi total received: ");
    pw.print(formatBytesLocked(wifiRxTotal));
    pw.print(", Total sent: ");
    pw.println(formatBytesLocked(wifiTxTotal));
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Total full wakelock time: ");
    formatTimeMs(sb, (fullWakeLockTimeTotalMicros + 500) / 1000);
    sb.append(", Total partial wakelock time: ");
    formatTimeMs(sb, (partialWakeLockTimeTotalMicros + 500) / 1000);
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Signal levels: ");
    didOne = false;
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        final long time = getPhoneSignalStrengthTime(i, batteryRealtime, which);
        if (time == 0) {
            continue;
        }
        if (didOne)
            sb.append(", ");
        didOne = true;
        sb.append(SignalStrength.SIGNAL_STRENGTH_NAMES[i]);
        sb.append(" ");
        formatTimeMs(sb, time / 1000);
        sb.append("(");
        sb.append(formatRatioLocked(time, whichBatteryRealtime));
        sb.append(") ");
        sb.append(getPhoneSignalStrengthCount(i, which));
        sb.append("x");
    }
    if (!didOne)
        sb.append("No activity");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Signal scanning time: ");
    formatTimeMs(sb, getPhoneSignalScanningTime(batteryRealtime, which) / 1000);
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Radio types: ");
    didOne = false;
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        final long time = getPhoneDataConnectionTime(i, batteryRealtime, which);
        if (time == 0) {
            continue;
        }
        if (didOne)
            sb.append(", ");
        didOne = true;
        sb.append(DATA_CONNECTION_NAMES[i]);
        sb.append(" ");
        formatTimeMs(sb, time / 1000);
        sb.append("(");
        sb.append(formatRatioLocked(time, whichBatteryRealtime));
        sb.append(") ");
        sb.append(getPhoneDataConnectionCount(i, which));
        sb.append("x");
    }
    if (!didOne)
        sb.append("No activity");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Radio data uptime when unplugged: ");
    sb.append(getRadioDataUptime() / 1000);
    sb.append(" ms");
    pw.println(sb.toString());
    sb.setLength(0);
    sb.append(prefix);
    sb.append("  Wifi on: ");
    formatTimeMs(sb, wifiOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(wifiOnTime, whichBatteryRealtime));
    sb.append("), Wifi running: ");
    formatTimeMs(sb, wifiRunningTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(wifiRunningTime, whichBatteryRealtime));
    sb.append("), Bluetooth on: ");
    formatTimeMs(sb, bluetoothOnTime / 1000);
    sb.append("(");
    sb.append(formatRatioLocked(bluetoothOnTime, whichBatteryRealtime));
    sb.append(")");
    pw.println(sb.toString());
    pw.println(" ");
    if (which == STATS_SINCE_UNPLUGGED) {
        if (getIsOnBattery()) {
            pw.print(prefix);
            pw.println("  Device is currently unplugged");
            pw.print(prefix);
            pw.print("    Discharge cycle start level: ");
            pw.println(getDischargeStartLevel());
            pw.print(prefix);
            pw.print("    Discharge cycle current level: ");
            pw.println(getDischargeCurrentLevel());
        } else {
            pw.print(prefix);
            pw.println("  Device is currently plugged into power");
            pw.print(prefix);
            pw.print("    Last discharge cycle start level: ");
            pw.println(getDischargeStartLevel());
            pw.print(prefix);
            pw.print("    Last discharge cycle end level: ");
            pw.println(getDischargeCurrentLevel());
        }
        pw.print(prefix);
        pw.print("    Amount discharged while screen on: ");
        pw.println(getDischargeAmountScreenOn());
        pw.print(prefix);
        pw.print("    Amount discharged while screen off: ");
        pw.println(getDischargeAmountScreenOff());
        pw.println(" ");
    } else {
        pw.print(prefix);
        pw.println("  Device battery use since last full charge");
        pw.print(prefix);
        pw.print("    Amount discharged (lower bound): ");
        pw.println(getLowDischargeAmountSinceCharge());
        pw.print(prefix);
        pw.print("    Amount discharged (upper bound): ");
        pw.println(getHighDischargeAmountSinceCharge());
        pw.print(prefix);
        pw.print("    Amount discharged while screen on: ");
        pw.println(getDischargeAmountScreenOnSinceCharge());
        pw.print(prefix);
        pw.print("    Amount discharged while screen off: ");
        pw.println(getDischargeAmountScreenOffSinceCharge());
        pw.println();
    }
    if (timers.size() > 0) {
        Collections.sort(timers, timerComparator);
        pw.print(prefix);
        pw.println("  All partial wake locks:");
        for (int i = 0; i < timers.size(); i++) {
            TimerEntry timer = timers.get(i);
            sb.setLength(0);
            sb.append("  Wake lock ");
            UserHandle.formatUid(sb, timer.mId);
            sb.append(" ");
            sb.append(timer.mName);
            printWakeLock(sb, timer.mTimer, batteryRealtime, null, which, ": ");
            sb.append(" realtime");
            pw.println(sb.toString());
        }
        timers.clear();
        pw.println();
    }
    for (int iu = 0; iu < NU; iu++) {
        final int uid = uidStats.keyAt(iu);
        if (reqUid >= 0 && uid != reqUid && uid != Process.SYSTEM_UID) {
            continue;
        }
        Uid u = uidStats.valueAt(iu);
        pw.print(prefix);
        pw.print("  ");
        UserHandle.formatUid(pw, uid);
        pw.println(":");
        boolean uidActivity = false;
        long mobileRxBytes = u.getNetworkActivityCount(NETWORK_MOBILE_RX_BYTES, which);
        long mobileTxBytes = u.getNetworkActivityCount(NETWORK_MOBILE_TX_BYTES, which);
        long wifiRxBytes = u.getNetworkActivityCount(NETWORK_WIFI_RX_BYTES, which);
        long wifiTxBytes = u.getNetworkActivityCount(NETWORK_WIFI_TX_BYTES, which);
        long fullWifiLockOnTime = u.getFullWifiLockTime(batteryRealtime, which);
        long wifiScanTime = u.getWifiScanTime(batteryRealtime, which);
        long uidWifiRunningTime = u.getWifiRunningTime(batteryRealtime, which);
        if (mobileRxBytes > 0 || mobileTxBytes > 0) {
            pw.print(prefix);
            pw.print("    Mobile network: ");
            pw.print(formatBytesLocked(mobileRxBytes));
            pw.print(" received, ");
            pw.print(formatBytesLocked(mobileTxBytes));
            pw.println(" sent");
        }
        if (wifiRxBytes > 0 || wifiTxBytes > 0) {
            pw.print(prefix);
            pw.print("    Wi-Fi network: ");
            pw.print(formatBytesLocked(wifiRxBytes));
            pw.print(" received, ");
            pw.print(formatBytesLocked(wifiTxBytes));
            pw.println(" sent");
        }
        if (u.hasUserActivity()) {
            boolean hasData = false;
            for (int i = 0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
                int val = u.getUserActivityCount(i, which);
                if (val != 0) {
                    if (!hasData) {
                        sb.setLength(0);
                        sb.append("    User activity: ");
                        hasData = true;
                    } else {
                        sb.append(", ");
                    }
                    sb.append(val);
                    sb.append(" ");
                    sb.append(Uid.USER_ACTIVITY_TYPES[i]);
                }
            }
            if (hasData) {
                pw.println(sb.toString());
            }
        }
        if (fullWifiLockOnTime != 0 || wifiScanTime != 0 || uidWifiRunningTime != 0) {
            sb.setLength(0);
            sb.append(prefix);
            sb.append("    Wifi Running: ");
            formatTimeMs(sb, uidWifiRunningTime / 1000);
            sb.append("(");
            sb.append(formatRatioLocked(uidWifiRunningTime, whichBatteryRealtime));
            sb.append(")\n");
            sb.append(prefix);
            sb.append("    Full Wifi Lock: ");
            formatTimeMs(sb, fullWifiLockOnTime / 1000);
            sb.append("(");
            sb.append(formatRatioLocked(fullWifiLockOnTime, whichBatteryRealtime));
            sb.append(")\n");
            sb.append(prefix);
            sb.append("    Wifi Scan: ");
            formatTimeMs(sb, wifiScanTime / 1000);
            sb.append("(");
            sb.append(formatRatioLocked(wifiScanTime, whichBatteryRealtime));
            sb.append(")");
            pw.println(sb.toString());
        }
        Map<String, ? extends BatteryStats.Uid.Wakelock> wakelocks = u.getWakelockStats();
        if (wakelocks.size() > 0) {
            long totalFull = 0, totalPartial = 0, totalWindow = 0;
            int count = 0;
            for (Map.Entry<String, ? extends BatteryStats.Uid.Wakelock> ent : wakelocks.entrySet()) {
                Uid.Wakelock wl = ent.getValue();
                String linePrefix = ": ";
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Wake lock ");
                sb.append(ent.getKey());
                linePrefix = printWakeLock(sb, wl.getWakeTime(WAKE_TYPE_FULL), batteryRealtime, "full", which, linePrefix);
                linePrefix = printWakeLock(sb, wl.getWakeTime(WAKE_TYPE_PARTIAL), batteryRealtime, "partial", which, linePrefix);
                linePrefix = printWakeLock(sb, wl.getWakeTime(WAKE_TYPE_WINDOW), batteryRealtime, "window", which, linePrefix);
                if (!linePrefix.equals(": ")) {
                    sb.append(" realtime");
                    // Only print out wake locks that were held
                    pw.println(sb.toString());
                    uidActivity = true;
                    count++;
                }
                totalFull += computeWakeLock(wl.getWakeTime(WAKE_TYPE_FULL), batteryRealtime, which);
                totalPartial += computeWakeLock(wl.getWakeTime(WAKE_TYPE_PARTIAL), batteryRealtime, which);
                totalWindow += computeWakeLock(wl.getWakeTime(WAKE_TYPE_WINDOW), batteryRealtime, which);
            }
            if (count > 1) {
                if (totalFull != 0 || totalPartial != 0 || totalWindow != 0) {
                    sb.setLength(0);
                    sb.append(prefix);
                    sb.append("    TOTAL wake: ");
                    boolean needComma = false;
                    if (totalFull != 0) {
                        needComma = true;
                        formatTimeMs(sb, totalFull);
                        sb.append("full");
                    }
                    if (totalPartial != 0) {
                        if (needComma) {
                            sb.append(", ");
                        }
                        needComma = true;
                        formatTimeMs(sb, totalPartial);
                        sb.append("partial");
                    }
                    if (totalWindow != 0) {
                        if (needComma) {
                            sb.append(", ");
                        }
                        needComma = true;
                        formatTimeMs(sb, totalWindow);
                        sb.append("window");
                    }
                    sb.append(" realtime");
                    pw.println(sb.toString());
                }
            }
        }
        Map<Integer, ? extends BatteryStats.Uid.Sensor> sensors = u.getSensorStats();
        if (sensors.size() > 0) {
            for (Map.Entry<Integer, ? extends BatteryStats.Uid.Sensor> ent : sensors.entrySet()) {
                Uid.Sensor se = ent.getValue();
                int sensorNumber = ent.getKey();
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Sensor ");
                int handle = se.getHandle();
                if (handle == Uid.Sensor.GPS) {
                    sb.append("GPS");
                } else {
                    sb.append(handle);
                }
                sb.append(": ");
                Timer timer = se.getSensorTime();
                if (timer != null) {
                    // Convert from microseconds to milliseconds with rounding
                    long totalTime = (timer.getTotalTimeLocked(batteryRealtime, which) + 500) / 1000;
                    int count = timer.getCountLocked(which);
                    // timer.logState();
                    if (totalTime != 0) {
                        formatTimeMs(sb, totalTime);
                        sb.append("realtime (");
                        sb.append(count);
                        sb.append(" times)");
                    } else {
                        sb.append("(not used)");
                    }
                } else {
                    sb.append("(not used)");
                }
                pw.println(sb.toString());
                uidActivity = true;
            }
        }
        Timer vibTimer = u.getVibratorOnTimer();
        if (vibTimer != null) {
            // Convert from microseconds to milliseconds with rounding
            long totalTime = (vibTimer.getTotalTimeLocked(batteryRealtime, which) + 500) / 1000;
            int count = vibTimer.getCountLocked(which);
            // timer.logState();
            if (totalTime != 0) {
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Vibrator: ");
                formatTimeMs(sb, totalTime);
                sb.append("realtime (");
                sb.append(count);
                sb.append(" times)");
                pw.println(sb.toString());
                uidActivity = true;
            }
        }
        Timer fgTimer = u.getForegroundActivityTimer();
        if (fgTimer != null) {
            // Convert from microseconds to milliseconds with rounding
            long totalTime = (fgTimer.getTotalTimeLocked(batteryRealtime, which) + 500) / 1000;
            int count = fgTimer.getCountLocked(which);
            if (totalTime != 0) {
                sb.setLength(0);
                sb.append(prefix);
                sb.append("    Foreground activities: ");
                formatTimeMs(sb, totalTime);
                sb.append("realtime (");
                sb.append(count);
                sb.append(" times)");
                pw.println(sb.toString());
                uidActivity = true;
            }
        }
        Map<String, ? extends BatteryStats.Uid.Proc> processStats = u.getProcessStats();
        if (processStats.size() > 0) {
            for (Map.Entry<String, ? extends BatteryStats.Uid.Proc> ent : processStats.entrySet()) {
                Uid.Proc ps = ent.getValue();
                long userTime;
                long systemTime;
                long foregroundTime;
                int starts;
                int numExcessive;
                userTime = ps.getUserTime(which);
                systemTime = ps.getSystemTime(which);
                foregroundTime = ps.getForegroundTime(which);
                starts = ps.getStarts(which);
                numExcessive = which == STATS_SINCE_CHARGED ? ps.countExcessivePowers() : 0;
                if (userTime != 0 || systemTime != 0 || foregroundTime != 0 || starts != 0 || numExcessive != 0) {
                    sb.setLength(0);
                    sb.append(prefix);
                    sb.append("    Proc ");
                    sb.append(ent.getKey());
                    sb.append(":\n");
                    sb.append(prefix);
                    sb.append("      CPU: ");
                    formatTime(sb, userTime);
                    sb.append("usr + ");
                    formatTime(sb, systemTime);
                    sb.append("krn ; ");
                    formatTime(sb, foregroundTime);
                    sb.append("fg");
                    if (starts != 0) {
                        sb.append("\n");
                        sb.append(prefix);
                        sb.append("      ");
                        sb.append(starts);
                        sb.append(" proc starts");
                    }
                    pw.println(sb.toString());
                    for (int e = 0; e < numExcessive; e++) {
                        Uid.Proc.ExcessivePower ew = ps.getExcessivePower(e);
                        if (ew != null) {
                            pw.print(prefix);
                            pw.print("      * Killed for ");
                            if (ew.type == Uid.Proc.ExcessivePower.TYPE_WAKE) {
                                pw.print("wake lock");
                            } else if (ew.type == Uid.Proc.ExcessivePower.TYPE_CPU) {
                                pw.print("cpu");
                            } else {
                                pw.print("unknown");
                            }
                            pw.print(" use: ");
                            TimeUtils.formatDuration(ew.usedTime, pw);
                            pw.print(" over ");
                            TimeUtils.formatDuration(ew.overTime, pw);
                            if (ew.overTime != 0) {
                                pw.print(" (");
                                pw.print((ew.usedTime * 100) / ew.overTime);
                                pw.println("%)");
                            }
                        }
                    }
                    uidActivity = true;
                }
            }
        }
        Map<String, ? extends BatteryStats.Uid.Pkg> packageStats = u.getPackageStats();
        if (packageStats.size() > 0) {
            for (Map.Entry<String, ? extends BatteryStats.Uid.Pkg> ent : packageStats.entrySet()) {
                pw.print(prefix);
                pw.print("    Apk ");
                pw.print(ent.getKey());
                pw.println(":");
                boolean apkActivity = false;
                Uid.Pkg ps = ent.getValue();
                int wakeups = ps.getWakeups(which);
                if (wakeups != 0) {
                    pw.print(prefix);
                    pw.print("      ");
                    pw.print(wakeups);
                    pw.println(" wakeup alarms");
                    apkActivity = true;
                }
                Map<String, ? extends Uid.Pkg.Serv> serviceStats = ps.getServiceStats();
                if (serviceStats.size() > 0) {
                    for (Map.Entry<String, ? extends BatteryStats.Uid.Pkg.Serv> sent : serviceStats.entrySet()) {
                        BatteryStats.Uid.Pkg.Serv ss = sent.getValue();
                        long startTime = ss.getStartTime(batteryUptime, which);
                        int starts = ss.getStarts(which);
                        int launches = ss.getLaunches(which);
                        if (startTime != 0 || starts != 0 || launches != 0) {
                            sb.setLength(0);
                            sb.append(prefix);
                            sb.append("      Service ");
                            sb.append(sent.getKey());
                            sb.append(":\n");
                            sb.append(prefix);
                            sb.append("        Created for: ");
                            formatTimeMs(sb, startTime / 1000);
                            sb.append("uptime\n");
                            sb.append(prefix);
                            sb.append("        Starts: ");
                            sb.append(starts);
                            sb.append(", launches: ");
                            sb.append(launches);
                            pw.println(sb.toString());
                            apkActivity = true;
                        }
                    }
                }
                if (!apkActivity) {
                    pw.print(prefix);
                    pw.println("      (nothing executed)");
                }
                uidActivity = true;
            }
        }
        if (!uidActivity) {
            pw.print(prefix);
            pw.println("    (nothing executed)");
        }
    }
}
#end_block

#method_before
private final Map<String, KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer, int len, boolean wakeup_sources) {
    String name;
    int count;
    long totalTime;
    int startIndex;
    int endIndex;
    int numUpdatedWlNames = 0;
    // Advance past the first line.
    int i;
    for (i = 0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++) ;
    startIndex = endIndex = i + 1;
    synchronized (this) {
        Map<String, KernelWakelockStats> m = mProcWakelockFileStats;
        sKernelWakelockUpdateVersion++;
        while (endIndex < len) {
            for (endIndex = startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++) ;
            // endIndex is an exclusive upper bound.
            endIndex++;
            // write to wlBuffer[endIndex]
            if (endIndex >= (len - 1)) {
                return m;
            }
            String[] nameStringArray = mProcWakelocksName;
            long[] wlData = mProcWakelocksData;
            // This should prevent crashes and the line will probably fail to parse
            for (int j = startIndex; j < endIndex; j++) {
                if ((wlBuffer[j] & 0x80) != 0)
                    wlBuffer[j] = (byte) '?';
            }
            boolean parsed = Process.parseProcLine(wlBuffer, startIndex, endIndex, wakeup_sources ? WAKEUP_SOURCES_FORMAT : PROC_WAKELOCKS_FORMAT, nameStringArray, wlData, null);
            name = nameStringArray[0];
            count = (int) wlData[1];
            if (wakeup_sources) {
                // convert milliseconds to microseconds
                totalTime = wlData[2] * 1000;
            } else {
                // convert nanoseconds to microseconds with rounding.
                totalTime = (wlData[2] + 500) / 1000;
            }
            if (parsed && name.length() > 0) {
                if (!m.containsKey(name)) {
                    m.put(name, new KernelWakelockStats(count, totalTime, sKernelWakelockUpdateVersion));
                    numUpdatedWlNames++;
                } else {
                    KernelWakelockStats kwlStats = m.get(name);
                    if (kwlStats.mVersion == sKernelWakelockUpdateVersion) {
                        kwlStats.mCount += count;
                        kwlStats.mTotalTime += totalTime;
                    } else {
                        kwlStats.mCount = count;
                        kwlStats.mTotalTime = totalTime;
                        kwlStats.mVersion = sKernelWakelockUpdateVersion;
                        numUpdatedWlNames++;
                    }
                }
            }
            startIndex = endIndex;
        }
        if (m.size() != numUpdatedWlNames) {
            // Don't report old data.
            Iterator<KernelWakelockStats> itr = m.values().iterator();
            while (itr.hasNext()) {
                if (itr.next().mVersion != sKernelWakelockUpdateVersion) {
                    itr.remove();
                }
            }
        }
        return m;
    }
}
#method_after
private final Map<String, KernelWakelockStats> parseProcWakelocks(byte[] wlBuffer, int len, boolean wakeup_sources) {
    String name;
    int count;
    long totalTime;
    int startIndex;
    int endIndex;
    int numUpdatedWlNames = 0;
    // Advance past the first line.
    int i;
    for (i = 0; i < len && wlBuffer[i] != '\n' && wlBuffer[i] != '\0'; i++) ;
    startIndex = endIndex = i + 1;
    synchronized (this) {
        Map<String, KernelWakelockStats> m = mProcWakelockFileStats;
        setKernelWakelockUpdateVersion(getKernelWakelockUpdateVersion() + 1);
        while (endIndex < len) {
            for (endIndex = startIndex; endIndex < len && wlBuffer[endIndex] != '\n' && wlBuffer[endIndex] != '\0'; endIndex++) ;
            // endIndex is an exclusive upper bound.
            endIndex++;
            // write to wlBuffer[endIndex]
            if (endIndex >= (len - 1)) {
                return m;
            }
            String[] nameStringArray = mProcWakelocksName;
            long[] wlData = mProcWakelocksData;
            // This should prevent crashes and the line will probably fail to parse
            for (int j = startIndex; j < endIndex; j++) {
                if ((wlBuffer[j] & 0x80) != 0)
                    wlBuffer[j] = (byte) '?';
            }
            boolean parsed = Process.parseProcLine(wlBuffer, startIndex, endIndex, wakeup_sources ? WAKEUP_SOURCES_FORMAT : PROC_WAKELOCKS_FORMAT, nameStringArray, wlData, null);
            name = nameStringArray[0];
            count = (int) wlData[1];
            if (wakeup_sources) {
                // convert milliseconds to microseconds
                totalTime = wlData[2] * 1000;
            } else {
                // convert nanoseconds to microseconds with rounding.
                totalTime = (wlData[2] + 500) / 1000;
            }
            if (parsed && name.length() > 0) {
                if (!m.containsKey(name)) {
                    m.put(name, new KernelWakelockStats(count, totalTime, getKernelWakelockUpdateVersion()));
                    numUpdatedWlNames++;
                } else {
                    KernelWakelockStats kwlStats = m.get(name);
                    if (kwlStats.mVersion == getKernelWakelockUpdateVersion()) {
                        kwlStats.mCount += count;
                        kwlStats.mTotalTime += totalTime;
                    } else {
                        kwlStats.mCount = count;
                        kwlStats.mTotalTime = totalTime;
                        kwlStats.mVersion = getKernelWakelockUpdateVersion();
                        numUpdatedWlNames++;
                    }
                }
            }
            startIndex = endIndex;
        }
        if (m.size() != numUpdatedWlNames) {
            // Don't report old data.
            Iterator<KernelWakelockStats> itr = m.values().iterator();
            while (itr.hasNext()) {
                if (itr.next().mVersion != getKernelWakelockUpdateVersion()) {
                    itr.remove();
                }
            }
        }
        return m;
    }
}
#end_block

#method_before
boolean reset() {
    boolean active = false;
    if (mWifiRunningTimer != null) {
        active |= !mWifiRunningTimer.reset(BatteryStatsImpl.this, false);
        active |= mWifiRunning;
    }
    if (mFullWifiLockTimer != null) {
        active |= !mFullWifiLockTimer.reset(BatteryStatsImpl.this, false);
        active |= mFullWifiLockOut;
    }
    if (mWifiScanTimer != null) {
        active |= !mWifiScanTimer.reset(BatteryStatsImpl.this, false);
        active |= mWifiScanStarted;
    }
    if (mWifiMulticastTimer != null) {
        active |= !mWifiMulticastTimer.reset(BatteryStatsImpl.this, false);
        active |= mWifiMulticastEnabled;
    }
    if (mAudioTurnedOnTimer != null) {
        active |= !mAudioTurnedOnTimer.reset(BatteryStatsImpl.this, false);
        active |= mAudioTurnedOn;
    }
    if (mVideoTurnedOnTimer != null) {
        active |= !mVideoTurnedOnTimer.reset(BatteryStatsImpl.this, false);
        active |= mVideoTurnedOn;
    }
    if (mForegroundActivityTimer != null) {
        active |= !mForegroundActivityTimer.reset(BatteryStatsImpl.this, false);
    }
    if (mVibratorOnTimer != null) {
        if (mVibratorOnTimer.reset(BatteryStatsImpl.this, false)) {
            mVibratorOnTimer.detach();
            mVibratorOnTimer = null;
        } else {
            active = true;
        }
    }
    if (mUserActivityCounters != null) {
        for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
            mUserActivityCounters[i].reset(false);
        }
    }
    if (mNetworkActivityCounters != null) {
        for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
            mNetworkActivityCounters[i].reset(false);
        }
    }
    if (mWakelockStats.size() > 0) {
        Iterator<Map.Entry<String, Wakelock>> it = mWakelockStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Wakelock> wakelockEntry = it.next();
            Wakelock wl = wakelockEntry.getValue();
            if (wl.reset()) {
                it.remove();
            } else {
                active = true;
            }
        }
    }
    if (mSensorStats.size() > 0) {
        Iterator<Map.Entry<Integer, Sensor>> it = mSensorStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, Sensor> sensorEntry = it.next();
            Sensor s = sensorEntry.getValue();
            if (s.reset()) {
                it.remove();
            } else {
                active = true;
            }
        }
    }
    if (mProcessStats.size() > 0) {
        Iterator<Map.Entry<String, Proc>> it = mProcessStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Proc> procEntry = it.next();
            procEntry.getValue().detach();
        }
        mProcessStats.clear();
    }
    if (mPids.size() > 0) {
        for (int i = 0; !active && i < mPids.size(); i++) {
            Pid pid = mPids.valueAt(i);
            if (pid.mWakeStart != 0) {
                active = true;
            }
        }
    }
    if (mPackageStats.size() > 0) {
        Iterator<Map.Entry<String, Pkg>> it = mPackageStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Pkg> pkgEntry = it.next();
            Pkg p = pkgEntry.getValue();
            p.detach();
            if (p.mServiceStats.size() > 0) {
                Iterator<Map.Entry<String, Pkg.Serv>> it2 = p.mServiceStats.entrySet().iterator();
                while (it2.hasNext()) {
                    Map.Entry<String, Pkg.Serv> servEntry = it2.next();
                    servEntry.getValue().detach();
                }
            }
        }
        mPackageStats.clear();
    }
    mPids.clear();
    if (!active) {
        if (mWifiRunningTimer != null) {
            mWifiRunningTimer.detach();
        }
        if (mFullWifiLockTimer != null) {
            mFullWifiLockTimer.detach();
        }
        if (mWifiScanTimer != null) {
            mWifiScanTimer.detach();
        }
        if (mWifiMulticastTimer != null) {
            mWifiMulticastTimer.detach();
        }
        if (mAudioTurnedOnTimer != null) {
            mAudioTurnedOnTimer.detach();
            mAudioTurnedOnTimer = null;
        }
        if (mVideoTurnedOnTimer != null) {
            mVideoTurnedOnTimer.detach();
            mVideoTurnedOnTimer = null;
        }
        if (mForegroundActivityTimer != null) {
            mForegroundActivityTimer.detach();
            mForegroundActivityTimer = null;
        }
        if (mUserActivityCounters != null) {
            for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
                mUserActivityCounters[i].detach();
            }
        }
        if (mNetworkActivityCounters != null) {
            for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
                mNetworkActivityCounters[i].detach();
            }
        }
    }
    return !active;
}
#method_after
boolean reset() {
    boolean active = false;
    if (mWifiRunningTimer != null) {
        active |= !mWifiRunningTimer.reset(BatteryStatsImpl.this, false);
        active |= mWifiRunning;
    }
    if (mFullWifiLockTimer != null) {
        active |= !mFullWifiLockTimer.reset(BatteryStatsImpl.this, false);
        active |= mFullWifiLockOut;
    }
    if (mWifiScanTimer != null) {
        active |= !mWifiScanTimer.reset(BatteryStatsImpl.this, false);
        active |= mWifiScanStarted;
    }
    if (mWifiBatchedScanTimer != null) {
        for (int i = 0; i < NUM_WIFI_BATCHED_SCAN_BINS; i++) {
            if (mWifiBatchedScanTimer[i] != null) {
                active |= !mWifiBatchedScanTimer[i].reset(BatteryStatsImpl.this, false);
            }
        }
        active |= (mWifiBatchedScanBinStarted != NO_BATCHED_SCAN_STARTED);
    }
    if (mWifiMulticastTimer != null) {
        active |= !mWifiMulticastTimer.reset(BatteryStatsImpl.this, false);
        active |= mWifiMulticastEnabled;
    }
    if (mAudioTurnedOnTimer != null) {
        active |= !mAudioTurnedOnTimer.reset(BatteryStatsImpl.this, false);
        active |= mAudioTurnedOn;
    }
    if (mVideoTurnedOnTimer != null) {
        active |= !mVideoTurnedOnTimer.reset(BatteryStatsImpl.this, false);
        active |= mVideoTurnedOn;
    }
    if (mForegroundActivityTimer != null) {
        active |= !mForegroundActivityTimer.reset(BatteryStatsImpl.this, false);
    }
    if (mVibratorOnTimer != null) {
        if (mVibratorOnTimer.reset(BatteryStatsImpl.this, false)) {
            mVibratorOnTimer.detach();
            mVibratorOnTimer = null;
        } else {
            active = true;
        }
    }
    if (mUserActivityCounters != null) {
        for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
            mUserActivityCounters[i].reset(false);
        }
    }
    if (mNetworkActivityCounters != null) {
        for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
            mNetworkActivityCounters[i].reset(false);
        }
    }
    if (mWakelockStats.size() > 0) {
        Iterator<Map.Entry<String, Wakelock>> it = mWakelockStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Wakelock> wakelockEntry = it.next();
            Wakelock wl = wakelockEntry.getValue();
            if (wl.reset()) {
                it.remove();
            } else {
                active = true;
            }
        }
    }
    if (mSensorStats.size() > 0) {
        Iterator<Map.Entry<Integer, Sensor>> it = mSensorStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, Sensor> sensorEntry = it.next();
            Sensor s = sensorEntry.getValue();
            if (s.reset()) {
                it.remove();
            } else {
                active = true;
            }
        }
    }
    if (mProcessStats.size() > 0) {
        Iterator<Map.Entry<String, Proc>> it = mProcessStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Proc> procEntry = it.next();
            procEntry.getValue().detach();
        }
        mProcessStats.clear();
    }
    if (mPids.size() > 0) {
        for (int i = 0; !active && i < mPids.size(); i++) {
            Pid pid = mPids.valueAt(i);
            if (pid.mWakeStart != 0) {
                active = true;
            }
        }
    }
    if (mPackageStats.size() > 0) {
        Iterator<Map.Entry<String, Pkg>> it = mPackageStats.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Pkg> pkgEntry = it.next();
            Pkg p = pkgEntry.getValue();
            p.detach();
            if (p.mServiceStats.size() > 0) {
                Iterator<Map.Entry<String, Pkg.Serv>> it2 = p.mServiceStats.entrySet().iterator();
                while (it2.hasNext()) {
                    Map.Entry<String, Pkg.Serv> servEntry = it2.next();
                    servEntry.getValue().detach();
                }
            }
        }
        mPackageStats.clear();
    }
    mPids.clear();
    if (!active) {
        if (mWifiRunningTimer != null) {
            mWifiRunningTimer.detach();
        }
        if (mFullWifiLockTimer != null) {
            mFullWifiLockTimer.detach();
        }
        if (mWifiScanTimer != null) {
            mWifiScanTimer.detach();
        }
        for (int i = 0; i < NUM_WIFI_BATCHED_SCAN_BINS; i++) {
            if (mWifiBatchedScanTimer[i] != null) {
                mWifiBatchedScanTimer[i].detach();
            }
        }
        if (mWifiMulticastTimer != null) {
            mWifiMulticastTimer.detach();
        }
        if (mAudioTurnedOnTimer != null) {
            mAudioTurnedOnTimer.detach();
            mAudioTurnedOnTimer = null;
        }
        if (mVideoTurnedOnTimer != null) {
            mVideoTurnedOnTimer.detach();
            mVideoTurnedOnTimer = null;
        }
        if (mForegroundActivityTimer != null) {
            mForegroundActivityTimer.detach();
            mForegroundActivityTimer = null;
        }
        if (mUserActivityCounters != null) {
            for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
                mUserActivityCounters[i].detach();
            }
        }
        if (mNetworkActivityCounters != null) {
            for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
                mNetworkActivityCounters[i].detach();
            }
        }
    }
    return !active;
}
#end_block

#method_before
void writeToParcelLocked(Parcel out, long batteryRealtime) {
    out.writeInt(mWakelockStats.size());
    for (Map.Entry<String, Uid.Wakelock> wakelockEntry : mWakelockStats.entrySet()) {
        out.writeString(wakelockEntry.getKey());
        Uid.Wakelock wakelock = wakelockEntry.getValue();
        wakelock.writeToParcelLocked(out, batteryRealtime);
    }
    out.writeInt(mSensorStats.size());
    for (Map.Entry<Integer, Uid.Sensor> sensorEntry : mSensorStats.entrySet()) {
        out.writeInt(sensorEntry.getKey());
        Uid.Sensor sensor = sensorEntry.getValue();
        sensor.writeToParcelLocked(out, batteryRealtime);
    }
    out.writeInt(mProcessStats.size());
    for (Map.Entry<String, Uid.Proc> procEntry : mProcessStats.entrySet()) {
        out.writeString(procEntry.getKey());
        Uid.Proc proc = procEntry.getValue();
        proc.writeToParcelLocked(out);
    }
    out.writeInt(mPackageStats.size());
    for (Map.Entry<String, Uid.Pkg> pkgEntry : mPackageStats.entrySet()) {
        out.writeString(pkgEntry.getKey());
        Uid.Pkg pkg = pkgEntry.getValue();
        pkg.writeToParcelLocked(out);
    }
    if (mWifiRunningTimer != null) {
        out.writeInt(1);
        mWifiRunningTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mFullWifiLockTimer != null) {
        out.writeInt(1);
        mFullWifiLockTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mWifiScanTimer != null) {
        out.writeInt(1);
        mWifiScanTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mWifiMulticastTimer != null) {
        out.writeInt(1);
        mWifiMulticastTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mAudioTurnedOnTimer != null) {
        out.writeInt(1);
        mAudioTurnedOnTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mVideoTurnedOnTimer != null) {
        out.writeInt(1);
        mVideoTurnedOnTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mForegroundActivityTimer != null) {
        out.writeInt(1);
        mForegroundActivityTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mVibratorOnTimer != null) {
        out.writeInt(1);
        mVibratorOnTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mUserActivityCounters != null) {
        out.writeInt(1);
        for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
            mUserActivityCounters[i].writeToParcel(out);
        }
    } else {
        out.writeInt(0);
    }
    if (mNetworkActivityCounters != null) {
        out.writeInt(1);
        for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
            mNetworkActivityCounters[i].writeToParcel(out);
        }
    } else {
        out.writeInt(0);
    }
}
#method_after
void writeToParcelLocked(Parcel out, long batteryRealtime) {
    out.writeInt(mWakelockStats.size());
    for (Map.Entry<String, Uid.Wakelock> wakelockEntry : mWakelockStats.entrySet()) {
        out.writeString(wakelockEntry.getKey());
        Uid.Wakelock wakelock = wakelockEntry.getValue();
        wakelock.writeToParcelLocked(out, batteryRealtime);
    }
    out.writeInt(mSensorStats.size());
    for (Map.Entry<Integer, Uid.Sensor> sensorEntry : mSensorStats.entrySet()) {
        out.writeInt(sensorEntry.getKey());
        Uid.Sensor sensor = sensorEntry.getValue();
        sensor.writeToParcelLocked(out, batteryRealtime);
    }
    out.writeInt(mProcessStats.size());
    for (Map.Entry<String, Uid.Proc> procEntry : mProcessStats.entrySet()) {
        out.writeString(procEntry.getKey());
        Uid.Proc proc = procEntry.getValue();
        proc.writeToParcelLocked(out);
    }
    out.writeInt(mPackageStats.size());
    for (Map.Entry<String, Uid.Pkg> pkgEntry : mPackageStats.entrySet()) {
        out.writeString(pkgEntry.getKey());
        Uid.Pkg pkg = pkgEntry.getValue();
        pkg.writeToParcelLocked(out);
    }
    if (mWifiRunningTimer != null) {
        out.writeInt(1);
        mWifiRunningTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mFullWifiLockTimer != null) {
        out.writeInt(1);
        mFullWifiLockTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mWifiScanTimer != null) {
        out.writeInt(1);
        mWifiScanTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    for (int i = 0; i < NUM_WIFI_BATCHED_SCAN_BINS; i++) {
        if (mWifiBatchedScanTimer[i] != null) {
            out.writeInt(1);
            mWifiBatchedScanTimer[i].writeToParcel(out, batteryRealtime);
        } else {
            out.writeInt(0);
        }
    }
    if (mWifiMulticastTimer != null) {
        out.writeInt(1);
        mWifiMulticastTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mAudioTurnedOnTimer != null) {
        out.writeInt(1);
        mAudioTurnedOnTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mVideoTurnedOnTimer != null) {
        out.writeInt(1);
        mVideoTurnedOnTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mForegroundActivityTimer != null) {
        out.writeInt(1);
        mForegroundActivityTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mVibratorOnTimer != null) {
        out.writeInt(1);
        mVibratorOnTimer.writeToParcel(out, batteryRealtime);
    } else {
        out.writeInt(0);
    }
    if (mUserActivityCounters != null) {
        out.writeInt(1);
        for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
            mUserActivityCounters[i].writeToParcel(out);
        }
    } else {
        out.writeInt(0);
    }
    if (mNetworkActivityCounters != null) {
        out.writeInt(1);
        for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
            mNetworkActivityCounters[i].writeToParcel(out);
        }
    } else {
        out.writeInt(0);
    }
}
#end_block

#method_before
void readFromParcelLocked(ArrayList<Unpluggable> unpluggables, Parcel in) {
    int numWakelocks = in.readInt();
    mWakelockStats.clear();
    for (int j = 0; j < numWakelocks; j++) {
        String wakelockName = in.readString();
        Uid.Wakelock wakelock = new Wakelock();
        wakelock.readFromParcelLocked(unpluggables, in);
        // We will just drop some random set of wakelocks if
        // the previous run of the system was an older version
        // that didn't impose a limit.
        mWakelockStats.put(wakelockName, wakelock);
    }
    int numSensors = in.readInt();
    mSensorStats.clear();
    for (int k = 0; k < numSensors; k++) {
        int sensorNumber = in.readInt();
        Uid.Sensor sensor = new Sensor(sensorNumber);
        sensor.readFromParcelLocked(mUnpluggables, in);
        mSensorStats.put(sensorNumber, sensor);
    }
    int numProcs = in.readInt();
    mProcessStats.clear();
    for (int k = 0; k < numProcs; k++) {
        String processName = in.readString();
        Uid.Proc proc = new Proc();
        proc.readFromParcelLocked(in);
        mProcessStats.put(processName, proc);
    }
    int numPkgs = in.readInt();
    mPackageStats.clear();
    for (int l = 0; l < numPkgs; l++) {
        String packageName = in.readString();
        Uid.Pkg pkg = new Pkg();
        pkg.readFromParcelLocked(in);
        mPackageStats.put(packageName, pkg);
    }
    mWifiRunning = false;
    if (in.readInt() != 0) {
        mWifiRunningTimer = new StopwatchTimer(Uid.this, WIFI_RUNNING, mWifiRunningTimers, mUnpluggables, in);
    } else {
        mWifiRunningTimer = null;
    }
    mFullWifiLockOut = false;
    if (in.readInt() != 0) {
        mFullWifiLockTimer = new StopwatchTimer(Uid.this, FULL_WIFI_LOCK, mFullWifiLockTimers, mUnpluggables, in);
    } else {
        mFullWifiLockTimer = null;
    }
    mWifiScanStarted = false;
    if (in.readInt() != 0) {
        mWifiScanTimer = new StopwatchTimer(Uid.this, WIFI_SCAN, mWifiScanTimers, mUnpluggables, in);
    } else {
        mWifiScanTimer = null;
    }
    mWifiMulticastEnabled = false;
    if (in.readInt() != 0) {
        mWifiMulticastTimer = new StopwatchTimer(Uid.this, WIFI_MULTICAST_ENABLED, mWifiMulticastTimers, mUnpluggables, in);
    } else {
        mWifiMulticastTimer = null;
    }
    mAudioTurnedOn = false;
    if (in.readInt() != 0) {
        mAudioTurnedOnTimer = new StopwatchTimer(Uid.this, AUDIO_TURNED_ON, null, mUnpluggables, in);
    } else {
        mAudioTurnedOnTimer = null;
    }
    mVideoTurnedOn = false;
    if (in.readInt() != 0) {
        mVideoTurnedOnTimer = new StopwatchTimer(Uid.this, VIDEO_TURNED_ON, null, mUnpluggables, in);
    } else {
        mVideoTurnedOnTimer = null;
    }
    if (in.readInt() != 0) {
        mForegroundActivityTimer = new StopwatchTimer(Uid.this, FOREGROUND_ACTIVITY, null, mUnpluggables, in);
    } else {
        mForegroundActivityTimer = null;
    }
    if (in.readInt() != 0) {
        mVibratorOnTimer = new BatchTimer(Uid.this, VIBRATOR_ON, mUnpluggables, BatteryStatsImpl.this.mOnBatteryInternal, in);
    } else {
        mVibratorOnTimer = null;
    }
    if (in.readInt() != 0) {
        mUserActivityCounters = new Counter[NUM_USER_ACTIVITY_TYPES];
        for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
            mUserActivityCounters[i] = new Counter(mUnpluggables, in);
        }
    } else {
        mUserActivityCounters = null;
    }
    if (in.readInt() != 0) {
        mNetworkActivityCounters = new LongSamplingCounter[NUM_NETWORK_ACTIVITY_TYPES];
        for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
            mNetworkActivityCounters[i] = new LongSamplingCounter(mUnpluggables, in);
        }
    } else {
        mNetworkActivityCounters = null;
    }
}
#method_after
void readFromParcelLocked(ArrayList<Unpluggable> unpluggables, Parcel in) {
    int numWakelocks = in.readInt();
    mWakelockStats.clear();
    for (int j = 0; j < numWakelocks; j++) {
        String wakelockName = in.readString();
        Uid.Wakelock wakelock = new Wakelock();
        wakelock.readFromParcelLocked(unpluggables, in);
        // We will just drop some random set of wakelocks if
        // the previous run of the system was an older version
        // that didn't impose a limit.
        mWakelockStats.put(wakelockName, wakelock);
    }
    int numSensors = in.readInt();
    mSensorStats.clear();
    for (int k = 0; k < numSensors; k++) {
        int sensorNumber = in.readInt();
        Uid.Sensor sensor = new Sensor(sensorNumber);
        sensor.readFromParcelLocked(mUnpluggables, in);
        mSensorStats.put(sensorNumber, sensor);
    }
    int numProcs = in.readInt();
    mProcessStats.clear();
    for (int k = 0; k < numProcs; k++) {
        String processName = in.readString();
        Uid.Proc proc = new Proc();
        proc.readFromParcelLocked(in);
        mProcessStats.put(processName, proc);
    }
    int numPkgs = in.readInt();
    mPackageStats.clear();
    for (int l = 0; l < numPkgs; l++) {
        String packageName = in.readString();
        Uid.Pkg pkg = new Pkg();
        pkg.readFromParcelLocked(in);
        mPackageStats.put(packageName, pkg);
    }
    mWifiRunning = false;
    if (in.readInt() != 0) {
        mWifiRunningTimer = new StopwatchTimer(Uid.this, WIFI_RUNNING, mWifiRunningTimers, mUnpluggables, in);
    } else {
        mWifiRunningTimer = null;
    }
    mFullWifiLockOut = false;
    if (in.readInt() != 0) {
        mFullWifiLockTimer = new StopwatchTimer(Uid.this, FULL_WIFI_LOCK, mFullWifiLockTimers, mUnpluggables, in);
    } else {
        mFullWifiLockTimer = null;
    }
    mWifiScanStarted = false;
    if (in.readInt() != 0) {
        mWifiScanTimer = new StopwatchTimer(Uid.this, WIFI_SCAN, mWifiScanTimers, mUnpluggables, in);
    } else {
        mWifiScanTimer = null;
    }
    mWifiBatchedScanBinStarted = NO_BATCHED_SCAN_STARTED;
    for (int i = 0; i < NUM_WIFI_BATCHED_SCAN_BINS; i++) {
        if (in.readInt() != 0) {
            makeWifiBatchedScanBin(i, in);
        } else {
            mWifiBatchedScanTimer[i] = null;
        }
    }
    mWifiMulticastEnabled = false;
    if (in.readInt() != 0) {
        mWifiMulticastTimer = new StopwatchTimer(Uid.this, WIFI_MULTICAST_ENABLED, mWifiMulticastTimers, mUnpluggables, in);
    } else {
        mWifiMulticastTimer = null;
    }
    mAudioTurnedOn = false;
    if (in.readInt() != 0) {
        mAudioTurnedOnTimer = new StopwatchTimer(Uid.this, AUDIO_TURNED_ON, null, mUnpluggables, in);
    } else {
        mAudioTurnedOnTimer = null;
    }
    mVideoTurnedOn = false;
    if (in.readInt() != 0) {
        mVideoTurnedOnTimer = new StopwatchTimer(Uid.this, VIDEO_TURNED_ON, null, mUnpluggables, in);
    } else {
        mVideoTurnedOnTimer = null;
    }
    if (in.readInt() != 0) {
        mForegroundActivityTimer = new StopwatchTimer(Uid.this, FOREGROUND_ACTIVITY, null, mUnpluggables, in);
    } else {
        mForegroundActivityTimer = null;
    }
    if (in.readInt() != 0) {
        mVibratorOnTimer = new BatchTimer(Uid.this, VIBRATOR_ON, mUnpluggables, BatteryStatsImpl.this.mOnBatteryInternal, in);
    } else {
        mVibratorOnTimer = null;
    }
    if (in.readInt() != 0) {
        mUserActivityCounters = new Counter[NUM_USER_ACTIVITY_TYPES];
        for (int i = 0; i < NUM_USER_ACTIVITY_TYPES; i++) {
            mUserActivityCounters[i] = new Counter(mUnpluggables, in);
        }
    } else {
        mUserActivityCounters = null;
    }
    if (in.readInt() != 0) {
        mNetworkActivityCounters = new LongSamplingCounter[NUM_NETWORK_ACTIVITY_TYPES];
        for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
            mNetworkActivityCounters[i] = new LongSamplingCounter(mUnpluggables, in);
        }
    } else {
        mNetworkActivityCounters = null;
    }
}
#end_block

#method_before
public void setNumSpeedSteps(int steps) {
    if (sNumSpeedSteps == 0)
        sNumSpeedSteps = steps;
}
#method_after
public void setNumSpeedSteps(int steps) {
    if (getCpuSpeedSteps() == 0)
        setCpuSpeedSteps(steps);
}
#end_block

#method_before
public void setBatteryState(int status, int health, int plugType, int level, int temp, int volt) {
    synchronized (this) {
        boolean onBattery = plugType == BATTERY_PLUGGED_NONE;
        int oldStatus = mHistoryCur.batteryStatus;
        if (!mHaveBatteryLevel) {
            mHaveBatteryLevel = true;
            // since we won't be going through the full setOnBattery().
            if (onBattery == mOnBattery) {
                if (onBattery) {
                    mHistoryCur.states &= ~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
                } else {
                    mHistoryCur.states |= HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
                }
            }
            oldStatus = status;
        }
        if (onBattery) {
            mDischargeCurrentLevel = level;
            mRecordingHistory = true;
        }
        if (onBattery != mOnBattery) {
            mHistoryCur.batteryLevel = (byte) level;
            mHistoryCur.batteryStatus = (byte) status;
            mHistoryCur.batteryHealth = (byte) health;
            mHistoryCur.batteryPlugType = (byte) plugType;
            mHistoryCur.batteryTemperature = (char) temp;
            mHistoryCur.batteryVoltage = (char) volt;
            setOnBatteryLocked(onBattery, oldStatus, level);
        } else {
            boolean changed = false;
            if (mHistoryCur.batteryLevel != level) {
                mHistoryCur.batteryLevel = (byte) level;
                changed = true;
            }
            if (mHistoryCur.batteryStatus != status) {
                mHistoryCur.batteryStatus = (byte) status;
                changed = true;
            }
            if (mHistoryCur.batteryHealth != health) {
                mHistoryCur.batteryHealth = (byte) health;
                changed = true;
            }
            if (mHistoryCur.batteryPlugType != plugType) {
                mHistoryCur.batteryPlugType = (byte) plugType;
                changed = true;
            }
            if (temp >= (mHistoryCur.batteryTemperature + 10) || temp <= (mHistoryCur.batteryTemperature - 10)) {
                mHistoryCur.batteryTemperature = (char) temp;
                changed = true;
            }
            if (volt > (mHistoryCur.batteryVoltage + 20) || volt < (mHistoryCur.batteryVoltage - 20)) {
                mHistoryCur.batteryVoltage = (char) volt;
                changed = true;
            }
            if (changed) {
                addHistoryRecordLocked(SystemClock.elapsedRealtime());
            }
        }
        if (!onBattery && status == BatteryManager.BATTERY_STATUS_FULL) {
            // We don't record history while we are plugged in and fully charged.
            // The next time we are unplugged, history will be cleared.
            mRecordingHistory = false;
        }
    }
}
#method_after
public void setBatteryState(int status, int health, int plugType, int level, int temp, int volt) {
    synchronized (this) {
        // We need to add a extra check over the status because of dock batteries
        // PlugType doesn't means that the dock battery is charging (some devices
        // doesn't charge under dock usb)
        boolean onBattery = plugType == BATTERY_PLUGGED_NONE && (status != BatteryManager.BATTERY_STATUS_CHARGING || status != BatteryManager.BATTERY_STATUS_FULL);
        int oldStatus = mHistoryCur.batteryStatus;
        if (!mHaveBatteryLevel) {
            mHaveBatteryLevel = true;
            // since we won't be going through the full setOnBattery().
            if (onBattery == mOnBattery) {
                if (onBattery) {
                    mHistoryCur.states &= ~HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
                } else {
                    mHistoryCur.states |= HistoryItem.STATE_BATTERY_PLUGGED_FLAG;
                }
            }
            oldStatus = status;
        }
        if (onBattery) {
            mDischargeCurrentLevel = level;
            mRecordingHistory = true;
        }
        if (onBattery != mOnBattery) {
            mHistoryCur.batteryLevel = (byte) level;
            mHistoryCur.batteryStatus = (byte) status;
            mHistoryCur.batteryHealth = (byte) health;
            mHistoryCur.batteryPlugType = (byte) plugType;
            mHistoryCur.batteryTemperature = (char) temp;
            mHistoryCur.batteryVoltage = (char) volt;
            setOnBatteryLocked(onBattery, oldStatus, level);
        } else {
            boolean changed = false;
            if (mHistoryCur.batteryLevel != level) {
                mHistoryCur.batteryLevel = (byte) level;
                changed = true;
            }
            if (mHistoryCur.batteryStatus != status) {
                mHistoryCur.batteryStatus = (byte) status;
                changed = true;
            }
            if (mHistoryCur.batteryHealth != health) {
                mHistoryCur.batteryHealth = (byte) health;
                changed = true;
            }
            if (mHistoryCur.batteryPlugType != plugType) {
                mHistoryCur.batteryPlugType = (byte) plugType;
                changed = true;
            }
            if (temp >= (mHistoryCur.batteryTemperature + 10) || temp <= (mHistoryCur.batteryTemperature - 10)) {
                mHistoryCur.batteryTemperature = (char) temp;
                changed = true;
            }
            if (volt > (mHistoryCur.batteryVoltage + 20) || volt < (mHistoryCur.batteryVoltage - 20)) {
                mHistoryCur.batteryVoltage = (char) volt;
                changed = true;
            }
            if (changed) {
                addHistoryRecordLocked(SystemClock.elapsedRealtime());
            }
        }
        if (!onBattery && status == BatteryManager.BATTERY_STATUS_FULL) {
            // We don't record history while we are plugged in and fully charged.
            // The next time we are unplugged, history will be cleared.
            mRecordingHistory = false;
        }
    }
}
#end_block

#method_before
public void updateKernelWakelocksLocked() {
    Map<String, KernelWakelockStats> m = readKernelWakelockStats();
    if (m == null) {
        // Not crashing might make board bringup easier.
        Slog.w(TAG, "Couldn't get kernel wake lock stats");
        return;
    }
    for (Map.Entry<String, KernelWakelockStats> ent : m.entrySet()) {
        String name = ent.getKey();
        KernelWakelockStats kws = ent.getValue();
        SamplingTimer kwlt = mKernelWakelockStats.get(name);
        if (kwlt == null) {
            kwlt = new SamplingTimer(mUnpluggables, mOnBatteryInternal, true);
            mKernelWakelockStats.put(name, kwlt);
        }
        kwlt.updateCurrentReportedCount(kws.mCount);
        kwlt.updateCurrentReportedTotalTime(kws.mTotalTime);
        kwlt.setUpdateVersion(sKernelWakelockUpdateVersion);
    }
    if (m.size() != mKernelWakelockStats.size()) {
        // Set timers to stale if they didn't appear in /proc/wakelocks this time.
        for (Map.Entry<String, SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
            SamplingTimer st = ent.getValue();
            if (st.getUpdateVersion() != sKernelWakelockUpdateVersion) {
                st.setStale();
            }
        }
    }
}
#method_after
public void updateKernelWakelocksLocked() {
    Map<String, KernelWakelockStats> m = readKernelWakelockStats();
    if (m == null) {
        // Not crashing might make board bringup easier.
        Slog.w(TAG, "Couldn't get kernel wake lock stats");
        return;
    }
    for (Map.Entry<String, KernelWakelockStats> ent : m.entrySet()) {
        String name = ent.getKey();
        KernelWakelockStats kws = ent.getValue();
        SamplingTimer kwlt = mKernelWakelockStats.get(name);
        if (kwlt == null) {
            kwlt = new SamplingTimer(mUnpluggables, mOnBatteryInternal, true);
            mKernelWakelockStats.put(name, kwlt);
        }
        kwlt.updateCurrentReportedCount(kws.mCount);
        kwlt.updateCurrentReportedTotalTime(kws.mTotalTime);
        kwlt.setUpdateVersion(getKernelWakelockUpdateVersion());
    }
    if (m.size() != mKernelWakelockStats.size()) {
        // Set timers to stale if they didn't appear in /proc/wakelocks this time.
        for (Map.Entry<String, SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
            SamplingTimer st = ent.getValue();
            if (st.getUpdateVersion() != getKernelWakelockUpdateVersion()) {
                st.setStale();
            }
        }
    }
}
#end_block

#method_before
private void readSummaryFromParcel(Parcel in) {
    final int version = in.readInt();
    if (version != VERSION) {
        Slog.w("BatteryStats", "readFromParcel: version got " + version + ", expected " + VERSION + "; erasing old stats");
        return;
    }
    readHistory(in, true);
    mStartCount = in.readInt();
    mBatteryUptime = in.readLong();
    mBatteryRealtime = in.readLong();
    mUptime = in.readLong();
    mRealtime = in.readLong();
    mDischargeUnplugLevel = in.readInt();
    mDischargeCurrentLevel = in.readInt();
    mLowDischargeAmountSinceCharge = in.readInt();
    mHighDischargeAmountSinceCharge = in.readInt();
    mDischargeAmountScreenOnSinceCharge = in.readInt();
    mDischargeAmountScreenOffSinceCharge = in.readInt();
    mStartCount++;
    mScreenOn = false;
    mScreenOnTimer.readSummaryFromParcelLocked(in);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
    }
    mInputEventCounter.readSummaryFromParcelLocked(in);
    mPhoneOn = false;
    mPhoneOnTimer.readSummaryFromParcelLocked(in);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
    }
    mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i].readSummaryFromParcelLocked(in);
    }
    mWifiOn = false;
    mWifiOnTimer.readSummaryFromParcelLocked(in);
    mGlobalWifiRunning = false;
    mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
    mBluetoothOn = false;
    mBluetoothOnTimer.readSummaryFromParcelLocked(in);
    int NKW = in.readInt();
    if (NKW > 10000) {
        Slog.w(TAG, "File corrupt: too many kernel wake locks " + NKW);
        return;
    }
    for (int ikw = 0; ikw < NKW; ikw++) {
        if (in.readInt() != 0) {
            String kwltName = in.readString();
            getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
        }
    }
    sNumSpeedSteps = in.readInt();
    final int NU = in.readInt();
    if (NU > 10000) {
        Slog.w(TAG, "File corrupt: too many uids " + NU);
        return;
    }
    for (int iu = 0; iu < NU; iu++) {
        int uid = in.readInt();
        Uid u = new Uid(uid);
        mUidStats.put(uid, u);
        u.mWifiRunning = false;
        if (in.readInt() != 0) {
            u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
        }
        u.mFullWifiLockOut = false;
        if (in.readInt() != 0) {
            u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
        }
        u.mWifiScanStarted = false;
        if (in.readInt() != 0) {
            u.mWifiScanTimer.readSummaryFromParcelLocked(in);
        }
        u.mWifiMulticastEnabled = false;
        if (in.readInt() != 0) {
            u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
        }
        u.mAudioTurnedOn = false;
        if (in.readInt() != 0) {
            u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
        }
        u.mVideoTurnedOn = false;
        if (in.readInt() != 0) {
            u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
        }
        if (in.readInt() != 0) {
            u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
        }
        if (in.readInt() != 0) {
            u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
        }
        if (in.readInt() != 0) {
            if (u.mUserActivityCounters == null) {
                u.initUserActivityLocked();
            }
            for (int i = 0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
                u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
            }
        }
        if (in.readInt() != 0) {
            if (u.mNetworkActivityCounters == null) {
                u.initNetworkActivityLocked();
            }
            for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
                u.mNetworkActivityCounters[i].readSummaryFromParcelLocked(in);
            }
        }
        int NW = in.readInt();
        if (NW > 100) {
            Slog.w(TAG, "File corrupt: too many wake locks " + NW);
            return;
        }
        for (int iw = 0; iw < NW; iw++) {
            String wlName = in.readString();
            if (in.readInt() != 0) {
                u.getWakeTimerLocked(wlName, WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
            }
            if (in.readInt() != 0) {
                u.getWakeTimerLocked(wlName, WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
            }
            if (in.readInt() != 0) {
                u.getWakeTimerLocked(wlName, WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
            }
        }
        int NP = in.readInt();
        if (NP > 1000) {
            Slog.w(TAG, "File corrupt: too many sensors " + NP);
            return;
        }
        for (int is = 0; is < NP; is++) {
            int seNumber = in.readInt();
            if (in.readInt() != 0) {
                u.getSensorTimerLocked(seNumber, true).readSummaryFromParcelLocked(in);
            }
        }
        NP = in.readInt();
        if (NP > 1000) {
            Slog.w(TAG, "File corrupt: too many processes " + NP);
            return;
        }
        for (int ip = 0; ip < NP; ip++) {
            String procName = in.readString();
            Uid.Proc p = u.getProcessStatsLocked(procName);
            p.mUserTime = p.mLoadedUserTime = in.readLong();
            p.mSystemTime = p.mLoadedSystemTime = in.readLong();
            p.mForegroundTime = p.mLoadedForegroundTime = in.readLong();
            p.mStarts = p.mLoadedStarts = in.readInt();
            int NSB = in.readInt();
            if (NSB > 100) {
                Slog.w(TAG, "File corrupt: too many speed bins " + NSB);
                return;
            }
            p.mSpeedBins = new SamplingCounter[NSB];
            for (int i = 0; i < NSB; i++) {
                if (in.readInt() != 0) {
                    p.mSpeedBins[i] = new SamplingCounter(mUnpluggables);
                    p.mSpeedBins[i].readSummaryFromParcelLocked(in);
                }
            }
            if (!p.readExcessivePowerFromParcelLocked(in)) {
                return;
            }
        }
        NP = in.readInt();
        if (NP > 10000) {
            Slog.w(TAG, "File corrupt: too many packages " + NP);
            return;
        }
        for (int ip = 0; ip < NP; ip++) {
            String pkgName = in.readString();
            Uid.Pkg p = u.getPackageStatsLocked(pkgName);
            p.mWakeups = p.mLoadedWakeups = in.readInt();
            final int NS = in.readInt();
            if (NS > 1000) {
                Slog.w(TAG, "File corrupt: too many services " + NS);
                return;
            }
            for (int is = 0; is < NS; is++) {
                String servName = in.readString();
                Uid.Pkg.Serv s = u.getServiceStatsLocked(pkgName, servName);
                s.mStartTime = s.mLoadedStartTime = in.readLong();
                s.mStarts = s.mLoadedStarts = in.readInt();
                s.mLaunches = s.mLoadedLaunches = in.readInt();
            }
        }
    }
}
#method_after
private void readSummaryFromParcel(Parcel in) {
    final int version = in.readInt();
    if (version != VERSION) {
        Slog.w("BatteryStats", "readFromParcel: version got " + version + ", expected " + VERSION + "; erasing old stats");
        return;
    }
    readHistory(in, true);
    mStartCount = in.readInt();
    mBatteryUptime = in.readLong();
    mBatteryRealtime = in.readLong();
    mUptime = in.readLong();
    mRealtime = in.readLong();
    mDischargeUnplugLevel = in.readInt();
    mDischargeCurrentLevel = in.readInt();
    mLowDischargeAmountSinceCharge = in.readInt();
    mHighDischargeAmountSinceCharge = in.readInt();
    mDischargeAmountScreenOnSinceCharge = in.readInt();
    mDischargeAmountScreenOffSinceCharge = in.readInt();
    mStartCount++;
    mScreenOn = false;
    mScreenOnTimer.readSummaryFromParcelLocked(in);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i].readSummaryFromParcelLocked(in);
    }
    mInputEventCounter.readSummaryFromParcelLocked(in);
    mPhoneOn = false;
    mPhoneOnTimer.readSummaryFromParcelLocked(in);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i].readSummaryFromParcelLocked(in);
    }
    mPhoneSignalScanningTimer.readSummaryFromParcelLocked(in);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i].readSummaryFromParcelLocked(in);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i].readSummaryFromParcelLocked(in);
    }
    mWifiOn = false;
    mWifiOnTimer.readSummaryFromParcelLocked(in);
    mGlobalWifiRunning = false;
    mGlobalWifiRunningTimer.readSummaryFromParcelLocked(in);
    mBluetoothOn = false;
    mBluetoothOnTimer.readSummaryFromParcelLocked(in);
    int NKW = in.readInt();
    if (NKW > 10000) {
        Slog.w(TAG, "File corrupt: too many kernel wake locks " + NKW);
        return;
    }
    for (int ikw = 0; ikw < NKW; ikw++) {
        if (in.readInt() != 0) {
            String kwltName = in.readString();
            getKernelWakelockTimerLocked(kwltName).readSummaryFromParcelLocked(in);
        }
    }
    setCpuSpeedSteps(in.readInt());
    final int NU = in.readInt();
    if (NU > 10000) {
        Slog.w(TAG, "File corrupt: too many uids " + NU);
        return;
    }
    for (int iu = 0; iu < NU; iu++) {
        int uid = in.readInt();
        Uid u = new Uid(uid);
        mUidStats.put(uid, u);
        u.mWifiRunning = false;
        if (in.readInt() != 0) {
            u.mWifiRunningTimer.readSummaryFromParcelLocked(in);
        }
        u.mFullWifiLockOut = false;
        if (in.readInt() != 0) {
            u.mFullWifiLockTimer.readSummaryFromParcelLocked(in);
        }
        u.mWifiScanStarted = false;
        if (in.readInt() != 0) {
            u.mWifiScanTimer.readSummaryFromParcelLocked(in);
        }
        u.mWifiBatchedScanBinStarted = Uid.NO_BATCHED_SCAN_STARTED;
        for (int i = 0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
            if (in.readInt() != 0) {
                u.makeWifiBatchedScanBin(i, null);
                u.mWifiBatchedScanTimer[i].readSummaryFromParcelLocked(in);
            }
        }
        u.mWifiMulticastEnabled = false;
        if (in.readInt() != 0) {
            u.mWifiMulticastTimer.readSummaryFromParcelLocked(in);
        }
        u.mAudioTurnedOn = false;
        if (in.readInt() != 0) {
            u.createAudioTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
        }
        u.mVideoTurnedOn = false;
        if (in.readInt() != 0) {
            u.createVideoTurnedOnTimerLocked().readSummaryFromParcelLocked(in);
        }
        if (in.readInt() != 0) {
            u.createForegroundActivityTimerLocked().readSummaryFromParcelLocked(in);
        }
        if (in.readInt() != 0) {
            u.createVibratorOnTimerLocked().readSummaryFromParcelLocked(in);
        }
        if (in.readInt() != 0) {
            if (u.mUserActivityCounters == null) {
                u.initUserActivityLocked();
            }
            for (int i = 0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
                u.mUserActivityCounters[i].readSummaryFromParcelLocked(in);
            }
        }
        if (in.readInt() != 0) {
            if (u.mNetworkActivityCounters == null) {
                u.initNetworkActivityLocked();
            }
            for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
                u.mNetworkActivityCounters[i].readSummaryFromParcelLocked(in);
            }
        }
        int NW = in.readInt();
        if (NW > 100) {
            Slog.w(TAG, "File corrupt: too many wake locks " + NW);
            return;
        }
        for (int iw = 0; iw < NW; iw++) {
            String wlName = in.readString();
            if (in.readInt() != 0) {
                u.getWakeTimerLocked(wlName, WAKE_TYPE_FULL).readSummaryFromParcelLocked(in);
            }
            if (in.readInt() != 0) {
                u.getWakeTimerLocked(wlName, WAKE_TYPE_PARTIAL).readSummaryFromParcelLocked(in);
            }
            if (in.readInt() != 0) {
                u.getWakeTimerLocked(wlName, WAKE_TYPE_WINDOW).readSummaryFromParcelLocked(in);
            }
        }
        int NP = in.readInt();
        if (NP > 1000) {
            Slog.w(TAG, "File corrupt: too many sensors " + NP);
            return;
        }
        for (int is = 0; is < NP; is++) {
            int seNumber = in.readInt();
            if (in.readInt() != 0) {
                u.getSensorTimerLocked(seNumber, true).readSummaryFromParcelLocked(in);
            }
        }
        NP = in.readInt();
        if (NP > 1000) {
            Slog.w(TAG, "File corrupt: too many processes " + NP);
            return;
        }
        for (int ip = 0; ip < NP; ip++) {
            String procName = in.readString();
            Uid.Proc p = u.getProcessStatsLocked(procName);
            p.mUserTime = p.mLoadedUserTime = in.readLong();
            p.mSystemTime = p.mLoadedSystemTime = in.readLong();
            p.mForegroundTime = p.mLoadedForegroundTime = in.readLong();
            p.mStarts = p.mLoadedStarts = in.readInt();
            int NSB = in.readInt();
            if (NSB > 100) {
                Slog.w(TAG, "File corrupt: too many speed bins " + NSB);
                return;
            }
            p.mSpeedBins = new SamplingCounter[NSB];
            for (int i = 0; i < NSB; i++) {
                if (in.readInt() != 0) {
                    p.mSpeedBins[i] = new SamplingCounter(mUnpluggables);
                    p.mSpeedBins[i].readSummaryFromParcelLocked(in);
                }
            }
            if (!p.readExcessivePowerFromParcelLocked(in)) {
                return;
            }
        }
        NP = in.readInt();
        if (NP > 10000) {
            Slog.w(TAG, "File corrupt: too many packages " + NP);
            return;
        }
        for (int ip = 0; ip < NP; ip++) {
            String pkgName = in.readString();
            Uid.Pkg p = u.getPackageStatsLocked(pkgName);
            p.mWakeups = p.mLoadedWakeups = in.readInt();
            final int NS = in.readInt();
            if (NS > 1000) {
                Slog.w(TAG, "File corrupt: too many services " + NS);
                return;
            }
            for (int is = 0; is < NS; is++) {
                String servName = in.readString();
                Uid.Pkg.Serv s = u.getServiceStatsLocked(pkgName, servName);
                s.mStartTime = s.mLoadedStartTime = in.readLong();
                s.mStarts = s.mLoadedStarts = in.readInt();
                s.mLaunches = s.mLoadedLaunches = in.readInt();
            }
        }
    }
}
#end_block

#method_before
public void writeSummaryToParcel(Parcel out) {
    // Need to update with current kernel wake lock counts.
    updateKernelWakelocksLocked();
    updateNetworkActivityLocked();
    final long NOW_SYS = SystemClock.uptimeMillis() * 1000;
    final long NOWREAL_SYS = SystemClock.elapsedRealtime() * 1000;
    final long NOW = getBatteryUptimeLocked(NOW_SYS);
    final long NOWREAL = getBatteryRealtimeLocked(NOWREAL_SYS);
    out.writeInt(VERSION);
    writeHistory(out, true);
    out.writeInt(mStartCount);
    out.writeLong(computeBatteryUptime(NOW_SYS, STATS_SINCE_CHARGED));
    out.writeLong(computeBatteryRealtime(NOWREAL_SYS, STATS_SINCE_CHARGED));
    out.writeLong(computeUptime(NOW_SYS, STATS_SINCE_CHARGED));
    out.writeLong(computeRealtime(NOWREAL_SYS, STATS_SINCE_CHARGED));
    out.writeInt(mDischargeUnplugLevel);
    out.writeInt(mDischargeCurrentLevel);
    out.writeInt(getLowDischargeAmountSinceCharge());
    out.writeInt(getHighDischargeAmountSinceCharge());
    out.writeInt(getDischargeAmountScreenOnSinceCharge());
    out.writeInt(getDischargeAmountScreenOffSinceCharge());
    mScreenOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i].writeSummaryFromParcelLocked(out, NOWREAL);
    }
    mInputEventCounter.writeSummaryFromParcelLocked(out);
    mPhoneOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i].writeSummaryFromParcelLocked(out, NOWREAL);
    }
    mPhoneSignalScanningTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i].writeSummaryFromParcelLocked(out, NOWREAL);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i].writeSummaryFromParcelLocked(out);
    }
    mWifiOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    mGlobalWifiRunningTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    mBluetoothOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    out.writeInt(mKernelWakelockStats.size());
    for (Map.Entry<String, SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
        Timer kwlt = ent.getValue();
        if (kwlt != null) {
            out.writeInt(1);
            out.writeString(ent.getKey());
            ent.getValue().writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
    }
    out.writeInt(sNumSpeedSteps);
    final int NU = mUidStats.size();
    out.writeInt(NU);
    for (int iu = 0; iu < NU; iu++) {
        out.writeInt(mUidStats.keyAt(iu));
        Uid u = mUidStats.valueAt(iu);
        if (u.mWifiRunningTimer != null) {
            out.writeInt(1);
            u.mWifiRunningTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mFullWifiLockTimer != null) {
            out.writeInt(1);
            u.mFullWifiLockTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mWifiScanTimer != null) {
            out.writeInt(1);
            u.mWifiScanTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mWifiMulticastTimer != null) {
            out.writeInt(1);
            u.mWifiMulticastTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mAudioTurnedOnTimer != null) {
            out.writeInt(1);
            u.mAudioTurnedOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mVideoTurnedOnTimer != null) {
            out.writeInt(1);
            u.mVideoTurnedOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mForegroundActivityTimer != null) {
            out.writeInt(1);
            u.mForegroundActivityTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mVibratorOnTimer != null) {
            out.writeInt(1);
            u.mVibratorOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mUserActivityCounters == null) {
            out.writeInt(0);
        } else {
            out.writeInt(1);
            for (int i = 0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
                u.mUserActivityCounters[i].writeSummaryFromParcelLocked(out);
            }
        }
        if (u.mNetworkActivityCounters == null) {
            out.writeInt(0);
        } else {
            out.writeInt(1);
            for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
                u.mNetworkActivityCounters[i].writeSummaryFromParcelLocked(out);
            }
        }
        int NW = u.mWakelockStats.size();
        out.writeInt(NW);
        if (NW > 0) {
            for (Map.Entry<String, BatteryStatsImpl.Uid.Wakelock> ent : u.mWakelockStats.entrySet()) {
                out.writeString(ent.getKey());
                Uid.Wakelock wl = ent.getValue();
                if (wl.mTimerFull != null) {
                    out.writeInt(1);
                    wl.mTimerFull.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
                if (wl.mTimerPartial != null) {
                    out.writeInt(1);
                    wl.mTimerPartial.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
                if (wl.mTimerWindow != null) {
                    out.writeInt(1);
                    wl.mTimerWindow.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
            }
        }
        int NSE = u.mSensorStats.size();
        out.writeInt(NSE);
        if (NSE > 0) {
            for (Map.Entry<Integer, BatteryStatsImpl.Uid.Sensor> ent : u.mSensorStats.entrySet()) {
                out.writeInt(ent.getKey());
                Uid.Sensor se = ent.getValue();
                if (se.mTimer != null) {
                    out.writeInt(1);
                    se.mTimer.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
            }
        }
        int NP = u.mProcessStats.size();
        out.writeInt(NP);
        if (NP > 0) {
            for (Map.Entry<String, BatteryStatsImpl.Uid.Proc> ent : u.mProcessStats.entrySet()) {
                out.writeString(ent.getKey());
                Uid.Proc ps = ent.getValue();
                out.writeLong(ps.mUserTime);
                out.writeLong(ps.mSystemTime);
                out.writeLong(ps.mForegroundTime);
                out.writeInt(ps.mStarts);
                final int N = ps.mSpeedBins.length;
                out.writeInt(N);
                for (int i = 0; i < N; i++) {
                    if (ps.mSpeedBins[i] != null) {
                        out.writeInt(1);
                        ps.mSpeedBins[i].writeSummaryFromParcelLocked(out);
                    } else {
                        out.writeInt(0);
                    }
                }
                ps.writeExcessivePowerToParcelLocked(out);
            }
        }
        NP = u.mPackageStats.size();
        out.writeInt(NP);
        if (NP > 0) {
            for (Map.Entry<String, BatteryStatsImpl.Uid.Pkg> ent : u.mPackageStats.entrySet()) {
                out.writeString(ent.getKey());
                Uid.Pkg ps = ent.getValue();
                out.writeInt(ps.mWakeups);
                final int NS = ps.mServiceStats.size();
                out.writeInt(NS);
                if (NS > 0) {
                    for (Map.Entry<String, BatteryStatsImpl.Uid.Pkg.Serv> sent : ps.mServiceStats.entrySet()) {
                        out.writeString(sent.getKey());
                        BatteryStatsImpl.Uid.Pkg.Serv ss = sent.getValue();
                        long time = ss.getStartTimeToNowLocked(NOW);
                        out.writeLong(time);
                        out.writeInt(ss.mStarts);
                        out.writeInt(ss.mLaunches);
                    }
                }
            }
        }
    }
}
#method_after
public void writeSummaryToParcel(Parcel out) {
    // Need to update with current kernel wake lock counts.
    updateKernelWakelocksLocked();
    updateNetworkActivityLocked();
    final long NOW_SYS = SystemClock.uptimeMillis() * 1000;
    final long NOWREAL_SYS = SystemClock.elapsedRealtime() * 1000;
    final long NOW = getBatteryUptimeLocked(NOW_SYS);
    final long NOWREAL = getBatteryRealtimeLocked(NOWREAL_SYS);
    out.writeInt(VERSION);
    writeHistory(out, true);
    out.writeInt(mStartCount);
    out.writeLong(computeBatteryUptime(NOW_SYS, STATS_SINCE_CHARGED));
    out.writeLong(computeBatteryRealtime(NOWREAL_SYS, STATS_SINCE_CHARGED));
    out.writeLong(computeUptime(NOW_SYS, STATS_SINCE_CHARGED));
    out.writeLong(computeRealtime(NOWREAL_SYS, STATS_SINCE_CHARGED));
    out.writeInt(mDischargeUnplugLevel);
    out.writeInt(mDischargeCurrentLevel);
    out.writeInt(getLowDischargeAmountSinceCharge());
    out.writeInt(getHighDischargeAmountSinceCharge());
    out.writeInt(getDischargeAmountScreenOnSinceCharge());
    out.writeInt(getDischargeAmountScreenOffSinceCharge());
    mScreenOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i].writeSummaryFromParcelLocked(out, NOWREAL);
    }
    mInputEventCounter.writeSummaryFromParcelLocked(out);
    mPhoneOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i].writeSummaryFromParcelLocked(out, NOWREAL);
    }
    mPhoneSignalScanningTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i].writeSummaryFromParcelLocked(out, NOWREAL);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i].writeSummaryFromParcelLocked(out);
    }
    mWifiOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    mGlobalWifiRunningTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    mBluetoothOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
    out.writeInt(mKernelWakelockStats.size());
    for (Map.Entry<String, SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
        Timer kwlt = ent.getValue();
        if (kwlt != null) {
            out.writeInt(1);
            out.writeString(ent.getKey());
            ent.getValue().writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
    }
    out.writeInt(getCpuSpeedSteps());
    final int NU = mUidStats.size();
    out.writeInt(NU);
    for (int iu = 0; iu < NU; iu++) {
        out.writeInt(mUidStats.keyAt(iu));
        Uid u = mUidStats.valueAt(iu);
        if (u.mWifiRunningTimer != null) {
            out.writeInt(1);
            u.mWifiRunningTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mFullWifiLockTimer != null) {
            out.writeInt(1);
            u.mFullWifiLockTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mWifiScanTimer != null) {
            out.writeInt(1);
            u.mWifiScanTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        for (int i = 0; i < Uid.NUM_WIFI_BATCHED_SCAN_BINS; i++) {
            if (u.mWifiBatchedScanTimer[i] != null) {
                out.writeInt(1);
                u.mWifiBatchedScanTimer[i].writeSummaryFromParcelLocked(out, NOWREAL);
            } else {
                out.writeInt(0);
            }
        }
        if (u.mWifiMulticastTimer != null) {
            out.writeInt(1);
            u.mWifiMulticastTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mAudioTurnedOnTimer != null) {
            out.writeInt(1);
            u.mAudioTurnedOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mVideoTurnedOnTimer != null) {
            out.writeInt(1);
            u.mVideoTurnedOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mForegroundActivityTimer != null) {
            out.writeInt(1);
            u.mForegroundActivityTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mVibratorOnTimer != null) {
            out.writeInt(1);
            u.mVibratorOnTimer.writeSummaryFromParcelLocked(out, NOWREAL);
        } else {
            out.writeInt(0);
        }
        if (u.mUserActivityCounters == null) {
            out.writeInt(0);
        } else {
            out.writeInt(1);
            for (int i = 0; i < Uid.NUM_USER_ACTIVITY_TYPES; i++) {
                u.mUserActivityCounters[i].writeSummaryFromParcelLocked(out);
            }
        }
        if (u.mNetworkActivityCounters == null) {
            out.writeInt(0);
        } else {
            out.writeInt(1);
            for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
                u.mNetworkActivityCounters[i].writeSummaryFromParcelLocked(out);
            }
        }
        int NW = u.mWakelockStats.size();
        out.writeInt(NW);
        if (NW > 0) {
            for (Map.Entry<String, BatteryStatsImpl.Uid.Wakelock> ent : u.mWakelockStats.entrySet()) {
                out.writeString(ent.getKey());
                Uid.Wakelock wl = ent.getValue();
                if (wl.mTimerFull != null) {
                    out.writeInt(1);
                    wl.mTimerFull.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
                if (wl.mTimerPartial != null) {
                    out.writeInt(1);
                    wl.mTimerPartial.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
                if (wl.mTimerWindow != null) {
                    out.writeInt(1);
                    wl.mTimerWindow.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
            }
        }
        int NSE = u.mSensorStats.size();
        out.writeInt(NSE);
        if (NSE > 0) {
            for (Map.Entry<Integer, BatteryStatsImpl.Uid.Sensor> ent : u.mSensorStats.entrySet()) {
                out.writeInt(ent.getKey());
                Uid.Sensor se = ent.getValue();
                if (se.mTimer != null) {
                    out.writeInt(1);
                    se.mTimer.writeSummaryFromParcelLocked(out, NOWREAL);
                } else {
                    out.writeInt(0);
                }
            }
        }
        int NP = u.mProcessStats.size();
        out.writeInt(NP);
        if (NP > 0) {
            for (Map.Entry<String, BatteryStatsImpl.Uid.Proc> ent : u.mProcessStats.entrySet()) {
                out.writeString(ent.getKey());
                Uid.Proc ps = ent.getValue();
                out.writeLong(ps.mUserTime);
                out.writeLong(ps.mSystemTime);
                out.writeLong(ps.mForegroundTime);
                out.writeInt(ps.mStarts);
                final int N = ps.mSpeedBins.length;
                out.writeInt(N);
                for (int i = 0; i < N; i++) {
                    if (ps.mSpeedBins[i] != null) {
                        out.writeInt(1);
                        ps.mSpeedBins[i].writeSummaryFromParcelLocked(out);
                    } else {
                        out.writeInt(0);
                    }
                }
                ps.writeExcessivePowerToParcelLocked(out);
            }
        }
        NP = u.mPackageStats.size();
        out.writeInt(NP);
        if (NP > 0) {
            for (Map.Entry<String, BatteryStatsImpl.Uid.Pkg> ent : u.mPackageStats.entrySet()) {
                out.writeString(ent.getKey());
                Uid.Pkg ps = ent.getValue();
                out.writeInt(ps.mWakeups);
                final int NS = ps.mServiceStats.size();
                out.writeInt(NS);
                if (NS > 0) {
                    for (Map.Entry<String, BatteryStatsImpl.Uid.Pkg.Serv> sent : ps.mServiceStats.entrySet()) {
                        out.writeString(sent.getKey());
                        BatteryStatsImpl.Uid.Pkg.Serv ss = sent.getValue();
                        long time = ss.getStartTimeToNowLocked(NOW);
                        out.writeLong(time);
                        out.writeInt(ss.mStarts);
                        out.writeInt(ss.mLaunches);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
void readFromParcelLocked(Parcel in) {
    int magic = in.readInt();
    if (magic != MAGIC) {
        throw new ParcelFormatException("Bad magic number");
    }
    readHistory(in, false);
    mStartCount = in.readInt();
    mBatteryUptime = in.readLong();
    mBatteryLastUptime = 0;
    mBatteryRealtime = in.readLong();
    mBatteryLastRealtime = 0;
    mScreenOn = false;
    mScreenOnTimer = new StopwatchTimer(null, -1, null, mUnpluggables, in);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i] = new StopwatchTimer(null, -100 - i, null, mUnpluggables, in);
    }
    mInputEventCounter = new Counter(mUnpluggables, in);
    mPhoneOn = false;
    mPhoneOnTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i] = new StopwatchTimer(null, -200 - i, null, mUnpluggables, in);
    }
    mPhoneSignalScanningTimer = new StopwatchTimer(null, -200 + 1, null, mUnpluggables, in);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i] = new StopwatchTimer(null, -300 - i, null, mUnpluggables, in);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i] = new LongSamplingCounter(mUnpluggables, in);
    }
    mWifiOn = false;
    mWifiOnTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    mGlobalWifiRunning = false;
    mGlobalWifiRunningTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    mBluetoothOn = false;
    mBluetoothOnTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    mUptime = in.readLong();
    mUptimeStart = in.readLong();
    mLastUptime = 0;
    mRealtime = in.readLong();
    mRealtimeStart = in.readLong();
    mLastRealtime = 0;
    mOnBattery = in.readInt() != 0;
    // we are no longer really running.
    mOnBatteryInternal = false;
    mTrackBatteryPastUptime = in.readLong();
    mTrackBatteryUptimeStart = in.readLong();
    mTrackBatteryPastRealtime = in.readLong();
    mTrackBatteryRealtimeStart = in.readLong();
    mUnpluggedBatteryUptime = in.readLong();
    mUnpluggedBatteryRealtime = in.readLong();
    mDischargeUnplugLevel = in.readInt();
    mDischargeCurrentLevel = in.readInt();
    mLowDischargeAmountSinceCharge = in.readInt();
    mHighDischargeAmountSinceCharge = in.readInt();
    mDischargeAmountScreenOn = in.readInt();
    mDischargeAmountScreenOnSinceCharge = in.readInt();
    mDischargeAmountScreenOff = in.readInt();
    mDischargeAmountScreenOffSinceCharge = in.readInt();
    mLastWriteTime = in.readLong();
    mRadioDataUptime = in.readLong();
    mRadioDataStart = -1;
    mBluetoothPingCount = in.readInt();
    mBluetoothPingStart = -1;
    mKernelWakelockStats.clear();
    int NKW = in.readInt();
    for (int ikw = 0; ikw < NKW; ikw++) {
        if (in.readInt() != 0) {
            String wakelockName = in.readString();
            // Extra 0/1 written by Timer.writeTimerToParcel
            in.readInt();
            SamplingTimer kwlt = new SamplingTimer(mUnpluggables, mOnBattery, in);
            mKernelWakelockStats.put(wakelockName, kwlt);
        }
    }
    mPartialTimers.clear();
    mFullTimers.clear();
    mWindowTimers.clear();
    mWifiRunningTimers.clear();
    mFullWifiLockTimers.clear();
    mWifiScanTimers.clear();
    mWifiMulticastTimers.clear();
    sNumSpeedSteps = in.readInt();
    int numUids = in.readInt();
    mUidStats.clear();
    for (int i = 0; i < numUids; i++) {
        int uid = in.readInt();
        Uid u = new Uid(uid);
        u.readFromParcelLocked(mUnpluggables, in);
        mUidStats.append(uid, u);
    }
}
#method_after
void readFromParcelLocked(Parcel in) {
    int magic = in.readInt();
    if (magic != MAGIC) {
        throw new ParcelFormatException("Bad magic number");
    }
    readHistory(in, false);
    mStartCount = in.readInt();
    mBatteryUptime = in.readLong();
    mBatteryLastUptime = 0;
    mBatteryRealtime = in.readLong();
    mBatteryLastRealtime = 0;
    mScreenOn = false;
    mScreenOnTimer = new StopwatchTimer(null, -1, null, mUnpluggables, in);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i] = new StopwatchTimer(null, -100 - i, null, mUnpluggables, in);
    }
    mInputEventCounter = new Counter(mUnpluggables, in);
    mPhoneOn = false;
    mPhoneOnTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i] = new StopwatchTimer(null, -200 - i, null, mUnpluggables, in);
    }
    mPhoneSignalScanningTimer = new StopwatchTimer(null, -200 + 1, null, mUnpluggables, in);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i] = new StopwatchTimer(null, -300 - i, null, mUnpluggables, in);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i] = new LongSamplingCounter(mUnpluggables, in);
    }
    mWifiOn = false;
    mWifiOnTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    mGlobalWifiRunning = false;
    mGlobalWifiRunningTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    mBluetoothOn = false;
    mBluetoothOnTimer = new StopwatchTimer(null, -2, null, mUnpluggables, in);
    mUptime = in.readLong();
    mUptimeStart = in.readLong();
    mLastUptime = 0;
    mRealtime = in.readLong();
    mRealtimeStart = in.readLong();
    mLastRealtime = 0;
    mOnBattery = in.readInt() != 0;
    // we are no longer really running.
    mOnBatteryInternal = false;
    mTrackBatteryPastUptime = in.readLong();
    mTrackBatteryUptimeStart = in.readLong();
    mTrackBatteryPastRealtime = in.readLong();
    mTrackBatteryRealtimeStart = in.readLong();
    mUnpluggedBatteryUptime = in.readLong();
    mUnpluggedBatteryRealtime = in.readLong();
    mDischargeUnplugLevel = in.readInt();
    mDischargeCurrentLevel = in.readInt();
    mLowDischargeAmountSinceCharge = in.readInt();
    mHighDischargeAmountSinceCharge = in.readInt();
    mDischargeAmountScreenOn = in.readInt();
    mDischargeAmountScreenOnSinceCharge = in.readInt();
    mDischargeAmountScreenOff = in.readInt();
    mDischargeAmountScreenOffSinceCharge = in.readInt();
    mLastWriteTime = in.readLong();
    mRadioDataUptime = in.readLong();
    mRadioDataStart = -1;
    mBluetoothPingCount = in.readInt();
    mBluetoothPingStart = -1;
    mKernelWakelockStats.clear();
    int NKW = in.readInt();
    for (int ikw = 0; ikw < NKW; ikw++) {
        if (in.readInt() != 0) {
            String wakelockName = in.readString();
            // Extra 0/1 written by Timer.writeTimerToParcel
            in.readInt();
            SamplingTimer kwlt = new SamplingTimer(mUnpluggables, mOnBattery, in);
            mKernelWakelockStats.put(wakelockName, kwlt);
        }
    }
    mPartialTimers.clear();
    mFullTimers.clear();
    mWindowTimers.clear();
    mWifiRunningTimers.clear();
    mFullWifiLockTimers.clear();
    mWifiScanTimers.clear();
    mWifiBatchedScanTimers.clear();
    mWifiMulticastTimers.clear();
    setCpuSpeedSteps(in.readInt());
    int numUids = in.readInt();
    mUidStats.clear();
    for (int i = 0; i < numUids; i++) {
        int uid = in.readInt();
        Uid u = new Uid(uid);
        u.readFromParcelLocked(mUnpluggables, in);
        mUidStats.append(uid, u);
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
void writeToParcelLocked(Parcel out, boolean inclUids, int flags) {
    // Need to update with current kernel wake lock counts.
    updateKernelWakelocksLocked();
    updateNetworkActivityLocked();
    final long uSecUptime = SystemClock.uptimeMillis() * 1000;
    final long uSecRealtime = SystemClock.elapsedRealtime() * 1000;
    final long batteryUptime = getBatteryUptimeLocked(uSecUptime);
    final long batteryRealtime = getBatteryRealtimeLocked(uSecRealtime);
    out.writeInt(MAGIC);
    writeHistory(out, false);
    out.writeInt(mStartCount);
    out.writeLong(mBatteryUptime);
    out.writeLong(mBatteryRealtime);
    mScreenOnTimer.writeToParcel(out, batteryRealtime);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i].writeToParcel(out, batteryRealtime);
    }
    mInputEventCounter.writeToParcel(out);
    mPhoneOnTimer.writeToParcel(out, batteryRealtime);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i].writeToParcel(out, batteryRealtime);
    }
    mPhoneSignalScanningTimer.writeToParcel(out, batteryRealtime);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i].writeToParcel(out, batteryRealtime);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i].writeToParcel(out);
    }
    mWifiOnTimer.writeToParcel(out, batteryRealtime);
    mGlobalWifiRunningTimer.writeToParcel(out, batteryRealtime);
    mBluetoothOnTimer.writeToParcel(out, batteryRealtime);
    out.writeLong(mUptime);
    out.writeLong(mUptimeStart);
    out.writeLong(mRealtime);
    out.writeLong(mRealtimeStart);
    out.writeInt(mOnBattery ? 1 : 0);
    out.writeLong(batteryUptime);
    out.writeLong(mTrackBatteryUptimeStart);
    out.writeLong(batteryRealtime);
    out.writeLong(mTrackBatteryRealtimeStart);
    out.writeLong(mUnpluggedBatteryUptime);
    out.writeLong(mUnpluggedBatteryRealtime);
    out.writeInt(mDischargeUnplugLevel);
    out.writeInt(mDischargeCurrentLevel);
    out.writeInt(mLowDischargeAmountSinceCharge);
    out.writeInt(mHighDischargeAmountSinceCharge);
    out.writeInt(mDischargeAmountScreenOn);
    out.writeInt(mDischargeAmountScreenOnSinceCharge);
    out.writeInt(mDischargeAmountScreenOff);
    out.writeInt(mDischargeAmountScreenOffSinceCharge);
    out.writeLong(mLastWriteTime);
    // Write radio uptime for data
    out.writeLong(getRadioDataUptime());
    out.writeInt(getBluetoothPingCount());
    if (inclUids) {
        out.writeInt(mKernelWakelockStats.size());
        for (Map.Entry<String, SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
            SamplingTimer kwlt = ent.getValue();
            if (kwlt != null) {
                out.writeInt(1);
                out.writeString(ent.getKey());
                Timer.writeTimerToParcel(out, kwlt, batteryRealtime);
            } else {
                out.writeInt(0);
            }
        }
    } else {
        out.writeInt(0);
    }
    out.writeInt(sNumSpeedSteps);
    if (inclUids) {
        int size = mUidStats.size();
        out.writeInt(size);
        for (int i = 0; i < size; i++) {
            out.writeInt(mUidStats.keyAt(i));
            Uid uid = mUidStats.valueAt(i);
            uid.writeToParcelLocked(out, batteryRealtime);
        }
    } else {
        out.writeInt(0);
    }
}
#method_after
@SuppressWarnings("unused")
void writeToParcelLocked(Parcel out, boolean inclUids, int flags) {
    // Need to update with current kernel wake lock counts.
    updateKernelWakelocksLocked();
    updateNetworkActivityLocked();
    final long uSecUptime = SystemClock.uptimeMillis() * 1000;
    final long uSecRealtime = SystemClock.elapsedRealtime() * 1000;
    final long batteryUptime = getBatteryUptimeLocked(uSecUptime);
    final long batteryRealtime = getBatteryRealtimeLocked(uSecRealtime);
    out.writeInt(MAGIC);
    writeHistory(out, false);
    out.writeInt(mStartCount);
    out.writeLong(mBatteryUptime);
    out.writeLong(mBatteryRealtime);
    mScreenOnTimer.writeToParcel(out, batteryRealtime);
    for (int i = 0; i < NUM_SCREEN_BRIGHTNESS_BINS; i++) {
        mScreenBrightnessTimer[i].writeToParcel(out, batteryRealtime);
    }
    mInputEventCounter.writeToParcel(out);
    mPhoneOnTimer.writeToParcel(out, batteryRealtime);
    for (int i = 0; i < SignalStrength.NUM_SIGNAL_STRENGTH_BINS; i++) {
        mPhoneSignalStrengthsTimer[i].writeToParcel(out, batteryRealtime);
    }
    mPhoneSignalScanningTimer.writeToParcel(out, batteryRealtime);
    for (int i = 0; i < NUM_DATA_CONNECTION_TYPES; i++) {
        mPhoneDataConnectionsTimer[i].writeToParcel(out, batteryRealtime);
    }
    for (int i = 0; i < NUM_NETWORK_ACTIVITY_TYPES; i++) {
        mNetworkActivityCounters[i].writeToParcel(out);
    }
    mWifiOnTimer.writeToParcel(out, batteryRealtime);
    mGlobalWifiRunningTimer.writeToParcel(out, batteryRealtime);
    mBluetoothOnTimer.writeToParcel(out, batteryRealtime);
    out.writeLong(mUptime);
    out.writeLong(mUptimeStart);
    out.writeLong(mRealtime);
    out.writeLong(mRealtimeStart);
    out.writeInt(mOnBattery ? 1 : 0);
    out.writeLong(batteryUptime);
    out.writeLong(mTrackBatteryUptimeStart);
    out.writeLong(batteryRealtime);
    out.writeLong(mTrackBatteryRealtimeStart);
    out.writeLong(mUnpluggedBatteryUptime);
    out.writeLong(mUnpluggedBatteryRealtime);
    out.writeInt(mDischargeUnplugLevel);
    out.writeInt(mDischargeCurrentLevel);
    out.writeInt(mLowDischargeAmountSinceCharge);
    out.writeInt(mHighDischargeAmountSinceCharge);
    out.writeInt(mDischargeAmountScreenOn);
    out.writeInt(mDischargeAmountScreenOnSinceCharge);
    out.writeInt(mDischargeAmountScreenOff);
    out.writeInt(mDischargeAmountScreenOffSinceCharge);
    out.writeLong(mLastWriteTime);
    // Write radio uptime for data
    out.writeLong(getRadioDataUptime());
    out.writeInt(getBluetoothPingCount());
    if (inclUids) {
        out.writeInt(mKernelWakelockStats.size());
        for (Map.Entry<String, SamplingTimer> ent : mKernelWakelockStats.entrySet()) {
            SamplingTimer kwlt = ent.getValue();
            if (kwlt != null) {
                out.writeInt(1);
                out.writeString(ent.getKey());
                Timer.writeTimerToParcel(out, kwlt, batteryRealtime);
            } else {
                out.writeInt(0);
            }
        }
    } else {
        out.writeInt(0);
    }
    out.writeInt(getCpuSpeedSteps());
    if (inclUids) {
        int size = mUidStats.size();
        out.writeInt(size);
        for (int i = 0; i < size; i++) {
            out.writeInt(mUidStats.keyAt(i));
            Uid uid = mUidStats.valueAt(i);
            uid.writeToParcelLocked(out, batteryRealtime);
        }
    } else {
        out.writeInt(0);
    }
}
#end_block

#method_before
public void refreshSignalCluster(SignalCluster cluster) {
    if (mDemoMode)
        return;
    cluster.setWifiIndicators(// only show wifi in the cluster if connected or if wifi-only
    mWifiEnabled && (mWifiConnected || !mHasMobileDataFeature), mWifiIconId, mWifiActivityIconId, mContentDescriptionWifi);
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is special
        cluster.setMobileDataIndicators(true, mAlwaysShowCdmaRssi ? mPhoneSignalIconId : mWimaxIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionWimax, mContentDescriptionDataType);
    } else {
        // normal mobile data
        cluster.setMobileDataIndicators(mHasMobileDataFeature, mShowPhoneRSSIForData ? mPhoneSignalIconId : mDataSignalIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionPhoneSignal, mContentDescriptionDataType);
    }
    cluster.setIsAirplaneMode(mAirplaneMode, mAirplaneIconId);
}
#method_after
public void refreshSignalCluster(SignalCluster cluster) {
    if (mDemoMode)
        return;
    cluster.setWifiIndicators(// only show wifi in the cluster if connected or if wifi-only
    mWifiEnabled && (mWifiConnected || !mHasMobileDataFeature), mWifiIconId, mWifiActivityIconId, mContentDescriptionWifi);
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is special
        cluster.setMobileDataIndicators(true, mAlwaysShowCdmaRssi ? mPhoneSignalIconId : mWimaxIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionWimax, mContentDescriptionDataType, mNoSimIconId);
    } else {
        // normal mobile data
        cluster.setMobileDataIndicators(mHasMobileDataFeature, mShowPhoneRSSIForData ? mPhoneSignalIconId : mDataSignalIconId, mMobileActivityIconId, mDataTypeIconId, mContentDescriptionPhoneSignal, mContentDescriptionDataType, mNoSimIconId);
    }
    cluster.setIsAirplaneMode(mAirplaneMode, mAirplaneIconId);
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    final String action = intent.getAction();
    if (action.equals(WifiManager.RSSI_CHANGED_ACTION) || action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION) || action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
        updateWifiState(intent);
        refreshViews();
    } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
        updateSimState(intent);
        updateDataIcon();
        refreshViews();
    } else if (action.equals(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION)) {
        updateNetworkName(intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_SPN, false), intent.getStringExtra(TelephonyIntents.EXTRA_SPN), intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_PLMN, false), intent.getStringExtra(TelephonyIntents.EXTRA_PLMN));
        refreshViews();
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) || action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
        updateConnectivity(intent);
        refreshViews();
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        refreshLocale();
        refreshViews();
    } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
        refreshLocale();
        updateAirplaneMode();
        refreshViews();
    } else if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION) || action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION) || action.equals(WimaxManagerConstants.WIMAX_NETWORK_STATE_CHANGED_ACTION)) {
        updateWimaxState(intent);
        refreshViews();
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    final String action = intent.getAction();
    if (action.equals(WifiManager.RSSI_CHANGED_ACTION) || action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION) || action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
        updateWifiState(intent);
        refreshViews();
    } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
        updateSimState(intent);
        updateDataIcon();
        refreshViews();
    } else if (action.equals(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION)) {
        updateNetworkName(intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_SPN, false), intent.getStringExtra(TelephonyIntents.EXTRA_SPN), intent.getBooleanExtra(TelephonyIntents.EXTRA_SHOW_PLMN, false), intent.getStringExtra(TelephonyIntents.EXTRA_PLMN));
        refreshViews();
    } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) || action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
        updateConnectivity(intent);
        refreshViews();
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        refreshLocale();
        refreshViews();
    } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
        refreshLocale();
        updateAirplaneMode();
        updateSimIcon();
        refreshViews();
    } else if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION) || action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION) || action.equals(WimaxManagerConstants.WIMAX_NETWORK_STATE_CHANGED_ACTION)) {
        updateWimaxState(intent);
        refreshViews();
    }
}
#end_block

#method_before
private final void updateSimState(Intent intent) {
    String stateExtra = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
    if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(stateExtra)) {
        mSimState = IccCardConstants.State.ABSENT;
    } else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(stateExtra)) {
        mSimState = IccCardConstants.State.READY;
    } else if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(stateExtra)) {
        final String lockedReason = intent.getStringExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON);
        if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN.equals(lockedReason)) {
            mSimState = IccCardConstants.State.PIN_REQUIRED;
        } else if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(lockedReason)) {
            mSimState = IccCardConstants.State.PUK_REQUIRED;
        } else {
            mSimState = IccCardConstants.State.NETWORK_LOCKED;
        }
    } else {
        mSimState = IccCardConstants.State.UNKNOWN;
    }
}
#method_after
protected void updateSimState(Intent intent) {
    String stateExtra = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
    if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(stateExtra)) {
        mSimState = IccCardConstants.State.ABSENT;
    } else if (IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR.equals(stateExtra)) {
        mSimState = IccCardConstants.State.CARD_IO_ERROR;
    } else if (IccCardConstants.INTENT_VALUE_ICC_READY.equals(stateExtra)) {
        mSimState = IccCardConstants.State.READY;
    } else if (IccCardConstants.INTENT_VALUE_ICC_LOCKED.equals(stateExtra)) {
        final String lockedReason = intent.getStringExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON);
        if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN.equals(lockedReason)) {
            mSimState = IccCardConstants.State.PIN_REQUIRED;
        } else if (IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK.equals(lockedReason)) {
            mSimState = IccCardConstants.State.PUK_REQUIRED;
        } else {
            mSimState = IccCardConstants.State.PERSO_LOCKED;
        }
    } else {
        mSimState = IccCardConstants.State.UNKNOWN;
    }
    updateSimIcon();
}
#end_block

#method_before
private void updateAirplaneMode() {
    mAirplaneMode = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON, 0) == 1);
}
#method_after
protected void updateAirplaneMode() {
    mAirplaneMode = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON, 0) == 1);
}
#end_block

#method_before
private final void updateTelephonySignalStrength() {
    if (!hasService()) {
        if (CHATTY)
            Log.d(TAG, "updateTelephonySignalStrength: !hasService()");
        mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
        mQSPhoneSignalIconId = R.drawable.ic_qs_signal_no_signal;
        mDataSignalIconId = R.drawable.stat_sys_signal_null;
    } else {
        if (mSignalStrength == null) {
            if (CHATTY)
                Log.d(TAG, "updateTelephonySignalStrength: mSignalStrength == null");
            mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
            mQSPhoneSignalIconId = R.drawable.ic_qs_signal_no_signal;
            mDataSignalIconId = R.drawable.stat_sys_signal_null;
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0]);
        } else {
            int iconLevel;
            int[] iconList;
            if (isCdma() && mAlwaysShowCdmaRssi) {
                mLastSignalLevel = iconLevel = mSignalStrength.getCdmaLevel();
                if (DEBUG)
                    Log.d(TAG, "mAlwaysShowCdmaRssi=" + mAlwaysShowCdmaRssi + " set to cdmaLevel=" + mSignalStrength.getCdmaLevel() + " instead of level=" + mSignalStrength.getLevel());
            } else {
                mLastSignalLevel = iconLevel = mSignalStrength.getLevel();
            }
            if (isCdma()) {
                if (isCdmaEri()) {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
                } else {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
                }
            } else {
                // Though mPhone is a Manager, this call is not an IPC
                if (mPhone.isNetworkRoaming()) {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
                } else {
                    iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
                }
            }
            mPhoneSignalIconId = iconList[iconLevel];
            mQSPhoneSignalIconId = TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH[mInetCondition][iconLevel];
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[iconLevel]);
            mDataSignalIconId = TelephonyIcons.DATA_SIGNAL_STRENGTH[mInetCondition][iconLevel];
        }
    }
}
#method_after
private final void updateTelephonySignalStrength() {
    if (!hasService() && (mDataServiceState != ServiceState.STATE_IN_SERVICE)) {
        if (DEBUG)
            Log.d(TAG, " No service");
        mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
        mQSPhoneSignalIconId = R.drawable.ic_qs_signal_no_signal;
        mDataSignalIconId = R.drawable.stat_sys_signal_null;
    } else {
        if ((mSignalStrength == null) || (mServiceState == null)) {
            if (DEBUG) {
                Log.d(TAG, " Null object, mSignalStrength= " + mSignalStrength + " mServiceState " + mServiceState);
            }
            mPhoneSignalIconId = R.drawable.stat_sys_signal_null;
            mQSPhoneSignalIconId = R.drawable.ic_qs_signal_no_signal;
            mDataSignalIconId = R.drawable.stat_sys_signal_null;
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[0]);
        } else {
            int iconLevel;
            int[] iconList;
            if (isCdma() && mAlwaysShowCdmaRssi) {
                mLastSignalLevel = iconLevel = mSignalStrength.getCdmaLevel();
                if (DEBUG)
                    Log.d(TAG, "mAlwaysShowCdmaRssi=" + mAlwaysShowCdmaRssi + " set to cdmaLevel=" + mSignalStrength.getCdmaLevel() + " instead of level=" + mSignalStrength.getLevel());
            } else {
                mLastSignalLevel = iconLevel = mSignalStrength.getLevel();
            }
            // Though mPhone is a Manager, this call is not an IPC
            if ((isCdma() && isCdmaEri()) || mPhone.isNetworkRoaming()) {
                iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH_ROAMING[mInetCondition];
            } else {
                iconList = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH[mInetCondition];
            }
            mPhoneSignalIconId = iconList[iconLevel];
            mQSPhoneSignalIconId = TelephonyIcons.QS_TELEPHONY_SIGNAL_STRENGTH[mInetCondition][iconLevel];
            mContentDescriptionPhoneSignal = mContext.getString(AccessibilityContentDescriptions.PHONE_SIGNAL_STRENGTH[iconLevel]);
            mDataSignalIconId = TelephonyIcons.DATA_SIGNAL_STRENGTH[mInetCondition][iconLevel];
        }
    }
}
#end_block

#method_before
private final void updateDataNetType() {
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is a special 4g network not handled by telephony
        mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
        mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_4g;
        mQSDataTypeIconId = TelephonyIcons.QS_DATA_4G[mInetCondition];
        mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
    } else {
        switch(mDataNetType) {
            case TelephonyManager.NETWORK_TYPE_UNKNOWN:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = 0;
                    mQSDataTypeIconId = 0;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_EDGE:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_E[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_e;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_E[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_edge);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_UMTS:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_HSDPA:
            case TelephonyManager.NETWORK_TYPE_HSUPA:
            case TelephonyManager.NETWORK_TYPE_HSPA:
                if (mHspaDataDistinguishable) {
                    mDataIconList = TelephonyIcons.DATA_H[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_h;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_H[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3_5g);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
            case TelephonyManager.NETWORK_TYPE_HSPAP:
                mDataIconList = TelephonyIcons.DATA_HP[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_hp;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_HP[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_HP);
                break;
            case TelephonyManager.NETWORK_TYPE_DCHSPAP:
                mDataIconList = TelephonyIcons.DATA_DC[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_dc;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_DC[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_DC);
                break;
            case TelephonyManager.NETWORK_TYPE_CDMA:
                if (!mShowAtLeastThreeGees) {
                    // display 1xRTT for IS95A/B
                    mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_1x;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_1X[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_1xRTT:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_1x;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_1X[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                    break;
                } else {
                // fall through
                }
            // fall through
            case TelephonyManager.NETWORK_TYPE_EVDO_0:
            case TelephonyManager.NETWORK_TYPE_EVDO_A:
            case TelephonyManager.NETWORK_TYPE_EVDO_B:
            case TelephonyManager.NETWORK_TYPE_EHRPD:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_LTE:
                boolean show4GforLTE = mContext.getResources().getBoolean(R.bool.config_show4GForLTE);
                if (show4GforLTE) {
                    mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_4g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_4G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
                } else {
                    mDataIconList = TelephonyIcons.DATA_LTE[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_lte;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_LTE[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_lte);
                }
                break;
            default:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
        }
    }
    if (isCdma()) {
        if (isCdmaEri()) {
            mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
            mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
        }
    } else if (mPhone.isNetworkRoaming()) {
        mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
        mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
    }
}
#method_after
private final void updateDataNetType() {
    if (mIsWimaxEnabled && mWimaxConnected) {
        // wimax is a special 4g network not handled by telephony
        mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
        mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_4g;
        mQSDataTypeIconId = TelephonyIcons.QS_DATA_4G[mInetCondition];
        mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
    } else {
        switch(mDataNetType) {
            case TelephonyManager.NETWORK_TYPE_UNKNOWN:
                if (DEBUG) {
                    Log.e(TAG, "updateDataNetType NETWORK_TYPE_UNKNOWN");
                }
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = 0;
                    mQSDataTypeIconId = 0;
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_EDGE:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_E[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_e;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_E[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_edge);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_UMTS:
            case TelephonyManager.NETWORK_TYPE_TD_SCDMA:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_HSDPA:
            case TelephonyManager.NETWORK_TYPE_HSUPA:
            case TelephonyManager.NETWORK_TYPE_HSPA:
                if (mHspaDataDistinguishable) {
                    mDataIconList = TelephonyIcons.DATA_H[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_h;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_H[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3_5g);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
            case TelephonyManager.NETWORK_TYPE_HSPAP:
                mDataIconList = TelephonyIcons.DATA_HP[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_hp;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_HP[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_HP);
                break;
            case TelephonyManager.NETWORK_TYPE_DCHSPAP:
                mDataIconList = TelephonyIcons.DATA_DC[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_dc;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_DC[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_DC);
                break;
            case TelephonyManager.NETWORK_TYPE_CDMA:
                if (!mShowAtLeastThreeGees) {
                    // display 1xRTT for IS95A/B
                    mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_1x;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_1X[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                    break;
                } else {
                // fall through
                }
            case TelephonyManager.NETWORK_TYPE_1xRTT:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_1X[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_1x;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_1X[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_cdma);
                    break;
                } else {
                // fall through
                }
            // fall through
            case TelephonyManager.NETWORK_TYPE_EVDO_0:
            case TelephonyManager.NETWORK_TYPE_EVDO_A:
            case TelephonyManager.NETWORK_TYPE_EVDO_B:
            case TelephonyManager.NETWORK_TYPE_EHRPD:
                mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                break;
            case TelephonyManager.NETWORK_TYPE_LTE:
                boolean show4GforLTE = mContext.getResources().getBoolean(R.bool.config_show4GForLTE);
                if (show4GforLTE) {
                    mDataIconList = TelephonyIcons.DATA_4G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_4g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_4G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_4g);
                } else {
                    mDataIconList = TelephonyIcons.DATA_LTE[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_lte;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_LTE[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_lte);
                }
                break;
            case TelephonyManager.NETWORK_TYPE_GPRS:
                if (!mShowAtLeastThreeGees) {
                    mDataIconList = TelephonyIcons.DATA_G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_gprs);
                } else {
                    mDataIconList = TelephonyIcons.DATA_3G[mInetCondition];
                    mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_3g;
                    mQSDataTypeIconId = TelephonyIcons.QS_DATA_3G[mInetCondition];
                    mContentDescriptionDataType = mContext.getString(R.string.accessibility_data_connection_3g);
                }
                break;
            default:
                if (DEBUG) {
                    Log.e(TAG, "updateDataNetType unknown radio:" + mDataNetType);
                }
                mDataNetType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
                mDataTypeIconId = 0;
                break;
        }
    }
    if (isCdma()) {
        if (isCdmaEri()) {
            mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
            mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
        }
    } else if (mPhone.isNetworkRoaming()) {
        mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
        mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
    }
}
#end_block

#method_before
boolean isCdmaEri() {
    if (mServiceState != null) {
        final int iconIndex = mServiceState.getCdmaEriIconIndex();
        if (iconIndex != EriInfo.ROAMING_INDICATOR_OFF) {
            final int iconMode = mServiceState.getCdmaEriIconMode();
            if (iconMode == EriInfo.ROAMING_ICON_MODE_NORMAL || iconMode == EriInfo.ROAMING_ICON_MODE_FLASH) {
                return true;
            }
        }
    }
    return false;
}
#method_after
boolean isCdmaEri() {
    if ((mServiceState != null) && (hasService() || (mDataServiceState == ServiceState.STATE_IN_SERVICE))) {
        final int iconIndex = mServiceState.getCdmaEriIconIndex();
        if (iconIndex != EriInfo.ROAMING_INDICATOR_OFF) {
            final int iconMode = mServiceState.getCdmaEriIconMode();
            if (iconMode == EriInfo.ROAMING_ICON_MODE_NORMAL || iconMode == EriInfo.ROAMING_ICON_MODE_FLASH) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private final void updateDataIcon() {
    int iconId;
    boolean visible = true;
    if (!isCdma()) {
        // GSM case, we have to check also the sim state
        if (mSimState == IccCardConstants.State.READY || mSimState == IccCardConstants.State.UNKNOWN) {
            if (hasService() && mDataState == TelephonyManager.DATA_CONNECTED) {
                switch(mDataActivity) {
                    case TelephonyManager.DATA_ACTIVITY_IN:
                        iconId = mDataIconList[1];
                        break;
                    case TelephonyManager.DATA_ACTIVITY_OUT:
                        iconId = mDataIconList[2];
                        break;
                    case TelephonyManager.DATA_ACTIVITY_INOUT:
                        iconId = mDataIconList[3];
                        break;
                    default:
                        iconId = mDataIconList[0];
                        break;
                }
                mDataDirectionIconId = iconId;
            } else {
                iconId = 0;
                visible = false;
            }
        } else {
            iconId = R.drawable.stat_sys_no_sim;
            // no SIM? no data
            visible = false;
        }
    } else {
        // CDMA case, mDataActivity can be also DATA_ACTIVITY_DORMANT
        if (hasService() && mDataState == TelephonyManager.DATA_CONNECTED) {
            switch(mDataActivity) {
                case TelephonyManager.DATA_ACTIVITY_IN:
                    iconId = mDataIconList[1];
                    break;
                case TelephonyManager.DATA_ACTIVITY_OUT:
                    iconId = mDataIconList[2];
                    break;
                case TelephonyManager.DATA_ACTIVITY_INOUT:
                    iconId = mDataIconList[3];
                    break;
                case TelephonyManager.DATA_ACTIVITY_DORMANT:
                default:
                    iconId = mDataIconList[0];
                    break;
            }
        } else {
            iconId = 0;
            visible = false;
        }
    }
    mDataDirectionIconId = iconId;
    mDataConnected = visible;
}
#method_after
private final void updateDataIcon() {
    int iconId = 0;
    boolean visible = true;
    if (mDataNetType == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
        // If data network type is unknown do not display data icon
        visible = false;
    } else if (!isCdma()) {
        // GSM case, we have to check also the sim state
        if (mSimState == IccCardConstants.State.READY || mSimState == IccCardConstants.State.UNKNOWN) {
            if (mDataState == TelephonyManager.DATA_CONNECTED) {
                switch(mDataActivity) {
                    case TelephonyManager.DATA_ACTIVITY_IN:
                        iconId = mDataIconList[1];
                        break;
                    case TelephonyManager.DATA_ACTIVITY_OUT:
                        iconId = mDataIconList[2];
                        break;
                    case TelephonyManager.DATA_ACTIVITY_INOUT:
                        iconId = mDataIconList[3];
                        break;
                    default:
                        iconId = mDataIconList[0];
                        break;
                }
                mDataDirectionIconId = iconId;
            } else {
                iconId = 0;
                visible = false;
            }
        } else {
            iconId = R.drawable.stat_sys_no_sim;
            // no SIM? no data
            visible = false;
        }
    } else {
        // CDMA case, mDataActivity can be also DATA_ACTIVITY_DORMANT
        if (mDataState == TelephonyManager.DATA_CONNECTED) {
            switch(mDataActivity) {
                case TelephonyManager.DATA_ACTIVITY_IN:
                    iconId = mDataIconList[1];
                    break;
                case TelephonyManager.DATA_ACTIVITY_OUT:
                    iconId = mDataIconList[2];
                    break;
                case TelephonyManager.DATA_ACTIVITY_INOUT:
                    iconId = mDataIconList[3];
                    break;
                case TelephonyManager.DATA_ACTIVITY_DORMANT:
                default:
                    iconId = mDataIconList[0];
                    break;
            }
        } else {
            iconId = 0;
            visible = false;
        }
    }
    mDataDirectionIconId = iconId;
    mDataConnected = visible;
}
#end_block

#method_before
private void updateWifiState(Intent intent) {
    final String action = intent.getAction();
    if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
        mWifiEnabled = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, WifiManager.WIFI_STATE_UNKNOWN) == WifiManager.WIFI_STATE_ENABLED;
    } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
        final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
        boolean wasConnected = mWifiConnected;
        mWifiConnected = networkInfo != null && networkInfo.isConnected();
        // If we just connected, grab the inintial signal strength and ssid
        if (mWifiConnected && !wasConnected) {
            // try getting it out of the intent first
            WifiInfo info = (WifiInfo) intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);
            if (info == null) {
                info = mWifiManager.getConnectionInfo();
            }
            if (info != null) {
                mWifiSsid = huntForSsid(info);
            } else {
                mWifiSsid = null;
            }
        } else if (!mWifiConnected) {
            mWifiSsid = null;
        }
    } else if (action.equals(WifiManager.RSSI_CHANGED_ACTION)) {
        mWifiRssi = intent.getIntExtra(WifiManager.EXTRA_NEW_RSSI, -200);
        mWifiLevel = WifiManager.calculateSignalLevel(mWifiRssi, WifiIcons.WIFI_LEVEL_COUNT);
    }
    updateWifiIcons();
}
#method_after
protected void updateWifiState(Intent intent) {
    final String action = intent.getAction();
    if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
        mWifiEnabled = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, WifiManager.WIFI_STATE_UNKNOWN) == WifiManager.WIFI_STATE_ENABLED;
    } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
        final NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
        boolean wasConnected = mWifiConnected;
        mWifiConnected = networkInfo != null && networkInfo.isConnected();
        // If we just connected, grab the inintial signal strength and ssid
        if (mWifiConnected && !wasConnected) {
            // try getting it out of the intent first
            WifiInfo info = (WifiInfo) intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);
            if (info == null) {
                info = mWifiManager.getConnectionInfo();
            }
            if (info != null) {
                mWifiSsid = huntForSsid(info);
            } else {
                mWifiSsid = null;
            }
        } else if (!mWifiConnected) {
            mWifiSsid = null;
        }
    } else if (action.equals(WifiManager.RSSI_CHANGED_ACTION)) {
        mWifiRssi = intent.getIntExtra(WifiManager.EXTRA_NEW_RSSI, -200);
        mWifiLevel = WifiManager.calculateSignalLevel(mWifiRssi, WifiIcons.WIFI_LEVEL_COUNT);
    }
    updateWifiIcons();
}
#end_block

#method_before
private void updateWifiIcons() {
    if (mWifiConnected) {
        mWifiIconId = WifiIcons.WIFI_SIGNAL_STRENGTH[mInetCondition][mWifiLevel];
        mQSWifiIconId = WifiIcons.QS_WIFI_SIGNAL_STRENGTH[mInetCondition][mWifiLevel];
        mContentDescriptionWifi = mContext.getString(AccessibilityContentDescriptions.WIFI_CONNECTION_STRENGTH[mWifiLevel]);
    } else {
        if (mDataAndWifiStacked) {
            mWifiIconId = 0;
            mQSWifiIconId = 0;
        } else {
            mWifiIconId = mWifiEnabled ? R.drawable.stat_sys_wifi_signal_null : 0;
            mQSWifiIconId = mWifiEnabled ? R.drawable.ic_qs_wifi_no_network : 0;
        }
        mContentDescriptionWifi = mContext.getString(R.string.accessibility_no_wifi);
    }
}
#method_after
protected void updateWifiIcons() {
    if (mWifiConnected) {
        mWifiIconId = WifiIcons.WIFI_SIGNAL_STRENGTH[mInetCondition][mWifiLevel];
        mQSWifiIconId = WifiIcons.QS_WIFI_SIGNAL_STRENGTH[mInetCondition][mWifiLevel];
        mContentDescriptionWifi = mContext.getString(AccessibilityContentDescriptions.WIFI_CONNECTION_STRENGTH[mWifiLevel]);
    } else {
        if (mDataAndWifiStacked) {
            mWifiIconId = 0;
            mQSWifiIconId = 0;
        } else {
            mWifiIconId = mWifiEnabled ? R.drawable.stat_sys_wifi_signal_null : 0;
            mQSWifiIconId = mWifiEnabled ? R.drawable.ic_qs_wifi_no_network : 0;
        }
        mContentDescriptionWifi = mContext.getString(R.string.accessibility_no_wifi);
    }
}
#end_block

#method_before
private final void updateWimaxState(Intent intent) {
    final String action = intent.getAction();
    boolean wasConnected = mWimaxConnected;
    if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION)) {
        int wimaxStatus = intent.getIntExtra(WimaxManagerConstants.EXTRA_4G_STATE, WimaxManagerConstants.NET_4G_STATE_UNKNOWN);
        mIsWimaxEnabled = (wimaxStatus == WimaxManagerConstants.NET_4G_STATE_ENABLED);
    } else if (action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION)) {
        mWimaxSignal = intent.getIntExtra(WimaxManagerConstants.EXTRA_NEW_SIGNAL_LEVEL, 0);
    } else if (action.equals(WimaxManagerConstants.WIMAX_NETWORK_STATE_CHANGED_ACTION)) {
        mWimaxState = intent.getIntExtra(WimaxManagerConstants.EXTRA_WIMAX_STATE, WimaxManagerConstants.NET_4G_STATE_UNKNOWN);
        mWimaxExtraState = intent.getIntExtra(WimaxManagerConstants.EXTRA_WIMAX_STATE_DETAIL, WimaxManagerConstants.NET_4G_STATE_UNKNOWN);
        mWimaxConnected = (mWimaxState == WimaxManagerConstants.WIMAX_STATE_CONNECTED);
        mWimaxIdle = (mWimaxExtraState == WimaxManagerConstants.WIMAX_IDLE);
    }
    updateDataNetType();
    updateWimaxIcons();
}
#method_after
protected final void updateWimaxState(Intent intent) {
    final String action = intent.getAction();
    boolean wasConnected = mWimaxConnected;
    if (action.equals(WimaxManagerConstants.NET_4G_STATE_CHANGED_ACTION)) {
        int wimaxStatus = intent.getIntExtra(WimaxManagerConstants.EXTRA_4G_STATE, WimaxManagerConstants.NET_4G_STATE_UNKNOWN);
        mIsWimaxEnabled = (wimaxStatus == WimaxManagerConstants.NET_4G_STATE_ENABLED);
    } else if (action.equals(WimaxManagerConstants.SIGNAL_LEVEL_CHANGED_ACTION)) {
        mWimaxSignal = intent.getIntExtra(WimaxManagerConstants.EXTRA_NEW_SIGNAL_LEVEL, 0);
    } else if (action.equals(WimaxManagerConstants.WIMAX_NETWORK_STATE_CHANGED_ACTION)) {
        mWimaxState = intent.getIntExtra(WimaxManagerConstants.EXTRA_WIMAX_STATE, WimaxManagerConstants.NET_4G_STATE_UNKNOWN);
        mWimaxExtraState = intent.getIntExtra(WimaxManagerConstants.EXTRA_WIMAX_STATE_DETAIL, WimaxManagerConstants.NET_4G_STATE_UNKNOWN);
        mWimaxConnected = (mWimaxState == WimaxManagerConstants.WIMAX_STATE_CONNECTED);
        mWimaxIdle = (mWimaxExtraState == WimaxManagerConstants.WIMAX_IDLE);
    }
    updateDataNetType();
    updateWimaxIcons();
}
#end_block

#method_before
private void updateWimaxIcons() {
    if (mIsWimaxEnabled) {
        if (mWimaxConnected) {
            if (mWimaxIdle)
                mWimaxIconId = WimaxIcons.WIMAX_IDLE;
            else
                mWimaxIconId = WimaxIcons.WIMAX_SIGNAL_STRENGTH[mInetCondition][mWimaxSignal];
            mContentDescriptionWimax = mContext.getString(AccessibilityContentDescriptions.WIMAX_CONNECTION_STRENGTH[mWimaxSignal]);
        } else {
            mWimaxIconId = WimaxIcons.WIMAX_DISCONNECTED;
            mContentDescriptionWimax = mContext.getString(R.string.accessibility_no_wimax);
        }
    } else {
        mWimaxIconId = 0;
    }
}
#method_after
protected void updateWimaxIcons() {
    if (mIsWimaxEnabled) {
        if (mWimaxConnected) {
            if (mWimaxIdle)
                mWimaxIconId = WimaxIcons.WIMAX_IDLE;
            else
                mWimaxIconId = WimaxIcons.WIMAX_SIGNAL_STRENGTH[mInetCondition][mWimaxSignal];
            mContentDescriptionWimax = mContext.getString(AccessibilityContentDescriptions.WIMAX_CONNECTION_STRENGTH[mWimaxSignal]);
        } else {
            mWimaxIconId = WimaxIcons.WIMAX_DISCONNECTED;
            mContentDescriptionWimax = mContext.getString(R.string.accessibility_no_wimax);
        }
    } else {
        mWimaxIconId = 0;
    }
}
#end_block

#method_before
// ===== Full or limited Internet connectivity ==================================
private void updateConnectivity(Intent intent) {
    if (CHATTY) {
        Log.d(TAG, "updateConnectivity: intent=" + intent);
    }
    final ConnectivityManager connManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
    final NetworkInfo info = connManager.getActiveNetworkInfo();
    // Are we connected at all, by any interface?
    mConnected = info != null && info.isConnected();
    if (mConnected) {
        mConnectedNetworkType = info.getType();
        mConnectedNetworkTypeName = info.getTypeName();
    } else {
        mConnectedNetworkType = ConnectivityManager.TYPE_NONE;
        mConnectedNetworkTypeName = null;
    }
    int connectionStatus = intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION, 0);
    if (CHATTY) {
        Log.d(TAG, "updateConnectivity: networkInfo=" + info);
        Log.d(TAG, "updateConnectivity: connectionStatus=" + connectionStatus);
    }
    mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
    if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {
        mBluetoothTethered = info.isConnected();
    } else {
        mBluetoothTethered = false;
    }
    // We want to update all the icons, all at once, for any condition change
    updateDataNetType();
    updateWimaxIcons();
    updateDataIcon();
    updateTelephonySignalStrength();
    updateWifiIcons();
}
#method_after
// ===== Full or limited Internet connectivity ==================================
protected void updateConnectivity(Intent intent) {
    if (CHATTY) {
        Log.d(TAG, "updateConnectivity: intent=" + intent);
    }
    final ConnectivityManager connManager = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
    final NetworkInfo info = connManager.getActiveNetworkInfo();
    // Are we connected at all, by any interface?
    mConnected = info != null && info.isConnected();
    if (mConnected) {
        mConnectedNetworkType = info.getType();
        mConnectedNetworkTypeName = info.getTypeName();
    } else {
        mConnectedNetworkType = ConnectivityManager.TYPE_NONE;
        mConnectedNetworkTypeName = null;
    }
    int connectionStatus = intent.getIntExtra(ConnectivityManager.EXTRA_INET_CONDITION, 0);
    if (CHATTY) {
        Log.d(TAG, "updateConnectivity: networkInfo=" + info);
        Log.d(TAG, "updateConnectivity: connectionStatus=" + connectionStatus);
    }
    mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);
    if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {
        mBluetoothTethered = info.isConnected();
    } else {
        mBluetoothTethered = false;
    }
    // We want to update all the icons, all at once, for any condition change
    updateDataNetType();
    updateWimaxIcons();
    updateDataIcon();
    updateTelephonySignalStrength();
    updateWifiIcons();
}
#end_block

#method_before
// ===== Update the views =======================================================
void refreshViews() {
    Context context = mContext;
    int combinedSignalIconId = 0;
    int combinedActivityIconId = 0;
    String combinedLabel = "";
    String wifiLabel = "";
    String mobileLabel = "";
    int N;
    final boolean emergencyOnly = isEmergencyOnly();
    if (!mHasMobileDataFeature) {
        mDataSignalIconId = mPhoneSignalIconId = 0;
        mQSPhoneSignalIconId = 0;
        mobileLabel = "";
    } else {
        if (mDataConnected) {
            mobileLabel = mNetworkName;
        } else if (mConnected || emergencyOnly) {
            if (hasService() || emergencyOnly) {
                // The isEmergencyOnly test covers the case of a phone with no SIM
                mobileLabel = mNetworkName;
            } else {
                // Tablets, basically
                mobileLabel = "";
            }
        } else {
            mobileLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
        // Now for things that should only be shown when actually using mobile data.
        if (mDataConnected) {
            combinedSignalIconId = mDataSignalIconId;
            switch(mDataActivity) {
                case TelephonyManager.DATA_ACTIVITY_IN:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_in;
                    break;
                case TelephonyManager.DATA_ACTIVITY_OUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_out;
                    break;
                case TelephonyManager.DATA_ACTIVITY_INOUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_inout;
                    break;
                default:
                    mMobileActivityIconId = 0;
                    break;
            }
            combinedLabel = mobileLabel;
            combinedActivityIconId = mMobileActivityIconId;
            // set by updateDataIcon()
            combinedSignalIconId = mDataSignalIconId;
            mContentDescriptionCombinedSignal = mContentDescriptionDataType;
        } else {
            mMobileActivityIconId = 0;
        }
    }
    if (mWifiConnected) {
        if (mWifiSsid == null) {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_wifi_nossid);
            // no wifis, no bits
            mWifiActivityIconId = 0;
        } else {
            wifiLabel = mWifiSsid;
            if (DEBUG) {
                wifiLabel += "xxxxXXXXxxxxXXXX";
            }
            switch(mWifiActivity) {
                case WifiManager.DATA_ACTIVITY_IN:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_in;
                    break;
                case WifiManager.DATA_ACTIVITY_OUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_out;
                    break;
                case WifiManager.DATA_ACTIVITY_INOUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_inout;
                    break;
                case WifiManager.DATA_ACTIVITY_NONE:
                    mWifiActivityIconId = 0;
                    break;
            }
        }
        combinedActivityIconId = mWifiActivityIconId;
        combinedLabel = wifiLabel;
        // set by updateWifiIcons()
        combinedSignalIconId = mWifiIconId;
        mContentDescriptionCombinedSignal = mContentDescriptionWifi;
    } else {
        if (mHasMobileDataFeature) {
            wifiLabel = "";
        } else {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
    }
    if (mBluetoothTethered) {
        combinedLabel = mContext.getString(R.string.bluetooth_tethered);
        combinedSignalIconId = mBluetoothTetherIconId;
        mContentDescriptionCombinedSignal = mContext.getString(R.string.accessibility_bluetooth_tether);
    }
    final boolean ethernetConnected = (mConnectedNetworkType == ConnectivityManager.TYPE_ETHERNET);
    if (ethernetConnected) {
        combinedLabel = context.getString(R.string.ethernet_label);
    }
    if (mAirplaneMode && (mServiceState == null || (!hasService() && !mServiceState.isEmergencyOnly()))) {
        // Only display the flight-mode icon if not in "emergency calls only" mode.
        // look again; your radios are now airplanes
        mContentDescriptionPhoneSignal = mContext.getString(R.string.accessibility_airplane_mode);
        mAirplaneIconId = FLIGHT_MODE_ICON;
        mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = mQSDataTypeIconId = 0;
        mQSPhoneSignalIconId = 0;
        // combined values from connected wifi take precedence over airplane mode
        if (mWifiConnected) {
            // Suppress "No internet connection." from mobile if wifi connected.
            mobileLabel = "";
        } else {
            if (mHasMobileDataFeature) {
                // let the mobile icon show "No internet connection."
                wifiLabel = "";
            } else {
                wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
                combinedLabel = wifiLabel;
            }
            mContentDescriptionCombinedSignal = mContentDescriptionPhoneSignal;
            combinedSignalIconId = mDataSignalIconId;
        }
    } else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !ethernetConnected) {
        // pretty much totally disconnected
        combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        // On devices without mobile radios, we want to show the wifi icon
        combinedSignalIconId = mHasMobileDataFeature ? mDataSignalIconId : mWifiIconId;
        mContentDescriptionCombinedSignal = mHasMobileDataFeature ? mContentDescriptionDataType : mContentDescriptionWifi;
        mDataTypeIconId = 0;
        mQSDataTypeIconId = 0;
        if (isCdma()) {
            if (isCdmaEri()) {
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
            }
        } else if (mPhone.isNetworkRoaming()) {
            mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
            mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
        }
    }
    if (DEBUG) {
        Log.d(TAG, "refreshViews connected={" + (mWifiConnected ? " wifi" : "") + (mDataConnected ? " data" : "") + " } level=" + ((mSignalStrength == null) ? "??" : Integer.toString(mSignalStrength.getLevel())) + " combinedSignalIconId=0x" + Integer.toHexString(combinedSignalIconId) + "/" + getResourceName(combinedSignalIconId) + " combinedActivityIconId=0x" + Integer.toHexString(combinedActivityIconId) + " mobileLabel=" + mobileLabel + " wifiLabel=" + wifiLabel + " emergencyOnly=" + emergencyOnly + " combinedLabel=" + combinedLabel + " mAirplaneMode=" + mAirplaneMode + " mDataActivity=" + mDataActivity + " mPhoneSignalIconId=0x" + Integer.toHexString(mPhoneSignalIconId) + " mQSPhoneSignalIconId=0x" + Integer.toHexString(mQSPhoneSignalIconId) + " mDataDirectionIconId=0x" + Integer.toHexString(mDataDirectionIconId) + " mDataSignalIconId=0x" + Integer.toHexString(mDataSignalIconId) + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId) + " mQSDataTypeIconId=0x" + Integer.toHexString(mQSDataTypeIconId) + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId) + " mQSWifiIconId=0x" + Integer.toHexString(mQSWifiIconId) + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
    }
    // update QS
    for (NetworkSignalChangedCallback cb : mSignalsChangedCallbacks) {
        notifySignalsChangedCallbacks(cb);
    }
    if (mLastPhoneSignalIconId != mPhoneSignalIconId || mLastDataDirectionOverlayIconId != combinedActivityIconId || mLastWifiIconId != mWifiIconId || mLastWimaxIconId != mWimaxIconId || mLastDataTypeIconId != mDataTypeIconId || mLastAirplaneMode != mAirplaneMode || mLastLocale != mLocale) {
        // NB: the mLast*s will be updated later
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    }
    if (mLastAirplaneMode != mAirplaneMode) {
        mLastAirplaneMode = mAirplaneMode;
    }
    if (mLastLocale != mLocale) {
        mLastLocale = mLocale;
    }
    // the phone icon on phones
    if (mLastPhoneSignalIconId != mPhoneSignalIconId) {
        mLastPhoneSignalIconId = mPhoneSignalIconId;
        N = mPhoneSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mPhoneSignalIconViews.get(i);
            if (mPhoneSignalIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mPhoneSignalIconId);
                v.setContentDescription(mContentDescriptionPhoneSignal);
            }
        }
    }
    // the data icon on phones
    if (mLastDataDirectionIconId != mDataDirectionIconId) {
        mLastDataDirectionIconId = mDataDirectionIconId;
        N = mDataDirectionIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionIconViews.get(i);
            v.setImageResource(mDataDirectionIconId);
            v.setContentDescription(mContentDescriptionDataType);
        }
    }
    // the wifi icon on phones
    if (mLastWifiIconId != mWifiIconId) {
        mLastWifiIconId = mWifiIconId;
        N = mWifiIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWifiIconViews.get(i);
            if (mWifiIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWifiIconId);
                v.setContentDescription(mContentDescriptionWifi);
            }
        }
    }
    // the wimax icon on phones
    if (mLastWimaxIconId != mWimaxIconId) {
        mLastWimaxIconId = mWimaxIconId;
        N = mWimaxIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWimaxIconViews.get(i);
            if (mWimaxIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWimaxIconId);
                v.setContentDescription(mContentDescriptionWimax);
            }
        }
    }
    // the combined data signal icon
    if (mLastCombinedSignalIconId != combinedSignalIconId) {
        mLastCombinedSignalIconId = combinedSignalIconId;
        N = mCombinedSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mCombinedSignalIconViews.get(i);
            v.setImageResource(combinedSignalIconId);
            v.setContentDescription(mContentDescriptionCombinedSignal);
        }
    }
    // the data network type overlay
    if (mLastDataTypeIconId != mDataTypeIconId) {
        mLastDataTypeIconId = mDataTypeIconId;
        N = mDataTypeIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataTypeIconViews.get(i);
            if (mDataTypeIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mDataTypeIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the data direction overlay
    if (mLastDataDirectionOverlayIconId != combinedActivityIconId) {
        if (DEBUG) {
            Log.d(TAG, "changing data overlay icon id to " + combinedActivityIconId);
        }
        mLastDataDirectionOverlayIconId = combinedActivityIconId;
        N = mDataDirectionOverlayIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionOverlayIconViews.get(i);
            if (combinedActivityIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(combinedActivityIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the combinedLabel in the notification panel
    if (!mLastCombinedLabel.equals(combinedLabel)) {
        mLastCombinedLabel = combinedLabel;
        N = mCombinedLabelViews.size();
        for (int i = 0; i < N; i++) {
            TextView v = mCombinedLabelViews.get(i);
            v.setText(combinedLabel);
        }
    }
    // wifi label
    N = mWifiLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mWifiLabelViews.get(i);
        v.setText(wifiLabel);
        if ("".equals(wifiLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // mobile label
    N = mMobileLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mMobileLabelViews.get(i);
        v.setText(mobileLabel);
        if ("".equals(mobileLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // e-call label
    N = mEmergencyLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mEmergencyLabelViews.get(i);
        if (!emergencyOnly) {
            v.setVisibility(View.GONE);
        } else {
            // comes from the telephony stack
            v.setText(mobileLabel);
            v.setVisibility(View.VISIBLE);
        }
    }
}
#method_after
// ===== Update the views =======================================================
void refreshViews() {
    Context context = mContext;
    int combinedSignalIconId = 0;
    int combinedActivityIconId = 0;
    String combinedLabel = "";
    String wifiLabel = "";
    String mobileLabel = "";
    int N;
    final boolean emergencyOnly = isEmergencyOnly();
    if (!mHasMobileDataFeature) {
        mDataSignalIconId = mPhoneSignalIconId = 0;
        mQSPhoneSignalIconId = 0;
        mobileLabel = "";
    } else {
        if (mDataConnected) {
            mobileLabel = mNetworkName;
        } else if (mConnected || emergencyOnly) {
            if (hasService() || emergencyOnly) {
                // The isEmergencyOnly test covers the case of a phone with no SIM
                mobileLabel = mNetworkName;
            } else {
                // Tablets, basically
                mobileLabel = "";
            }
        } else {
            mobileLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
        // Now for things that should only be shown when actually using mobile data.
        if (mDataConnected) {
            combinedSignalIconId = mDataSignalIconId;
            switch(mDataActivity) {
                case TelephonyManager.DATA_ACTIVITY_IN:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_in;
                    break;
                case TelephonyManager.DATA_ACTIVITY_OUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_out;
                    break;
                case TelephonyManager.DATA_ACTIVITY_INOUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_inout;
                    break;
                default:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_noinout;
                    break;
            }
            combinedLabel = mobileLabel;
            combinedActivityIconId = mMobileActivityIconId;
            // set by updateDataIcon()
            combinedSignalIconId = mDataSignalIconId;
            mContentDescriptionCombinedSignal = mContentDescriptionDataType;
        } else {
            mMobileActivityIconId = 0;
        }
    }
    if (mWifiConnected) {
        if (mWifiSsid == null) {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_wifi_nossid);
            // no wifis, no bits
            mWifiActivityIconId = 0;
        } else {
            wifiLabel = mWifiSsid;
            if (DEBUG) {
                wifiLabel += "xxxxXXXXxxxxXXXX";
            }
            switch(mWifiActivity) {
                case WifiManager.DATA_ACTIVITY_IN:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_in;
                    break;
                case WifiManager.DATA_ACTIVITY_OUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_out;
                    break;
                case WifiManager.DATA_ACTIVITY_INOUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_inout;
                    break;
                case WifiManager.DATA_ACTIVITY_NONE:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_noinout;
                    break;
            }
        }
        combinedActivityIconId = mWifiActivityIconId;
        combinedLabel = wifiLabel;
        // set by updateWifiIcons()
        combinedSignalIconId = mWifiIconId;
        mContentDescriptionCombinedSignal = mContentDescriptionWifi;
    } else {
        if (mHasMobileDataFeature) {
            wifiLabel = "";
        } else {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
    }
    if (mBluetoothTethered) {
        combinedLabel = mContext.getString(R.string.bluetooth_tethered);
        combinedSignalIconId = mBluetoothTetherIconId;
        mContentDescriptionCombinedSignal = mContext.getString(R.string.accessibility_bluetooth_tether);
    }
    final boolean ethernetConnected = (mConnectedNetworkType == ConnectivityManager.TYPE_ETHERNET);
    if (ethernetConnected) {
        combinedLabel = context.getString(R.string.ethernet_label);
    }
    if (mAirplaneMode && (mServiceState == null || (!hasService() && !mServiceState.isEmergencyOnly()))) {
        // Only display the flight-mode icon if not in "emergency calls only" mode.
        // look again; your radios are now airplanes
        mContentDescriptionPhoneSignal = mContext.getString(R.string.accessibility_airplane_mode);
        mAirplaneIconId = FLIGHT_MODE_ICON;
        mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = mQSDataTypeIconId = 0;
        mQSPhoneSignalIconId = 0;
        mNoSimIconId = 0;
        // combined values from connected wifi take precedence over airplane mode
        if (mWifiConnected) {
            // Suppress "No internet connection." from mobile if wifi connected.
            mobileLabel = "";
        } else {
            if (mHasMobileDataFeature) {
                // let the mobile icon show "No internet connection."
                wifiLabel = "";
            } else {
                wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
                combinedLabel = wifiLabel;
            }
            mContentDescriptionCombinedSignal = mContentDescriptionPhoneSignal;
            combinedSignalIconId = mDataSignalIconId;
        }
    } else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !ethernetConnected) {
        // pretty much totally disconnected
        combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        // On devices without mobile radios, we want to show the wifi icon
        combinedSignalIconId = mHasMobileDataFeature ? mDataSignalIconId : mWifiIconId;
        mContentDescriptionCombinedSignal = mHasMobileDataFeature ? mContentDescriptionDataType : mContentDescriptionWifi;
    }
    if (!mDataConnected) {
        mDataTypeIconId = 0;
        mQSDataTypeIconId = 0;
        if (isCdma()) {
            if (isCdmaEri()) {
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
            }
        } else if (mPhone.isNetworkRoaming()) {
            mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
            mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
        }
    }
    if (!mAirplaneMode && mSimState == IccCardConstants.State.ABSENT) {
        // look again; your radios are now sim cards
        mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = mQSDataTypeIconId = 0;
        mQSPhoneSignalIconId = 0;
    }
    if (DEBUG) {
        Log.d(TAG, "refreshViews connected={" + (mWifiConnected ? " wifi" : "") + (mDataConnected ? " data" : "") + " } level=" + ((mSignalStrength == null) ? "??" : Integer.toString(mSignalStrength.getLevel())) + " combinedSignalIconId=0x" + Integer.toHexString(combinedSignalIconId) + "/" + getResourceName(combinedSignalIconId) + " combinedActivityIconId=0x" + Integer.toHexString(combinedActivityIconId) + " mobileLabel=" + mobileLabel + " wifiLabel=" + wifiLabel + " emergencyOnly=" + emergencyOnly + " combinedLabel=" + combinedLabel + " mAirplaneMode=" + mAirplaneMode + " mDataActivity=" + mDataActivity + " mPhoneSignalIconId=0x" + Integer.toHexString(mPhoneSignalIconId) + " mQSPhoneSignalIconId=0x" + Integer.toHexString(mQSPhoneSignalIconId) + " mDataDirectionIconId=0x" + Integer.toHexString(mDataDirectionIconId) + " mDataSignalIconId=0x" + Integer.toHexString(mDataSignalIconId) + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId) + " mQSDataTypeIconId=0x" + Integer.toHexString(mQSDataTypeIconId) + " mNoSimIconId=0x" + Integer.toHexString(mNoSimIconId) + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId) + " mQSWifiIconId=0x" + Integer.toHexString(mQSWifiIconId) + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
    }
    // update QS
    for (NetworkSignalChangedCallback cb : mSignalsChangedCallbacks) {
        notifySignalsChangedCallbacks(cb);
    }
    for (SignalStrengthChangedCallback cb : mSignalStrengthChangedCallbacks) {
        notifySignalStrengthChangedCallbacks(cb);
    }
    if (mLastPhoneSignalIconId != mPhoneSignalIconId || mLastDataDirectionOverlayIconId != combinedActivityIconId || mLastWifiIconId != mWifiIconId || mLastWimaxIconId != mWimaxIconId || mLastDataTypeIconId != mDataTypeIconId || mLastAirplaneMode != mAirplaneMode || mLastLocale != mLocale || mLastSimIconId != mNoSimIconId) {
        // NB: the mLast*s will be updated later
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    }
    if (mLastAirplaneMode != mAirplaneMode) {
        mLastAirplaneMode = mAirplaneMode;
    }
    if (mLastLocale != mLocale) {
        mLastLocale = mLocale;
    }
    // the phone icon on phones
    if (mLastPhoneSignalIconId != mPhoneSignalIconId) {
        mLastPhoneSignalIconId = mPhoneSignalIconId;
        N = mPhoneSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mPhoneSignalIconViews.get(i);
            if (mPhoneSignalIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mPhoneSignalIconId);
                v.setContentDescription(mContentDescriptionPhoneSignal);
            }
        }
    }
    // the data icon on phones
    if (mLastDataDirectionIconId != mDataDirectionIconId) {
        mLastDataDirectionIconId = mDataDirectionIconId;
        N = mDataDirectionIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionIconViews.get(i);
            v.setImageResource(mDataDirectionIconId);
            v.setContentDescription(mContentDescriptionDataType);
        }
    }
    if (mLastSimIconId != mNoSimIconId) {
        mLastSimIconId = mNoSimIconId;
    }
    // the wifi icon on phones
    if (mLastWifiIconId != mWifiIconId) {
        mLastWifiIconId = mWifiIconId;
        N = mWifiIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWifiIconViews.get(i);
            if (mWifiIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWifiIconId);
                v.setContentDescription(mContentDescriptionWifi);
            }
        }
    }
    // the wimax icon on phones
    if (mLastWimaxIconId != mWimaxIconId) {
        mLastWimaxIconId = mWimaxIconId;
        N = mWimaxIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWimaxIconViews.get(i);
            if (mWimaxIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWimaxIconId);
                v.setContentDescription(mContentDescriptionWimax);
            }
        }
    }
    // the combined data signal icon
    if (mLastCombinedSignalIconId != combinedSignalIconId) {
        mLastCombinedSignalIconId = combinedSignalIconId;
        N = mCombinedSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mCombinedSignalIconViews.get(i);
            v.setImageResource(combinedSignalIconId);
            v.setContentDescription(mContentDescriptionCombinedSignal);
        }
    }
    // the data network type overlay
    if (mLastDataTypeIconId != mDataTypeIconId) {
        mLastDataTypeIconId = mDataTypeIconId;
        N = mDataTypeIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataTypeIconViews.get(i);
            if (mDataTypeIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mDataTypeIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the data direction overlay
    if (mLastDataDirectionOverlayIconId != combinedActivityIconId) {
        if (DEBUG) {
            Log.d(TAG, "changing data overlay icon id to " + combinedActivityIconId);
        }
        mLastDataDirectionOverlayIconId = combinedActivityIconId;
        N = mDataDirectionOverlayIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionOverlayIconViews.get(i);
            if (combinedActivityIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(combinedActivityIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the combinedLabel in the notification panel
    if (!mLastCombinedLabel.equals(combinedLabel)) {
        mLastCombinedLabel = combinedLabel;
        N = mCombinedLabelViews.size();
        for (int i = 0; i < N; i++) {
            TextView v = mCombinedLabelViews.get(i);
            v.setText(combinedLabel);
        }
    }
    // wifi label
    N = mWifiLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mWifiLabelViews.get(i);
        v.setText(wifiLabel);
        if ("".equals(wifiLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // mobile label
    N = mMobileLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mMobileLabelViews.get(i);
        v.setText(mobileLabel);
        if ("".equals(mobileLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // e-call label
    N = mEmergencyLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mEmergencyLabelViews.get(i);
        if (!emergencyOnly) {
            v.setVisibility(View.GONE);
        } else {
            // comes from the telephony stack
            v.setText(mobileLabel);
            v.setVisibility(View.VISIBLE);
        }
    }
    // Update the dependency UI
    if (mUpdateUIListener != null) {
        mUpdateUIListener.onUpdateUI();
    }
}
#end_block

#method_before
private String getResourceName(int resId) {
    if (resId != 0) {
        final Resources res = mContext.getResources();
        try {
            return res.getResourceName(resId);
        } catch (android.content.res.Resources.NotFoundException ex) {
            return "(unknown)";
        }
    } else {
        return "(null)";
    }
}
#method_after
protected String getResourceName(int resId) {
    if (resId != 0) {
        final Resources res = mContext.getResources();
        try {
            return res.getResourceName(resId);
        } catch (android.content.res.Resources.NotFoundException ex) {
            return "(unknown)";
        }
    } else {
        return "(null)";
    }
}
#end_block

#method_before
@Override
public void dispatchDemoCommand(String command, Bundle args) {
    if (!mDemoMode && command.equals(COMMAND_ENTER)) {
        mDemoMode = true;
        mDemoWifiLevel = mWifiLevel;
        mDemoInetCondition = mInetCondition;
        mDemoDataTypeIconId = mDataTypeIconId;
        mDemoMobileLevel = mLastSignalLevel;
    } else if (mDemoMode && command.equals(COMMAND_EXIT)) {
        mDemoMode = false;
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    } else if (mDemoMode && command.equals(COMMAND_NETWORK)) {
        String airplane = args.getString("airplane");
        if (airplane != null) {
            boolean show = airplane.equals("show");
            for (SignalCluster cluster : mSignalClusters) {
                cluster.setIsAirplaneMode(show, FLIGHT_MODE_ICON);
            }
        }
        String fully = args.getString("fully");
        if (fully != null) {
            mDemoInetCondition = Boolean.parseBoolean(fully) ? 1 : 0;
        }
        String wifi = args.getString("wifi");
        if (wifi != null) {
            boolean show = wifi.equals("show");
            String level = args.getString("level");
            if (level != null) {
                mDemoWifiLevel = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), WifiIcons.WIFI_LEVEL_COUNT - 1);
            }
            int iconId = mDemoWifiLevel < 0 ? R.drawable.stat_sys_wifi_signal_null : WifiIcons.WIFI_SIGNAL_STRENGTH[mDemoInetCondition][mDemoWifiLevel];
            for (SignalCluster cluster : mSignalClusters) {
                cluster.setWifiIndicators(show, iconId, mWifiActivityIconId, "Demo");
            }
        }
        String mobile = args.getString("mobile");
        if (mobile != null) {
            boolean show = mobile.equals("show");
            String datatype = args.getString("datatype");
            if (datatype != null) {
                mDemoDataTypeIconId = datatype.equals("1x") ? R.drawable.stat_sys_data_fully_connected_1x : datatype.equals("3g") ? R.drawable.stat_sys_data_fully_connected_3g : datatype.equals("4g") ? R.drawable.stat_sys_data_fully_connected_4g : datatype.equals("e") ? R.drawable.stat_sys_data_fully_connected_e : datatype.equals("g") ? R.drawable.stat_sys_data_fully_connected_g : datatype.equals("h") ? R.drawable.stat_sys_data_fully_connected_h : datatype.equals("lte") ? R.drawable.stat_sys_data_fully_connected_lte : datatype.equals("roam") ? R.drawable.stat_sys_data_fully_connected_roam : 0;
            }
            int[][] icons = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
            String level = args.getString("level");
            if (level != null) {
                mDemoMobileLevel = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), icons[0].length - 1);
            }
            int iconId = mDemoMobileLevel < 0 ? R.drawable.stat_sys_signal_null : icons[mDemoInetCondition][mDemoMobileLevel];
            for (SignalCluster cluster : mSignalClusters) {
                cluster.setMobileDataIndicators(show, iconId, mMobileActivityIconId, mDemoDataTypeIconId, "Demo", "Demo");
            }
        }
    }
}
#method_after
@Override
public void dispatchDemoCommand(String command, Bundle args) {
    if (!mDemoMode && command.equals(COMMAND_ENTER)) {
        mDemoMode = true;
        mDemoWifiLevel = mWifiLevel;
        mDemoInetCondition = mInetCondition;
        mDemoDataTypeIconId = mDataTypeIconId;
        mDemoMobileLevel = mLastSignalLevel;
    } else if (mDemoMode && command.equals(COMMAND_EXIT)) {
        mDemoMode = false;
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    } else if (mDemoMode && command.equals(COMMAND_NETWORK)) {
        String airplane = args.getString("airplane");
        if (airplane != null) {
            boolean show = airplane.equals("show");
            for (SignalCluster cluster : mSignalClusters) {
                cluster.setIsAirplaneMode(show, FLIGHT_MODE_ICON);
            }
        }
        String fully = args.getString("fully");
        if (fully != null) {
            mDemoInetCondition = Boolean.parseBoolean(fully) ? 1 : 0;
        }
        String wifi = args.getString("wifi");
        if (wifi != null) {
            boolean show = wifi.equals("show");
            String level = args.getString("level");
            if (level != null) {
                mDemoWifiLevel = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), WifiIcons.WIFI_LEVEL_COUNT - 1);
            }
            int iconId = mDemoWifiLevel < 0 ? R.drawable.stat_sys_wifi_signal_null : WifiIcons.WIFI_SIGNAL_STRENGTH[mDemoInetCondition][mDemoWifiLevel];
            for (SignalCluster cluster : mSignalClusters) {
                cluster.setWifiIndicators(show, iconId, mWifiActivityIconId, "Demo");
            }
        }
        String mobile = args.getString("mobile");
        if (mobile != null) {
            boolean show = mobile.equals("show");
            String datatype = args.getString("datatype");
            if (datatype != null) {
                mDemoDataTypeIconId = datatype.equals("1x") ? R.drawable.stat_sys_data_fully_connected_1x : datatype.equals("3g") ? R.drawable.stat_sys_data_fully_connected_3g : datatype.equals("4g") ? R.drawable.stat_sys_data_fully_connected_4g : datatype.equals("e") ? R.drawable.stat_sys_data_fully_connected_e : datatype.equals("g") ? R.drawable.stat_sys_data_fully_connected_g : datatype.equals("h") ? R.drawable.stat_sys_data_fully_connected_h : datatype.equals("lte") ? R.drawable.stat_sys_data_fully_connected_lte : datatype.equals("roam") ? R.drawable.stat_sys_data_fully_connected_roam : 0;
            }
            int[][] icons = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
            String level = args.getString("level");
            if (level != null) {
                mDemoMobileLevel = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), icons[0].length - 1);
            }
            int iconId = mDemoMobileLevel < 0 ? R.drawable.stat_sys_signal_null : icons[mDemoInetCondition][mDemoMobileLevel];
            for (SignalCluster cluster : mSignalClusters) {
                cluster.setMobileDataIndicators(show, iconId, mMobileActivityIconId, mDemoDataTypeIconId, "Demo", "Demo", mNoSimIconId);
            }
        }
    }
}
#end_block

#method_before
public static int getPhoneType(int networkMode) {
    switch(networkMode) {
        case RILConstants.NETWORK_MODE_CDMA:
        case RILConstants.NETWORK_MODE_CDMA_NO_EVDO:
        case RILConstants.NETWORK_MODE_EVDO_NO_CDMA:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_WCDMA_PREF:
        case RILConstants.NETWORK_MODE_GSM_ONLY:
        case RILConstants.NETWORK_MODE_WCDMA_ONLY:
        case RILConstants.NETWORK_MODE_GSM_UMTS:
        case RILConstants.NETWORK_MODE_LTE_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
            return PhoneConstants.PHONE_TYPE_GSM;
        // Use CDMA Phone for the global mode including CDMA
        case RILConstants.NETWORK_MODE_GLOBAL:
        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_LTE_ONLY:
            if (getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                return PhoneConstants.PHONE_TYPE_CDMA;
            } else {
                return PhoneConstants.PHONE_TYPE_GSM;
            }
        default:
            return PhoneConstants.PHONE_TYPE_GSM;
    }
}
#method_after
public static int getPhoneType(int networkMode) {
    switch(networkMode) {
        case RILConstants.NETWORK_MODE_CDMA:
        case RILConstants.NETWORK_MODE_CDMA_NO_EVDO:
        case RILConstants.NETWORK_MODE_EVDO_NO_CDMA:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_WCDMA_PREF:
        case RILConstants.NETWORK_MODE_GSM_ONLY:
        case RILConstants.NETWORK_MODE_WCDMA_ONLY:
        case RILConstants.NETWORK_MODE_GSM_UMTS:
        case RILConstants.NETWORK_MODE_LTE_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_WCDMA:
        case RILConstants.NETWORK_MODE_TD_SCDMA_ONLY:
        case RILConstants.NETWORK_MODE_TD_SCDMA_WCDMA:
        case RILConstants.NETWORK_MODE_TD_SCDMA_LTE:
        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM:
        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM_LTE:
        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_TD_SCDMA_WCDMA_LTE:
        case RILConstants.NETWORK_MODE_TD_SCDMA_GSM_WCDMA_LTE:
            return PhoneConstants.PHONE_TYPE_GSM;
        // Use CDMA Phone for the global mode including CDMA
        case RILConstants.NETWORK_MODE_GLOBAL:
        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO:
        case RILConstants.NETWORK_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_TD_SCDMA_CDMA_EVDO_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_TD_SCDMA_LTE_CDMA_EVDO_GSM_WCDMA:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_LTE_ONLY:
            if (getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                return PhoneConstants.PHONE_TYPE_CDMA;
            } else {
                return PhoneConstants.PHONE_TYPE_GSM;
            }
        default:
            return PhoneConstants.PHONE_TYPE_GSM;
    }
}
#end_block

#method_before
// 
// 
// Current Network
// 
// 
public String getNetworkOperatorName() {
    return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
}
#method_after
// 
// 
// Current Network
// 
// 
public String getNetworkOperatorName() {
    return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA, getDefaultSubscription(), "");
}
#end_block

#method_before
public String getNetworkOperator() {
    return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC);
}
#method_after
public String getNetworkOperator() {
    return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC, getDefaultSubscription(), "");
}
#end_block

#method_before
public boolean isNetworkRoaming() {
    return "true".equals(SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ISROAMING));
}
#method_after
public boolean isNetworkRoaming() {
    return "true".equals(getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ISROAMING, getDefaultSubscription(), "false"));
}
#end_block

#method_before
public String getNetworkCountryIso() {
    return SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY);
}
#method_after
public String getNetworkCountryIso() {
    return getTelephonyProperty(TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY, getDefaultSubscription(), "");
}
#end_block

#method_before
public static int getNetworkClass(int networkType) {
    switch(networkType) {
        case NETWORK_TYPE_GPRS:
        case NETWORK_TYPE_EDGE:
        case NETWORK_TYPE_CDMA:
        case NETWORK_TYPE_1xRTT:
        case NETWORK_TYPE_IDEN:
            return NETWORK_CLASS_2_G;
        case NETWORK_TYPE_UMTS:
        case NETWORK_TYPE_EVDO_0:
        case NETWORK_TYPE_EVDO_A:
        case NETWORK_TYPE_HSDPA:
        case NETWORK_TYPE_HSUPA:
        case NETWORK_TYPE_HSPA:
        case NETWORK_TYPE_EVDO_B:
        case NETWORK_TYPE_EHRPD:
        case NETWORK_TYPE_HSPAP:
        case NETWORK_TYPE_DCHSPAP:
            return NETWORK_CLASS_3_G;
        case NETWORK_TYPE_LTE:
            return NETWORK_CLASS_4_G;
        default:
            return NETWORK_CLASS_UNKNOWN;
    }
}
#method_after
public static int getNetworkClass(int networkType) {
    switch(networkType) {
        case NETWORK_TYPE_GPRS:
        case NETWORK_TYPE_GSM:
        case NETWORK_TYPE_EDGE:
        case NETWORK_TYPE_CDMA:
        case NETWORK_TYPE_1xRTT:
        case NETWORK_TYPE_IDEN:
            return NETWORK_CLASS_2_G;
        case NETWORK_TYPE_UMTS:
        case NETWORK_TYPE_EVDO_0:
        case NETWORK_TYPE_EVDO_A:
        case NETWORK_TYPE_HSDPA:
        case NETWORK_TYPE_HSUPA:
        case NETWORK_TYPE_HSPA:
        case NETWORK_TYPE_EVDO_B:
        case NETWORK_TYPE_EHRPD:
        case NETWORK_TYPE_HSPAP:
        case NETWORK_TYPE_TD_SCDMA:
        case NETWORK_TYPE_DCHSPAP:
            return NETWORK_CLASS_3_G;
        case NETWORK_TYPE_LTE:
        case NETWORK_TYPE_IWLAN:
            return NETWORK_CLASS_4_G;
        default:
            return NETWORK_CLASS_UNKNOWN;
    }
}
#end_block

#method_before
public static String getNetworkTypeName(int type) {
    switch(type) {
        case NETWORK_TYPE_GPRS:
            return "GPRS";
        case NETWORK_TYPE_EDGE:
            return "EDGE";
        case NETWORK_TYPE_UMTS:
            return "UMTS";
        case NETWORK_TYPE_HSDPA:
            return "HSDPA";
        case NETWORK_TYPE_HSUPA:
            return "HSUPA";
        case NETWORK_TYPE_HSPA:
            return "HSPA";
        case NETWORK_TYPE_CDMA:
            return "CDMA";
        case NETWORK_TYPE_EVDO_0:
            return "CDMA - EvDo rev. 0";
        case NETWORK_TYPE_EVDO_A:
            return "CDMA - EvDo rev. A";
        case NETWORK_TYPE_EVDO_B:
            return "CDMA - EvDo rev. B";
        case NETWORK_TYPE_1xRTT:
            return "CDMA - 1xRTT";
        case NETWORK_TYPE_LTE:
            return "LTE";
        case NETWORK_TYPE_EHRPD:
            return "CDMA - eHRPD";
        case NETWORK_TYPE_IDEN:
            return "iDEN";
        case NETWORK_TYPE_HSPAP:
            return "HSPA+";
        case NETWORK_TYPE_DCHSPAP:
            return "DC-HSPA+";
        default:
            return "UNKNOWN";
    }
}
#method_after
public static String getNetworkTypeName(int type) {
    switch(type) {
        case NETWORK_TYPE_GPRS:
            return "GPRS";
        case NETWORK_TYPE_EDGE:
            return "EDGE";
        case NETWORK_TYPE_UMTS:
            return "UMTS";
        case NETWORK_TYPE_HSDPA:
            return "HSDPA";
        case NETWORK_TYPE_HSUPA:
            return "HSUPA";
        case NETWORK_TYPE_HSPA:
            return "HSPA";
        case NETWORK_TYPE_CDMA:
            return "CDMA";
        case NETWORK_TYPE_EVDO_0:
            return "CDMA - EvDo rev. 0";
        case NETWORK_TYPE_EVDO_A:
            return "CDMA - EvDo rev. A";
        case NETWORK_TYPE_EVDO_B:
            return "CDMA - EvDo rev. B";
        case NETWORK_TYPE_1xRTT:
            return "CDMA - 1xRTT";
        case NETWORK_TYPE_LTE:
            return "LTE";
        case NETWORK_TYPE_EHRPD:
            return "CDMA - eHRPD";
        case NETWORK_TYPE_IDEN:
            return "iDEN";
        case NETWORK_TYPE_HSPAP:
            return "HSPA+";
        case NETWORK_TYPE_GSM:
            return "GSM";
        case NETWORK_TYPE_TD_SCDMA:
            return "TD-SCDMA";
        case NETWORK_TYPE_IWLAN:
            return "IWLAN";
        case NETWORK_TYPE_DCHSPAP:
            return "DC-HSPA+";
        default:
            return "UNKNOWN";
    }
}
#end_block

#method_before
public int getSimState() {
    String prop = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
    if ("ABSENT".equals(prop)) {
        return SIM_STATE_ABSENT;
    } else if ("PIN_REQUIRED".equals(prop)) {
        return SIM_STATE_PIN_REQUIRED;
    } else if ("PUK_REQUIRED".equals(prop)) {
        return SIM_STATE_PUK_REQUIRED;
    } else if ("NETWORK_LOCKED".equals(prop)) {
        return SIM_STATE_NETWORK_LOCKED;
    } else if ("READY".equals(prop)) {
        return SIM_STATE_READY;
    } else {
        return SIM_STATE_UNKNOWN;
    }
}
#method_after
public int getSimState() {
    String prop = getTelephonyProperty(TelephonyProperties.PROPERTY_SIM_STATE, getDefaultSubscription(), "");
    if ("ABSENT".equals(prop)) {
        return SIM_STATE_ABSENT;
    } else if ("PIN_REQUIRED".equals(prop)) {
        return SIM_STATE_PIN_REQUIRED;
    } else if ("PUK_REQUIRED".equals(prop)) {
        return SIM_STATE_PUK_REQUIRED;
    } else if ("PERSO_LOCKED".equals(prop)) {
        return SIM_STATE_NETWORK_LOCKED;
    } else if ("READY".equals(prop)) {
        return SIM_STATE_READY;
    } else if ("CARD_IO_ERROR".equals(prop)) {
        return SIM_STATE_CARD_IO_ERROR;
    } else {
        return SIM_STATE_UNKNOWN;
    }
}
#end_block

#method_before
public String getSimOperator() {
    return SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC);
}
#method_after
public String getSimOperator() {
    return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC, getDefaultSubscription(), "");
}
#end_block

#method_before
public String getSimOperatorName() {
    return SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA);
}
#method_after
public String getSimOperatorName() {
    return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA, getDefaultSubscription(), "");
}
#end_block

#method_before
public String getSimCountryIso() {
    return SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY);
}
#method_after
public String getSimCountryIso() {
    return getTelephonyProperty(TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY, getDefaultSubscription(), "");
}
#end_block

#method_before
public boolean isSmsCapable() {
    if (mContext == null)
        return true;
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_sms_capable);
}
#method_after
public boolean isSmsCapable() {
    if (!SystemProperties.getBoolean(TelephonyProperties.PROPERTY_SMS_RECEIVE, true) && !SystemProperties.getBoolean(TelephonyProperties.PROPERTY_SMS_SEND, true)) {
        return false;
    }
    if (mContext == null)
        return true;
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_sms_capable);
}
#end_block

#method_before
public static String rilRadioTechnologyToString(int rt) {
    String rtString;
    switch(rt) {
        case RIL_RADIO_TECHNOLOGY_UNKNOWN:
            rtString = "Unknown";
            break;
        case RIL_RADIO_TECHNOLOGY_GPRS:
            rtString = "GPRS";
            break;
        case RIL_RADIO_TECHNOLOGY_EDGE:
            rtString = "EDGE";
            break;
        case RIL_RADIO_TECHNOLOGY_UMTS:
            rtString = "UMTS";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95A:
            rtString = "CDMA-IS95A";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95B:
            rtString = "CDMA-IS95B";
            break;
        case RIL_RADIO_TECHNOLOGY_1xRTT:
            rtString = "1xRTT";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_0:
            rtString = "EvDo-rev.0";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_A:
            rtString = "EvDo-rev.A";
            break;
        case RIL_RADIO_TECHNOLOGY_HSDPA:
            rtString = "HSDPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSUPA:
            rtString = "HSUPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPA:
            rtString = "HSPA";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_B:
            rtString = "EvDo-rev.B";
            break;
        case RIL_RADIO_TECHNOLOGY_EHRPD:
            rtString = "eHRPD";
            break;
        case RIL_RADIO_TECHNOLOGY_LTE:
            rtString = "LTE";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPAP:
            rtString = "HSPA+";
            break;
        case RIL_RADIO_TECHNOLOGY_DCHSPAP:
            rtString = "DC-HSPA+";
            break;
        case RIL_RADIO_TECHNOLOGY_GSM:
            rtString = "GSM";
            break;
        default:
            rtString = "Unexpected";
            Rlog.w(LOG_TAG, "Unexpected radioTechnology=" + rt);
            break;
    }
    return rtString;
}
#method_after
public static String rilRadioTechnologyToString(int rt) {
    String rtString;
    switch(rt) {
        case RIL_RADIO_TECHNOLOGY_UNKNOWN:
            rtString = "Unknown";
            break;
        case RIL_RADIO_TECHNOLOGY_GPRS:
            rtString = "GPRS";
            break;
        case RIL_RADIO_TECHNOLOGY_EDGE:
            rtString = "EDGE";
            break;
        case RIL_RADIO_TECHNOLOGY_UMTS:
            rtString = "UMTS";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95A:
            rtString = "CDMA-IS95A";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95B:
            rtString = "CDMA-IS95B";
            break;
        case RIL_RADIO_TECHNOLOGY_1xRTT:
            rtString = "1xRTT";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_0:
            rtString = "EvDo-rev.0";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_A:
            rtString = "EvDo-rev.A";
            break;
        case RIL_RADIO_TECHNOLOGY_HSDPA:
            rtString = "HSDPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSUPA:
            rtString = "HSUPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPA:
            rtString = "HSPA";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_B:
            rtString = "EvDo-rev.B";
            break;
        case RIL_RADIO_TECHNOLOGY_EHRPD:
            rtString = "eHRPD";
            break;
        case RIL_RADIO_TECHNOLOGY_LTE:
            rtString = "LTE";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPAP:
            rtString = "HSPA+";
            break;
        case RIL_RADIO_TECHNOLOGY_DCHSPAP:
            rtString = "DC-HSPA+";
            break;
        case RIL_RADIO_TECHNOLOGY_GSM:
            rtString = "GSM";
            break;
        case RIL_RADIO_TECHNOLOGY_TD_SCDMA:
            rtString = "TD-SCDMA";
            break;
        case RIL_RADIO_TECHNOLOGY_IWLAN:
            rtString = "IWLAN";
            break;
        default:
            rtString = "Unexpected";
            Rlog.w(LOG_TAG, "Unexpected radioTechnology=" + rt);
            break;
    }
    return rtString;
}
#end_block

#method_before
private int rilRadioTechnologyToNetworkType(int rt) {
    switch(rt) {
        case ServiceState.RIL_RADIO_TECHNOLOGY_GPRS:
            return TelephonyManager.NETWORK_TYPE_GPRS;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EDGE:
            return TelephonyManager.NETWORK_TYPE_EDGE;
        case ServiceState.RIL_RADIO_TECHNOLOGY_UMTS:
            return TelephonyManager.NETWORK_TYPE_UMTS;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSDPA:
            return TelephonyManager.NETWORK_TYPE_HSDPA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSUPA:
            return TelephonyManager.NETWORK_TYPE_HSUPA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSPA:
            return TelephonyManager.NETWORK_TYPE_HSPA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_IS95A:
        case ServiceState.RIL_RADIO_TECHNOLOGY_IS95B:
            return TelephonyManager.NETWORK_TYPE_CDMA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT:
            return TelephonyManager.NETWORK_TYPE_1xRTT;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_0:
            return TelephonyManager.NETWORK_TYPE_EVDO_0;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A:
            return TelephonyManager.NETWORK_TYPE_EVDO_A;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_B:
            return TelephonyManager.NETWORK_TYPE_EVDO_B;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD:
            return TelephonyManager.NETWORK_TYPE_EHRPD;
        case ServiceState.RIL_RADIO_TECHNOLOGY_LTE:
            return TelephonyManager.NETWORK_TYPE_LTE;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP:
            return TelephonyManager.NETWORK_TYPE_HSPAP;
        case ServiceState.RIL_RADIO_TECHNOLOGY_DCHSPAP:
            return TelephonyManager.NETWORK_TYPE_DCHSPAP;
        default:
            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
private int rilRadioTechnologyToNetworkType(int rt) {
    switch(rt) {
        case ServiceState.RIL_RADIO_TECHNOLOGY_GPRS:
            return TelephonyManager.NETWORK_TYPE_GPRS;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EDGE:
            return TelephonyManager.NETWORK_TYPE_EDGE;
        case ServiceState.RIL_RADIO_TECHNOLOGY_UMTS:
            return TelephonyManager.NETWORK_TYPE_UMTS;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSDPA:
            return TelephonyManager.NETWORK_TYPE_HSDPA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSUPA:
            return TelephonyManager.NETWORK_TYPE_HSUPA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSPA:
            return TelephonyManager.NETWORK_TYPE_HSPA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_IS95A:
        case ServiceState.RIL_RADIO_TECHNOLOGY_IS95B:
            return TelephonyManager.NETWORK_TYPE_CDMA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT:
            return TelephonyManager.NETWORK_TYPE_1xRTT;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_0:
            return TelephonyManager.NETWORK_TYPE_EVDO_0;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A:
            return TelephonyManager.NETWORK_TYPE_EVDO_A;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_B:
            return TelephonyManager.NETWORK_TYPE_EVDO_B;
        case ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD:
            return TelephonyManager.NETWORK_TYPE_EHRPD;
        case ServiceState.RIL_RADIO_TECHNOLOGY_LTE:
            return TelephonyManager.NETWORK_TYPE_LTE;
        case ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP:
            return TelephonyManager.NETWORK_TYPE_HSPAP;
        case ServiceState.RIL_RADIO_TECHNOLOGY_GSM:
            return TelephonyManager.NETWORK_TYPE_GSM;
        case ServiceState.RIL_RADIO_TECHNOLOGY_TD_SCDMA:
            return TelephonyManager.NETWORK_TYPE_TD_SCDMA;
        case ServiceState.RIL_RADIO_TECHNOLOGY_DCHSPAP:
            return TelephonyManager.NETWORK_TYPE_DCHSPAP;
        default:
            return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
public static boolean isGsm(int radioTechnology) {
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_DCHSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM;
}
#method_after
public static boolean isGsm(int radioTechnology) {
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_DCHSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM || radioTechnology == RIL_RADIO_TECHNOLOGY_TD_SCDMA || radioTechnology == RIL_RADIO_TECHNOLOGY_IWLAN;
}
#end_block

