313
#method_before
@GET
public V3VMs list() {
    V3VMs vms = adaptList(getDelegate()::list);
    vms.getVMs().stream().forEach(vm -> V3VmHelper.addDisksLink(vm));
    return vms;
}
#method_after
@GET
public V3VMs list() {
    V3VMs vms = adaptList(getDelegate()::list);
    vms.getVMs().stream().forEach(V3VmHelper::addDisksLink);
    return vms;
}
#end_block

#method_before
public static Response addDisksLinkToResponse(Response response) {
    if (response.getEntity() != null) {
        V3VM vm = (V3VM) response.getEntity();
        addDisksLink(vm);
        return response;
    }
    return null;
}
#method_after
public static Response addDisksLinkToResponse(Response response) {
    if (response.getEntity() instanceof V3VM) {
        V3VM vm = (V3VM) response.getEntity();
        addDisksLink(vm);
    }
    return response;
}
#end_block

#method_before
public static V3VM addDisksLink(V3VM vm) {
    if (vm == null) {
        return null;
    }
    Current current = CurrentManager.get();
    StringBuilder buffer = new StringBuilder();
    buffer.append(current.getPrefix());
    if (current.getVersionSource() == VersionSource.URL) {
        buffer.append("/v");
        buffer.append(current.getVersion());
    }
    buffer.append(current.getPath());
    buffer.append(vm.getId());
    buffer.append("/disks");
    String href = buffer.toString();
    // Make the link:
    V3Link link = new V3Link();
    link.setRel("disks");
    link.setHref(href);
    vm.getLinks().add(link);
    return vm;
}
#method_after
public static V3VM addDisksLink(V3VM vm) {
    if (vm == null) {
        return null;
    }
    Current current = CurrentManager.get();
    StringBuilder buffer = new StringBuilder();
    buffer.append(current.getPrefix());
    if (current.getVersionSource() == VersionSource.URL) {
        buffer.append("/v");
        buffer.append(current.getVersion());
    }
    buffer.append(current.getPath());
    if (!current.getPath().contains(vm.getId())) {
        buffer.append(vm.getId());
    }
    buffer.append("/disks");
    String href = buffer.toString();
    // Make the link:
    V3Link link = new V3Link();
    link.setRel("disks");
    link.setHref(href);
    vm.getLinks().add(link);
    return vm;
}
#end_block

#method_before
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#method_after
public static ArrayList<DiskImage> buildDiskImagesFromDevices(Map<String, Object> vmStruct, Guid vmId) {
    ArrayList<DiskImage> diskImages = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.Disk.equals(deviceMap.get(VdsProperties.Device))) {
                DiskImage image = new DiskImage();
                image.setDiskAlias((String) deviceMap.get(VdsProperties.Alias));
                image.setSize(Long.parseLong((String) deviceMap.get("apparentsize")));
                image.setActualSize(Long.parseLong((String) deviceMap.get("truesize")));
                image.setId(Guid.newGuid());
                image.setVolumeFormat(VolumeFormat.valueOf(((String) deviceMap.get(VdsProperties.Format)).toUpperCase()));
                image.setShareable(false);
                image.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                image.setImageId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.VolumeId)));
                Guid domainId = Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DomainId));
                List<Guid> domainIds = Collections.singletonList(domainId);
                image.setStorageIds(new ArrayList<>(domainIds));
                // TODO not sure how to extract that info
                image.setVolumeType(VolumeType.Preallocated);
                DiskVmElement dve = new DiskVmElement(image.getId(), vmId);
                image.setDiskVmElements(Collections.singletonList(dve));
                switch((String) deviceMap.get("iface")) {
                    case "virtio":
                        dve.setDiskInterface(DiskInterface.VirtIO);
                        break;
                    case "iscsi":
                        dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
                        break;
                    case "ide":
                        dve.setDiskInterface(DiskInterface.IDE);
                        break;
                }
                diskImages.add(image);
            }
        }
    }
    return diskImages;
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(xmlRpcStruct, VdsProperties.kernel_args));
    vds.setPrettyName(assignStringValue((Map<String, Object>) (xmlRpcStruct.get(VdsProperties.host_os)), VdsProperties.pretty_name));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(assignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(assignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(assignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(assignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(assignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(assignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(assignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKernelArgs(assignStringValue(xmlRpcStruct, VdsProperties.kernel_args));
    vds.setKvmEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(assignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = assignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(assignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    updatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(assignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(assignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(assignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(assignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    vds.setHostDevicePassthroughEnabled(assignBoolValue(xmlRpcStruct, VdsProperties.HOST_DEVICE_PASSTHROUGH));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(assignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#end_block

#method_before
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(getPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
        vds.setPrettyName(assignStringValue((Map<String, Object>) (xmlRpcStruct.get(VdsProperties.host_os)), VdsProperties.pretty_name));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#method_after
private static void updatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(assignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(assignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(assignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        Map<String, Object> hostOsMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os);
        vds.setHostOs(getPackageVersionFormated(hostOsMap, true));
        if (hostOsMap.containsKey(VdsProperties.pretty_name)) {
            vds.setPrettyName(assignStringValue(hostOsMap, VdsProperties.pretty_name));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = assignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(getPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(getPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.glusterfsCliPackageName)) {
            Map<String, Object> glusterfsCli = (Map<String, Object>) packages.get(VdsProperties.glusterfsCliPackageName);
            vds.setGlusterfsCliVersion(getPackageRpmVersion(VdsProperties.glusterfsCliPackageName, glusterfsCli));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters()) || isClusterLevelChange();
}
#end_block

#method_before
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#method_after
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.hasMemoryBalloon(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : getVmDeviceUtils().hasMemoryBalloon(getVmId());
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getVmId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : getVmDeviceUtils().hasSoundDevice(getVmId());
}
#end_block

#method_before
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
        vmStatic.setMigrationPolicyId(instanceType.getMigrationPolicyId());
    }
}
#method_after
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = getVmDeviceUtils().getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
        vmStatic.setMigrationPolicyId(instanceType.getMigrationPolicyId());
    }
}
#end_block

#method_before
protected VdcReturnValueBase runAction(CommandBase<?> command, boolean runAsInternal) {
    VdcReturnValueBase returnValue = evaluateCorrelationId(command);
    if (returnValue != null) {
        return returnValue;
    }
    command.setInternalExecution(runAsInternal);
    ExecutionHandler.prepareCommandForMonitoring(command, command.getActionType(), runAsInternal);
    returnValue = command.executeAction();
    returnValue.setCorrelationId(command.getParameters().getCorrelationId());
    returnValue.setJobId(command.getJobId());
    return returnValue;
}
#method_after
protected VdcReturnValueBase runAction(CommandBase<?> command, boolean runAsInternal) {
    VdcReturnValueBase returnValue = evaluateCorrelationId(command);
    if (returnValue != null) {
        return returnValue;
    }
    command.setInternalExecution(runAsInternal);
    ExecutionHandler.prepareCommandForMonitoring(command, command.getActionType(), runAsInternal);
    returnValue = actionExecutor.get().execute(command);
    returnValue.setCorrelationId(command.getParameters().getCorrelationId());
    returnValue.setJobId(command.getJobId());
    return returnValue;
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || sessionDataContainer.getUser(sessionId, parameters.getRefresh()) == null) {
            log.debug("Unable to execute query {} as no user session was found", actionType);
            return getErrorQueryReturnValue(EngineMessage.USER_IS_NOT_LOGGED_IN);
        }
        logExecution(sessionId, String.format("query %s with isFiltered : %s", actionType, parameters.isFiltered()));
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = vdcOptionDao.getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || sessionDataContainer.getUser(sessionId, parameters.getRefresh()) == null) {
            log.debug("Unable to execute query {} as no user session was found", actionType);
            return getErrorQueryReturnValue(EngineMessage.USER_IS_NOT_LOGGED_IN);
        }
        logExecution(sessionId, String.format("query %s with isFiltered : %s", actionType, parameters.isFiltered()));
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = vdcOptionDao.getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    return queryExecutor.get().execute(command, actionType);
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    /*        final IValidation[] versionValidations = getIsNew()
                ? new IValidation[] { new NotEmptyValidation() }
                : new IValidation[] { new NotEmptyValidation(),
                        new ClusterVersionChangeValidation(hasActiveVm, getEntity().getCompatibilityVersion()) };
                        */
    final IValidation[] versionValidations = new IValidation[] { new NotEmptyValidation() };
    getVersion().validateSelectedItem(versionValidations);
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getMacPoolModel().validate();
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null) {
        if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
            getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
        } else {
            getCustomMigrationNetworkBandwidth().setIsValid(true);
        }
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    boolean macPoolTabValid = getMacPoolModel().getIsValid();
    setValidTab(TabName.MAC_POOL_TAB, macPoolTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && macPoolTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    final IValidation[] versionValidations = new IValidation[] { new NotEmptyValidation() };
    getVersion().validateSelectedItem(versionValidations);
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getMacPoolModel().validate();
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null) {
        if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
            getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
        } else {
            getCustomMigrationNetworkBandwidth().setIsValid(true);
        }
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    boolean macPoolTabValid = getMacPoolModel().getIsValid();
    setValidTab(TabName.MAC_POOL_TAB, macPoolTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && macPoolTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isClusterLevelChange() {
    Version newVersion = getParameters().getClusterLevelChangeToVersion();
    return newVersion != null && getVm().isRunningOrPaused() && (getVm().getCustomCompatibilityVersion() == null || !newVersion.equals(getVm().getCompatibilityVersion()));
}
#method_after
private boolean isClusterLevelChange() {
    Version newVersion = getParameters().getClusterLevelChangeToVersion();
    return newVersion != null && (getVm().isRunningOrPaused() || getVm().isSuspended()) && getVm().getCustomCompatibilityVersion() == null;
}
#end_block

#method_before
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#method_after
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.hasMemoryBalloon(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : getVmDeviceUtils().hasMemoryBalloon(getVmId());
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getVmId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : getVmDeviceUtils().hasSoundDevice(getVmId());
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.HOST_NETWORK, EngineMessage.ACTION_TYPE_FAILED_SETUP_NETWORKS_OR_REFRESH_IN_PROGRESS));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return hostLocking.getSetupNetworksLock(getParameters().getVdsId());
}
#end_block

#method_before
@Override
public void onNext(Map<String, Object> map) {
    boolean lockAcquired = false;
    Guid vdsId = vdsManager.getVdsId();
    try {
        lockAcquired = LockManagerFactory.getLockManager().acquireLock(setupNetworksLock).getFirst();
        if (lockAcquired) {
            resourceManager.getEventListener().refreshHostCapabilities(vdsId);
        }
    } finally {
        if (lockAcquired) {
            LockManagerFactory.getLockManager().releaseLock(setupNetworksLock);
        }
        subscription.request(1);
    }
}
#method_after
@Override
public void onNext(Map<String, Object> map) {
    try {
        resourceManager.getEventListener().refreshHostCapabilities(vdsManager.getVdsId());
    } finally {
        subscription.request(1);
    }
}
#end_block

#method_before
private void initMembers() {
    executedUpdatedMetadataForStoragePool = new HashMap<>();
    executedRemovedIds = new HashSet<>();
    executedUpdatedOvfGenerationIdsInDb = new HashMap<>();
    poolDomainsOvfInfo = new HashMap<>();
    vms = new HashMap<>();
    templates = new HashMap<>();
    pool1 = new StoragePool();
    pool1.setId(Guid.newGuid());
    pool1.setStatus(StoragePoolStatus.Maintenance);
    performStoragePoolInitOps(pool1);
}
#method_after
private void initMembers() {
    executedUpdatedOvfGenerationIdsInDb = new HashMap<>();
    poolDomainsOvfInfo = new HashMap<>();
    vms = new HashMap<>();
    templates = new HashMap<>();
    pool1 = new StoragePool();
    pool1.setId(Guid.newGuid());
    pool1.setStatus(StoragePoolStatus.Maintenance);
    performStoragePoolInitOps(pool1);
}
#end_block

#method_before
private void performStoragePoolInitOps(StoragePool pool) {
    executedUpdatedMetadataForStoragePool = new HashMap<>();
    executedRemovedIds = new HashSet<>();
    executedUpdatedOvfGenerationIdsInDb = new HashMap<>();
    for (int i = 0; i < 2; i++) {
        Guid domainId = Guid.newGuid();
        StorageDomainOvfInfo ovfInfo = new StorageDomainOvfInfo(domainId, null, null, StorageDomainOvfInfoStatus.UPDATED, null);
        StorageDomain domain = new StorageDomain();
        domain.setId(domainId);
        domain.setStoragePoolIsoMapData(new StoragePoolIsoMap(domainId, pool.getId(), StorageDomainStatus.Active));
        poolDomainsOvfInfo.put(domainId, new Pair<>(Arrays.asList(ovfInfo), domain));
    }
}
#method_after
private void performStoragePoolInitOps(StoragePool pool) {
    executedUpdatedOvfGenerationIdsInDb = new HashMap<>();
    for (int i = 0; i < 2; i++) {
        Guid domainId = Guid.newGuid();
        StorageDomainOvfInfo ovfInfo = new StorageDomainOvfInfo(domainId, null, null, StorageDomainOvfInfoStatus.UPDATED, null);
        StorageDomain domain = new StorageDomain();
        domain.setId(domainId);
        domain.setStoragePoolIsoMapData(new StoragePoolIsoMap(domainId, pool.getId(), StorageDomainStatus.Active));
        poolDomainsOvfInfo.put(domainId, new Pair<>(Collections.singletonList(ovfInfo), domain));
    }
}
#end_block

#method_before
private void mockAnswers() {
    doAnswer(new Answer<String>() {

        @Override
        public String answer(InvocationOnMock invocation) throws Throwable {
            VM vm = (VM) invocation.getArguments()[0];
            return vm.getId().toString();
        }
    }).when(ovfUpdateProcessHelper).generateVmMetadata(any(VM.class), any(ArrayList.class));
    doAnswer(new Answer<String>() {

        @Override
        public String answer(InvocationOnMock invocation) throws Throwable {
            VmTemplate template = (VmTemplate) invocation.getArguments()[0];
            return template.getId().toString();
        }
    }).when(ovfUpdateProcessHelper).generateVmTemplateMetadata(any(VmTemplate.class), anyList());
    doAnswer(new Answer<List<VM>>() {

        @Override
        public List<VM> answer(InvocationOnMock invocation) throws Throwable {
            List<Guid> neededIds = (List<Guid>) invocation.getArguments()[0];
            List<VM> toReturn = new LinkedList<>();
            for (Guid id : neededIds) {
                toReturn.add(vms.get(id));
            }
            return toReturn;
        }
    }).when(vmDao).getVmsByIds(anyList());
    doAnswer(new Answer<List<VmTemplate>>() {

        @Override
        public List<VmTemplate> answer(InvocationOnMock invocation) throws Throwable {
            List<Guid> neededIds = (List<Guid>) invocation.getArguments()[0];
            List<VmTemplate> toReturn = new LinkedList<>();
            for (Guid id : neededIds) {
                toReturn.add(templates.get(id));
            }
            return toReturn;
        }
    }).when(vmTemplateDao).getVmTemplatesByIds(anyList());
    doAnswer(new Answer<Boolean>() {

        @Override
        public Boolean answer(InvocationOnMock invocation) throws Throwable {
            Map<Guid, KeyValuePairCompat<String, List<Guid>>> updateMap = (Map<Guid, KeyValuePairCompat<String, List<Guid>>>) invocation.getArguments()[1];
            executedUpdatedMetadataForStoragePool.putAll(updateMap);
            assertTrue("too many ovfs were sent in one vdsm call", updateMap.size() <= ITEMS_COUNT_PER_UPDATE);
            return true;
        }
    }).when(ovfUpdateProcessHelper).executeUpdateVmInSpmCommand(any(Guid.class), anyMap(), any(Guid.class));
    doAnswer(new Answer<Boolean>() {

        @Override
        public Boolean answer(InvocationOnMock invocation) throws Throwable {
            executedRemovedIds.add((Guid) invocation.getArguments()[1]);
            return true;
        }
    }).when(ovfUpdateProcessHelper).executeRemoveVmInSpm(any(Guid.class), any(Guid.class), any(Guid.class));
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            List<Guid> ids = (List<Guid>) invocation.getArguments()[0];
            List<Long> values = (List<Long>) invocation.getArguments()[1];
            assertFalse("update of ovf version in db shouldn't be called with an empty value list", values.isEmpty());
            assertTrue("update of ovf version in db shouldn't be called with more items then MAX_ITEMS_PER_SQL_STATEMENT", values.size() <= StorageConstants.OVF_MAX_ITEMS_PER_SQL_STATEMENT);
            assertEquals("the size of the list of ids for update is not the same as the size of the " + "list with the new ovf values", values.size(), ids.size());
            Guid[] ids_array = ids.toArray(new Guid[ids.size()]);
            Long[] values_array = values.toArray(new Long[values.size()]);
            for (int i = 0; i < ids_array.length; i++) {
                executedUpdatedOvfGenerationIdsInDb.put(ids_array[i], values_array[i]);
            }
            return null;
        }
    }).when(vmAndTemplatesGenerationsDao).updateOvfGenerations(anyList(), anyList(), anyList());
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            StoragePoolStatus desiredStatus = (StoragePoolStatus) invocation.getArguments()[0];
            List<StoragePool> toReturn = new LinkedList<>();
            for (StoragePool pool : buildStoragePoolsList()) {
                if (desiredStatus.equals(pool.getStatus())) {
                    toReturn.add(pool);
                }
            }
            return toReturn;
        }
    }).when(storagePoolDao).getAllByStatus(any(StoragePoolStatus.class));
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            Guid poolId = (Guid) invocation.getArguments()[0];
            List<StorageDomain> toReturn = new LinkedList<>();
            for (Pair<List<StorageDomainOvfInfo>, StorageDomain> pair : poolDomainsOvfInfo.values()) {
                toReturn.add(pair.getSecond());
            }
            return toReturn;
        }
    }).when(storageDomainDao).getAllForStoragePool(any(Guid.class));
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            Guid domainId = (Guid) invocation.getArguments()[0];
            Pair<List<StorageDomainOvfInfo>, StorageDomain> pair = poolDomainsOvfInfo.get(domainId);
            if (pair != null) {
                return pair.getFirst();
            }
            return null;
        }
    }).when(storageDomainOvfInfoDao).getAllForDomain(any(Guid.class));
}
#method_after
private void mockAnswers() {
    doAnswer((Answer<String>) invocation -> {
        VM vm = (VM) invocation.getArguments()[0];
        return vm.getId().toString();
    }).when(ovfUpdateProcessHelper).generateVmMetadata(any(VM.class), anyListOf(DiskImage.class));
    doAnswer((Answer<String>) invocation -> {
        VmTemplate template = (VmTemplate) invocation.getArguments()[0];
        return template.getId().toString();
    }).when(ovfUpdateProcessHelper).generateVmTemplateMetadata(any(VmTemplate.class), anyListOf(DiskImage.class));
    doAnswer((Answer<List<VM>>) invocation -> {
        List<Guid> neededIds = (List<Guid>) invocation.getArguments()[0];
        return neededIds.stream().map(id -> vms.get(id)).collect(Collectors.toList());
    }).when(vmDao).getVmsByIds(anyListOf(Guid.class));
    doAnswer((Answer<List<VmTemplate>>) invocation -> {
        List<Guid> neededIds = (List<Guid>) invocation.getArguments()[0];
        return neededIds.stream().map(id -> templates.get(id)).collect(Collectors.toList());
    }).when(vmTemplateDao).getVmTemplatesByIds(anyListOf(Guid.class));
    doAnswer((Answer<Boolean>) invocation -> {
        Map<Guid, KeyValuePairCompat<String, List<Guid>>> updateMap = (Map<Guid, KeyValuePairCompat<String, List<Guid>>>) invocation.getArguments()[1];
        assertTrue("too many ovfs were sent in one vdsm call", updateMap.size() <= ITEMS_COUNT_PER_UPDATE);
        return true;
    }).when(ovfUpdateProcessHelper).executeUpdateVmInSpmCommand(any(Guid.class), anyMap(), any(Guid.class));
    doReturn(true).when(ovfUpdateProcessHelper).executeRemoveVmInSpm(any(Guid.class), any(Guid.class), any(Guid.class));
    doAnswer((Answer<Object>) invocation -> {
        List<Guid> ids = (List<Guid>) invocation.getArguments()[0];
        List<Long> values = (List<Long>) invocation.getArguments()[1];
        assertFalse("update of ovf version in db shouldn't be called with an empty value list", values.isEmpty());
        assertTrue("update of ovf version in db shouldn't be called with more items then MAX_ITEMS_PER_SQL_STATEMENT", values.size() <= StorageConstants.OVF_MAX_ITEMS_PER_SQL_STATEMENT);
        assertEquals("the size of the list of ids for update is not the same as the size of the " + "list with the new ovf values", values.size(), ids.size());
        Guid[] ids_array = ids.toArray(new Guid[ids.size()]);
        Long[] values_array = values.toArray(new Long[values.size()]);
        for (int i = 0; i < ids_array.length; i++) {
            executedUpdatedOvfGenerationIdsInDb.put(ids_array[i], values_array[i]);
        }
        return null;
    }).when(vmAndTemplatesGenerationsDao).updateOvfGenerations(anyListOf(Guid.class), anyListOf(Long.class), anyListOf(String.class));
    doAnswer((Answer<Object>) invocation -> {
        StoragePoolStatus desiredStatus = (StoragePoolStatus) invocation.getArguments()[0];
        return buildStoragePoolsList().stream().filter(p -> desiredStatus.equals(p.getStatus())).collect(Collectors.toList());
    }).when(storagePoolDao).getAllByStatus(any(StoragePoolStatus.class));
    doReturn(poolDomainsOvfInfo.values().stream().map(Pair::getSecond).collect(Collectors.toList())).when(storageDomainDao).getAllForStoragePool(any(Guid.class));
    doAnswer((Answer<Object>) invocation -> {
        Guid domainId = (Guid) invocation.getArguments()[0];
        Pair<List<StorageDomainOvfInfo>, StorageDomain> pair = poolDomainsOvfInfo.get(domainId);
        if (pair != null) {
            return pair.getFirst();
        }
        return null;
    }).when(storageDomainOvfInfoDao).getAllForDomain(any(Guid.class));
}
#end_block

#method_before
private List<StoragePool> buildStoragePoolsList() {
    return Arrays.asList(pool1);
}
#method_after
private List<StoragePool> buildStoragePoolsList() {
    return Collections.singletonList(pool1);
}
#end_block

#method_before
private List<Guid> generateGuidList(int size) {
    List<Guid> toReturn = new LinkedList<>();
    for (int i = 0; i < size; i++) {
        toReturn.add(Guid.newGuid());
    }
    return toReturn;
}
#method_after
private List<Guid> generateGuidList(int size) {
    return IntStream.range(0, size).mapToObj(x -> Guid.newGuid()).collect(Collectors.toList());
}
#end_block

#method_before
private Map<Guid, VM> generateVmsMapByGuids(List<Guid> ids, int diskCount, VMStatus vmStatus, ImageStatus diskStatus, Guid poolId) {
    Map<Guid, VM> toReturn = new HashMap<>();
    for (Guid id : ids) {
        VM vm = createVm(id, vmStatus);
        for (int i = 0; i < diskCount; i++) {
            DiskImage image = createDiskImage(diskStatus, poolId);
            vm.getDiskMap().put(image.getId(), image);
            vm.getDiskList().add(image);
        }
        toReturn.put(vm.getId(), vm);
    }
    return toReturn;
}
#method_after
private Map<Guid, VM> generateVmsMapByGuids(List<Guid> ids, int diskCount, VMStatus vmStatus, ImageStatus diskStatus) {
    Map<Guid, VM> toReturn = new HashMap<>();
    for (Guid id : ids) {
        VM vm = createVm(id, vmStatus);
        for (int i = 0; i < diskCount; i++) {
            DiskImage image = createDiskImage(diskStatus);
            vm.getDiskMap().put(image.getId(), image);
            vm.getDiskList().add(image);
        }
        toReturn.put(vm.getId(), vm);
    }
    return toReturn;
}
#end_block

#method_before
private Map<Guid, VmTemplate> generateVmTemplatesMapByGuids(List<Guid> ids, int diskCount, VmTemplateStatus templateStatus, ImageStatus diskStatus, Guid poolId) {
    Map<Guid, VmTemplate> toReturn = new HashMap<>();
    for (Guid id : ids) {
        VmTemplate template = createVmTemplate(id, templateStatus);
        for (int i = 0; i < diskCount; i++) {
            DiskImage image = createDiskImage(diskStatus, poolId);
            template.getDiskTemplateMap().put(image.getId(), image);
            template.getDiskList().add(image);
        }
        toReturn.put(template.getId(), template);
    }
    return toReturn;
}
#method_after
private Map<Guid, VmTemplate> generateVmTemplatesMapByGuids(List<Guid> ids, int diskCount, VmTemplateStatus templateStatus, ImageStatus diskStatus) {
    Map<Guid, VmTemplate> toReturn = new HashMap<>();
    for (Guid id : ids) {
        VmTemplate template = createVmTemplate(id, templateStatus);
        for (int i = 0; i < diskCount; i++) {
            DiskImage image = createDiskImage(diskStatus);
            template.getDiskTemplateMap().put(image.getId(), image);
            template.getDiskList().add(image);
        }
        toReturn.put(template.getId(), template);
    }
    return toReturn;
}
#end_block

#method_before
private DiskImage createDiskImage(ImageStatus status, Guid poolId) {
    DiskImage disk = new DiskImage();
    disk.setId(Guid.newGuid());
    disk.setImageStatus(status);
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(poolDomainsOvfInfo.keySet().iterator().next());
    disk.setStorageIds(storageIds);
    return disk;
}
#method_after
private DiskImage createDiskImage(ImageStatus status) {
    DiskImage disk = new DiskImage();
    disk.setId(Guid.newGuid());
    disk.setImageStatus(status);
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(poolDomainsOvfInfo.keySet().iterator().next());
    disk.setStorageIds(storageIds);
    return disk;
}
#end_block

#method_before
private void addVms(List<Guid> vmGuids, int diskCount, VMStatus vmStatus, ImageStatus vmImageStatus, Guid poolId) {
    vms.putAll(generateVmsMapByGuids(vmGuids, diskCount, vmStatus, vmImageStatus, poolId));
}
#method_after
private void addVms(List<Guid> vmGuids, int diskCount, VMStatus vmStatus, ImageStatus vmImageStatus) {
    vms.putAll(generateVmsMapByGuids(vmGuids, diskCount, vmStatus, vmImageStatus));
}
#end_block

#method_before
private void addTemplates(List<Guid> templatesGuids, int diskCount, VmTemplateStatus templateStatus, ImageStatus templateImageStatus, Guid poolId) {
    templates.putAll(generateVmTemplatesMapByGuids(templatesGuids, diskCount, templateStatus, templateImageStatus, poolId));
}
#method_after
private void addTemplates(List<Guid> templatesGuids, int diskCount, VmTemplateStatus templateStatus, ImageStatus templateImageStatus) {
    templates.putAll(generateVmTemplatesMapByGuids(templatesGuids, diskCount, templateStatus, templateImageStatus));
}
#end_block

#method_before
@Test
public void testOvfDataUpdaterRunWithUpdateAndRemoveHigherThanCountOnePool() {
    int size = 3 * ITEMS_COUNT_PER_UPDATE + 10;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    List<Guid> removedGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK, pool1.getId());
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK, pool1.getId());
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    List<Guid> idsThatNeededToBeUpdated = new LinkedList<>(vmGuids);
    idsThatNeededToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(idsThatNeededToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Arrays.asList(pool1.getId()), Collections.<Guid, List<Guid>>emptyMap());
}
#method_after
@Test
public void testOvfDataUpdaterRunWithUpdateAndRemoveHigherThanCountOnePool() {
    int size = 3 * ITEMS_COUNT_PER_UPDATE + 10;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    List<Guid> removedGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK);
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    List<Guid> idsThatNeededToBeUpdated = new LinkedList<>(vmGuids);
    idsThatNeededToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(idsThatNeededToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Collections.singletonList(pool1.getId()), Collections.emptyMap());
}
#end_block

#method_before
@Test
public void testOvfDataUpdaterRunWithUpdateAndRemoveLowerThanCount() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    List<Guid> vmGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK, pool1.getId());
    List<Guid> templatesGuids = generateGuidList(size);
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK, pool1.getId());
    List<Guid> removedGuids = generateGuidList(size);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    List<Guid> needToBeUpdated = new LinkedList<>(vmGuids);
    needToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(needToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Arrays.asList(pool1.getId()), Collections.<Guid, List<Guid>>emptyMap());
}
#method_after
@Test
public void testOvfDataUpdaterRunWithUpdateAndRemoveLowerThanCount() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    List<Guid> vmGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK);
    List<Guid> templatesGuids = generateGuidList(size);
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK);
    List<Guid> removedGuids = generateGuidList(size);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    List<Guid> needToBeUpdated = new LinkedList<>(vmGuids);
    needToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(needToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Collections.singletonList(pool1.getId()), Collections.emptyMap());
}
#end_block

#method_before
@Test
public void testOvfDataUpdaterAllDisksAreLockedNonToRemove() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> removedGuids = Collections.emptyList();
    List<Guid> templatesGuids = generateGuidList(size);
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.LOCKED, pool1.getId());
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.LOCKED, pool1.getId());
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    verifyCorrectOvfDataUpdaterRun(Collections.<Guid>emptyList());
}
#method_after
@Test
public void testOvfDataUpdaterAllDisksAreLockedNonToRemove() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> removedGuids = Collections.emptyList();
    List<Guid> templatesGuids = generateGuidList(size);
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.LOCKED);
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.LOCKED);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    verifyCorrectOvfDataUpdaterRun(Collections.emptyList());
}
#end_block

#method_before
@Test
public void testOvfDataUpdaterPartOfDisksAreLocked() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    // unlocked vms/templates
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK, pool1.getId());
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK, pool1.getId());
    // locked vms/templates
    List<Guid> lockedVmGuids = generateGuidList(size);
    List<Guid> lockedTemplatesGuids = generateGuidList(size);
    addVms(lockedVmGuids, 2, VMStatus.Down, ImageStatus.LOCKED, pool1.getId());
    addTemplates(lockedTemplatesGuids, 2, VmTemplateStatus.OK, ImageStatus.LOCKED, pool1.getId());
    // ids for removal
    List<Guid> removedGuids = generateGuidList(size);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    // list of ids that should have been updated.
    List<Guid> needToBeUpdated = new LinkedList<>(vmGuids);
    needToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(needToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Collections.<Guid>emptyList(), Collections.<Guid, List<Guid>>emptyMap());
}
#method_after
@Test
public void testOvfDataUpdaterPartOfDisksAreLocked() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    // unlocked vms/templates
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK);
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK);
    // locked vms/templates
    List<Guid> lockedVmGuids = generateGuidList(size);
    List<Guid> lockedTemplatesGuids = generateGuidList(size);
    addVms(lockedVmGuids, 2, VMStatus.Down, ImageStatus.LOCKED);
    addTemplates(lockedTemplatesGuids, 2, VmTemplateStatus.OK, ImageStatus.LOCKED);
    // ids for removal
    List<Guid> removedGuids = generateGuidList(size);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    // list of ids that should have been updated.
    List<Guid> needToBeUpdated = new LinkedList<>(vmGuids);
    needToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(needToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Collections.emptyList(), Collections.emptyMap());
}
#end_block

#method_before
private int numberOfTimesToBeCalled(int size, boolean isBothVmAndTemplates) {
    int toReturn = 0;
    if (size % ITEMS_COUNT_PER_UPDATE != 0) {
        toReturn++;
    }
    toReturn += size / ITEMS_COUNT_PER_UPDATE;
    if (isBothVmAndTemplates) {
        toReturn = toReturn * 2;
    }
    return toReturn;
}
#method_after
private int numberOfTimesToBeCalled(int size, boolean isBothVmAndTemplates) {
    int toReturn = 0;
    if (size % ITEMS_COUNT_PER_UPDATE != 0) {
        toReturn++;
    }
    toReturn += size / ITEMS_COUNT_PER_UPDATE;
    if (isBothVmAndTemplates) {
        toReturn *= 2;
    }
    return toReturn;
}
#end_block

#method_before
@Test
public void testOvfDataUpdaterAllVmsAndTemplatesAreLocked() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    List<Guid> vmGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.ImageLocked, ImageStatus.OK, pool1.getId());
    List<Guid> removedGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    addTemplates(templatesGuids, 2, VmTemplateStatus.Locked, ImageStatus.OK, pool1.getId());
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    command.executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    verifyCorrectOvfDataUpdaterRun(Collections.<Guid>emptyList());
    verifyOvfUpdatedForSupportedPools(Collections.<Guid>emptyList(), Collections.<Guid, List<Guid>>emptyMap());
}
#method_after
@Test
public void testOvfDataUpdaterAllVmsAndTemplatesAreLocked() {
    int size = ITEMS_COUNT_PER_UPDATE - 1;
    List<Guid> vmGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.ImageLocked, ImageStatus.OK);
    List<Guid> removedGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    addTemplates(templatesGuids, 2, VmTemplateStatus.Locked, ImageStatus.OK);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    command.executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    verifyCorrectOvfDataUpdaterRun(Collections.emptyList());
    verifyOvfUpdatedForSupportedPools(Collections.emptyList(), Collections.emptyMap());
}
#end_block

#method_before
@Test
public void testOvfDataUpdaterPartOfVmsAndTemplatesAreLocked() {
    int size = ITEMS_COUNT_PER_UPDATE;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> removedGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.ImageLocked, ImageStatus.OK, pool1.getId());
    addTemplates(templatesGuids, 2, VmTemplateStatus.Locked, ImageStatus.OK, pool1.getId());
    List<Guid> vmGuidsUnlocked = generateGuidList(size);
    List<Guid> templatesGuidsUnlocked = generateGuidList(size);
    addVms(vmGuidsUnlocked, 2, VMStatus.Down, ImageStatus.OK, pool1.getId());
    addTemplates(templatesGuidsUnlocked, 2, VmTemplateStatus.OK, ImageStatus.OK, pool1.getId());
    vmGuids.addAll(vmGuidsUnlocked);
    templatesGuids.addAll(templatesGuidsUnlocked);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    List<Guid> neededToBeUpdated = new LinkedList<>(vmGuidsUnlocked);
    neededToBeUpdated.addAll(templatesGuidsUnlocked);
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    verifyCorrectOvfDataUpdaterRun(neededToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Collections.<Guid>emptyList(), Collections.<Guid, List<Guid>>emptyMap());
}
#method_after
@Test
public void testOvfDataUpdaterPartOfVmsAndTemplatesAreLocked() {
    int size = ITEMS_COUNT_PER_UPDATE;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> removedGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    addVms(vmGuids, 2, VMStatus.ImageLocked, ImageStatus.OK);
    addTemplates(templatesGuids, 2, VmTemplateStatus.Locked, ImageStatus.OK);
    List<Guid> vmGuidsUnlocked = generateGuidList(size);
    List<Guid> templatesGuidsUnlocked = generateGuidList(size);
    addVms(vmGuidsUnlocked, 2, VMStatus.Down, ImageStatus.OK);
    addTemplates(templatesGuidsUnlocked, 2, VmTemplateStatus.OK, ImageStatus.OK);
    vmGuids.addAll(vmGuidsUnlocked);
    templatesGuids.addAll(templatesGuidsUnlocked);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    executeCommand();
    List<Guid> neededToBeUpdated = new LinkedList<>(vmGuidsUnlocked);
    neededToBeUpdated.addAll(templatesGuidsUnlocked);
    verify(command, times(numberOfTimesToBeCalled(size, true))).performOvfUpdate(anyMap());
    verifyCorrectOvfDataUpdaterRun(neededToBeUpdated);
    verifyOvfUpdatedForSupportedPools(Collections.emptyList(), Collections.emptyMap());
}
#end_block

#method_before
@Test
public void testUpdatedDbGeneration() {
    int size = 3 * ITEMS_COUNT_PER_UPDATE + 10;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    List<Guid> removedGuids = Collections.emptyList();
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK, pool1.getId());
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK, pool1.getId());
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    doReturn(2L).when(vmStaticDao).getDbGeneration(any(Guid.class));
    executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    List<Guid> idsThatNeededToBeUpdated = new LinkedList<>(vmGuids);
    idsThatNeededToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(Collections.<Guid>emptyList());
    verifyOvfUpdatedForSupportedPools(Collections.<Guid>emptyList(), Collections.<Guid, List<Guid>>emptyMap());
}
#method_after
@Test
public void testUpdatedDbGeneration() {
    int size = 3 * ITEMS_COUNT_PER_UPDATE + 10;
    List<Guid> vmGuids = generateGuidList(size);
    List<Guid> templatesGuids = generateGuidList(size);
    List<Guid> removedGuids = Collections.emptyList();
    addVms(vmGuids, 2, VMStatus.Down, ImageStatus.OK);
    addTemplates(templatesGuids, 2, VmTemplateStatus.OK, ImageStatus.OK);
    initTestForPool(pool1, vmGuids, templatesGuids, removedGuids);
    doReturn(2L).when(vmStaticDao).getDbGeneration(any(Guid.class));
    executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    List<Guid> idsThatNeededToBeUpdated = new LinkedList<>(vmGuids);
    idsThatNeededToBeUpdated.addAll(templatesGuids);
    verifyCorrectOvfDataUpdaterRun(Collections.emptyList());
    verifyOvfUpdatedForSupportedPools(Collections.emptyList(), Collections.emptyMap());
}
#end_block

#method_before
@Test
public void testUpdateCalledForUnupdatedDomain() {
    Guid poolId = pool1.getId();
    StorageDomainOvfInfo ovfInfo = poolDomainsOvfInfo.entrySet().iterator().next().getValue().getFirst().get(0);
    ovfInfo.setStatus(StorageDomainOvfInfoStatus.OUTDATED);
    initTestForPool(pool1, Collections.<Guid>emptyList(), Collections.<Guid>emptyList(), Collections.<Guid>emptyList());
    executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    Map<Guid, List<Guid>> domainsRequiredUpdateForPool = Collections.singletonMap(poolId, Arrays.asList(ovfInfo.getStorageDomainId()));
    verifyOvfUpdatedForSupportedPools(Arrays.asList(poolId), domainsRequiredUpdateForPool);
}
#method_after
@Test
public void testUpdateCalledForUnupdatedDomain() {
    Guid poolId = pool1.getId();
    StorageDomainOvfInfo ovfInfo = poolDomainsOvfInfo.entrySet().iterator().next().getValue().getFirst().get(0);
    ovfInfo.setStatus(StorageDomainOvfInfoStatus.OUTDATED);
    initTestForPool(pool1, Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
    executeCommand();
    verify(command, never()).performOvfUpdate(anyMap());
    Map<Guid, List<Guid>> domainsRequiredUpdateForPool = Collections.singletonMap(poolId, Collections.singletonList(ovfInfo.getStorageDomainId()));
    verifyOvfUpdatedForSupportedPools(Collections.singletonList(poolId), domainsRequiredUpdateForPool);
}
#end_block

#method_before
@Override
protected void perform() {
    String iface = null;
    int index = 0;
    if (getVm().getCompatibilityVersion().greaterOrEquals(Version.v4_0)) {
        iface = vmDeviceUtils.getCdInterface(getVm());
        index = VmDeviceCommonUtils.getCdDeviceIndex(iface);
    }
    cdImagePath = ImagesHandler.cdPathWindowsToLinux(getParameters().getCdImagePath(), getVm().getStoragePoolId(), getVm().getRunOnVds());
    setActionReturnValue(runVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), iface, index, cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    String iface = null;
    int index = 0;
    if (getVm().getCompatibilityVersion().greaterOrEquals(Version.v4_0)) {
        iface = getVmDeviceUtils().getCdInterface(getVm());
        index = VmDeviceCommonUtils.getCdDeviceIndex(iface);
    }
    cdImagePath = ImagesHandler.cdPathWindowsToLinux(getParameters().getCdImagePath(), getVm().getStoragePoolId(), getVm().getRunOnVds());
    setActionReturnValue(runVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), iface, index, cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#end_block

#method_before
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = vmDeviceUtils.getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
        vmStatic.setMigrationPolicyId(instanceType.getMigrationPolicyId());
    }
}
#method_after
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setThreadsPerCpu(instanceType.getThreadsPerCpu());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = getVmDeviceUtils().getMemoryBalloons(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
        vmStatic.setMigrationPolicyId(instanceType.getMigrationPolicyId());
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!isOperationPerformedOnDiskSnapshot()) {
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    DiskVmElement diskVmElement = getDiskVmElement();
    diskVmElement.getId().setDeviceId(disk.getId());
    getDiskVmElementDao().save(diskVmElement);
    // update cached image
    List<Disk> imageList = new ArrayList<>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (!isOperationPerformedOnDiskSnapshot()) {
        if (disk.isAllowSnapshot()) {
            updateDiskVmSnapshotId();
        }
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!isOperationPerformedOnDiskSnapshot()) {
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    DiskVmElement diskVmElement = getDiskVmElement();
    diskVmElement.getId().setDeviceId(disk.getId());
    getDiskVmElementDao().save(diskVmElement);
    // When performing hot plug for VirtIO-SCSI or SPAPR_VSCSI the address map calculation needs this info to be populated
    disk.setDiskVmElements(Collections.singletonList(diskVmElement));
    // update cached image
    List<Disk> imageList = new ArrayList<>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (!isOperationPerformedOnDiskSnapshot()) {
        if (disk.isAllowSnapshot()) {
            updateDiskVmSnapshotId();
        }
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void init() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster));
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#method_after
@Override
protected void init() {
    if (getCluster() == null) {
        return;
    }
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster));
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#end_block

#method_before
private AddVmParameters buildAddVmParameters(Guid poolId, String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(poolId);
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || vmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#method_after
private AddVmParameters buildAddVmParameters(Guid poolId, String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    currVm.setStateless(!getVmPool().isStateful());
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(poolId);
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || vmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    // A Pool cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    VmPool pool = getVmPoolDao().getByName(getParameters().getVmPool().getName());
    if (pool != null && (getActionType() == VdcActionType.AddVmPoolWithVms || !pool.getVmPoolId().equals(getParameters().getVmPoolId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    setStoragePoolId(getCluster().getStoragePoolId());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (!verifyAddVM()) {
        return false;
    }
    if (getVmTemplate().getDiskTemplateMap().values().size() != diskInfoDestinationMap.size()) {
        log.error("Can not found any default active domain for one of the disks of template with id '{}'", getVmTemplate().getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        return false;
    }
    List<Guid> storageIds = new ArrayList<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        Guid storageId = diskImage.getStorageIds().get(0);
        if (!storageIds.contains(storageId) && !areTemplateImagesInStorageReady(storageId)) {
            return false;
        }
        storageIds.add(storageId);
    }
    if (getActionType() == VdcActionType.AddVmPoolWithVms && getParameters().getVmsCount() < 1) {
        return failValidation(EngineMessage.VM_POOL_CANNOT_CREATE_WITH_NO_VMS);
    }
    if (getParameters().getVmStaticData().isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (getParameters().getVmPool().getPrestartedVms() > getParameters().getVmPool().getAssignedVmsCount() + getParameters().getVmsCount()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_PRESTARTED_VMS_CANNOT_EXCEED_VMS_COUNT);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return checkDestDomains();
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    // A Pool cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    VmPool pool = getVmPoolDao().getByName(getParameters().getVmPool().getName());
    if (pool != null && (getActionType() == VdcActionType.AddVmPoolWithVms || !pool.getVmPoolId().equals(getParameters().getVmPoolId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    setStoragePoolId(getCluster().getStoragePoolId());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (!verifyAddVM()) {
        return false;
    }
    if (getVmTemplate().getDiskTemplateMap().values().size() != diskInfoDestinationMap.size()) {
        log.error("Can not found any default active domain for one of the disks of template with id '{}'", getVmTemplate().getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        return false;
    }
    List<Guid> storageIds = new ArrayList<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        Guid storageId = diskImage.getStorageIds().get(0);
        if (!storageIds.contains(storageId) && !areTemplateImagesInStorageReady(storageId)) {
            return false;
        }
        storageIds.add(storageId);
    }
    if (getActionType() == VdcActionType.AddVmPoolWithVms && getParameters().getVmsCount() < 1) {
        return failValidation(EngineMessage.VM_POOL_CANNOT_CREATE_WITH_NO_VMS);
    }
    if (getParameters().getVmPool().getPrestartedVms() > getParameters().getVmPool().getAssignedVmsCount() + getParameters().getVmsCount()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_PRESTARTED_VMS_CANNOT_EXCEED_VMS_COUNT);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return checkDestDomains();
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    cpuFlagsManagerHandler = Injector.get(CpuFlagsManagerHandler.class);
    vmDeviceUtils = Injector.get(VmDeviceUtils.class);
    osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    updateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, inspectedClassNames)) {
        updateVmsStatic.addPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        updateVmsStatic.addPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.addField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
        if (pair.getFirst().isHotsetAllowed()) {
            updateVmsStatic.addHotsetFields(pair.getSecond().getName());
        }
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.addField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    for (Pair<TransientField, Field> pair : BaseHandler.extractAnnotatedFields(TransientField.class, inspectedClassNames)) {
        updateVmsStatic.addTransientFields(pair.getSecond().getName());
    }
    for (Pair<EditableHostedEngineField, Field> pair : BaseHandler.extractAnnotatedFields(EditableHostedEngineField.class, inspectedClassNames)) {
        updateVmsStatic.addHostedEngineFields(pair.getSecond().getName());
    }
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    cpuFlagsManagerHandler = Injector.get(CpuFlagsManagerHandler.class);
    vmDeviceUtils = Injector.get(VmDeviceUtils.class);
    osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    updateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        updateVmsStatic.addField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    for (Pair<TransientField, Field> pair : BaseHandler.extractAnnotatedFields(TransientField.class, inspectedClassNames)) {
        updateVmsStatic.addTransientFields(pair.getSecond().getName());
    }
    for (Pair<EditableVmField, Field> pair : BaseHandler.extractAnnotatedFields(EditableVmField.class, inspectedClassNames)) {
        EditableVmField annotation = pair.getFirst();
        List<VMStatus> statusList = Arrays.asList(annotation.onStatuses());
        String fieldName = pair.getSecond().getName();
        if (statusList.isEmpty()) {
            updateVmsStatic.addPermittedFields(fieldName);
        } else {
            updateVmsStatic.addField(statusList, fieldName);
            if (annotation.hotsetAllowed()) {
                updateVmsStatic.addHotsetFields(fieldName);
            }
        }
        if (annotation.onHostedEngine()) {
            updateVmsStatic.addHostedEngineFields(fieldName);
        }
    }
}
#end_block

#method_before
public static void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, Cluster cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS) {
        return;
    }
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), CompatibilityVersionUtils.getEffective(parametersStaticData, cluster));
    if (parametersStaticData.getDefaultDisplayType() != null && isDisplayTypeSupported(parametersStaticData.getDefaultDisplayType(), graphicsAndDisplays)) {
        return;
    }
    DisplayType defaultDisplayType = null;
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new LinkedHashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        if (entry.getValue().containsAll(VmHandler.getResultingVmGraphics(vmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId), graphicsDevices))) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    if (defaultDisplayType == null) {
        if (!displayGraphicsSupport.isEmpty()) {
            // when not found otherwise, let's take osinfo's record as the default
            Map.Entry<DisplayType, Set<GraphicsType>> entry = displayGraphicsSupport.entrySet().iterator().next();
            defaultDisplayType = entry.getKey();
        } else {
            // no osinfo record
            defaultDisplayType = DisplayType.qxl;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#method_after
public static void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, Cluster cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS) {
        return;
    }
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), CompatibilityVersionUtils.getEffective(parametersStaticData, cluster));
    if (parametersStaticData.getDefaultDisplayType() != null && isDisplayTypeSupported(parametersStaticData.getDefaultDisplayType(), graphicsAndDisplays)) {
        return;
    }
    DisplayType defaultDisplayType = null;
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new LinkedHashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        final List<GraphicsType> graphicsTypes = vmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId);
        final Set<GraphicsType> resultingVmGraphics = getResultingVmGraphics(graphicsTypes, graphicsDevices);
        if (entry.getValue().containsAll(resultingVmGraphics)) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    if (defaultDisplayType == null) {
        if (!displayGraphicsSupport.isEmpty()) {
            // when not found otherwise, let's take osinfo's record as the default
            Map.Entry<DisplayType, Set<GraphicsType>> entry = displayGraphicsSupport.entrySet().iterator().next();
            defaultDisplayType = entry.getKey();
        } else {
            // no osinfo record
            defaultDisplayType = DisplayType.qxl;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#end_block

#method_before
@Before
public void initTest() {
    mockCpuFlagsManagerHandler();
    mockOsRepository();
    doReturn(deviceDao).when(dbFacade).getVmDeviceDao();
}
#method_after
@Before
public void initTest() {
    mockCpuFlagsManagerHandler();
    mockOsRepository();
    doReturn(deviceDao).when(dbFacade).getVmDeviceDao();
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
    VmHandler.init();
}
#end_block

#method_before
protected void addPermissionSubjectForAdminLevelProperties(List<PermissionSubject> permissionList) {
    VmStatic vmFromParams = getParameters().getVmStaticData();
    if (vmFromParams != null && getVmTemplate() != null) {
        // user needs specific permission to change custom properties
        if (!Objects.equals(vmFromParams.getCustomProperties(), getVmTemplate().getCustomProperties())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        Set<Guid> dedicatedVmForVdsFromUser = new HashSet<>(vmFromParams.getDedicatedVmForVdsList());
        Set<Guid> dedicatedVmForVdsFromTemplate = new HashSet<>(getVmTemplate().getDedicatedVmForVdsList());
        // host-specific parameters can be changed by administration role only
        if (!dedicatedVmForVdsFromUser.equals(dedicatedVmForVdsFromTemplate) || !StringUtils.isEmpty(vmFromParams.getCpuPinning())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
}
#method_after
protected void addPermissionSubjectForAdminLevelProperties(List<PermissionSubject> permissionList) {
    VmStatic vmFromParams = getParameters().getVmStaticData();
    VmTemplate vmTemplate = getVmTemplate();
    if (vmFromParams != null && vmTemplate != null) {
        // user needs specific permission to change custom properties
        if (!Objects.equals(vmFromParams.getCustomProperties(), vmTemplate.getCustomProperties())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // if the template is blank we ignore his pinned hosts
        if (vmTemplate.isBlank()) {
            return;
        }
        Set<Guid> dedicatedVmForVdsFromUser = new HashSet<>(vmFromParams.getDedicatedVmForVdsList());
        Set<Guid> dedicatedVmForVdsFromTemplate = new HashSet<>(vmTemplate.getDedicatedVmForVdsList());
        // host-specific parameters can be changed by administration role only
        if (!dedicatedVmForVdsFromUser.equals(dedicatedVmForVdsFromTemplate) || !StringUtils.isEmpty(vmFromParams.getCpuPinning())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
}
#end_block

#method_before
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getCluster().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getCluster().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    autoSelectGraphicsDevice();
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getCluster().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getCluster().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    VmHandler.autoSelectGraphicsDevice(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices(), getEffectiveCompatibilityVersion());
}
#end_block

#method_before
protected DiskValidator createDiskValidator(DiskImage disk) {
    return new DiskValidator(disk, super.getVmDeviceUtils());
}
#method_after
protected DiskValidator createDiskValidator(DiskImage disk) {
    return new DiskValidator(disk, getVmDeviceUtils());
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_6;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    injectorRule.bind(DbFacade.class, dbFacade);
    injectorRule.bind(InClusterUpgradeValidator.class, inClusterUpgradeValidator);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setClusterId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public Cluster getCluster() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(VdcActionType.UpdateVm).when(command).getActionType();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
    vmDeviceUtils = new VmDeviceUtils(vmDao, vmDeviceDao, diskDao, clusterDao, vmTemplateDao);
    doReturn(vmDeviceUtils).when(command).getVmDeviceUtils();
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_6;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    injectorRule.bind(DbFacade.class, dbFacade);
    injectorRule.bind(InClusterUpgradeValidator.class, inClusterUpgradeValidator);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setClusterId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public Cluster getCluster() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(VdcActionType.UpdateVm).when(command).getActionType();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
    doReturn(vmDeviceUtils).when(command).getVmDeviceUtils();
}
#end_block

#method_before
public String buildMetadataDictionaryForVm(VM vm, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary, ArrayList<DiskImage> allVmImages) {
    String vmMeta = generateVmMetadata(vm, allVmImages);
    metaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, vm.getDiskMap().values().stream().map(BaseDisk::getId).collect(Collectors.toList())));
    return vmMeta;
}
#method_after
public String buildMetadataDictionaryForVm(VM vm, Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary, List<DiskImage> allVmImages) {
    String vmMeta = generateVmMetadata(vm, allVmImages);
    metaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, vm.getDiskMap().values().stream().map(BaseDisk::getId).collect(Collectors.toList())));
    return vmMeta;
}
#end_block

#method_before
protected String generateVmMetadata(VM vm, ArrayList<DiskImage> AllVmImages) {
    return ovfManager.exportVm(vm, AllVmImages, ClusterUtils.getCompatibilityVersion(vm));
}
#method_after
protected String generateVmMetadata(VM vm, List<DiskImage> AllVmImages) {
    return ovfManager.exportVm(vm, AllVmImages, ClusterUtils.getCompatibilityVersion(vm));
}
#end_block

#method_before
@Override
protected void incrementDbGeneration() {
    // and there's no need for exporting the template's ovf.
    if (getParameters().getTaskGroupSuccess()) {
        Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
        OvfUpdateProcessHelper ovfUpdateProcessHelper = new OvfUpdateProcessHelper(vmDeviceUtils);
        ovfUpdateProcessHelper.loadTemplateData(getVmTemplate());
        VmTemplateHandler.updateDisksFromDb(getVmTemplate());
        // update the target (export) domain
        ovfUpdateProcessHelper.buildMetadataDictionaryForTemplate(getVmTemplate(), metaDictionary);
        ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVmTemplate().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
    }
}
#method_after
@Override
protected void incrementDbGeneration() {
    // and there's no need for exporting the template's ovf.
    if (getParameters().getTaskGroupSuccess()) {
        Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
        OvfUpdateProcessHelper ovfUpdateProcessHelper = new OvfUpdateProcessHelper(getVmDeviceUtils());
        ovfUpdateProcessHelper.loadTemplateData(getVmTemplate());
        VmTemplateHandler.updateDisksFromDb(getVmTemplate());
        // update the target (export) domain
        ovfUpdateProcessHelper.buildMetadataDictionaryForTemplate(getVmTemplate(), metaDictionary);
        ovfUpdateProcessHelper.executeUpdateVmInSpmCommand(getVmTemplate().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        VmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), parameterMasterVm);
    }
}
#method_after
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getMasterVmCompatibilityVersion(), parameterMasterVm);
    }
}
#end_block

#method_before
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, LastTimeUsedAsMasterComp.instance);
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if (isHostedEngineDomain(dbStorageDomain)) {
            continue;
        }
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#method_after
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, Comparator.comparing(StorageDomain::getLastTimeUsedAsMaster));
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if (isHostedEngineDomain(dbStorageDomain)) {
            continue;
        }
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#end_block

#method_before
protected Map<String, VmHostDevice> getExistingVmHostDevicesByName() {
    List<VmDevice> existingDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    List<VmHostDevice> result = new ArrayList<>();
    for (VmDevice device : existingDevices) {
        result.add(new VmHostDevice(device));
    }
    return vmDeviceUtils.vmDevicesByDevice(result);
}
#method_after
protected Map<String, VmHostDevice> getExistingVmHostDevicesByName() {
    List<VmDevice> existingDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    List<VmHostDevice> result = new ArrayList<>();
    for (VmDevice device : existingDevices) {
        result.add(new VmHostDevice(device));
    }
    return getVmDeviceUtils().vmDevicesByDevice(result);
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    vmDeviceUtils.updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getCluster().getEmulatedMachine());
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    getVmDeviceUtils().updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getCluster().getEmulatedMachine());
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#end_block

#method_before
protected boolean isRunAsStateless() {
    return getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().isStateless();
}
#method_after
protected boolean isRunAsStateless() {
    return getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().getVmPoolId() == null && getVm().isStateless();
}
#end_block

#method_before
private void createNewDiskId() {
    Guid newDiskId = Guid.newGuid();
    getParameters().getDiskInfo().setId(newDiskId);
    if (!isFloatingDisk()) {
        getDiskVmElement().getId().setDeviceId(newDiskId);
    }
}
#method_after
private void createNewDiskId() {
    Guid diskId = getParameters().isUsePassedDiskId() ? getParameters().getDiskInfo().getId() : Guid.newGuid();
    getParameters().getDiskInfo().setId(diskId);
    if (!isFloatingDisk()) {
        getDiskVmElement().getId().setDeviceId(diskId);
    }
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        // The disk VM element has to be added before the VM device since as a part of the VM device creation the
        // boot order is determined so the VM device creation depends on the existance of the disk VM element
        getCompensationContext().snapshotEntity(addDiskVmElementForDisk(getDiskVmElement()));
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        // The disk VM element has to be added before the VM device since as a part of the VM device creation the
        // boot order is determined so the VM device creation depends on the existance of the disk VM element
        getCompensationContext().snapshotEntity(addDiskVmElementForDisk(getDiskVmElement()));
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
@Before
public void setUp() {
    // The VM to use
    Guid vmId = Guid.newGuid();
    Guid clusterId = Guid.newGuid();
    spId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    vm.setClusterId(clusterId);
    vm.setStoragePoolId(spId);
    vm.setVmOs(14);
    when(vmDao.get(vmId)).thenReturn(vm);
    // The cluster to use
    cluster = new Cluster();
    cluster.setCpuName("Intel Conroe Family");
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setId(clusterId);
    cluster.setStoragePoolId(spId);
    cluster.setCompatibilityVersion(Version.getLast());
    when(clusterDao.get(clusterId)).thenReturn(cluster);
    AddVmTemplateParameters params = new AddVmTemplateParameters(vm, "templateName", "Template for testing");
    mockOsRepository();
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    // Using the compensation constructor since the normal one contains DB access
    cmd = spy(new AddVmTemplateCommand<AddVmTemplateParameters>(params, CommandContext.createContext(params.getSessionId())) {

        @Override
        protected void initUser() {
        }

        @Override
        protected List<DiskImage> getVmDisksFromDB() {
            return getDisksList(spId);
        }

        @Override
        protected void updateVmDevices() {
        }

        @Override
        public VM getVm() {
            return vm;
        }

        @Override
        public void separateCustomProperties(VmStatic parameterMasterVm) {
        }
    });
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(clusterDao).when(cmd).getClusterDao();
    doReturn(vmDeviceUtils).when(cmd).getVmDeviceUtils();
    cmd.postConstruct();
    cmd.setVmId(vmId);
    cmd.setClusterId(clusterId);
}
#method_after
@Before
public void setUp() {
    // The VM to use
    Guid vmId = Guid.newGuid();
    Guid clusterId = Guid.newGuid();
    spId = Guid.newGuid();
    vm = new VM();
    vm.setId(vmId);
    vm.setClusterId(clusterId);
    vm.setStoragePoolId(spId);
    vm.setVmOs(14);
    when(vmDao.get(vmId)).thenReturn(vm);
    // The cluster to use
    cluster = new Cluster();
    cluster.setCpuName("Intel Conroe Family");
    cluster.setArchitecture(ArchitectureType.x86_64);
    cluster.setId(clusterId);
    cluster.setStoragePoolId(spId);
    cluster.setCompatibilityVersion(Version.getLast());
    when(clusterDao.get(clusterId)).thenReturn(cluster);
    AddVmTemplateParameters params = new AddVmTemplateParameters(vm, "templateName", "Template for testing");
    mockOsRepository();
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    doReturn(deviceDao).when(dbFacade).getVmDeviceDao();
    // Using the compensation constructor since the normal one contains DB access
    cmd = spy(new AddVmTemplateCommand<AddVmTemplateParameters>(params, CommandContext.createContext(params.getSessionId())) {

        @Override
        protected void initUser() {
        }

        @Override
        protected List<DiskImage> getVmDisksFromDB() {
            return getDisksList(spId);
        }

        @Override
        protected void updateVmDevices() {
        }

        @Override
        public VM getVm() {
            return vm;
        }

        @Override
        public void separateCustomProperties(VmStatic parameterMasterVm) {
        }
    });
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(clusterDao).when(cmd).getClusterDao();
    doReturn(vmDeviceUtils).when(cmd).getVmDeviceUtils();
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
    VmHandler.init();
    cmd.postConstruct();
    cmd.setVmId(vmId);
    cmd.setClusterId(clusterId);
}
#end_block

#method_before
protected void mockOsRepository() {
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    vmDeviceUtils.init();
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.getMinimumRam(vm.getVmOsId(), Version.getLast())).thenReturn(0);
    when(osRepository.getMaximumRam(vm.getVmOsId(), Version.getLast())).thenReturn(100);
    when(osRepository.getArchitectureFromOS(14)).thenReturn(ArchitectureType.x86_64);
}
#method_after
protected void mockOsRepository() {
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    vmDeviceUtils.init();
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.getMinimumRam(vm.getVmOsId(), Version.getLast())).thenReturn(0);
    when(osRepository.getMaximumRam(vm.getVmOsId(), Version.getLast())).thenReturn(100);
    when(osRepository.getArchitectureFromOS(14)).thenReturn(ArchitectureType.x86_64);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) {
        addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    ChangeVmClusterValidator validator = new ChangeVmClusterValidator(this, getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), vmDeviceUtils);
    return validator.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) {
        addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    ChangeVmClusterValidator validator = new ChangeVmClusterValidator(this, getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), getVmDeviceUtils());
    return validator.validate();
}
#end_block

#method_before
protected final void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        vmDeviceUtils.setVmDevices(getVmTemplate());
        VmHandler.updateVmInitFromDB(getVmTemplate(), true);
        incrementDbGeneration();
        VmTemplateHandler.unlockVmTemplate(getVmTemplateId());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full endAction");
    }
}
#method_after
protected final void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        getVmDeviceUtils().setVmDevices(getVmTemplate());
        VmHandler.updateVmInitFromDB(getVmTemplate(), true);
        incrementDbGeneration();
        VmTemplateHandler.unlockVmTemplate(getVmTemplateId());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full endAction");
    }
}
#end_block

#method_before
private void addImportedDevices(VM vm) {
    VmStatic vmStatic = vm.getStaticData();
    // Disk and network interface devices were already added
    vmStatic.setImages(new ArrayList<>());
    vmStatic.setInterfaces(new ArrayList<>());
    ImportUtils.updateGraphicsDevices(vmStatic, getStoragePool().getCompatibilityVersion());
    vmDeviceUtils.addImportedDevices(vmStatic, false);
    saveDiskVmElements(vm);
    getVmDeviceDao().updateBootOrderInBatch(new ArrayList<>(vm.getManagedVmDeviceMap().values()));
}
#method_after
private void addImportedDevices(VM vm) {
    VmStatic vmStatic = vm.getStaticData();
    // Disk and network interface devices were already added
    vmStatic.setImages(new ArrayList<>());
    vmStatic.setInterfaces(new ArrayList<>());
    ImportUtils.updateGraphicsDevices(vmStatic, getStoragePool().getCompatibilityVersion());
    getVmDeviceUtils().addImportedDevices(vmStatic, false);
    saveDiskVmElements(vm);
    getVmDeviceDao().updateBootOrderInBatch(new ArrayList<>(vm.getManagedVmDeviceMap().values()));
}
#end_block

#method_before
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmImagesAndSnapshots();
        addMemoryImages();
        updateSnapshotsFromExport();
        if (useCopyImages) {
            moveOrCopyAllImageGroups();
        }
        vmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
        if (getParameters().isImportAsNewEntity()) {
            getParameters().setVm(getVm());
            setVmId(getVm().getId());
        }
        return null;
    });
}
#method_after
private void processImages(final boolean useCopyImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        addVmImagesAndSnapshots();
        addMemoryImages();
        updateSnapshotsFromExport();
        if (useCopyImages) {
            moveOrCopyAllImageGroups();
        }
        getVmDeviceUtils().addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
        if (getParameters().isImportAsNewEntity()) {
            getParameters().setVm(getVm());
            setVmId(getVm().getId());
        }
        return null;
    });
}
#end_block

#method_before
@Override
protected void addVmInterfaces() {
    super.addVmInterfaces();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        vmDeviceUtils.addInterface(getVmId(), iface.getId(), iface.isPlugged(), false);
    }
}
#method_after
@Override
protected void addVmInterfaces() {
    super.addVmInterfaces();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        getVmDeviceUtils().addInterface(getVmId(), iface.getId(), iface.isPlugged(), false);
    }
}
#end_block

#method_before
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, diskVmElements, vmDeviceUtils.hasVirtioScsiController(getVmId()), vmDeviceUtils.hasWatchdog(getVmId()), vmDeviceUtils.hasMemoryBalloon(getVmId()), vmDeviceUtils.hasSoundDevice(getVmId()), getReturnValue().getValidationMessages());
}
#method_after
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<DiskVmElement> diskVmElements = getDiskVmElementDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, diskVmElements, getVmDeviceUtils().hasVirtioScsiController(getVmId()), getVmDeviceUtils().hasWatchdog(getVmId()), getVmDeviceUtils().hasMemoryBalloon(getVmId()), getVmDeviceUtils().hasSoundDevice(getVmId()), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
@Before
public void setUp() {
    super.setUp();
    ImportRepoImageParameters importParameters = new ImportRepoImageParameters();
    importParameters.setSourceRepoImageId(getRepoImageId());
    importParameters.setSourceStorageDomainId(getRepoStorageDomainId());
    importParameters.setStoragePoolId(getStoragePoolId());
    importParameters.setStorageDomainId(getStorageDomainId());
    cmd = spy(new ImportRepoImageCommand<ImportRepoImageParameters>(importParameters, null) {

        @Override
        protected VmDeviceUtils getVmDeviceUtils() {
            return vmDeviceUtils;
        }
    });
    doReturn(getStorageDomainDao()).when(cmd).getStorageDomainDao();
    doReturn(getStoragePoolDao()).when(cmd).getStoragePoolDao();
    doReturn(getProviderProxy()).when(cmd).getProviderProxy();
    doReturn(true).when(cmd).validateSpaceRequirements(any(DiskImage.class));
}
#method_after
@Override
@Before
public void setUp() {
    super.setUp();
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
    ImportRepoImageParameters importParameters = new ImportRepoImageParameters();
    importParameters.setSourceRepoImageId(getRepoImageId());
    importParameters.setSourceStorageDomainId(getRepoStorageDomainId());
    importParameters.setStoragePoolId(getStoragePoolId());
    importParameters.setStorageDomainId(getStorageDomainId());
    cmd = spy(new ImportRepoImageCommand<>(importParameters, null));
    doReturn(getStorageDomainDao()).when(cmd).getStorageDomainDao();
    doReturn(getStoragePoolDao()).when(cmd).getStoragePoolDao();
    doReturn(getProviderProxy()).when(cmd).getProviderProxy();
    doReturn(true).when(cmd).validateSpaceRequirements(any(DiskImage.class));
}
#end_block

#method_before
private TransactionMethod<Void> updateDevice() {
    return () -> {
        vmDevice.setIsPlugged(getParameters().getAction() == PlugAction.PLUG);
        getVmDeviceDao().update(vmDevice);
        vmDeviceUtils.updateBootOrder(getVm().getId());
        return null;
    };
}
#method_after
private TransactionMethod<Void> updateDevice() {
    return () -> {
        vmDevice.setIsPlugged(getParameters().getAction() == PlugAction.PLUG);
        getVmDeviceDao().update(vmDevice);
        getVmDeviceUtils().updateBootOrder(getVm().getId());
        return null;
    };
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean success = true;
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        VmHandler.addVmInitToDB(getVmTemplate());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    vmDeviceUtils.addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    checkTrustedService();
    setSucceeded(success);
}
#method_after
@Override
protected void executeCommand() {
    boolean success = true;
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        VmHandler.addVmInitToDB(getVmTemplate());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    checkTrustedService();
    setSucceeded(success);
}
#end_block

#method_before
private void addInterfaceDeviceToDb() {
    VmDevice vmDevice = vmDeviceUtils.addInterface(getParameters().getVmId(), getInterface().getId(), getInterface().isPlugged(), getInterface().isPassthrough());
    getCompensationContext().snapshotNewEntity(vmDevice);
}
#method_after
private void addInterfaceDeviceToDb() {
    VmDevice vmDevice = getVmDeviceUtils().addInterface(getParameters().getVmId(), getInterface().getId(), getInterface().isPlugged(), getInterface().isPassthrough());
    getCompensationContext().snapshotNewEntity(vmDevice);
}
#end_block

#method_before
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion(), vmDeviceUtils);
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#method_after
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion(), getVmDeviceUtils());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.newGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getVmNicDao().save(getParameters().getInterface());
    vmDeviceUtils.addInterface(getParameters().getVmTemplateId(), getParameters().getInterface().getId(), getParameters().getInterface().isPlugged(), getParameters().getInterface().isPassthrough());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.newGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getVmNicDao().save(getParameters().getInterface());
    getVmDeviceUtils().addInterface(getParameters().getVmTemplateId(), getParameters().getInterface().getId(), getParameters().getInterface().isPlugged(), getParameters().getInterface().isPassthrough());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getOsId(), getCluster().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, getTemplateDiskVmElements(), vmDeviceUtils.hasVirtioScsiController(getVmTemplate().getId()), vmDeviceUtils.hasWatchdog(getVmTemplate().getId()), vmDeviceUtils.hasMemoryBalloon(getVmTemplate().getId()), vmDeviceUtils.hasSoundDevice(getVmTemplate().getId()), getReturnValue().getValidationMessages())) {
            return false;
        }
        Version clusterCompatibilityVersion = getCluster().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        return validate(nicValidator.isCompatibleWithOs()) && validate(nicValidator.profileValid(getVmTemplate().getClusterId())) && validate(nicValidator.typeMatchesProfile()) && validate(nicValidator.passthroughIsLinked());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getOsId(), getCluster().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, getTemplateDiskVmElements(), getVmDeviceUtils().hasVirtioScsiController(getVmTemplate().getId()), getVmDeviceUtils().hasWatchdog(getVmTemplate().getId()), getVmDeviceUtils().hasMemoryBalloon(getVmTemplate().getId()), getVmDeviceUtils().hasSoundDevice(getVmTemplate().getId()), getReturnValue().getValidationMessages())) {
            return false;
        }
        Version clusterCompatibilityVersion = getCluster().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        return validate(nicValidator.isCompatibleWithOs()) && validate(nicValidator.profileValid(getVmTemplate().getClusterId())) && validate(nicValidator.typeMatchesProfile()) && validate(nicValidator.passthroughIsLinked());
    }
    return true;
}
#end_block

#method_before
protected boolean updateVmInSpm() {
    OvfUpdateProcessHelper ovfHelper = new OvfUpdateProcessHelper(vmDeviceUtils);
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfHelper.loadVmData(getVm());
    ovfHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, ovfHelper.getVmImagesFromDb(getVm()));
    return ovfHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#method_after
protected boolean updateVmInSpm() {
    OvfUpdateProcessHelper ovfHelper = new OvfUpdateProcessHelper(getVmDeviceUtils());
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<>();
    ovfHelper.loadVmData(getVm());
    ovfHelper.buildMetadataDictionaryForVm(getVm(), metaDictionary, ovfHelper.getVmImagesFromDb(getVm()));
    return ovfHelper.executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#end_block

#method_before
private void populateVmData(VM vm) {
    VmHandler.updateDisksFromDb(vm);
    VmHandler.updateVmInitFromDB(vm.getStaticData(), true);
    vmDeviceUtils.setVmDevices(vm.getStaticData());
}
#method_after
private void populateVmData(VM vm) {
    VmHandler.updateDisksFromDb(vm);
    VmHandler.updateVmInitFromDB(vm.getStaticData(), true);
    getVmDeviceUtils().setVmDevices(vm.getStaticData());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setupParameters();
    persistCommand(getParameters().getParentCommand(), true);
    Backend.getInstance().runInternalAction(VdcActionType.AddDisk, createAddDiskParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    getParameters().setNextPhase(ImportRepoImageParameters.Phase.DOWNLOAD);
    persistCommand(getParameters().getParentCommand(), true);
    setSucceeded(true);
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VM getVmEntity() {
    org.ovirt.engine.core.common.businessentities.VM entity = control.createMock(org.ovirt.engine.core.common.businessentities.VM.class);
    expect(entity.getId()).andReturn(GUIDS[0]).anyTimes();
    expect(entity.getStaticData()).andReturn(new VmStatic());
    expect(entity.getDedicatedVmForVdsList()).andReturn(Collections.emptyList()).anyTimes();
    // expect(entity.getVmType()).andReturn(VmType.Server).anyTimes();
    return entity;
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VM getVmEntity() {
    org.ovirt.engine.core.common.businessentities.VM entity = control.createMock(org.ovirt.engine.core.common.businessentities.VM.class);
    expect(entity.getId()).andReturn(GUIDS[0]).anyTimes();
    expect(entity.getStaticData()).andReturn(new VmStatic());
    expect(entity.getDedicatedVmForVdsList()).andReturn(Collections.emptyList()).anyTimes();
    return entity;
}
#end_block

#method_before
private void handleForwardMerge(DiskImage topImage, DiskImage baseImage, DiskImage imageFromVdsm) {
    // For forward merge, the volume format and type may change.
    topImage.setVolumeFormat(baseImage.getVolumeFormat());
    topImage.setVolumeType(baseImage.getVolumeType());
    topImage.setParentId(baseImage.getParentId());
    getDestinationDiskImage().setSize(baseImage.getSize());
    getDestinationDiskImage().setActualSizeInBytes(getImageInfoFromVdsm(getDestinationDiskImage()).getActualSizeInBytes());
    topImage.setImageStatus(ImageStatus.OK);
    getBaseDiskDao().update(topImage);
    getImageDao().update(topImage.getImage());
    updateDiskImageDynamic(imageFromVdsm, topImage);
    updateVmConfigurationForImageChange(getDestinationDiskImage().getImage().getSnapshotId(), getDestinationDiskImage().getImageId(), getDestinationDiskImage());
}
#method_after
private void handleForwardMerge(DiskImage topImage, DiskImage baseImage, DiskImage imageFromVdsm) {
    // For forward merge, the volume format and type may change.
    topImage.setVolumeFormat(baseImage.getVolumeFormat());
    topImage.setVolumeType(baseImage.getVolumeType());
    topImage.setParentId(baseImage.getParentId());
    getDestinationDiskImage().setSize(baseImage.getSize());
    getDestinationDiskImage().setActualSizeInBytes(getImageInfoFromVdsm(getDestinationDiskImage()).getActualSizeInBytes());
    getBaseDiskDao().update(topImage);
    getImageDao().update(topImage.getImage());
    updateDiskImageDynamic(imageFromVdsm, topImage);
    updateVmConfigurationForImageChange(getDestinationDiskImage().getImage().getSnapshotId(), getDestinationDiskImage().getImageId(), getDestinationDiskImage());
}
#end_block

#method_before
@Override
public ValidationResult validateAddProvider() {
    ValidationResult result = validatePluginType();
    if (!result.isValid()) {
        return result;
    }
    if (!(result = validateAuthentication()).isValid()) {
        return result;
    }
    return super.validateAddProvider();
}
#method_after
@Override
public ValidationResult validateAddProvider() {
    ValidationResult result = validatePluginType();
    if (!result.isValid()) {
        return result;
    }
    result = validateAuthentication();
    if (!result.isValid()) {
        return result;
    }
    return super.validateAddProvider();
}
#end_block

#method_before
@Override
public ProviderValidator getProviderValidator() {
    if (networkProviderValidator == null) {
        networkProviderValidator = new NetworkProviderValidator(provider);
    }
    return networkProviderValidator;
}
#method_after
@Override
public ProviderValidator getProviderValidator() {
    return new NetworkProviderValidator(provider);
}
#end_block

#method_before
@Override
public String convertPrefixToNetmask(String prefix) {
    prefix = removeTrailingSlashFromNetmaskIfPresent(prefix);
    int prefixAsInt = Integer.parseInt(prefix);
    int mask = prefixAsInt == 0 ? 0 : 0xffffffff ^ (1 << 32 - prefixAsInt) - 1;
    byte[] netmaskByteArray = new byte[] { (byte) (mask >>> 24), (byte) (mask >>> 16), (byte) (mask >>> 8), (byte) mask };
    StringBuilder stringBuilder = new StringBuilder();
    for (int i = 0; i < netmaskByteArray.length; i++) {
        int octet = 0xFF & netmaskByteArray[i];
        stringBuilder.append(".").append(octet);
    }
    return stringBuilder.substring(1);
}
#method_after
@Override
public String convertPrefixToNetmask(String prefix) {
    prefix = removeLeadingSlashFromNetmaskIfPresent(prefix);
    int prefixAsInt = Integer.parseInt(prefix);
    int mask = prefixAsInt == 0 ? 0 : 0xffffffff ^ (1 << 32 - prefixAsInt) - 1;
    byte[] netmaskByteArray = new byte[] { (byte) (mask >>> 24), (byte) (mask >>> 16), (byte) (mask >>> 8), (byte) mask };
    StringBuilder stringBuilder = new StringBuilder();
    for (int i = 0; i < netmaskByteArray.length; i++) {
        int octet = 0xFF & netmaskByteArray[i];
        stringBuilder.append(".").append(octet);
    }
    return stringBuilder.substring(1);
}
#end_block

#method_before
@Override
public void handleFailure() {
    log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
}
#method_after
@Override
public void handleFailure() {
    log.error("Command id: '{} failed child command status for step '{}'", getCommandId(), getParameters().getCommandStep());
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
        if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
            log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
            getParameters().setCommandStep(getParameters().getNextCommandStep());
        } else {
            if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
                getParameters().setCommandStep(getParameters().getNextCommandStep());
            } else {
                log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value");
                setCommandStatus(CommandStatus.FAILED);
                return false;
            }
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue(vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue(vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    // Handle first execution based on vm status, and recovery based on isLiveMerge (VM may be down)
    if (isLiveMerge()) {
        return new RemoveDiskSnapshotsCommandCallback();
    } else if (getParameters().isUseCinderCommandCallback()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return null;
}
#method_after
@Override
public CommandCallback getCallback() {
    // Handle first execution based on vm status, and recovery based on isLiveMerge (VM may be down)
    if (isLiveMerge()) {
        return new SerialChildCommandsExecutionCallback();
    } else if (getParameters().isUseCinderCommandCallback()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return null;
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildren) {
    if (completedChildren == getParameters().getImageIds().size()) {
        return false;
    }
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        checkImageIdConsistency(completedChildren - 1);
    }
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskLiveParameters(imageId);
    parameters.setShouldBeEndedByParent(false);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, parameters, cloneContextAndDetachFromParent());
    return true;
}
#method_after
@Override
public boolean performNextOperation(int completedChildren) {
    if (completedChildren == getParameters().getImageIds().size()) {
        return false;
    }
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        checkImageIdConsistency(completedChildren - 1);
    }
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskLiveParameters(imageId);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, parameters, cloneContextAndDetachFromParent());
    return true;
}
#end_block

#method_before
private RemoveAllVmCinderDisksParameters buildRemoveCinderSnapshotDiskParameters(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters params = new RemoveAllVmCinderDisksParameters();
    params.setCinderDisks(cinderDisks);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSessionId(getParameters().getSessionId());
    params.setInvokeEndActionOnParent(false);
    params.setShouldBeEndedByParent(false);
    return params;
}
#method_after
private RemoveAllVmCinderDisksParameters buildRemoveCinderSnapshotDiskParameters(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters params = new RemoveAllVmCinderDisksParameters();
    params.setCinderDisks(cinderDisks);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSessionId(getParameters().getSessionId());
    params.setInvokeEndActionOnParent(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            if (!hasTaskHandlers() && !getParameters().isUseCinderCommandCallback()) {
                return getParameters().getTaskGroupSuccess() ? AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS : AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
            }
            if (isFirstTaskHandler() && getSucceeded()) {
                return AuditLogType.USER_REMOVE_DISK_SNAPSHOT;
            }
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_FAILED_REMOVE_DISK_SNAPSHOT;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            if (!hasTaskHandlers() && !getParameters().isUseCinderCommandCallback()) {
                return getParameters().getTaskGroupSuccess() ? AuditLogType.USER_REMOVE_DISK_SNAPSHOT : AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
            }
            if (isFirstTaskHandler() && getSucceeded()) {
                return AuditLogType.USER_REMOVE_DISK_SNAPSHOT;
            }
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_FAILED_REMOVE_DISK_SNAPSHOT;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        map(model.getProtocol(), entity);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetSpm()) {
        if (model.getSpm().getPriority() != null) {
            entity.setVdsSpmPriority(model.getSpm().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetExternalHostProvider()) {
        String providerId = model.getExternalHostProvider().getId();
        entity.setHostProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    if (model.isSetCertificate()) {
        entity.setCertificateSubject(model.getCertificate().getSubject());
    }
    if (model.isSetOs()) {
        map(model.getOs(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.setHostName(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setPort(model.getPort());
    } else {
        entity.setPort(DEFAULT_VDSM_PORT);
    }
    if (model.isSetProtocol()) {
        map(model.getProtocol(), entity);
    }
    if (model.isSetSsh()) {
        map(model.getSsh(), entity);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetSpm()) {
        if (model.getSpm().getPriority() != null) {
            entity.setVdsSpmPriority(model.getSpm().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetExternalHostProvider()) {
        String providerId = model.getExternalHostProvider().getId();
        entity.setHostProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    if (model.isSetCertificate()) {
        entity.setCertificateSubject(model.getCertificate().getSubject());
    }
    if (model.isSetOs()) {
        mapOperatingSystem(model.getOs(), entity);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    model.setProtocol(map(entity.getProtocol(), null));
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(status);
    if (entity.getExternalStatus() != null) {
        ExternalStatus externalStatus = ExternalStatusMapper.map(entity.getExternalStatus());
        model.setExternalStatus(externalStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.setStatusDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.setStatusDetail(entity.getMaintenanceReason());
    }
    Spm spm = new Spm();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(mapSpmStatus(entity.getSpmStatus()));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(map(entity, (HostOperatingSystem) null));
    model.setKsm(new Ksm());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), null));
    Cpu cpu = new Cpu();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSeLinux(map(entity, (SeLinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    if (entity.getCertificateSubject() != null) {
        String subject = entity.getCertificateSubject();
        model.setCertificate(new Certificate());
        model.getCertificate().setSubject(subject);
        model.getCertificate().setOrganization(subject.split(",")[0].replace("O=", ""));
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    model.setProtocol(map(entity.getProtocol(), null));
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(status);
    if (entity.getExternalStatus() != null) {
        ExternalStatus externalStatus = ExternalStatusMapper.map(entity.getExternalStatus());
        model.setExternalStatus(externalStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.setStatusDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.setStatusDetail(entity.getMaintenanceReason());
    }
    Spm spm = new Spm();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(mapSpmStatus(entity.getSpmStatus()));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(mapOperatingSystem(entity));
    model.setKsm(new Ksm());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), null));
    Cpu cpu = new Cpu();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSeLinux(map(entity, (SeLinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    if (entity.getCertificateSubject() != null) {
        String subject = entity.getCertificateSubject();
        model.setCertificate(new Certificate());
        model.getCertificate().setSubject(subject);
        model.getCertificate().setOrganization(subject.split(",")[0].replace("O=", ""));
    }
    return model;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId()));
    // and the vm will still be usable with previous version
    if (!result.getSucceeded() && !result.isValid()) {
        log.warn("Couldn't update VM '{}' ({}) version from it's template, continue with restoring stateless snapshot.", getVm().getName(), getVmId());
        setSucceeded(restoreInitialState());
    } else {
        setSucceeded(result.getSucceeded());
    }
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.UpdateVmVersion, buildUpdateVmVersionParameters());
    // and the vm will still be usable with previous version
    if (!result.getSucceeded() && !result.isValid()) {
        log.warn("Couldn't update VM '{}' ({}) version from it's template, continue with restoring stateless snapshot.", getVm().getName(), getVmId());
        setSucceeded(restoreInitialState());
    } else {
        setSucceeded(result.getSucceeded());
    }
}
#end_block

#method_before
protected void addPermissionSubjectForAdminLevelProperties(List<PermissionSubject> permissionList) {
    VmStatic vmFromParams = getParameters().getVmStaticData();
    VmTemplate vmTemplate = getVmTemplate();
    if (vmFromParams != null && vmTemplate != null && !vmTemplate.isBlank()) {
        // user needs specific permission to change custom properties
        if (!Objects.equals(vmFromParams.getCustomProperties(), vmTemplate.getCustomProperties())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        Set<Guid> dedicatedVmForVdsFromUser = new HashSet<>(vmFromParams.getDedicatedVmForVdsList());
        Set<Guid> dedicatedVmForVdsFromTemplate = new HashSet<>(vmTemplate.getDedicatedVmForVdsList());
        // host-specific parameters can be changed by administration role only
        if (!dedicatedVmForVdsFromUser.equals(dedicatedVmForVdsFromTemplate) || !StringUtils.isEmpty(vmFromParams.getCpuPinning())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
}
#method_after
protected void addPermissionSubjectForAdminLevelProperties(List<PermissionSubject> permissionList) {
    VmStatic vmFromParams = getParameters().getVmStaticData();
    VmTemplate vmTemplate = getVmTemplate();
    if (vmFromParams != null && vmTemplate != null) {
        // user needs specific permission to change custom properties
        if (!Objects.equals(vmFromParams.getCustomProperties(), vmTemplate.getCustomProperties())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // if the template is blank we ignore his pinned hosts
        if (vmTemplate.isBlank()) {
            return;
        }
        Set<Guid> dedicatedVmForVdsFromUser = new HashSet<>(vmFromParams.getDedicatedVmForVdsList());
        Set<Guid> dedicatedVmForVdsFromTemplate = new HashSet<>(vmTemplate.getDedicatedVmForVdsList());
        // host-specific parameters can be changed by administration role only
        if (!dedicatedVmForVdsFromUser.equals(dedicatedVmForVdsFromTemplate) || !StringUtils.isEmpty(vmFromParams.getCpuPinning())) {
            permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
}
#end_block

#method_before
private void updateLabelList() {
    AsyncQuery getLabelsQuery = new AsyncQuery();
    getLabelsQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            final List<Label> allLabels = (List<Label>) result;
            boolean isAnyTemplateBehavior = getBehavior().isAnyTemplateBehavior() || getBehavior().isNewTemplateBehavior();
            if (getIsNew() || isAnyTemplateBehavior) {
                labelList.setItems(allLabels);
                labelList.setSelectedItems(new ArrayList<Label>());
            } else {
                AsyncQuery getLabelsByVmIdQuery = new AsyncQuery();
                getLabelsByVmIdQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        List<Label> vmLabelsList = (List<Label>) returnValue;
                        labelList.setItems(allLabels);
                        labelList.setSelectedItems(vmLabelsList);
                    }
                };
                Guid vmId = ((ExistingVmModelBehavior) getBehavior()).getVm().getId();
                AsyncDataProvider.getInstance().getLabelListByEntityId(getLabelsByVmIdQuery, vmId);
            }
            labelList.setIsChangeable(false);
        }
    };
    AsyncDataProvider.getInstance().getLabelList(getLabelsQuery);
}
#method_after
private void updateLabelList() {
    AsyncQuery getLabelsQuery = new AsyncQuery();
    getLabelsQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            final List<Label> allLabels = (List<Label>) result;
            boolean isExistingVmBehavior = getBehavior() instanceof ExistingVmModelBehavior;
            if (isExistingVmBehavior) {
                AsyncQuery getLabelsByVmIdQuery = new AsyncQuery();
                getLabelsByVmIdQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        List<Label> vmLabelsList = (List<Label>) returnValue;
                        labelList.setItems(allLabels);
                        labelList.setSelectedItems(vmLabelsList);
                    }
                };
                Guid vmId = ((ExistingVmModelBehavior) getBehavior()).getVm().getId();
                AsyncDataProvider.getInstance().getLabelListByEntityId(getLabelsByVmIdQuery, vmId);
            } else {
                labelList.setItems(allLabels);
                labelList.setSelectedItems(new ArrayList<Label>());
            }
            labelList.setIsChangeable(false);
        }
    };
    AsyncDataProvider.getInstance().getLabelList(getLabelsQuery);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public void initModelSortHandler(final SortedListModel<T> sortedModel) {
    final SearchableListModel<?, T> searchableModel = (sortedModel instanceof SearchableListModel) ? (SearchableListModel<?, T>) sortedModel : null;
    addColumnSortHandler(new ColumnSortEvent.Handler() {

        @Override
        public void onColumnSort(ColumnSortEvent event) {
            Column<?, ?> column = event.getColumn();
            if (column instanceof SortableColumn) {
                SortableColumn<T, ?> sortableColumn = (SortableColumn<T, ?>) column;
                boolean sortApplied = false;
                // Apply server-side sorting, if supported by the model
                if (searchableModel != null && searchableModel.supportsServerSideSorting()) {
                    /*
                         * If we support both server side and client side, we need to enabled server side,
                         * but later if we use client side, we actually never apply the comparator.
                         * So if server side is supported and we have created comparator, do client side sorting.
                         */
                    Comparator<? super T> comparator = sortableColumn.getComparator();
                    if (comparator != null) {
                        sortedModel.setComparator(comparator, event.isSortAscending());
                        sortApplied = true;
                    } else {
                        sortedModel.setComparator(null);
                        if (searchableModel.isSearchValidForServerSideSorting()) {
                            searchableModel.updateSortOptions(sortableColumn.getSortBy(), event.isSortAscending());
                            sortApplied = true;
                        } else {
                            searchableModel.clearSortOptions();
                        }
                    }
                } else // Otherwise, fall back to client-side sorting
                {
                    Comparator<? super T> comparator = sortableColumn.getComparator();
                    if (comparator != null) {
                        sortedModel.setComparator(comparator, event.isSortAscending());
                        sortApplied = true;
                        // SortedListModel.setComparator does not sort the items
                        if (searchableModel == null) {
                            sortedModel.setItems(sortedModel.getItems());
                        }
                    }
                }
                // Update column sort status, redrawing table headers if necessary
                ColumnSortInfo columnSortInfo = event.getColumnSortList().get(0);
                if (sortApplied) {
                    pushColumnSort(columnSortInfo);
                } else {
                    clearColumnSort();
                }
            }
        }
    });
}
#method_after
@SuppressWarnings("unchecked")
public void initModelSortHandler(final SortedListModel<T> sortedModel) {
    final SearchableListModel<?, T> searchableModel = (sortedModel instanceof SearchableListModel) ? (SearchableListModel<?, T>) sortedModel : null;
    addColumnSortHandler(new ColumnSortEvent.Handler() {

        @Override
        public void onColumnSort(ColumnSortEvent event) {
            Column<?, ?> column = event.getColumn();
            if (column instanceof SortableColumn) {
                SortableColumn<T, ?> sortableColumn = (SortableColumn<T, ?>) column;
                boolean sortApplied = false;
                Comparator<? super T> comparator = sortableColumn.getComparator();
                boolean supportsServerSideSorting = searchableModel != null && searchableModel.supportsServerSideSorting();
                // uses Comparator for client-side sorting, use client-side sorting
                if (supportsServerSideSorting && comparator != null) {
                    sortedModel.setComparator(comparator, event.isSortAscending());
                    sortApplied = true;
                } else // update model's sort options and reload its items via search query
                if (supportsServerSideSorting) {
                    sortedModel.setComparator(null);
                    if (searchableModel.isSearchValidForServerSideSorting()) {
                        searchableModel.updateSortOptions(sortableColumn.getSortBy(), event.isSortAscending());
                        sortApplied = true;
                    } else {
                        // Search string not valid, cannot perform search query
                        searchableModel.clearSortOptions();
                    }
                } else // Otherwise, fall back to client-side sorting
                if (comparator != null) {
                    sortedModel.setComparator(comparator, event.isSortAscending());
                    sortApplied = true;
                    // SortedListModel.setComparator does not sort the items
                    if (searchableModel == null) {
                        sortedModel.setItems(sortedModel.getItems());
                    }
                }
                // Update column sort status, redrawing table headers if necessary
                ColumnSortInfo columnSortInfo = event.getColumnSortList().get(0);
                if (sortApplied) {
                    pushColumnSort(columnSortInfo);
                } else {
                    clearColumnSort();
                }
            }
        }
    });
}
#end_block

#method_before
private String getTemplateVersionNameAndNumber(VmTemplate template) {
    if (template.isBaseTemplate()) {
        // $NON-NLS-1$
        return "";
    }
    return // $NON-NLS-1$
    StringFormat.format(// $NON-NLS-1$
    " (Version: %s (%s))", // $NON-NLS-1$
    template.getTemplateVersionName() != null ? template.getTemplateVersionName() : "", template.getTemplateVersionNumber());
}
#method_after
private String getTemplateVersionNameAndNumber(VmTemplate template) {
    if (template.isBaseTemplate()) {
        // $NON-NLS-1$
        return "";
    }
    return // $NON-NLS-1$
    messages.templateVersionNameAndNumber(// $NON-NLS-1$
    template.getTemplateVersionName() != null ? template.getTemplateVersionName() : "", template.getTemplateVersionNumber());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVds() == null) {
        return failValidation(EngineMessage.VDS_NOT_EXIST);
    }
    if (!getVds().getClusterSupportsVirtService()) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_CLUSTER_DOES_NOT_SUPPORT_VIRT_SERVICES);
    }
    if (getVds().getStatus() != VDSStatus.Up) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
    }
    if (getStoragePoolForVds() == null) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
    }
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
    }
    if (getVds().getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
    }
    if (!validate(new StoragePoolValidator(getStoragePoolForVds()).isUp())) {
        return false;
    }
    if (isAsyncTasksRunningOnPool(getStoragePoolForVds().getId())) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVds() == null) {
        return failValidation(EngineMessage.VDS_NOT_EXIST);
    }
    if (!getVds().getClusterSupportsVirtService()) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_HOST_DOES_NOT_SUPPORT_VIRT_SERVICES);
    }
    if (getVds().getStatus() != VDSStatus.Up) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
    }
    if (getStoragePoolForVds() == null) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
    }
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
    }
    if (getVds().getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
    }
    if (!validate(new StoragePoolValidator(getStoragePoolForVds()).isUp())) {
        return false;
    }
    if (isAsyncTasksRunningOnPool(getStoragePoolForVds().getId())) {
        return failValidation(EngineMessage.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
    }
    return true;
}
#end_block

#method_before
@Test
public void testCDAVDSDoesNotSupportVirtServices() {
    vds.setId(Guid.newGuid());
    vds.setClusterSupportsVirtService(false);
    ValidateTestUtils.runAndAssertValidateFailure("validate did not fail on cluster withou virt services", command, EngineMessage.CANNOT_FORCE_SELECT_SPM_CLUSTER_DOES_NOT_SUPPORT_VIRT_SERVICES);
}
#method_after
@Test
public void testCDAVDSDoesNotSupportVirtServices() {
    vds.setId(Guid.newGuid());
    vds.setClusterSupportsVirtService(false);
    ValidateTestUtils.runAndAssertValidateFailure("validate did not fail on host without virt services", command, EngineMessage.CANNOT_FORCE_SELECT_SPM_HOST_DOES_NOT_SUPPORT_VIRT_SERVICES);
}
#end_block

#method_before
private void createVDSandStoragePool() {
    vds = new VDS();
    vds.setId(vdsId);
    vds.setVdsName("TestVDS");
    vds.setStoragePoolId(storagePoolId);
    vds.setStatus(VDSStatus.Up);
    vds.setSpmStatus(VdsSpmStatus.None);
    vds.setVdsSpmPriority(10);
    storagePool = new StoragePool();
    storagePool.setId(storagePoolId);
    storagePool.setStatus(StoragePoolStatus.Up);
}
#method_after
private void createVDSandStoragePool() {
    vds = new VDS();
    vds.setId(vdsId);
    vds.setVdsName("TestVDS");
    vds.setStoragePoolId(storagePoolId);
    vds.setStatus(VDSStatus.Up);
    vds.setClusterSupportsVirtService(true);
    vds.setSpmStatus(VdsSpmStatus.None);
    vds.setVdsSpmPriority(10);
    storagePool = new StoragePool();
    storagePool.setId(storagePoolId);
    storagePool.setStatus(StoragePoolStatus.Up);
}
#end_block

#method_before
public void setDefaultInterface() {
    Guid vmId = getVmId();
    if (!Guid.isNullOrEmpty(vmId)) {
        getDiskInterface().setSelectedItem(getDisk().getDiskVmElementForVm(vmId).getDiskInterface());
    } else {
        getDiskInterface().setSelectedItem(DiskInterface.VirtIO);
    }
}
#method_after
public void setDefaultInterface() {
    Guid vmId = getVmId();
    if (Guid.isNullOrEmpty(vmId)) {
        getDiskInterface().setSelectedItem(DiskInterface.VirtIO);
    } else {
        getDiskInterface().setSelectedItem(getDisk().getDiskVmElementForVm(vmId).getDiskInterface());
    }
}
#end_block

#method_before
public void restartGluster() {
    // call restart gluster
    GlusterServiceParameters parameters = new GlusterServiceParameters(getEntity().getClusterId(), getEntity().getId(), ServiceType.GLUSTER, // $NON-NLS-1$
    "restart");
    Frontend.getInstance().runMultipleAction(VdcActionType.ManageGlusterService, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { parameters })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
public void restartGluster() {
    // call restart gluster
    GlusterServiceParameters parameters = new GlusterServiceParameters(getEntity().getClusterId(), getEntity().getId(), ServiceType.GLUSTER, // $NON-NLS-1$
    "restart");
    Frontend.getInstance().runAction(VdcActionType.ManageGlusterService, parameters);
}
#end_block

#method_before
private org.snmp4j.Snmp createSnmp3(Profile profile) {
    try {
        TransportMapping<?> transport = new DefaultUdpTransportMapping();
        org.snmp4j.Snmp snmp = new org.snmp4j.Snmp(transport);
        SecurityProtocols securityProtocols = SecurityProtocols.getInstance();
        securityProtocols.addDefaultProtocols();
        securityProtocols.addPrivacyProtocol(new PrivAES192());
        USM usm = new USM(securityProtocols, profile.engineId, 0);
        ((org.snmp4j.mp.MPv3) snmp.getMessageProcessingModel(org.snmp4j.mp.MPv3.ID)).setLocalEngineID(profile.engineId.getValue());
        ((org.snmp4j.mp.MPv3) snmp.getMessageProcessingModel(org.snmp4j.mp.MPv3.ID)).getSecurityModels().addSecurityModel(usm);
        SecurityModels.getInstance().addSecurityModel(usm);
        transport.listen();
        snmp.getUSM().addUser(profile.username, getUsmUser(profile));
        return snmp;
    } catch (IOException e) {
        throw new NotificationServiceException("error creating version 3 snmp " + getClass().getName());
    }
}
#method_after
private org.snmp4j.Snmp createSnmp3(Profile profile) {
    try {
        TransportMapping<?> transport = new DefaultUdpTransportMapping();
        org.snmp4j.Snmp snmp = new org.snmp4j.Snmp(transport);
        SecurityProtocols securityProtocols = SecurityProtocols.getInstance();
        securityProtocols.addDefaultProtocols();
        securityProtocols.addAuthenticationProtocol(new AuthMD5());
        securityProtocols.addAuthenticationProtocol(new AuthSHA());
        securityProtocols.addPrivacyProtocol(new PrivAES128());
        securityProtocols.addPrivacyProtocol(new PrivAES192());
        securityProtocols.addPrivacyProtocol(new PrivAES256());
        USM usm = new USM(securityProtocols, profile.engineId, 0);
        ((org.snmp4j.mp.MPv3) snmp.getMessageProcessingModel(org.snmp4j.mp.MPv3.ID)).setLocalEngineID(profile.engineId.getValue());
        ((org.snmp4j.mp.MPv3) snmp.getMessageProcessingModel(org.snmp4j.mp.MPv3.ID)).getSecurityModels().addSecurityModel(usm);
        SecurityModels.getInstance().addSecurityModel(usm);
        transport.listen();
        snmp.getUSM().addUser(profile.username, getUsmUser(profile));
        return snmp;
    } catch (IOException e) {
        throw new NotificationServiceException("error creating version 3 snmp " + getClass().getName());
    }
}
#end_block

#method_before
private UsmUser getUsmUser(Profile profile) {
    OID authenticationProtocol = null;
    OctetString authenticationPassphrase = null;
    OID privacyProtocol = null;
    OctetString privacyPassphrase = null;
    switch(profile.securityLevel) {
        case SecurityLevel.AUTH_NOPRIV:
            authenticationProtocol = AuthMD5.ID;
            authenticationPassphrase = profile.authPassphrase;
            break;
        case SecurityLevel.AUTH_PRIV:
            authenticationProtocol = AuthMD5.ID;
            authenticationPassphrase = profile.authPassphrase;
            privacyProtocol = PrivAES128.ID;
            privacyPassphrase = profile.privacyPassphrase;
            break;
    }
    return new UsmUser(profile.username, authenticationProtocol, authenticationPassphrase, privacyProtocol, privacyPassphrase);
}
#method_after
private UsmUser getUsmUser(Profile profile) {
    OID authenticationProtocol = null;
    OctetString authenticationPassphrase = null;
    OID privacyProtocol = null;
    OctetString privacyPassphrase = null;
    switch(profile.securityLevel) {
        case SecurityLevel.AUTH_NOPRIV:
            authenticationProtocol = profile.authProtocol;
            authenticationPassphrase = profile.authPassphrase;
            break;
        case SecurityLevel.AUTH_PRIV:
            authenticationProtocol = profile.authProtocol;
            authenticationPassphrase = profile.authPassphrase;
            privacyProtocol = profile.privProtocol;
            privacyPassphrase = profile.privacyPassphrase;
            break;
    }
    return new UsmUser(profile.username, authenticationProtocol, authenticationPassphrase, privacyProtocol, privacyPassphrase);
}
#end_block

#method_before
@Test
public void testSnmpManagersParsing() {
    List<Snmp.Host> expectedManagers = new ArrayList<>();
    StringBuilder snmpManagers = new StringBuilder();
    for (Pair<String, String> host : hosts) {
        expectedManagers.add(new Snmp.Host(host.getFirst(), host.getSecond()));
        snmpManagers.append(host.getFirst());
        if (host.getSecond() != null) {
            snmpManagers.append(":").append(host.getSecond());
        }
        snmpManagers.append(" ");
    }
    Snmp.Profile profile = new Snmp.Profile(snmpManagers.toString(), "public", "1.3.6.1.4.1.2312.13.1.1", SnmpConstants.version2c);
    for (int i = 0; i < expectedManagers.size(); i++) {
        Snmp.Host parsed = profile.hosts.get(i);
        Snmp.Host expected = expectedManagers.get(i);
        Assert.assertEquals(parsed.name, expected.name);
        Assert.assertEquals(parsed.port, expected.port);
    }
}
#method_after
@Test
public void testSnmpManagersParsing() {
    List<Snmp.Host> expectedManagers = new ArrayList<>();
    StringBuilder snmpManagers = new StringBuilder();
    for (Pair<String, String> host : hosts) {
        expectedManagers.add(new Snmp.Host(host.getFirst(), host.getSecond()));
        snmpManagers.append(host.getFirst());
        if (host.getSecond() != null) {
            snmpManagers.append(":").append(host.getSecond());
        }
        snmpManagers.append(" ");
    }
    Snmp.Profile profile = Snmp.Profile.buildProfile(snmpManagers.toString(), "public", "1.3.6.1.4.1.2312.13.1.1", SnmpConstants.version2c);
    for (int i = 0; i < expectedManagers.size(); i++) {
        Snmp.Host parsed = profile.hosts.get(i);
        Snmp.Host expected = expectedManagers.get(i);
        Assert.assertEquals(parsed.name, expected.name);
        Assert.assertEquals(parsed.port, expected.port);
    }
}
#end_block

#method_before
public void connectStoragePool() {
    Map<String, String> storageDomains = null;
    storageDomains = StoragePoolDomainHelper.buildStoragePoolDomainsMap(getParameters().getStorageDomains());
    log.info("executing with domain map: {}", storageDomains);
    status = getBroker().connectStoragePool(getParameters().getStoragePoolId().toString(), getParameters().getVds().getVdsSpmId(), getParameters().getStoragePoolId().toString(), getParameters().getMasterDomainId().toString(), getParameters().getStoragePool().getMasterDomainVersion(), storageDomains);
}
#method_after
public void connectStoragePool() {
    Map<String, String> storageDomains = null;
    storageDomains = StoragePoolDomainHelper.buildStoragePoolDomainsMap(getParameters().getStorageDomains());
    log.info("Executing with domain map: {}", storageDomains);
    status = getBroker().connectStoragePool(getParameters().getStoragePoolId().toString(), getParameters().getVds().getVdsSpmId(), getParameters().getStoragePoolId().toString(), getParameters().getMasterDomainId().toString(), getParameters().getStoragePool().getMasterDomainVersion(), storageDomains);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DownloadImage, getVDSParameters());
    if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
        getTaskIdList().add(createTask(getAsyncTaskId(), vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Disk, getParameters().getDestinationImageId()));
    }
    setSucceeded(vdsReturnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DownloadImage, getVDSParameters());
    if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
        getTaskIdList().add(createTask(getAsyncTaskId(), vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Disk, getParameters().getDestinationImageId()));
    }
    setSucceeded(vdsReturnValue != null ? vdsReturnValue.getSucceeded() : false);
}
#end_block

#method_before
private void createNewDiskId() {
    Guid diskId = !getParameters().isUsePassedDiskId() ? Guid.newGuid() : getParameters().getDiskInfo().getId();
    getParameters().getDiskInfo().setId(diskId);
    if (!isFloatingDisk()) {
        getDiskVmElement().getId().setDeviceId(diskId);
    }
}
#method_after
private void createNewDiskId() {
    Guid diskId = getParameters().isUsePassedDiskId() ? getParameters().getDiskInfo().getId() : Guid.newGuid();
    getParameters().getDiskInfo().setId(diskId);
    if (!isFloatingDisk()) {
        getDiskVmElement().getId().setDeviceId(diskId);
    }
}
#end_block

#method_before
private void createDiskBasedOnLun() {
    final LUNs lun;
    if (lunFromStorage == null) {
        lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    } else {
        lun = lunFromStorage;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
        getBaseDiskDao().save(getParameters().getDiskInfo());
        getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUNId()));
        if (getVm() != null) {
            addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
            addDiskVmElementForDisk(getParameters().getDiskInfo().getDiskVmElementForVm(getVmId()));
        }
        return null;
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#method_after
private void createDiskBasedOnLun() {
    final LUNs lun;
    if (lunFromStorage == null) {
        lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    } else {
        lun = lunFromStorage;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
        getBaseDiskDao().save(getParameters().getDiskInfo());
        getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUNId()));
        if (getVm() != null) {
            // The disk VM element has to be added before the VM device since as a part of the VM device creation the
            // boot order is determined so the VM device creation depends on the existance of the disk VM element
            addDiskVmElementForDisk(getDiskVmElement());
            addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
        }
        return null;
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        // The disk VM element has to be added before the VM device since as a part of the VM device creation the
        // boot order is determined so the VM device creation depends on the existance of the disk VM element
        getCompensationContext().snapshotEntity(addDiskVmElementForDisk(getDiskVmElement()));
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        // The disk VM element has to be added before the VM device since as a part of the VM device creation the
        // boot order is determined so the VM device creation depends on the existance of the disk VM element
        getCompensationContext().snapshotEntity(addDiskVmElementForDisk(getDiskVmElement()));
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getVm() != null) {
        parameters.setVmSnapshotId(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
        parameters.setDiskVmElement(parameters.getDiskVmElement());
    }
    return parameters;
}
#method_after
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getVm() != null) {
        parameters.setVmSnapshotId(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
        parameters.setDiskVmElement(getParameters().getDiskVmElement());
    }
    return parameters;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setImageGroupID(Guid.newGuid());
    getParameters().setDestinationImageId(Guid.newGuid());
    persistCommand(getParameters().getParentCommand(), true);
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupID()));
    Backend.getInstance().runInternalAction(VdcActionType.AddDisk, createAddDiskParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    getParameters().setNextPhase(ImportRepoImageParameters.Phase.DOWNLOAD);
    persistCommand(getParameters().getParentCommand(), true);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setupParameters();
    persistCommand(getParameters().getParentCommand(), true);
    Backend.getInstance().runInternalAction(VdcActionType.AddDisk, createAddDiskParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    getParameters().setNextPhase(ImportRepoImageParameters.Phase.DOWNLOAD);
    persistCommand(getParameters().getParentCommand(), true);
    setSucceeded(true);
}
#end_block

#method_before
protected AddDiskParameters createAddDiskParameters() {
    DiskImage diskImage = getParameters().getDiskImage();
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(getParameters().getStorageDomainId());
    diskImage.setDiskAlias(getParameters().getDiskAlias());
    diskImage.setStorageIds(storageIds);
    diskImage.setStoragePoolId(getParameters().getStoragePoolId());
    diskImage.setId(getParameters().getImageGroupID());
    diskImage.setDiskProfileId(getParameters().getDiskProfileId());
    diskImage.setImageId(getParameters().getDestinationImageId());
    diskImage.setQuotaId(getParameters().getQuotaId());
    AddDiskParameters parameters = new AddDiskParameters(diskImage);
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldRemainIllegalOnFailedExecution(true);
    parameters.setShouldRemainLockedOnSuccesfulExecution(true);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setUsePassedDiskId(true);
    return parameters;
}
#method_after
protected AddDiskParameters createAddDiskParameters() {
    DiskImage diskImage = getParameters().getDiskImage();
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(getParameters().getStorageDomainId());
    diskImage.setDiskAlias(getParameters().getDiskAlias());
    diskImage.setStorageIds(storageIds);
    diskImage.setStoragePoolId(getParameters().getStoragePoolId());
    diskImage.setId(getParameters().getImageGroupID());
    diskImage.setDiskProfileId(getParameters().getDiskProfileId());
    diskImage.setImageId(getParameters().getDestinationImageId());
    diskImage.setQuotaId(getParameters().getQuotaId());
    AddDiskParameters parameters = new AddDiskParameters(diskImage);
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldRemainIllegalOnFailedExecution(true);
    parameters.setShouldRemainLockedOnSuccesfulExecution(true);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setUsePassedDiskId(true);
    parameters.setUsePassedImageId(true);
    return parameters;
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getNextPhase() == ImportRepoImageParameters.Phase.DOWNLOAD) {
        Backend.getInstance().runInternalAction(VdcActionType.DownloadImage, createDownloadImageParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
        getParameters().setNextPhase(ImportRepoImageParameters.Phase.END);
        persistCommand(getParameters().getParentCommand(), true);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getNextPhase() == ImportRepoImageParameters.Phase.DOWNLOAD) {
        getParameters().setNextPhase(ImportRepoImageParameters.Phase.END);
        persistCommand(getParameters().getParentCommand(), true);
        Backend.getInstance().runInternalAction(VdcActionType.DownloadImage, createDownloadImageParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void handleFailure() {
    updateDiskStatus(ImageStatus.ILLEGAL);
}
#method_after
@Override
public void handleFailure() {
    updateDiskStatus(ImageStatus.ILLEGAL);
    removeDisk();
}
#end_block

#method_before
@Override
public void endSuccessfully() {
    super.endSuccessfully();
    if (getParameters().getImportAsTemplate()) {
        Guid newTemplateId = createTemplate();
        // No reason for this to happen, but checking just to make sure
        if (newTemplateId != null) {
            attachDiskToTemplate(newTemplateId);
        }
    }
    updateDiskStatus(ImageStatus.OK);
    getReturnValue().setSucceeded(true);
}
#method_after
@Override
public void endSuccessfully() {
    super.endSuccessfully();
    if (getParameters().getImportAsTemplate()) {
        Guid newTemplateId = createTemplate();
        // No reason for this to happen, but checking just to make sure
        if (newTemplateId != null) {
            attachDiskToTemplate(newTemplateId);
        }
    }
    updateDiskStatus(ImageStatus.OK);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void endWithFailure() {
    updateDiskStatus(ImageStatus.ILLEGAL);
}
#method_after
@Override
public void endWithFailure() {
    updateDiskStatus(ImageStatus.ILLEGAL);
    setSucceeded(true);
}
#end_block

#method_before
private Guid createTemplate() {
    VmTemplate blankTemplate = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    DiskImage templateDiskImage = getParameters().getDiskImage();
    String templateName = getParameters().getTemplateName();
    // Following the same convention as the glance disk name, using a GlanceTemplate prefix, followed by a short identifier
    String vmTemplateName = templateName != null ? templateName : "GlanceTemplate-" + Guid.newGuid().toString().substring(0, 7);
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    // Setting the user from the parent command, as the session might already be invalid
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    // Setting the cluster ID, and other related properties derived from it
    if (getParameters().getClusterId() != null) {
        masterVm.setClusterId(getParameters().getClusterId());
        Cluster vdsGroup = getCluster(masterVm.getClusterId());
        masterVm.setOsId(osRepository.getDefaultOSes().get(vdsGroup.getArchitecture()));
        DisplayType defaultDisplayType = osRepository.getGraphicsAndDisplays(masterVm.getOsId(), vdsGroup.getCompatibilityVersion()).get(0).getSecond();
        masterVm.setDefaultDisplayType(defaultDisplayType);
    }
    parameters.setBalloonEnabled(true);
    VdcReturnValueBase addVmTemplateReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#method_after
private Guid createTemplate() {
    VmTemplate blankTemplate = getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    DiskImage templateDiskImage = getParameters().getDiskImage();
    String vmTemplateName = getParameters().getTemplateName();
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    // Setting the user from the parent command, as the session might already be invalid
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    // Setting the cluster ID, and other related properties derived from it
    if (getParameters().getClusterId() != null) {
        masterVm.setClusterId(getParameters().getClusterId());
        Cluster vdsGroup = getCluster(masterVm.getClusterId());
        masterVm.setOsId(osRepository.getDefaultOSes().get(vdsGroup.getArchitecture()));
        DisplayType defaultDisplayType = osRepository.getGraphicsAndDisplays(masterVm.getOsId(), vdsGroup.getCompatibilityVersion()).get(0).getSecond();
        masterVm.setDefaultDisplayType(defaultDisplayType);
    }
    parameters.setBalloonEnabled(true);
    VdcReturnValueBase addVmTemplateReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#end_block

#method_before
public Cluster getCluster(Guid clusterId) {
    return DbFacade.getInstance().getClusterDao().get(clusterId);
}
#method_after
public Cluster getCluster(Guid clusterId) {
    return getClusterDao().get(clusterId);
}
#end_block

#method_before
private void attachDiskToTemplate(Guid templateId) {
    DiskImage templateDiskImage = getParameters().getDiskImage();
    DiskVmElement dve = new DiskVmElement(templateDiskImage.getId(), templateId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    DbFacade.getInstance().getDiskVmElementDao().save(dve);
    VmDeviceUtils.addDiskDevice(templateId, templateDiskImage.getId());
}
#method_after
private void attachDiskToTemplate(Guid templateId) {
    DiskImage templateDiskImage = getParameters().getDiskImage();
    DiskVmElement dve = new DiskVmElement(templateDiskImage.getId(), templateId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    getDiskVmElementDao().save(dve);
    VmDeviceUtils.addDiskDevice(templateId, templateDiskImage.getId());
}
#end_block

#method_before
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    callsHandler.executeStoredProcAsBatch("insert_osinfo", executions);
}
#method_after
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    getCallsHandler().executeStoredProcAsBatch("insert_osinfo", executions);
}
#end_block

#method_before
@Override
public List<VDS> getAllForClusterWithStatusAndPeerStatus(Guid clusterId, VDSStatus status, PeerStatus peerStatus) {
    List<VDS> vdsList = getCallsHandler().executeReadList("getVdsForClusterWithPeerStatus", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId).addValue("status", status.getValue()).addValue("peer_status", peerStatus));
    return uniteAgents(vdsList);
}
#method_after
@Override
public List<VDS> getAllForClusterWithStatusAndPeerStatus(Guid clusterId, VDSStatus status, PeerStatus peerStatus) {
    List<VDS> vdsList = getCallsHandler().executeReadList("getVdsForClusterWithPeerStatus", VdsRowMapper.instance, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId).addValue("status", status.getValue()).addValue("peer_status", peerStatus.name()));
    return uniteAgents(vdsList);
}
#end_block

#method_before
private void syncServers(Cluster cluster, List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    Network glusterNetwork = findGlusterNetwork(cluster.getId());
    for (VDS server : existingServers) {
        GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
        if (isRemovableStatus(server.getStatus())) {
            if (glusterServer == null) {
                if (cluster.supportsVirtService()) {
                    // If the cluster supports virt service as well, we should not be removing any servers from it, even
                    // if they
                    // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be
                    // used for
                    // running VMs
                    log.debug("As cluster '{}' supports virt service as well, server '{}' detected as removed from glusterfs will not be removed from engine", cluster.getName(), server.getHostName());
                    continue;
                }
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = getGlusterUtil().acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // if last but one server, reset alternate probed address for last server
                    checkAndResetKnownAddress(existingServers, server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            }
        } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
            // check gluster is running, if down then move the host to Non-Operational
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
            if (!returnValue.getSucceeded()) {
                setNonOperational(server);
            }
        } else {
            // check if all interfaces with gluster network have been peer probed.
            updateStatusAndpeerProbeOtherIface(glusterNetwork, server, glusterServer);
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#method_after
private void syncServers(Cluster cluster, List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    Network glusterNetwork = findGlusterNetwork(cluster.getId());
    for (VDS server : existingServers) {
        GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
        if (isSyncableStatus(server.getStatus())) {
            if (glusterServer == null) {
                if (cluster.supportsVirtService()) {
                    // If the cluster supports virt service as well, we should not be removing any servers from it, even
                    // if they have been removed from the Gluster cluster using the Gluster cli, as they could
                    // potentially be
                    // used for running VMs. Will mark this server status as DISCONNECTED instead
                    log.debug("As cluster '{}' supports virt service as well, server '{}' detected as removed from glusterfs will not be removed from engine", cluster.getName(), server.getHostName());
                    setNonOperational(server);
                    continue;
                }
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = getGlusterUtil().acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // if last but one server, reset alternate probed address for last server
                    checkAndResetKnownAddress(existingServers, server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
                // check gluster is running, if down then move the host to Non-Operational
                VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
                if (!returnValue.getSucceeded()) {
                    setNonOperational(server);
                }
            } else {
                // update correct status and check if all interfaces with gluster network have been peer probed.
                updateStatusAndpeerProbeOtherIface(glusterNetwork, server, glusterServer);
            }
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#end_block

#method_before
private void updateStatusAndpeerProbeOtherIface(Network glusterNetwork, VDS host, GlusterServerInfo fetchedServerInfo) {
    if (glusterNetwork == null || host.getStatus() != VDSStatus.Up) {
        return;
    }
    GlusterServer glusterServer = getGlusterServerDao().get(host.getId());
    if (glusterServer == null) {
        return;
    }
    if (glusterServer.getPeerStatus() == PeerStatus.DISCONNECTED && fetchedServerInfo.getStatus() == PeerStatus.CONNECTED) {
        // change the status to indicate that host is now part of cluster
        getGlusterServerDao().updatePeerStatus(host.getId(), PeerStatus.DISCONNECTED);
    }
    List<VdsNetworkInterface> interfaces = getInterfaceDao().getAllInterfacesForVds(host.getId());
    for (VdsNetworkInterface iface : interfaces) {
        if (glusterNetwork.getName().equals(iface.getNetworkName()) && StringUtils.isNotBlank(iface.getIpv4Address()) && !glusterServer.getKnownAddresses().contains(iface.getIpv4Address())) {
            // get another server in the cluster
            VDS upServer = getAlternateUpServerInCluster(host.getClusterId(), host.getId());
            if (upServer != null) {
                boolean peerProbed = glusterPeerProbeAdditionalInterface(upServer.getId(), iface.getIpv4Address());
                if (peerProbed) {
                    getGlusterServerDao().addKnownAddress(host.getId(), iface.getIpv4Address());
                }
            } else {
                log.warn("probe could not be done for server '{}' as no alternate UP server found", host.getHostName());
            }
        }
    }
}
#method_after
private void updateStatusAndpeerProbeOtherIface(Network glusterNetwork, VDS host, GlusterServerInfo fetchedServerInfo) {
    GlusterServer glusterServer = getGlusterServerDao().get(host.getId());
    if (glusterServer == null) {
        return;
    }
    if (glusterServer.getPeerStatus() == PeerStatus.DISCONNECTED && fetchedServerInfo.getStatus() == PeerStatus.CONNECTED) {
        // change the status to indicate that host is now part of cluster
        getGlusterServerDao().updatePeerStatus(host.getId(), PeerStatus.CONNECTED);
    }
    if (glusterNetwork == null || host.getStatus() != VDSStatus.Up) {
        return;
    }
    List<VdsNetworkInterface> interfaces = getInterfaceDao().getAllInterfacesForVds(host.getId());
    for (VdsNetworkInterface iface : interfaces) {
        if (glusterNetwork.getName().equals(iface.getNetworkName()) && StringUtils.isNotBlank(iface.getIpv4Address()) && !glusterServer.getKnownAddresses().contains(iface.getIpv4Address())) {
            // get another server in the cluster
            VDS upServer = getAlternateUpServerInCluster(host.getClusterId(), host.getId());
            if (upServer != null) {
                boolean peerProbed = glusterPeerProbeAdditionalInterface(upServer.getId(), iface.getIpv4Address());
                if (peerProbed) {
                    getGlusterServerDao().addKnownAddress(host.getId(), iface.getIpv4Address());
                }
            } else {
                log.warn("probe could not be done for server '{}' as no alternate UP server found", host.getHostName());
            }
        }
    }
}
#end_block

#method_before
private VDS getAlternateUpServerInCluster(Guid clusterId, Guid vdsId) {
    List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(clusterId, VDSStatus.Up);
    // If the cluster already having Gluster servers, get an up server
    if (vdsList.isEmpty()) {
        return null;
    }
    for (VDS vds : vdsList) {
        if (!vdsId.equals(vds.getId()) && vds.getExternalStatus() == ExternalStatus.Ok) {
            return vds;
        }
    }
    return null;
}
#method_after
private VDS getAlternateUpServerInCluster(Guid clusterId, Guid vdsId) {
    List<VDS> vdsList = getVdsDao().getAllForClusterWithStatusAndPeerStatus(clusterId, VDSStatus.Up, PeerStatus.CONNECTED);
    // If the cluster already having Gluster servers, get an up server
    if (vdsList.isEmpty()) {
        return null;
    }
    for (VDS vds : vdsList) {
        if (!vdsId.equals(vds.getId()) && vds.getExternalStatus() == ExternalStatus.Ok) {
            return vds;
        }
    }
    return null;
}
#end_block

#method_before
private void setNonOperational(VDS server) {
    Cluster cluster = getClusterDao().get(server.getClusterId());
    if (!cluster.supportsVirtService()) {
        SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
        backend.runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
    }
    getGlusterServerDao().updatePeerStatus(server.getId(), PeerStatus.DISCONNECTED);
}
#method_after
private void setNonOperational(VDS server) {
    Cluster cluster = getClusterDao().get(server.getClusterId());
    if (!cluster.supportsVirtService()) {
        SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
        backend.runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
    }
    getGlusterServerDao().updatePeerStatus(server.getId(), PeerStatus.DISCONNECTED);
    logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_STATUS_DISCONNECTED);
}
#end_block

#method_before
public VDS getRandomUpServer(Guid clusterId) {
    List<VDS> servers = getAllUpServers(clusterId);
    if (servers == null || servers.isEmpty()) {
        return null;
    }
    return servers.get(new Random().nextInt(servers.size()));
}
#method_after
public VDS getRandomUpServer(Guid clusterId) {
    List<VDS> servers = getAllUpServers(clusterId);
    if (CollectionUtils.isEmpty(servers)) {
        return null;
    }
    return servers.get(new Random().nextInt(servers.size()));
}
#end_block

#method_before
public VDS getUpServer(Guid clusterId) {
    List<VDS> servers = getAllUpServers(clusterId);
    if (servers == null || servers.isEmpty()) {
        return null;
    }
    return servers.get(0);
}
#method_after
public VDS getUpServer(Guid clusterId) {
    List<VDS> servers = getAllUpServers(clusterId);
    if (CollectionUtils.isEmpty(servers)) {
        return null;
    }
    return servers.get(0);
}
#end_block

#method_before
@Override
protected boolean validate() {
    VDS vds = getVds();
    if (vds == null) {
        addValidationMessage(EngineMessage.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.canUpdateField(vds, "clusterId", vds.getStatus())) {
        addValidationMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForCluster(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForCluster(getParameters().getClusterId()).isEmpty()) {
            addValidationMessage(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getCluster().supportsGlusterService()) {
        if (getGlusterDBUtils().hasBricks(getVdsId())) {
            addValidationMessage(EngineMessage.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), targetClusterCompatibilityVersion));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failValidation(EngineMessage.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (!(VDSStatus.PendingApproval == vds.getStatus() || isDetachedSourceCluster() || isSameManagementNetwork())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_CLUSTER_DIFFERENT_MANAGEMENT_NETWORKS);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    VDS vds = getVds();
    if (vds == null) {
        addValidationMessage(EngineMessage.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.canUpdateField(vds, "clusterId", vds.getStatus())) {
        addValidationMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForCluster(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForCluster(getParameters().getClusterId()).isEmpty()) {
            addValidationMessage(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getCluster().supportsGlusterService()) {
        if (getGlusterDbUtils().hasBricks(getVdsId())) {
            addValidationMessage(EngineMessage.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), targetClusterCompatibilityVersion));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failValidation(EngineMessage.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (!(VDSStatus.PendingApproval == vds.getStatus() || isDetachedSourceCluster() || isSameManagementNetwork())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_CLUSTER_DIFFERENT_MANAGEMENT_NETWORKS);
    }
    return true;
}
#end_block

#method_before
private void syncServers(Cluster cluster, List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    Network glusterNetwork = findGlusterNetwork(cluster.getId());
    for (VDS server : existingServers) {
        GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
        if (isRemovableStatus(server.getStatus())) {
            if (glusterServer == null) {
                if (cluster.supportsVirtService()) {
                    // If the cluster supports virt service as well, we should not be removing any servers from it, even
                    // if they
                    // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be
                    // used for
                    // running VMs
                    log.debug("As cluster '{}' supports virt service as well, server '{}' detected as removed from glusterfs will not be removed from engine", cluster.getName(), server.getHostName());
                    continue;
                }
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = getGlusterUtil().acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // if last but one server, reset alternate probed address for last server
                    checkAndResetKnownAddress(existingServers, server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            }
        } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
            // check gluster is running, if down then move the host to Non-Operational
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
            if (!returnValue.getSucceeded()) {
                setNonOperational(server);
            }
        } else {
            // check if all interfaces with gluster network have been peer probed.
            updateStatusAndpeerProbeOtherIface(glusterNetwork, server, glusterServer);
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#method_after
private void syncServers(Cluster cluster, List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    Network glusterNetwork = findGlusterNetwork(cluster.getId());
    for (VDS server : existingServers) {
        GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
        if (isSyncableStatus(server.getStatus())) {
            if (glusterServer == null) {
                if (cluster.supportsVirtService()) {
                    // If the cluster supports virt service as well, we should not be removing any servers from it, even
                    // if they have been removed from the Gluster cluster using the Gluster cli, as they could
                    // potentially be
                    // used for running VMs. Will mark this server status as DISCONNECTED instead
                    log.debug("As cluster '{}' supports virt service as well, server '{}' detected as removed from glusterfs will not be removed from engine", cluster.getName(), server.getHostName());
                    setNonOperational(server);
                    continue;
                }
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = getGlusterUtil().acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // if last but one server, reset alternate probed address for last server
                    checkAndResetKnownAddress(existingServers, server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
                // check gluster is running, if down then move the host to Non-Operational
                VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
                if (!returnValue.getSucceeded()) {
                    setNonOperational(server);
                }
            } else {
                // update correct status and check if all interfaces with gluster network have been peer probed.
                updateStatusAndpeerProbeOtherIface(glusterNetwork, server, glusterServer);
            }
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#end_block

#method_before
private void updateStatusAndpeerProbeOtherIface(Network glusterNetwork, VDS host, GlusterServerInfo fetchedServerInfo) {
    if (glusterNetwork == null || host.getStatus() != VDSStatus.Up) {
        return;
    }
    GlusterServer glusterServer = getGlusterServerDao().get(host.getId());
    if (glusterServer == null) {
        return;
    }
    if (glusterServer.getPeerStatus() == PeerStatus.DISCONNECTED && fetchedServerInfo.getStatus() == PeerStatus.CONNECTED) {
        // change the status to indicate that host is now part of cluster
        getGlusterServerDao().updatePeerStatus(host.getId(), PeerStatus.CONNECTED);
    }
    List<VdsNetworkInterface> interfaces = getInterfaceDao().getAllInterfacesForVds(host.getId());
    for (VdsNetworkInterface iface : interfaces) {
        if (glusterNetwork.getName().equals(iface.getNetworkName()) && StringUtils.isNotBlank(iface.getIpv4Address()) && !glusterServer.getKnownAddresses().contains(iface.getIpv4Address())) {
            // get another server in the cluster
            VDS upServer = getAlternateUpServerInCluster(host.getClusterId(), host.getId());
            if (upServer != null) {
                boolean peerProbed = glusterPeerProbeAdditionalInterface(upServer.getId(), iface.getIpv4Address());
                if (peerProbed) {
                    getGlusterServerDao().addKnownAddress(host.getId(), iface.getIpv4Address());
                }
            } else {
                log.warn("probe could not be done for server '{}' as no alternate UP server found", host.getHostName());
            }
        }
    }
}
#method_after
private void updateStatusAndpeerProbeOtherIface(Network glusterNetwork, VDS host, GlusterServerInfo fetchedServerInfo) {
    GlusterServer glusterServer = getGlusterServerDao().get(host.getId());
    if (glusterServer == null) {
        return;
    }
    if (glusterServer.getPeerStatus() == PeerStatus.DISCONNECTED && fetchedServerInfo.getStatus() == PeerStatus.CONNECTED) {
        // change the status to indicate that host is now part of cluster
        getGlusterServerDao().updatePeerStatus(host.getId(), PeerStatus.CONNECTED);
    }
    if (glusterNetwork == null || host.getStatus() != VDSStatus.Up) {
        return;
    }
    List<VdsNetworkInterface> interfaces = getInterfaceDao().getAllInterfacesForVds(host.getId());
    for (VdsNetworkInterface iface : interfaces) {
        if (glusterNetwork.getName().equals(iface.getNetworkName()) && StringUtils.isNotBlank(iface.getIpv4Address()) && !glusterServer.getKnownAddresses().contains(iface.getIpv4Address())) {
            // get another server in the cluster
            VDS upServer = getAlternateUpServerInCluster(host.getClusterId(), host.getId());
            if (upServer != null) {
                boolean peerProbed = glusterPeerProbeAdditionalInterface(upServer.getId(), iface.getIpv4Address());
                if (peerProbed) {
                    getGlusterServerDao().addKnownAddress(host.getId(), iface.getIpv4Address());
                }
            } else {
                log.warn("probe could not be done for server '{}' as no alternate UP server found", host.getHostName());
            }
        }
    }
}
#end_block

#method_before
private void setNonOperational(VDS server) {
    Cluster cluster = getClusterDao().get(server.getClusterId());
    if (!cluster.supportsVirtService()) {
        SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
        backend.runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
    }
    getGlusterServerDao().updatePeerStatus(server.getId(), PeerStatus.DISCONNECTED);
}
#method_after
private void setNonOperational(VDS server) {
    Cluster cluster = getClusterDao().get(server.getClusterId());
    if (!cluster.supportsVirtService()) {
        SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
        backend.runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
    }
    getGlusterServerDao().updatePeerStatus(server.getId(), PeerStatus.DISCONNECTED);
    logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_STATUS_DISCONNECTED);
}
#end_block

#method_before
private void setupMock() throws Exception {
    VDSBrokerFrontend vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    GlusterUtil glusterUtils = mock(GlusterUtil.class);
    VdsDao vdsDaoMock = mock(VdsDao.class);
    clusterDaoMock = mock(ClusterDao.class);
    GlusterDBUtils dbUtils = mock(GlusterDBUtils.class);
    BackendInternal backendInternal = mock(BackendInternal.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getVdsBroker();
    doReturn(glusterUtils).when(getQuery()).getGlusterUtils();
    doReturn(dbUtils).when(getQuery()).getDbUtils();
    doReturn(getVds(VDSStatus.Up)).when(glusterUtils).getUpServer(CLUSTER_ID);
    doReturn(backendInternal).when(getQuery()).getBackend();
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.runVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    VdcQueryReturnValue vdcReturnValue = getVdcReturnValue();
    when(backendInternal.runInternalQuery(eq(VdcQueryType.GetServerSSHKeyFingerprint), any(VdcQueryParametersBase.class), any(EngineContext.class))).thenReturn(vdcReturnValue);
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    // doReturn(vdsDaoMock).when(clusterUtils).getVdsDao();
    doReturn(clusterDaoMock).when(getQuery()).getClusterDao();
// doReturn(serversList).when(vdsDaoMock).getAllForCluster(CLUSTER_ID);
}
#method_after
private void setupMock() throws Exception {
    VDSBrokerFrontend vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    GlusterUtil glusterUtils = mock(GlusterUtil.class);
    clusterDaoMock = mock(ClusterDao.class);
    GlusterDBUtils dbUtils = mock(GlusterDBUtils.class);
    BackendInternal backendInternal = mock(BackendInternal.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getVdsBroker();
    doReturn(glusterUtils).when(getQuery()).getGlusterUtils();
    doReturn(dbUtils).when(getQuery()).getDbUtils();
    doReturn(getVds(VDSStatus.Up)).when(glusterUtils).getUpServer(CLUSTER_ID);
    doReturn(backendInternal).when(getQuery()).getBackend();
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.runVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    VdcQueryReturnValue vdcReturnValue = getVdcReturnValue();
    when(backendInternal.runInternalQuery(eq(VdcQueryType.GetServerSSHKeyFingerprint), any(VdcQueryParametersBase.class), any(EngineContext.class))).thenReturn(vdcReturnValue);
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    doReturn(clusterDaoMock).when(getQuery()).getClusterDao();
}
#end_block

#method_before
private void mockVdsDbFacadeAndDao() {
    doReturn(Collections.singletonList(getVds(VDSStatus.Up))).when(vdsDao).getAllForClusterWithStatus(CLUSTER_ID, VDSStatus.Up);
    doReturn(volumeDao).when(getQuery()).getGlusterVolumeDao();
    doReturn(brickDao).when(getQuery()).getGlusterBrickDao();
    doReturn(glusterUtils).when(getQuery()).getGlusterUtils();
    doReturn(getVds(VDSStatus.Up)).when(glusterUtils).getUpServer(CLUSTER_ID);
    // doReturn(vdsDao).when(clusterUtils).getVdsDao();
    doReturn("test-vol").when(getQuery()).getGlusterVolumeName(VOLUME_ID);
    doReturn(getBrick()).when(brickDao).getById(any(Guid.class));
}
#method_after
private void mockVdsDbFacadeAndDao() {
    doReturn(Collections.singletonList(getVds(VDSStatus.Up))).when(vdsDao).getAllForClusterWithStatus(CLUSTER_ID, VDSStatus.Up);
    doReturn(volumeDao).when(getQuery()).getGlusterVolumeDao();
    doReturn(brickDao).when(getQuery()).getGlusterBrickDao();
    doReturn(glusterUtils).when(getQuery()).getGlusterUtils();
    doReturn(getVds(VDSStatus.Up)).when(glusterUtils).getUpServer(CLUSTER_ID);
    doReturn("test-vol").when(getQuery()).getGlusterVolumeName(VOLUME_ID);
    doReturn(getBrick()).when(brickDao).getById(any(Guid.class));
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    mockVdsDbFacadeAndDao();
    setupExpectedGlusterVolumeOptionInfo();
    setupMock();
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    setupExpectedGlusterVolumeOptionInfo();
    setupMock();
}
#end_block

#method_before
private void setupMock() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setReturnValue(expected);
    doReturn(returnValue).when(getQuery()).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeOptionsInfo), any(VDSParametersBase.class));
}
#method_after
private void setupMock() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setReturnValue(expected);
    doReturn(returnValue).when(getQuery()).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeOptionsInfo), any(VDSParametersBase.class));
    doReturn(glusterUtils).when(getQuery()).getGlusterUtils();
    when(glusterUtils.getUpServer(CLUSTER_ID)).thenReturn(getVds(VDSStatus.Up));
}
#end_block

#method_before
private MapSqlParameterSource createInterfaceParametersMapper(VdsNetworkInterface nic) {
    return getCustomMapSqlParameterSource().addValue("addr", nic.getAddress()).addValue("bond_name", nic.getBondName()).addValue("bond_type", nic.getBondType()).addValue("gateway", nic.getGateway()).addValue("id", nic.getId()).addValue("is_bond", nic.getBonded()).addValue("bond_opts", nic.getBondOptions()).addValue("mac_addr", nic.getMacAddress()).addValue("name", nic.getName()).addValue("network_name", nic.getNetworkName()).addValue("speed", nic.getSpeed()).addValue("subnet", nic.getSubnet()).addValue("boot_protocol", nic.getBootProtocol()).addValue("type", nic.getType()).addValue("vds_id", nic.getVdsId()).addValue("vlan_id", nic.getVlanId()).addValue("base_interface", nic.getBaseInterface()).addValue("mtu", nic.getMtu()).addValue("bridged", nic.isBridged()).addValue("labels", SerializationFactory.getSerializer().serialize(nic.getLabels()));
}
#method_after
private MapSqlParameterSource createInterfaceParametersMapper(VdsNetworkInterface nic) {
    return getCustomMapSqlParameterSource().addValue("addr", nic.getIpv4Address()).addValue("ipv6_address", nic.getIpv6Address()).addValue("bond_name", nic.getBondName()).addValue("bond_type", nic.getBondType()).addValue("gateway", nic.getIpv4Gateway()).addValue("ipv6_gateway", nic.getIpv6Gateway()).addValue("id", nic.getId()).addValue("is_bond", nic.getBonded()).addValue("bond_opts", nic.getBondOptions()).addValue("mac_addr", nic.getMacAddress()).addValue("name", nic.getName()).addValue("network_name", nic.getNetworkName()).addValue("speed", nic.getSpeed()).addValue("subnet", nic.getIpv4Subnet()).addValue("ipv6_prefix", nic.getIpv6Prefix()).addValue("boot_protocol", nic.getIpv4BootProtocol()).addValue("ipv6_boot_protocol", nic.getIpv6BootProtocol()).addValue("type", nic.getType()).addValue("vds_id", nic.getVdsId()).addValue("vlan_id", nic.getVlanId()).addValue("base_interface", nic.getBaseInterface()).addValue("mtu", nic.getMtu()).addValue("bridged", nic.isBridged()).addValue("labels", SerializationFactory.getSerializer().serialize(nic.getLabels())).addValue("ad_partner_mac", nic.getAdPartnerMac()).addValue("reported_switch_type", nic.getReportedSwitchType() == null ? null : nic.getReportedSwitchType().getOptionValue());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(NetworkAttachment networkAttachment) {
    MapSqlParameterSource mapper = createIdParameterMapper(networkAttachment.getId()).addValue("network_id", networkAttachment.getNetworkId()).addValue("nic_id", networkAttachment.getNicId()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(networkAttachment.getProperties()));
    IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration();
    mapIpConfiguration(mapper, ipConfiguration == null ? new IpConfiguration() : ipConfiguration);
    return mapper;
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(NetworkAttachment networkAttachment) {
    MapSqlParameterSource mapper = createIdParameterMapper(networkAttachment.getId()).addValue("network_id", networkAttachment.getNetworkId()).addValue("nic_id", networkAttachment.getNicId()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(networkAttachment.getProperties()));
    mapIpConfiguration(networkAttachment, mapper);
    return mapper;
}
#end_block

#method_before
private void mapIpConfiguration(MapSqlParameterSource mapper, IpConfiguration ipConfiguration) {
    boolean hasPrimaryAddressSet = ipConfiguration.hasPrimaryAddressSet();
    IPv4Address primaryAddress = hasPrimaryAddressSet ? ipConfiguration.getPrimaryAddress() : null;
    mapper.addValue("boot_protocol", hasPrimaryAddressSet ? EnumUtils.nameOrNull(primaryAddress.getBootProtocol()) : null).addValue("address", hasPrimaryAddressSet ? primaryAddress.getAddress() : null).addValue("netmask", hasPrimaryAddressSet ? primaryAddress.getNetmask() : null).addValue("gateway", hasPrimaryAddressSet ? primaryAddress.getGateway() : null);
}
#method_after
private void mapIpConfiguration(NetworkAttachment networkAttachment, MapSqlParameterSource mapper) {
    final IpConfiguration ipConfiguration = networkAttachment.getIpConfiguration() == null ? new IpConfiguration() : networkAttachment.getIpConfiguration();
    mapIpv4Configuration(mapper, ipConfiguration);
    mapIpv6Configuration(mapper, ipConfiguration);
}
#end_block

#method_before
@Override
public NetworkAttachment mapRow(ResultSet rs, int rowNum) throws SQLException {
    NetworkAttachment entity = new NetworkAttachment();
    entity.setId(getGuid(rs, "id"));
    entity.setNetworkId(getGuid(rs, "network_id"));
    entity.setNicId(getGuid(rs, "nic_id"));
    entity.setProperties(getCustomProperties(rs));
    IpConfiguration ipConfiguration = new IpConfiguration();
    String bootProtocol = rs.getString("boot_protocol");
    if (bootProtocol != null) {
        ipConfiguration.setIPv4Addresses(new ArrayList<>());
        IPv4Address iPv4Address = new IPv4Address();
        iPv4Address.setBootProtocol(NetworkBootProtocol.valueOf(bootProtocol));
        iPv4Address.setAddress(rs.getString("address"));
        iPv4Address.setNetmask(rs.getString("netmask"));
        iPv4Address.setGateway(rs.getString("gateway"));
        ipConfiguration.getIPv4Addresses().add(iPv4Address);
        entity.setIpConfiguration(ipConfiguration);
    }
    entity.setHostNetworkQos(hostNetworkQosDao.get(entity.getId()));
    return entity;
}
#method_after
@Override
public NetworkAttachment mapRow(ResultSet rs, int rowNum) throws SQLException {
    NetworkAttachment entity = new NetworkAttachment();
    entity.setId(getGuid(rs, "id"));
    entity.setNetworkId(getGuid(rs, "network_id"));
    entity.setNicId(getGuid(rs, "nic_id"));
    entity.setProperties(getCustomProperties(rs));
    final IpConfiguration ipConfiguration = new IpConfiguration();
    final String bootProtocol = rs.getString("boot_protocol");
    if (bootProtocol != null) {
        final IPv4Address iPv4Address = createIpv4Address(rs, bootProtocol);
        ipConfiguration.getIPv4Addresses().add(iPv4Address);
    }
    final String v6BootProtocol = rs.getString("ipv6_boot_protocol");
    if (v6BootProtocol != null) {
        final IpV6Address ipV6Address = createIpV6Address(rs, v6BootProtocol);
        ipConfiguration.getIpV6Addresses().add(ipV6Address);
    }
    if (bootProtocol != null || v6BootProtocol != null) {
        entity.setIpConfiguration(ipConfiguration);
    }
    entity.setHostNetworkQos(hostNetworkQosDao.get(entity.getId()));
    return entity;
}
#end_block

#method_before
@Override
protected void init() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster));
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#method_after
@Override
protected void init() {
    if (getCluster() == null) {
        return;
    }
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster));
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#end_block

#method_before
protected List<Guid> getPredefinedVdsIdListToRunOn() {
    return getVm().getDedicatedVmForVdsList();
}
#method_after
protected List<Guid> getPredefinedVdsIdListToRunOn() {
    // only to allow the user to disable it.
    return Collections.emptyList();
}
#end_block

#method_before
private RunVmFlow setFlow(RunVmFlow flow) {
    return cachedFlow = flow;
}
#method_after
private RunVmFlow setFlow(RunVmFlow flow) {
    getParameters().setCachedFlow(flow);
    return flow;
}
#end_block

#method_before
protected RunVmFlow getFlow() {
    if (cachedFlow != null) {
        return cachedFlow;
    }
    switch(getVm().getStatus()) {
        case Paused:
            return setFlow(RunVmFlow.RESUME_PAUSE);
        case Suspended:
            return setFlow(RunVmFlow.RESUME_HIBERNATE);
        default:
    }
    if (isRunAsStateless()) {
        fetchVmDisksFromDb();
        if (getVm().getDiskList().isEmpty()) {
            // If there are no snappable disks, there is no meaning for
            // running as stateless, log a warning and run normally
            warnIfNotAllDisksPermitSnapshots();
            return setFlow(RunVmFlow.RUN);
        }
        if (isStatelessSnapshotExistsForVm()) {
            log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
            return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
        }
        return setFlow(RunVmFlow.CREATE_STATELESS_IMAGES);
    }
    if (!isInternalExecution() && isStatelessSnapshotExistsForVm() && !isVmPartOfManualPool()) {
        return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
    }
    return setFlow(RunVmFlow.RUN);
}
#method_after
protected RunVmFlow getFlow() {
    RunVmFlow cachedFlow = getParameters().getCachedFlow();
    if (cachedFlow != null) {
        return cachedFlow;
    }
    switch(getVm().getStatus()) {
        case Paused:
            return setFlow(RunVmFlow.RESUME_PAUSE);
        case Suspended:
            return setFlow(RunVmFlow.RESUME_HIBERNATE);
        default:
    }
    if (isRunAsStateless()) {
        fetchVmDisksFromDb();
        if (getVm().getDiskList().isEmpty()) {
            // If there are no snappable disks, there is no meaning for
            // running as stateless, log a warning and run normally
            warnIfNotAllDisksPermitSnapshots();
            return setFlow(RunVmFlow.RUN);
        }
        if (isStatelessSnapshotExistsForVm()) {
            log.error("VM '{}' ({}) already contains stateless snapshot, removing it", getVm().getName(), getVm().getId());
            return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
        }
        return setFlow(RunVmFlow.CREATE_STATELESS_IMAGES);
    }
    if (!isInternalExecution() && isStatelessSnapshotExistsForVm() && !isVmPartOfManualPool()) {
        return setFlow(RunVmFlow.REMOVE_STATELESS_IMAGES);
    }
    return setFlow(RunVmFlow.RUN);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (shouldEndSnapshotCreation()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        getParameters().setCachedFlow(null);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#method_after
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    if (step == null) {
        return cloneContextAndDetachFromParent();
    }
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (shouldEndSnapshotCreation()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
public boolean isEmpty() {
    return getOutAverageLinkshare() == null && getOutAverageUpperlimit() == null && getOutAverageRealtime() == null;
}
#method_after
public boolean isEmpty() {
    return hostNetworkQosProperties.isEmpty();
}
#end_block

#method_before
public boolean isEmpty() {
    return getOutAverageLinkshare() == null && getOutAverageUpperlimit() == null && getOutAverageRealtime() == null;
}
#method_after
public boolean isEmpty() {
    return hostNetworkQosProperties.isEmpty();
}
#end_block

#method_before
public static <T> List<String> validateInputs(List<Class<?>> validationGroupList, T parameters) {
    List<String> messages = Collections.emptyList();
    Set<ConstraintViolation<T>> violations = ValidationUtils.getValidator().validate(parameters, validationGroupList.toArray(new Class<?>[validationGroupList.size()]));
    if (!violations.isEmpty()) {
        messages = new ArrayList<>(violations.size());
        for (ConstraintViolation<T> constraintViolation : violations) {
            if (constraintViolation.getPropertyPath() != null) {
                messages.add(String.format("%1$s[%2$s]", constraintViolation.getMessage(), constraintViolation.getPropertyPath()));
            } else {
                messages.add(constraintViolation.getMessage());
            }
        }
    }
    return messages;
}
#method_after
public static <T> List<String> validateInputs(List<Class<?>> validationGroupList, T parameters) {
    List<String> messages = Collections.emptyList();
    Set<ConstraintViolation<T>> violations = ValidationUtils.getValidator().validate(parameters, validationGroupList.toArray(new Class<?>[validationGroupList.size()]));
    if (!violations.isEmpty()) {
        messages = new ArrayList<>(violations.size());
        for (ConstraintViolation<T> constraintViolation : violations) {
            messages.add(constraintViolation.getMessage());
            if (constraintViolation.getPropertyPath() != null) {
                messages.add(EngineMessage.ACTION_TYPE_FAILED_ATTRIBUTE_PATH.name());
                messages.add(String.format("$path %s", constraintViolation.getPropertyPath()));
            }
        }
    }
    return messages;
}
#end_block

#method_before
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasCreatedByUser(vm.getCreatedByUserId() != null);
    if (getHasCreatedByUser()) {
        Frontend.getInstance().runQuery(VdcQueryType.GetDbUserByUserId, new IdQueryParameters(vm.getCreatedByUserId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object result) {
                VmGeneralModel model = (VmGeneralModel) target;
                Object dbUser = ((VdcQueryReturnValue) result).getReturnValue();
                model.setCreatedByUser(getUserName(dbUser));
            }

            private String getUserName(Object dbUserObject) {
                String userName = "";
                if (dbUserObject != null) {
                    DbUser dbUser = (DbUser) dbUserObject;
                    if (StringUtils.isNotEmpty(dbUser.getFirstName()) || StringUtils.isNotEmpty(dbUser.getLastName())) {
                        userName = messages.userName(nullToEmpty(dbUser.getFirstName()), nullToEmpty(dbUser.getLastName()));
                    } else {
                        userName = dbUser.getLoginName();
                    }
                }
                return userName;
            }

            private String nullToEmpty(String val) {
                return val == null ? "" : val;
            }
        }));
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS).withoutRefresh(), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (localVm.getDedicatedVmForVdsList().size() > 0) {
                    String defaultHost = "";
                    for (VDS host : hosts) {
                        if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                            if (defaultHost.isEmpty()) {
                                defaultHost = host.getName();
                            } else {
                                // $NON-NLS-1$
                                defaultHost += ", " + host.getName();
                            }
                        }
                    }
                    model.setDefaultHost(defaultHost);
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#method_after
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasCreatedByUser(vm.getCreatedByUserId() != null);
    if (getHasCreatedByUser()) {
        Frontend.getInstance().runQuery(VdcQueryType.GetDbUserByUserId, new IdQueryParameters(vm.getCreatedByUserId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object result) {
                DbUser dbUser = ((VdcQueryReturnValue) result).getReturnValue();
                if (dbUser != null) {
                    setCreatedByUser(getUserName(dbUser));
                }
            }

            private String getUserName(DbUser dbUser) {
                if (StringUtils.isNotEmpty(dbUser.getFirstName()) || StringUtils.isNotEmpty(dbUser.getLastName())) {
                    return messages.userName(nullToEmpty(dbUser.getFirstName()), nullToEmpty(dbUser.getLastName()));
                }
                return dbUser.getLoginName();
            }

            private String nullToEmpty(String val) {
                return val == null ? "" : val;
            }
        }));
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS).withoutRefresh(), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (localVm.getDedicatedVmForVdsList().size() > 0) {
                    String defaultHost = "";
                    for (VDS host : hosts) {
                        if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                            if (defaultHost.isEmpty()) {
                                defaultHost = host.getName();
                            } else {
                                // $NON-NLS-1$
                                defaultHost += ", " + host.getName();
                            }
                        }
                    }
                    model.setDefaultHost(defaultHost);
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Disk incoming, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    DiskAttachment diskAttachmentFromDb = BackendApiResource.getInstance().getVmsResource().getVmResource(vmId.toString()).getDiskAttachmentsResource().getAttachmentResource(entity.getId().toString()).get();
    DiskAttachment updatedDiskAttachment = mapDiskToDiskAttachment(incoming, diskAttachmentFromDb);
    return new VmDiskOperationParameterBase(DiskAttachmentMapper.map(updatedDiskAttachment, new DiskVmElement(entity.getId(), vmId)), map(incoming, entity));
}
#method_after
@Override
public VdcActionParametersBase getParameters(Disk incoming, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    DiskVmElement dveFromDb = runQuery(VdcQueryType.GetDiskVmElementById, new VmDeviceIdQueryParameters(new VmDeviceId(entity.getId(), vmId))).getReturnValue();
    DiskVmElement updatedDve = updateDiskVmElementFromDisk(incoming, dveFromDb);
    return new VmDiskOperationParameterBase(updatedDve, map(incoming, entity));
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    DiskAttachment diskAttachment = new DiskAttachment();
    if (disk.isSetBootable()) {
        diskAttachment.setBootable(disk.isBootable());
    }
    if (disk.isSetInterface()) {
        diskAttachment.setInterface(disk.getInterface());
    } else {
        diskAttachment.setInterface(DiskInterface.VIRTIO);
    }
    diskAttachment.setDisk(disk);
    if (disk.isSetId()) {
        Guid diskId = Guid.createGuidFromStringDefaultEmpty(disk.getId());
        return getAttachmentsResource().attachDiskToVm(this, diskAttachment, new OldAttachDiskResolver(diskId));
    } else {
        return getAttachmentsResource().createDisk(this, diskAttachment, new OldAddDiskResolver());
    }
}
#method_after
@Override
public Response add(Disk disk) {
    DiskAttachment diskAttachment = new DiskAttachment();
    if (disk.isSetBootable()) {
        diskAttachment.setBootable(disk.isBootable());
    } else {
        diskAttachment.setBootable(false);
    }
    if (disk.isSetInterface()) {
        diskAttachment.setInterface(disk.getInterface());
    } else {
        diskAttachment.setInterface(DiskInterface.VIRTIO);
    }
    diskAttachment.setDisk(disk);
    if (disk.isSetId()) {
        Guid diskId = Guid.createGuidFromStringDefaultEmpty(disk.getId());
        return getAttachmentsResource().attachDiskToVm(this, diskAttachment, new OldAttachDiskResolver(diskId));
    } else {
        return getAttachmentsResource().createDisk(this, diskAttachment, new OldAddDiskResolver());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (updateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(() -> {
            getStoragePool().setStatus(StoragePoolStatus.Maintenance);
            getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
            DbFacade.getInstance().getStoragePoolDao().update(getStoragePool());
            getCompensationContext().stateChanged();
            StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
            return null;
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        boolean isStoragePoolInIrsFound = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePool().getId());
                StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            if (!isStoragePoolInIrsFound) {
                retVal = addStoragePoolInIrs();
                if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == EngineError.StorageDomainAccessError) {
                    log.warn("Error creating storage pool on vds '{}' - continuing", vds.getName());
                    continue;
                }
                // storage pool creation succeeded or failed
                // but didn't throw exception
                result = retVal.getSucceeded();
                isStoragePoolInIrsFound = true;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new EngineException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new EngineException(EngineError.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        } else {
            registerOvfStoreDisks();
        }
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(() -> {
        // TODO MMUCHA: Dear code reviewer! I think CommandBase would(should) handle that. Please advise.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        activateStorageDomains();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (updateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(() -> {
            getStoragePool().setStatus(StoragePoolStatus.Maintenance);
            getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
            DbFacade.getInstance().getStoragePoolDao().update(getStoragePool());
            getCompensationContext().stateChanged();
            StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
            return null;
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        // Once we create a storage pool with multiple hosts, the engine should connect all
        // the hosts in the storage pool,
        // since the engine picks a random host to fetch all the unregistered disks.
        boolean isStoragePoolCreated = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePool().getId());
                StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            if (!isStoragePoolCreated) {
                retVal = addStoragePoolInIrs();
                if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == EngineError.StorageDomainAccessError) {
                    log.warn("Error creating storage pool on vds '{}' - continuing", vds.getName());
                    continue;
                }
                // storage pool creation succeeded or failed
                // but didn't throw exception
                result = retVal.getSucceeded();
                isStoragePoolCreated = true;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new EngineException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new EngineException(EngineError.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        } else {
            registerOvfStoreDisks();
        }
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(() -> {
        // TODO MMUCHA: Dear code reviewer! I think CommandBase would(should) handle that. Please advise.
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        activateStorageDomains();
    }
}
#end_block

#method_before
public void initMigrationPolicies(boolean isEdit) {
    List<MigrationPolicy> policies = AsyncDataProvider.getInstance().getMigrationPolicies();
    getMigrationPolicies().setItems(policies);
    if (isEdit) {
        for (MigrationPolicy policy : policies) {
            if (Objects.equals(policy.getId(), getEntity().getMigrationPolicyId())) {
                getMigrationPolicies().setSelectedItem(policy);
                break;
            }
        }
    } else {
        // the first defined item in the list is the default selected
        for (MigrationPolicy policy : policies) {
            if (!Objects.equals(policy.getId(), NoMigrationPolicy.ID)) {
                getMigrationPolicies().setSelectedItem(policy);
                break;
            }
        }
    }
}
#method_after
public void initMigrationPolicies(boolean isEdit) {
    List<MigrationPolicy> policies = AsyncDataProvider.getInstance().getMigrationPolicies();
    getMigrationPolicies().setItems(policies);
    MigrationPolicy migrationPolicy = isEdit ? findMigrationPolicyById(getEntity().getMigrationPolicyId(), policies) : findFirstNonEmptyMigrationPolicy(policies);
    getMigrationPolicies().setSelectedItem(migrationPolicy != null ? migrationPolicy : findMigrationPolicyById(NoMigrationPolicy.ID, policies));
}
#end_block

#method_before
private void updateLabelList() {
    AsyncQuery getLabelsQuery = new AsyncQuery();
    getLabelsQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            List<Label> allLabels = (List<Label>) result;
            if (getIsNew()) {
                labelList.setItems(allLabels);
                labelList.setSelectedItems(new ArrayList<Label>());
            } else {
                List<Label> selectedLabels = new ArrayList<>();
                for (Label label : allLabels) {
                    if (label.getHosts().contains(getHostId())) {
                        selectedLabels.add(label);
                    }
                }
                labelList.setItems(allLabels);
                labelList.setSelectedItems(selectedLabels);
            }
            labelList.setIsChangeable(false);
        }
    };
    AsyncDataProvider.getInstance().getLabelList(getLabelsQuery);
}
#method_after
private void updateLabelList() {
    final AsyncQuery getAllLabelsQuery = new AsyncQuery();
    getAllLabelsQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            final List<Label> allLabels = (List<Label>) result;
            if (getIsNew()) {
                labelList.setItems(allLabels);
                labelList.setSelectedItems(new ArrayList<Label>());
            } else {
                AsyncQuery getLabelsByHostIdQuery = new AsyncQuery();
                getLabelsByHostIdQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        List<Label> hostLabelsList = (List<Label>) returnValue;
                        labelList.setItems(allLabels);
                        labelList.setSelectedItems(hostLabelsList);
                    }
                };
                AsyncDataProvider.getInstance().getLabelListByEntityId(getLabelsByHostIdQuery, getHostId());
            }
            // This is phase 1 of this feature. Phase 2 will introduce the ability to make
            // changes to the selected labels via the UI. Until then, labels can be set through
            // the REST API.
            labelList.setIsChangeable(false);
        }
    };
    AsyncDataProvider.getInstance().getLabelList(getAllLabelsQuery);
}
#end_block

#method_before
public void getLabelList(AsyncQuery aQuery) {
    getLabelList(aQuery, true);
}
#method_after
public void getLabelList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Label> list = (ArrayList<Label>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Label>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllLabels, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(model.getProtocol().getEntity() ? VdsProtocol.STOMP : VdsProtocol.XML);
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    updateLabels(model.getLabelList().getSelectedItems(), host);
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(model.getProtocol().getEntity() ? VdsProtocol.STOMP : VdsProtocol.XML);
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getActions().getSelectedItem()));
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
private void updateLabelList() {
    AsyncQuery getLabelsQuery = new AsyncQuery();
    getLabelsQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            List<Label> allLabels = (List<Label>) result;
            if (getIsNew()) {
                labelList.setItems(allLabels);
                labelList.setSelectedItems(new ArrayList<Label>());
            } else {
                List<Label> selectedLabels = new ArrayList<>();
                for (Label label : allLabels) {
                    if (label.getHosts().contains(getVmId())) {
                        selectedLabels.add(label);
                    }
                }
                labelList.setItems(allLabels);
                labelList.setSelectedItems(selectedLabels);
            }
            labelList.setIsChangeable(false);
        }
    };
    AsyncDataProvider.getInstance().getLabelList(getLabelsQuery);
}
#method_after
private void updateLabelList() {
    AsyncQuery getLabelsQuery = new AsyncQuery();
    getLabelsQuery.asyncCallback = new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object model, Object result) {
            final List<Label> allLabels = (List<Label>) result;
            if (getIsNew()) {
                labelList.setItems(allLabels);
                labelList.setSelectedItems(new ArrayList<Label>());
            } else {
                AsyncQuery getLabelsByVmIdQuery = new AsyncQuery();
                getLabelsByVmIdQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        List<Label> vmLabelsList = (List<Label>) returnValue;
                        labelList.setItems(allLabels);
                        labelList.setSelectedItems(vmLabelsList);
                    }
                };
                Guid vmId = ((ExistingVmModelBehavior) getBehavior()).getVm().getId();
                AsyncDataProvider.getInstance().getLabelListByEntityId(getLabelsByVmIdQuery, vmId);
            }
            labelList.setIsChangeable(false);
        }
    };
    AsyncDataProvider.getInstance().getLabelList(getLabelsQuery);
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangeable(true);
    getCdImage().setIsChangeable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    initConsoleDisconnectAction();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangeable(true);
    getCdImage().setIsChangeable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    initConsoleDisconnectAction();
    updateLabelList();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getLabelList()) {
            labelsChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        } else if (sender == getName()) {
            autoSetHostname();
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        } else if (sender == getName()) {
            autoSetHostname();
        }
    }
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public SortedMap<String, List<Cluster>> getGroupedList(List<Cluster> acceptableValues) {
            SortedMap<String, List<Cluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterClusterComparator());
            String currentDataCenter = null;
            List<Cluster> currentClusterList = null;
            for (Cluster cluster : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(cluster.getStoragePoolName())) {
                    currentClusterList = new ArrayList<>();
                    currentDataCenter = cluster.getStoragePoolName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterList);
                    }
                }
                if (currentClusterList != null) {
                    currentClusterList.add(cluster);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    labelEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<org.ovirt.engine.core.common.businessentities.Label>(), new ModeSwitchingVisibilityRenderer());
    labelEditor.asListBox().setVisibleItemCount(3);
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    protocolEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public SortedMap<String, List<Cluster>> getGroupedList(List<Cluster> acceptableValues) {
            SortedMap<String, List<Cluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterClusterComparator());
            String currentDataCenter = null;
            List<Cluster> currentClusterList = null;
            for (Cluster cluster : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(cluster.getStoragePoolName())) {
                    currentClusterList = new ArrayList<>();
                    currentDataCenter = cluster.getStoragePoolName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterList);
                    }
                }
                if (currentClusterList != null) {
                    currentClusterList.add(cluster);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    labelEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<org.ovirt.engine.core.common.businessentities.Label>(), new VisibilityRenderer.SimpleVisibilityRenderer());
    labelEditor.asListBox().setVisibleItemCount(VISIBLE_ITEM_COUNT);
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    protocolEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
}
#end_block

#method_before
@Override
protected void executeSave() {
    boolean addOnProvider = getExport().getEntity();
    IFrontendActionAsyncCallback addNetworkCallback = addNetworkCallback(addOnProvider);
    final AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    // New network
    if (addOnProvider) {
        Provider externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        Frontend.getInstance().runAction(VdcActionType.AddNetworkOnProvider, parameters, addNetworkCallback, null);
    } else {
        Frontend.getInstance().runAction(VdcActionType.AddNetwork, parameters, addNetworkCallback, null);
    }
}
#method_after
@Override
protected void executeSave() {
    final AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    // New network
    if (getExport().getEntity()) {
        Provider externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        Frontend.getInstance().runAction(VdcActionType.AddNetworkOnProvider, parameters, addNetworkOnProviderCallback(), null);
    } else {
        Frontend.getInstance().runAction(VdcActionType.AddNetwork, parameters, addNetworkCallback(), null);
    }
}
#end_block

#method_before
private IFrontendActionAsyncCallback addNetworkCallback(final boolean addOnProvider) {
    return new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            VdcReturnValueBase retVal = result1.getReturnValue();
            boolean succeeded = false;
            if (retVal != null && retVal.getSucceeded()) {
                succeeded = true;
            }
            if (!succeeded) {
                postSaveAction(null, null, succeeded);
            } else if (addOnProvider) {
                postSaveAction((Network) retVal.getActionReturnValue(), succeeded);
            } else {
                postSaveAction((Guid) retVal.getActionReturnValue(), null, succeeded);
            }
        }
    };
}
#method_after
private IFrontendActionAsyncCallback addNetworkCallback() {
    return new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            postAddNetwork(result1.getReturnValue());
        }
    };
}
#end_block

#method_before
protected void postSaveAction(Guid id, ProviderNetwork providedBy, boolean succeeded) {
    super.postSaveAction(id, succeeded);
    if (!succeeded) {
        return;
    }
    attachNetworkToClusters(id);
    if (getExport().getEntity() && getCreateSubnet().getEntity() && providedBy != null) {
        getSubnetModel().setExternalNetwork(providedBy);
        getSubnetModel().flush();
        Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(getSubnetModel().getSubnet(), providedBy.getProviderId(), providedBy.getExternalId()));
    }
}
#method_after
private void postSaveAction(Guid id, ProviderNetwork providedBy) {
    super.postSaveAction(id, true);
    attachNetworkToClusters(id);
    if (getExport().getEntity() && getCreateSubnet().getEntity() && providedBy != null) {
        getSubnetModel().setExternalNetwork(providedBy);
        getSubnetModel().flush();
        Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(getSubnetModel().getSubnet(), providedBy.getProviderId(), providedBy.getExternalId()));
    }
}
#end_block

#method_before
private static SwitchType getSwitchType(Version clusterVersion, Map<String, Object> networkProperties) {
    Object switchType = networkProperties.get(VdsProperties.SWITCH_KEY);
    boolean switchTypeShouldBeReportedByOvs = FeatureSupported.ovsSupported(clusterVersion);
    if (switchTypeShouldBeReportedByOvs && switchType == null) {
        throw new IllegalStateException("Required SwitchType is not reported.");
    }
    return switchType != null ? SwitchType.parse(switchType.toString()) : null;
}
#method_after
private static SwitchType getSwitchType(Version clusterVersion, Map<String, Object> networkProperties) {
    Object switchType = networkProperties.get(VdsProperties.SWITCH_KEY);
    boolean switchTypeShouldBeReportedByVdsm = FeatureSupported.ovsSupported(clusterVersion);
    if (switchTypeShouldBeReportedByVdsm && switchType == null) {
        throw new IllegalStateException("Required SwitchType is not reported.");
    }
    return SwitchType.parse(Objects.toString(switchType, null));
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VmPool incoming, org.ovirt.engine.core.common.businessentities.VmPool current) {
    final int currentVmCount = current.getAssignedVmsCount();
    int size = 0;
    if (incoming.isSetSize()) {
        // in case the value is negative, the backend command will fail on validate
        size = incoming.getSize() - currentVmCount;
    }
    final org.ovirt.engine.core.common.businessentities.VmPool entity = map(incoming, current);
    final VM vm = mapToVM(map(entity));
    if (incoming.isSetTemplate()) {
        vm.setVmtGuid(getTempalteId(incoming.getTemplate()));
    } else {
        final VM existing = currentVmCount > 0 ? getEntity(VM.class, VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(current.getId()), "Vms: pool=" + current.getId()) : null;
        if (existing != null) {
            vm.setVmtGuid(existing.getVmtGuid());
            vm.setVmInit(existing.getVmInit());
        }
    }
    if (vm.getVmtGuid() != null) {
        final VmTemplate template = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(vm.getVmtGuid()), vm.getVmtGuid().toString());
        vm.getStaticData().setMemSizeMb(template.getMemSizeMb());
        vm.getStaticData().setSingleQxlPci(template.getSingleQxlPci());
        vm.getStaticData().setOsId(template.getOsId());
        vm.getStaticData().setDefaultDisplayType(template.getDefaultDisplayType());
        vm.getStaticData().setMigrationSupport(template.getMigrationSupport());
    }
    if (incoming.isSetUseLatestTemplateVersion()) {
        vm.setUseLatestVersion(incoming.isUseLatestTemplateVersion());
    }
    final AddVmPoolWithVmsParameters parameters = new AddVmPoolWithVmsParameters(entity, vm, size, -1);
    parameters.setStorageDomainId(getStorageDomainId(vm.getVmtGuid()));
    return parameters;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VmPool incoming, org.ovirt.engine.core.common.businessentities.VmPool current) {
    final int currentVmCount = current.getAssignedVmsCount();
    int size = 0;
    if (incoming.isSetSize()) {
        // in case the value is negative, the backend command will fail on validate
        size = incoming.getSize() - currentVmCount;
    }
    final org.ovirt.engine.core.common.businessentities.VmPool entity = map(incoming, current);
    final VM vm = mapToVM(map(entity));
    if (incoming.isSetTemplate()) {
        vm.setVmtGuid(getTempalteId(incoming.getTemplate()));
    } else {
        final VM existing = currentVmCount > 0 ? getEntity(VM.class, VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(current.getId()), "Vms: pool=" + current.getId()) : null;
        if (existing != null) {
            vm.setVmtGuid(existing.getVmtGuid());
            vm.setVmInit(existing.getVmInit());
        }
    }
    if (vm.getVmtGuid() != null) {
        final VmTemplate template = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(vm.getVmtGuid()), vm.getVmtGuid().toString());
        vm.getStaticData().setMemSizeMb(template.getMemSizeMb());
        vm.getStaticData().setSingleQxlPci(template.getSingleQxlPci());
        vm.getStaticData().setOsId(template.getOsId());
        vm.getStaticData().setDefaultDisplayType(template.getDefaultDisplayType());
        vm.getStaticData().setMigrationSupport(template.getMigrationSupport());
        if (vm.getVmInit() == null) {
            vm.setVmInit(template.getVmInit());
        }
    }
    if (incoming.isSetUseLatestTemplateVersion()) {
        vm.setUseLatestVersion(incoming.isUseLatestTemplateVersion());
    }
    final AddVmPoolWithVmsParameters parameters = new AddVmPoolWithVmsParameters(entity, vm, size, -1);
    parameters.setStorageDomainId(getStorageDomainId(vm.getVmtGuid()));
    return parameters;
}
#end_block

#method_before
public static List<Pair<Guid, DiskImageDynamic>> sortDiskImageDynamicForUpdate(Collection<Pair<Guid, DiskImageDynamic>> diskImageDynamicForVm) {
    List<Pair<Guid, DiskImageDynamic>> sortedDisks = new ArrayList<>();
    sortedDisks.addAll(diskImageDynamicForVm);
    sortedDisks.sort((Pair<Guid, DiskImageDynamic> p1, Pair<Guid, DiskImageDynamic> p2) -> p1.getSecond().getId().compareTo(p2.getSecond().getId()));
    return sortedDisks;
}
#method_after
public static List<Pair<Guid, DiskImageDynamic>> sortDiskImageDynamicForUpdate(Collection<Pair<Guid, DiskImageDynamic>> diskImageDynamicForVm) {
    List<Pair<Guid, DiskImageDynamic>> sortedDisks = new ArrayList<>();
    sortedDisks.addAll(diskImageDynamicForVm);
    sortedDisks.sort(Comparator.comparing(x -> x.getSecond().getId()));
    return sortedDisks;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    initPoolUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach();
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach();
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
            setVmId(vmToAttach);
            Permission perm = new Permission(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParameters permParams = new PermissionsOperationsParameters(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(getActionType());
            permParams.setParentParameters(getParameters());
            VdcReturnValueBase vdcReturnValueFromAddPerm = runInternalAction(VdcActionType.AddPermission, permParams, cloneContext().withoutExecutionContext().withoutLock());
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.info("Failed to give user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.info("Succeeded giving user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
            }
        } else {
            log.info("No free Vms in pool '{}'. Cannot allocate for user '{}'", getVmPoolId(), getAdUserId());
            throw new EngineException(EngineError.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(getVmDao().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
        runVmParams.setParentCommand(getActionType());
        runVmParams.setParentParameters(getParameters());
        runVmParams.setRunAsStateless(!getVmPool().isStateful());
        ExecutionContext runVmContext = createRunVmContext();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RunVm, runVmParams, cloneContext().withExecutionContext(runVmContext).withoutLock().withCompensationContext(null));
        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getVdsmTaskIdList().addAll(getReturnValue().getInternalVdsmTaskIdList());
    } else {
        // no need to start, just return it
        setActionReturnValue(vmToAttach);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    initPoolUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach();
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach();
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
            setVmId(vmToAttach);
            Permission perm = new Permission(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParameters permParams = new PermissionsOperationsParameters(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(getActionType());
            permParams.setParentParameters(getParameters());
            VdcReturnValueBase vdcReturnValueFromAddPerm = runInternalAction(VdcActionType.AddPermission, permParams, cloneContext().withoutExecutionContext().withoutLock());
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.info("Failed to give user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.info("Succeeded giving user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
            }
        } else {
            log.info("No free Vms in pool '{}'. Cannot allocate for user '{}'", getVmPoolId(), getAdUserId());
            throw new EngineException(EngineError.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(getVmDao().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
        runVmParams.setParentCommand(getActionType());
        runVmParams.setParentParameters(getParameters());
        runVmParams.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        runVmParams.setRunAsStateless(!getVmPool().isStateful());
        ExecutionContext runVmContext = createRunVmContext();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RunVm, runVmParams, cloneContext().withExecutionContext(runVmContext).withoutLock().withCompensationContext(null));
        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getVdsmTaskIdList().addAll(getReturnValue().getInternalVdsmTaskIdList());
    } else {
        // no need to start, just return it
        setActionReturnValue(vmToAttach);
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    RunVmParams runVmParams = getChildRunVmParameters();
    if (runVmParams != null) {
        setVmId(runVmParams.getVmId());
        if (getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS)) {
            setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, runVmParams, cloneContext().withoutLock().withoutExecutionContext()).getSucceeded());
            if (!getSucceeded()) {
                log.warn("endSuccessfully: endAction of RunVm failed, detaching user from Vm");
                // just in case.
                detachUserFromVmFromPool();
                getReturnValue().setEndActionTryAgain(false);
            }
        } else {
            // Pool-snapshot is gone (probably due to processVmPoolOnStopVm
            // treatment) ->
            // no point in running the VM or trying to run again the endAction
            // method:
            log.warn("endSuccessfully: No images were created for Vm, detaching user from Vm");
            // just in case.
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("endSuccessfully: Vm is null - not performing full endAction");
        setSucceeded(true);
    }
}
#method_after
@Override
protected void endSuccessfully() {
    RunVmParams runVmParams = getChildRunVmParameters();
    if (runVmParams != null) {
        setVmId(runVmParams.getVmId());
        if (!isRunVmSucceeded()) {
            log.warn("endSuccessfully: RunVm failed, detaching user from VM");
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("endSuccessfully: VM is null");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    RunVmParams runVmParams = getChildRunVmParameters();
    if (runVmParams != null) {
        setVmId(runVmParams.getVmId());
        setSucceeded(Backend.getInstance().endAction(VdcActionType.RunVm, runVmParams, cloneContext().withoutExecutionContext().withoutLock()).getSucceeded());
        if (!getSucceeded()) {
            log.warn("endWithFailure: endAction of RunVm failed");
        }
        detachUserFromVmFromPool();
    }
}
#method_after
@Override
protected void endWithFailure() {
    RunVmParams runVmParams = getChildRunVmParameters();
    if (runVmParams != null) {
        setVmId(runVmParams.getVmId());
        log.warn("endWithFailure: RunVm failed, detaching user from VM");
        detachUserFromVmFromPool();
    } else {
        log.warn("endWithFailure: VM is null");
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void detachUserFromVmFromPool() {
    // Detach user from vm from pool:
    if (!Guid.Empty.equals(getAdUserId())) {
        Permission perm = getPermissionDao().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            getPermissionDao().remove(perm.getId());
        }
    }
}
#method_after
protected void detachUserFromVmFromPool() {
    if (!Guid.Empty.equals(getAdUserId())) {
        Permission perm = getPermissionDao().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            getPermissionDao().remove(perm.getId());
        }
    }
}
#end_block

#method_before
protected List<Guid> getPredefinedVdsIdListToRunOn() {
    return getVm().getDedicatedVmForVdsList();
}
#method_after
protected List<Guid> getPredefinedVdsIdListToRunOn() {
    // only to allow the user to disable it.
    return Collections.emptyList();
}
#end_block

#method_before
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clearVms();
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery(this, createGetStorageDomainsByStoragePoolIdCallback(dataCenter)));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncQuery hostsQuery = new AsyncQuery();
            hostsQuery.setModel(ImportVmsModel.this);
            hostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<VDS> hosts = (List<VDS>) returnValue;
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            };
            AsyncDataProvider.getInstance().getHostListByDataCenter(hostsQuery, dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#method_after
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clearVms();
            exportDomain.setEntity(null);
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery(this, createGetStorageDomainsByStoragePoolIdCallback(dataCenter)));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncQuery hostsQuery = new AsyncQuery();
            hostsQuery.setModel(ImportVmsModel.this);
            hostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<VDS> hosts = (List<VDS>) returnValue;
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            };
            AsyncDataProvider.getInstance().getHostListByDataCenter(hostsQuery, dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#end_block

#method_before
@Override
public void init(final ImportVmsModel model) {
    super.init(model);
    addDataCenterListeners();
    updateExportDomainLoadButtonEnabledState();
}
#method_after
@Override
public void init(final ImportVmsModel model) {
    super.init(model);
    addDataCenterListener();
    addExportDomainListener();
    updateExportDomainLoadButtonEnabledState();
}
#end_block

#method_before
protected void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                if (exSchedulerDiscovery.discover()) {
                    reloadPolicyUnits();
                }
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#method_after
private void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                if (exSchedulerDiscovery.discover()) {
                    reloadPolicyUnits();
                }
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#end_block

#method_before
public void reloadPolicyUnits() {
    synchronized (policyUnitsLock) {
        policyUnits = new ConcurrentHashMap<>();
        loadPolicyUnits();
    }
}
#method_after
private void reloadPolicyUnits() {
    synchronized (policyUnitsLock) {
        policyUnits = new ConcurrentHashMap<>();
        loadPolicyUnits();
    }
}
#end_block

#method_before
protected void loadClusterPolicies() {
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll();
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#method_after
private void loadClusterPolicies() {
    // Load internal cluster policies
    policyMap.putAll(InternalClusterPolicies.getClusterPolicies());
    // Get all user provided cluster policies
    List<ClusterPolicy> allClusterPolicies = getClusterPolicyDao().getAll();
    for (ClusterPolicy clusterPolicy : allClusterPolicies) {
        policyMap.put(clusterPolicy.getId(), clusterPolicy);
    }
}
#end_block

#method_before
protected void loadPolicyUnits() {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        if (policyUnit.isInternal()) {
            policyUnits.put(policyUnit.getId(), PolicyUnitImpl.getPolicyUnitImpl(policyUnit, getPendingResourceManager()));
        } else {
            policyUnits.put(policyUnit.getId(), new PolicyUnitImpl(policyUnit, getPendingResourceManager()));
        }
    }
}
#method_after
private void loadPolicyUnits() {
    // Load internal policy units
    for (Class<? extends PolicyUnitImpl> unitType : InternalPolicyUnits.getList()) {
        PolicyUnitImpl unit = InternalPolicyUnits.instantiate(unitType, getPendingResourceManager());
        if (unit != null) {
            policyUnits.put(unit.getGuid(), Injector.injectMembers(unit));
        } else {
            log.error("Could not instantiate a policy unit {}.", unitType.getName());
        }
    }
    // Load all external policy units
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    for (PolicyUnit policyUnit : allPolicyUnits) {
        policyUnits.put(policyUnit.getId(), new ExternalPolicyUnit(policyUnit, getPendingResourceManager()));
    }
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, vdsList, policy, parameters);
        if (bestHost != null) {
            getPendingResourceManager().addPending(new PendingCpuCores(bestHost, vm, vm.getNumOfCpus()));
            getPendingResourceManager().addPending(new PendingMemory(bestHost, vm, vm.getMinAllocatedMem()));
            getPendingResourceManager().addPending(new PendingVM(bestHost, vm));
            getPendingResourceManager().notifyHostManagers(bestHost);
            VfScheduler vfScheduler = Injector.get(VfScheduler.class);
            Map<Guid, String> passthroughVnicToVfMap = vfScheduler.getVnicToVfMap(vm.getId(), bestHost);
            if (passthroughVnicToVfMap != null && !passthroughVnicToVfMap.isEmpty()) {
                markVfsAsUsedByVm(bestHost, vm.getId(), passthroughVnicToVfMap);
            }
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, List<Guid> destHostIdList, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost != null) {
            getPendingResourceManager().addPending(new PendingCpuCores(bestHost, vm, vm.getNumOfCpus()));
            getPendingResourceManager().addPending(new PendingMemory(bestHost, vm, vm.getMinAllocatedMem()));
            getPendingResourceManager().addPending(new PendingVM(bestHost, vm));
            getPendingResourceManager().notifyHostManagers(bestHost);
            VfScheduler vfScheduler = Injector.get(VfScheduler.class);
            Map<Guid, String> passthroughVnicToVfMap = vfScheduler.getVnicToVfMap(vm.getId(), bestHost);
            if (passthroughVnicToVfMap != null && !passthroughVnicToVfMap.isEmpty()) {
                markVfsAsUsedByVm(bestHost, vm.getId(), passthroughVnicToVfMap);
            }
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
private Guid selectBestHost(VDSGroup cluster, VM vm, List<VDS> availableVdsList, ClusterPolicy policy, Map<String, String> parameters) {
    switch(availableVdsList.size()) {
        case 0:
            // no runnable hosts found, nothing found
            return null;
        case 1:
            // found single available host, in available list return it
            return availableVdsList.get(0).getId();
        default:
            // select best runnable host with scoring functions (from policy)
            List<Pair<Guid, Integer>> functions = policy.getFunctions();
            if (functions != null && !functions.isEmpty() && shouldWeighClusterHosts(cluster, availableVdsList)) {
                Guid bestHostByFunctions = runFunctions(functions, availableVdsList, vm, parameters);
                if (bestHostByFunctions != null) {
                    return bestHostByFunctions;
                }
            }
    }
    // failed select best runnable host using scoring functions, return the first
    return availableVdsList.get(0).getId();
}
#method_after
private Guid selectBestHost(VDSGroup cluster, VM vm, List<Guid> destHostIdList, List<VDS> availableVdsList, ClusterPolicy policy, Map<String, String> parameters) {
    // in case a default destination host was specified and
    // it passed filters, return the first found
    List<VDS> runnableHosts = new LinkedList<>();
    if (destHostIdList.size() > 0) {
        // intersect dedicated hosts list with available list
        for (VDS vds : availableVdsList) {
            for (Guid destHostId : destHostIdList) {
                if (destHostId.equals(vds.getId())) {
                    runnableHosts.add(vds);
                }
            }
        }
    }
    if (runnableHosts.isEmpty()) {
        // no dedicated hosts found
        runnableHosts = availableVdsList;
    }
    switch(runnableHosts.size()) {
        case 0:
            // no runnable hosts found, nothing found
            return null;
        case 1:
            // found single available host, in available list return it
            return runnableHosts.get(0).getId();
        default:
            // select best runnable host with scoring functions (from policy)
            List<Pair<Guid, Integer>> functions = policy.getFunctions();
            Guid selector = policy.getSelector();
            PolicyUnitImpl selectorUnit = policyUnits.get(selector);
            SelectorInstance selectorInstance = selectorUnit != null ? selectorUnit.selector(parameters) : null;
            if (selectorInstance == null) {
                selectorInstance = new BasicWeightSelectorPolicyUnit.Selector();
            }
            List<Guid> runnableGuids = new ArrayList<>();
            for (VDS h : runnableHosts) {
                runnableGuids.add(h.getId());
            }
            selectorInstance.init(functions, runnableGuids);
            if (functions != null && !functions.isEmpty() && shouldWeighClusterHosts(cluster, runnableHosts)) {
                Guid bestHostByFunctions = runFunctions(selectorInstance, functions, runnableHosts, vm, parameters);
                if (bestHostByFunctions != null) {
                    return bestHostByFunctions;
                }
            }
    }
    // failed select best runnable host using scoring functions, return the first
    return runnableHosts.get(0).getId();
}
#end_block

#method_before
protected void checkAllowOverbooking(VDSGroup cluster) {
    if (OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType() && Config.<Boolean>getValue(ConfigValues.SchedulerAllowOverBooking) && clusterLockMap.get(cluster.getId()).getQueueLength() >= Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold)) {
        log.info("Scheduler: cluster '{}' lock is skipped (cluster is allowed to overbook)", cluster.getName());
        // release pending threads (requests) and current one (+1)
        clusterLockMap.get(cluster.getId()).release(Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold) + 1);
    }
}
#method_after
private void checkAllowOverbooking(VDSGroup cluster) {
    if (OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType() && Config.<Boolean>getValue(ConfigValues.SchedulerAllowOverBooking) && clusterLockMap.get(cluster.getId()).getQueueLength() >= Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold)) {
        log.info("Scheduler: cluster '{}' lock is skipped (cluster is allowed to overbook)", cluster.getName());
        // release pending threads (requests) and current one (+1)
        clusterLockMap.get(cluster.getId()).release(Config.<Integer>getValue(ConfigValues.SchedulerOverBookingThreshold) + 1);
    }
}
#end_block

#method_before
protected boolean shouldWeighClusterHosts(VDSGroup cluster, List<VDS> vdsList) {
    Integer threshold = Config.<Integer>getValue(ConfigValues.SpeedOptimizationSchedulingThreshold);
    // threshold is crossed only when cluster is configured for optimized for speed
    boolean crossedThreshold = OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType() && clusterLockMap.get(cluster.getId()).getQueueLength() > threshold;
    if (crossedThreshold) {
        log.info("Scheduler: skipping whinging hosts in cluster '{}', since there are more than '{}' parallel requests", cluster.getName(), threshold);
    }
    return vdsList.size() > 1 && !crossedThreshold;
}
#method_after
private boolean shouldWeighClusterHosts(VDSGroup cluster, List<VDS> vdsList) {
    Integer threshold = Config.<Integer>getValue(ConfigValues.SpeedOptimizationSchedulingThreshold);
    // threshold is crossed only when cluster is configured for optimized for speed
    boolean crossedThreshold = OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType() && clusterLockMap.get(cluster.getId()).getQueueLength() > threshold;
    if (crossedThreshold) {
        log.info("Scheduler: skipping whinging hosts in cluster '{}', since there are more than '{}' parallel requests", cluster.getName(), threshold);
    }
    return vdsList.size() > 1 && !crossedThreshold;
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<String> messages) {
    List<VDS> vdsList = getVdsDao().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsIdList, List<String> messages) {
    List<VDS> vdsList = getVdsDao().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    refreshCachedPendingValues(vdsList);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#end_block

#method_before
protected Map<String, String> createClusterPolicyParameters(VDSGroup cluster) {
    Map<String, String> parameters = new HashMap<>();
    if (cluster.getClusterPolicyProperties() != null) {
        parameters.putAll(cluster.getClusterPolicyProperties());
    }
    return parameters;
}
#method_after
private Map<String, String> createClusterPolicyParameters(VDSGroup cluster) {
    Map<String, String> parameters = new HashMap<>();
    if (cluster.getClusterPolicyProperties() != null) {
        parameters.putAll(cluster.getClusterPolicyProperties());
    }
    return parameters;
}
#end_block

#method_before
protected void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<>();
        Set<Guid> listSet = new HashSet<>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#method_after
private void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<>();
        Set<Guid> listSet = new HashSet<>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    filters = new ArrayList<>(filters);
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<>();
    filters = (filters != null) ? new ArrayList<>(filters) : new ArrayList<Guid>();
    sortFilters(filters, filterPositionMap);
    for (Guid filter : filters) {
        PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
        if (filterPolicyUnit.getPolicyUnit().isInternal()) {
            internalFilters.add(filterPolicyUnit);
        } else {
            if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                externalFilters.add(filterPolicyUnit);
            }
        }
    }
    /* Short circuit filters if there are no hosts at all */
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_NO_HOSTS.name());
        messages.addAll(result.getReasonMessages());
        return hostList;
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(EngineMessage.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
protected Guid runFunctions(List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#method_after
private Guid runFunctions(SelectorInstance selector, List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<>(currentPolicy, pair.getSecond()));
            }
        }
    }
    runInternalFunctions(selector, internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(selector, externalScoreFunctions, hostList, vm, parameters);
    }
    return selector.best();
}
#end_block

#method_before
private Map<Guid, Integer> runInternalFunctions(List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostCostTable = new HashMap<>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        List<Pair<Guid, Integer>> scoreResult = pair.getFirst().score(hostList, vm, parameters);
        for (Pair<Guid, Integer> result : scoreResult) {
            Guid hostId = result.getFirst();
            if (hostCostTable.get(hostId) == null) {
                hostCostTable.put(hostId, 0);
            }
            if (result.getSecond() != null) {
                hostCostTable.put(hostId, hostCostTable.get(hostId) + pair.getSecond() * result.getSecond());
            }
        }
    }
    return hostCostTable;
}
#method_after
private void runInternalFunctions(SelectorInstance selector, List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        List<Pair<Guid, Integer>> scoreResult = pair.getFirst().score(hostList, vm, parameters);
        for (Pair<Guid, Integer> result : scoreResult) {
            selector.record(pair.getFirst().getGuid(), result.getFirst(), result.getSecond());
        }
    }
}
#end_block

#method_before
private void runExternalFunctions(List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> hostCostTable) {
    List<Pair<String, Integer>> scoreNameAndWeight = new ArrayList<>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        scoreNameAndWeight.add(new Pair<>(pair.getFirst().getPolicyUnit().getName(), pair.getSecond()));
    }
    List<Guid> hostIDs = new ArrayList<>();
    for (VDS vds : hostList) {
        hostIDs.add(vds.getId());
    }
    List<Pair<Guid, Integer>> externalScores = ExternalSchedulerFactory.getInstance().runScores(scoreNameAndWeight, hostIDs, vm.getId(), parameters);
    if (externalScores != null) {
        sumScoreResults(hostCostTable, externalScores);
    }
}
#method_after
private void runExternalFunctions(SelectorInstance selector, List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<String, Integer>> scoreNameAndWeight = new ArrayList<>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        scoreNameAndWeight.add(new Pair<>(pair.getFirst().getPolicyUnit().getName(), pair.getSecond()));
    }
    List<Guid> hostIDs = new ArrayList<>();
    for (VDS vds : hostList) {
        hostIDs.add(vds.getId());
    }
    List<Pair<Guid, Integer>> externalScores = ExternalSchedulerFactory.getInstance().runScores(scoreNameAndWeight, hostIDs, vm.getId(), parameters);
    if (externalScores != null) {
        sumScoreResults(selector, externalScores);
    }
}
#end_block

#method_before
private void sumScoreResults(Map<Guid, Integer> hostCostTable, List<Pair<Guid, Integer>> externalScores) {
    if (externalScores == null) {
        // the external scheduler proxy may return null if error happens, in this case the external scores will
        // remain empty
        log.warn("External scheduler proxy returned null score");
    } else {
        for (Pair<Guid, Integer> pair : externalScores) {
            Guid hostId = pair.getFirst();
            if (hostCostTable.get(hostId) == null) {
                hostCostTable.put(hostId, 0);
            }
            hostCostTable.put(hostId, hostCostTable.get(hostId) + pair.getSecond());
        }
    }
}
#method_after
private void sumScoreResults(SelectorInstance selector, List<Pair<Guid, Integer>> externalScores) {
    if (externalScores == null) {
        // the external scheduler proxy may return null if error happens, in this case the external scores will
        // remain empty
        log.warn("External scheduler proxy returned null score");
    } else {
        for (Pair<Guid, Integer> pair : externalScores) {
            selector.record(null, pair.getFirst(), pair.getSecond());
        }
    }
}
#end_block

#method_before
protected VdsDao getVdsDao() {
    return dbFacade.getVdsDao();
}
#method_after
private VdsDao getVdsDao() {
    return dbFacade.getVdsDao();
}
#end_block

#method_before
protected VdsGroupDao getVdsGroupDao() {
    return dbFacade.getVdsGroupDao();
}
#method_after
private VdsGroupDao getVdsGroupDao() {
    return dbFacade.getVdsGroupDao();
}
#end_block

#method_before
protected PolicyUnitDao getPolicyUnitDao() {
    return dbFacade.getPolicyUnitDao();
}
#method_after
private PolicyUnitDao getPolicyUnitDao() {
    return dbFacade.getPolicyUnitDao();
}
#end_block

#method_before
protected ClusterPolicyDao getClusterPolicyDao() {
    return dbFacade.getClusterPolicyDao();
}
#method_after
private ClusterPolicyDao getClusterPolicyDao() {
    return dbFacade.getClusterPolicyDao();
}
#end_block

#method_before
public void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#method_after
private void enableLoadBalancer() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start scheduling to enable vds load balancer");
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsLoadBalancingIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished scheduling to enable vds load balancer");
    }
}
#end_block

#method_before
public void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#method_after
private void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        Injector.get(SchedulerUtilQuartzImpl.class).scheduleAFixedDelayJob(this, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#end_block

#method_before
protected GlusterGeoRepSession getSession(String masterVolumeName, Map<String, Object> innerMap) {
    GlusterGeoRepSession geoRepSession = new GlusterGeoRepSession();
    // sessionKey in the form - the uuid is the gluster server uuid on master
    // <sessionKey>11ae7a03-e793-4270-8fc4-b42def8b3051:ssh://192.168.122.14::slave2:bd52ddf1-9659-4168-8197-c62e9f3e855c</sessionKey>
    String sessionKey = (String) innerMap.get(SESSION_KEY);
    String[] sessSplit = sessionKey.split("([://]+)");
    // Older gluster versions doesn't have slave volume ID in the sessionKey, it is added in Glusterfs 3.7.12
    String slaveNode = sessSplit.length == 5 ? sessSplit[sessSplit.length - 3] : sessSplit[sessSplit.length - 2];
    if (slaveNode.contains("@")) {
        String[] hostComponents = slaveNode.split("@");
        slaveNode = hostComponents[hostComponents.length - 1];
        geoRepSession.setUserName(hostComponents[0]);
    }
    String slaveVolume = (String) innerMap.get(REMOTE_VOL_NAME);
    geoRepSession.setSlaveHostName(slaveNode);
    geoRepSession.setSlaveVolumeName(slaveVolume);
    geoRepSession.setSessionKey(sessionKey);
    geoRepSession.setMasterVolumeName(masterVolumeName);
    return geoRepSession;
}
#method_after
protected GlusterGeoRepSession getSession(String masterVolumeName, Map<String, Object> innerMap) {
    GlusterGeoRepSession geoRepSession = new GlusterGeoRepSession();
    // sessionKey in the form - the uuid is the gluster server uuid on master
    // <sessionKey>11ae7a03-e793-4270-8fc4-b42def8b3051:ssh://192.168.122.14::slave2:bd52ddf1-9659-4168-8197-c62e9f3e855c</sessionKey>
    String sessionKey = (String) innerMap.get(SESSION_KEY);
    String[] sessSplit = sessionKey.split("([://]+)");
    // Older gluster versions doesn't have slave volume ID in the sessionKey, it is added in Glusterfs 3.7.12
    String slaveNode = sessSplit[2];
    if (slaveNode.contains("@")) {
        String[] hostComponents = slaveNode.split("@");
        slaveNode = hostComponents[hostComponents.length - 1];
        geoRepSession.setUserName(hostComponents[0]);
    }
    String slaveVolume = (String) innerMap.get(REMOTE_VOL_NAME);
    geoRepSession.setSlaveHostName(slaveNode);
    geoRepSession.setSlaveVolumeName(slaveVolume);
    geoRepSession.setSessionKey(sessionKey);
    geoRepSession.setMasterVolumeName(masterVolumeName);
    return geoRepSession;
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    clusterModel.setSwitchType(null);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(MigrationBandwidthLimitType.DEFAULT);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangeable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
    clusterModel.initMigrationPolicies(false);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(MigrationBandwidthLimitType.DEFAULT);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrNull(dataCenters, new Linq.IdPredicate<>(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangeable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
    clusterModel.initMigrationPolicies(false);
}
#end_block

#method_before
public void edit() {
    final Cluster cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getSwitchType().setSelectedItem(cluster.getRequiredSwitchTypeForCluster());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.setKsmPolicyForNuma(cluster.isKsmMergeAcrossNumaNodes());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getClusterHostsAndVms().getHosts() == 0);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(cluster.getMigrationBandwidthLimitType() != null ? cluster.getMigrationBandwidthLimitType() : MigrationBandwidthLimitType.DEFAULT);
    clusterModel.getCustomMigrationNetworkBandwidth().setEntity(cluster.getCustomMigrationNetworkBandwidth());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    List<GlusterVolumeEntity> volumes = (List<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getClusterHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getClusterHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    clusterModel.initMigrationPolicies(true);
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final Cluster cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getSwitchType().setSelectedItem(cluster.getRequiredSwitchTypeForCluster());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.setKsmPolicyForNuma(cluster.isKsmMergeAcrossNumaNodes());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getClusterHostsAndVms().getHosts() == 0);
    clusterModel.getMigrationBandwidthLimitType().setItems(Arrays.asList(MigrationBandwidthLimitType.values()));
    clusterModel.getMigrationBandwidthLimitType().setSelectedItem(cluster.getMigrationBandwidthLimitType() != null ? cluster.getMigrationBandwidthLimitType() : MigrationBandwidthLimitType.DEFAULT);
    clusterModel.getCustomMigrationNetworkBandwidth().setEntity(cluster.getCustomMigrationNetworkBandwidth());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    List<GlusterVolumeEntity> volumes = (List<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getClusterHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getClusterHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    clusterModel.initMigrationPolicies(true);
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private Cluster buildCluster(ClusterModel model) {
    Cluster cluster = model.getIsNew() ? new Cluster() : (Cluster) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setRequiredSwitchTypeForCluster(model.getSwitchType().getSelectedItem());
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    if (model.getMigrationPolicies().getSelectedItem() != null) {
        cluster.setMigrationPolicyId(model.getMigrationPolicies().getSelectedItem().getId());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMigrationBandwidthLimitType(model.getMigrationBandwidthLimitType().getSelectedItem());
    cluster.setCustomMigrationNetworkBandwidth(MigrationBandwidthLimitType.CUSTOM.equals(model.getMigrationBandwidthLimitType().getSelectedItem()) ? model.getCustomMigrationNetworkBandwidth().getEntity() : null);
    return cluster;
}
#method_after
private Cluster buildCluster(ClusterModel model) {
    Cluster cluster = model.getIsNew() ? new Cluster() : (Cluster) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(true);
    cluster.setCompatibilityVersion(version);
    cluster.setRequiredSwitchTypeForCluster(model.getSwitchType().getSelectedItem());
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    if (model.getMigrationPolicies().getSelectedItem() != null) {
        cluster.setMigrationPolicyId(model.getMigrationPolicies().getSelectedItem().getId());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMigrationBandwidthLimitType(model.getMigrationBandwidthLimitType().getSelectedItem());
    cluster.setCustomMigrationNetworkBandwidth(MigrationBandwidthLimitType.CUSTOM.equals(model.getMigrationBandwidthLimitType().getSelectedItem()) ? model.getCustomMigrationNetworkBandwidth().getEntity() : null);
    cluster.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    return cluster;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command, Object... parameters) {
    if (command == getEditCommand() && parameters.length > 0 && Boolean.TRUE.equals(parameters[0])) {
        super.executeCommand(command, parameters);
    }
}
#method_after
@Override
public void executeCommand(UICommand command, Object... parameters) {
    if (command == getEditCommand() && parameters.length > 0 && Boolean.TRUE.equals(parameters[0])) {
        super.executeCommand(command, parameters);
    } else if (command == getAddMacPoolCommand()) {
        super.executeCommand(command, parameters);
        addMacPool((ClusterModel) parameters[0]);
    }
}
#end_block

#method_before
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CLUSTER_POLICY_TAB, this.clusterPolicyTab);
    getTabNameMapping().put(TabName.OPTIMIZATION_TAB, this.optimizationTab);
    getTabNameMapping().put(TabName.MIGRATION_TAB, this.migrationTab);
}
#method_after
@Override
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, this.generalTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CLUSTER_POLICY_TAB, this.clusterPolicyTab);
    getTabNameMapping().put(TabName.OPTIMIZATION_TAB, this.optimizationTab);
    getTabNameMapping().put(TabName.MIGRATION_TAB, this.migrationTab);
    getTabNameMapping().put(TabName.MAC_POOL_TAB, macPoolTab);
}
#end_block

#method_before
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<>(new NameRenderer<StoragePool>());
    managementNetworkEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Network>() {

        @Override
        protected String renderNullSafe(Network network) {
            return network.getName();
        }
    });
    cpuEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<ServerCpu>() {

        @Override
        public String renderNullSafe(ServerCpu object) {
            return object.getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Version>() {

        @Override
        public String renderNullSafe(Version object) {
            return object.toString();
        }
    });
    switchTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<SwitchType>());
    architectureEditor = new ListModelListBoxEditor<>(new EnumRenderer<ArchitectureType>() {

        @Override
        public String render(ArchitectureType object) {
            if (object == null || object == ArchitectureType.undefined) {
                // only localize the 'undefined' enum value
                return super.render(object);
            } else {
                // all other (concrete) architectures should be displayed directly
                return object.toString();
            }
        }
    });
    clusterPolicyEditor = new ListModelListBoxEditor<>(new NameRenderer<ClusterPolicy>());
    hostsWithBrokenConnectivityThresholdEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            if (object == null) {
                return "";
            }
            NumberFormatRenderer renderer = new NumberFormatRenderer(NumberFormat.getPercentFormat());
            // Since this is a percentage renderer, you need to divide by 100 to get the right values to show.
            return renderer.render(object.doubleValue() / 100);
        }
    });
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromGlobal()));
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromGlobal()));
    // $NON-NLS-1$ $NON-NLS-2$
    customPropertiesSheetEditor = new KeyValueWidget<>("auto", "auto");
    migrationBandwidthLimitTypeEditor = new BootstrapListBoxListModelEditor<>(new EnumRenderer<MigrationBandwidthLimitType>());
    migrationPolicyEditor = new ListModelListBoxEditor<>(new NameRenderer());
}
#method_after
private void initListBoxEditors() {
    dataCenterEditor = new ListModelListBoxEditor<>(new NameRenderer<StoragePool>());
    managementNetworkEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Network>() {

        @Override
        protected String renderNullSafe(Network network) {
            return network.getName();
        }
    });
    cpuEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<ServerCpu>() {

        @Override
        public String renderNullSafe(ServerCpu object) {
            return object.getCpuName();
        }
    });
    versionEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Version>() {

        @Override
        public String renderNullSafe(Version object) {
            return object.toString();
        }
    });
    switchTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<SwitchType>());
    architectureEditor = new ListModelListBoxEditor<>(new EnumRenderer<ArchitectureType>() {

        @Override
        public String render(ArchitectureType object) {
            if (object == null || object == ArchitectureType.undefined) {
                // only localize the 'undefined' enum value
                return super.render(object);
            } else {
                // all other (concrete) architectures should be displayed directly
                return object.toString();
            }
        }
    });
    clusterPolicyEditor = new ListModelListBoxEditor<>(new NameRenderer<ClusterPolicy>());
    hostsWithBrokenConnectivityThresholdEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            if (object == null) {
                return "";
            }
            NumberFormatRenderer renderer = new NumberFormatRenderer(NumberFormat.getPercentFormat());
            // Since this is a percentage renderer, you need to divide by 100 to get the right values to show.
            return renderer.render(object.doubleValue() / 100);
        }
    });
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromGlobal()));
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromGlobal()));
    // $NON-NLS-1$ $NON-NLS-2$
    customPropertiesSheetEditor = new KeyValueWidget<>("auto", "auto");
    migrationBandwidthLimitTypeEditor = new BootstrapListBoxListModelEditor<>(new EnumRenderer<MigrationBandwidthLimitType>());
    migrationPolicyEditor = new ListModelListBoxEditor<>(new NameRenderer());
    migrationPolicyEditor.hideLabel();
    macPoolListEditor = new ListModelListBoxEditor<>(new NameRenderer<MacPool>());
    macPoolListEditor.setLabel(constants.clusterPopupMacPoolLabel());
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    enableOvirtServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableOvirtServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            migrationTab.setVisible(object.isMigrationTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            cpuThreadsRow.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingRow.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                Version clusterVersion = object.getVersion().getSelectedItem();
                migrationPolicyDetails.setVisible(AsyncDataProvider.getInstance().isMigrationPoliciesSupported(clusterVersion));
            }
        }
    });
    object.getAdditionalClusterFeatures().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List<List<AdditionalFeature>> items = (List<List<AdditionalFeature>>) object.getAdditionalClusterFeatures().getItems();
            // Hide the fields if there is no feature to show
            additionalFeaturesExpander.setVisible(!items.get(0).isEmpty());
            additionalFeaturesExpanderContent.setVisible(!items.get(0).isEmpty());
        }
    });
    object.getMigrationPolicies().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            MigrationPolicy selectedPolicy = object.getMigrationPolicies().getSelectedItem();
            if (selectedPolicy != null) {
                migrationPolicyDetails.setHTML(templates.migrationPolicyDetails(selectedPolicy.getName(), selectedPolicy.getDescription()));
            } else {
                // $NON-NLS-1$
                migrationPolicyDetails.setText("");
            }
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    updateMacPool(object.getMacPoolModel());
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    enableOvirtServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceEditor.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    enableOvirtServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    enableGlusterServiceOptionEditor.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            migrationTab.setVisible(object.isMigrationTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            cpuThreadsRow.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(templates.italicText(object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingRow.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                Version clusterVersion = object.getVersion().getSelectedItem();
                migrationPolicyDetails.setVisible(AsyncDataProvider.getInstance().isMigrationPoliciesSupported(clusterVersion));
            }
        }
    });
    object.getAdditionalClusterFeatures().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List<List<AdditionalFeature>> items = (List<List<AdditionalFeature>>) object.getAdditionalClusterFeatures().getItems();
            // Hide the fields if there is no feature to show
            additionalFeaturesExpander.setVisible(!items.get(0).isEmpty());
            additionalFeaturesExpanderContent.setVisible(!items.get(0).isEmpty());
        }
    });
    object.getMigrationPolicies().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            MigrationPolicy selectedPolicy = object.getMigrationPolicies().getSelectedItem();
            if (selectedPolicy != null) {
                migrationPolicyDetails.setHTML(templates.migrationPolicyDetails(selectedPolicy.getName(), selectedPolicy.getDescription()));
            } else {
                // $NON-NLS-1$
                migrationPolicyDetails.setText("");
            }
        }
    });
}
#end_block

#method_before
private void initSwitchType() {
    boolean version40OrNewer = version40OrNewer();
    ListModel<SwitchType> switchType = getSwitchType();
    switchType.setItems(Arrays.asList(SwitchType.values()));
    switchType.setIsChangeable(version40OrNewer);
    switchType.setSelectedItem(version40OrNewer ? SwitchType.OVS : SwitchType.LEGACY);
}
#method_after
private void initSwitchType() {
    ListModel<SwitchType> switchType = getSwitchType();
    switchType.setItems(Arrays.asList(SwitchType.values()));
    switchType.setIsChangeable(false);
    switchType.setSelectedItem(SwitchType.LEGACY);
}
#end_block

#method_before
private void updateSwitchTypeUponVersionChange() {
    boolean version40OrNewer = version40OrNewer();
    boolean needToChangeValue = !version40OrNewer;
    ListModel<SwitchType> switchType = getSwitchType();
    switchType.setIsChangeable(version40OrNewer);
    if (needToChangeValue) {
        switchType.setSelectedItem(SwitchType.LEGACY);
    }
}
#method_after
private void updateSwitchTypeUponVersionChange(Version version) {
    ListModel<SwitchType> switchType = getSwitchType();
    boolean ovsSupported = isOvsSupported(version);
    switchType.setIsChangeable(ovsSupported);
    if (!ovsSupported && switchType.getSelectedItem().equals(SwitchType.OVS)) {
        switchType.setSelectedItem(SwitchType.LEGACY);
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        } else if (sender == getArchitecture()) {
            architectureSelectedItemChanged(args);
        } else if (sender == getMigrationPolicies()) {
            migrationPoliciesChanged();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangeable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.itemsChangedEventDefinition)) {
        handleItemsChangedEventDefinition(sender);
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        handleSelectedItemChangedEventDefinition(sender, args);
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        handleEntityChangedEventDefinition((EntityModel) sender);
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getCompatibilityVersion();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    getVersionSupportsCpuThreads().setEntity(true);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangeable(true);
    setRngSourcesCheckboxes(version);
    updateSwitchTypeUponVersionChange();
    updateFencingPolicyContent(version);
    updateKSMPolicy();
    updateMigrateOnError();
    getMigrationPolicies().updateChangeability(ConfigurationValues.MigrationPoliciesSupported, version);
    refreshAdditionalClusterFeaturesList();
    if (getEnableGlusterService().getEntity()) {
        initTunedProfiles();
    }
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getCompatibilityVersion();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    getVersionSupportsCpuThreads().setEntity(true);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangeable(true);
    setRngSourcesCheckboxes(version);
    updateSwitchTypeUponVersionChange(version);
    updateFencingPolicyContent(version);
    updateKSMPolicy();
    updateMigrateOnError();
    getMigrationPolicies().updateChangeability(ConfigurationValues.MigrationPoliciesSupported, version);
    refreshAdditionalClusterFeaturesList();
    if (getEnableGlusterService().getEntity()) {
        initTunedProfiles();
    }
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new ClusterVersionChangeValidation(hasActiveVm, getEntity().getCompatibilityVersion()) });
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null) {
        if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
            getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
        } else {
            getCustomMigrationNetworkBandwidth().setIsValid(true);
        }
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    validateName();
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        validateCPU();
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    setValidTab(TabName.CLUSTER_POLICY_TAB, getCustomPropertySheet().getIsValid());
    final IValidation[] versionValidations = getIsNew() ? new IValidation[] { new NotEmptyValidation() } : new IValidation[] { new NotEmptyValidation(), new ClusterVersionChangeValidation(hasActiveVm, getEntity().getCompatibilityVersion()) };
    getVersion().validateSelectedItem(versionValidations);
    getManagementNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validateRngRequiredSource();
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setValidTab(TabName.CONSOLE_TAB, getSpiceProxy().getIsValid());
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getMacPoolModel().validate();
    boolean generalTabValid = getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getManagementNetwork().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getRngRandomSourceRequired().getIsValid() && getRngHwrngSourceRequired().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && isFingerprintVerified()) : true);
    setValidTab(TabName.GENERAL_TAB, generalTabValid);
    if (getVersion().getSelectedItem() != null) {
        if (AsyncDataProvider.getInstance().isMigrationPoliciesSupported(getVersion().getSelectedItem()) && MigrationBandwidthLimitType.CUSTOM.equals(getMigrationBandwidthLimitType().getSelectedItem())) {
            getCustomMigrationNetworkBandwidth().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
        } else {
            getCustomMigrationNetworkBandwidth().setIsValid(true);
        }
    }
    final boolean migrationTabValid = getMigrationBandwidthLimitType().getIsValid() && getCustomMigrationNetworkBandwidth().getIsValid();
    setValidTab(TabName.MIGRATION_TAB, migrationTabValid);
    boolean macPoolTabValid = getMacPoolModel().getIsValid();
    setValidTab(TabName.MAC_POOL_TAB, macPoolTabValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return generalTabValid && macPoolTabValid && getCustomPropertySheet().getIsValid() && getSpiceProxy().getIsValid() && migrationTabValid;
}
#end_block

#method_before
protected List<VDS> getUnderUtilizedCPUHosts(Collection<VDS> relevantHosts, final int lowUtilization, final int minVmCount, final int cpuOverCommitDurationMinutes) {
    List<VDS> underUtilizedHosts = LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) < lowUtilization && p.getVmCount() >= minVmCount && (p.getCpuOverCommitTimestamp() == null || (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) < TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes));
        }
    });
    if (underUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        VDSGroup cluster = getVdsGroupDao().get(underUtilizedHosts.get(0).getVdsGroupId());
        Collections.sort(underUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores()));
    }
    return underUtilizedHosts;
}
#method_after
protected List<VDS> getUnderUtilizedCPUHosts(Collection<VDS> relevantHosts, final int lowUtilization, final int minVmCount, final int cpuOverCommitDurationMinutes) {
    List<VDS> underUtilizedHosts = LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) < lowUtilization && p.getVmCount() >= minVmCount && (p.getCpuOverCommitTimestamp() == null || (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes));
        }
    });
    if (underUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        VDSGroup cluster = getVdsGroupDao().get(underUtilizedHosts.get(0).getVdsGroupId());
        Collections.sort(underUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores()));
    }
    return underUtilizedHosts;
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> list = new ArrayList<>();
    final int highUtilization = tryParseWithDefault(parameters.get(HIGH_UTILIZATION), getHighUtilizationDefaultValue());
    final int cpuOverCommitDurationMinutes = tryParseWithDefault(parameters.get("CpuOverCommitDurationMinutes"), Config.<Integer>getValue(ConfigValues.CpuOverCommitDurationMinutes));
    for (VDS vds : hosts) {
        VDSGroup cluster = getVdsGroupDao().get(vds.getVdsGroupId());
        // Check the core count
        Integer cores = SlaValidator.getEffectiveCpuCores(vds, cluster != null && cluster.getCountThreadsAsCores());
        if (cores != null && vm.getNumOfCpus() > cores) {
            messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_CORES.toString());
            log.debug("Host '{}' has less cores ({}) than vm cores ({})", vds.getName(), cores, vm.getNumOfCpus());
            continue;
        }
        // Check the CPU load. A Host is considered overloaded when all cores are loaded
        // more than the defined percentage
        int highUtilizationTotal = getHighUtilizationForAllCores(highUtilization, cores);
        if ((vds.getUsageCpuPercent() + CpuAndMemoryBalancingPolicyUnit.calcSpmCpuConsumption(vds)) >= highUtilizationTotal && vds.getCpuOverCommitTimestamp() != null && (getTime().getTime() - vds.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes) && vds.getVmCount() > 0) {
            continue;
        }
        list.add(vds);
    }
    return list;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> list = new ArrayList<>();
    for (VDS vds : hosts) {
        VDSGroup cluster = getVdsGroupDao().get(vds.getVdsGroupId());
        // Check the core count
        Integer cores = SlaValidator.getEffectiveCpuCores(vds, cluster != null && cluster.getCountThreadsAsCores());
        if (cores != null && vm.getNumOfCpus() > cores) {
            messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_CORES.toString());
            log.debug("Host '{}' has less cores ({}) than vm cores ({})", vds.getName(), cores, vm.getNumOfCpus());
            continue;
        }
        list.add(vds);
    }
    return list;
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    Set<VDS> candidateHosts = new HashSet<>();
    Set<VDS> spares = new HashSet<>();
    final int requiredSpares = tryParseWithDefault(parameters.get(SPARES_COUNT), 0);
    // There are no hosts, skip this unit
    if (hosts.isEmpty()) {
        return hosts;
    }
    // No spares requested, skip this unit
    if (requiredSpares == 0) {
        return hosts;
    }
    // Get the instance of hosted engine VM so we can get the amount of memory that is needed
    VM hostedEngine = vmDao().getHostedEngine();
    // Not a hosted engine deployment, ignore this unit
    if (hostedEngine == null) {
        return hosts;
    }
    // The hosted engine VM is not part of the currently scheduled cluster
    if (!hostedEngine.getVdsGroupId().equals(vm.getVdsGroupId())) {
        return hosts;
    }
    // Scheduling the hosted engine VM, do nothing
    if (hostedEngine.getId().equals(vm.getId())) {
        return hosts;
    }
    // Count the number of hosted engine spares
    for (VDS h : hosts) {
        // Not a HE host
        if (!h.getHighlyAvailableIsActive()) {
            candidateHosts.add(h);
        // HE host that can't run the engine at this moment because of score
        } else if (h.getHighlyAvailableScore() == 0) {
            candidateHosts.add(h);
        // HE host in local maintenance can't be used as a spare
        } else if (h.getHighlyAvailableLocalMaintenance()) {
            candidateHosts.add(h);
        // HE host where the engine is currently running
        } else if (h.getId().equals(hostedEngine.getRunOnVds())) {
            candidateHosts.add(h);
        // HE host that has enough memory to run both the hosted engine VM
        // and the scheduled VM at the same time -- count as candidate and spare!
        } else if (SlaValidator.getInstance().getHostAvailableMemoryLimit(h) > vm.getMemSizeMb() + 2 * h.getGuestOverhead() + hostedEngine.getMemSizeMb()) {
            spares.add(h);
            candidateHosts.add(h);
        // HE host that has enough memory to run the hosted engine VM -- count as spare only!
        } else if (SlaValidator.getInstance().getHostAvailableMemoryLimit(h) > hostedEngine.getMemSizeMb() + h.getGuestOverhead()) {
            spares.add(h);
        } else {
            candidateHosts.add(h);
        }
    }
    if (spares.size() < requiredSpares) {
        for (VDS h : spares) {
            messages.addMessage(h.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_HE_SPARES.toString());
        }
    } else {
        candidateHosts.addAll(spares);
    }
    return new ArrayList<>(candidateHosts);
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    Set<VDS> candidateHosts = new HashSet<>();
    Set<VDS> spares = new HashSet<>();
    final int requiredSpares = NumberUtils.toInt(parameters.get(SPARES_COUNT), 0);
    // There are no hosts, skip this unit
    if (hosts.isEmpty()) {
        return hosts;
    }
    // No spares requested, skip this unit
    if (requiredSpares == 0) {
        return hosts;
    }
    // Get the instance of hosted engine VM so we can get the amount of memory that is needed
    VM hostedEngine = vmDao().getHostedEngineVm();
    // Not a hosted engine deployment, ignore this unit
    if (hostedEngine == null) {
        return hosts;
    }
    // The hosted engine VM is not part of the currently scheduled cluster
    if (!hostedEngine.getVdsGroupId().equals(vm.getVdsGroupId())) {
        return hosts;
    }
    // Scheduling the hosted engine VM, do nothing
    if (hostedEngine.getId().equals(vm.getId())) {
        return hosts;
    }
    // Count the number of hosted engine spares
    for (VDS h : hosts) {
        // Not a HE host
        if (!h.getHighlyAvailableIsActive()) {
            candidateHosts.add(h);
        // HE host that can't run the engine at this moment because of score
        } else if (h.getHighlyAvailableScore() == 0) {
            candidateHosts.add(h);
        // HE host in local maintenance can't be used as a spare
        } else if (h.getHighlyAvailableLocalMaintenance()) {
            candidateHosts.add(h);
        // HE host where the engine is currently running
        } else if (h.getId().equals(hostedEngine.getRunOnVds())) {
            candidateHosts.add(h);
        // HE host that has enough memory to run both the hosted engine VM
        // and the scheduled VM at the same time -- count as candidate and spare!
        } else if (SlaValidator.getInstance().getHostAvailableMemoryLimit(h) > vm.getMemSizeMb() + 2 * h.getGuestOverhead() + hostedEngine.getMemSizeMb()) {
            spares.add(h);
            candidateHosts.add(h);
        // HE host that has enough memory to run the hosted engine VM -- count as spare only!
        } else if (SlaValidator.getInstance().getHostAvailableMemoryLimit(h) > hostedEngine.getMemSizeMb() + h.getGuestOverhead()) {
            spares.add(h);
        } else {
            candidateHosts.add(h);
        }
    }
    if (spares.size() < requiredSpares) {
        for (VDS h : spares) {
            messages.addMessage(h.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_HE_SPARES.toString());
        }
    } else {
        candidateHosts.addAll(spares);
    }
    return new ArrayList<>(candidateHosts);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    clusterId = Guid.newGuid();
    pendingResourceManager = new PendingResourceManager();
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setVdsGroupId(clusterId);
    vm.setVmMemSizeMb(1024);
    hosts = new ArrayList<>();
    hosts.add(prepareHost("A", 8192, true, 2400, false));
    hosts.add(prepareHost("B", 8192, true, 2400, false));
    hosts.add(prepareHost("C", 8192, true, 2400, false));
    hosts.add(prepareHost("D", 8192, true, 2400, false));
    hosts.add(prepareHost("E", 8192, true, 2400, false));
    hostedEngine = new VM();
    hostedEngine.setOrigin(OriginType.HOSTED_ENGINE);
    hostedEngine.setVmMemSizeMb(4096);
    hostedEngine.setId(Guid.newGuid());
    hostedEngine.setVdsGroupId(clusterId);
    hostedEngine.setRunOnVds(hosts.get(0).getId());
    uut = new HostedEngineMemoryReservationFilterPolicyUnit(null, pendingResourceManager);
    parameters = new HashMap<>();
    parameters.put(HostedEngineMemoryReservationFilterPolicyUnit.SPARES_COUNT, "0");
    messages = new PerHostMessages();
    when(DbFacade.getInstance().getVmDao()).thenReturn(vmDao);
    doReturn(hostedEngine).when(vmDao).getHostedEngine();
}
#method_after
@Before
public void setUp() throws Exception {
    clusterId = Guid.newGuid();
    pendingResourceManager = new PendingResourceManager();
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setVdsGroupId(clusterId);
    vm.setVmMemSizeMb(1024);
    hosts = new ArrayList<>();
    hosts.add(prepareHost("A", 8192, true, 2400, false));
    hosts.add(prepareHost("B", 8192, true, 2400, false));
    hosts.add(prepareHost("C", 8192, true, 2400, false));
    hosts.add(prepareHost("D", 8192, true, 2400, false));
    hosts.add(prepareHost("E", 8192, true, 2400, false));
    hostedEngine = new VM();
    hostedEngine.setOrigin(OriginType.HOSTED_ENGINE);
    hostedEngine.setVmMemSizeMb(4096);
    hostedEngine.setId(Guid.newGuid());
    hostedEngine.setVdsGroupId(clusterId);
    hostedEngine.setRunOnVds(hosts.get(0).getId());
    uut = new HostedEngineMemoryReservationFilterPolicyUnit(null, pendingResourceManager);
    parameters = new HashMap<>();
    parameters.put(HostedEngineMemoryReservationFilterPolicyUnit.SPARES_COUNT, "0");
    messages = new PerHostMessages();
    when(DbFacade.getInstance().getVmDao()).thenReturn(vmDao);
    doReturn(hostedEngine).when(vmDao).getHostedEngineVm();
}
#end_block

#method_before
@Test
public void testWithoutEnoughSparesFullMemory() throws Exception {
    parameters.put(HostedEngineMemoryReservationFilterPolicyUnit.SPARES_COUNT, "5");
    hostedEngine.setVmMemSizeMb(7000);
    List<VDS> result = uut.filter(hosts, vm, parameters, messages);
    assertEquals(1, result.size());
}
#method_after
@Test
public void testWithoutEnoughSparesFullMemory() throws Exception {
    parameters.put(HostedEngineMemoryReservationFilterPolicyUnit.SPARES_COUNT, "5");
    hostedEngine.setVmMemSizeMb(7000);
    List<VDS> result = uut.filter(hosts, vm, parameters, messages);
    assertEquals(1, result.size());
    assertEquals("A", result.get(0).getName());
}
#end_block

#method_before
@Test
public void testNoHostedEngine() throws Exception {
    parameters.put(HostedEngineMemoryReservationFilterPolicyUnit.SPARES_COUNT, "5");
    hostedEngine.setVmMemSizeMb(7000);
    hostedEngine.setOrigin(OriginType.OVIRT);
    doReturn(null).when(vmDao).getHostedEngine();
    List<VDS> result = uut.filter(hosts, vm, parameters, messages);
    assertEquals(5, result.size());
}
#method_after
@Test
public void testNoHostedEngine() throws Exception {
    parameters.put(HostedEngineMemoryReservationFilterPolicyUnit.SPARES_COUNT, "5");
    hostedEngine.setVmMemSizeMb(7000);
    hostedEngine.setOrigin(OriginType.OVIRT);
    doReturn(null).when(vmDao).getHostedEngineVm();
    List<VDS> result = uut.filter(hosts, vm, parameters, messages);
    assertEquals(5, result.size());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    NetworkProviderProxy proxy = ProviderProxyFactory.getInstance().create(getProvider());
    getNetwork().getProvidedBy().setExternalId(proxy.add(getNetwork()));
    getNetwork().setVlanId(null);
    getNetwork().setLabel(null);
    TransactionSupport.executeInNewTransaction(() -> {
        addNetwork();
        return null;
    });
}
#method_after
@Override
protected void executeCommand() {
    NetworkProviderProxy proxy = ProviderProxyFactory.getInstance().create(getProvider());
    getNetwork().getProvidedBy().setExternalId(proxy.add(getNetwork()));
    getNetwork().setVlanId(null);
    getNetwork().setLabel(null);
    TransactionSupport.executeInNewTransaction(() -> {
        super.executeCommand();
        getReturnValue().setActionReturnValue(getNetwork());
        return null;
    });
}
#end_block

#method_before
@Before
public void setUp() {
    injectorRule.bind(ManagementNetworkUtil.class, mockManagementNetworkUtil);
    managementNetwork.setId(MANAGEMENT_NETWORK_ID);
    Mockito.when(mockManagementNetworkUtil.getManagementNetwork(CLUSTER_ID)).thenReturn(managementNetwork);
    nic.setNetworkName(NETWORK_NAME1);
    nic.setName(NIC_NAME);
    host = new VDS();
    host.setClusterId(CLUSTER_ID);
    host.setClusterCompatibilityVersion(Version.v4_0);
    host.getInterfaces().add(nic);
    underTest = new NetworkConfigurator(host, COMMAND_CONTEXT);
}
#method_after
@Before
public void setUp() {
    injectorRule.bind(ManagementNetworkUtil.class, mockManagementNetworkUtil);
    managementNetwork.setId(MANAGEMENT_NETWORK_ID);
    when(mockManagementNetworkUtil.getManagementNetwork(CLUSTER_ID)).thenReturn(managementNetwork);
    nic.setNetworkName(NETWORK_NAME1);
    nic.setName(NIC_NAME);
    host = new VDS();
    host.setClusterId(CLUSTER_ID);
    host.setClusterCompatibilityVersion(Version.v4_0);
    host.getInterfaces().add(nic);
    underTest = new NetworkConfigurator(host, COMMAND_CONTEXT);
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setClusterName(rs.getString("cluster_name"));
    entity.setClusterDescription(rs.getString("cluster_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setExternalStatus(ExternalStatus.forValue(rs.getInt("external_status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setMemFree(rs.getLong("mem_free"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setClusterCpuName(rs.getString("cluster_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setClusterCompatibilityVersion(new Version(rs.getString("cluster_compatibility_version")));
    entity.setClusterSupportsVirtService(rs.getBoolean("cluster_virt_service"));
    entity.setClusterSupportsGlusterService(rs.getBoolean("cluster_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setLibrbdVersion(new RpmVersion(rs.getString("librbd1_version")));
    entity.setGlusterfsCliVersion(new RpmVersion(rs.getString("glusterfs_cli_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    entity.getStaticData().setOpenstackNetworkProviderId(getGuid(rs, "openstack_network_provider_id"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FenceAgent agent = new FenceAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setEncryptOptions(rs.getBoolean("agent_encrypt_options"));
        if (agent.getEncryptOptions()) {
            agent.setOptions(DbFacadeUtils.decryptPassword(rs.getString("agent_options")));
        } else {
            agent.setOptions(rs.getString("agent_options"));
        }
        agent.setIp(rs.getString("agent_ip"));
        entity.getFenceAgents().add(agent);
    }
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    entity.setHostDevicePassthroughEnabled(rs.getBoolean("is_hostdev_enabled"));
    entity.setHostedEngineHost(rs.getBoolean("is_hosted_engine_host"));
    VdsStaticDaoImpl.KernelCmdlineColumn.fromJson(rs.getString("kernel_cmdline")).toVds(entity);
    entity.setLastStoredKernelCmdline(rs.getString("last_stored_kernel_cmdline"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setClusterName(rs.getString("cluster_name"));
    entity.setClusterDescription(rs.getString("cluster_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setExternalStatus(ExternalStatus.forValue(rs.getInt("external_status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setOnlineCpus(rs.getString("online_cpus"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setIncomingMigrations(rs.getInt("incoming_migrations"));
    entity.setOutgoingMigrations(rs.getInt("outgoing_migrations"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setMemFree(rs.getLong("mem_free"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setClusterCpuName(rs.getString("cluster_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setClusterCompatibilityVersion(new Version(rs.getString("cluster_compatibility_version")));
    entity.setClusterSupportsVirtService(rs.getBoolean("cluster_virt_service"));
    entity.setClusterSupportsGlusterService(rs.getBoolean("cluster_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setLibrbdVersion(new RpmVersion(rs.getString("librbd1_version")));
    entity.setGlusterfsCliVersion(new RpmVersion(rs.getString("glusterfs_cli_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setBalloonEnabled(rs.getBoolean("enable_balloon"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setMaintenanceReason(rs.getString("maintenance_reason"));
    entity.getStaticData().setOpenstackNetworkProviderId(getGuid(rs, "openstack_network_provider_id"));
    Guid agentGuid = getGuid(rs, "agent_id");
    if (agentGuid != null) {
        FenceAgent agent = new FenceAgent();
        agent.setId(agentGuid);
        agent.setHostId(getGuid(rs, "vds_id"));
        agent.setOrder(rs.getInt("agent_order"));
        agent.setType(rs.getString("agent_type"));
        agent.setUser(rs.getString("agent_user"));
        agent.setPassword(DbFacadeUtils.decryptPassword(rs.getString("agent_password")));
        int port = rs.getInt("agent_port");
        agent.setPort(port == 0 ? null : port);
        agent.setEncryptOptions(rs.getBoolean("agent_encrypt_options"));
        if (agent.getEncryptOptions()) {
            agent.setOptions(DbFacadeUtils.decryptPassword(rs.getString("agent_options")));
        } else {
            agent.setOptions(rs.getString("agent_options"));
        }
        agent.setIp(rs.getString("agent_ip"));
        entity.getFenceAgents().add(agent);
    }
    entity.setUpdateAvailable(rs.getBoolean("is_update_available"));
    entity.setHostDevicePassthroughEnabled(rs.getBoolean("is_hostdev_enabled"));
    entity.setHostedEngineHost(rs.getBoolean("is_hosted_engine_host"));
    VdsStaticDaoImpl.KernelCmdlineColumn.fromJson(rs.getString("kernel_cmdline")).toVds(entity);
    entity.setLastStoredKernelCmdline(rs.getString("last_stored_kernel_cmdline"));
    entity.setKernelArgs(rs.getString("kernel_args"));
    entity.setFencingEnabled(rs.getBoolean("fencing_enabled"));
    return entity;
}
#end_block

#method_before
private boolean isSnapshotEligibleToBeDeleted(Snapshot candidateSnapshotToRemove) {
    return (candidateSnapshotToRemove != null) && (candidateSnapshotToRemove.getType() != SnapshotType.REGULAR || candidateSnapshotToRemove.getCreationDate().getTime() > removedSnapshot.getCreationDate().getTime());
}
#method_after
private boolean isSnapshotEligibleToBeDeleted(Snapshot candidateSnapshotToRemove) {
    return candidateSnapshotToRemove != null && (candidateSnapshotToRemove.getType() != SnapshotType.REGULAR || candidateSnapshotToRemove.getCreationDate().getTime() > removedSnapshot.getCreationDate().getTime());
}
#end_block

#method_before
private void handleBackwardLiveMerge(DiskImage topImage, DiskImage baseImage, DiskImage imageFromVdsm) {
    // For backwards merge, the prior base image now has the data associated with the newer
    // snapshot we want to keep.  Re-associate this older image with the newer snapshot.
    // The base snapshot is deleted if everything went well.  In case it's not deleted, we
    // hijack it to preserve a link to the broken image.  This makes the image discoverable
    // so that we can retry the deletion later, yet doesn't corrupt the VM image chain.
    List<DiskImage> children = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(topImage.getImageId());
    if (!children.isEmpty()) {
        DiskImage childImage = children.get(0);
        childImage.setParentId(baseImage.getImageId());
        getImageDao().update(childImage.getImage());
    }
    Image oldTopImage = topImage.getImage();
    topImage.setImage(baseImage.getImage());
    baseImage.setImage(oldTopImage);
    Guid oldTopSnapshotId = topImage.getImage().getSnapshotId();
    topImage.getImage().setSnapshotId(baseImage.getImage().getSnapshotId());
    baseImage.getImage().setSnapshotId(oldTopSnapshotId);
    boolean oldTopIsActive = topImage.getImage().isActive();
    topImage.getImage().setActive(baseImage.getImage().isActive());
    VolumeClassification baseImageVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(baseImage.getImage().isActive());
    topImage.getImage().setVolumeClassification(baseImageVolumeClassification);
    baseImage.getImage().setActive(oldTopIsActive);
    VolumeClassification oldTopVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(oldTopIsActive);
    topImage.getImage().setVolumeClassification(oldTopVolumeClassification);
    topImage.setActualSizeInBytes(imageFromVdsm.getActualSizeInBytes());
    topImage.setImageStatus(ImageStatus.OK);
    getBaseDiskDao().update(topImage);
    getImageDao().update(topImage.getImage());
    updateDiskImageDynamic(imageFromVdsm, topImage);
    getBaseDiskDao().update(baseImage);
    getImageDao().update(baseImage.getImage());
    updateVmConfigurationForImageChange(topImage.getImage().getSnapshotId(), baseImage.getImageId(), topImage);
    updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), topImage.getImageId());
}
#method_after
private void handleBackwardLiveMerge(DiskImage topImage, DiskImage baseImage, DiskImage imageFromVdsm) {
    // For backwards merge, the prior base image now has the data associated with the newer
    // snapshot we want to keep.  Re-associate this older image with the newer snapshot.
    // The base snapshot is deleted if everything went well.  In case it's not deleted, we
    // hijack it to preserve a link to the broken image.  This makes the image discoverable
    // so that we can retry the deletion later, yet doesn't corrupt the VM image chain.
    List<DiskImage> children = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(topImage.getImageId());
    if (!children.isEmpty()) {
        DiskImage childImage = children.get(0);
        childImage.setParentId(baseImage.getImageId());
        getImageDao().update(childImage.getImage());
    }
    Image oldTopImage = topImage.getImage();
    topImage.setImage(baseImage.getImage());
    baseImage.setImage(oldTopImage);
    Guid oldTopSnapshotId = topImage.getImage().getSnapshotId();
    topImage.getImage().setSnapshotId(baseImage.getImage().getSnapshotId());
    baseImage.getImage().setSnapshotId(oldTopSnapshotId);
    boolean oldTopIsActive = topImage.getImage().isActive();
    topImage.getImage().setActive(baseImage.getImage().isActive());
    VolumeClassification baseImageVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(baseImage.getImage().isActive());
    topImage.getImage().setVolumeClassification(baseImageVolumeClassification);
    baseImage.getImage().setActive(oldTopIsActive);
    VolumeClassification oldTopVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(oldTopIsActive);
    topImage.getImage().setVolumeClassification(oldTopVolumeClassification);
    topImage.setSize(baseImage.getSize());
    topImage.setActualSizeInBytes(imageFromVdsm.getActualSizeInBytes());
    topImage.setImageStatus(ImageStatus.OK);
    getBaseDiskDao().update(topImage);
    getImageDao().update(topImage.getImage());
    updateDiskImageDynamic(imageFromVdsm, topImage);
    getBaseDiskDao().update(baseImage);
    getImageDao().update(baseImage.getImage());
    updateVmConfigurationForImageChange(topImage.getImage().getSnapshotId(), baseImage.getImageId(), topImage);
    updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), topImage.getImageId());
}
#end_block

#method_before
private NetworkAttachment createAttachmentWhenAttachingTo(VdsNetworkInterface targetNic) {
    NetworkAttachment networkAttachment = new NetworkAttachment(targetNic, networkModel.getNetwork(), NetworkCommonUtils.createDefaultIpConfiguration());
    NetworkParameters netParams = networkModel.getSetupModel().getNetworkToLastDetachParams().get(networkModel.getName());
    if (netParams != null) {
        applyOnAttachmentParamsFrom(netParams, networkAttachment);
    } else {
        VdsNetworkInterface nicToTakeParamsFrom = null;
        if (networkModel.hasVlan()) {
            nicToTakeParamsFrom = getPotentialVlanDevice(targetNic);
        } else {
            nicToTakeParamsFrom = targetNic;
        }
        if (nicToTakeParamsFrom != null && nicToTakeParamsFrom.getId() != null) {
            applyOnAttachmentParamsFrom(new InterfacePropertiesAccessor.FromNic(nicToTakeParamsFrom), networkAttachment);
        }
        fixBootProtocolOfMgmtNetworkIfNeeded(networkAttachment);
    }
    return networkAttachment;
}
#method_after
private NetworkAttachment createAttachmentWhenAttachingTo(VdsNetworkInterface targetNic) {
    NetworkAttachment networkAttachment = new NetworkAttachment(targetNic, networkModel.getNetwork(), NetworkCommonUtils.createDefaultIpConfiguration());
    NetworkParameters netParams = networkModel.getSetupModel().getNetworkToLastDetachParams().get(networkModel.getName());
    if (netParams != null) {
        applyOnAttachmentParamsFrom(netParams, networkAttachment);
    } else {
        VdsNetworkInterface nicToTakeParamsFrom = null;
        if (networkModel.hasVlan()) {
            nicToTakeParamsFrom = getPotentialVlanDevice(targetNic);
        } else {
            nicToTakeParamsFrom = targetNic;
        }
        boolean newlyCreatedBond = nicToTakeParamsFrom != null && nicToTakeParamsFrom.getId() == null;
        if (nicToTakeParamsFrom != null && !newlyCreatedBond) {
            applyOnAttachmentParamsFrom(new InterfacePropertiesAccessor.FromNic(nicToTakeParamsFrom), networkAttachment);
        }
        fixBootProtocolOfMgmtNetworkIfNeeded(networkAttachment);
    }
    return networkAttachment;
}
#end_block

#method_before
public static void updateVdsDomainsData(VDS vds, Guid storagePoolId, ArrayList<VDSDomainsData> vdsDomainData) {
    // from it.
    if (vds.getStatus() == reportingVdsStatus && vds.getVdsGroupSupportsVirtService()) {
        IrsProxyData proxy = _irsProxyData.get(storagePoolId);
        if (proxy != null) {
            proxy.updateVdsDomainsData(vds.getId(), vds.getName(), vdsDomainData);
        }
    }
}
#method_after
public static void updateVdsDomainsData(VDS vds, Guid storagePoolId, ArrayList<VDSDomainsData> vdsDomainData) {
    IrsProxyData proxy = _irsProxyData.get(storagePoolId);
    if (proxy != null) {
        proxy.updateVdsDomainsData(vds, vdsDomainData);
    }
}
#end_block

#method_before
public static List<Guid> fetchDomainsReportedAsProblematic(List<VDSDomainsData> vdsDomainsData, StoragePool storagePool) {
    IrsProxyData proxy = _irsProxyData.get(storagePool.getId());
    if (proxy != null) {
        return proxy.obtainDomainsReportedAsProblematic(vdsDomainsData, storagePool);
    }
    return Collections.emptyList();
}
#method_after
public static List<Guid> fetchDomainsReportedAsProblematic(List<VDSDomainsData> vdsDomainsData, StoragePool storagePool) {
    IrsProxyData proxy = _irsProxyData.get(storagePool.getId());
    if (proxy != null) {
        return proxy.obtainDomainsReportedAsProblematic(vdsDomainsData);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected void executeVDSCommand() {
    boolean isStartReconstruct = false;
    Lock lock = getCurrentIrsProxyData().getLock();
    try {
        lock.lock();
        try {
            if (getIrsProxy() != null) {
                executeIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(EngineError.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.error("IrsBroker::Failed::{} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.error("IrsBroker::Failed::{}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.error("IrsBroker::Failed::{}: {}", getCommandName(), ex.getMessage());
            log.debug("Exception", ex);
            if ((ex.getVdsError() == null || ex.getVdsError().getCode() != EngineError.StoragePoolWrongMaster) && getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException | IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && EngineError.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    } finally {
        lock.unlock();
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#method_after
@Override
protected void executeVDSCommand() {
    AtomicBoolean isStartReconstruct = new AtomicBoolean(false);
    getCurrentIrsProxyData().runInControlledConcurrency(() -> {
        try {
            if (getIrsProxy() != null) {
                executeIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(EngineError.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.error("IrsBroker::Failed::{} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.error("IrsBroker::Failed::{}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.error("IrsBroker::Failed::{}: {}", getCommandName(), ex.getMessage());
            log.debug("Exception", ex);
            if ((ex.getVdsError() == null || ex.getVdsError().getCode() != EngineError.StoragePoolWrongMaster) && getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct.set(true);
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException | IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && EngineError.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    });
    if (isStartReconstruct.get()) {
        startReconstruct();
    }
}
#end_block

#method_before
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        eventQueue.submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT, "IrsBrokerCommand.startReconstruct()"), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true, getVDSReturnValue().getVdsError() != null && getVDSReturnValue().getVdsError().getCode() == EngineError.StoragePoolWrongMaster);
            }
        });
    } else {
        log.error("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool '{}'", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        eventQueue.submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT, "IrsBrokerCommand.startReconstruct()"), () -> eventListener.masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true, getVDSReturnValue().getVdsError() != null && getVDSReturnValue().getVdsError().getCode() == EngineError.StoragePoolWrongMaster));
    } else {
        log.error("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool '{}'", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
public void setCurrentVdsId(Guid value) {
    currentVdsId = (Guid.Empty.equals(value)) ? null : value;
}
#method_after
public void setCurrentVdsId(Guid value) {
    currentVdsId = Guid.Empty.equals(value) ? null : value;
}
#end_block

#method_before
private static Set<Guid> getVdsConnectedToPool(Guid storagePoolId) {
    Set<Guid> vdsNotInMaintenance = new HashSet<>();
    // every change to it should be inspected carefully.
    for (VDS vds : DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(storagePoolId, null)) {
        if (vds.getStatus() == VDSStatus.Up || vds.getStatus() == VDSStatus.NonResponsive || vds.getStatus() == VDSStatus.PreparingForMaintenance || vds.getStatus() == VDSStatus.NonOperational) {
            vdsNotInMaintenance.add(vds.getId());
        }
    }
    return vdsNotInMaintenance;
}
#method_after
private static Collection<Guid> getVdsConnectedToPool(Guid storagePoolId) {
    // every change to it should be inspected carefully.
    return DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatuses(storagePoolId, vdsConnectedToPoolStatuses).stream().map(VDS::getId).collect(Collectors.toSet());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = currentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
    domainsInMaintenanceCheck(domainsInDb);
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = currentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
    domainsInMaintenanceCheck(domainsInDb, storagePool);
}
#end_block

#method_before
private void domainsInMaintenanceCheck(List<StorageDomain> storageDomains) {
    for (StorageDomain domainInDb : storageDomains) {
        if (domainInDb.getStatus() == StorageDomainStatus.PreparingForMaintenance) {
            queueDomainMaintenanceCheck(domainInDb);
        }
    }
}
#method_after
private void domainsInMaintenanceCheck(List<StorageDomain> storageDomains, StoragePool pool) {
    for (StorageDomain domainInDb : storageDomains) {
        if (domainInDb.getStatus() == StorageDomainStatus.PreparingForMaintenance) {
            queueDomainMaintenanceCheck(domainInDb, pool);
        }
    }
}
#end_block

#method_before
public void queueDomainMaintenanceCheck(final StorageDomain domain) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domain.getId(), null, EventType.DOMAINFAILOVER, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            Set<Guid> vdsConnectedToPool = getVdsConnectedToPool(_storagePoolId);
            Set<Guid> vdsDomInMaintenance = _domainsInMaintenance.get(domain.getId());
            if (vdsConnectedToPool.isEmpty() || (vdsDomInMaintenance != null && vdsDomInMaintenance.containsAll(vdsConnectedToPool))) {
                log.info("Moving domain '{}' to maintenance", domain.getId());
                DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(domain.getStoragePoolIsoMapData().getId(), StorageDomainStatus.Maintenance);
            }
            return null;
        }
    });
}
#method_after
public void queueDomainMaintenanceCheck(final StorageDomain domain, final StoragePool pool) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domain.getId(), null, EventType.DOMAINFAILOVER, ""), () -> {
        Collection<Guid> vdsConnectedToPool = getVdsConnectedToPool(_storagePoolId);
        Set<Guid> vdsDomInMaintenance = _domainsInMaintenance.get(domain.getId());
        if (vdsConnectedToPool.isEmpty() || (vdsDomInMaintenance != null && vdsDomInMaintenance.containsAll(vdsConnectedToPool))) {
            log.info("Moving domain '{}' to maintenance", domain.getId());
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(domain.getStoragePoolIsoMapData().getId(), StorageDomainStatus.Maintenance);
            AuditLogableBase auditLogableBase = new AuditLogableBase();
            auditLogableBase.addCustomValue("StorageDomainName", domain.getName());
            auditLogableBase.addCustomValue("StoragePoolName", pool.getName());
            new AuditLogDirector().log(auditLogableBase, AuditLogType.STORAGE_DOMAIN_MOVED_TO_MAINTENANCE);
        }
        return null;
    });
}
#end_block

#method_before
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getMasterDomainVersion()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getMasterDomainVersion(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() != StorageDomainStatus.Inactive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.Inactive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // For block domains, synchronize LUN details comprising the storage domain with the DB
        if (statusChanged && data.getStatus() == StorageDomainStatus.Active && storage_domain.getStorageType().isBlockDomain()) {
            ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(data.getId(), getCurrentVdsId());
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                AuditLogType type = AuditLogType.UNASSIGNED;
                Integer freeDiskInGB = data.getStorageDynamicData().getAvailableDiskSize();
                if (freeDiskInGB != null) {
                    if (freePercent < domainFromDb.getWarningLowSpaceIndicator()) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                    if (freeDiskInGB < domainFromDb.getCriticalSpaceActionBlocker()) {
                        // Note, if both conditions are met, only IRS_DISK_SPACE_LOW_ERROR will be shown
                        type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    new AuditLogDirector().log(logable, type);
                }
            }
            Set<EngineError> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (EngineError alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.error("Unrecognized alert for domain {}(id = {}): {}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debug("The domain with id '{}' was not found in DB", data.getId());
    }
}
#method_after
private void proceedStorageDomain(StorageDomain domainFromVdsm, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(domainFromVdsm.getId(), _storagePoolId);
    if (storage_domain != null) {
        StorageDomainStatic domainFromDb = storage_domain.getStorageStaticData();
        StoragePoolIsoMap domainPoolMapFromDb = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMapFromDb != null && domainPoolMapFromDb.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((domainFromVdsm.getStorageDomainType() == StorageDomainType.Master) || (domainFromVdsm.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(domainFromVdsm.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getMasterDomainVersion()) {
                reconstructMasterDomainNotInSync(domainFromVdsm.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getMasterDomainVersion(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMapFromDb == null) {
            domainFromVdsm.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainFromVdsm.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (!domainPoolMapFromDb.getStatus().isStorageDomainInProcess() && domainPoolMapFromDb.getStatus() != domainFromVdsm.getStatus()) {
            if (domainPoolMapFromDb.getStatus() != StorageDomainStatus.Inactive && domainFromVdsm.getStatus() != StorageDomainStatus.Inactive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(domainFromVdsm.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (domainFromVdsm.getStatus() != null && domainFromVdsm.getStatus() == StorageDomainStatus.Inactive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMapFromDb.getStoragePoolId());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // For block domains, synchronize LUN details comprising the storage domain with the DB
        if (statusChanged && domainFromVdsm.getStatus() == StorageDomainStatus.Active && storage_domain.getStorageType().isBlockDomain()) {
            ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(domainFromVdsm.getId(), getCurrentVdsId());
        }
        // update dynamic data
        if (statusChanged || (domainPoolMapFromDb.getStatus() != StorageDomainStatus.Inactive && domainFromVdsm.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(domainFromVdsm.getStorageDynamicData());
            if (domainFromVdsm.getAvailableDiskSize() != null && domainFromVdsm.getUsedDiskSize() != null) {
                double freePercent = domainFromVdsm.getStorageDynamicData().getfreeDiskPercent();
                AuditLogType type = AuditLogType.UNASSIGNED;
                Integer freeDiskInGB = domainFromVdsm.getStorageDynamicData().getAvailableDiskSize();
                if (freeDiskInGB != null) {
                    if (freePercent < domainFromDb.getWarningLowSpaceIndicator()) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                    if (freeDiskInGB < domainFromDb.getCriticalSpaceActionBlocker()) {
                        // Note, if both conditions are met, only IRS_DISK_SPACE_LOW_ERROR will be shown
                        type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(domainFromVdsm);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", domainFromVdsm.getAvailableDiskSize().toString());
                    domainFromVdsm.setStorageName(domainFromDb.getStorageName());
                    new AuditLogDirector().log(logable, type);
                }
            }
            Set<EngineError> alerts = domainFromVdsm.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(domainFromVdsm);
                domainFromVdsm.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (EngineError alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.error("Unrecognized alert for domain {}(id = {}): {}", domainFromVdsm.getStorageName(), domainFromVdsm.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debug("The domain with id '{}' was not found in DB", domainFromVdsm.getId());
    }
}
#end_block

#method_before
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    getEventQueue().submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT, "Reconstruct caused by failure to execute spm command"), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warn(logMessage);
            AuditLogableBase logable = new AuditLogableBase(currentVdsId);
            logable.setStorageDomainId(masterDomainId);
            new AuditLogDirector().log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false, true);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#method_after
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    getEventQueue().submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT, "Reconstruct caused by failure to execute spm command"), () -> {
        log.warn(logMessage);
        AuditLogableBase logable = new AuditLogableBase(currentVdsId);
        logable.setStorageDomainId(masterDomainId);
        new AuditLogDirector().log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
        return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false, true);
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#end_block

#method_before
public void init(VDS vds) {
    currentVdsId = vds.getId();
    setmIrsPort(vds.getPort());
    privatemCurrentIrsHost = vds.getHostName();
    setProtocol(vds.getProtocol());
    setVersion(vds.getVdsGroupCompatibilityVersion());
}
#method_after
public void init(VDS vds) {
    currentVdsId = vds.getId();
    setmIrsPort(vds.getPort());
    privatemCurrentIrsHost = vds.getHostName();
    setProtocol(vds.getProtocol());
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(getProtocol(), getVersion(), host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, () -> gethostFromVds());
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(getProtocol(), host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (DbFacade.getInstance().isStoragePoolMasterUp(_storagePoolId)) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent: {}", exp.getMessage());
                log.debug("Exception", exp);
            }
        }
    });
}
#method_after
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (isMasterDomainUp()) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent: {}", exp.getMessage());
                log.debug("Exception", exp);
            }
        }

        private boolean isMasterDomainUp() {
            return DbFacade.getInstance().getStorageDomainDao().getStorageDomains(_storagePoolId, StorageDomainType.Master).stream().anyMatch(d -> d.getStatus() == StorageDomainStatus.Active || d.getStatus() == StorageDomainStatus.Unknown);
        }
    });
}
#end_block

#method_before
public boolean getHasVdssForSpmSelection() {
    return (getPrioritizedVdsInPool().size() > 0);
}
#method_after
public boolean getHasVdssForSpmSelection() {
    return getPrioritizedVdsInPool().size() > 0;
}
#end_block

#method_before
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.info("hostFromVds::Finished elect spm, storage pool '{}' was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    currentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        triedVdssList.add(selectedVdsId);
        if (isStoragePoolMemoryBackend(storagePool)) {
            connectStoragePool(selectedVds, storagePool);
        }
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        boolean ignoreSpmStatusResult = returnValueFromVds.getVdsError() != null && returnValueFromVds.getVdsError().getCode() == EngineError.InquireNotSupportedError;
        if (spmStatus != null || ignoreSpmStatusResult) {
            currentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.info("hostFromVds::selectedVds - '{}', spmStatus '{}', storage pool '{}', storage pool version '{}'", selectedVds.getName(), spmStatus != null ? spmStatus.getSpmStatus() : "unknown", storagePool.getName(), storagePool.getCompatibilityVersion());
            if (ignoreSpmStatusResult) {
                spmStatus = startSpm(storagePool, selectedVds, DEFAULT_PREV_ID, DEFAULT_LVER, DEFAULT_PREV_ID);
            } else {
                if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                    connectStoragePool(selectedVds, storagePool);
                    performedPoolConnect = true;
                    // refresh spmStatus result
                    spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                    log.info("hostFromVds::Connected host to pool - selectedVds - {}, spmStatus {}, storage pool {}", selectedVds.getName(), spmStatus.getSpmStatus(), storagePool.getName());
                }
                RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
                spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
                selectedVds = tempRefObject.argvalue;
            }
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                currentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.info("hostFromVds::selectedVds - '{}', spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.info("hostFromVds::Finished elect spm, storage pool '{}' was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    currentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        triedVdssList.add(selectedVdsId);
        connectStoragePool(selectedVds, storagePool);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        boolean ignoreSpmStatusResult = returnValueFromVds.getVdsError() != null && returnValueFromVds.getVdsError().getCode() == EngineError.InquireNotSupportedError;
        if (spmStatus != null || ignoreSpmStatusResult) {
            currentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.info("hostFromVds::selectedVds - '{}', spmStatus '{}', storage pool '{}', storage pool version '{}'", selectedVds.getName(), spmStatus != null ? spmStatus.getSpmStatus() : "unknown", storagePool.getName(), storagePool.getCompatibilityVersion());
            if (ignoreSpmStatusResult) {
                spmStatus = startSpm(storagePool, selectedVds, DEFAULT_PREV_ID, DEFAULT_LVER, DEFAULT_PREV_ID);
            } else {
                if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                    connectStoragePool(selectedVds, storagePool);
                    performedPoolConnect = true;
                    // refresh spmStatus result
                    spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                    log.info("hostFromVds::Connected host to pool - selectedVds - {}, spmStatus {}, storage pool {}", selectedVds.getName(), spmStatus.getSpmStatus(), storagePool.getName());
                }
                RefObject<VDS> tempRefObject = new RefObject<>(selectedVds);
                spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
                selectedVds = tempRefObject.argvalue;
            }
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                currentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.info("hostFromVds::selectedVds - '{}', spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private List<VDS> getPrioritizedVdsInPool() {
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getListForSpmSelection(_storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<VDS>();
    Guid preferredHost = IrsBrokerCommand.getIrsProxyData(_storagePoolId).getPreferredHostId();
    IrsBrokerCommand.getIrsProxyData(_storagePoolId).setPreferredHostId(null);
    for (VDS vds : allVds) {
        if (!triedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            if (vds.getId().equals(preferredHost)) {
                vdsRelevantForSpmSelection.add(0, vds);
            } else {
                vdsRelevantForSpmSelection.add(vds);
            }
        }
    }
    return vdsRelevantForSpmSelection;
}
#method_after
private List<VDS> getPrioritizedVdsInPool() {
    Guid curVdsId = (currentVdsId != null) ? currentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getListForSpmSelection(_storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<>();
    Guid preferredHost = IrsBrokerCommand.getIrsProxyData(_storagePoolId).getPreferredHostId();
    IrsBrokerCommand.getIrsProxyData(_storagePoolId).setPreferredHostId(null);
    for (VDS vds : allVds) {
        if (!triedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            if (vds.getId().equals(preferredHost)) {
                vdsRelevantForSpmSelection.add(0, vds);
            } else {
                vdsRelevantForSpmSelection.add(vds);
            }
        }
    }
    return vdsRelevantForSpmSelection;
}
#end_block

#method_before
private String handleSelectedVdsForSPM(StoragePool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        movePoolToProblematicInDB(storagePool);
        selectedVds.argvalue = null;
        log.info("spm start treatment ended and status is not SPM!!! status: '{}' - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus());
    } else {
        init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setSpmVdsId(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.NonResponsive) {
            storagePool.setStatus(prevStatus);
        } else {
            storagePool.setStatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
        setFencedIrs(null);
        returnValue = selectedVds.argvalue.getHostName();
        log.info("Initialize Irs proxy from vds: {}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.addCustomValue("ServerIp", returnValue);
        new AuditLogDirector().log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#method_after
private String handleSelectedVdsForSPM(StoragePool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        movePoolToProblematicInDB(storagePool);
        selectedVds.argvalue = null;
        log.info("spm start treatment ended and status is not SPM!!! status: '{}' - setting selectedVds to null!", spmStatus.argvalue != null ? spmStatus.argvalue.getSpmStatus() : null);
    } else {
        init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setSpmVdsId(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.NonResponsive) {
            storagePool.setStatus(prevStatus);
        } else {
            storagePool.setStatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
        setFencedIrs(null);
        returnValue = selectedVds.argvalue.getHostName();
        log.info("Initialize Irs proxy from vds: {}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.addCustomValue("ServerIp", returnValue);
        new AuditLogDirector().log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#end_block

#method_before
private boolean wasVdsManuallyFenced(int spmId) {
    vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, spmId);
    return map != null && map.getId().equals(getFencedIrs());
}
#method_after
private boolean wasVdsManuallyFenced(int spmId) {
    VdsSpmIdMap map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, spmId);
    return map != null && map.getId().equals(getFencedIrs());
}
#end_block

#method_before
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1 && !wasVdsManuallyFenced(spmStatus.getSpmId())) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.info("Found spm host '{}', host name: '{}', according to spmId: '{}'.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.info("SpmStatus on vds '{}': '{}'", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus());
                    // intentionally unreachable code
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (!spmVdsId.equals(selectedVds.argvalue.getId()) && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.info("Using old spm server: '{}', no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM '{}', but is not up.", spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.error("SPM Init: could not find reported vds or not up - pool: '{}' vds_spm_id: '{}'", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.info("SPM selection - vds seems as spm '{}'", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            spmStatus = startSpm(storagePool, selectedVds.argvalue, spmStatus.getSpmId(), spmStatus.getSpmLVER(), vdsSpmIdToFence);
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1 && !wasVdsManuallyFenced(spmStatus.getSpmId())) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.info("Found spm host '{}', host name: '{}', according to spmId: '{}'.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.info("SpmStatus on vds '{}': '{}'", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus());
                    // intentionally unreachable code
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (!spmVdsId.equals(selectedVds.argvalue.getId()) && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.info("Using old spm server: '{}', no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM '{}', but is not up.", spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.error("SPM Init: could not find reported vds or not up - pool: '{}' vds_spm_id: '{}'", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            VdsSpmIdMap map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.info("SPM selection - vds seems as spm '{}'", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            spmStatus = startSpm(storagePool, selectedVds.argvalue, spmStatus.getSpmId(), spmStatus.getSpmLVER(), vdsSpmIdToFence);
        }
    }
    return spmStatus;
}
#end_block

#method_before
private SpmStatusResult startSpm(final StoragePool storagePool, VDS selectedVds, int prevId, String lver, int vdsSpmIdToFence) {
    storagePool.setStatus(StoragePoolStatus.Contend);
    storagePool.setSpmVdsId(selectedVds.getId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            DbFacade.getInstance().getStoragePoolDao().update(storagePool);
            return null;
        }
    });
    log.info("starting spm on vds '{}', storage pool '{}', prevId '{}', LVER '{}'", selectedVds.getName(), storagePool.getName(), prevId, lver);
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.getId(), _storagePoolId, prevId, lver, storagePool.getRecoveryMode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
    if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
        ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        if (spmStatus != null) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                    pool.setSpmVdsId(null);
                    DbFacade.getInstance().getStoragePoolDao().update(pool);
                    return null;
                }
            });
        }
        throw new IrsSpmStartFailedException();
    }
    return spmStatus;
}
#method_after
private SpmStatusResult startSpm(final StoragePool storagePool, VDS selectedVds, int prevId, String lver, int vdsSpmIdToFence) {
    storagePool.setStatus(StoragePoolStatus.Contend);
    storagePool.setSpmVdsId(selectedVds.getId());
    TransactionSupport.executeInNewTransaction(() -> {
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        return null;
    });
    log.info("starting spm on vds '{}', storage pool '{}', prevId '{}', LVER '{}'", selectedVds.getName(), storagePool.getName(), prevId, lver);
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.getId(), _storagePoolId, prevId, lver, storagePool.getRecoveryMode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
    if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
        ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, EngineError.ENGINE, TransactionScopeOption.RequiresNew);
        if (spmStatus != null) {
            TransactionSupport.executeInNewTransaction(() -> {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                pool.setSpmVdsId(null);
                DbFacade.getInstance().getStoragePoolDao().update(pool);
                return null;
            });
        }
        throw new IrsSpmStartFailedException();
    }
    return spmStatus;
}
#end_block

#method_before
public String getIsoDirectory() {
    String tempVar = privatemCurrentIrsHost;
    return String.format("\\\\%1$s\\CD", ((tempVar != null) ? tempVar : gethostFromVds()));
}
#method_after
public String getIsoDirectory() {
    String tempVar = privatemCurrentIrsHost;
    return String.format("\\\\%1$s\\CD", tempVar != null ? tempVar : gethostFromVds());
}
#end_block

#method_before
private void nullifyInternalProxies() {
    if (irsProxy != null) {
        if (IrsServerWrapper.class.isInstance(irsProxy)) {
            XmlRpcUtils.shutDownConnection(((IrsServerWrapper) irsProxy).getHttpClient());
        } else {
            ((JsonRpcIIrsServer) irsProxy).close();
        }
    }
    privatemCurrentIrsHost = null;
    irsProxy = null;
    currentVdsId = null;
}
#method_after
private void nullifyInternalProxies() {
    if (irsProxy != null) {
        irsProxy.close();
    }
    privatemCurrentIrsHost = null;
    irsProxy = null;
    currentVdsId = null;
}
#end_block

#method_before
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInMaintenance = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = new HashMap<>();
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> activeDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            Set<Guid> unknownDomainsInPool = new HashSet<>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Inactive));
            // build a list of all the domains in
            // pool (activeDomainsInPool and unknownDomainsInPool) that are not
            // visible by the host.
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : activeDomainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
                }
            }
            for (Guid tempDomainId : unknownDomainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
                }
            }
            // Unknown domains in pool
            for (VDSDomainsData tempData : data) {
                if (activeDomainsInPool.contains(tempData.getDomainId()) || unknownDomainsInPool.contains(tempData.getDomainId())) {
                    DomainMonitoringResult domainMonitoringResult = analyzeDomainReport(tempData, storagePool, false);
                    if (domainMonitoringResult.invalidAndActual()) {
                        domainsProblematicReportInfo.put(tempData.getDomainId(), domainMonitoringResult);
                    } else if (domainMonitoringResult.actual() && tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if ((inActiveDomainsInPool.contains(tempData.getDomainId()) || // in data centers with spm, unknown domains are moving to Active status according to the pool metadata.
                (FeatureSupported.dataCenterWithoutSpm(storagePool.getCompatibilityVersion()) && unknownDomainsInPool.contains(tempData.getDomainId()))) && analyzeDomainReport(tempData, storagePool, false).validAndActual()) {
                    log.warn("Storage Domain '{}' was reported by Host '{}' as Active in Pool '{}', moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                    // For block domains, synchronize LUN details comprising the storage domain with the DB
                    StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(tempData.getDomainId());
                    if (storageDomain.getStorageType().isBlockDomain()) {
                        ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(storageDomain.getId(), vdsId);
                    }
                }
            }
            Set<Guid> maintInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Maintenance));
            maintInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.PreparingForMaintenance));
            domainsInMaintenance = new HashSet<Guid>();
            for (Guid tempDomainId : maintInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInMaintenance.add(tempDomainId);
                }
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#method_after
public void updateVdsDomainsData(VDS vds, final ArrayList<VDSDomainsData> data) {
    if (!shouldProcessVdsDomainReport(vds)) {
        return;
    }
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        Guid vdsId = vds.getId();
        String vdsName = vds.getName();
        try {
            Set<Guid> monitoredDomains = new HashSet<>();
            for (VDSDomainsData tempData : data) {
                monitoredDomains.add(tempData.getDomainId());
            }
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = Collections.emptyMap();
            if (StoragePoolDomainHelper.vdsDomainsActiveMonitoringStatus.contains(vds.getStatus())) {
                domainsProblematicReportInfo = handleMonitoredDomainsForHost(vdsId, vdsName, data, monitoredDomains, storagePool);
            }
            Set<Guid> domainsInMaintenance = Collections.emptySet();
            if (StoragePoolDomainHelper.vdsDomainsMaintenanceMonitoringStatus.contains(vds.getStatus())) {
                domainsInMaintenance = handleDomainsInMaintenanceForHost(monitoredDomains);
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#end_block

#method_before
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Map<Guid, DomainMonitoringResult> domainsInProblem, final Set<Guid> domainsInMaintenance) {
    getEventQueue().submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
            updateProblematicVdsData(vdsId, vdsName, domainsInProblem);
            updateMaintenanceVdsData(vdsId, vdsName, domainsInMaintenance);
            return result;
        }
    });
}
#method_after
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Map<Guid, DomainMonitoringResult> domainsInProblem, final Set<Guid> domainsInMaintenance) {
    getEventQueue().submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING, ""), () -> {
        EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
        updateProblematicVdsData(vdsId, vdsName, domainsInProblem);
        updateMaintenanceVdsData(vdsId, vdsName, domainsInMaintenance);
        return result;
    });
}
#end_block

#method_before
protected List<Guid> obtainDomainsReportedAsProblematic(List<VDSDomainsData> vdsDomainsData, StoragePool storagePool) {
    List<Guid> domainsInProblem = new LinkedList<>();
    Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
    domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
    List<Guid> domainWhichWereSeen = new ArrayList<Guid>();
    for (VDSDomainsData vdsDomainData : vdsDomainsData) {
        if (domainsInPool.contains(vdsDomainData.getDomainId())) {
            if (analyzeDomainReport(vdsDomainData, storagePool, true).invalidAndActual()) {
                domainsInProblem.add(vdsDomainData.getDomainId());
            }
            domainWhichWereSeen.add(vdsDomainData.getDomainId());
        }
    }
    domainsInPool.removeAll(domainWhichWereSeen);
    if (domainsInPool.size() > 0) {
        for (Guid domainId : domainsInPool) {
            log.error("Domain '{}' is not seen by Host", domainId);
        }
        domainsInProblem.addAll(domainsInPool);
    }
    return domainsInProblem;
}
#method_after
protected List<Guid> obtainDomainsReportedAsProblematic(List<VDSDomainsData> vdsDomainsData) {
    List<Guid> domainsInProblem = new LinkedList<>();
    Set<Guid> domainsInPool = new HashSet<>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
    domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
    List<Guid> domainWhichWereSeen = new ArrayList<>();
    for (VDSDomainsData vdsDomainData : vdsDomainsData) {
        if (domainsInPool.contains(vdsDomainData.getDomainId())) {
            if (analyzeDomainReport(vdsDomainData, true).invalidAndActual()) {
                domainsInProblem.add(vdsDomainData.getDomainId());
            }
            domainWhichWereSeen.add(vdsDomainData.getDomainId());
        }
    }
    domainsInPool.removeAll(domainWhichWereSeen);
    if (domainsInPool.size() > 0) {
        for (Guid domainId : domainsInPool) {
            log.error("Domain '{}' is not seen by Host", domainId);
        }
        domainsInProblem.addAll(domainsInPool);
    }
    return domainsInProblem;
}
#end_block

#method_before
private DomainMonitoringResult analyzeDomainReport(VDSDomainsData tempData, StoragePool storagePool, boolean isLog) {
    if (!tempData.isActual() && FeatureSupported.reportWhetherDomainMonitoringResultIsActual(storagePool.getCompatibilityVersion())) {
        log.warn("Domain '{}' report isn't an actual report", getDomainIdTuple(tempData.getDomainId()));
        return DomainMonitoringResult.NOT_ACTUAL;
    }
    if (tempData.getCode() != 0) {
        if (isLog) {
            log.error("Domain '{}' was reported with error code '{}'", getDomainIdTuple(tempData.getDomainId()), tempData.getCode());
        }
        if (tempData.getCode() == EngineError.StorageDomainDoesNotExist.getValue() || tempData.getCode() == EngineError.StorageException.getValue()) {
            return DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        }
        return DomainMonitoringResult.PROBLEMATIC;
    }
    if (tempData.getLastCheck() > Config.<Double>getValue(ConfigValues.MaxStorageVdsTimeoutCheckSec)) {
        if (isLog) {
            log.error("Domain '{}' check timeout '{}' is too big", getDomainIdTuple(tempData.getDomainId()), tempData.getLastCheck());
        }
        return DomainMonitoringResult.PROBLEMATIC;
    }
    return DomainMonitoringResult.OK;
}
#method_after
private DomainMonitoringResult analyzeDomainReport(VDSDomainsData tempData, boolean isLog) {
    if (!tempData.isActual()) {
        log.warn("Domain '{}' report isn't an actual report", getDomainIdTuple(tempData.getDomainId()));
        return DomainMonitoringResult.NOT_ACTUAL;
    }
    if (tempData.getCode() != 0) {
        if (isLog) {
            log.error("Domain '{}' was reported with error code '{}'", getDomainIdTuple(tempData.getDomainId()), tempData.getCode());
        }
        if (tempData.getCode() == EngineError.StorageDomainDoesNotExist.getValue() || tempData.getCode() == EngineError.StorageException.getValue()) {
            return DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        }
        return DomainMonitoringResult.PROBLEMATIC;
    }
    if (tempData.getLastCheck() > Config.<Double>getValue(ConfigValues.MaxStorageVdsTimeoutCheckSec)) {
        if (isLog) {
            log.error("Domain '{}' check timeout '{}' is too big", getDomainIdTuple(tempData.getDomainId()), tempData.getLastCheck());
        }
        return DomainMonitoringResult.PROBLEMATIC;
    }
    return DomainMonitoringResult.OK;
}
#end_block

#method_before
private void updateProblematicVdsData(final Guid vdsId, final String vdsName, Map<Guid, DomainMonitoringResult> problematicDomains) {
    // for all problematic domains
    // update cache of _domainsInProblem
    // and _vdssInProblem and add a new
    // timer for new domains in problem
    boolean newDomainUnreachableByHost = false;
    List<Guid> domainsUnreachableByHost = new LinkedList<>();
    for (Map.Entry<Guid, DomainMonitoringResult> entry : problematicDomains.entrySet()) {
        Guid domainId = entry.getKey();
        DomainMonitoringResult domainMonitoringResult = entry.getValue();
        HashSet<Guid> hostsReportedDomainAsProblematic = _domainsInProblem.get(domainId);
        boolean domainNotFound = domainMonitoringResult == DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        if (domainNotFound) {
            domainsUnreachableByHost.add(domainId);
        }
        if (hostsReportedDomainAsProblematic != null) {
            if (!hostsReportedDomainAsProblematic.contains(vdsId) && domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // existing domains in problem
            updateDomainInProblemData(domainId, vdsId, vdsName);
        } else {
            if (domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // new domains in problems
            addDomainInProblemData(domainId, vdsId, vdsName);
        }
    }
    if (domainsUnreachableByHost.isEmpty()) {
        Guid clearedReport = clearVdsReportInfoOnUnseenDomain(vdsId);
        if (clearedReport != null)
            log.info("Host '{}' no longer storage access problem to any relevant domain " + " clearing it's report (report id: '{}')", vdsId, clearedReport);
    } else if (newDomainUnreachableByHost) {
        Guid newReportId = Guid.newGuid();
        log.info("Host '{}' has reported new storage access problem to the following domains '{}'" + " marking it for storage connections and pool metadata refresh (report id: '{}')", vdsId, StringUtils.join(domainsUnreachableByHost, ","), newReportId);
        vdsReportsOnUnseenDomain.put(vdsId, newReportId);
    }
    Set<Guid> notReportedDomainsByHost = new HashSet<Guid>(_domainsInProblem.keySet());
    notReportedDomainsByHost.removeAll(problematicDomains.keySet());
    for (Guid domainId : notReportedDomainsByHost) {
        Set<Guid> vdsForDomain = _domainsInProblem.get(domainId);
        if (vdsForDomain != null && vdsForDomain.contains(vdsId)) {
            domainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#method_after
private void updateProblematicVdsData(final Guid vdsId, final String vdsName, Map<Guid, DomainMonitoringResult> problematicDomains) {
    // for all problematic domains
    // update cache of _domainsInProblem
    // and _vdssInProblem and add a new
    // timer for new domains in problem
    boolean newDomainUnreachableByHost = false;
    List<Guid> domainsUnreachableByHost = new LinkedList<>();
    for (Map.Entry<Guid, DomainMonitoringResult> entry : problematicDomains.entrySet()) {
        Guid domainId = entry.getKey();
        DomainMonitoringResult domainMonitoringResult = entry.getValue();
        HashSet<Guid> hostsReportedDomainAsProblematic = _domainsInProblem.get(domainId);
        boolean domainNotFound = domainMonitoringResult == DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        if (domainNotFound) {
            domainsUnreachableByHost.add(domainId);
        }
        if (hostsReportedDomainAsProblematic != null) {
            if (!hostsReportedDomainAsProblematic.contains(vdsId) && domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // existing domains in problem
            updateDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        } else {
            if (domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // new domains in problems
            addDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        }
    }
    if (domainsUnreachableByHost.isEmpty()) {
        Guid clearedReport = clearVdsReportInfoOnUnseenDomain(vdsId);
        if (clearedReport != null) {
            log.info("Host '{}' no longer storage access problem to any relevant domain " + " clearing it's report (report id: '{}')", vdsId, clearedReport);
        }
    } else if (newDomainUnreachableByHost) {
        Guid newReportId = Guid.newGuid();
        log.info("Host '{}' has reported new storage access problem to the following domains '{}'" + " marking it for storage connections and pool metadata refresh (report id: '{}')", vdsId, StringUtils.join(domainsUnreachableByHost, ","), newReportId);
        vdsReportsOnUnseenDomain.put(vdsId, newReportId);
    }
    Set<Guid> notReportedDomainsByHost = new HashSet<>(_domainsInProblem.keySet());
    notReportedDomainsByHost.removeAll(problematicDomains.keySet());
    for (Guid domainId : notReportedDomainsByHost) {
        Set<Guid> vdsForDomain = _domainsInProblem.get(domainId);
        if (vdsForDomain != null && vdsForDomain.contains(vdsId)) {
            domainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#end_block

#method_before
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new HashSet<Guid>(Arrays.asList(vdsId)));
    log.warn("domain '{}' in problem. vds: '{}'", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFailureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#method_after
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    _domainsInProblem.put(domainId, new HashSet<>(Arrays.asList(vdsId)));
    log.warn("domain '{}' in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFailureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer(final Guid domainId) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting processDomainRecovery for domain '{}'.", getDomainIdTuple(domainId));
                result = processDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer(final Guid domainId) {
    getEventQueue().submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER, ""), () -> {
        EventResult result = null;
        if (_domainsInProblem.containsKey(domainId)) {
            log.info("starting processDomainRecovery for domain '{}'.", getDomainIdTuple(domainId));
            result = processDomainRecovery(domainId);
        }
        _timers.remove(domainId);
        return result;
    });
}
#end_block

#method_before
@OnTimerMethodAnnotation("hostsStorageConnectionsAndPoolMetadataRefresh")
public void hostsStorageConnectionsAndPoolMetadataRefresh() {
    Map<Guid, Guid> reportsToHandle = procceedReportsThreatmenet();
    if (reportsToHandle.isEmpty()) {
        return;
    }
    List<Callable<Void>> connectStorageTasks = new ArrayList<>();
    final List<Callable<Void>> refreshStoragePoolTasks = new ArrayList<>();
    final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    final Guid masterDomainId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
    final List<StoragePoolIsoMap> storagePoolIsoMap = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(_storagePoolId);
    Map<String, Pair<String, String>> acquiredLocks = new HashMap<>();
    try {
        for (Map.Entry<Guid, Guid> entry : reportsToHandle.entrySet()) {
            Guid vdsId = entry.getKey();
            Guid currentReportId = entry.getValue();
            vdsHandeledReportsOnUnseenDomains.put(vdsId, currentReportId);
            Map<String, Pair<String, String>> lockMap = Collections.singletonMap(vdsId.toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString()));
            EngineLock engineLock = new EngineLock(lockMap, null);
            if (!LockManagerFactory.getLockManager().acquireLock(engineLock).getFirst()) {
                log.info("Failed to acquire lock to refresh storage connection and pool metadata for host '{}', skipping it", vdsId);
                continue;
            }
            final VDS vds = DbFacade.getInstance().getVdsDao().get(entry.getKey());
            if (vds.getStatus() != VDSStatus.Up) {
                log.info("Skipping storage connection and pool metadata information for host '{}' as it's no longer in status UP", vdsId);
                LockManagerFactory.getLockManager().releaseLock(engineLock);
                continue;
            }
            acquiredLocks.putAll(lockMap);
            connectStorageTasks.add(new Callable<Void>() {

                @Override
                public Void call() {
                    ResourceManager.getInstance().getEventListener().connectHostToDomainsInActiveOrUnknownStatus(vds);
                    return null;
                }
            });
            refreshStoragePoolTasks.add(new Callable<Void>() {

                @Override
                public Void call() {
                    StoragePoolDomainHelper.refreshHostPoolMetadata(vds, storagePool, masterDomainId, storagePoolIsoMap);
                    return null;
                }
            });
        }
        final Set<String> handledHosts = acquiredLocks.keySet();
        log.info("Running storage connections refresh for hosts '{}'", handledHosts);
        ThreadPoolUtil.invokeAll(connectStorageTasks);
        log.info("Submitting to the event queue pool refresh for hosts '{}'", handledHosts);
        getEventQueue().submitEventSync(new Event(_storagePoolId, null, null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                log.info("Running storage pool metadata refresh for hosts '{}'", handledHosts);
                ThreadPoolUtil.invokeAll(refreshStoragePoolTasks);
                return new EventResult(true, EventType.POOLREFRESH);
            }
        });
    } finally {
        if (!acquiredLocks.isEmpty()) {
            LockManagerFactory.getLockManager().releaseLock(new EngineLock(acquiredLocks, null));
        }
    }
}
#method_after
@OnTimerMethodAnnotation("hostsStorageConnectionsAndPoolMetadataRefresh")
public void hostsStorageConnectionsAndPoolMetadataRefresh() {
    Map<Guid, Guid> reportsToHandle = procceedReportsThreatmenet();
    if (reportsToHandle.isEmpty()) {
        return;
    }
    List<Callable<Void>> connectStorageTasks = new ArrayList<>();
    final List<Callable<Void>> refreshStoragePoolTasks = new ArrayList<>();
    final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    final Guid masterDomainId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
    final List<StoragePoolIsoMap> storagePoolIsoMap = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(_storagePoolId);
    Map<String, Pair<String, String>> acquiredLocks = new HashMap<>();
    try {
        for (Map.Entry<Guid, Guid> entry : reportsToHandle.entrySet()) {
            Guid vdsId = entry.getKey();
            Guid currentReportId = entry.getValue();
            vdsHandeledReportsOnUnseenDomains.put(vdsId, currentReportId);
            Map<String, Pair<String, String>> lockMap = Collections.singletonMap(vdsId.toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString()));
            EngineLock engineLock = new EngineLock(lockMap, null);
            if (!LockManagerFactory.getLockManager().acquireLock(engineLock).getFirst()) {
                log.info("Failed to acquire lock to refresh storage connection and pool metadata for host '{}', skipping it", vdsId);
                continue;
            }
            final VDS vds = DbFacade.getInstance().getVdsDao().get(entry.getKey());
            if (vds.getStatus() != VDSStatus.Up) {
                log.info("Skipping storage connection and pool metadata information for host '{}' as it's no longer in status UP", vdsId);
                LockManagerFactory.getLockManager().releaseLock(engineLock);
                continue;
            }
            acquiredLocks.putAll(lockMap);
            connectStorageTasks.add(() -> {
                ResourceManager.getInstance().getEventListener().connectHostToDomainsInActiveOrUnknownStatus(vds);
                return null;
            });
            refreshStoragePoolTasks.add(() -> {
                StoragePoolDomainHelper.refreshHostPoolMetadata(vds, storagePool, masterDomainId, storagePoolIsoMap);
                return null;
            });
        }
        final Set<String> handledHosts = acquiredLocks.keySet();
        log.info("Running storage connections refresh for hosts '{}'", handledHosts);
        ThreadPoolUtil.invokeAll(connectStorageTasks);
        log.info("Submitting to the event queue pool refresh for hosts '{}'", handledHosts);
        getEventQueue().submitEventSync(new Event(_storagePoolId, null, null, EventType.POOLREFRESH, ""), () -> {
            log.info("Running storage pool metadata refresh for hosts '{}'", handledHosts);
            ThreadPoolUtil.invokeAll(refreshStoragePoolTasks);
            return new EventResult(true, EventType.POOLREFRESH);
        });
    } finally {
        if (!acquiredLocks.isEmpty()) {
            LockManagerFactory.getLockManager().releaseLock(new EngineLock(acquiredLocks, null));
        }
    }
}
#end_block

#method_before
private void updateDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    log.debug("domain '{}' still in problem. vds: '{}'", getDomainIdTuple(domainId), vdsName);
    _domainsInProblem.get(domainId).add(vdsId);
}
#method_after
private void updateDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    log.debug("domain '{}' still in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    _domainsInProblem.get(domainId).add(vdsId);
}
#end_block

#method_before
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    // Note - this method is used as it returns only hosts from VIRT supported clusters
    // (we use the domain monitoring results only from those clusters hosts).
    // every change to it should be inspected carefully.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, null);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warn("vds '{}' reported domain '{}' - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warn("vds '{}' reported domain '{}' as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    final Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", storageDomain.getName());
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId, customLogValues);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warn("vds '{}' reported domain '{}' as in problem, vds is in status '{}', no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warn("Storage domain '{}' is not visible to one or more hosts. " + "Since the domain's type is '{}', hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.error("Domain '{}' was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warn("Domain '{}' was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<>();
    // Note - this method is used as it returns only hosts from VIRT supported clusters
    // (we use the domain monitoring results only from those clusters hosts).
    // every change to it should be inspected carefully.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, null);
    Map<Guid, VDS> vdsMap = new HashMap<>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warn("vds '{}' reported domain '{}' - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warn("vds '{}' reported domain '{}' as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    final Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", storageDomain.getName());
                    ThreadPoolUtil.execute(() -> ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId, customLogValues));
                    nonOpVdss.add(vdsId);
                } else {
                    log.warn("vds '{}' reported domain '{}' as in problem, vds is in status '{}', no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warn("Storage domain '{}' is not visible to one or more hosts. " + "Since the domain's type is '{}', hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.error("Domain '{}' was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warn("Domain '{}' was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
public void dispose() {
    try {
        syncLock.lock();
        log.info("IrsProxyData::disposing");
        resetIrs();
        getSchedulUtil().deleteJob(storagePoolRefreshJobId);
        getSchedulUtil().deleteJob(domainRecoverOnHostJobId);
        _disposed = true;
    } finally {
        syncLock.unlock();
    }
}
#method_after
public void dispose() {
    runInControlledConcurrency(() -> {
        log.info("IrsProxyData::disposing");
        resetIrs();
        getSchedulUtil().deleteJob(storagePoolRefreshJobId);
        getSchedulUtil().deleteJob(domainRecoverOnHostJobId);
        _disposed = true;
    });
}
#end_block

#method_before
@Override
public boolean ignoreChildCommandFailure() {
    return getParameters().getStage() != LiveMigrateStage.CREATE_SNAPSHOT;
}
#method_after
@Override
public boolean ignoreChildCommandFailure() {
    return isRemoveAutoGeneratedSnapshotRequired();
}
#end_block

#method_before
private boolean isRemoveAutoGeneratedSnapshotRequired() {
    return getParameters().getStage() == LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_START || getParameters().getStage() == LiveMigrateStage.LIVE_MIGRATE_DISK_EXEC_COMPLETED;
}
#method_after
private boolean isRemoveAutoGeneratedSnapshotRequired() {
    return getParameters().getStage() != LiveMigrateStage.CREATE_SNAPSHOT && getParameters().getStage() != LiveMigrateStage.AUTO_GENERATED_SNAPSHOT_REMOVE_END;
}
#end_block

#method_before
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), "Auto-generated for Live Storage Migration");
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDisks(getMovedDisks());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#method_after
protected CreateAllSnapshotsFromVmParameters getCreateSnapshotParameters() {
    CreateAllSnapshotsFromVmParameters params = new CreateAllSnapshotsFromVmParameters(getParameters().getVmId(), StorageConstants.LSM_AUTO_GENERATED_SNAPSHOT_DESCRIPTION, false);
    params.setParentCommand(VdcActionType.LiveMigrateVmDisks);
    params.setSnapshotType(SnapshotType.REGULAR);
    params.setParentParameters(getParameters());
    params.setImagesParameters(getParameters().getImagesParameters());
    params.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
    params.setDisks(getMovedDisks());
    params.setDiskIdsToIgnoreInChecks(getMovedDiskIds());
    params.setNeedsLocking(false);
    params.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return params;
}
#end_block

#method_before
private Guid createDisk(DiskImage image, boolean isBoot) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    image.setVolumeFormat(VolumeFormat.COW);
    AddDiskParameters diskParameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    DiskVmElement dve = new DiskVmElement(image.getId(), getVmId());
    dve.setDiskInterface(DiskInterface.VirtIO);
    dve.setBoot(isBoot);
    diskParameters.setDiskVmElement(dve);
    VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.AddDisk, diskParameters);
    if (!vdcReturnValueBase.getSucceeded()) {
        throw new EngineException(vdcReturnValueBase.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    return vdcReturnValueBase.getActionReturnValue();
}
#method_after
private Guid createDisk(DiskImage image, boolean isBoot) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    AddDiskParameters diskParameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    DiskVmElement dve = new DiskVmElement(image.getId(), getVmId());
    dve.setDiskInterface(DiskInterface.VirtIO);
    dve.setBoot(isBoot);
    diskParameters.setDiskVmElement(dve);
    VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.AddDisk, diskParameters);
    if (!vdcReturnValueBase.getSucceeded()) {
        throw new EngineException(vdcReturnValueBase.getFault().getError(), "Failed to create disk!");
    }
    getTaskIdList().addAll(vdcReturnValueBase.getInternalVdsmTaskIdList());
    return vdcReturnValueBase.getActionReturnValue();
}
#end_block

#method_before
private static void mockGetTemplatesFromExportDomainQuery(VolumeFormat volumeFormat, VolumeType volumeType, ImportVmTemplateCommand command) {
    final VdcQueryReturnValue result = new VdcQueryReturnValue();
    Map<VmTemplate, List<DiskImage>> resultMap = new HashMap<>();
    DiskImage image = new DiskImage();
    image.setActualSizeInBytes(2);
    image.setVolumeFormat(volumeFormat);
    image.setVolumeType(volumeType);
    resultMap.put(new VmTemplate(), Arrays.asList(image));
    result.setReturnValue(resultMap);
    result.setSucceeded(true);
    when(command.getBackend().runInternalQuery(eq(VdcQueryType.GetTemplatesFromExportDomain), any(VdcQueryParametersBase.class), any(EngineContext.class))).thenReturn(result);
}
#method_after
private static void mockGetTemplatesFromExportDomainQuery(VolumeFormat volumeFormat, VolumeType volumeType, ImportVmTemplateCommand command) {
    final VdcQueryReturnValue result = new VdcQueryReturnValue();
    Map<VmTemplate, List<DiskImage>> resultMap = new HashMap<>();
    DiskImage image = new DiskImage();
    image.setActualSizeInBytes(2);
    image.setvolumeFormat(volumeFormat);
    image.setVolumeType(volumeType);
    resultMap.put(new VmTemplate(), Arrays.asList(image));
    result.setReturnValue(resultMap);
    result.setSucceeded(true);
    when(command.getBackend().runInternalQuery(eq(VdcQueryType.GetTemplatesFromExportDomain), any(VdcQueryParametersBase.class), any(EngineContext.class))).thenReturn(result);
}
#end_block

#method_before
private void changeRawToCowIfSparseOnBlockDevice(StorageType storageType, DiskImage image) {
    if (storageType.isBlockDomain() && image.getVolumeFormat() == VolumeFormat.RAW && image.getVolumeType() == VolumeType.Sparse) {
        image.setVolumeFormat(VolumeFormat.COW);
    }
}
#method_after
private void changeRawToCowIfSparseOnBlockDevice(StorageType storageType, DiskImage image) {
    if (storageType.isBlockDomain() && image.getVolumeFormat() == VolumeFormat.RAW && image.getVolumeType() == VolumeType.Sparse) {
        image.setvolumeFormat(VolumeFormat.COW);
    }
}
#end_block

#method_before
protected boolean validateImages(Map<Guid, StorageDomain> domainsMap) {
    List<String> validationMessages = getReturnValue().getValidationMessages();
    // Iterate over all the VM images (active image and snapshots)
    for (DiskImage image : getImages()) {
        if (Guid.Empty.equals(image.getVmSnapshotId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
        }
        if (getParameters().getCopyCollapse()) {
            // a match with the image from the VM.
            for (DiskImage p : imageList) {
                // only if requested by the user
                if (p.getImageId().equals(image.getImageId())) {
                    if (p.getVolumeFormat() != null) {
                        image.setVolumeFormat(p.getVolumeFormat());
                    }
                    if (p.getVolumeType() != null) {
                        image.setVolumeType(p.getVolumeType());
                    }
                    // Validate the configuration of the image got from the parameters.
                    if (!validateImageConfig(validationMessages, domainsMap, image)) {
                        return false;
                    }
                    break;
                }
            }
        }
        image.setStoragePoolId(getParameters().getStoragePoolId());
        // we put the source domain id in order that copy will
        // work properly.
        // we fix it to DestDomainId in
        // MoveOrCopyAllImageGroups();
        image.setStorageIds(new ArrayList<>(Arrays.asList(getSourceDomainId(image))));
    }
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
        Guid id = entry.getKey();
        List<DiskImage> diskList = entry.getValue();
        getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
    }
    return true;
}
#method_after
protected boolean validateImages(Map<Guid, StorageDomain> domainsMap) {
    List<String> validationMessages = getReturnValue().getValidationMessages();
    // Iterate over all the VM images (active image and snapshots)
    for (DiskImage image : getImages()) {
        if (Guid.Empty.equals(image.getVmSnapshotId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
        }
        if (getParameters().getCopyCollapse()) {
            // a match with the image from the VM.
            for (DiskImage p : imageList) {
                // only if requested by the user
                if (p.getImageId().equals(image.getImageId())) {
                    if (p.getVolumeFormat() != null) {
                        image.setvolumeFormat(p.getVolumeFormat());
                    }
                    if (p.getVolumeType() != null) {
                        image.setVolumeType(p.getVolumeType());
                    }
                    // Validate the configuration of the image got from the parameters.
                    if (!validateImageConfig(validationMessages, domainsMap, image)) {
                        return false;
                    }
                    break;
                }
            }
        }
        image.setStoragePoolId(getParameters().getStoragePoolId());
        // we put the source domain id in order that copy will
        // work properly.
        // we fix it to DestDomainId in
        // MoveOrCopyAllImageGroups();
        image.setStorageIds(new ArrayList<>(Arrays.asList(getSourceDomainId(image))));
    }
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
        Guid id = entry.getKey();
        List<DiskImage> diskList = entry.getValue();
        getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
    }
    return true;
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    if (isCopyCollapseOrNoSnapshots()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setVolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskVmElement(disk.getId(), getVmId(), disk.getDiskVmElementForVm(getParameters().getVmId()));
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    if (isCopyCollapseOrNoSnapshots()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
@Override
protected void onFetchVms() {
    logBuilder = new StringBuilder(String.format("Poll %s:", vdsManager.getVdsId()));
    super.onFetchVms();
    logBuilder.append(String.format("(%d VMs)", vmsCounter));
    log.info(logBuilder.toString());
}
#method_after
@Override
protected void onFetchVms() {
    logBuilder = new StringBuilder(String.format("Poll %s:", vdsManager.getVdsId()));
    super.onFetchVms();
    logBuilder.append(String.format("(%d VMs)", changedVms.size()));
    log.info(logBuilder.toString());
}
#end_block

#method_before
@Override
protected void gatherChangedVms(VM dbVm, VmInternalData vdsmVm) {
    changedVms.add(new Pair<>(dbVm, vdsmVm));
    logBuilder.append(String.format(" %s:%s", vdsmVm.getVmDynamic().getId().toString().substring(0, 8), vdsmVm.getVmDynamic().getStatus()));
    ++vmsCounter;
}
#method_after
@Override
protected void gatherChangedVms(VM dbVm, VmInternalData vdsmVm) {
    changedVms.add(new Pair<>(dbVm, vdsmVm));
    logBuilder.append(String.format(" %s:%s", vdsmVm.getVmDynamic().getId().toString().substring(0, 8), vdsmVm.getVmDynamic().getStatus()));
}
#end_block

#method_before
public ValidationResult verifyDisks(Iterable<DiskImage> imageList, Map<Guid, Guid> imageToDestinationDomainMap) {
    if (!params.isImportAsNewEntity() && !params.isImagesExistOnTargetStorageDomain()) {
        return new DiskImagesValidator(imageList).diskImagesOnStorage(imageToDestinationDomainMap);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult verifyDisks(Iterable<DiskImage> imageList, Map<Guid, Guid> imageToDestinationDomainMap) {
    if (!params.isImportAsNewEntity() && !params.isImagesExistOnTargetStorageDomain()) {
        return checkIfDisksExist(imageList, imageToDestinationDomainMap);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateMacAddress(List<? extends VmNic> vmNics, MacPool macPool) {
    int freeMacs = 0;
    for (VmNic iface : vmNics) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID, String.format("$IfaceName %1$s", iface.getName()), String.format("$MacAddress %1$s", iface.getMacAddress()));
            }
        } else {
            freeMacs++;
        }
    }
    if (freeMacs > 0 && !(macPool.getAvailableMacsCount() >= freeMacs)) {
        return new ValidationResult(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateMacAddress(List<? extends VmNic> vmNics, MacPoolManagerStrategy macPool) {
    int freeMacs = 0;
    for (VmNic iface : vmNics) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID, String.format("$IfaceName %1$s", iface.getName()), String.format("$MacAddress %1$s", iface.getMacAddress()));
            }
        } else {
            freeMacs++;
        }
    }
    if (freeMacs > 0 && !(macPool.getAvailableMacsCount() >= freeMacs)) {
        return new ValidationResult(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = org.ovirt.engine.api.model.Cluster.class)
public static org.ovirt.engine.api.model.Cluster map(Cluster entity, org.ovirt.engine.api.model.Cluster template) {
    org.ovirt.engine.api.model.Cluster model = template != null ? template : new org.ovirt.engine.api.model.Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        Cpu cpu = new Cpu();
        cpu.setType(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    Guid clusterPolicyId = entity.getClusterPolicyId();
    if (clusterPolicyId != null) {
        SchedulingPolicy schedulingPolicy = model.getSchedulingPolicy();
        if (schedulingPolicy == null) {
            schedulingPolicy = new SchedulingPolicy();
            model.setSchedulingPolicy(schedulingPolicy);
        }
        schedulingPolicy.setId(clusterPolicyId.toString());
    }
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    Ksm ksm = model.getKsm();
    if (ksm == null) {
        ksm = new Ksm();
        model.setKsm(ksm);
    }
    ksm.setEnabled(entity.isEnableKsm());
    ksm.setMergeAcrossNodes(entity.isKsmMergeAcrossNumaNodes());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(new org.ovirt.engine.api.model.Cluster.RequiredRngSourcesList());
        model.getRequiredRngSources().getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources()));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    if (entity.getMacPoolId() != null) {
        model.setMacPool(new MacPool());
        model.getMacPool().setId(entity.getMacPoolId().toString());
    }
    return model;
}
#method_after
@Mapping(from = Cluster.class, to = org.ovirt.engine.api.model.Cluster.class)
public static org.ovirt.engine.api.model.Cluster map(Cluster entity, org.ovirt.engine.api.model.Cluster template) {
    org.ovirt.engine.api.model.Cluster model = template != null ? template : new org.ovirt.engine.api.model.Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        Cpu cpu = new Cpu();
        cpu.setType(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    Guid clusterPolicyId = entity.getClusterPolicyId();
    if (clusterPolicyId != null) {
        SchedulingPolicy schedulingPolicy = model.getSchedulingPolicy();
        if (schedulingPolicy == null) {
            schedulingPolicy = new SchedulingPolicy();
            model.setSchedulingPolicy(schedulingPolicy);
        }
        schedulingPolicy.setId(clusterPolicyId.toString());
    }
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    Ksm ksm = model.getKsm();
    if (ksm == null) {
        ksm = new Ksm();
        model.setKsm(ksm);
    }
    ksm.setEnabled(entity.isEnableKsm());
    ksm.setMergeAcrossNodes(entity.isKsmMergeAcrossNumaNodes());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(new org.ovirt.engine.api.model.Cluster.RequiredRngSourcesList());
        model.getRequiredRngSources().getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources()));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    if (entity.getMacPoolId() != null) {
        MacPool macPool = model.getMacPool();
        if (macPool == null) {
            macPool = new MacPool();
            model.setMacPool(macPool);
        }
        macPool.setId(entity.getMacPoolId().toString());
    }
    return model;
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VDSGroup, ClusterListModel<Void>> getClusterListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<MultipleHostsPopupPresenterWidget> addMultipleHostsPopupProvider, final Provider<SharedMacPoolPopupPresenterWidget> macPoolPopupProvider, final Provider<ClusterListModel<Void>> clusterProvider, final Provider<CommonModel> commonModelProvider, final Provider<ClusterWarningsPopupPresenterWidget> clusterWarningsPopupProvider) {
    MainTabModelProvider<VDSGroup, ClusterListModel<Void>> result = new MainTabModelProvider<VDSGroup, ClusterListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMacPoolCommand()) {
                return macPoolPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMultipleHostsCommand()) {
                return addMultipleHostsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResetEmulatedMachineCommand()) {
                return defaultConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof ClusterWarningsModel) {
                return clusterWarningsPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(clusterProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<Cluster, ClusterListModel<Void>> getClusterListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<MultipleHostsPopupPresenterWidget> addMultipleHostsPopupProvider, final Provider<SharedMacPoolPopupPresenterWidget> macPoolPopupProvider, final Provider<ClusterListModel<Void>> clusterProvider, final Provider<CommonModel> commonModelProvider, final Provider<ClusterWarningsPopupPresenterWidget> clusterWarningsPopupProvider) {
    MainTabModelProvider<Cluster, ClusterListModel<Void>> result = new MainTabModelProvider<Cluster, ClusterListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMacPoolCommand()) {
                return macPoolPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMultipleHostsCommand()) {
                return addMultipleHostsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResetEmulatedMachineCommand()) {
                return defaultConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof ClusterWarningsModel) {
                return clusterWarningsPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(clusterProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(new TypeLiteral<ClusterListModel<Void>>() {
    }).in(Singleton.class);
    bind(ClusterGeneralModel.class).in(Singleton.class);
    bind(ClusterHostListModel.class).in(Singleton.class);
    bind(ClusterNetworkListModel.class).in(Singleton.class);
    bind(ClusterVmListModel.class).in(Singleton.class);
    bind(ClusterServiceModel.class).in(Singleton.class);
    bind(ClusterGlusterHookListModel.class).in(Singleton.class);
    bind(ClusterAffinityGroupListModel.class).in(Singleton.class);
    bind(CpuProfileListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VDSGroup>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<CpuProfile>>() {
    }).in(Singleton.class);
    bind(ClusterMainTabSelectedItems.class).asEagerSingleton();
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<ClusterListModel<Void>, ClusterServiceModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ClusterListModel<Void>, ClusterServiceModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VDS, ClusterListModel<Void>, ClusterHostListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VDS, ClusterListModel<Void>, ClusterHostListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VM, ClusterListModel<Void>, ClusterVmListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VM, ClusterListModel<Void>, ClusterVmListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, ClusterListModel<Void>, PermissionListModel<VDSGroup>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VDSGroup, ClusterListModel<Void>>>() {
    }).in(Singleton.class);
    // Cpu Profile permission list model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, CpuProfileListModel, PermissionListModel<CpuProfile>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<CpuProfile, CpuProfileListModel>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<ClusterListModel<Void>>() {
    }).in(Singleton.class);
    bind(ClusterGeneralModel.class).in(Singleton.class);
    bind(ClusterHostListModel.class).in(Singleton.class);
    bind(ClusterNetworkListModel.class).in(Singleton.class);
    bind(ClusterVmListModel.class).in(Singleton.class);
    bind(ClusterServiceModel.class).in(Singleton.class);
    bind(ClusterGlusterHookListModel.class).in(Singleton.class);
    bind(ClusterAffinityGroupListModel.class).in(Singleton.class);
    bind(CpuProfileListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<Cluster>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<CpuProfile>>() {
    }).in(Singleton.class);
    bind(ClusterMainTabSelectedItems.class).asEagerSingleton();
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<ClusterListModel<Void>, ClusterServiceModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ClusterListModel<Void>, ClusterServiceModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VDS, ClusterListModel<Void>, ClusterHostListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VDS, ClusterListModel<Void>, ClusterHostListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VM, ClusterListModel<Void>, ClusterVmListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VM, ClusterListModel<Void>, ClusterVmListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, ClusterListModel<Void>, PermissionListModel<Cluster>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<Cluster, ClusterListModel<Void>>>() {
    }).in(Singleton.class);
    // Cpu Profile permission list model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, CpuProfileListModel, PermissionListModel<CpuProfile>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<CpuProfile, CpuProfileListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(DataCenterListModel.class).in(Singleton.class);
    bind(DataCenterClusterListModel.class).in(Singleton.class);
    bind(DataCenterNetworkListModel.class).in(Singleton.class);
    bind(DataCenterStorageListModel.class).in(Singleton.class);
    bind(DataCenterQuotaListModel.class).in(Singleton.class);
    bind(DataCenterNetworkQoSListModel.class).in(Singleton.class);
    bind(DataCenterHostNetworkQosListModel.class).in(Singleton.class);
    bind(DataCenterEventListModel.class).in(Singleton.class);
    bind(DataCenterIscsiBondListModel.class).in(Singleton.class);
    bind(DataCenterStorageQosListModel.class).in(Singleton.class);
    bind(DataCenterCpuQosListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<StoragePool>>() {
    }).in(Singleton.class);
    bind(DataCenterMainTabSelectedItems.class).asEagerSingleton();
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VDSGroup, DataCenterListModel, DataCenterClusterListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VDSGroup, DataCenterListModel, DataCenterClusterListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, DataCenterListModel, PermissionListModel<StoragePool>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<StoragePool, DataCenterListModel>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(DataCenterListModel.class).in(Singleton.class);
    bind(DataCenterClusterListModel.class).in(Singleton.class);
    bind(DataCenterNetworkListModel.class).in(Singleton.class);
    bind(DataCenterStorageListModel.class).in(Singleton.class);
    bind(DataCenterQuotaListModel.class).in(Singleton.class);
    bind(DataCenterNetworkQoSListModel.class).in(Singleton.class);
    bind(DataCenterHostNetworkQosListModel.class).in(Singleton.class);
    bind(DataCenterEventListModel.class).in(Singleton.class);
    bind(DataCenterIscsiBondListModel.class).in(Singleton.class);
    bind(DataCenterStorageQosListModel.class).in(Singleton.class);
    bind(DataCenterCpuQosListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<StoragePool>>() {
    }).in(Singleton.class);
    bind(DataCenterMainTabSelectedItems.class).asEagerSingleton();
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<Cluster, DataCenterListModel, DataCenterClusterListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<Cluster, DataCenterListModel, DataCenterClusterListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, DataCenterListModel, PermissionListModel<StoragePool>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<StoragePool, DataCenterListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Override
public void setEntity(VDSGroup value) {
    super.setEntity(value);
    initSelectedMacPool();
}
#method_after
@Override
public void setEntity(Cluster value) {
    super.setEntity(value);
    initSelectedMacPool();
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getDescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getFencingEnabledModel().setEntity(getEntity().getFencingPolicy().isFencingEnabled());
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfConnectivityBroken());
    getHostsWithBrokenConnectivityThreshold().setSelectedItem(getEntity().getFencingPolicy().getHostsWithBrokenConnectivityThreshold());
    setMemoryOverCommit(getEntity().getMaxVdsMemoryOverCommit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            final Guid dataCenterId = clusterModel.getEntity().getStoragePoolId();
            for (StoragePool dataCenter : dataCenters) {
                if (dataCenterId != null && dataCenter.getId().equals(dataCenterId)) {
                    clusterModel.getDataCenter().setSelectedItem(dataCenter);
                    break;
                }
            }
            final StoragePool selectedDataCenter = clusterModel.getDataCenter().getSelectedItem();
            clusterModel.getDataCenter().setIsChangeable(selectedDataCenter == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
            if (!clusterModel.getManagementNetwork().getIsChangable()) {
                loadCurrentClusterManagementNetwork();
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
    // inactive KsmPolicyForNuma if KSM disabled
    if (getEnableKsm().getEntity() == false)
        getKsmPolicyForNumaSelection().setIsChangeable(false);
    // hide KsmPolicyForNuma is cluseter version bellow 3.4
    Version version = getEntity().getCompatibilityVersion();
    if (version.compareTo(Version.v3_4) < 0)
        getKsmPolicyForNumaSelection().setIsAvailable(false);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getDescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getFencingEnabledModel().setEntity(getEntity().getFencingPolicy().isFencingEnabled());
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfConnectivityBroken());
    getHostsWithBrokenConnectivityThreshold().setSelectedItem(getEntity().getFencingPolicy().getHostsWithBrokenConnectivityThreshold());
    setMemoryOverCommit(getEntity().getMaxVdsMemoryOverCommit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            final Guid dataCenterId = clusterModel.getEntity().getStoragePoolId();
            for (StoragePool dataCenter : dataCenters) {
                if (dataCenterId != null && dataCenter.getId().equals(dataCenterId)) {
                    clusterModel.getDataCenter().setSelectedItem(dataCenter);
                    break;
                }
            }
            final StoragePool selectedDataCenter = clusterModel.getDataCenter().getSelectedItem();
            clusterModel.getDataCenter().setIsChangeable(selectedDataCenter == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
            if (!clusterModel.getManagementNetwork().getIsChangable()) {
                loadCurrentClusterManagementNetwork();
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
    // inactive KsmPolicyForNuma if KSM disabled
    if (getEnableKsm().getEntity() == false) {
        getKsmPolicyForNumaSelection().setIsChangeable(false);
    }
    // hide KsmPolicyForNuma is cluseter version bellow 3.4
    Version version = getEntity().getCompatibilityVersion();
    if (version.compareTo(Version.v3_4) < 0) {
        getKsmPolicyForNumaSelection().setIsAvailable(false);
    }
}
#end_block

#method_before
private void handleEntityChangedEventDefinition(EntityModel senderEntityModel) {
    if (senderEntityModel == getSpiceProxyEnabled()) {
        getSpiceProxy().setIsChangeable(getSpiceProxyEnabled().getEntity());
    } else {
        if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
private void handleEntityChangedEventDefinition(EntityModel senderEntityModel) {
    if (senderEntityModel == getSpiceProxyEnabled()) {
        getSpiceProxy().setIsChangeable(getSpiceProxyEnabled().getEntity());
    } else if ((Boolean) senderEntityModel.getEntity()) {
        if (senderEntityModel == getOptimizationNone_IsSelected()) {
            getOptimizationForServer_IsSelected().setEntity(false);
            getOptimizationForDesktop_IsSelected().setEntity(false);
            getOptimizationCustom_IsSelected().setEntity(false);
        } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
            getOptimizationNone_IsSelected().setEntity(false);
            getOptimizationForDesktop_IsSelected().setEntity(false);
            getOptimizationCustom_IsSelected().setEntity(false);
        } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
            getOptimizationNone_IsSelected().setEntity(false);
            getOptimizationForServer_IsSelected().setEntity(false);
            getOptimizationCustom_IsSelected().setEntity(false);
        } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
            getOptimizationNone_IsSelected().setEntity(false);
            getOptimizationForServer_IsSelected().setEntity(false);
            getOptimizationForDesktop_IsSelected().setEntity(false);
        } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
            getMigrateOnErrorOption_NO().setEntity(false);
            getMigrateOnErrorOption_HA_ONLY().setEntity(false);
        } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
            getMigrateOnErrorOption_YES().setEntity(false);
            getMigrateOnErrorOption_HA_ONLY().setEntity(false);
        } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
            getMigrateOnErrorOption_YES().setEntity(false);
            getMigrateOnErrorOption_NO().setEntity(false);
        } else if (senderEntityModel == getOptimizeForUtilization()) {
            getOptimizeForSpeed().setEntity(false);
        } else if (senderEntityModel == getOptimizeForSpeed()) {
            getOptimizeForUtilization().setEntity(false);
        } else if (senderEntityModel == getGuarantyResources()) {
            getAllowOverbooking().setEntity(false);
        } else if (senderEntityModel == getAllowOverbooking()) {
            getGuarantyResources().setEntity(false);
        }
    }
}
#end_block

#method_before
private void initSelectedMacPool() {
    Collection<MacPool> allMacPools = getMacPoolListModel().getItems();
    VDSGroup vdsGroup = getEntity();
    if (allMacPools != null && vdsGroup != null) {
        Guid macPoolId = vdsGroup.getMacPoolId();
        for (MacPool macPool : allMacPools) {
            if (macPool.getId().equals(macPoolId)) {
                getMacPoolListModel().setSelectedItem(macPool);
                break;
            }
        }
    }
}
#method_after
private void initSelectedMacPool() {
    Collection<MacPool> allMacPools = getMacPoolListModel().getItems();
    Cluster cluster = getEntity();
    if (allMacPools != null && cluster != null) {
        Guid macPoolId = cluster.getMacPoolId();
        for (MacPool macPool : allMacPools) {
            if (macPool.getId().equals(macPoolId)) {
                getMacPoolListModel().setSelectedItem(macPool);
                break;
            }
        }
    }
}
#end_block

#method_before
public void setKsmPolicyForNuma(Boolean ksmPolicyForNumaFlag) {
    if (ksmPolicyForNumaFlag == null)
        return;
    KsmPolicyForNuma ksmPolicyForNuma = KsmPolicyForNuma.shareAcrossNumaNodes;
    if (ksmPolicyForNumaFlag == false)
        ksmPolicyForNuma = KsmPolicyForNuma.shareInsideEachNumaNode;
    getKsmPolicyForNumaSelection().setSelectedItem(ksmPolicyForNuma);
    return;
}
#method_after
public void setKsmPolicyForNuma(Boolean ksmPolicyForNumaFlag) {
    if (ksmPolicyForNumaFlag == null) {
        return;
    }
    KsmPolicyForNuma ksmPolicyForNuma = KsmPolicyForNuma.shareAcrossNumaNodes;
    if (ksmPolicyForNumaFlag == false) {
        ksmPolicyForNuma = KsmPolicyForNuma.shareInsideEachNumaNode;
    }
    getKsmPolicyForNumaSelection().setSelectedItem(ksmPolicyForNuma);
    return;
}
#end_block

#method_before
protected Object[] getSelectedKeys() {
    if (getSelectedItems() == null) {
        return new Object[0];
    } else {
        ArrayList<Object> items = new ArrayList<>();
        for (VDSGroup vdsGroup : getSelectedItems()) {
            items.add(vdsGroup.getId());
        }
        return items.toArray(new Object[] {});
    }
}
#method_after
protected Object[] getSelectedKeys() {
    if (getSelectedItems() == null) {
        return new Object[0];
    } else {
        ArrayList<Object> items = new ArrayList<>();
        for (Cluster cluster : getSelectedItems()) {
            items.add(cluster.getId());
        }
        return items.toArray(new Object[] {});
    }
}
#end_block

#method_before
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        VDSGroup cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((VDSGroup) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        Cluster cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((Cluster) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void setDetailList(final ClusterGeneralModel clusterGeneralModel, final ClusterNetworkListModel clusterNetworkListModel, final ClusterHostListModel clusterHostListModel, final PermissionListModel<VDSGroup> permissionListModel) {
    List<HasEntity<VDSGroup>> list = new ArrayList<>();
    list.add(clusterGeneralModel);
    list.add(clusterNetworkListModel);
    list.add(clusterHostListModel);
    list.add(clusterVmListModel);
    list.add(clusterServiceModel);
    list.add(clusterGlusterHookListModel);
    list.add(cpuProfileListModel);
    list.add(permissionListModel);
    list.add(affinityGroupListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final ClusterGeneralModel clusterGeneralModel, final ClusterNetworkListModel clusterNetworkListModel, final ClusterHostListModel clusterHostListModel, final PermissionListModel<Cluster> permissionListModel) {
    List<HasEntity<Cluster>> list = new ArrayList<>();
    list.add(clusterGeneralModel);
    list.add(clusterNetworkListModel);
    list.add(clusterHostListModel);
    list.add(clusterVmListModel);
    list.add(clusterServiceModel);
    list.add(clusterGlusterHookListModel);
    list.add(cpuProfileListModel);
    list.add(permissionListModel);
    list.add(affinityGroupListModel);
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getCompatibilityVersion()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getCompatibilityVersion()));
    getAffinityGroupListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getCpuProfileListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService() && Boolean.TRUE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuQosSupported, vdsGroup.getCompatibilityVersion().getValue())));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    Cluster cluster = getSelectedItem();
    getClusterVmListModel().setIsAvailable(cluster != null && cluster.supportsVirtService());
    getClusterServiceModel().setIsAvailable(cluster != null && cluster.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(cluster.getCompatibilityVersion()));
    getClusterGlusterHookListModel().setIsAvailable(cluster != null && cluster.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(cluster.getCompatibilityVersion()));
    getAffinityGroupListModel().setIsAvailable(cluster != null && cluster.supportsVirtService());
    getCpuProfileListModel().setIsAvailable(cluster != null && cluster.supportsVirtService() && Boolean.TRUE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuQosSupported, cluster.getCompatibilityVersion().getValue())));
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.setKsmPolicyForNuma(cluster.isKsmMergeAcrossNumaNodes());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getGroupHostsAndVms().getHosts() == 0);
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    List<GlusterVolumeEntity> volumes = (List<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final Cluster cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setAddMacPoolCommand(addMacPoolCommand);
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.setKsmPolicyForNuma(cluster.isKsmMergeAcrossNumaNodes());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getGroupHostsAndVms().getHosts() == 0);
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    List<GlusterVolumeEntity> volumes = (List<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    model.setHelpTag(HelpTag.remove_cluster);
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    ArrayList<String> list = new ArrayList<>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    model.setHelpTag(HelpTag.remove_cluster);
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    ArrayList<String> list = new ArrayList<>();
    for (Cluster a : Linq.<Cluster>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void resetEmulatedMachine() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineMessage());
    model.setHelpTag(HelpTag.reset_emulated_machine_cluster);
    // $NON-NLS-1$
    model.setHashName("reset_cluster_emulated_machine");
    ArrayList<String> list = new ArrayList<>();
    for (VDSGroup vdsGroup : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(vdsGroup.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnResetClusterEmulatedMachine", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
public void resetEmulatedMachine() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineMessage());
    model.setHelpTag(HelpTag.reset_emulated_machine_cluster);
    // $NON-NLS-1$
    model.setHashName("reset_cluster_emulated_machine");
    ArrayList<String> list = new ArrayList<>();
    for (Cluster cluster : Linq.<Cluster>cast(getSelectedItems())) {
        list.add(cluster.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnResetClusterEmulatedMachine", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
public void onResetClusterEmulatedMachine() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (VDSGroup vdsGroup : getSelectedItems()) {
        ManagementNetworkOnClusterOperationParameters currentParam = new ManagementNetworkOnClusterOperationParameters((vdsGroup));
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVdsGroup, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            model.stopProgress();
            cancel();
        }
    });
}
#method_after
public void onResetClusterEmulatedMachine() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Cluster cluster : getSelectedItems()) {
        ManagementNetworkOnClusterOperationParameters currentParam = new ManagementNetworkOnClusterOperationParameters((cluster));
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.UpdateCluster, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            model.stopProgress();
            cancel();
        }
    });
}
#end_block

#method_before
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Object a : getSelectedItems()) {
        prms.add(new VdsGroupParametersBase(((VDSGroup) a).getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVdsGroup, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Object a : getSelectedItems()) {
        prms.add(new ClusterParametersBase(((Cluster) a).getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveCluster, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onSaveConfirmGenericWarnings() {
    ClusterModel model = (ClusterModel) getWindow();
    cancelConfirmation();
    VDSGroup cluster = buildCluster(model);
    AsyncDataProvider.getInstance().getClusterEditWarnings(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterEditWarnings warnings = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (!warnings.isEmpty()) {
                ClusterWarningsModel confirmWindow = new ClusterWarningsModel();
                confirmWindow.init(warnings);
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createDefaultOkUiCommand("OnSaveInternal", ClusterListModel.this));
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", ClusterListModel.this));
                setConfirmWindow(confirmWindow);
            } else {
                onSaveInternal();
            }
        }
    }), model.getClusterId(), cluster);
}
#method_after
private void onSaveConfirmGenericWarnings() {
    ClusterModel model = (ClusterModel) getWindow();
    cancelConfirmation();
    Cluster cluster = buildCluster(model);
    AsyncDataProvider.getInstance().getClusterEditWarnings(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterEditWarnings warnings = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (!warnings.isEmpty()) {
                ClusterWarningsModel confirmWindow = new ClusterWarningsModel();
                confirmWindow.init(warnings);
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createDefaultOkUiCommand("OnSaveInternal", ClusterListModel.this));
                // $NON-NLS-1$
                confirmWindow.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", ClusterListModel.this));
                setConfirmWindow(confirmWindow);
            } else {
                onSaveInternal();
            }
        }
    }), model.getClusterId(), cluster);
}
#end_block

#method_before
private VDSGroup buildCluster(ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    return cluster;
}
#method_after
private Cluster buildCluster(ClusterModel model) {
    Cluster cluster = model.getIsNew() ? new Cluster() : (Cluster) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    cluster.setMacPoolId(model.getMacPoolListModel().getSelectedItem().getId());
    return cluster;
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = buildCluster(model);
    model.startProgress();
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    Cluster cluster = buildCluster(model);
    model.startProgress();
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddCluster : VdcActionType.UpdateCluster;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllValidatePassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllValidatePassed = isAllValidatePassed && returnValueBase.isValid();
                if (!isAllValidatePassed) {
                    break;
                }
            }
            if (isAllValidatePassed) {
                cancel();
            }
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setClusterId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllValidatePassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllValidatePassed = isAllValidatePassed && returnValueBase.isValid();
                if (!isAllValidatePassed) {
                    break;
                }
            }
            if (isAllValidatePassed) {
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
@Override
protected void itemsCollectionChanged(Object sender, NotifyCollectionChangedEventArgs e) {
    super.itemsCollectionChanged(sender, e);
    // Try to select an item corresponding to the system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        VDSGroup cluster = (VDSGroup) getSystemTreeSelectedItem().getEntity();
        setSelectedItem(Linq.firstOrNull(Linq.<VDSGroup>cast(getItems()), new Linq.IdPredicate<>(cluster.getId())));
    }
}
#method_after
@Override
protected void itemsCollectionChanged(Object sender, NotifyCollectionChangedEventArgs e) {
    super.itemsCollectionChanged(sender, e);
    // Try to select an item corresponding to the system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        Cluster cluster = (Cluster) getSystemTreeSelectedItem().getEntity();
        setSelectedItem(Linq.firstOrNull(Linq.<Cluster>cast(getItems()), new Linq.IdPredicate<>(cluster.getId())));
    }
}
#end_block

#method_before
@Before
public void setUp() {
    super.setUp();
    vmBuilder.id(VM1_GUID).cluster(clusterBuilder.reset().persist()).persist();
}
#method_after
@Before
public void setUp() {
    vmBuilder.id(VM1_GUID).cluster(clusterBuilder.reset().persist()).persist();
}
#end_block

#method_before
private VmStatic importHostedEngineVM(Map vmStruct) {
    VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
    if (vm != null) {
        vm.setImages(VdsBrokerObjectsBuilder.buildDiskImagesFromDevices(vmStruct));
        vm.setInterfaces(VdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct));
        for (DiskImage diskImage : vm.getImages()) {
            vm.getDiskMap().put(Guid.newGuid(), diskImage);
        }
        vm.setVdsGroupId(getVdsManager().getVdsGroupId());
        vm.setRunOnVds(getVdsManager().getVdsId());
        getVdsEventListener().importHostedEngineVm(vm);
        return vm.getStaticData();
    }
    return null;
}
#method_after
protected void importHostedEngineVM(Map vmStruct) {
    VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
    if (vm != null) {
        vm.setImages(VdsBrokerObjectsBuilder.buildDiskImagesFromDevices(vmStruct));
        vm.setInterfaces(VdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct));
        for (DiskImage diskImage : vm.getImages()) {
            vm.getDiskMap().put(Guid.newGuid(), diskImage);
        }
        vm.setVdsGroupId(getVdsManager().getVdsGroupId());
        vm.setRunOnVds(getVdsManager().getVdsId());
        // Search for spice or vnc devices and add the result as a managed device to the VM
        for (Object o : (Object[]) vmStruct.get(VdsProperties.Devices)) {
            Map device = (Map<String, Object>) o;
            String deviceName = (String) device.get(VdsProperties.Device);
            if (graphicsDevices.contains(deviceName)) {
                GraphicsDevice graphicsDevice = new GraphicsDevice(VmDeviceType.valueOf(deviceName.toUpperCase()));
                graphicsDevice.setVmId(vm.getId());
                graphicsDevice.setDeviceId(Guid.newGuid());
                vm.setSingleQxlPci(false);
                if (graphicsDevice.getGraphicsType() == GraphicsType.VNC) {
                    vm.setDefaultDisplayType(DisplayType.cirrus);
                } else {
                    vm.setDefaultDisplayType(DisplayType.qxl);
                }
                vm.getManagedVmDeviceMap().put(graphicsDevice.getDeviceId(), graphicsDevice);
                break;
            }
        }
        getVdsEventListener().importHostedEngineVm(vm);
    }
}
#end_block

#method_before
protected VmStatic convertVm(int defaultOsId, DisplayType defaultDisplayType, Map vmInfo) {
    Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(vmId);
    vmStatic.setCreationDate(new Date());
    vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
    String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
    if (StringUtils.equals(Config.<String>getValue(ConfigValues.HostedEngineVmName), vmNameOnHost)) {
        // its a hosted engine VM -> import it and skip the external VM phase
        return importHostedEngineVM(vmInfo);
    } else {
        vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
        vmStatic.setOrigin(OriginType.EXTERNAL);
    }
    vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
    vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
    vmStatic.setSingleQxlPci(false);
    setOsId(vmStatic, (String) vmInfo.get(VdsProperties.guest_os), defaultOsId);
    setDisplayType(vmStatic, (String) vmInfo.get(VdsProperties.displayType), defaultDisplayType);
    log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
    externalVmsToAdd.add(vmStatic);
    return vmStatic;
}
#method_after
protected void convertVm(int defaultOsId, DisplayType defaultDisplayType, Map vmInfo) {
    Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(vmId);
    vmStatic.setCreationDate(new Date());
    vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
    String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
    if (StringUtils.equals(Config.<String>getValue(ConfigValues.HostedEngineVmName), vmNameOnHost)) {
        // its a hosted engine VM -> import it and skip the external VM phase
        importHostedEngineVM(vmInfo);
        return;
    } else {
        vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
        vmStatic.setOrigin(OriginType.EXTERNAL);
    }
    vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
    vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
    vmStatic.setSingleQxlPci(false);
    setOsId(vmStatic, (String) vmInfo.get(VdsProperties.guest_os), defaultOsId);
    setDisplayType(vmStatic, (String) vmInfo.get(VdsProperties.displayType), defaultDisplayType);
    log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
    externalVmsToAdd.add(vmStatic);
}
#end_block

#method_before
protected void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null && !devicesWithoutAddress.contains(device.get(VdsProperties.Device))) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (vmDevice == null) {
            vmDevice = getByDeviceType((String) device.get(VdsProperties.Device), deviceMap);
            deviceId = vmDevice != null ? vmDevice.getDeviceId() : deviceId;
        }
        String logicalName = null;
        if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(getVdsManager().getGroupCompatibilityVersion()) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
            try {
                logicalName = getDeviceLogicalName((Map<?, ?>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
            } catch (Exception e) {
                log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping '{}'", vmId, device, e.getMessage());
                log.error("Exception", e);
            }
        }
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device, logicalName);
        } else {
            vmDevice.setIsPlugged(Boolean.TRUE);
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            vmDevice.setLogicalName(logicalName);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
protected void processVmDevices(Map vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDevices = new HashSet<Guid>();
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = Entities.businessEntitiesById(devices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (device.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        Guid deviceId = getDeviceId(device);
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (vmDevice == null) {
            vmDevice = getByDeviceType((String) device.get(VdsProperties.Device), deviceMap);
            deviceId = vmDevice != null ? vmDevice.getDeviceId() : deviceId;
        }
        String logicalName = null;
        if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(getVdsManager().getGroupCompatibilityVersion()) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
            try {
                logicalName = getDeviceLogicalName((Map<?, ?>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
            } catch (Exception e) {
                log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping '{}'", vmId, device, e.getMessage());
                log.error("Exception", e);
            }
        }
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device, logicalName);
        } else {
            vmDevice.setIsPlugged(Boolean.TRUE);
            vmDevice.setAddress(((Map<String, String>) device.get(VdsProperties.Address)).toString());
            vmDevice.setAlias(StringUtils.defaultString((String) device.get(VdsProperties.Alias)));
            vmDevice.setLogicalName(logicalName);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device, String logicalName) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.error("Empty or NULL values were passed for a VM '{}' device, Device is skipped", vmId);
    } else {
        String address = ObjectUtils.toString(device.get(VdsProperties.Address), "");
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null, logicalName);
        newVmDevices.add(newDevice);
        log.debug("New device was marked for adding to VM '{}' Devices : '{}'", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device, String logicalName) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.error("Empty or NULL values were passed for a VM '{}' device, Device is skipped", vmId);
    } else {
        String address = device.get(VdsProperties.Address).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null, logicalName);
        newVmDevices.add(newDevice);
        log.debug("New device was marked for adding to VM '{}' Devices : '{}'", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
@Test
public void shouldConvertExternalVm() throws IOException {
    VmStatic vmStatic = vmsMonitoring.convertVm(1, DisplayType.qxl, external_vm);
    verifyZeroInteractions(eventListener);
    assertThat(vmStatic.getNumOfSockets(), is(4));
    assertThat(vmStatic.getMemSizeMb(), is(7052));
}
#method_after
@Test
public void shouldConvertExternalVm() throws IOException {
    vmsMonitoring.convertVm(1, DisplayType.qxl, external_vm);
    VmStatic vmStatic = vmsMonitoring.getExternalVmsToAdd().get(0);
    verifyZeroInteractions(eventListener);
    assertThat(vmStatic.getNumOfSockets(), is(4));
    assertThat(vmStatic.getMemSizeMb(), is(7052));
}
#end_block

#method_before
@Test
public void shouldExtractExternalVmDevices() throws IOException {
    vmsMonitoring.processVmDevices(external_vm);
    List<VmDevice> newDevices = vmsMonitoring.getNewVmDevices();
    List<VmDeviceId> removedDevices = vmsMonitoring.getRemovedVmDevices();
    List<VmDeviceGeneralType> devices = getDeviceTypes(vmsMonitoring.getNewVmDevices());
    List<String> deviceNames = getDevice(vmsMonitoring.getNewVmDevices());
    assertThat(removedDevices.size(), is(0));
    assertThat(newDevices.size(), is(12));
    // A ballooning device model of type 'none' means that there is no such device
    assertThat(devices.contains(VmDeviceGeneralType.BALLOON), is(false));
    // TODO: Do we really not want to import devices like that?
    assertThat(devices.contains(VmDeviceGeneralType.CONSOLE), is(false));
    // Cirrus and VNC device should be there
    assertThat(deviceNames.contains(VmDeviceType.CIRRUS.name().toLowerCase()), is(true));
    assertThat(deviceNames.contains(VmDeviceType.VNC.name().toLowerCase()), is(true));
}
#method_after
@Test
public void shouldExtractExternalVmDevices() throws IOException {
    vmsMonitoring.processVmDevices(external_vm);
    List<VmDevice> newDevices = vmsMonitoring.getNewVmDevices();
    List<VmDeviceId> removedDevices = vmsMonitoring.getRemovedVmDevices();
    List<VmDeviceGeneralType> devices = getDeviceTypes(vmsMonitoring.getNewVmDevices());
    List<String> deviceNames = getDevice(vmsMonitoring.getNewVmDevices());
    assertThat(removedDevices.size(), is(0));
    assertThat(newDevices.size(), is(11));
    // A ballooning device model of type 'none' means that there is no such device
    assertThat(devices.contains(VmDeviceGeneralType.BALLOON), is(false));
    // TODO: Do we really not want to import devices like that?
    assertThat(devices.contains(VmDeviceGeneralType.CONSOLE), is(false));
    // Cirrus device should be there
    assertThat(deviceNames.contains(VmDeviceType.CIRRUS.name().toLowerCase()), is(true));
    // TODO: VNC and SPICE devices should also be imported for external VMs
    assertThat(deviceNames.contains(VmDeviceType.VNC.name().toLowerCase()), is(false));
}
#end_block

#method_before
@Test
public void shouldExtractInternalVmDevices() throws IOException {
    vmsMonitoring.processVmDevices(internal_vm);
    List<VmDevice> newDevices = vmsMonitoring.getNewVmDevices();
    List<VmDeviceId> removedDevices = vmsMonitoring.getRemovedVmDevices();
    List<VmDeviceGeneralType> deviceTypes = getDeviceTypes(vmsMonitoring.getNewVmDevices());
    List<String> deviceNames = getDevice(vmsMonitoring.getNewVmDevices());
    assertThat(removedDevices.size(), is(0));
    assertThat(newDevices.size(), is(12));
    assertThat(deviceTypes.contains(VmDeviceGeneralType.BALLOON), is(true));
    // TODO: Do we really not want to import deviceTypes like that?
    assertThat(deviceTypes.contains(VmDeviceGeneralType.CONSOLE), is(false));
    // QXL and SPICE device should be there
    assertThat(deviceNames.contains(VmDeviceType.QXL.name().toLowerCase()), is(true));
    assertThat(deviceNames.contains(VmDeviceType.SPICE.name().toLowerCase()), is(true));
}
#method_after
@Test
public void shouldExtractInternalVmDevices() throws IOException {
    vmsMonitoring.processVmDevices(internal_vm);
    List<VmDevice> newDevices = vmsMonitoring.getNewVmDevices();
    List<VmDeviceId> removedDevices = vmsMonitoring.getRemovedVmDevices();
    List<VmDeviceGeneralType> deviceTypes = getDeviceTypes(vmsMonitoring.getNewVmDevices());
    List<String> deviceNames = getDevice(vmsMonitoring.getNewVmDevices());
    assertThat(removedDevices.size(), is(0));
    assertThat(newDevices.size(), is(11));
    assertThat(deviceTypes.contains(VmDeviceGeneralType.BALLOON), is(true));
    // TODO: Do we really not want to import deviceTypes like that?
    assertThat(deviceTypes.contains(VmDeviceGeneralType.CONSOLE), is(false));
    // QXL device should be there
    assertThat(deviceNames.contains(VmDeviceType.QXL.name().toLowerCase()), is(true));
    // SPICE device details are fetched when needed, don't reimport the device
    assertThat(deviceNames.contains(VmDeviceType.SPICE.name().toLowerCase()), is(false));
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    WatchdogParameters parameters = new WatchdogParameters();
    parameters.setId(templateId);
    parameters.setVm(true);
    return performAction(VdcActionType.RemoveWatchdog, parameters);
}
#method_after
@Override
public Response remove() {
    get();
    WatchdogParameters parameters = new WatchdogParameters();
    parameters.setId(templateId);
    parameters.setVm(false);
    return performAction(VdcActionType.RemoveWatchdog, parameters);
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Watchdog model, VmWatchdog entity) {
    WatchdogParameters parameters = new WatchdogParameters();
    if (model.isSetAction()) {
        parameters.setAction(WatchdogMapper.map(model.getAction()));
    } else {
        parameters.setAction(entity.getAction());
    }
    if (model.isSetModel()) {
        parameters.setModel(WatchdogMapper.map(model.getModel()));
    } else {
        parameters.setAction(entity.getAction());
    }
    parameters.setId(instanceTypeId);
    parameters.setVm(false);
    return parameters;
}
#method_after
@Override
public VdcActionParametersBase getParameters(Watchdog model, VmWatchdog entity) {
    WatchdogParameters parameters = new WatchdogParameters();
    if (model.isSetAction()) {
        parameters.setAction(WatchdogMapper.map(model.getAction()));
    } else {
        parameters.setAction(entity.getAction());
    }
    if (model.isSetModel()) {
        parameters.setModel(WatchdogMapper.map(model.getModel()));
    } else {
        parameters.setModel(entity.getModel());
    }
    parameters.setId(instanceTypeId);
    parameters.setVm(false);
    return parameters;
}
#end_block

