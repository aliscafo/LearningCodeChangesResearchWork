271
#method_before
private Guid createTemplate() {
    VmTemplate blankTemplate = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    DiskImage templateDiskImage = getEnclosingCommand().getParameters().getDiskImage();
    // Following the same convention as the glance disk name, using a GlanceTemplate prefix, followed by a short identifier
    String vmTemplateName = "GlanceTemplate-" + Guid.newGuid().toString().substring(0, 7);
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    if (getEnclosingCommand().getParameters().getClusterId() != null) {
        masterVm.setVdsGroupId(getEnclosingCommand().getParameters().getClusterId());
    }
    VdcReturnValueBase addVmTemplateReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContexForTasks(getEnclosingCommand().getExecutionContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#method_after
private Guid createTemplate() {
    VmTemplate blankTemplate = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    VmStatic masterVm = new VmStatic(blankTemplate);
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    DiskImage templateDiskImage = getEnclosingCommand().getParameters().getDiskImage();
    // Following the same convention as the glance disk name, using a GlanceTemplate prefix, followed by a short identifier
    String vmTemplateName = "GlanceTemplate-" + Guid.newGuid().toString().substring(0, 7);
    AddVmTemplateParameters parameters = new AddVmTemplateParameters(masterVm, vmTemplateName, templateDiskImage.getDiskDescription());
    // Setting the cluster ID, and other related properties derived from it
    if (getEnclosingCommand().getParameters().getClusterId() != null) {
        masterVm.setVdsGroupId(getEnclosingCommand().getParameters().getClusterId());
        VDSGroup vdsGroup = getVdsGroup(masterVm.getVdsGroupId());
        masterVm.setOsId(osRepository.getDefaultOSes().get(vdsGroup.getArchitecture()));
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(masterVm.getOsId(), vdsGroup.getcompatibility_version()).get(0);
        masterVm.setDefaultDisplayType(defaultDisplayType);
    }
    VdcReturnValueBase addVmTemplateReturnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmTemplate, parameters, ExecutionHandler.createDefaultContexForTasks(getEnclosingCommand().getExecutionContext()));
    // No reason for this to return null, but checking just to make sure, and returning the created template, or null if failed
    return addVmTemplateReturnValue.getActionReturnValue() != null ? (Guid) addVmTemplateReturnValue.getActionReturnValue() : null;
}
#end_block

#method_before
protected void updateClusters(Guid storagePoolId) {
    INewAsyncCallback callback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ImportExportRepoImageBaseModel model = (ImportExportRepoImageBaseModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            model.getCluster().setItems(clusters);
            model.getCluster().setIsEmpty(clusters.isEmpty());
            model.updateControlsAvailability();
            stopProgress();
        }
    };
    startProgress(null);
    if (storagePoolId != null) {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback), storagePoolId);
    } else {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback));
    }
}
#method_after
protected void updateClusters(Guid storagePoolId) {
    INewAsyncCallback callback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ImportExportRepoImageBaseModel model = (ImportExportRepoImageBaseModel) target;
            List<VDSGroup> clusters = AsyncDataProvider.filterClustersWithoutArchitecture((List<VDSGroup>) returnValue);
            model.getCluster().setItems(clusters);
            model.getCluster().setIsEmpty(clusters.isEmpty());
            model.updateControlsAvailability();
            stopProgress();
        }
    };
    startProgress(null);
    if (storagePoolId != null) {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback), storagePoolId);
    } else {
        AsyncDataProvider.getClusterList(new AsyncQuery(this, callback));
    }
}
#end_block

#method_before
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    nfsDataModel.setRole(StorageDomainType.Data);
    models.add(nfsDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setRole(StorageDomainType.Data);
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    fcpDataModel.setRole(StorageDomainType.Data);
    models.add(fcpDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    posixDataModel.setRole(StorageDomainType.Data);
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    GlusterDataModel.setRole(StorageDomainType.Data);
    models.add(GlusterDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    localDataModel.setRole(StorageDomainType.Data);
    models.add(localDataModel);
    return models;
}
#method_after
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    models.add(nfsDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    models.add(GlusterDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    models.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    models.add(localDataModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.Data);
    }
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    LocalStorageModel localIsoModel = new LocalStorageModel();
    localIsoModel.setRole(StorageDomainType.ISO);
    models.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    posixIsoModel.setRole(StorageDomainType.ISO);
    models.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    nfsIsoModel.setRole(StorageDomainType.ISO);
    models.add(nfsIsoModel);
    return models;
}
#method_after
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.ISO);
    }
    return models;
}
#end_block

#method_before
@Override
public final void run() {
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "].run() called");
    if (repetitions > 0) {
        repetitions--;
    } else if (repetitions == 0) {
        cycleRate();
    }
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    "GridTimer[" + name + "] Executing! Current Rate: " + rateCycle[currentRate] + ":" + getRefreshRate() + // $NON-NLS-1$
    " Reps: " + repetitions);
    execute();
}
#method_after
@Override
public final void run() {
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "].run() called");
    if (repetitions > 0) {
        repetitions--;
    } else if (repetitions == 0) {
        cycleRate();
    }
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$
    "GridTimer[" + name + "] Executing! Current Rate: " + rateCycle[currentRate] + ":" + // $NON-NLS-1$
    getRefreshRate() + // $NON-NLS-1$
    " Reps: " + repetitions);
    execute();
}
#end_block

#method_before
public void setRefreshRate(int interval) {
    if (getRefreshRate() == interval) {
        return;
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "]: Refresh Rate set to: " + interval);
    // set the NORMAL interval
    normalInterval = interval;
    ValueChangeEvent.fire(this, getRefreshRate());
}
#method_after
public void setRefreshRate(int interval) {
    if (getRefreshRate() == interval) {
        return;
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    logger.fine("GridTimer[" + name + "]: Refresh Rate set to: " + interval);
    // set the NORMAL interval
    normalInterval = interval;
    GridTimerStateChangeEvent.fire(this, getRefreshRate());
}
#end_block

#method_before
private void cycleRate() {
    currentRate = (currentRate + 1) % rateCycle.length;
    RATE rate = rateCycle[currentRate];
    repetitions = rate.getRepetitions();
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
    "GridTimer[" + name + "] Rate Cycled: Current Rate: " + rate + " Reps: " + repetitions + " Interval: " + rate.getInterval());
    cancel();
    start();
    if (rate == RATE.NORMAL) {
        ValueChangeEvent.fire(this, getRefreshRate());
    }
}
#method_after
private void cycleRate() {
    currentRate = (currentRate + 1) % rateCycle.length;
    RATE rate = rateCycle[currentRate];
    repetitions = rate.getRepetitions();
    logger.fine(// $NON-NLS-1$ //$NON-NLS-2$
    "GridTimer[" + name + "] Rate Cycled: Current Rate: " + rate + " Reps: " + repetitions + // $NON-NLS-1$ //$NON-NLS-2$
    " Interval: " + rate.getInterval());
    cancel();
    start();
    if (rate == RATE.NORMAL) {
        GridTimerStateChangeEvent.fire(this, getRefreshRate());
    }
}
#end_block

#method_before
public final void setEventBus(EventBus eventBus) {
    if (eventBus == null) {
        unregisterHandlers();
        this.eventBus = null;
    } else if (this.eventBus == null || this.eventBus != eventBus) {
        this.eventBus = eventBus;
        registerHandlers();
    }
}
#method_after
public final void setEventBus(EventBus eventBus) {
    // $NON-NLS-1$
    assert eventBus != null : "EventBus cannot be null";
    // $NON-NLS-1$
    assert this.eventBus == null : "EventBus is already set";
    this.eventBus = eventBus;
    registerHandlers();
}
#end_block

#method_before
protected void registerHandlers() {
// No-op, sub classes override.
}
#method_after
protected void registerHandlers() {
// No-op, override as necessary
}
#end_block

#method_before
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#method_after
private void updateTimer() {
    final GridTimer modelTimer = getModelTimer();
    modelTimer.setRefreshRate(readRefreshRate());
    if (statusUpdateHandlerRegistration != null) {
        statusUpdateHandlerRegistration.removeHandler();
    }
    statusUpdateHandlerRegistration = modelTimer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            onRefresh(modelTimer.getTimerRefreshStatus());
        }
    });
    modelTimer.resume();
}
#end_block

#method_before
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    getModelTimer().setRefreshRate(readRefreshRate());
    updateTimer();
}
#method_after
public void setCurrentRefreshRate(int newRefreshRate) {
    saveRefreshRate(newRefreshRate);
    updateTimer();
}
#end_block

#method_before
public void setSearchString(String value) {
    if (!ObjectUtils.objectsEqual(searchString, value)) {
        searchString = value;
        searchStringChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SearchString"));
    }
}
#method_after
public void setSearchString(String value) {
    if (!ObjectUtils.objectsEqual(searchString, value)) {
        searchString = value;
        pagingSearchString = null;
        searchStringChanged();
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("SearchString"));
    }
}
#end_block

#method_before
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addValueChangeHandler(new ValueChangeHandler<Integer>() {

        @Override
        public void onValueChange(ValueChangeEvent<Integer> event) {
            int newInterval = event.getValue();
            if (timer.isActive()) {
                // Immediately adjust timer and restart if it was active.
                if (newInterval != timer.getRefreshRate()) {
                    timer.stop();
                    timer.setRefreshRate(newInterval);
                    timer.start();
                }
            } else {
                // Update the timer interval for inactive timers, so they are correct when they become active
                timer.setRefreshRate(newInterval);
            }
        }
    });
}
#method_after
private void addTimerChangeHandler() {
    timerChangeHandler = timer.addGridTimerStateChangeEventHandler(new GridTimerStateChangeEventHandler() {

        @Override
        public void onGridTimerStateChange(GridTimerStateChangeEvent event) {
            int newInterval = event.getRefreshRate();
            if (timer.isActive()) {
                // Immediately adjust timer and restart if it was active.
                if (newInterval != timer.getRefreshRate()) {
                    timer.stop();
                    timer.setRefreshRate(newInterval);
                    timer.start();
                }
            } else {
                // Update the timer interval for inactive timers, so they are correct when they become active
                timer.setRefreshRate(newInterval);
            }
        }
    });
}
#end_block

#method_before
protected void searchNextPage() {
    setSearchStringPage(getNextSearchPageNumber());
    getSearchCommand().execute();
}
#method_after
protected void searchNextPage() {
    searchString = stripPageKeyword(searchString);
    setSearchStringPage(getNextSearchPageNumber());
    getSearchCommand().execute();
}
#end_block

#method_before
protected void searchPreviousPage() {
    setSearchStringPage(getPreviousSearchPageNumber());
    getSearchCommand().execute();
}
#method_after
protected void searchPreviousPage() {
    searchString = stripPageKeyword(searchString);
    setSearchStringPage(getPreviousSearchPageNumber());
    getSearchCommand().execute();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.getid())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (paramConnection.getstorage_type() == StorageType.NFS && !new NfsMountPointConstraint().isValid(paramConnection.getconnection(), null)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (paramConnection.getstorage_type() == StorageType.POSIXFS && (StringUtils.isEmpty(paramConnection.getVfsType()))) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && StringUtils.isEmpty(paramConnection.getiqn())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && (StringUtils.isEmpty(paramConnection.getport()) || Integer.parseInt(paramConnection.getport()) <= 0)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
    }
    if (checkIsConnectionFieldEmpty(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    if (isConnWithSameDetailsExists(paramConnection, storagePoolId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failCanDoAction(VdcBllMessages.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failCanDoAction(VdcBllMessages.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.getid())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (paramConnection.getstorage_type() == StorageType.NFS && !new NfsMountPointConstraint().isValid(paramConnection.getconnection(), null)) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (paramConnection.getstorage_type() == StorageType.POSIXFS && (StringUtils.isEmpty(paramConnection.getVfsType()))) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && StringUtils.isEmpty(paramConnection.getiqn())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
    }
    if (paramConnection.getstorage_type() == StorageType.ISCSI && !isValidStorageConnectionPort(paramConnection.getport())) {
        return failCanDoAction(VdcBllMessages.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
    }
    if (checkIsConnectionFieldEmpty(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    if (isConnWithSameDetailsExists(paramConnection, storagePoolId)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failCanDoAction(VdcBllMessages.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failCanDoAction(VdcBllMessages.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(false);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setProviderId(getParameters().getProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
protected void initializeVds() {
    initializeVds(true);
}
#method_after
protected void initializeVds() {
    initializeVds(false);
}
#end_block

#method_before
protected void initializeVds(boolean expectHostToBeFound) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId(), expectHostToBeFound));
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddVds, new AddVdsVDSCommandParameters(getVdsId()));
}
#method_after
protected void initializeVds(boolean newHost) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId(), newHost));
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddVds, new AddVdsVDSCommandParameters(getVdsId()));
}
#end_block

#method_before
public void RemoveVds(Guid vdsId) {
    RemoveVds(vdsId, true);
}
#method_after
public void RemoveVds(Guid vdsId) {
    RemoveVds(vdsId, false);
}
#end_block

#method_before
public void RemoveVds(Guid vdsId, boolean errorIfManagerNotFound) {
    VdsManager vdsManager = GetVdsManager(vdsId, errorIfManagerNotFound);
    if (vdsManager != null) {
        vdsManager.dispose();
        vdsManagersDict.remove(vdsId);
    }
}
#method_after
public void RemoveVds(Guid vdsId, boolean newHost) {
    VdsManager vdsManager = GetVdsManager(vdsId, newHost);
    if (vdsManager != null) {
        vdsManager.dispose();
        vdsManagersDict.remove(vdsId);
    }
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId) {
    return GetVdsManager(vdsId, true);
}
#method_after
public VdsManager GetVdsManager(Guid vdsId) {
    return GetVdsManager(vdsId, false);
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId, boolean errorIfManagerNotFound) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (errorIfManagerNotFound) {
            log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        } else {
            log.infoFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        }
    }
    return vdsManger;
}
#method_after
public VdsManager GetVdsManager(Guid vdsId, boolean newHost) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (!newHost) {
            log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        }
    }
    return vdsManger;
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    ResourceManager.getInstance().RemoveVds(getVdsId(), parameters.isErrorIfHostDoesntExist());
}
#method_after
@Override
protected void executeVdsIdCommand() {
    ResourceManager.getInstance().RemoveVds(getVdsId(), parameters.isNewHost());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DirectoryEntry other = (DirectoryEntry) obj;
    return ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(status, other.status) && ObjectUtils.objectsEqual(directoryName, other.directoryName);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DirectoryEntry other = (DirectoryEntry) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(status, other.status) && ObjectUtils.objectsEqual(directoryName, other.directoryName));
}
#end_block

#method_before
public static AuthenticationProfileRepository getInstance() {
    return instance;
}
#method_after
public static AuthenticationProfileRepository getInstance() {
    if (instance == null) {
        synchronized (AuthenticationProfileRepository.class) {
            if (instance == null) {
                instance = new AuthenticationProfileRepository();
            }
        }
    }
    return instance;
}
#end_block

#method_before
public void registerProfile(String name, AuthenticationProfile profile) {
    profiles.put(name, profile);
}
#method_after
public void registerProfile(AuthenticationProfile profile) {
    profiles.put(profile.getName(), profile);
}
#end_block

#method_before
public Authenticator create(Configuration config) throws ConfigurationException {
    String profileName = config.getString(PROFILE_NAME_KEY);
    Authenticator authenticator = createImpl(profileName, config);
    return authenticator;
}
#method_after
public Authenticator create(Configuration config) throws ConfigurationException {
    return createImpl(config.getString(PROFILE_NAME_KEY), config);
}
#end_block

#method_before
public VM getVmFromConfiguration(String configuration, Guid vmId, Guid snapshotId) {
    VM vm;
    if (configuration != null) {
        vm = getVmWithConfiguration(configuration, vmId);
        Snapshot snapshot = getSnapshotDao().get(snapshotId);
        if (snapshot != null && snapshot.getType() != Snapshot.SnapshotType.PREVIEW) {
            // No need to mark disks of 'PREVIEW' snapshot as illegal
            // as it represents previous 'Active VM' state.
            markImagesIllegalIfNotInDb(vm, snapshotId);
        }
    } else {
        vm = getVmWithoutConfiguration(vmId, snapshotId);
    }
    VmHandler.updateDisksForVm(vm, vm.getImages());
    return vm;
}
#method_after
public VM getVmFromConfiguration(String configuration, Guid vmId, Guid snapshotId) {
    VM vm;
    if (configuration != null) {
        vm = getVmWithConfiguration(configuration, vmId);
        Snapshot snapshot = getSnapshotDao().get(snapshotId);
        if (snapshot != null && snapshot.getType() != Snapshot.SnapshotType.PREVIEW) {
            // No need to mark disks of 'PREVIEW' snapshot as illegal
            // as it represents previous 'Active VM' state and no operations
            // on disks can be done while previewing a snapshot.
            markImagesIllegalIfNotInDb(vm, snapshotId);
        }
    } else {
        vm = getVmWithoutConfiguration(vmId, snapshotId);
    }
    VmHandler.updateDisksForVm(vm, vm.getImages());
    return vm;
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        Version version = getDbFacade().getVdsDao().get(getParameters().getVdsId()).getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (FeatureSupported.defaultRoute(version) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway()))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        Version version = getDbFacade().getVdsDao().get(getParameters().getVdsId()).getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (FeatureSupported.defaultRoute(version) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
public static boolean supportedInConfig(ConfigValues feature, Version version) {
    return Config.<Boolean>getValue(feature, version.getValue());
}
#method_after
public static boolean supportedInConfig(ConfigValues feature, Version version, ArchitectureType arch) {
    return Boolean.parseBoolean(((Map<String, String>) Config.<Map>getValue(feature, version.getValue())).get(arch.name()));
}
#end_block

#method_before
public static boolean antiMacSpoofing(Version version) {
    return supportedInConfig(ConfigValues.EnableMACAntiSpoofingFilterRules, version);
}
#method_after
public static boolean antiMacSpoofing(Version version) {
    return supportedInConfig(ConfigValues.MacAntiSpoofingFilterRulesSupported, version);
}
#end_block

#method_before
@Override
public IsoListReturnForXmlRpc getIsoList(String spUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getIsoList(spUUID);
        IsoListReturnForXmlRpc wrapper = new IsoListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public FileStatsReturnForXmlRpc getIsoList(String spUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getIsoList(spUUID);
        FileStatsReturnForXmlRpc wrapper = new FileStatsReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.isHostedEngine()) {
                            // The Hosted Engine vm is migrated by the HA agent
                            continue;
                        }
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Unassigned));
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ActivateVds, new ActivateVdsVDSCommandParameters(getVdsId()));
        setSucceeded(returnValue.getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDAO().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        }
    }
    logMonitorLockReleased("Activate");
}
#method_after
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Unassigned));
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ActivateVds, new ActivateVdsVDSCommandParameters(getVdsId()));
        setSucceeded(returnValue.getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDAO().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        } else {
            // We didn't manage to activate host. Set its status to Error
            runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Error));
        }
    }
    logMonitorLockReleased("Activate");
}
#end_block

#method_before
public HaMaintenanceMode getMode() {
    return this.mode;
}
#method_after
public HaMaintenanceMode getMode() {
    return mode;
}
#end_block

#method_before
public boolean getIsEnabled() {
    return this.enabled;
}
#method_after
public boolean getIsEnabled() {
    return enabled;
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_MANUAL_HA_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private void assignTags() {
    if (getWindow() != null) {
        return;
    }
    TagListModel model = new TagListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignTagsTitle());
    // $NON-NLS-1$
    model.setHashName("assign_tags_vms");
    getAttachedTagsToSelectedVMs(model);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAssignTags", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void assignTags() {
    if (getWindow() != null) {
        return;
    }
    TagListModel model = new TagListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignTagsTitle());
    model.setHelpTag(HelpTag.assign_tags_vms);
    // $NON-NLS-1$
    model.setHashName("assign_tags_vms");
    getAttachedTagsToSelectedVMs(model);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAssignTags", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    model.setHelpTag(HelpTag.editConsole);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    window.setHelpTag(HelpTag.remove_virtual_machine);
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameter.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!(Boolean) model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnExportNoTemplates", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("CancelConfirmation", this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameter.setCopyCollapse((Boolean) model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!(Boolean) model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnExportNoTemplates", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("CancelConfirmation", this);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void newTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#method_after
private void newTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    model.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#method_after
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    // $NON-NLS-1$
    model.setHashName(actionName + "_virtual_machine");
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(// $NON-NLS-1$
    "Shutdown", constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#method_after
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(SHUTDOWN, constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(// $NON-NLS-1$
    "Stop", constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#method_after
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(STOP, constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(// $NON-NLS-1$
    "Reboot", constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#method_after
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void setGlobalHaMaintenance(boolean enabled) {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (!vm.isHostedEngine()) {
        return;
    }
    SetHaMaintenanceParameters params = new SetHaMaintenanceParameters(vm.getRunOnVds(), HaMaintenanceMode.GLOBAL, enabled);
    Frontend.getInstance().runAction(VdcActionType.SetHaMaintenance, params, null, this);
}
#method_after
private void setGlobalHaMaintenance(boolean enabled) {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (!vm.isHostedEngine()) {
        return;
    }
    SetHaMaintenanceParameters params = new SetHaMaintenanceParameters(vm.getRunOnVds(), HaMaintenanceMode.GLOBAL, enabled);
    Frontend.getInstance().runAction(VdcActionType.SetHaMaintenance, params);
}
#end_block

#method_before
private void updateHaMaintenanceAvailability(List items) {
    if (items == null || items.size() != 1) {
        setHaMaintenanceAvailability(false);
        return;
    }
    VM vm = (VM) getSelectedItem();
    if (vm == null || !vm.isHostedEngine() || vm.getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        setHaMaintenanceAvailability(false);
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(vm.getRunOnVds()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response == null || !response.getSucceeded() || response.getReturnValue() == null) {
                setHaMaintenanceAvailability(false);
            } else {
                VDS vds = response.getReturnValue();
                setHaMaintenanceAvailability(vds.getHighlyAvailableIsConfigured());
            }
        }
    }, true));
}
#method_after
private void updateHaMaintenanceAvailability(List items) {
    if (items == null || items.size() != 1) {
        setHaMaintenanceAvailability(false);
        return;
    }
    VM vm = (VM) getSelectedItem();
    if (vm == null || !vm.isHostedEngine() || vm.getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        setHaMaintenanceAvailability(false);
    } else {
        setHaMaintenanceAvailability(true);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean succeeded = false;
    SetHaMaintenanceParameters params = (SetHaMaintenanceParameters) getParameters();
    try {
        succeeded = runVdsCommand(VDSCommandType.SetHaMaintenanceMode, new SetHaMaintenanceModeVDSCommandParameters(getVds(), params.getMode(), params.getIsEnabled())).getSucceeded();
    } catch (VdcBLLException e) {
        log.errorFormat("Could not {0} {1} Hosted Engine HA maintenance mode on host {2}", (params.getIsEnabled() ? "enable" : "disable"), params.getMode().name().toLowerCase(), getVdsName());
    }
    getReturnValue().setSucceeded(succeeded);
}
#method_after
@Override
protected void executeCommand() {
    boolean succeeded = false;
    SetHaMaintenanceParameters params = getParameters();
    try {
        succeeded = runVdsCommand(VDSCommandType.SetHaMaintenanceMode, new SetHaMaintenanceModeVDSCommandParameters(getVds(), params.getMode(), params.getIsEnabled())).getSucceeded();
    } catch (VdcBLLException e) {
        log.errorFormat("Could not {0} {1} Hosted Engine HA maintenance mode on host {2}", (params.getIsEnabled() ? "enable" : "disable"), params.getMode().name().toLowerCase(), getVdsName());
    }
    getReturnValue().setSucceeded(succeeded);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VdsValidator vdsValidator = new VdsValidator(getVds());
    if (!validate(vdsValidator.exists()) || !validate(vdsValidator.isUp())) {
        return false;
    }
    if (getVds().getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_MAINT_NOT_SUPPORTED);
    }
    if (getVds().getHighlyAvailableIsConfigured()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_NOT_CONFIGURED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VdsValidator vdsValidator = new VdsValidator(getVds());
    if (!validate(vdsValidator.exists()) || !validate(vdsValidator.isUp())) {
        return false;
    }
    if (getVds().getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_MAINT_NOT_SUPPORTED);
    }
    if (!getVds().getHighlyAvailableIsConfigured()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_NOT_CONFIGURED);
    }
    return true;
}
#end_block

#method_before
public Integer getHighlyAvailableScore() {
    return this.mVdsStatistics.getHighlyAvailableScore();
}
#method_after
public int getHighlyAvailableScore() {
    return this.mVdsStatistics.getHighlyAvailableScore();
}
#end_block

#method_before
public void setHighlyAvailableScore(Integer value) {
    this.mVdsStatistics.setHighlyAvailableScore(value);
}
#method_after
public void setHighlyAvailableScore(int value) {
    this.mVdsStatistics.setHighlyAvailableScore(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableIsConfigured() {
    return this.mVdsStatistics.getHighlyAvailableIsConfigured();
}
#method_after
public boolean getHighlyAvailableIsConfigured() {
    return this.mVdsStatistics.getHighlyAvailableIsConfigured();
}
#end_block

#method_before
public void setHighlyAvailableIsConfigured(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsConfigured(value);
}
#method_after
public void setHighlyAvailableIsConfigured(boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsConfigured(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableIsActive() {
    return this.mVdsStatistics.getHighlyAvailableIsActive();
}
#method_after
public boolean getHighlyAvailableIsActive() {
    return this.mVdsStatistics.getHighlyAvailableIsActive();
}
#end_block

#method_before
public void setHighlyAvailableIsActive(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsActive(value);
}
#method_after
public void setHighlyAvailableIsActive(boolean value) {
    this.mVdsStatistics.setHighlyAvailableIsActive(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableGlobalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableGlobalMaintenance();
}
#method_after
public boolean getHighlyAvailableGlobalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableGlobalMaintenance();
}
#end_block

#method_before
public void setHighlyAvailableGlobalMaintenance(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableGlobalMaintenance(value);
}
#method_after
public void setHighlyAvailableGlobalMaintenance(boolean value) {
    this.mVdsStatistics.setHighlyAvailableGlobalMaintenance(value);
}
#end_block

#method_before
public Boolean getHighlyAvailableLocalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableLocalMaintenance();
}
#method_after
public boolean getHighlyAvailableLocalMaintenance() {
    return this.mVdsStatistics.getHighlyAvailableLocalMaintenance();
}
#end_block

#method_before
public void setHighlyAvailableLocalMaintenance(Boolean value) {
    this.mVdsStatistics.setHighlyAvailableLocalMaintenance(value);
}
#method_after
public void setHighlyAvailableLocalMaintenance(boolean value) {
    this.mVdsStatistics.setHighlyAvailableLocalMaintenance(value);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((cpu_idle == null) ? 0 : cpu_idle.hashCode());
    result = prime * result + ((cpu_load == null) ? 0 : cpu_load.hashCode());
    result = prime * result + ((cpu_sys == null) ? 0 : cpu_sys.hashCode());
    result = prime * result + ((cpu_user == null) ? 0 : cpu_user.hashCode());
    result = prime * result + ((mem_available == null) ? 0 : mem_available.hashCode());
    result = prime * result + ((memFree == null) ? 0 : memFree.hashCode());
    result = prime * result + ((mem_shared == null) ? 0 : mem_shared.hashCode());
    result = prime * result + ((usage_cpu_percent == null) ? 0 : usage_cpu_percent.hashCode());
    result = prime * result + ((usage_network_percent == null) ? 0 : usage_network_percent.hashCode());
    result = prime * result + ((ksm_state == null) ? 0 : ksm_state.hashCode());
    result = prime * result + ((ksm_pages == null) ? 0 : ksm_pages.hashCode());
    result = prime * result + ((ksm_cpu_percent == null) ? 0 : ksm_cpu_percent.hashCode());
    result = prime * result + ((swap_total == null) ? 0 : swap_total.hashCode());
    result = prime * result + ((swap_free == null) ? 0 : swap_free.hashCode());
    result = prime * result + ((highlyAvailableScore == null) ? 0 : highlyAvailableScore.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + ((highlyAvailableIsConfigured == null) ? 0 : highlyAvailableIsConfigured.hashCode());
    result = prime * result + ((highlyAvailableIsActive == null) ? 0 : highlyAvailableIsActive.hashCode());
    result = prime * result + ((highlyAvailableGlobalMaintenance == null) ? 0 : highlyAvailableGlobalMaintenance.hashCode());
    result = prime * result + ((highlyAvailableLocalMaintenance == null) ? 0 : highlyAvailableLocalMaintenance.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((cpu_idle == null) ? 0 : cpu_idle.hashCode());
    result = prime * result + ((cpu_load == null) ? 0 : cpu_load.hashCode());
    result = prime * result + ((cpu_sys == null) ? 0 : cpu_sys.hashCode());
    result = prime * result + ((cpu_user == null) ? 0 : cpu_user.hashCode());
    result = prime * result + ((mem_available == null) ? 0 : mem_available.hashCode());
    result = prime * result + ((memFree == null) ? 0 : memFree.hashCode());
    result = prime * result + ((mem_shared == null) ? 0 : mem_shared.hashCode());
    result = prime * result + ((usage_cpu_percent == null) ? 0 : usage_cpu_percent.hashCode());
    result = prime * result + ((usage_network_percent == null) ? 0 : usage_network_percent.hashCode());
    result = prime * result + ((ksm_state == null) ? 0 : ksm_state.hashCode());
    result = prime * result + ((ksm_pages == null) ? 0 : ksm_pages.hashCode());
    result = prime * result + ((ksm_cpu_percent == null) ? 0 : ksm_cpu_percent.hashCode());
    result = prime * result + ((swap_total == null) ? 0 : swap_total.hashCode());
    result = prime * result + ((swap_free == null) ? 0 : swap_free.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + highlyAvailableScore;
    result = prime * result + (highlyAvailableIsConfigured ? 1231 : 1237);
    result = prime * result + (highlyAvailableIsActive ? 1231 : 1237);
    result = prime * result + (highlyAvailableGlobalMaintenance ? 1231 : 1237);
    result = prime * result + (highlyAvailableLocalMaintenance ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatistics other = (VdsStatistics) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.bigDecimalEqual(cpu_idle, other.cpu_idle) && ObjectUtils.bigDecimalEqual(cpu_load, other.cpu_load) && ObjectUtils.bigDecimalEqual(cpu_sys, other.cpu_sys) && ObjectUtils.bigDecimalEqual(cpu_user, other.cpu_user) && ObjectUtils.objectsEqual(mem_available, other.mem_available) && ObjectUtils.objectsEqual(memFree, other.memFree) && ObjectUtils.objectsEqual(mem_shared, other.mem_shared) && ObjectUtils.objectsEqual(usage_cpu_percent, other.usage_cpu_percent) && ObjectUtils.objectsEqual(usage_network_percent, other.usage_network_percent) && ObjectUtils.objectsEqual(ksm_state, other.ksm_state) && ObjectUtils.objectsEqual(ksm_pages, other.ksm_pages) && ObjectUtils.objectsEqual(ksm_cpu_percent, other.ksm_cpu_percent) && ObjectUtils.objectsEqual(swap_total, other.swap_total) && ObjectUtils.objectsEqual(swap_free, other.swap_free) && ObjectUtils.objectsEqual(highlyAvailableScore, other.highlyAvailableScore) && (anonymousHugePages == other.anonymousHugePages) && ObjectUtils.objectsEqual(highlyAvailableIsConfigured, other.highlyAvailableIsConfigured) && ObjectUtils.objectsEqual(highlyAvailableIsActive, other.highlyAvailableIsActive) && ObjectUtils.objectsEqual(highlyAvailableGlobalMaintenance, other.highlyAvailableGlobalMaintenance) && ObjectUtils.objectsEqual(highlyAvailableLocalMaintenance, other.highlyAvailableLocalMaintenance));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatistics other = (VdsStatistics) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.bigDecimalEqual(cpu_idle, other.cpu_idle) && ObjectUtils.bigDecimalEqual(cpu_load, other.cpu_load) && ObjectUtils.bigDecimalEqual(cpu_sys, other.cpu_sys) && ObjectUtils.bigDecimalEqual(cpu_user, other.cpu_user) && ObjectUtils.objectsEqual(mem_available, other.mem_available) && ObjectUtils.objectsEqual(memFree, other.memFree) && ObjectUtils.objectsEqual(mem_shared, other.mem_shared) && ObjectUtils.objectsEqual(usage_cpu_percent, other.usage_cpu_percent) && ObjectUtils.objectsEqual(usage_network_percent, other.usage_network_percent) && ObjectUtils.objectsEqual(ksm_state, other.ksm_state) && ObjectUtils.objectsEqual(ksm_pages, other.ksm_pages) && ObjectUtils.objectsEqual(ksm_cpu_percent, other.ksm_cpu_percent) && ObjectUtils.objectsEqual(swap_total, other.swap_total) && ObjectUtils.objectsEqual(swap_free, other.swap_free) && (anonymousHugePages == other.anonymousHugePages) && (highlyAvailableScore == other.highlyAvailableScore) && (highlyAvailableIsConfigured == other.highlyAvailableIsConfigured) && (highlyAvailableIsActive == other.highlyAvailableIsActive) && (highlyAvailableGlobalMaintenance == other.highlyAvailableGlobalMaintenance) && (highlyAvailableLocalMaintenance == other.highlyAvailableLocalMaintenance));
}
#end_block

#method_before
public Integer getHighlyAvailableScore() {
    return highlyAvailableScore;
}
#method_after
public int getHighlyAvailableScore() {
    return highlyAvailableScore;
}
#end_block

#method_before
public void setHighlyAvailableScore(Integer value) {
    highlyAvailableScore = value;
}
#method_after
public void setHighlyAvailableScore(int value) {
    highlyAvailableScore = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableIsConfigured() {
    return highlyAvailableIsConfigured;
}
#method_after
public boolean getHighlyAvailableIsConfigured() {
    return highlyAvailableIsConfigured;
}
#end_block

#method_before
public void setHighlyAvailableIsConfigured(Boolean value) {
    highlyAvailableIsConfigured = value;
}
#method_after
public void setHighlyAvailableIsConfigured(boolean value) {
    highlyAvailableIsConfigured = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableIsActive() {
    return highlyAvailableIsActive;
}
#method_after
public boolean getHighlyAvailableIsActive() {
    return highlyAvailableIsActive;
}
#end_block

#method_before
public void setHighlyAvailableIsActive(Boolean value) {
    highlyAvailableIsActive = value;
}
#method_after
public void setHighlyAvailableIsActive(boolean value) {
    highlyAvailableIsActive = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableGlobalMaintenance() {
    return highlyAvailableGlobalMaintenance;
}
#method_after
public boolean getHighlyAvailableGlobalMaintenance() {
    return highlyAvailableGlobalMaintenance;
}
#end_block

#method_before
public void setHighlyAvailableGlobalMaintenance(Boolean value) {
    highlyAvailableGlobalMaintenance = value;
}
#method_after
public void setHighlyAvailableGlobalMaintenance(boolean value) {
    highlyAvailableGlobalMaintenance = value;
}
#end_block

#method_before
public Boolean getHighlyAvailableLocalMaintenance() {
    return highlyAvailableLocalMaintenance;
}
#method_after
public boolean getHighlyAvailableLocalMaintenance() {
    return highlyAvailableLocalMaintenance;
}
#end_block

#method_before
public void setHighlyAvailableLocalMaintenance(Boolean value) {
    highlyAvailableLocalMaintenance = value;
}
#method_after
public void setHighlyAvailableLocalMaintenance(boolean value) {
    highlyAvailableLocalMaintenance = value;
}
#end_block

#method_before
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    model.setVds(getEntity());
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#method_after
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    model.setVds(getEntity());
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, new Comparator<RpmVersion>() {

                    @Override
                    public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                        return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                    }
                });
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#end_block

#method_before
public ValidationResult diskImagesAlreadyExist() {
    List<String> existingDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : diskImages) {
        DiskImage existingDisk = getExistingDisk(diskImage.getId());
        if (existingDisk != null) {
            existingDisksAliases.add(diskImage.getDiskAlias() == null ? existingDisk.getDiskAlias() : diskImage.getDiskAlias());
        }
    }
    if (!existingDisksAliases.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", StringUtils.join(existingDisksAliases, ", ")));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesAlreadyExist() {
    List<String> existingDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : diskImages) {
        DiskImage existingDisk = getExistingDisk(diskImage.getId());
        if (existingDisk != null) {
            existingDisksAliases.add(diskImage.getDiskAlias().isEmpty() ? existingDisk.getDiskAlias() : diskImage.getDiskAlias());
        }
    }
    if (!existingDisksAliases.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", StringUtils.join(existingDisksAliases, ", ")));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debugFormat("scheduling started, correlation Id: {0}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debugFormat("Scheduling ended, correlation Id: {0}", correlationId);
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debugFormat("scheduling started, correlation Id: {0}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debugFormat("Scheduling ended, correlation Id: {0}", correlationId);
    }
}
#end_block

#method_before
private Guid selectBestHost(VDSGroup cluster, VM vm, Guid destHostId, List<VDS> vdsList, ClusterPolicy policy, Map<String, String> parameters) {
    // it passed filters return it
    if (destHostId != null) {
        for (VDS vds : vdsList) {
            if (destHostId.equals(vds.getId())) {
                return destHostId;
            }
        }
    }
    if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
        return vdsList.get(0).getId();
    }
    if (shouldWeighClusterHosts(cluster, vdsList)) {
        return runFunctions(policy.getFunctions(), vdsList, vm, parameters);
    }
    if (!vdsList.isEmpty()) {
        return vdsList.get(0).getId();
    }
    return null;
}
#method_after
private Guid selectBestHost(VDSGroup cluster, VM vm, Guid destHostId, List<VDS> vdsList, ClusterPolicy policy, Map<String, String> parameters) {
    // it passed filters, return it
    if (destHostId != null) {
        for (VDS vds : vdsList) {
            if (destHostId.equals(vds.getId())) {
                return destHostId;
            }
        }
    }
    List<Pair<Guid, Integer>> functions = policy.getFunctions();
    if (functions != null && !functions.isEmpty() && shouldWeighClusterHosts(cluster, vdsList)) {
        Guid bestHostByFunctions = runFunctions(functions, vdsList, vm, parameters);
        if (bestHostByFunctions != null) {
            return bestHostByFunctions;
        }
    }
    return vdsList.get(0).getId();
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    return vdsList != null && !vdsList.isEmpty();
}
#end_block

#method_before
protected void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && list.size() > 0) {
        List<VDS> toRemoveList = new ArrayList<VDS>();
        Set<Guid> listSet = new HashSet<Guid>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#method_after
protected void updateInitialHostList(List<VDS> vdsList, List<Guid> list, boolean contains) {
    if (list != null && !list.isEmpty()) {
        List<VDS> toRemoveList = new ArrayList<VDS>();
        Set<Guid> listSet = new HashSet<Guid>(list);
        for (VDS vds : vdsList) {
            if (listSet.contains(vds.getId()) == contains) {
                toRemoveList.add(vds);
            }
        }
        vdsList.removeAll(toRemoveList);
    }
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.getPolicyUnit().isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.size() == 0) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.getPolicyUnit().isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.getPolicyUnit().isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalFilters.isEmpty() && hostList != null && !hostList.isEmpty()) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.isEmpty()) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
protected Guid runFunctions(ArrayList<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    ArrayList<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<Pair<PolicyUnitImpl, Integer>>();
    ArrayList<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<Pair<PolicyUnitImpl, Integer>>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && externalScoreFunctions.size() > 0) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#method_after
protected Guid runFunctions(List<Pair<Guid, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    List<Pair<PolicyUnitImpl, Integer>> internalScoreFunctions = new ArrayList<>();
    List<Pair<PolicyUnitImpl, Integer>> externalScoreFunctions = new ArrayList<>();
    for (Pair<Guid, Integer> pair : functions) {
        PolicyUnitImpl currentPolicy = policyUnits.get(pair.getFirst());
        if (currentPolicy.getPolicyUnit().isInternal()) {
            internalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
        } else {
            if (currentPolicy.getPolicyUnit().isEnabled()) {
                externalScoreFunctions.add(new Pair<PolicyUnitImpl, Integer>(currentPolicy, pair.getSecond()));
            }
        }
    }
    Map<Guid, Integer> hostCostTable = runInternalFunctions(internalScoreFunctions, hostList, vm, parameters);
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled) && !externalScoreFunctions.isEmpty()) {
        runExternalFunctions(externalScoreFunctions, hostList, vm, parameters, hostCostTable);
    }
    Entry<Guid, Integer> bestHostEntry = null;
    for (Entry<Guid, Integer> entry : hostCostTable.entrySet()) {
        if (bestHostEntry == null || bestHostEntry.getValue() > entry.getValue()) {
            bestHostEntry = entry;
        }
    }
    if (bestHostEntry == null) {
        return null;
    }
    return bestHostEntry.getKey();
}
#end_block

#method_before
private Map<Guid, Integer> runInternalFunctions(ArrayList<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostCostTable = new HashMap<Guid, Integer>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        List<Pair<Guid, Integer>> scoreResult = pair.getFirst().score(hostList, vm, parameters);
        for (Pair<Guid, Integer> result : scoreResult) {
            Guid hostId = result.getFirst();
            if (hostCostTable.get(hostId) == null) {
                hostCostTable.put(hostId, 0);
            }
            hostCostTable.put(hostId, hostCostTable.get(hostId) + pair.getSecond() * result.getSecond());
        }
    }
    return hostCostTable;
}
#method_after
private Map<Guid, Integer> runInternalFunctions(List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostCostTable = new HashMap<Guid, Integer>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        List<Pair<Guid, Integer>> scoreResult = pair.getFirst().score(hostList, vm, parameters);
        for (Pair<Guid, Integer> result : scoreResult) {
            Guid hostId = result.getFirst();
            if (hostCostTable.get(hostId) == null) {
                hostCostTable.put(hostId, 0);
            }
            hostCostTable.put(hostId, hostCostTable.get(hostId) + pair.getSecond() * result.getSecond());
        }
    }
    return hostCostTable;
}
#end_block

#method_before
private void runExternalFunctions(ArrayList<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> hostCostTable) {
    List<Pair<String, Integer>> scoreNameAndWeight = new ArrayList<Pair<String, Integer>>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        scoreNameAndWeight.add(new Pair<String, Integer>(pair.getFirst().getPolicyUnit().getName(), pair.getSecond()));
    }
    List<Guid> hostIDs = new ArrayList<Guid>();
    for (VDS vds : hostList) {
        hostIDs.add(vds.getId());
    }
    List<Pair<Guid, Integer>> externalScores = ExternalSchedulerFactory.getInstance().runScores(scoreNameAndWeight, hostIDs, vm.getId(), parameters);
    if (externalScores != null) {
        sumScoreResults(hostCostTable, externalScores);
    }
}
#method_after
private void runExternalFunctions(List<Pair<PolicyUnitImpl, Integer>> functions, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> hostCostTable) {
    List<Pair<String, Integer>> scoreNameAndWeight = new ArrayList<Pair<String, Integer>>();
    for (Pair<PolicyUnitImpl, Integer> pair : functions) {
        scoreNameAndWeight.add(new Pair<String, Integer>(pair.getFirst().getPolicyUnit().getName(), pair.getSecond()));
    }
    List<Guid> hostIDs = new ArrayList<Guid>();
    for (VDS vds : hostList) {
        hostIDs.add(vds.getId());
    }
    List<Pair<Guid, Integer>> externalScores = ExternalSchedulerFactory.getInstance().runScores(scoreNameAndWeight, hostIDs, vm.getId(), parameters);
    if (externalScores != null) {
        sumScoreResults(hostCostTable, externalScores);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(returnedFailedHosts, ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
@Override
public void dispatchEvent(Event event, String address) {
    sendQueue.add(new DispatchAttempt(event, address));
}
#method_after
@Override
public void dispatchEvent(AuditLogEvent event, String address) {
    if (StringUtils.isEmpty(address)) {
        log.error("Address is empty, cannot distribute message." + event.getName());
    } else {
        sendQueue.add(new DispatchAttempt(event, address));
    }
}
#end_block

#method_before
@Override
public void idle() {
    DispatchAttempt dispatchAttempt = sendQueue.remove();
    Event event = dispatchAttempt.getEvent();
    String address = dispatchAttempt.getAddress();
    // throw an exception if not AuditLogEvent
    AuditLogEvent auditLogEvent;
    auditLogEvent = (AuditLogEvent) event;
    EventMessageContent message = new EventMessageContent();
    message.prepareMessage(hostName, auditLogEvent, isBodyHtml);
    if (StringUtils.isEmpty(address)) {
        log.error("Address is empty, cannot distribute message." + event.getName());
        return;
    }
    log.info(String.format("Send email to [%s]%n subject:%n [%s]", address, message.getMessageSubject()));
    if (log.isDebugEnabled()) {
        log.debug(String.format("body:%n [%s]", message.getMessageBody()));
    }
    String errorMessage = null;
    boolean success = false;
    try {
        mailSender.send(address, message.getMessageSubject(), message.getMessageBody());
        setChanged();
        notifyObservers(DispatchData.success(event, address, EventNotificationMethod.EMAIL));
        success = true;
    } catch (MessagingException ex) {
        errorMessage = ex.getMessage();
    }
    dispatchAttempt.setAttempts(dispatchAttempt.getAttempts() + 1);
    // Could not send after ATTEMPTS attempts.
    if (!success) {
        if (dispatchAttempt.getAttempts() < maxRetries) {
            sendQueue.add(dispatchAttempt);
        } else {
            // fail
            setChanged();
            notifyObservers(DispatchData.failure(event, address, EventNotificationMethod.EMAIL, errorMessage));
        }
    }
}
#method_after
@Override
public void idle() {
    if (lastSendInterval++ >= sendIntervals) {
        lastSendInterval = 0;
        Iterator<DispatchAttempt> iterator = sendQueue.iterator();
        while (iterator.hasNext()) {
            DispatchAttempt attempt = iterator.next();
            try {
                EventMessageContent message = new EventMessageContent();
                message.prepareMessage(hostName, attempt.event, isBodyHtml);
                log.info(String.format("Send email to [%s]%n subject:%n [%s]", attempt.address, message.getMessageSubject()));
                if (log.isDebugEnabled()) {
                    log.debug(String.format("body:%n [%s]", message.getMessageBody()));
                }
                sendMail(attempt.address, message.getMessageSubject(), message.getMessageBody());
                notifyObservers(DispatchResult.success(attempt.event, attempt.address, EventNotificationMethod.EMAIL));
                iterator.remove();
            } catch (Exception ex) {
                attempt.retries++;
                if (attempt.retries >= retries) {
                    notifyObservers(DispatchResult.failure(attempt.event, attempt.address, EventNotificationMethod.EMAIL, ex.getMessage()));
                    iterator.remove();
                }
            }
        }
    }
}
#end_block

#method_before
public void validate() {
    validateCommon();
    validateSmtp();
    validateFilter();
}
#method_after
public void validate() {
    validateCommon();
}
#end_block

#method_before
private void validateCommon() {
    requireAll(NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION, NotificationProperties.IDLE_INTERVAL);
    // validate mandatory and non empty properties
    requireOne(NotificationProperties.MAIL_SERVER);
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.IDLE_INTERVAL }) {
        validateNonNegative(property);
    }
}
#method_after
private void validateCommon() {
    requireAll(DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD, ENGINE_INTERVAL_IN_SECONDS, ENGINE_TIMEOUT_IN_SECONDS, INTERVAL_IN_SECONDS, IS_HTTPS_PROTOCOL, REPEAT_NON_RESPONSIVE_NOTIFICATION, IDLE_INTERVAL);
    // validate non negative args
    for (String property : new String[] { DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD, IDLE_INTERVAL }) {
        validateNonNegetive(property);
    }
}
#end_block

#method_before
private void requireAll(String... mandatoryProperties) {
    for (String property : mandatoryProperties) {
        if (StringUtils.isEmpty(getProperty(property, true))) {
            throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "'%s' is missing", property));
        }
    }
}
#method_after
public void requireAll(String... mandatoryProperties) {
    for (String property : mandatoryProperties) {
        if (StringUtils.isEmpty(getProperty(property, true))) {
            throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "'%s' is missing", property));
        }
    }
}
#end_block

#method_before
private void requireOne(String... mandatoryProperties) {
    boolean provided = false;
    for (String property : mandatoryProperties) {
        if (isConfigured(property)) {
            provided = true;
        }
    }
    if (!provided) {
        StringBuilder sb = new StringBuilder(100);
        sb.append(GENERIC_MESSAGE);
        String prefix = " ";
        for (String property : mandatoryProperties) {
            sb.append(prefix).append(property);
            prefix = " or ";
        }
        sb.append(" must be defined");
        throw new IllegalArgumentException(sb.toString());
    }
}
#method_after
public void requireOne(String... mandatoryProperties) {
    boolean provided = false;
    for (String property : mandatoryProperties) {
        if (isConfigured(property)) {
            provided = true;
        }
    }
    if (!provided) {
        StringBuilder sb = new StringBuilder(100);
        sb.append(GENERIC_MESSAGE);
        String prefix = " ";
        for (String property : mandatoryProperties) {
            sb.append(prefix).append(property);
            prefix = " or ";
        }
        sb.append(" must be defined");
        throw new IllegalArgumentException(sb.toString());
    }
}
#end_block

#method_before
private void validateEmail(String propName, String propVal) {
    if (!StringUtils.isEmpty(propVal)) {
        try {
            new InternetAddress(propVal);
        } catch (Exception ex) {
            throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "invalid format in '%s'", propName), ex);
        }
    }
}
#method_after
public InternetAddress validateEmail(String property) {
    try {
        InternetAddress ret = null;
        String value = getProperty(property);
        if (!StringUtils.isEmpty(value)) {
            ret = new InternetAddress(value);
        }
        return ret;
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format(GENERIC_MESSAGE + "invalid format in '%s'", property), ex);
    }
}
#end_block

#method_before
@Override
public void run() {
    log.debug("Start event notification service iteration");
    processEvents();
    long now = new Date(0).getTime();
    if (now - lastIdle >= getIdleInterval())
        for (Transport transport : transports) {
            log.debug(String.format("Transport %s is idle", transport.getName()));
            transport.idle();
        }
    lastIdle = now;
    log.debug("Finished event notification service iteration");
}
#method_after
@Override
public void run() {
    markOldEventsAsProcessed();
    ShutdownHook shutdownHook = ShutdownHook.getInstance();
    ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();
    shutdownHook.addScheduledExecutorService(exec);
    shutdownHook.addServiceHandler(exec.scheduleWithFixedDelay(new Runnable() {

        @Override
        public void run() {
            mainLogic();
        }
    }, 1, prop.getLong(NotificationProperties.INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
    shutdownHook.addServiceHandler(exec.scheduleWithFixedDelay(new Runnable() {

        @Override
        public void run() {
            idle();
        }
    }, 1, prop.getLong(NotificationProperties.IDLE_INTERVAL), TimeUnit.SECONDS));
}
#end_block

#method_before
private void markOldEventsAsProcessed() {
    log.debug("Processing old events");
    final int updatedEvents = eventsManager.markOldEventsAsProcessed(prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
    if (updatedEvents > 0) {
        log.debug(updatedEvents + " old records were marked as processed in the \"audit_log\" table.");
    }
}
#method_after
private void markOldEventsAsProcessed() {
    eventsManager.markOldEventsAsProcessed(prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
}
#end_block

#method_before
@Override
public void run() {
    try {
        log.debug("Start event notification service iteration");
        List<AuditLogEventSubscriber> eventSubscribers = getEventSubscribers(false);
        List<AuditLogSubscriber> subscribers = getSubscribers(false);
        List<AuditLogEvent> events = eventsManager.getAuditLogEvents(false);
        distributeEvents(events, eventSubscribers, subscribers);
        deleteObsoleteHistoryData();
        log.debug("Finished event notification service iteration");
    } catch (Throwable e) {
        if (isConnectionException(e)) {
            log.info("Connection exception while querying for notifications.", e);
            distributeDbDownEvent();
        }
        if (!Thread.interrupted()) {
            log.error(String.format("Failed to run the service: [%s]", e.getMessage()), e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        try {
            log.debug("Start event notification service iteration");
            // Clear filter chain
            firstMatchSimpleFilter.clearFilterEntries();
            // Read Database subscriptions first
            firstMatchSimpleFilter.addFilterEntries(eventsManager.getAuditLogEventSubscribers());
            // Backward compatibility, aim to remove (can be replaced by "FILTER")
            String dbDownSubscribers = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
            if (!StringUtils.isEmpty(dbDownSubscribers)) {
                for (String subscriber : dbDownSubscribers.split(",")) {
                    new FirstMatchSimpleFilter.FilterEntry(EventsManager.DATABASE_UNREACHABLE, false, EventNotificationMethod.EMAIL.name(), subscriber);
                }
            }
            // Add configurations subscription
            firstMatchSimpleFilter.addFilterEntries(configurationFilters);
            for (AuditLogEvent event : eventsManager.getAuditLogEvents()) {
                firstMatchSimpleFilter.processEvent(event);
                eventsManager.updateAuditLogEventProcessed(event.getId());
            }
            deleteObsoleteHistoryData();
            log.debug("Finished event notification service iteration");
        } catch (SQLException se) {
            distributeDbDownEvent();
            throw se;
        }
    } catch (Throwable t) {
        log.error(String.format("Failed to run the service."), t);
    }
}
#end_block

#method_before
private void deleteObsoleteHistoryData() throws SQLException {
    if (prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY) > 0) {
        final int deletedRecords = eventsManager.deleteObsoleteHistoryData(prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
        if (deletedRecords > 0) {
            log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
        }
    }
}
#method_after
private void deleteObsoleteHistoryData() throws SQLException {
    eventsManager.deleteObsoleteHistoryData(prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
}
#end_block

#method_before
private void distributeDbDownEvent() {
    if (failedQueries == 0) {
        try {
            distributeEvents(eventsManager.getAuditLogEvents(true), getEventSubscribers(true), getSubscribers(true));
        } catch (Exception e) {
            log.error("Failed to dispatch query failure email message", e);
        // Don't rethrow. we don't want to mask the original query exception.
        }
    }
    int failedQueriesNotificationThreshold = prop.getInteger(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    failedQueries = (failedQueries + 1) % failedQueriesNotificationThreshold;
}
#method_after
private void distributeDbDownEvent() {
    firstMatchSimpleFilter.clearFilterEntries();
    firstMatchSimpleFilter.addFilterEntries(configurationFilters);
    if (failedQueries == 0) {
        try {
            firstMatchSimpleFilter.processEvent(eventsManager.createDBDownEvent());
        } catch (Exception e) {
            log.error(String.format("Failed to dispatch %s event", EventsManager.DATABASE_UNREACHABLE), e);
        // Don't rethrow. we don't want to mask the original query exception.
        }
    }
    int failedQueriesNotificationThreshold = prop.getInteger(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    failedQueries = (failedQueries + 1) % failedQueriesNotificationThreshold;
}
#end_block

#method_before
private Map<String, String> populateEventMap() {
    Map<String, String> eventMap = new HashMap<>();
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT em.event_up_name, em.event_down_name " + "FROM event_map em;");
        rs = ps.executeQuery();
        while (rs.next()) {
            eventMap.put(rs.getString("event_up_name"), rs.getString("event_down_name"));
        }
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed to query for event subscribers.", e);
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventMap;
}
#method_after
private Map<String, String> populateEventMap() throws SQLException {
    Map<String, String> eventMap = new HashMap<>();
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT em.event_up_name, em.event_down_name " + "FROM event_map em;");
        rs = ps.executeQuery();
        while (rs.next()) {
            eventMap.put(rs.getString("event_up_name"), rs.getString("event_down_name"));
        }
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventMap;
}
#end_block

#method_before
public List<AuditLogEventSubscriber> getAuditLogEventSubscribers() {
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    List<AuditLogEventSubscriber> eventSubscribers = new ArrayList<>();
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT event_subscriber.event_up_name, " + "       event_subscriber.method_address, " + "       event_subscriber.notification_method " + "FROM event_subscriber ");
        rs = ps.executeQuery();
        while (rs.next()) {
            String eventUpName = rs.getString("event_up_name");
            eventSubscribers.add(EventSubscriberFactory.createEventSubscriber(rs.getString("notification_method"), rs.getString("method_address"), eventUpName, true));
            String eventDownName = eventMap.get(eventUpName);
            if (eventDownName != null) {
                eventSubscribers.add(EventSubscriberFactory.createEventSubscriber(rs.getString("notification_method"), rs.getString("method_address"), eventDownName, true));
            }
        }
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed to query for event subscribers.", e);
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventSubscribers;
}
#method_after
public List<FirstMatchSimpleFilter.FilterEntry> getAuditLogEventSubscribers() throws SQLException {
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    List<FirstMatchSimpleFilter.FilterEntry> eventSubscribers = new ArrayList<>();
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT event_subscriber.event_up_name, " + "       event_subscriber.method_address, " + "       event_subscriber.notification_method " + "FROM event_subscriber ");
        rs = ps.executeQuery();
        while (rs.next()) {
            String eventUpName = rs.getString("event_up_name");
            String eventDownName = eventMap.get(eventUpName);
            eventSubscribers.add(new FirstMatchSimpleFilter.FilterEntry(eventUpName, false, rs.getString("notification_method"), rs.getString("method_address")));
            if (eventDownName != null) {
                eventSubscribers.add(new FirstMatchSimpleFilter.FilterEntry(eventDownName, false, rs.getString("notification_method"), rs.getString("method_address")));
            }
        }
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    return eventSubscribers;
}
#end_block

#method_before
public List<AuditLogEvent> getAuditLogEvents(boolean dbDown) {
    List<AuditLogEvent> auditLogEvents = new ArrayList<>();
    if (dbDown) {
        auditLogEvents.add(createDBDownEvent());
    } else {
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            connection = ds.getConnection();
            ps = connection.prepareStatement("" + "SELECT al.audit_log_id, al.log_type_name, " + "       em_down.event_down_name," + "       al.user_id, al.user_name, " + "       al.vm_id, al.vm_name, al.vm_template_id, al.vm_template_name, " + "       al.vds_id, al.vds_name, al.storage_pool_id, al.storage_pool_name, " + "       al.storage_domain_id, al.storage_domain_name, " + "       al.log_time, al.severity, al.message " + "FROM audit_log al " + "LEFT JOIN event_map em_down ON al.log_type_name = em_down.event_down_name " + "WHERE al.processed = FALSE ;");
            rs = ps.executeQuery();
            while (rs.next()) {
                auditLogEvents.add(extractAuditLogEvent(rs));
            }
        } catch (SQLException e) {
            throw new NotificationServiceException("Failed to query for events.", e);
        } finally {
            DbUtils.closeQuietly(rs, ps, connection);
        }
    }
    if (log.isDebugEnabled()) {
        log.debug(String.format("%d unprocessed events read from audit_log database table.", auditLogEvents.size()));
        for (int i = 0; i < auditLogEvents.size(); i++) {
            log.debug(String.format("event %d => %s", i, auditLogEvents.get(i).toString()));
        }
    }
    return auditLogEvents;
}
#method_after
public List<AuditLogEvent> getAuditLogEvents() throws SQLException {
    List<AuditLogEvent> auditLogEvents = new ArrayList<>();
    HashSet<String> downEvents = new HashSet<>(eventMap.values());
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("" + "SELECT al.audit_log_id, al.log_type_name, " + "       al.user_id, al.user_name, " + "       al.vm_id, al.vm_name, al.vm_template_id, al.vm_template_name, " + "       al.vds_id, al.vds_name, al.storage_pool_id, al.storage_pool_name, " + "       al.storage_domain_id, al.storage_domain_name, " + "       al.log_time, al.severity, al.message " + "FROM audit_log al " + "WHERE al.processed = FALSE ;");
        rs = ps.executeQuery();
        while (rs.next()) {
            auditLogEvents.add(extractAuditLogEvent(rs, downEvents));
        }
    } finally {
        DbUtils.closeQuietly(rs, ps, connection);
    }
    if (log.isDebugEnabled()) {
        log.debug(String.format("%d unprocessed events read from audit_log database table.", auditLogEvents.size()));
        for (int i = 0; i < auditLogEvents.size(); i++) {
            log.debug(String.format("event %d => %s", i, auditLogEvents.get(i).toString()));
        }
    }
    return auditLogEvents;
}
#end_block

#method_before
private AuditLogEvent extractAuditLogEvent(ResultSet rs) throws SQLException {
    AuditLogEvent auditLogEvent = new AuditLogEvent();
    auditLogEvent.setId(rs.getLong("audit_log_id"));
    auditLogEvent.setLogTypeName(rs.getString("log_type_name"));
    final String eventDownName = rs.getString("event_down_name");
    if (eventDownName != null) {
        auditLogEvent.setType(AuditLogEventType.resolveMessage);
    } else {
        auditLogEvent.setType(AuditLogEventType.alertMessage);
    }
    auditLogEvent.setUserId(Guid.createGuidFromString(rs.getString("user_id")));
    auditLogEvent.setUserName(rs.getString("user_name"));
    auditLogEvent.setVmId(Guid.createGuidFromString(rs.getString("vm_id")));
    auditLogEvent.setVmName(rs.getString("vm_name"));
    auditLogEvent.setVmTemplateId(Guid.createGuidFromString(rs.getString("vm_template_id")));
    auditLogEvent.setVmTemplateName(rs.getString("vm_template_name"));
    auditLogEvent.setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
    auditLogEvent.setVdsName(rs.getString("vds_name"));
    auditLogEvent.setStoragePoolId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_pool_id")));
    auditLogEvent.setStoragePoolName(rs.getString("storage_pool_name"));
    auditLogEvent.setStorageDomainId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_domain_id")));
    auditLogEvent.setStorageDomainName(rs.getString("storage_domain_name"));
    auditLogEvent.setLogTime(rs.getTimestamp("log_time"));
    auditLogEvent.setSeverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    auditLogEvent.setMessage(rs.getString("message"));
    return auditLogEvent;
}
#method_after
private AuditLogEvent extractAuditLogEvent(ResultSet rs, Set<String> downEvents) throws SQLException {
    AuditLogEvent auditLogEvent = new AuditLogEvent();
    auditLogEvent.setId(rs.getLong("audit_log_id"));
    auditLogEvent.setLogTypeName(rs.getString("log_type_name"));
    if (downEvents.contains(auditLogEvent.getLogTypeName())) {
        auditLogEvent.setType(AuditLogEventType.resolveMessage);
    } else {
        auditLogEvent.setType(AuditLogEventType.alertMessage);
    }
    auditLogEvent.setUserId(Guid.createGuidFromString(rs.getString("user_id")));
    auditLogEvent.setUserName(rs.getString("user_name"));
    auditLogEvent.setVmId(Guid.createGuidFromString(rs.getString("vm_id")));
    auditLogEvent.setVmName(rs.getString("vm_name"));
    auditLogEvent.setVmTemplateId(Guid.createGuidFromString(rs.getString("vm_template_id")));
    auditLogEvent.setVmTemplateName(rs.getString("vm_template_name"));
    auditLogEvent.setVdsId(Guid.createGuidFromString(rs.getString("vds_id")));
    auditLogEvent.setVdsName(rs.getString("vds_name"));
    auditLogEvent.setStoragePoolId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_pool_id")));
    auditLogEvent.setStoragePoolName(rs.getString("storage_pool_name"));
    auditLogEvent.setStorageDomainId(Guid.createGuidFromStringDefaultEmpty(rs.getString("storage_domain_id")));
    auditLogEvent.setStorageDomainName(rs.getString("storage_domain_name"));
    auditLogEvent.setLogTime(rs.getTimestamp("log_time"));
    auditLogEvent.setSeverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    auditLogEvent.setMessage(rs.getString("message"));
    return auditLogEvent;
}
#end_block

#method_before
private AuditLogEvent createDBDownEvent() {
    final AuditLogEvent dbDownEvent = new AuditLogEvent();
    dbDownEvent.setLogTime(new Date());
    dbDownEvent.setType(AuditLogEventType.alertMessage);
    dbDownEvent.setLogTypeName(DATABASE_UNREACHABLE);
    dbDownEvent.setMessage("Failed to query for notifications. Database Connection refused.");
    dbDownEvent.setSeverity(AuditLogSeverity.ERROR);
    return dbDownEvent;
}
#method_after
public AuditLogEvent createDBDownEvent() {
    final AuditLogEvent dbDownEvent = new AuditLogEvent();
    dbDownEvent.setLogTime(new Date());
    dbDownEvent.setType(AuditLogEventType.alertMessage);
    dbDownEvent.setLogTypeName(DATABASE_UNREACHABLE);
    dbDownEvent.setMessage("Failed to query for notifications. Database Connection refused.");
    dbDownEvent.setSeverity(AuditLogSeverity.ERROR);
    return dbDownEvent;
}
#end_block

#method_before
public int markOldEventsAsProcessed(int daysToSendOnStartup) {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -daysToSendOnStartup);
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("" + "UPDATE audit_log " + "SET  processed = 'true' " + "WHERE processed = 'false' AND log_time < ? ;");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed mark old events as processed.", e);
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
    return updatedRecords;
}
#method_after
public void markOldEventsAsProcessed(int daysToSendOnStartup) {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -daysToSendOnStartup);
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("" + "UPDATE audit_log " + "SET  processed = 'true' " + "WHERE processed = 'false' AND log_time < ? ;");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
        if (updatedRecords > 0) {
            log.debug(updatedRecords + " old records were marked as processed in the \"audit_log\" table.");
        }
    } catch (SQLException e) {
        throw new NotificationServiceException("Failed mark old events as processed.", e);
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
}
#end_block

#method_before
public int deleteObsoleteHistoryData(int daysToKeepHistory) throws SQLException {
    Calendar cal = Calendar.getInstance();
    cal.setTime(new Date());
    cal.add(Calendar.DATE, -daysToKeepHistory);
    Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
    Connection connection = null;
    PreparedStatement deleteStmt = null;
    int deletedRecords;
    try {
        connection = ds.getConnection();
        deleteStmt = connection.prepareStatement("" + "DELETE " + "FROM event_notification_hist " + "WHERE sent_at < ? ;");
        deleteStmt.setTimestamp(1, startDeleteFrom);
        deletedRecords = deleteStmt.executeUpdate();
    } finally {
        DbUtils.closeQuietly(deleteStmt, connection);
    }
    return deletedRecords;
}
#method_after
public void deleteObsoleteHistoryData(int daysToKeepHistory) throws SQLException {
    if (daysToKeepHistory > 0) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -daysToKeepHistory);
        Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
        Connection connection = null;
        PreparedStatement deleteStmt = null;
        int deletedRecords;
        try {
            connection = ds.getConnection();
            deleteStmt = connection.prepareStatement("" + "DELETE " + "FROM event_notification_hist " + "WHERE sent_at < ? ;");
            deleteStmt.setTimestamp(1, startDeleteFrom);
            deletedRecords = deleteStmt.executeUpdate();
            if (deletedRecords > 0) {
                log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
            }
        } finally {
            DbUtils.closeQuietly(deleteStmt, connection);
        }
    }
}
#end_block

#method_before
@BeforeClass
static public void beforeClass() {
    NotificationProperties.release();
    NotificationProperties.setDefaults(ClassLoader.getSystemResource("conf/notifier-prop-test.conf").getPath(), "");
    prop = NotificationProperties.getInstance();
    assertNotNull(prop);
}
#method_after
@BeforeClass
static public void beforeClass() throws UnsupportedEncodingException {
    NotificationProperties.release();
    NotificationProperties.setDefaults(URLDecoder.decode(ClassLoader.getSystemResource("conf/notifier-prop-test.conf").getPath(), "UTF-8"), "");
    prop = NotificationProperties.getInstance();
    assertNotNull(prop);
}
#end_block

#method_before
private void validateCommon() {
    requireAll(NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION);
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
}
#method_after
private void validateCommon() {
    requireAll(DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD, ENGINE_INTERVAL_IN_SECONDS, ENGINE_TIMEOUT_IN_SECONDS, INTERVAL_IN_SECONDS, IS_HTTPS_PROTOCOL, REPEAT_NON_RESPONSIVE_NOTIFICATION);
    // validate non negative args
    for (String property : new String[] { DAYS_TO_KEEP_HISTORY, DAYS_TO_SEND_ON_STARTUP, FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
}
#end_block

#method_before
public int validateInteger(String property) {
    final String stringVal = getProperty(property);
    try {
        return Integer.parseInt(getProperty(property));
    } catch (NumberFormatException exception) {
        throw new IllegalArgumentException(String.format("'%s' must be an integer.", property));
    }
}
#method_after
public int validateInteger(String property) {
    try {
        return Integer.parseInt(getProperty(property));
    } catch (NumberFormatException exception) {
        throw new IllegalArgumentException(String.format("'%s' must be an integer.", property));
    }
}
#end_block

#method_before
private void initConfigurationProperties() throws NotificationServiceException {
    daysToKeepHistory = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_KEEP_HISTORY);
    daysToSendOnStartup = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_SEND_ON_STARTUP);
    failedQueriesNotificationThreshold = getNonNegativeIntegerProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    methodsMapper = new NotificationMethodsMapper(prop);
    failedQueriesEventSender = methodsMapper.getEventSender(EventNotificationMethods.EMAIL);
}
#method_after
private void initConfigurationProperties() throws NotificationServiceException {
    daysToKeepHistory = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_KEEP_HISTORY);
    daysToSendOnStartup = getNonNegativeIntegerProperty(NotificationProperties.DAYS_TO_SEND_ON_STARTUP);
    failedQueriesNotificationThreshold = getNonNegativeIntegerProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD);
    if (failedQueriesNotificationThreshold == 0) {
        failedQueriesNotificationThreshold = 1;
    }
    methodsMapper = new NotificationMethodsMapper(prop);
    failedQueriesEventSender = methodsMapper.getEventSender(EventNotificationMethod.EMAIL);
}
#end_block

#method_before
private event_notification_hist geteventNotificationHist(EventAuditLogSubscriber eals, boolean isNotified, String reason) {
    event_notification_hist eventHistory = new event_notification_hist();
    eventHistory.setaudit_log_id(eals.getaudit_log_id());
    eventHistory.setevent_name(eals.getevent_up_name());
    eventHistory.setmethod_type(EventNotificationMethods.forValue(eals.getmethod_id()).name());
    eventHistory.setreason(reason);
    eventHistory.setsent_at(new Date());
    eventHistory.setstatus(isNotified);
    eventHistory.setsubscriber_id(eals.getsubscriber_id());
    return eventHistory;
}
#method_after
private event_notification_hist geteventNotificationHist(EventAuditLogSubscriber eals, boolean isNotified, String reason) {
    event_notification_hist eventHistory = new event_notification_hist();
    eventHistory.setaudit_log_id(eals.getaudit_log_id());
    eventHistory.setevent_name(eals.getevent_up_name());
    eventHistory.setmethod_type(EventNotificationMethod.forMethodId(eals.getmethod_id()).name());
    eventHistory.setreason(reason);
    eventHistory.setsent_at(new Date());
    eventHistory.setstatus(isNotified);
    eventHistory.setsubscriber_id(eals.getsubscriber_id());
    return eventHistory;
}
#end_block

#method_before
private void initFailedQueriesEventSubscribers() {
    String emailRecipients = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
    if (StringUtils.isEmpty(emailRecipients)) {
        return;
    }
    List<EventAuditLogSubscriber> failedQueriesEventSubscribers = new LinkedList<>();
    for (String email : emailRecipients.split(",")) {
        EventAuditLogSubscriber eals = new EventAuditLogSubscriber();
        eals.setevent_type(MessageHelper.MessageType.alertMessage.getEventType());
        eals.setevent_up_name("DATABASE_UNREACHABLE");
        eals.setmethod_id(EventNotificationMethods.EMAIL.getValue());
        eals.setmethod_address(StringUtils.strip(email));
        eals.setmessage("Failed to query for notifications. Database Connection refused.");
        eals.setseverity(AuditLogSeverity.ERROR.getValue());
        failedQueriesEventSubscribers.add(eals);
    }
    this.failedQueriesEventSubscribers = failedQueriesEventSubscribers;
}
#method_after
private void initFailedQueriesEventSubscribers() {
    String emailRecipients = prop.getProperty(NotificationProperties.FAILED_QUERIES_NOTIFICATION_RECIPIENTS, true);
    if (StringUtils.isEmpty(emailRecipients)) {
        return;
    }
    List<EventAuditLogSubscriber> failedQueriesEventSubscribers = new LinkedList<>();
    for (String email : emailRecipients.split(",")) {
        EventAuditLogSubscriber eals = new EventAuditLogSubscriber();
        eals.setevent_type(MessageHelper.MessageType.alertMessage.getEventType());
        eals.setevent_up_name("DATABASE_UNREACHABLE");
        eals.setmethod_id(EventNotificationMethod.EMAIL.getMethodId());
        eals.setmethod_address(StringUtils.strip(email));
        eals.setmessage("Failed to query for notifications. Database Connection refused.");
        eals.setseverity(AuditLogSeverity.ERROR.getValue());
        failedQueriesEventSubscribers.add(eals);
    }
    this.failedQueriesEventSubscribers = failedQueriesEventSubscribers;
}
#end_block

#method_before
public EventSender getEventSender(int intValue) {
    return eventSenders.get(EventNotificationMethods.forValue(intValue));
}
#method_after
public EventSender getEventSender(EventNotificationMethod method) {
    return eventSenders.get(method);
}
#end_block

#method_before
public EventSender getEventSender(int intValue) {
    return eventSenders.get(EventNotificationMethods.forValue(intValue));
}
#method_after
public EventSender getEventSender(int methodId) {
    return eventSenders.get(EventNotificationMethod.forMethodId(methodId));
}
#end_block

#method_before
private static Map<String, String> getMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.redhat.com");
    prop.put(NotificationProperties.MAIL_USER, "dev-null@redhat.com");
    prop.put(NotificationProperties.HTML_MESSAGE_FORMAT, "true");
    return prop;
}
#method_after
private static Map<String, String> getMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.redhat.com");
    prop.put(NotificationProperties.MAIL_USER, "dev-null@redhat.com");
    prop.put(NotificationProperties.HTML_MESSAGE_FORMAT, "true");
    prop.put(NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE);
    return prop;
}
#end_block

#method_before
private static Map<String, String> getSecuredMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.gmail.com");
    prop.put(NotificationProperties.MAIL_PORT, "465");
    prop.put(NotificationProperties.MAIL_USER, "mailtest.redhat@gmail.com");
    prop.put(NotificationProperties.MAIL_PASSWORD, "q1!w2@e3#!");
    prop.put(NotificationProperties.MAIL_FROM, "dev-null@redhat.com");
    prop.put(NotificationProperties.MAIL_ENABLE_SSL, "true");
    return prop;
}
#method_after
private static Map<String, String> getSecuredMailProperties() {
    Map<String, String> prop = new HashMap<String, String>();
    prop.put(NotificationProperties.MAIL_SERVER, "smtp.gmail.com");
    prop.put(NotificationProperties.MAIL_PORT, "465");
    prop.put(NotificationProperties.MAIL_USER, "mailtest.redhat@gmail.com");
    prop.put(NotificationProperties.MAIL_PASSWORD, "q1!w2@e3#!");
    prop.put(NotificationProperties.MAIL_FROM, "dev-null@redhat.com");
    prop.put(NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL);
    return prop;
}
#end_block

#method_before
private void distributeEvent(List<AuditLogEventSubscriber> eventSubscribers, AuditLogEvent event) throws SQLException {
    for (AuditLogEventSubscriber subscriber : eventSubscribers) {
        if (subscriber.isSubscribed(event)) {
            EventSender method = notificationMethodsMapper.getEventSender(subscriber.getEventNotificationMethod());
            EventSenderResult sendResult;
            try {
                sendResult = method.send(event, subscriber);
            } catch (Exception e) {
                log.error("Failed to dispatch message", e);
                sendResult = new EventSenderResult();
                sendResult.setSent(false);
                sendResult.setReason(e.getMessage());
            }
            eventsManager.addEventNotificationHistoryRecord(event, subscriber, sendResult);
            eventsManager.updateAuditLogEventProcessed(event.getId(), log);
        }
    }
}
#method_after
private void distributeEvent(List<AuditLogEventSubscriber> eventSubscribers, AuditLogEvent event) throws SQLException {
    for (AuditLogEventSubscriber subscriber : eventSubscribers) {
        if (subscriber.isSubscribed(event)) {
            Transport sender = notificationMethodsMapper.getEventSender(subscriber.getEventNotificationMethod());
            EventSenderResult sendResult;
            try {
                sendResult = sender.send(event, subscriber);
            } catch (Exception e) {
                log.error("Failed to dispatch message", e);
                sendResult = new EventSenderResult();
                sendResult.setSent(false);
                sendResult.setReason(e.getMessage());
            }
            eventsManager.addEventNotificationHistoryRecord(event, subscriber, sendResult);
            eventsManager.updateAuditLogEventProcessed(event.getId(), log);
        }
    }
}
#end_block

#method_before
private void deleteObsoleteHistoryData() throws SQLException {
    if (prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY) > 0) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
        Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
        Connection connection = null;
        PreparedStatement deleteStmt = null;
        int deletedRecords;
        try {
            connection = ds.getConnection();
            deleteStmt = connection.prepareStatement("DELETE FROM event_notification_hist WHERE sent_at < ?");
            deleteStmt.setTimestamp(1, startDeleteFrom);
            deletedRecords = deleteStmt.executeUpdate();
        } finally {
            if (deleteStmt != null) {
                deleteStmt.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
        if (deletedRecords > 0) {
            log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
        }
    }
}
#method_after
private void deleteObsoleteHistoryData() throws SQLException {
    if (prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY) > 0) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_KEEP_HISTORY));
        Timestamp startDeleteFrom = new Timestamp(cal.getTimeInMillis());
        Connection connection = null;
        PreparedStatement deleteStmt = null;
        int deletedRecords;
        try {
            connection = ds.getConnection();
            deleteStmt = connection.prepareStatement("delete from event_notification_hist where sent_at < ?");
            deleteStmt.setTimestamp(1, startDeleteFrom);
            deletedRecords = deleteStmt.executeUpdate();
        } finally {
            if (deleteStmt != null) {
                deleteStmt.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
        if (deletedRecords > 0) {
            log.debug(deletedRecords + " records were deleted from \"event_notification_hist\" table.");
        }
    }
}
#end_block

#method_before
private void markOldEventsAsProcessed() throws SQLException {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("UPDATE audit_log SET " + "processed = 'true' " + "WHERE " + "processed = 'false' " + "AND log_time < ?");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
    if (updatedRecords > 0) {
        log.debug(updatedRecords + " old records were marked as processed in the \"audit_log\" table.");
    }
}
#method_after
private void markOldEventsAsProcessed() throws SQLException {
    Calendar calendar = Calendar.getInstance();
    calendar.add(Calendar.DATE, -prop.getInteger(NotificationProperties.DAYS_TO_SEND_ON_STARTUP));
    Timestamp ts = new Timestamp(calendar.getTimeInMillis());
    Connection connection = null;
    PreparedStatement statement = null;
    int updatedRecords;
    try {
        connection = ds.getConnection();
        statement = connection.prepareStatement("update audit_log set " + "processed = 'true' " + "where " + "processed = 'false' " + "and log_time < ?");
        statement.setTimestamp(1, ts);
        updatedRecords = statement.executeUpdate();
    } finally {
        DbUtils.closeQuietly(statement, connection);
    }
    if (updatedRecords > 0) {
        log.debug(updatedRecords + " old records were marked as processed in the \"audit_log\" table.");
    }
}
#end_block

#method_before
private void updateAuditLogEventProcessed(EventAuditLogSubscriber eventSubscriber) throws SQLException {
    Connection connection = null;
    PreparedStatement ps = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("UPDATE audit_log SET processed = 'true' WHERE audit_log_id = ?");
        ps.setLong(1, eventSubscriber.getaudit_log_id());
        int updated = ps.executeUpdate();
        if (updated != 1) {
            log.error("Failed to mark audit_log entry as processed for audit_log_id: " + eventSubscriber.getaudit_log_id());
        }
    } finally {
        DbUtils.closeQuietly(ps, connection);
    }
}
#method_after
private void updateAuditLogEventProcessed(EventAuditLogSubscriber eventSubscriber) throws SQLException {
    Connection connection = null;
    PreparedStatement ps = null;
    try {
        connection = ds.getConnection();
        ps = connection.prepareStatement("update audit_log set processed = 'true' where audit_log_id = ?");
        ps.setLong(1, eventSubscriber.getaudit_log_id());
        int updated = ps.executeUpdate();
        if (updated != 1) {
            log.error("Failed to mark audit_log entry as processed for audit_log_id: " + eventSubscriber.getaudit_log_id());
        }
    } finally {
        DbUtils.closeQuietly(ps, connection);
    }
}
#end_block

#method_before
public void validate() {
    // validate mandatory and non empty properties
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.MAIL_PORT, NotificationProperties.MAIL_SERVER, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION }) {
        if (StringUtils.isEmpty(getProperty(property))) {
            throw new IllegalArgumentException(String.format("Check configuration file, '%s' is missing", property));
        }
    }
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
    if (!isSmtpEncryptionOptionValid()) {
        throw new IllegalArgumentException(String.format("Check configuration file, '%s' value has to be one of: '%s', '%s', '%s'.", NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL, NotificationProperties.MAIL_SMTP_ENCRYPTION_TLS));
    }
    // try to resolve MAIL_SERVER host
    try {
        InetAddress.getAllByName(getProperty(NotificationProperties.MAIL_SERVER));
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format("Check configuration file, cannot verify '%s' value", NotificationProperties.MAIL_SERVER), ex);
    }
    // validate email addresses
    for (String property : new String[] { NotificationProperties.MAIL_USER, NotificationProperties.MAIL_FROM, NotificationProperties.MAIL_REPLY_TO }) {
        String candidate = getProperty(property);
        if (!StringUtils.isEmpty(candidate)) {
            try {
                new InternetAddress(candidate);
            } catch (Exception ex) {
                throw new IllegalArgumentException(String.format("Check configuration file, invalid format in '%s'", property), ex);
            }
        }
    }
    // validate mail user value
    String emailUser = getProperty(NotificationProperties.MAIL_USER, true);
    if (StringUtils.isEmpty(emailUser) && (MAIL_SMTP_ENCRYPTION_SSL.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || MAIL_SMTP_ENCRYPTION_TLS.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || StringUtils.isNotEmpty(getProperty(NotificationProperties.MAIL_PASSWORD, true)))) {
        throw new IllegalArgumentException(String.format("'%s' must be set when SSL or TLS is enabled or when password is set", NotificationProperties.MAIL_USER));
    }
}
#method_after
public void validate() {
    // validate mandatory and non empty properties
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD, NotificationProperties.ENGINE_INTERVAL_IN_SECONDS, NotificationProperties.ENGINE_TIMEOUT_IN_SECONDS, NotificationProperties.INTERVAL_IN_SECONDS, NotificationProperties.IS_HTTPS_PROTOCOL, NotificationProperties.MAIL_PORT, NotificationProperties.MAIL_SERVER, NotificationProperties.REPEAT_NON_RESPONSIVE_NOTIFICATION }) {
        if (StringUtils.isEmpty(getProperty(property))) {
            throw new IllegalArgumentException(String.format("Check configuration file, '%s' is missing", property));
        }
    }
    // validate non negative args
    for (String property : new String[] { NotificationProperties.DAYS_TO_KEEP_HISTORY, NotificationProperties.DAYS_TO_SEND_ON_STARTUP, NotificationProperties.FAILED_QUERIES_NOTIFICATION_THRESHOLD }) {
        final String stringVal = getProperty(property);
        try {
            int value = Integer.parseInt(stringVal);
            if (value < 0) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException exception) {
            throw new IllegalArgumentException(String.format("'%s' must be a non negative integer.", property));
        }
    }
    if (!isSmtpEncryptionOptionValid()) {
        throw new IllegalArgumentException(String.format("Check configuration file, '%s' value has to be one of: '%s', '%s', '%s'.", NotificationProperties.MAIL_SMTP_ENCRYPTION, NotificationProperties.MAIL_SMTP_ENCRYPTION_NONE, NotificationProperties.MAIL_SMTP_ENCRYPTION_SSL, NotificationProperties.MAIL_SMTP_ENCRYPTION_TLS));
    }
    boolean mailPortValid = false;
    try {
        int port = new Integer(getProperty(MAIL_PORT));
        if (port > 0 && port < 65536) {
            mailPortValid = true;
        }
    } catch (NumberFormatException ex) {
    }
    if (!mailPortValid) {
        throw new IllegalArgumentException(String.format("Check configuration file, MAIL_PORT value has to be in range from 1 to 65535," + " currently '%s'", getProperty(MAIL_PORT)));
    }
    // try to resolve MAIL_SERVER host
    try {
        InetAddress.getAllByName(getProperty(NotificationProperties.MAIL_SERVER));
    } catch (Exception ex) {
        throw new IllegalArgumentException(String.format("Check configuration file, cannot verify '%s' value", NotificationProperties.MAIL_SERVER), ex);
    }
    // validate email addresses
    for (String property : new String[] { NotificationProperties.MAIL_USER, NotificationProperties.MAIL_FROM, NotificationProperties.MAIL_REPLY_TO }) {
        String candidate = getProperty(property);
        if (!StringUtils.isEmpty(candidate)) {
            try {
                new InternetAddress(candidate);
            } catch (Exception ex) {
                throw new IllegalArgumentException(String.format("Check configuration file, invalid format in '%s'", property), ex);
            }
        }
    }
    // validate mail user value
    String emailUser = getProperty(NotificationProperties.MAIL_USER, true);
    if (StringUtils.isEmpty(emailUser) && (MAIL_SMTP_ENCRYPTION_SSL.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || MAIL_SMTP_ENCRYPTION_TLS.equals(getProperty(MAIL_SMTP_ENCRYPTION, true)) || StringUtils.isNotEmpty(getProperty(NotificationProperties.MAIL_PASSWORD, true)))) {
        throw new IllegalArgumentException(String.format("'%s' must be set when SSL or TLS is enabled or when password is set", NotificationProperties.MAIL_USER));
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    EventNotificationMethod eventNotificationMethod = getParameters().getEventSubscriber().getevent_notification_method();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, eventNotificationMethod)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        if (eventNotificationMethod != null) {
            // validate event
            List<EventMap> eventMap = DbFacade.getInstance().getEventDao().getEventMapByName(eventName);
            if (eventMap.size() > 0) {
                String domain = getParameters().getDomain();
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    // If an exception is thrown while trying, handle it and and fail with the relevant message
                    try {
                        user = UserCommandBase.initUser(getParameters().getSessionId(), domain, subscriberId);
                        retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
                    } catch (VdcBLLException vdcBllException) {
                        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
                        retValue = false;
                    }
                } else {
                    retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(String.format("$eventName %1$s", eventName));
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    EventNotificationMethod eventNotificationMethod = getParameters().getEventSubscriber().getevent_notification_method();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, eventNotificationMethod)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        if (eventNotificationMethod != null) {
            // validate event
            List<EventMap> eventMap = DbFacade.getInstance().getEventDao().getEventMapByName(eventName);
            if (eventMap.size() > 0) {
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                    retValue = false;
                } else {
                    retValue = ValidateAdd(eventNotificationMethod, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(String.format("$eventName %1$s", eventName));
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#end_block

#method_before
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getAvailableNotificationEvents();
    Translator eventNotificationEntityTranslator = EnumTranslator.create(EventNotificationEntity.class);
    Translator auditLogTypeTranslator = EnumTranslator.create(AuditLogType.class);
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(eventNotificationEntityTranslator.containsKey(eventType) ? eventNotificationEntityTranslator.get(eventType) : eventType.toString());
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = auditLogTypeTranslator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void manageEvents() {
    EventNotificationModel model = new EventNotificationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addEventNotificationTitle());
    model.setHelpTag(HelpTag.add_event_notification);
    // $NON-NLS-1$
    model.setHashName("add_event_notification");
    ArrayList<EventNotificationEntity> eventTypes = ApplicationModeHelper.getModeSpecificEventNotificationTypeList();
    Map<EventNotificationEntity, HashSet<AuditLogType>> availableEvents = AsyncDataProvider.getAvailableNotificationEvents();
    Translator eventNotificationEntityTranslator = EnumTranslator.create(EventNotificationEntity.class);
    Translator auditLogTypeTranslator = EnumTranslator.create(AuditLogType.class);
    ArrayList<SelectionTreeNodeModel> list = new ArrayList<SelectionTreeNodeModel>();
    ArrayList<event_subscriber> items = getItems() == null ? new ArrayList<event_subscriber>() : Linq.<event_subscriber>cast(getItems());
    for (EventNotificationEntity eventType : eventTypes) {
        SelectionTreeNodeModel stnm = new SelectionTreeNodeModel();
        stnm.setTitle(eventType.toString());
        stnm.setDescription(eventNotificationEntityTranslator.containsKey(eventType) ? eventNotificationEntityTranslator.get(eventType) : eventType.toString());
        list.add(stnm);
        for (AuditLogType logtype : availableEvents.get(eventType)) {
            SelectionTreeNodeModel eventGrp = new SelectionTreeNodeModel();
            String description;
            try {
                description = auditLogTypeTranslator.get(logtype);
            } catch (MissingResourceException e) {
                description = logtype.toString();
            }
            eventGrp.setTitle(logtype.toString());
            eventGrp.setDescription(description);
            eventGrp.setParent(list.get(list.size() - 1));
            eventGrp.setIsSelectedNotificationPrevent(true);
            eventGrp.setIsSelectedNullable(false);
            for (event_subscriber es : items) {
                if (es.getevent_up_name().equals(logtype.toString())) {
                    eventGrp.setIsSelectedNullable(true);
                    break;
                }
            }
            list.get(list.size() - 1).getChildren().add(eventGrp);
            eventGrp.setIsSelectedNotificationPrevent(false);
        }
        if (list.get(list.size() - 1).getChildren().size() > 0) {
            list.get(list.size() - 1).getChildren().get(0).updateParentSelection();
        }
    }
    model.setEventGroupModels(list);
    if (!StringHelper.isNullOrEmpty(getEntity().getEmail())) {
        model.getEmail().setEntity(getEntity().getEmail());
    } else if (items.size() > 0) {
        model.getEmail().setEntity(items.get(0).getmethod_address());
    }
    model.setOldEmail((String) model.getEmail().getEntity());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getManageEventsCommand()) {
        manageEvents();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getManageEventsCommand()) {
        manageEvents();
    }
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    }
    if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(_vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            ResourceManager.getInstance().getEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase(_vds.getId());
    logable.addCustomValue("VdsStatus", _vds.getStatus().toString());
    auditLog(logable, AuditLogType.VDS_DETECTED);
}
#method_after
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (_vds.getStatus() != VDSStatus.Up) {
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("HostStatus", _vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                if (lunFromMap != null && lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    _vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    for (VmDynamic vmDynamic : getPoweringUpVms()) {
        VmInternalData vmInternalData = getRunningVms().get(vmDynamic.getId());
        if (vmInternalData != null) {
            Map<String, LUNs> lunsMap = vmInternalData.getLunsMap();
            if (lunsMap.isEmpty()) {
                // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
                continue;
            }
            List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vmDynamic.getId(), true);
            for (Disk disk : vmDisks) {
                if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                    continue;
                }
                LUNs lunFromDB = ((LunDisk) disk).getLun();
                LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
                // Hence, verify before updating.
                if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                    // Found a mismatch - set LUN for update
                    log.infoFormat("Updated LUN device size - ID: {0}, previous size: {1}, new size: {2}.", lunFromDB.getLUN_id(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                    lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                    vmLunDisksToSave.add(lunFromDB);
                }
            }
        }
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    // Go over all the vms and determine which ones require updating
    // Update only running VMs
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null && vmDynamic.getStatus() != VMStatus.MigratingTo) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#method_after
private void handleVmDeviceChange() {
    // Go over all the vms and determine which ones require updating
    // Update only running VMs
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null && vmDynamic.getStatus() != VMStatus.MigratingTo) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (!vmsToUpdateFromVds.isEmpty()) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#end_block

#method_before
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        // => cacheVm == null
        {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#method_after
private void handleVmOnDown(VM cacheVm, VmDynamic vmDynamic, VmStatistics vmStatistics) {
    VmExitStatus exitStatus = vmDynamic.getExitStatus();
    if (exitStatus != VmExitStatus.Normal) {
        auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        // Vm failed to run - try to rerun it on other Vds
        if (cacheVm != null) {
            if (ResourceManager.getInstance().IsVmInAsyncRunningList(vmDynamic.getId())) {
                log.infoFormat("Running on vds during rerun failed vm: {0}", vmDynamic.getRunOnVds());
                _vmsToRerun.add(vmDynamic.getId());
            } else if (cacheVm.isAutoStartup()) {
                _autoVmsToRun.add(vmDynamic.getId());
            }
        } else // if failed in destination right after migration
        {
            // => cacheVm == null
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
            addVmDynamicToList(vmDynamic);
        }
    } else {
        // don't generate an event
        if (cacheVm != null) {
            auditVmOnDownEvent(exitStatus, vmDynamic.getExitMessage(), vmStatistics.getId());
        }
        // Vm moved safely to down status. May be migration - just remove it from Async Running command.
        ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        props.remove("runOnce");
        props.remove("cpuName");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#method_after
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // remove all fields that should not be checked:
        props.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains(VmDynamic.STATUS_FIELD_NAME) && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove(VmDynamic.STATUS_FIELD_NAME);
        }
        // if anything else changed
        if (!props.isEmpty()) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#end_block

#method_before
private void addVmInterfaceStatisticsToList(List<VmNetworkInterface> list) {
    if (list.size() <= 0) {
        return;
    }
    _vmInterfaceStatisticsToSave.put(list.get(0).getVmId(), list);
}
#method_after
private void addVmInterfaceStatisticsToList(List<VmNetworkInterface> list) {
    if (list.isEmpty()) {
        return;
    }
    _vmInterfaceStatisticsToSave.put(list.get(0).getVmId(), list);
}
#end_block

#method_before
protected List<LUNs> getVmLunDisksToSave() {
    return Collections.unmodifiableList(_vmLunDisksToSave);
}
#method_after
protected List<LUNs> getVmLunDisksToSave() {
    return Collections.unmodifiableList(vmLunDisksToSave);
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setStorageType(StorageType.valueOf(xmlRpcStruct.get("type").toString()));
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    } else {
        vm.setCurrentCd(null);
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
}
#end_block

#method_before
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Integer> currVlans, Map<String, Integer> networkVlans, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        if (currVlans.containsKey(iface.getName())) {
            networkVlans.put(net.getName(), currVlans.get(iface.getName()));
        }
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
    }
}
#method_after
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Integer> currVlans, Map<String, Integer> networkVlans, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        if (currVlans.containsKey(iface.getName())) {
            networkVlans.put(net.getName(), currVlans.get(iface.getName()));
        }
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        if (FeatureSupported.hostNetworkQos(Collections.max(host.getSupportedClusterVersionsSet()))) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(network, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            iface.setQos(qosMapper.deserialize());
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.isHostedEngine()) {
                            // The Hosted Engine vm is migrated by the HA agent
                            continue;
                        }
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
private void postGetAttachedTags(VmListModel vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(vmListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(VmListModel vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.gettag_id().equals(tag.gettag_id())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.gettag_id(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(vmListModel.getLastExecutedCommand().getName())) {
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (StringHelper.stringsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (StringHelper.stringsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    StringHelper.stringsEqual(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void changeCD(Object sender, EventArgs e) {
    ChangeCDModel model = (ChangeCDModel) sender;
    // TODO: Patch!
    String isoName = model.getTitle();
    if (ObjectUtils.objectsEqual(isoName, ConstantsManager.getInstance().getConstants().noCds())) {
        return;
    }
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(vm.getId(), // $NON-NLS-1$
    ObjectUtils.objectsEqual(isoName, ConsoleModel.getEjectLabel()) ? "" : isoName) })), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        onExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        onShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        onStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnReboot")) {
        onReboot();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debugFormat("scheduling started, correlation Id: {0}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // it passed filters return it
        if (destHostId != null) {
            for (VDS vds : vdsList) {
                if (destHostId.equals(vds.getId())) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = null;
        if (shouldWeighClusterHosts(cluster, vdsList)) {
            bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        }
        if (bestHost == null && vdsList.size() > 0) {
            bestHost = vdsList.get(0).getId();
        }
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debugFormat("Scheduling ended, correlation Id: {0}", correlationId);
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debugFormat("scheduling started, correlation Id: {0}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        Guid bestHost = null;
        // it passed filters return it
        if (destHostId != null) {
            for (VDS vds : vdsList) {
                if (destHostId.equals(vds.getId())) {
                    bestHost = destHostId;
                    break;
                }
            }
        }
        if (bestHost == null && (policy.getFunctions() == null || policy.getFunctions().isEmpty())) {
            bestHost = vdsList.get(0).getId();
        }
        if (bestHost == null && shouldWeighClusterHosts(cluster, vdsList)) {
            bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        }
        if (bestHost == null && vdsList.size() > 0) {
            bestHost = vdsList.get(0).getId();
        }
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debugFormat("Scheduling ended, correlation Id: {0}", correlationId);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    // create a string of host names
                    final StringBuilder buf = new StringBuilder(returnedFailedHosts.size() * 16);
                    for (int i = 0; i < returnedFailedHosts.size(); i++) {
                        if (i > 0) {
                            buf.append(SEPARATOR);
                        }
                        if (returnedFailedHosts.get(i) != null) {
                            buf.append(returnedFailedHosts.get(i).getName());
                        }
                    }
                    String failedHostsStr = buf.toString();
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
private void validateProvider() throws ManageDomainsResult {
    if (contains(ARG_PROVIDER)) {
        try {
            LdapProviderType.valueOfIgnoreCase(get(ARG_PROVIDER));
        } catch (IllegalArgumentException | NullPointerException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_VALUE, String.format("Invalid provider, valid providers are %s", StringUtils.join(new String[] { PROV_AD, PROV_IPA, PROV_RHDS, PROV_ITDS, PROV_OLDAP }, ", ")));
        }
    }
}
#method_after
private void validateProvider() throws ManageDomainsResult {
    if (contains(ARG_PROVIDER)) {
        try {
            LdapProviderType.valueOfIgnoreCase(get(ARG_PROVIDER));
        } catch (IllegalArgumentException | NullPointerException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_VALUE, String.format("Invalid provider, valid providers are: '%s'.", StringUtils.join(new String[] { PROV_AD, PROV_IPA, PROV_RHDS, PROV_ITDS, PROV_OLDAP }, ", ")));
        }
    }
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#end_block

#method_before
private void initVmInitEnabled(VmInit vmInit) {
    if (vmInit == null) {
        getIsCloudInitEnabled().setEntity(false);
        getIsSysprepEnabled().setEntity(false);
        getAttachFloppy().setEntity(false);
    } else {
        if (getIsWindowsOS()) {
            getIsSysprepEnabled().setEntity(true);
            getAttachFloppy().setEntity(true);
        } else {
            getIsCloudInitEnabled().setEntity(true);
        }
    }
}
#method_after
private void initVmInitEnabled(VmInit vmInit, boolean isInitialized) {
    if (vmInit == null) {
        getIsCloudInitEnabled().setEntity(false);
        getIsSysprepEnabled().setEntity(false);
        getAttachFloppy().setEntity(false);
    } else if (!isInitialized) {
        if (getIsWindowsOS()) {
            getIsSysprepEnabled().setEntity(true);
            getAttachFloppy().setEntity(true);
        } else {
            getIsCloudInitEnabled().setEntity(true);
        }
    }
}
#end_block

#method_before
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Iterable<VmNetworkInterface> nics = (Iterable<VmNetworkInterface>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Iterable<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !((List<VmNetworkInterface>) pluggedNics).isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#method_after
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = (Collection<VmNetworkInterface>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !((List<VmNetworkInterface>) pluggedNics).isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#end_block

#method_before
public void getConfiguration() {
    String currentDomainNameEntry = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomainNameEntry, DOMAIN_SEPERATOR, null);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    Set<String> domainNames = new TreeSet<String>(domainNameEntry.getDomainNames());
    for (String domain : domainNames) {
        String authMode = getDomainAuthMode(domain);
        String userName = adUserNameEntry.getValueForDomain(domain);
        System.out.println("Domain: " + domain);
        System.out.println("\tUser name: " + userName);
    }
}
#method_after
public void getConfiguration() {
    String currentDomainNameEntry = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomainNameEntry, DOMAIN_SEPERATOR, null);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    for (String domain : createDomainNameList(domainNameEntry.getDomainNames(), true)) {
        String authMode = getDomainAuthMode(domain);
        String userName = adUserNameEntry.getValueForDomain(domain);
        System.out.println("Domain: " + domain);
        System.out.println("\tUser name: " + userName);
    }
}
#end_block

#method_before
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    List<Entry<String, String>> gssapiDomainValues = new ArrayList<>(gssapiDomains.getValues());
    if (isValidate) {
        // sort domains so validate report looks better
        Collections.sort(gssapiDomainValues, createDomainComparator());
    }
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName + "\n");
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && args.contains(ARG_REPORT)) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#method_after
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    for (String domain : createDomainNameList(gssapiDomains.getDomainNames(), isValidate)) {
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName + "\n");
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && args.contains(ARG_REPORT)) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#end_block

#method_before
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    List<Entry<String, String>> simpleDomainValues = new ArrayList<>(simpleDomains.getValues());
    if (isValidate) {
        // sort domains so validate report looks better
        Collections.sort(simpleDomainValues, createDomainComparator());
    }
    StringBuffer userGuid = new StringBuffer();
    for (Entry<String, String> currDomain : simpleDomainValues) {
        String domain = currDomain.getKey();
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (args.contains(ARG_REPORT)) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#method_after
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    StringBuffer userGuid = new StringBuffer();
    for (String domain : createDomainNameList(simpleDomains.getDomainNames(), isValidate)) {
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (args.contains(ARG_REPORT)) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#end_block

#method_before
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warnFormat("Could not live snapshot due to error: {0}. VM will still be configured to the new created snapshot", ExceptionUtils.getMessage(e));
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#method_after
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warnFormat("Could not perform live snapshot due to error: {0}. VM will still be configured to the new created snapshot", ExceptionUtils.getMessage(e));
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#end_block

#method_before
public void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, PersistentSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (!NetworkUtils.isLabeled(nic)) {
        return;
    }
    for (String label : nic.getLabels()) {
        // configure networks by target cluster assignment
        List<Network> targetLabeledNetworks = targetNetworksByLabel.get(label);
        if (targetLabeledNetworks != null) {
            for (Network net : targetLabeledNetworks) {
                if (targetNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                    configureNetwork(nic, params.getInterfaces(), net);
                } else if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
        // remove labeled networks originated in source cluster but not assigned to target cluster
        List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
        if (sourceLabeledNetworks != null) {
            for (Network net : sourceLabeledNetworks) {
                if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
    }
}
#method_after
public void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, PersistentSetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (!NetworkUtils.isLabeled(nic)) {
        return;
    }
    for (String label : nic.getLabels()) {
        // remove labeled networks originated in source cluster but not assigned to target cluster
        List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
        if (sourceLabeledNetworks != null) {
            for (Network net : sourceLabeledNetworks) {
                if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
        // configure networks by target cluster assignment
        List<Network> targetLabeledNetworks = targetNetworksByLabel.get(label);
        if (targetLabeledNetworks != null) {
            for (Network net : targetLabeledNetworks) {
                if (targetNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                    configureNetwork(nic, params.getInterfaces(), net);
                } else if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
    }
}
#end_block

#method_before
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    model.setHelpTag(HelpTag.new_data_center);
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setEntity(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_data_center");
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDataCenterTitle());
    model.setHelpTag(HelpTag.remove_data_center);
    // $NON-NLS-1$
    model.setHashName("remove_data_center");
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void forceRemove() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceRemoveDataCenterTitle());
    // $NON-NLS-1$
    model.setHashName("force_remove_data_center");
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnForceRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void forceRemove() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().forceRemoveDataCenterTitle());
    model.setHelpTag(HelpTag.force_remove_data_center);
    // $NON-NLS-1$
    model.setHashName("force_remove_data_center");
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    ArrayList<String> list = new ArrayList<String>();
    for (StoragePool a : Linq.<StoragePool>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnForceRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#method_after
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#end_block

#method_before
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg());
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#method_after
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        confirmModel.setHelpTag(HelpTag.change_data_center_compatibility_version);
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    Version v = VersionStorageFormatUtil.getEarliestVersionSupported(newFormat);
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg(v.getValue()));
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#end_block

#method_before
private void promptNoQuotaInDCMessage() {
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDCQuotaEnforcementModeTitle());
    // $NON-NLS-1$
    confirmModel.setHashName("change_data_center_quota_enforcement_mode");
    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDCQuotaEnforcementMsg());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSaveInternal", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    getConfirmWindow().getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("CancelConfirmation", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    getConfirmWindow().getCommands().add(tempVar2);
}
#method_after
private void promptNoQuotaInDCMessage() {
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDCQuotaEnforcementModeTitle());
    confirmModel.setHelpTag(HelpTag.change_data_center_quota_enforcement_mode);
    // $NON-NLS-1$
    confirmModel.setHashName("change_data_center_quota_enforcement_mode");
    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDCQuotaEnforcementMsg());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSaveInternal", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    getConfirmWindow().getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("CancelConfirmation", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    getConfirmWindow().getCommands().add(tempVar2);
}
#end_block

#method_before
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    AsyncDataProvider.getDataCenterStorageConnectionsByType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
            iscsiBondListModel.setIsAvailable(!connections.isEmpty());
        }
    }), storagePool.getId(), StorageType.ISCSI);
}
#method_after
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    AsyncDataProvider.getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            boolean hasIscsiStorage = false;
            ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
            for (StorageServerConnections connection : connections) {
                if (connection.getstorage_type() == StorageType.ISCSI) {
                    hasIscsiStorage = true;
                    break;
                }
            }
            iscsiBondListModel.setIsAvailable(hasIscsiStorage);
        }
    }), storagePool.getId(), StorageType.ISCSI);
}
#end_block

#method_before
private void initializeStorageTargetsList() {
    AsyncDataProvider.getDataCenterStorageConnectionsByType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<StorageServerConnections> selected = new ArrayList<StorageServerConnections>();
            ArrayList<StorageServerConnections> conns = (ArrayList<StorageServerConnections>) returnValue;
            Set<String> iscsiBonded = isBondExist() ? new HashSet<String>(getIscsiBond().getStorageConnectionIds()) : Collections.<String>emptySet();
            for (StorageServerConnections conn : conns) {
                if (iscsiBonded.contains(conn.getid())) {
                    selected.add(conn);
                }
            }
            IscsiBondModel model = (IscsiBondModel) target;
            model.getStorageTargets().setItems(conns);
            model.getStorageTargets().setSelectedItems(selected);
        }
    }), getStoragePool().getId(), StorageType.ISCSI);
}
#method_after
private void initializeStorageTargetsList() {
    AsyncDataProvider.getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<StorageServerConnections> selected = new ArrayList<StorageServerConnections>();
            ArrayList<StorageServerConnections> conns = (ArrayList<StorageServerConnections>) returnValue;
            Set<String> iscsiBonded = isBondExist() ? new HashSet<String>(getIscsiBond().getStorageConnectionIds()) : Collections.<String>emptySet();
            for (StorageServerConnections conn : conns) {
                if (iscsiBonded.contains(conn.getid())) {
                    selected.add(conn);
                }
            }
            IscsiBondModel model = (IscsiBondModel) target;
            model.getStorageTargets().setItems(conns);
            model.getStorageTargets().setSelectedItems(selected);
        }
    }), getStoragePool().getId(), StorageType.ISCSI);
}
#end_block

#method_before
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Iterable<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI }));
    return diskInterfaces;
}
#method_after
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            HashMap<Integer, String> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            String defaultValue = result.get(DEFAULT_OS_ID);
            osNames = new MapWithDefaults<Integer, String>(result, defaultValue);
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Integer, Map<Version, List<DisplayType>>> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            displayTypes = new MapWithDefaults<Integer, Map<Version, List<DisplayType>>>(result, result.get(DEFAULT_OS_ID));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
@Test
public void testgetAllConnectableStorageSeverConnectionWithNoConnections() {
    List<StorageServerConnections> result = dao.getConnectableStorageConnectionsByStorageType(Guid.newGuid(), null);
    assertNotNull(result);
    assertTrue(result.isEmpty());
}
#method_after
@Test
public void testgetAllConnectableStorageSeverConnectionWithNoConnections() {
    List<StorageServerConnections> result = dao.getAllConnectableStorageSeverConnection(Guid.newGuid());
    assertNotNull(result);
    assertTrue(result.isEmpty());
}
#end_block

#method_before
@Test
public void testGetAllConnectableStorageSeverConnections() {
    List<StorageServerConnections> result = dao.getConnectableStorageConnectionsByStorageType(EXISTING_STORAGE_POOL_ID, null);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllConnectableStorageSeverConnections() {
    List<StorageServerConnections> result = dao.getAllConnectableStorageSeverConnection(EXISTING_STORAGE_POOL_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause((Boolean) getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless((Boolean) getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties((String) getCustomProperties().getEntity());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setkernel_url((String) getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setkernel_params((String) getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setinitrd_url((String) getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName((String) getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword((String) getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = (String) getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause((Boolean) getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless((Boolean) getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties((String) getCustomProperties().getEntity());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl((String) getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams((String) getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl((String) getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName((String) getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword((String) getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = (String) getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#end_block

#method_before
public static void updateVmInitFromDB(VmBase vm, boolean secure) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    vm.setVmInit(db.get(vm.getId()));
    if (secure && vm.getVmInit() != null) {
        vm.getVmInit().setPasswordSet(!StringUtils.isEmpty(vm.getVmInit().getRootPassword()));
        vm.getVmInit().setRootPassword(null);
    }
}
#method_after
public static void updateVmInitFromDB(VmBase vm, boolean secure) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    vm.setVmInit(db.get(vm.getId()));
    if (vm.getVmInit() != null) {
        if (secure) {
            vm.getVmInit().setPasswordAlreadyStored(!StringUtils.isEmpty(vm.getVmInit().getRootPassword()));
            vm.getVmInit().setRootPassword(null);
        } else {
            vm.getVmInit().setPasswordAlreadyStored(false);
        }
    }
}
#end_block

#method_before
public static void addVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        vm.getVmInit().setId(vm.getId());
        VmInitDAO db = DbFacade.getInstance().getVmInitDao();
        VmInit oldVmInit = db.get(vm.getId());
        if (oldVmInit == null) {
            db.save(vm.getVmInit());
        } else {
            if (vm.getVmInit().isPasswordSet()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vm.getVmInit().setRootPassword(oldVmInit.getRootPassword());
            }
            db.update(vm.getVmInit());
        }
    }
}
#method_after
public static void addVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        vm.getVmInit().setId(vm.getId());
        VmInitDAO db = DbFacade.getInstance().getVmInitDao();
        VmInit oldVmInit = db.get(vm.getId());
        if (oldVmInit == null) {
            db.save(vm.getVmInit());
        } else {
            if (vm.getVmInit().isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vm.getVmInit().setRootPassword(oldVmInit.getRootPassword());
            }
            db.update(vm.getVmInit());
        }
    }
}
#end_block

#method_before
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, long sizeRequested, Map<StorageDomain, Integer> domain2reservedSpaceInDomain) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    for (StorageDomain currDomain : domainsInPool) {
        long reservedSizeForDisks = domain2reservedSpaceInDomain.containsKey(currDomain) ? domain2reservedSpaceInDomain.get(currDomain) : 0;
        long sizeNeeded = sizeRequested + reservedSizeForDisks;
        if ((currDomain.getStorageDomainType().equals(StorageDomainType.Master) || currDomain.getStorageDomainType().equals(StorageDomainType.Data)) && currDomain.getStatus() == StorageDomainStatus.Active && doesStorageDomainHaveSpaceForRequest(currDomain, sizeNeeded)) {
            return currDomain;
        }
    }
    return null;
}
#method_after
public static StorageDomain findStorageDomainForMemory(Guid storagePoolId, long sizeRequested, Map<StorageDomain, Integer> domain2reservedSpaceInDomain) {
    List<StorageDomain> domainsInPool = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePoolId);
    for (StorageDomain currDomain : domainsInPool) {
        long reservedSizeForDisks = domain2reservedSpaceInDomain.containsKey(currDomain) ? domain2reservedSpaceInDomain.get(currDomain) : 0;
        long sizeNeeded = sizeRequested + reservedSizeForDisks;
        if (currDomain.getStorageDomainType().isDataDomain() && currDomain.getStatus() == StorageDomainStatus.Active && doesStorageDomainHaveSpaceForRequest(currDomain, sizeNeeded)) {
            return currDomain;
        }
    }
    return null;
}
#end_block

#method_before
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    // if not proven to be hidden, show it
    boolean isWindows = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    getDomain().setIsAvailable(isWindows);
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordSet());
        getPasswordSet().setIsChangable(vmInit.isPasswordSet());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#method_after
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    // if not proven to be hidden, show it
    boolean isWindows = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    getDomain().setIsAvailable(isWindows);
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname((String) getHostname().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordSet((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname((String) getHostname().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.PERSIST_NETWORK_ON_HOST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            } else {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
            }
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            }
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl();
    } catch (SQLException e) {
        throw new ManageDomainsResult("Please verify the following:\n1. Your database credentials are valid.\n2. The database machine is accessible.\n3. The database service is running", ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#method_after
public void init() throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(args.get(ARG_CONFIG_FILE));
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl();
    } catch (SQLException e) {
        throw new ManageDomainsResult("Please verify the following:\n1. Your database credentials are valid.\n2. The database machine is accessible.\n3. The database service is running", ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#end_block

#method_before
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    util = new ManageDomains();
    CLIParser parser = new CLIParser(args);
    String configFilePath = CONF_FILE_PATH;
    if (parser.hasArg(Arguments.configFile.name())) {
        configFilePath = parser.getArg(Arguments.configFile.name());
    }
    if (parser.hasArg(Arguments.report.name())) {
        util.reportAllErrors = true;
    }
    if (parser.hasArg(Arguments.addPermissions.name())) {
        util.addPermissions = true;
    }
    try {
        // it's existence is checked during the parser validation
        String engineConfigProperties = parser.getArg(Arguments.propertiesFile.name());
        util.init(configFilePath);
        util.validate(parser);
        util.createConfigurationProvider(engineConfigProperties);
        util.runCommand(parser);
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    try {
        ManageDomainsArguments mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
            System.exit(0);
        } else {
            util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#end_block

#method_before
private void createConfigurationProvider(String engineConfigProperties) throws ManageDomainsResult {
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#method_after
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        if (changePasswordUrl == null) {
            changePasswordUrl = "";
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser);
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.hasArg(Arguments.forceDelete.name()));
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
}
#method_after
private void runCommand() throws ManageDomainsResult {
    String action = args.get(ARG_ACTION);
    if (ACTION_ADD.equals(action)) {
        addDomain();
    } else if (ACTION_EDIT.equals(action)) {
        editDomain();
    } else if (ACTION_DELETE.equals(action)) {
        deleteDomain();
    } else if (ACTION_VALIDATE.equals(action)) {
        validate();
    } else if (ACTION_LIST.equals(action)) {
        getConfiguration();
    }
}
#end_block

#method_before
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#method_after
private String getPasswordInput() throws ManageDomainsResult {
    String pass = null;
    if (args.contains(ARG_PASSWORD_FILE)) {
        try {
            pass = readPasswordFile(args.get(ARG_PASSWORD_FILE));
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else {
        pass = readInteractively("Enter password:", true);
    }
    validatePassword(pass);
    return pass;
}
#end_block

#method_before
protected List<String> getLdapServers(CLIParser parser, String domainName) throws ManageDomainsResult {
    String argValue = parser.getArg(Arguments.ldapServers.toString().toLowerCase());
    if (StringUtils.isEmpty(argValue)) {
        LdapSRVLocator locator = new LdapSRVLocator();
        DnsSRVResult ldapDnsResult = null;
        boolean foundServers = true;
        try {
            InetAddress ia = InetAddress.getByName(domainName);
            ia.getCanonicalHostName();
        } catch (UnknownHostException e) {
            foundServers = false;
        }
        try {
            ldapDnsResult = locator.getLdapServers(domainName);
            if (!foundSrvRecords(ldapDnsResult)) {
                foundServers = false;
            }
        } catch (Exception ex) {
            foundServers = false;
        }
        if (!foundServers) {
            throw new ManageDomainsResult("Could not locate LDAP servers to be used to validate the input of the utility", ManageDomainsResultEnum.NO_LDAP_SERVERS_FOR_DOMAIN, domainName);
        }
        ArrayList<String> result = new ArrayList<String>();
        for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
            result.add(ldapDnsResult.getAddresses()[counter]);
        }
        return result;
    }
    return new ArrayList<String>(Arrays.asList(argValue.split(",")));
}
#method_after
protected List<String> getLdapServers(String domainName) throws ManageDomainsResult {
    ArrayList<String> servers = new ArrayList<String>();
    String argValue = args.get(ARG_LDAP_SERVERS);
    if (StringUtils.isEmpty(argValue)) {
        LdapSRVLocator locator = new LdapSRVLocator();
        DnsSRVResult ldapDnsResult = null;
        boolean foundServers = true;
        try {
            ldapDnsResult = locator.getLdapServers(domainName);
            if (!foundSrvRecords(ldapDnsResult)) {
                foundServers = false;
            }
        } catch (Exception ex) {
            foundServers = false;
        }
        if (!foundServers) {
            throw new ManageDomainsResult("Could not locate LDAP servers to be used to validate the input of the utility", ManageDomainsResultEnum.NO_LDAP_SERVERS_FOR_DOMAIN, domainName);
        }
        for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
            // In case the address provides a port, don't keep it, we currently assume only the port
            // defined at ConfigValues.ldapServerPort is being used.
            String[] addressParts = ldapDnsResult.getAddresses()[counter].split(":");
            servers.add(addressParts[0]);
        }
    } else {
        servers = new ArrayList<String>(Arrays.asList(argValue.split(",")));
        for (String server : servers) {
            try {
                for (InetAddress ip : InetAddress.getAllByName(server)) {
                    ip.getCanonicalHostName();
                    log.debug(String.format("Successfuly resolved IP '%s' for server '%s'", ip.getHostAddress(), server));
                }
            } catch (Exception ex) {
                String msg = String.format("Cannot resolve LDAP server hostname '%s'. Details: %s,", server, ex.getMessage());
                log.warn(msg, ex);
                System.err.println(msg);
            }
        }
    }
    return servers;
}
#end_block

#method_before
public void addDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    adUserNameEntry.setValueForDomain(domainName, parser.getArg(Arguments.user.toString()));
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput(parser));
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    String ldapServersStr = parser.getArg(Arguments.ldapServers.name());
    if (!StringUtils.isEmpty(ldapServersStr)) {
        // Replacing "," with ";" - from user perspective of the utility, passing comma delimited string makes more sense and more natural
        // But "," is used as domain separate character when storing to DB.
        ldapServersStr = ldapServersStr.replace(',', ';');
        ldapServersEntry.setValueForDomain(domainName, ldapServersStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = null;
    try {
        changePasswordUrlStr = getChangePasswordMsg();
    } catch (UnsupportedEncodingException e) {
        log.error("Error in encoding the change password message. ", e);
    }
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
private void printSuccessMessage(String domainName, String action) {
    if (addPermissions) {
        System.out.print(String.format(SUCCESS_MESSAGE_FOR_ACTION_WITH_ADD_PERMISSIONS, "added", domainName));
    }
    System.out.println(SERVICE_RESTART_MESSAGE);
}
#method_after
private void printSuccessMessage(String domainName, String action) {
    if (args.contains(ARG_ADD_PERMISSIONS)) {
        System.out.print(String.format(SUCCESS_MESSAGE_FOR_ACTION_WITH_ADD_PERMISSIONS, "added", domainName));
    }
    System.out.println(SERVICE_RESTART_MESSAGE);
}
#end_block

#method_before
private void handleAddPermissions(String domainName, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUserIdEntry) {
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else if (!userHasPermissions(adUserNameEntry, adUserIdEntry)) {
        System.out.println(String.format(INFO_ABOUT_NOT_ADDING_PERMISSIONS, domainName));
    }
}
#method_after
private void handleAddPermissions(String domainName, String userName, String userId) {
    if (args.contains(ARG_ADD_PERMISSIONS)) {
        updatePermissionsTable(userName, domainName, userId);
    } else if (!userHasPermissions(userName, domainName)) {
        System.out.println(String.format(INFO_ABOUT_NOT_ADDING_PERMISSIONS, domainName));
    }
}
#end_block

#method_before
private ManageDomainsResult updatePermissionsTable(DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUseridEntry) {
    try {
        Set<Entry<String, String>> userNameValues = adUserNameEntry.getValues();
        for (Entry<String, String> currUserEntry : userNameValues) {
            String currDomain = currUserEntry.getKey();
            String currUser = currUserEntry.getValue();
            String guid = adUseridEntry.getValueForDomain(currDomain);
            daoImpl.updatePermissionsTable(guid, currUser, currDomain);
        }
        return OK_RESULT;
    } catch (SQLException e) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_CHANGES_IN_DATABASE, e.getMessage());
    }
}
#method_after
private ManageDomainsResult updatePermissionsTable(String userName, String domainName, String adUserId) {
    try {
        daoImpl.updatePermissionsTable(adUserId, userName, domainName);
        return OK_RESULT;
    } catch (SQLException e) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_CHANGES_IN_DATABASE, e.getMessage());
    }
}
#end_block

#method_before
private boolean userHasPermissions(DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUseridEntry) {
    try {
        Set<Entry<String, String>> userNameValues = adUserNameEntry.getValues();
        for (Entry<String, String> currUserEntry : userNameValues) {
            String currDomain = currUserEntry.getKey();
            String currUser = currUserEntry.getValue();
            if (daoImpl.getUserHasPermissions(currUser, currDomain)) {
                return true;
            }
        }
    } catch (SQLException e) {
        log.error(e);
    }
    return false;
}
#method_after
private boolean userHasPermissions(String userName, String domainName) {
    boolean result = false;
    try {
        result = daoImpl.getUserHasPermissions(userName, domainName);
    } catch (SQLException ex) {
        log.error("Error testing user permissions", ex);
    }
    return result;
}
#end_block

#method_before
public void editDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode;
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    authMode = getDomainAuthMode(domainName);
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = parser.getArg(Arguments.user.toString());
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput(parser);
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    printSuccessMessage(domainName, "edited");
}
#method_after
public void editDomain() throws ManageDomainsResult {
    String authMode;
    String domainName = args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.contains(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.contains(ARG_PROVIDER)) {
        ldapProviderType = args.getLdapProvider();
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        try {
            changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordMsg());
        } catch (UnsupportedEncodingException e) {
            log.error("Error in encoding the change password message. ", e);
        }
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#end_block

#method_before
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#method_after
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (!args.contains(ARG_LDAP_SERVERS) && useDnsLookup) {
                // The arguments do not contain a list of ldap servers, the
                // kerberos configuration should not be created according to it if
                // useDnsLookup is set to true as in this case the kdc and the domain_realm information
                // will be resolved by DNS during kerberos negotiation.
                ldapServersPerGSSAPIDomains = Collections.emptyMap();
            }
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#end_block

#method_before
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    Set<Entry<String, String>> gssapiDomainValues = gssapiDomains.getValues();
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName);
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && reportAllErrors) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#method_after
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, Map<String, List<String>> ldapServersPerDomainMap, String kerberosConfigFile, String ldapServerPort, boolean isValidate, List<String> ldapServers) throws ManageDomainsResult {
    Set<Entry<String, String>> gssapiDomainValues = gssapiDomains.getValues();
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            List<String> ldapServersPerDomain = ldapServersPerDomainMap.get(domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck(ldapServersPerDomain, ldapServerPort);
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
                System.out.println("The configured user for domain " + domain + " is " + currUserName);
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && args.contains(ARG_REPORT)) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#end_block

#method_before
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    Set<Entry<String, String>> simpleDomainValues = simpleDomains.getValues();
    StringBuffer userGuid = new StringBuffer();
    for (Entry<String, String> currDomain : simpleDomainValues) {
        String domain = currDomain.getKey();
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (reportAllErrors) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#method_after
private void checkSimpleDomains(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry simpleDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderType, Map<String, List<String>> ldapServersMapPerDomainMap, boolean isValidate) throws ManageDomainsResult {
    Set<Entry<String, String>> simpleDomainValues = simpleDomains.getValues();
    StringBuffer userGuid = new StringBuffer();
    for (Entry<String, String> currDomain : simpleDomainValues) {
        String domain = currDomain.getKey();
        List<String> domainLdapServers = ldapServersMapPerDomainMap.get(domain);
        ManageDomainsResult result = checkSimple(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), userGuid, LdapProviderType.valueOf(ldapProviderType.getValueForDomain(domain)), domainLdapServers);
        if (!result.isSuccessful()) {
            if (isValidate || ((domainName != null) && !domain.equals(domainName))) {
                if (args.contains(ARG_REPORT)) {
                    System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
                } else {
                    throw result;
                }
            } else {
                throw result;
            }
        } else {
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
        }
    }
}
#end_block

#method_before
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
}
#method_after
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordMsg, changePasswordUrlEntry);
    }
}
#end_block

#method_before
public void deleteDomain(String domainName, boolean forceDelete) throws ManageDomainsResult {
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !forceDelete) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!forceDelete && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#method_after
public void deleteDomain() throws ManageDomainsResult {
    String domainName = args.get(ARG_DOMAIN).toLowerCase();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !args.contains(ARG_FORCE)) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!args.contains(ARG_FORCE) && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String changePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(changePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    changePasswordUrlEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePasswordUrlEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#end_block

#method_before
private boolean confirmDeleteDomain(String domainName) {
    String response = null;
    while (StringUtils.isBlank(response) || (!StringUtils.equalsIgnoreCase(response, "yes") && !StringUtils.equalsIgnoreCase(response, "no"))) {
        System.out.println("Are you sure you like to delete domain " + domainName + " (yes/no) : ");
        response = System.console().readLine();
    }
    return response.equals("yes");
}
#method_after
private boolean confirmDeleteDomain(String domainName) {
    String response = null;
    while (StringUtils.isBlank(response) || (!StringUtils.equalsIgnoreCase(response, "yes") && !StringUtils.equalsIgnoreCase(response, "no"))) {
        System.out.print("Are you sure you like to delete domain " + domainName + " (yes/no): ");
        response = System.console().readLine();
    }
    return response.equals("yes");
}
#end_block

#method_before
private static void deleteFile(String filePath) {
    File file = new File(filePath);
    if (file.exists()) {
        file.delete();
    }
}
#method_after
private static void deleteFile(String filePath) {
    File file = new File(filePath);
    if (file.exists()) {
        if (!file.delete()) {
            log.info("Failed deleting file " + file.getAbsolutePath() + ". Continuing anyway.");
        }
    }
}
#end_block

#method_before
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (!ldapServers && useDnsLookup) {
                // The arguments do not contain a list of ldap servers, the 725
                // kerberos configuration should not be created according to it if 726
                // useDnsLookup is set to true as in this case the kdc and the domain_realm info
                ldapServersPerGSSAPIDomains = Collections.emptyMap();
            }
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#method_after
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (!ldapServers && useDnsLookup) {
                // The arguments do not contain a list of ldap servers, the
                // kerberos configuration should not be created according to it if
                // useDnsLookup is set to true as in this case the kdc and the domain_realm info
                ldapServersPerGSSAPIDomains = Collections.emptyMap();
            }
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<IVdcQueryable>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            {
                returnValue = searchVmsFromDb();
                break;
            }
        case AdGroup:
            {
                returnValue = searchAdGroups();
                break;
            }
        case AdUser:
            {
                returnValue = searchAdUsers();
                break;
            }
        case AuditLog:
            {
                returnValue = searchAuditLogEvents();
                break;
            }
        case DBUser:
            {
                returnValue = searchDbUsers();
                break;
            }
        case VDS:
            {
                returnValue = searchVDSsByDb();
                break;
            }
        case VmTemplate:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case VmPools:
            {
                returnValue = searchVmPools();
                break;
            }
        case Cluster:
            {
                returnValue = searchClusters();
                break;
            }
        case StoragePool:
            {
                returnValue = searchStoragePool();
                break;
            }
        case StorageDomain:
            {
                returnValue = searchStorageDomain();
                break;
            }
        case Quota:
            {
                returnValue = searchQuota();
                break;
            }
        case Disk:
            {
                returnValue = searchDisk();
                break;
            }
        case GlusterVolume:
            {
                returnValue = searchGlusterVolumes();
                break;
            }
        case Network:
            {
                returnValue = searchNetworks();
                break;
            }
        case Provider:
            {
                returnValue = searchProviders();
                break;
            }
        case InstanceType:
            {
                returnValue = searchInstanceTypes();
                break;
            }
        case ImageType:
            {
                returnValue = searchVMTemplates();
                break;
            }
        default:
            {
                log.errorFormat("Search object type not handled: {0}", getParameters().getSearchTypeValue());
                break;
            }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<IVdcQueryable>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            {
                returnValue = searchVmsFromDb();
                break;
            }
        case DirectoryGroup:
            {
                returnValue = searchDirectoryGroups();
                break;
            }
        case DirectoryUser:
            {
                returnValue = searchDirectoryUsers();
                break;
            }
        case AuditLog:
            {
                returnValue = searchAuditLogEvents();
                break;
            }
        case DBUser:
            {
                returnValue = searchDbUsers();
                break;
            }
        case DBGroup:
            {
                returnValue = searchDbGroups();
                break;
            }
        case VDS:
            {
                returnValue = searchVDSsByDb();
                break;
            }
        case VmTemplate:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case VmPools:
            {
                returnValue = searchVmPools();
                break;
            }
        case Cluster:
            {
                returnValue = searchClusters();
                break;
            }
        case StoragePool:
            {
                returnValue = searchStoragePool();
                break;
            }
        case StorageDomain:
            {
                returnValue = searchStorageDomain();
                break;
            }
        case Quota:
            {
                returnValue = searchQuota();
                break;
            }
        case Disk:
            {
                returnValue = searchDisk();
                break;
            }
        case GlusterVolume:
            {
                returnValue = searchGlusterVolumes();
                break;
            }
        case Network:
            {
                returnValue = searchNetworks();
                break;
            }
        case Provider:
            {
                returnValue = searchProviders();
                break;
            }
        case InstanceType:
            {
                returnValue = searchInstanceTypes();
                break;
            }
        case ImageType:
            {
                returnValue = searchVMTemplates();
                break;
            }
        default:
            {
                log.errorFormat("Search object type not handled: {0}", getParameters().getSearchTypeValue());
                break;
            }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#end_block

#method_before
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.UpdateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#method_after
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.updateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().Subtract(data.getDate());
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.CreateADSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.CreateBackendSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Config.<Integer>GetValue(ConfigValues.SearchResultsLimit) : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), searchObj.getSearchObjectStr(), new Date(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            int maxValue = Integer.MAX_VALUE;
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? maxValue : Math.min(maxValue, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
protected String getDefaultDomain() {
    return LdapBrokerUtils.getDomainsList().get(0);
}
#method_after
protected String getDefaultDomain() {
    return DirectoryManager.getInstance().getDirectories().get(0).getName();
}
#end_block

#method_before
private static String getQuotaRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.QUOTA_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.QUOTA_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getQuotaRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.QUOTA_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.QUOTA_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getDiskImageRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.DISK_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.DISK_OBJ_NAME) + ".* ";
    System.out.println("DiskImageRegExp: " + query);
    return query;
}
#method_after
private static String getDiskImageRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.DISK_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.DISK_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVMRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VM_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VM_OBJ_NAME) + ".* ";
    System.out.println("VMRegExp: " + query);
    return query;
}
#method_after
private static String getVMRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VM_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VM_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVdsRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VDS_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VDS_OBJ_NAME) + ".* ";
    System.out.println("VdsRegExp: " + query);
    return query;
}
#method_after
private static String getVdsRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDS_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDS_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getVdsGroupRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VDC_CLUSTER_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VDC_CLUSTER_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getVdsGroupRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_CLUSTER_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDC_CLUSTER_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getStoragePoolRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getStoragePoolRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.VDC_STORAGE_POOL_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
// return ".*" + search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*"
// + search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".* "
// + search.getPrimeryKeyName(SearchObjects.GLUSTER_VOLUME_OBJ_NAME) + ".*";
}
#method_after
private static String getGlusterVolumeRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.GLUSTER_VOLUME_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.GLUSTER_VOLUME_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private static String getNetworkRegexString(SearchObjectAutoCompleter search) {
    String query = ".*" + search.getDefaultSort(SearchObjects.NETWORK_OBJ_NAME) + ".*" + search.getRelatedTableNameWithOutTags(SearchObjects.NETWORK_OBJ_NAME) + ".* ";
    System.out.println("VdsGroupRegExp: " + query);
    return query;
}
#method_after
private static String getNetworkRegexString(SearchObjectAutoCompleter search) {
    StringBuilder query = new StringBuilder();
    query.append(".*").append(search.getDefaultSort(SearchObjects.NETWORK_OBJ_NAME)).append(".*").append(search.getRelatedTableNameWithOutTags(SearchObjects.NETWORK_OBJ_NAME)).append(".* ");
    return query.toString();
}
#end_block

#method_before
private SqlInjectionChecker getSqlInjectionChecker() throws Exception {
    // GWT lacks support of reflection.
    if (((String) Config.GetValue(ConfigValues.DBEngine)).equalsIgnoreCase("postgres")) {
        return new PostgresSqlInjectionChecker();
    } else {
        throw new IllegalStateException("Failed to get correct sql injection checker instance name :" + SqlInjectionChecker.class);
    }
}
#method_after
private SqlInjectionChecker getSqlInjectionChecker() throws Exception {
    // GWT lacks support of reflection.
    if (((String) Config.getValue(ConfigValues.DBEngine)).equalsIgnoreCase("postgres")) {
        return new PostgresSqlInjectionChecker();
    } else {
        throw new IllegalStateException("Failed to get correct sql injection checker instance name :" + SqlInjectionChecker.class);
    }
}
#end_block

#method_before
@Override
public SyntaxContainer analyzeSyntaxState(final String searchText, boolean final2) {
    final SyntaxContainer syntaxContainer = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter curConditionFieldAC = null;
    IAutoCompleter curConditionRelationAC = null;
    final List<String> freeTextObjSearched = new ArrayList<String>();
    char[] searchCharArr = searchText.toCharArray();
    int curStartPos = 0;
    String tryNextObj = "";
    boolean keepValid;
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        final SyntaxObjectType curState = syntaxContainer.getState();
        final char curChar = searchCharArr[idx];
        if (mDisAllowedChars.contains(curChar)) {
            syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
            return syntaxContainer;
        }
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION) && (curState != SyntaxObjectType.COLON) && (curState != SyntaxObjectType.CONDITION_VALUE) && (curState != SyntaxObjectType.OR) && (curState != SyntaxObjectType.AND)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return syntaxContainer;
                    }
                } else {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    syntaxContainer.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case CROSS_REF_OBJ:
                String curRefObj = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                }
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (mDotAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.DOT, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!"".equals(tryNextObj)) && (curConditionRelationAC.validate(tryNextObj))) {
                    // i.e. the relation object has another charecter
                    break;
                } else if (curConditionRelationAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!curConditionRelationAC.validateCompletion(nextObject)) && (!mDotAC.validateCompletion(nextObject))) {
                    syntaxContainer.setErr(SyntaxError.INVALID_POST_CROSS_REF_OBJ, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                tryNextObj = "";
                break;
            case DOT:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                if (curConditionFieldAC == null) {
                    syntaxContainer.setErr(SyntaxError.CANT_GET_CONDITION_FIELD_AC, curStartPos, idx);
                    return syntaxContainer;
                }
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                }
                break;
            case AND:
            case OR:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject, syntaxContainer);
                    curStartPos = tempRefObject.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            curRefObj = syntaxContainer.getSearchObjectStr();
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                            syntaxContainer.setvalid(true);
                            keepValid = true;
                        }
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_OR_AND_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case COLON:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSortbyAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mPageAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject2 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject2, syntaxContainer);
                    curStartPos = tempRefObject2.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            freeTextObjSearched.add(syntaxContainer.getSearchObjectStr());
                        }
                        keepValid = true;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_COLON_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case CONDITION_VALUE:
                nextObject = nextObject.trim();
                if (nextObject.length() > 0) {
                    keepValid = false;
                    curRefObj = syntaxContainer.getSearchObjectStr();
                    curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                    if (curConditionFieldAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSortbyAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mPageAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                        if (// Check that this
                        searchCharArr.length >= idx + 2) // maybe a
                        // plural
                        {
                            // Validate that the next character is an 's'
                            if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                                // Then just move things along.
                                idx++;
                                StringBuilder sb = new StringBuilder(nextObject);
                                sb.append('S');
                                nextObject = sb.toString();
                            }
                        }
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mAndAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.AND, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mOrAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.OR, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject)) && (!mAndAC.validateCompletion(nextObject)) && (!mOrAC.validateCompletion(nextObject))) {
                        RefObject<Integer> tempRefObject3 = new RefObject<Integer>(curStartPos);
                        ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject3, syntaxContainer);
                        curStartPos = tempRefObject3.argvalue;
                        if (ans != ValueParseResult.Err) {
                            if (ans == ValueParseResult.FreeText) {
                                if (freeTextObjSearched.contains(curRefObj)) {
                                    syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                    return syntaxContainer;
                                }
                                freeTextObjSearched.add(curRefObj);
                                syntaxContainer.setvalid(true);
                                keepValid = true;
                            }
                        } else {
                            syntaxContainer.setErr(SyntaxError.INVALID_POST_CONDITION_VALUE_PHRASE, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                    }
                    if (keepValid == false) {
                        syntaxContainer.setvalid(false);
                    }
                }
                break;
            case CONDITION_FIELD:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                String curConditionField = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                curConditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(curRefObj, curConditionField);
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (curConditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!curConditionRelationAC.validate(nextObject)) {
                    if (!curConditionRelationAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                syntaxContainer.setvalid(false);
                tryNextObj = "";
                break;
            case CONDITION_RELATION:
                {
                    RefObject<Integer> tempRefObject4 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject4, syntaxContainer);
                    curStartPos = tempRefObject4.argvalue;
                    if (ans == ValueParseResult.Err) {
                        return syntaxContainer;
                    }
                    if (ans == ValueParseResult.FreeText) {
                        if (syntaxContainer.getPreviousSyntaxObjectType(2) == SyntaxObjectType.CROSS_REF_OBJ) {
                            curRefObj = syntaxContainer.getObjSingularName(syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ));
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                        }
                    }
                }
                break;
            case SORTBY:
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_FIELD, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE:
                Integer pageNumber = IntegerCompat.tryParse(nextObject);
                if (pageNumber == null) {
                    syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
                    return syntaxContainer;
                } else {
                    final StringBuilder buff = new StringBuilder();
                    int pos = idx;
                    // parsing the whole page number (can be more than one char)
                    while (pos < searchText.length() - 1 && Character.isDigit(nextObject.charAt(0))) {
                        buff.append(nextObject);
                        pos++;
                        strRealObj = searchText.substring(pos, pos + 1);
                        nextObject = strRealObj.toUpperCase();
                    }
                    buff.append(nextObject);
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE_VALUE, buff.toString(), curStartPos, idx + buff.length());
                    // update index position
                    idx = pos + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case SORT_FIELD:
                if (!mSortDirectionAC.validate(nextObject)) {
                    if (!mSortDirectionAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_DIRECTION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_DIRECTION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE_VALUE:
                if (curChar != ' ') {
                    syntaxContainer.setErr(SyntaxError.NOTHING_COMES_AFTER_PAGE_VALUE, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                break;
            case SORT_DIRECTION:
                if (!mPageAC.validate(nextObject)) {
                    if (!mPageAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_PAGE_FEILD, curStartPos, idx);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            default:
                syntaxContainer.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return syntaxContainer;
        }
    }
    return syntaxContainer;
}
#method_after
@Override
public SyntaxContainer analyzeSyntaxState(final String searchText, boolean final2) {
    final SyntaxContainer syntaxContainer = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter curConditionFieldAC = null;
    IAutoCompleter curConditionRelationAC = null;
    final List<String> freeTextObjSearched = new ArrayList<String>();
    char[] searchCharArr = searchText.toCharArray();
    int curStartPos = 0;
    String tryNextObj = "";
    boolean keepValid;
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        final SyntaxObjectType curState = syntaxContainer.getState();
        final char curChar = searchCharArr[idx];
        if (mDisAllowedChars.contains(curChar)) {
            syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
            return syntaxContainer;
        }
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION) && (curState != SyntaxObjectType.COLON) && (curState != SyntaxObjectType.CONDITION_VALUE) && (curState != SyntaxObjectType.OR) && (curState != SyntaxObjectType.AND)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return syntaxContainer;
                    }
                } else {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    syntaxContainer.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case CROSS_REF_OBJ:
                String curRefObj = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                }
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (mDotAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.DOT, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!"".equals(tryNextObj)) && (curConditionRelationAC.validate(tryNextObj))) {
                    // i.e. the relation object has another charecter
                    break;
                } else if (curConditionRelationAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if ((!curConditionRelationAC.validateCompletion(nextObject)) && (!mDotAC.validateCompletion(nextObject))) {
                    syntaxContainer.setErr(SyntaxError.INVALID_POST_CROSS_REF_OBJ, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                tryNextObj = "";
                break;
            case DOT:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                if (curConditionFieldAC == null) {
                    syntaxContainer.setErr(SyntaxError.CANT_GET_CONDITION_FIELD_AC, curStartPos, idx);
                    return syntaxContainer;
                }
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                }
                break;
            case AND:
            case OR:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject, syntaxContainer);
                    curStartPos = tempRefObject.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            curRefObj = syntaxContainer.getSearchObjectStr();
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                            syntaxContainer.setvalid(true);
                            keepValid = true;
                        }
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_OR_AND_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case COLON:
                keepValid = false;
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (curConditionFieldAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSortbyAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mPageAC.validate(nextObject)) {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                } else {
                    RefObject<Integer> tempRefObject2 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject2, syntaxContainer);
                    curStartPos = tempRefObject2.argvalue;
                    if (ans != ValueParseResult.Err) {
                        if (ans == ValueParseResult.FreeText) {
                            freeTextObjSearched.add(syntaxContainer.getSearchObjectStr());
                        }
                        keepValid = true;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject))) {
                        syntaxContainer.setErr(SyntaxError.INVALID_POST_COLON_PHRASE, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                }
                if (keepValid == false) {
                    syntaxContainer.setvalid(false);
                }
                break;
            case CONDITION_VALUE:
                nextObject = nextObject.trim();
                if (nextObject.length() > 0) {
                    keepValid = false;
                    curRefObj = syntaxContainer.getSearchObjectStr();
                    curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(curRefObj);
                    if (curConditionFieldAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSortbyAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.SORTBY, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mPageAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mSearchObjectAC.isCrossReference(nextObject, syntaxContainer.getFirst().getBody())) {
                        if (searchCharArr.length >= idx + 2) {
                            // Validate that the next character is an 's'
                            if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                                // Then just move things along.
                                idx++;
                                StringBuilder sb = new StringBuilder(nextObject);
                                sb.append('S');
                                nextObject = sb.toString();
                            }
                        }
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.CROSS_REF_OBJ, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mAndAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.AND, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if (mOrAC.validate(nextObject)) {
                        syntaxContainer.addSyntaxObject(SyntaxObjectType.OR, nextObject, curStartPos, idx + 1);
                        curStartPos = idx + 1;
                    } else if ((!curConditionFieldAC.validateCompletion(nextObject)) && (!mSortbyAC.validateCompletion(nextObject)) && (!mSearchObjectAC.validateCompletion(nextObject)) && (!mAndAC.validateCompletion(nextObject)) && (!mOrAC.validateCompletion(nextObject))) {
                        RefObject<Integer> tempRefObject3 = new RefObject<Integer>(curStartPos);
                        ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject3, syntaxContainer);
                        curStartPos = tempRefObject3.argvalue;
                        if (ans != ValueParseResult.Err) {
                            if (ans == ValueParseResult.FreeText) {
                                if (freeTextObjSearched.contains(curRefObj)) {
                                    syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                    return syntaxContainer;
                                }
                                freeTextObjSearched.add(curRefObj);
                                syntaxContainer.setvalid(true);
                                keepValid = true;
                            }
                        } else {
                            syntaxContainer.setErr(SyntaxError.INVALID_POST_CONDITION_VALUE_PHRASE, curStartPos, idx + 1);
                            return syntaxContainer;
                        }
                    }
                    if (keepValid == false) {
                        syntaxContainer.setvalid(false);
                    }
                }
                break;
            case CONDITION_FIELD:
                curRefObj = syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                String curConditionField = syntaxContainer.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                curConditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(curRefObj, curConditionField);
                if (curConditionRelationAC == null) {
                    syntaxContainer.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                if (idx + 1 < searchCharArr.length) {
                    tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (curConditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!curConditionRelationAC.validate(nextObject)) {
                    if (!curConditionRelationAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                syntaxContainer.setvalid(false);
                tryNextObj = "";
                break;
            case CONDITION_RELATION:
                {
                    RefObject<Integer> tempRefObject4 = new RefObject<Integer>(curStartPos);
                    ValueParseResult ans = handleValuePhrase(final2, searchText, idx, tempRefObject4, syntaxContainer);
                    curStartPos = tempRefObject4.argvalue;
                    if (ans == ValueParseResult.Err) {
                        return syntaxContainer;
                    }
                    if (ans == ValueParseResult.FreeText) {
                        if (syntaxContainer.getPreviousSyntaxObjectType(2) == SyntaxObjectType.CROSS_REF_OBJ) {
                            curRefObj = syntaxContainer.getObjSingularName(syntaxContainer.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ));
                            if (freeTextObjSearched.contains(curRefObj)) {
                                syntaxContainer.setErr(SyntaxError.FREE_TEXT_ALLOWED_ONCE_PER_OBJ, curStartPos, idx + 1);
                                return syntaxContainer;
                            }
                            freeTextObjSearched.add(curRefObj);
                        }
                    }
                }
                break;
            case SORTBY:
                curConditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(syntaxContainer.getSearchObjectStr());
                if (!curConditionFieldAC.validate(nextObject)) {
                    if (!curConditionFieldAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_FIELD, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_FIELD, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE:
                Integer pageNumber = IntegerCompat.tryParse(nextObject);
                if (pageNumber == null) {
                    syntaxContainer.setErr(SyntaxError.INVALID_CHARECTER, curStartPos, idx + 1);
                    return syntaxContainer;
                } else {
                    final StringBuilder buff = new StringBuilder();
                    int pos = idx;
                    // parsing the whole page number (can be more than one char)
                    while (pos < searchText.length() - 1 && Character.isDigit(nextObject.charAt(0))) {
                        buff.append(nextObject);
                        pos++;
                        strRealObj = searchText.substring(pos, pos + 1);
                        nextObject = strRealObj.toUpperCase();
                    }
                    buff.append(nextObject);
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE_VALUE, buff.toString(), curStartPos, idx + buff.length());
                    // update index position
                    idx = pos + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case SORT_FIELD:
                if (!mSortDirectionAC.validate(nextObject)) {
                    if (!mSortDirectionAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_SORT_DIRECTION, curStartPos, idx + 1);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.SORT_DIRECTION, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            case PAGE_VALUE:
                if (curChar != ' ') {
                    syntaxContainer.setErr(SyntaxError.NOTHING_COMES_AFTER_PAGE_VALUE, curStartPos, idx + 1);
                    return syntaxContainer;
                }
                break;
            case SORT_DIRECTION:
                if (!mPageAC.validate(nextObject)) {
                    if (!mPageAC.validateCompletion(nextObject)) {
                        syntaxContainer.setErr(SyntaxError.INVALID_PAGE_FEILD, curStartPos, idx);
                        return syntaxContainer;
                    }
                } else {
                    syntaxContainer.addSyntaxObject(SyntaxObjectType.PAGE, nextObject, curStartPos, idx + 1);
                    curStartPos = idx + 1;
                    syntaxContainer.setvalid(true);
                }
                break;
            default:
                syntaxContainer.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return syntaxContainer;
        }
    }
    return syntaxContainer;
}
#end_block

#method_before
@Override
public SyntaxContainer getCompletion(String searchText) {
    SyntaxContainer retval = analyzeSyntaxState(searchText, false);
    if (retval.getError() == SyntaxError.NO_ERROR) {
        IConditionFieldAutoCompleter conditionFieldAC;
        IAutoCompleter conditionRelationAC;
        IConditionValueAutoCompleter conditionValueAC;
        int lastIdx = retval.getLastHandledIndex();
        String curPartialWord = "";
        if (lastIdx < searchText.length()) {
            curPartialWord = searchText.substring(lastIdx, searchText.length());
            curPartialWord = curPartialWord.trim();
        }
        SyntaxObjectType curState = retval.getState();
        for (int idx = 0; idx < mStateMap.get(curState).length; idx++) {
            switch(mStateMap.get(curState)[idx]) {
                case SEARCH_OBJECT:
                    retval.addToACList(mSearchObjectAC.getCompletion(curPartialWord));
                    break;
                case CROSS_REF_OBJ:
                    IAutoCompleter crossRefAC = mSearchObjectAC.getCrossRefAutoCompleter(retval.getFirst().getBody());
                    if (crossRefAC != null) {
                        retval.addToACList(crossRefAC.getCompletion(curPartialWord));
                    }
                    break;
                case DOT:
                    retval.addToACList(mDotAC.getCompletion(curPartialWord));
                    break;
                case COLON:
                    retval.addToACList(mColonAC.getCompletion(curPartialWord));
                    break;
                case AND:
                    retval.addToACList(mAndAC.getCompletion(curPartialWord));
                    break;
                case OR:
                    retval.addToACList(mOrAC.getCompletion(curPartialWord));
                    break;
                case CONDITION_FIELD:
                    String relObj = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(relObj);
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case CONDITION_RELATION:
                    {
                        if (curState == SyntaxObjectType.CONDITION_FIELD) {
                            relObj = retval.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                            String fldName = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                            conditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(relObj, fldName);
                        } else // curState == SyntaxObjectType.CROSS_REF_OBJ
                        {
                            relObj = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                            conditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                        }
                        if (conditionRelationAC != null) {
                            retval.addToACList(conditionRelationAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case CONDITION_VALUE:
                    {
                        relObj = retval.getPreviousSyntaxObject(3, SyntaxObjectType.CROSS_REF_OBJ);
                        String fldName = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CONDITION_FIELD);
                        conditionValueAC = mSearchObjectAC.getFieldValueAutoCompleter(relObj, fldName);
                        if (conditionValueAC != null) {
                            retval.addToACList(conditionValueAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case SORTBY:
                    retval.addToACList(mSortbyAC.getCompletion(curPartialWord));
                    break;
                case PAGE:
                    retval.addToACList(mPageAC.getCompletion(curPartialWord));
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(retval.getSearchObjectStr());
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case SORT_DIRECTION:
                    retval.addToACList(mSortDirectionAC.getCompletion(curPartialWord));
                    break;
            }
        }
    }
    return retval;
}
#method_after
@Override
public SyntaxContainer getCompletion(String searchText) {
    SyntaxContainer retval = analyzeSyntaxState(searchText, false);
    if (retval.getError() == SyntaxError.NO_ERROR) {
        IConditionFieldAutoCompleter conditionFieldAC;
        IAutoCompleter conditionRelationAC;
        IConditionValueAutoCompleter conditionValueAC;
        int lastIdx = retval.getLastHandledIndex();
        String curPartialWord = "";
        if (lastIdx < searchText.length()) {
            curPartialWord = searchText.substring(lastIdx, searchText.length());
            curPartialWord = curPartialWord.trim();
        }
        SyntaxObjectType curState = retval.getState();
        for (int idx = 0; idx < mStateMap.get(curState).length; idx++) {
            switch(mStateMap.get(curState)[idx]) {
                case SEARCH_OBJECT:
                    retval.addToACList(mSearchObjectAC.getCompletion(curPartialWord));
                    break;
                case CROSS_REF_OBJ:
                    IAutoCompleter crossRefAC = mSearchObjectAC.getCrossRefAutoCompleter(retval.getFirst().getBody());
                    if (crossRefAC != null) {
                        retval.addToACList(crossRefAC.getCompletion(curPartialWord));
                    }
                    break;
                case DOT:
                    retval.addToACList(mDotAC.getCompletion(curPartialWord));
                    break;
                case COLON:
                    retval.addToACList(mColonAC.getCompletion(curPartialWord));
                    break;
                case AND:
                    retval.addToACList(mAndAC.getCompletion(curPartialWord));
                    break;
                case OR:
                    retval.addToACList(mOrAC.getCompletion(curPartialWord));
                    break;
                case CONDITION_FIELD:
                    String relObj = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CROSS_REF_OBJ);
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(relObj);
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case CONDITION_RELATION:
                    {
                        if (curState == SyntaxObjectType.CONDITION_FIELD) {
                            relObj = retval.getPreviousSyntaxObject(2, SyntaxObjectType.CROSS_REF_OBJ);
                            String fldName = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CONDITION_FIELD);
                            conditionRelationAC = mSearchObjectAC.getFieldRelationshipAutoCompleter(relObj, fldName);
                        } else {
                            // curState == SyntaxObjectType.CROSS_REF_OBJ
                            relObj = retval.getPreviousSyntaxObject(0, SyntaxObjectType.CROSS_REF_OBJ);
                            conditionRelationAC = mSearchObjectAC.getObjectRelationshipAutoCompleter();
                        }
                        if (conditionRelationAC != null) {
                            retval.addToACList(conditionRelationAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case CONDITION_VALUE:
                    {
                        relObj = retval.getPreviousSyntaxObject(3, SyntaxObjectType.CROSS_REF_OBJ);
                        String fldName = retval.getPreviousSyntaxObject(1, SyntaxObjectType.CONDITION_FIELD);
                        conditionValueAC = mSearchObjectAC.getFieldValueAutoCompleter(relObj, fldName);
                        if (conditionValueAC != null) {
                            retval.addToACList(conditionValueAC.getCompletion(curPartialWord));
                        }
                    }
                    break;
                case SORTBY:
                    retval.addToACList(mSortbyAC.getCompletion(curPartialWord));
                    break;
                case PAGE:
                    retval.addToACList(mPageAC.getCompletion(curPartialWord));
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(retval.getSearchObjectStr());
                    if (conditionFieldAC != null) {
                        retval.addToACList(conditionFieldAC.getCompletion(curPartialWord));
                    }
                    break;
                case SORT_DIRECTION:
                    retval.addToACList(mSortDirectionAC.getCompletion(curPartialWord));
                    break;
            }
        }
    }
    return retval;
}
#end_block

#method_before
private String generateFromStatement(SyntaxContainer syntax, boolean useTags) {
    LinkedList<String> innerJoins = new LinkedList<String>();
    ArrayList<String> refObjList = syntax.getCrossRefObjList();
    String searchObjStr = syntax.getSearchObjectStr();
    if (refObjList.size() > 0) {
        if (SearchObjects.TEMPLATE_OBJ_NAME.equals(searchObjStr)) {
            innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.TEMPLATE_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
            if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                refObjList.remove(SearchObjects.VM_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.AUDIT_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.AUDIT_OBJ_NAME));
                refObjList.remove(SearchObjects.AUDIT_OBJ_NAME);
            }
        } else if (SearchObjects.VDS_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) || (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.VDC_USER_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDS_OBJ_NAME)) || (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.AUDIT_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.AUDIT_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
        } else if (SearchObjects.DISK_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.DISK_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
            }
        }
    }
    for (String cro : refObjList) {
        innerJoins.addLast(mSearchObjectAC.getInnerJoin(searchObjStr, cro));
    }
    if (useTags) {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableName(searchObjStr));
    } else {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr));
    }
    StringBuilder sb = new StringBuilder();
    for (String part : innerJoins) {
        sb.append(" ");
        sb.append(part);
        sb.append(" ");
    }
    return sb.toString();
}
#method_after
private String generateFromStatement(SyntaxContainer syntax, boolean useTags) {
    LinkedList<String> innerJoins = new LinkedList<String>();
    ArrayList<String> refObjList = syntax.getCrossRefObjList();
    String searchObjStr = syntax.getSearchObjectStr();
    if (refObjList.size() > 0) {
        if (SearchObjects.TEMPLATE_OBJ_NAME.equals(searchObjStr)) {
            innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.TEMPLATE_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
            if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                refObjList.remove(SearchObjects.VM_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.AUDIT_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.AUDIT_OBJ_NAME));
                refObjList.remove(SearchObjects.AUDIT_OBJ_NAME);
            }
        } else if (SearchObjects.VDS_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDC_USER_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDS_OBJ_NAME, SearchObjects.VDC_USER_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_USER_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.VDC_USER_OBJ_NAME.equals(searchObjStr)) {
            if ((refObjList.contains(SearchObjects.VDS_OBJ_NAME))) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
            if (refObjList.contains(SearchObjects.VDS_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.VDS_OBJ_NAME));
                refObjList.remove(SearchObjects.VDS_OBJ_NAME);
            }
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_USER_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
            }
        } else if (SearchObjects.AUDIT_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.TEMPLATE_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.AUDIT_OBJ_NAME, SearchObjects.VM_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VM_OBJ_NAME, SearchObjects.TEMPLATE_OBJ_NAME));
                refObjList.remove(SearchObjects.TEMPLATE_OBJ_NAME);
                if (refObjList.contains(SearchObjects.VM_OBJ_NAME)) {
                    refObjList.remove(SearchObjects.VM_OBJ_NAME);
                }
            }
        } else if (SearchObjects.DISK_OBJ_NAME.equals(searchObjStr)) {
            if (refObjList.contains(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME)) {
                innerJoins.addFirst(mSearchObjectAC.getInnerJoin(SearchObjects.DISK_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME));
                innerJoins.addLast(mSearchObjectAC.getInnerJoin(SearchObjects.VDC_STORAGE_DOMAIN_IMAGE_OBJ_NAME, SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME));
                refObjList.remove(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME);
            }
        }
    }
    for (String cro : refObjList) {
        innerJoins.addLast(mSearchObjectAC.getInnerJoin(searchObjStr, cro));
    }
    if (useTags) {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableName(searchObjStr));
    } else {
        innerJoins.addFirst(mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr));
    }
    StringBuilder sb = new StringBuilder();
    for (String part : innerJoins) {
        sb.append(" ");
        sb.append(part);
        sb.append(" ");
    }
    return sb.toString();
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        boolean generalQuery = false;
        String innerQuery;
        if (!wherePhrase.toString().contains("tag") && (searchObjStr.equals(SearchObjects.VDS_OBJ_NAME) || searchObjStr.equals(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME))) {
            innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableNameWithOutTags, "*", generateFromStatement(syntax, false), wherePhrase);
            generalQuery = true;
        } else {
            innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        }
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (generalQuery) {
            inQuery = "(" + innerQuery;
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>GetValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        boolean generalQuery = false;
        String innerQuery;
        if (!wherePhrase.toString().contains(TAG_COLUMN_NAME_IN_CRITERIA) && !wherePhrase.toString().contains(".") && (searchObjStr.equals(SearchObjects.VDS_OBJ_NAME) || searchObjStr.equals(SearchObjects.VDC_STORAGE_DOMAIN_OBJ_NAME))) {
            innerQuery = getInnerQuery(tableNameWithOutTags, "*", generateFromStatement(syntax, false), wherePhrase);
            generalQuery = true;
        } else {
            innerQuery = getInnerQuery(tableName, primeryKey, fromStatement, wherePhrase);
        }
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = StringFormat.format("SELECT %1$s.* FROM %2$s %3$s and (not deleted", tableName, fromStatement, wherePhrase);
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() == 0) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s ", tableNameWithOutTags);
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else if (generalQuery) {
            inQuery = "(" + innerQuery;
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
protected String getPagePhrase(SyntaxContainer syntax, String pageNumber) {
    String result = "";
    Integer page = IntegerCompat.tryParse(pageNumber);
    if (page == null) {
        page = 1;
    }
    PagingType pagingType = getPagingType();
    if (pagingType != null) {
        String pagingSyntax = Config.<String>GetValue(ConfigValues.DBPagingSyntax);
        switch(pagingType) {
            case Range:
                result = StringFormat.format(pagingSyntax, (page - 1) * syntax.getMaxCount() + 1, page * syntax.getMaxCount());
                break;
            case Offset:
                result = StringFormat.format(pagingSyntax, (page - 1) * syntax.getMaxCount() + 1, syntax.getMaxCount());
                break;
        }
    }
    return result;
}
#method_after
protected String getPagePhrase(SyntaxContainer syntax, String pageNumber) {
    String result = "";
    Integer page = IntegerCompat.tryParse(pageNumber);
    if (page == null) {
        page = 1;
    }
    PagingType pagingType = getPagingType();
    if (pagingType != null) {
        String pagingSyntax = Config.<String>getValue(ConfigValues.DBPagingSyntax);
        BigInteger bigPage = BigInteger.valueOf(page);
        BigInteger bigCount = BigInteger.valueOf(syntax.getMaxCount());
        BigInteger bigX = bigPage.subtract(BigInteger.ONE).multiply(bigCount).add(BigInteger.ONE);
        BigInteger bigY = bigPage.multiply(bigCount);
        switch(pagingType) {
            case Range:
                result = StringFormat.format(pagingSyntax, bigX, bigY);
                break;
            case Offset:
                result = StringFormat.format(pagingSyntax, bigX, bigCount);
                break;
        }
    }
    return result;
}
#end_block

#method_before
private PagingType getPagingType() {
    String val = Config.<String>GetValue(ConfigValues.DBPagingType);
    PagingType type = null;
    try {
        type = PagingType.valueOf(val);
    } catch (Exception e) {
        log.error("Unknown paging type " + val);
    }
    return type;
}
#method_after
private PagingType getPagingType() {
    String val = Config.<String>getValue(ConfigValues.DBPagingType);
    PagingType type = null;
    try {
        type = PagingType.valueOf(val);
    } catch (Exception e) {
        log.error("Unknown paging type " + val);
    }
    return type;
}
#end_block

#method_before
private String generateSafeConditionStatement(final SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final String safeValue) {
    IConditionFieldAutoCompleter conditionFieldAC;
    IConditionValueAutoCompleter conditionValueAC = null;
    // check for sql injection
    String fieldName = "";
    String objName;
    ConditionType conditionType;
    SyntaxObject previous = objIter.previous();
    SyntaxObject prev = previous;
    SyntaxObjectType prevType = prev.getType();
    if (prevType != SyntaxObjectType.CONDITION_RELATION) {
        // free text of default search object
        objName = searchObjStr;
        conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
        conditionType = ConditionType.FreeText;
    } else {
        prev = objIter.previous();
        if (prev.getType() == SyntaxObjectType.CROSS_REF_OBJ) {
            // free text
            // search
            // for some
            // object
            objName = prev.getBody();
            conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
            conditionType = ConditionType.FreeTextSpecificObj;
        } else // if (prev.getType() == SyntaxObjectType.CONDITION_FIELD)
        {
            fieldName = prev.getBody();
            prev = objIter.previous();
            if (prev.getType() != SyntaxObjectType.DOT) {
                // standard condition with default AC (search obj)
                objName = searchObjStr;
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                conditionType = ConditionType.ConditionWithDefaultObj;
            } else {
                // standard condition with specific AC
                prev = objIter.previous();
                objName = prev.getBody();
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
                conditionType = ConditionType.ConditionwithSpesificObj;
            }
        }
        conditionValueAC = conditionFieldAC.getFieldValueAutoCompleter(fieldName);
    }
    final BaseConditionFieldAutoCompleter conditionAsBase = (BaseConditionFieldAutoCompleter) ((conditionFieldAC instanceof BaseConditionFieldAutoCompleter) ? conditionFieldAC : null);
    final Class<?> curType = conditionAsBase != null ? conditionAsBase.getTypeDictionary().get(fieldName) : null;
    final String customizedValue = buildCustomizedValue(obj, conditionFieldAC, conditionValueAC, safeValue, fieldName, curType);
    final String customizedRelation = buildCustomizedRelation(caseSensitive, conditionFieldAC, conditionValueAC, fieldName, previous, prevType);
    return buildCondition(caseSensitive, conditionFieldAC, customizedValue, customizedRelation, fieldName, objName, conditionType);
}
#method_after
private String generateSafeConditionStatement(final SyntaxObject obj, ListIterator<SyntaxObject> objIter, final String searchObjStr, final boolean caseSensitive, final String safeValue) {
    IConditionFieldAutoCompleter conditionFieldAC;
    IConditionValueAutoCompleter conditionValueAC = null;
    // check for sql injection
    String fieldName = "";
    String objName;
    ConditionType conditionType;
    SyntaxObject previous = objIter.previous();
    SyntaxObject prev = previous;
    SyntaxObjectType prevType = prev.getType();
    if (prevType != SyntaxObjectType.CONDITION_RELATION) {
        // free text of default search object
        objName = searchObjStr;
        conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
        conditionType = ConditionType.FreeText;
    } else {
        prev = objIter.previous();
        if (prev.getType() == SyntaxObjectType.CROSS_REF_OBJ) {
            // free text
            // search
            // for some
            // object
            objName = prev.getBody();
            conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
            conditionType = ConditionType.FreeTextSpecificObj;
        } else {
            // if (prev.getType() == SyntaxObjectType.CONDITION_FIELD)
            fieldName = prev.getBody();
            prev = objIter.previous();
            if (prev.getType() != SyntaxObjectType.DOT) {
                // standard condition with default AC (search obj)
                objName = searchObjStr;
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                conditionType = ConditionType.ConditionWithDefaultObj;
            } else {
                // standard condition with specific AC
                prev = objIter.previous();
                objName = prev.getBody();
                conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(objName);
                conditionType = ConditionType.ConditionwithSpesificObj;
            }
        }
        conditionValueAC = conditionFieldAC.getFieldValueAutoCompleter(fieldName);
    }
    final BaseConditionFieldAutoCompleter conditionAsBase = (BaseConditionFieldAutoCompleter) ((conditionFieldAC instanceof BaseConditionFieldAutoCompleter) ? conditionFieldAC : null);
    final Class<?> curType = conditionAsBase != null ? conditionAsBase.getTypeDictionary().get(fieldName) : null;
    final String customizedValue = buildCustomizedValue(obj, conditionFieldAC, conditionValueAC, safeValue, fieldName, curType);
    final String customizedRelation = buildCustomizedRelation(caseSensitive, conditionFieldAC, conditionValueAC, fieldName, previous, prevType);
    return buildCondition(caseSensitive, conditionFieldAC, customizedValue, customizedRelation, fieldName, objName, conditionType);
}
#end_block

#method_before
final String buildCondition(boolean caseSensitive, IConditionFieldAutoCompleter conditionFieldAC, String customizedValue, String customizedRelation, String fieldName, String objName, ConditionType conditionType) {
    final String tableName = mSearchObjectAC.getRelatedTableName(objName);
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        String replaceWith = "_";
        int pgMajorRelease = Config.<Integer>GetValue(ConfigValues.PgMajorRelease);
        if (pgMajorRelease == PgMajorRelease.PG8.getValue()) {
            replaceWith = "\\\\_";
        } else if (pgMajorRelease == PgMajorRelease.PG9.getValue()) {
            replaceWith = "\\_";
        }
        customizedValue = customizedValue.replace("_", replaceWith);
    }
    switch(conditionType) {
        case FreeText:
        case FreeTextSpecificObj:
            return conditionFieldAC.buildFreeTextConditionSql(tableName, customizedRelation, customizedValue, caseSensitive);
        case ConditionWithDefaultObj:
        case ConditionwithSpesificObj:
            return conditionFieldAC.buildConditionSql(fieldName, customizedValue, customizedRelation, tableName, caseSensitive);
        default:
            return "";
    }
}
#method_after
final String buildCondition(boolean caseSensitive, IConditionFieldAutoCompleter conditionFieldAC, String customizedValue, String customizedRelation, String fieldName, String objName, ConditionType conditionType) {
    final String tableName = mSearchObjectAC.getRelatedTableName(objName);
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        String replaceWith = "_";
        int pgMajorRelease = Config.<Integer>getValue(ConfigValues.PgMajorRelease);
        if (pgMajorRelease == PgMajorRelease.PG8.getValue()) {
            replaceWith = "\\\\_";
        } else if (pgMajorRelease == PgMajorRelease.PG9.getValue()) {
            replaceWith = "\\_";
        }
        customizedValue = customizedValue.replace("_", replaceWith);
    }
    switch(conditionType) {
        case FreeText:
        case FreeTextSpecificObj:
            return conditionFieldAC.buildFreeTextConditionSql(tableName, customizedRelation, customizedValue, caseSensitive);
        case ConditionWithDefaultObj:
        case ConditionwithSpesificObj:
            return conditionFieldAC.buildConditionSql(fieldName, customizedValue, customizedRelation, tableName, caseSensitive);
        default:
            return "";
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isDiskInterfaceSupportReadOnly())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm, diskValidator);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#end_block

#method_before
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isDiskInterfaceSupportReadOnly()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void canDoActionFailWithUnsupportedDiskInterface() throws Exception {
    Guid storageId = Guid.newGuid();
    initializeCommand(storageId);
    mockVm();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isDiskInterfaceSupportReadOnly()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSizeAndAlias()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#end_block

#method_before
private boolean shouldUpdateDiskProperties() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isWipeAfterDelete() != getNewDisk().isWipeAfterDelete() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio() || !StringUtils.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription()) || !StringUtils.equals(getOldDisk().getDiskAlias(), getNewDisk().getDiskAlias());
}
#method_after
private boolean shouldUpdateDiskProperties() {
    return getOldDisk().isBoot() != getNewDisk().isBoot() || getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface() || getOldDisk().getPropagateErrors() != getNewDisk().getPropagateErrors() || getOldDisk().isWipeAfterDelete() != getNewDisk().isWipeAfterDelete() || getOldDisk().isShareable() != getNewDisk().isShareable() || getOldDisk().getSgio() != getNewDisk().getSgio() || !StringUtils.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription());
}
#end_block

#method_before
@Test
public void readOnlyIsNotSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isDiskInterfaceSupportReadOnly(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IDE_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR));
}
#method_after
@Test
public void readOnlyIsNotSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IDE_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR));
}
#end_block

#method_before
@Test
public void readOnlyIsSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.VirtIO);
    assertThat(validator.isDiskInterfaceSupportReadOnly(), isValid());
    disk.setReadOnly(false);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isDiskInterfaceSupportReadOnly(), isValid());
}
#method_after
@Test
public void readOnlyIsSupportedByDiskInterface() {
    disk.setReadOnly(true);
    disk.setDiskInterface(DiskInterface.VirtIO);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), isValid());
    disk.setReadOnly(false);
    disk.setDiskInterface(DiskInterface.IDE);
    assertThat(validator.isReadOnlyPropertyCompatibleWithInterface(), isValid());
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(any(List.class));
    when(diskValidator.isDiskInterfaceSupportReadOnly()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(any(List.class));
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#method_after
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#end_block

#method_before
public static boolean isSet(Object o, String name) {
    if (o != null) {
        Method m = getMethod(o, IS_SET_ROOT + name);
        Object ret = invoke(o, m);
        return ret != null && ret instanceof Boolean && ((Boolean) ret).booleanValue();
    }
    return false;
}
#method_after
public static boolean isSet(Object o, String name) {
    boolean set = false;
    if (o != null) {
        Method m = getMethod(o, IS_SET_ROOT + name);
        Object ret = invoke(o, m);
        if (ret != null && ret instanceof Boolean && ((Boolean) ret).booleanValue()) {
            // for Strings we also have to check that the value is not empty.
            if (getReturnType(o, name).equals(String.class)) {
                Object result = invoke(o, getGetter(o, name));
                String resultAsString = (String) result;
                if (!resultAsString.isEmpty()) {
                    set = true;
                }
            } else {
                set = true;
            }
        }
    }
    return set;
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            // (Integer.MAX_VALUE - 1) is used since in SyntaxChecker code we use getMaxCount() + 1
            // If a number > maxValue is given then maxValue will be used
            int maxValue = Integer.MAX_VALUE - 1;
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? maxValue : Math.min(maxValue, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            int maxValue = Integer.MAX_VALUE;
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? maxValue : Math.min(maxValue, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
private void DiskInterface_SelectedItemChanged() {
    boolean isInternal = (Boolean) getIsInternal().getEntity();
    DiskInterface diskInterface = (DiskInterface) getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(!isInternal && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    if (DiskInterface.IDE.equals(diskInterface) && !Boolean.TRUE.equals(getIsReadOnly().getEntity())) {
        getIsReadOnly().setIsChangable(false);
    } else if (isEditEnabled()) {
        getIsReadOnly().setIsChangable(true);
    }
}
#method_after
private void DiskInterface_SelectedItemChanged() {
    boolean isInternal = (Boolean) getIsInternal().getEntity();
    DiskInterface diskInterface = (DiskInterface) getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(!isInternal && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    updateReadOnlyChangeability();
}
#end_block

#method_before
protected void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    ConfirmationModel confirmationModel = new ConfirmationModel();
    setConfirmWindow(confirmationModel);
    confirmationModel.setTitle(CONSTANTS.forceStorageDomainCreation());
    confirmationModel.setMessage(CONSTANTS.lunsAlreadyPartOfSD());
    // $NON-NLS-1$
    confirmationModel.setHashName("force_lun_disk_creation");
    confirmationModel.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand forceSaveCommand = new UICommand("OnForceSave", this);
    forceSaveCommand.setTitle(CONSTANTS.ok());
    forceSaveCommand.setIsDefault(true);
    confirmationModel.getCommands().add(forceSaveCommand);
    // $NON-NLS-1$
    UICommand cancelconfirmCommand = new UICommand("CancelConfirm", this);
    cancelconfirmCommand.setTitle(CONSTANTS.cancel());
    cancelconfirmCommand.setIsCancel(true);
    confirmationModel.getCommands().add(cancelconfirmCommand);
}
#method_after
protected void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    ConfirmationModel confirmationModel = new ConfirmationModel();
    setConfirmWindow(confirmationModel);
    confirmationModel.setTitle(CONSTANTS.forceStorageDomainCreation());
    confirmationModel.setMessage(CONSTANTS.lunsAlreadyPartOfSD());
    confirmationModel.setHelpTag(HelpTag.force_lun_disk_creation);
    // $NON-NLS-1$
    confirmationModel.setHashName("force_lun_disk_creation");
    confirmationModel.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand forceSaveCommand = new UICommand("OnForceSave", this);
    forceSaveCommand.setTitle(CONSTANTS.ok());
    forceSaveCommand.setIsDefault(true);
    confirmationModel.getCommands().add(forceSaveCommand);
    // $NON-NLS-1$
    UICommand cancelconfirmCommand = new UICommand("CancelConfirm", this);
    cancelconfirmCommand.setTitle(CONSTANTS.cancel());
    cancelconfirmCommand.setIsCancel(true);
    confirmationModel.getCommands().add(cancelconfirmCommand);
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        getSize().setEntity(diskImage.getSizeInGigabytes());
        getIsInternal().setEntity(true);
        getVolumeType().setSelectedItem(diskImage.getVolumeType());
        setVolumeFormat(diskImage.getVolumeFormat());
        boolean isExtendImageSizeEnabled = getVm() != null && !diskImage.isDiskSnapshot() && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
        getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        AsyncDataProvider.getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                DiskModel diskModel = (DiskModel) target;
                StorageDomain storageDomain = (StorageDomain) returnValue;
                diskModel.getStorageDomain().setSelectedItem(storageDomain);
            }
        }, getHash()), storageDomainId);
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        getSize().setEntity(lunDisk.getLun().getDeviceSize());
        getIsInternal().setEntity(false);
        getSizeExtend().setIsAvailable(false);
    }
    if (getDisk().getDiskInterface() == DiskInterface.IDE) {
        getIsReadOnly().setIsChangable(false);
    }
}
#method_after
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        getSize().setEntity(diskImage.getSizeInGigabytes());
        getIsInternal().setEntity(true);
        getVolumeType().setSelectedItem(diskImage.getVolumeType());
        setVolumeFormat(diskImage.getVolumeFormat());
        boolean isExtendImageSizeEnabled = getVm() != null && !diskImage.isDiskSnapshot() && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
        getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        AsyncDataProvider.getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                DiskModel diskModel = (DiskModel) target;
                StorageDomain storageDomain = (StorageDomain) returnValue;
                diskModel.getStorageDomain().setSelectedItem(storageDomain);
            }
        }, getHash()), storageDomainId);
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        getSize().setEntity(lunDisk.getLun().getDeviceSize());
        getIsInternal().setEntity(false);
        getSizeExtend().setIsAvailable(false);
    }
    updateReadOnlyChangeability();
}
#end_block

#method_before
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    if (!isEditEnabled()) {
        getDescription().setIsChangable(false);
        getAlias().setIsChangable(false);
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getIsWipeAfterDelete().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#method_after
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    if (!isEditEnabled()) {
        getDescription().setIsChangable(false);
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getIsWipeAfterDelete().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#end_block

#method_before
private void newEntity() {
    final VM vm = getEntity();
    if (getWindow() != null) {
        return;
    }
    NewDiskModel model = new NewDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(vm);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#method_after
private void newEntity() {
    final VM vm = getEntity();
    if (getWindow() != null) {
        return;
    }
    NewDiskModel model = new NewDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    model.setHelpTag(HelpTag.new_virtual_disk);
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(vm);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#end_block

#method_before
private void changeQuota() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    ChangeQuotaModel model = new ChangeQuotaModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignQuotaForDisk());
    // $NON-NLS-1$
    model.setHashName("change_quota_disks");
    model.startProgress(null);
    model.init(disks);
    // $NON-NLS-1$
    UICommand command = new UICommand("onChangeQuota", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void changeQuota() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    ChangeQuotaModel model = new ChangeQuotaModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignQuotaForDisk());
    model.setHelpTag(HelpTag.change_quota_disks);
    // $NON-NLS-1$
    model.setHashName("change_quota_disks");
    model.startProgress(null);
    model.init(disks);
    // $NON-NLS-1$
    UICommand command = new UICommand("onChangeQuota", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#end_block

#method_before
private void edit() {
    final Disk disk = (Disk) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    EditDiskModel model = new EditDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().editVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("edit_virtual_disk");
    model.setVm(getEntity());
    model.setDisk(disk);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#method_after
private void edit() {
    final Disk disk = (Disk) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    EditDiskModel model = new EditDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().editVirtualDiskTitle());
    model.setHelpTag(HelpTag.edit_virtual_disk);
    // $NON-NLS-1$
    model.setHashName("edit_virtual_disk");
    model.setVm(getEntity());
    model.setDisk(disk);
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    model.setHelpTag(HelpTag.remove_disk);
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void plug(boolean plug) {
    VM vm = getEntity();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        disk.setPlugged(plug);
        paramerterList.add(new HotPlugDiskToVmParameters(vm.getId(), disk.getId()));
    }
    VdcActionType plugAction = VdcActionType.HotPlugDiskToVm;
    if (!plug) {
        plugAction = VdcActionType.HotUnPlugDiskFromVm;
    }
    Frontend.getInstance().runMultipleAction(plugAction, paramerterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, this);
}
#method_after
private void plug() {
    Frontend.getInstance().runMultipleAction(VdcActionType.HotPlugDiskToVm, createHotPlugDiskToVmParameters(true), new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, this);
}
#end_block

#method_before
private void confirmUnplug() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().deactivateVmDisksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDeactivateVMDisksMsg());
    // $NON-NLS-1$
    model.setHashName("deactivate_vm_disk");
    setWindow(model);
    model.getLatch().setEntity(false);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((Disk) selected).getDiskAlias());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand unPlug = new UICommand("OnConfirmUnplug", this);
    unPlug.setTitle(ConstantsManager.getInstance().getConstants().ok());
    unPlug.setIsDefault(true);
    model.getCommands().add(unPlug);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#method_after
private void confirmUnplug() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().deactivateVmDisksTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantDeactivateVMDisksMsg());
    // $NON-NLS-1$
    model.setHashName("deactivate_vm_disk");
    setWindow(model);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((Disk) selected).getDiskAlias());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand unPlug = new UICommand("OnUnplug", this);
    unPlug.setTitle(ConstantsManager.getInstance().getConstants().ok());
    unPlug.setIsDefault(true);
    model.getCommands().add(unPlug);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#end_block

#method_before
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = getEntity();
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    boolean vmIsUp = vm.getStatus() == VMStatus.Up;
    model.setVmUp(vmIsUp);
    model.setWarningAvailable(vmIsUp);
    if (vmIsUp) {
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationWarning());
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationStorageFilteringNote());
    }
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#method_after
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = getEntity();
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    boolean vmIsUp = vm.getStatus() == VMStatus.Up;
    model.setVmUp(vmIsUp);
    model.setWarningAvailable(vmIsUp);
    if (vmIsUp) {
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationWarning());
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationStorageFilteringNote());
    }
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disk);
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#end_block

#method_before
private void updateActionAvailability() {
    Disk disk = (Disk) getSelectedItem();
    getNewCommand().setIsExecutionAllowed(true);
    getEditCommand().setIsExecutionAllowed(disk != null && isSingleDiskSelected() && !isDiskLocked(disk) && (isVmDown() || !disk.getPlugged() || (isExtendImageSizeSupported() && isExtendImageSizeEnabled())));
    getRemoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && isRemoveCommandAvailable());
    getMoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && (isMoveCommandAvailable() || isLiveMoveCommandAvailable()));
    updateGetAlignmentCommandAvailability();
    updateScanAlignmentEnabled();
    getPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(true));
    getUnPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(false));
    ChangeQuotaModel.updateChangeQuotaActionAvailability(getItems() != null ? (List<Disk>) getItems() : null, getSelectedItems() != null ? (List<Disk>) getSelectedItems() : null, getSystemTreeSelectedItem(), getChangeQuotaCommand());
}
#method_after
private void updateActionAvailability() {
    Disk disk = (Disk) getSelectedItem();
    getNewCommand().setIsExecutionAllowed(true);
    getEditCommand().setIsExecutionAllowed(disk != null && isSingleDiskSelected() && !isDiskLocked(disk) && (isVmDown() || !disk.getPlugged() || (isExtendImageSizeSupported() && isExtendImageSizeEnabled())));
    getRemoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && isRemoveCommandAvailable());
    getMoveCommand().setIsExecutionAllowed(atLeastOneDiskSelected() && (isMoveCommandAvailable() || isLiveMoveCommandAvailable()));
    updateScanAlignmentCommandAvailability();
    getPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(true));
    getUnPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(false));
    ChangeQuotaModel.updateChangeQuotaActionAvailability(getItems() != null ? (List<Disk>) getItems() : null, getSelectedItems() != null ? (List<Disk>) getSelectedItems() : null, getSystemTreeSelectedItem(), getChangeQuotaCommand());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getMoveCommand()) {
        move();
    } else if (command == getScanAlignmentCommand()) {
        scanAlignment();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (command == getPlugCommand()) {
        plug(true);
    } else if (command == getUnPlugCommand()) {
        confirmUnplug();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnConfirmUnplug")) {
        plug(false);
    } else if (command == getChangeQuotaCommand()) {
        changeQuota();
    } else if (command.getName().equals("onChangeQuota")) {
        // $NON-NLS-1$
        onChangeQuota();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getMoveCommand()) {
        move();
    } else if (command == getScanAlignmentCommand()) {
        scanAlignment();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (command == getPlugCommand()) {
        plug();
    } else if (command == getUnPlugCommand()) {
        confirmUnplug();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnUnplug")) {
        unplug();
    } else if (command == getChangeQuotaCommand()) {
        changeQuota();
    } else if (command.getName().equals("onChangeQuota")) {
        // $NON-NLS-1$
        onChangeQuota();
    }
}
#end_block

#method_before
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (args.contains(ARG_LDAP_SERVERS)) {
                krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            } else {
                krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, Collections.EMPTY_MAP);
            }
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#method_after
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains, Map<String, List<String>> ldapServersPerGSSAPIDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            useDnsLookup = utilityConfiguration.getUseDnsLookup();
            if (!args.contains(ARG_LDAP_SERVERS) && useDnsLookup) {
                // The arguments do not contain a list of ldap servers, the
                // kerberos configuration should not be created according to it if
                // useDnsLookup is set to true as in this case the kdc and the domain_realm information
                // will be resolved by DNS during kerberos negotiation.
                ldapServersPerGSSAPIDomains = Collections.emptyMap();
            }
            krbConfCreator = new KrbConfCreator(gssapiDomainsString, useDnsLookup, ldapServersPerGSSAPIDomains);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#end_block

#method_before
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    updateWanColorDepthOptions(spice);
    updateWANDisableEffects(spice);
    spice.setSpiceProxyEnabled(isSpiceProxyDefined());
}
#method_after
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    updateWanColorDepthOptions(spice);
    updateWANDisableEffects(spice);
}
#end_block

#method_before
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "userportal.json", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // TODO: don't hardcode userportal application name here
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "userportal.json", documentationFileFetchedEvent);
}
#end_block

#method_before
public static String getPath(String hashName) {
    String path = null;
    if (hashName != null && documentationPathMap != null) {
        path = documentationPathMap.get(hashName);
    }
    return path;
}
#method_after
public static String getPath(String helpTag) {
    String path = null;
    if (helpTag != null && documentationPathMap != null) {
        path = documentationPathMap.get(helpTag);
    }
    return path;
}
#end_block

#method_before
public static void init(String fileContent) {
    // fileContent is a JSON object with all unknown fields
    Mapping mapping = JsonUtils.safeEval(fileContent);
    JSONObject mappingJson = new JSONObject(mapping);
    documentationPathMap = new HashMap<String, String>();
    for (String docTag : mappingJson.keySet()) {
        JSONValue url = mappingJson.get(docTag);
        JSONString urlString = url.isString();
        if (docTag != null && urlString != null && !docTag.isEmpty() && !urlString.stringValue().isEmpty() && !documentationPathMap.containsKey(docTag)) {
            documentationPathMap.put(docTag, urlString.stringValue());
        }
    }
}
#method_after
public static void init(String fileContent) {
    // fileContent is a JSON object with all unknown fields
    Mapping mapping = JsonUtils.safeEval(fileContent);
    JSONObject mappingJson = new JSONObject(mapping);
    documentationPathMap = new HashMap<String, String>();
    for (String docTag : mappingJson.keySet()) {
        JSONString urlString = mappingJson.get(docTag).isString();
        if (docTag != null && urlString != null && !docTag.isEmpty() && !urlString.stringValue().isEmpty() && !documentationPathMap.containsKey(docTag)) {
            documentationPathMap.put(docTag, urlString.stringValue());
        }
    }
}
#end_block

#method_before
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    spice.setWANDisableEffects(new ArrayList<WANDisableEffects>());
    spice.setWanOptionsEnabled(false);
    spice.setSpiceProxyEnabled(isSpiceProxyDefined());
}
#method_after
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    spice.setWANDisableEffects(new ArrayList<WANDisableEffects>());
    spice.setWanOptionsEnabled(false);
}
#end_block

#method_before
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "webadmin.json", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // TODO: don't hard code webadmin application name here
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "webadmin.json", documentationFileFetchedEvent);
}
#end_block

#method_before
@Override
public void edit(GuideModel object) {
    driver.edit(object);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            GuideModel guideModel = (GuideModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Progress".equals(propertyName)) {
                // $NON-NLS-1$
                if (guideModel.getProgress() == null) {
                    // Check whether there any available actions.
                    boolean hasAllowedActions = false;
                    for (Object item : Linq.concat(guideModel.getCompulsoryActions(), guideModel.getOptionalActions())) {
                        UICommand command = (UICommand) item;
                        if (command.getIsExecutionAllowed()) {
                            hasAllowedActions = true;
                            break;
                        }
                    }
                    // Choose an appropriate message matching the entity type (DC, Cluster or VM).
                    String message = null;
                    if (guideModel instanceof DataCenterGuideModel) {
                        message = constants.guidePopupConfiguredDataCenterLabel();
                    } else if (guideModel instanceof ClusterGuideModel) {
                        message = constants.guidePopupConfiguredClusterLabel();
                    } else if (guideModel instanceof VmGuideModel) {
                        message = constants.guidePopupConfiguredVmLabel();
                    }
                    if (!hasAllowedActions) {
                        if (!guideModel.getNote().getIsAvailable()) {
                            infoLabel.setText(message);
                        } else {
                            infoLabel.setText(configurationCompleted);
                            noteLabel.setText(guideModel.getNote().getEntity());
                        }
                        compulsorySection.setVisible(false);
                        optionalSection.setVisible(false);
                        // Rename dialog button.
                        guideModel.getCommands().get(0).setTitle(null);
                        guideModel.getCommands().get(0).setTitle(ConstantsManager.getInstance().getConstants().ok());
                    } else if (guideModel.getCompulsoryActions().isEmpty()) {
                        infoLabel.setText(configurationCompleted);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(false);
                    } else if (guideModel.getOptionalActions().isEmpty()) {
                        updateCreatedLabel(guideModel);
                        optionalSection.setVisible(false);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(true);
                    } else {
                        infoLabel.setText(unconfigured);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(false);
                    }
                }
                updateActionsPanels(guideModel);
            } else if ("Window".equals(propertyName)) {
                // $NON-NLS-1$
                if (guideModel.getLastExecutedCommand().getName().equals("Cancel")) {
                    // $NON-NLS-1$
                    redrawActionsPanels();
                }
            }
        }
    });
}
#method_after
@Override
public void edit(GuideModel object) {
    driver.edit(object);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            GuideModel guideModel = (GuideModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if (PropertyChangedEventArgs.Args.PROGRESS.toString().equals(propertyName)) {
                if (guideModel.getProgress() == null) {
                    // Check whether there any available actions.
                    boolean hasAllowedActions = false;
                    for (Object item : Linq.concat(guideModel.getCompulsoryActions(), guideModel.getOptionalActions())) {
                        UICommand command = (UICommand) item;
                        if (command.getIsExecutionAllowed()) {
                            hasAllowedActions = true;
                            break;
                        }
                    }
                    // Choose an appropriate message matching the entity type (DC, Cluster or VM).
                    String message = null;
                    if (guideModel instanceof DataCenterGuideModel) {
                        message = constants.guidePopupConfiguredDataCenterLabel();
                    } else if (guideModel instanceof ClusterGuideModel) {
                        message = constants.guidePopupConfiguredClusterLabel();
                    } else if (guideModel instanceof VmGuideModel) {
                        message = constants.guidePopupConfiguredVmLabel();
                    }
                    if (!hasAllowedActions) {
                        if (!guideModel.getNote().getIsAvailable()) {
                            infoLabel.setText(message);
                        } else {
                            infoLabel.setText(configurationCompleted);
                            noteLabel.setText(guideModel.getNote().getEntity());
                        }
                        compulsorySection.setVisible(false);
                        optionalSection.setVisible(false);
                        // Rename dialog button.
                        guideModel.getCommands().get(0).setTitle(null);
                        guideModel.getCommands().get(0).setTitle(ConstantsManager.getInstance().getConstants().ok());
                    } else if (guideModel.getCompulsoryActions().isEmpty()) {
                        infoLabel.setText(configurationCompleted);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(false);
                    } else if (guideModel.getOptionalActions().isEmpty()) {
                        updateCreatedLabel(guideModel);
                        optionalSection.setVisible(false);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(true);
                    } else {
                        infoLabel.setText(unconfigured);
                        optionalSection.setVisible(true);
                        compulsorySection.setVisible(true);
                        compulsoryActionsLabel.setVisible(false);
                    }
                }
                updateActionsPanels(guideModel);
            } else if ("Window".equals(propertyName)) {
                // $NON-NLS-1$
                if (guideModel.getLastExecutedCommand().getName().equals("Cancel")) {
                    // $NON-NLS-1$
                    redrawActionsPanels();
                }
            }
        }
    });
}
#end_block

#method_before
private SnapshotVDSCommandParameters buildLiveSnapshotParameters(Snapshot snapshot) {
    List<Disk> pluggedDisksForVm = getDiskDao().getAllForVm(getVm().getId(), true);
    List<DiskImage> filteredPluggedDisksForVm = ImagesHandler.filterImageDisks(pluggedDisksForVm, false, true, true);
    List<DiskImage> filteredPluggedDisks = ImagesHandler.imagesIntersection(filteredPluggedDisksForVm, getDisksList());
    if (FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion())) {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks, snapshot.getMemoryVolume());
    } else {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks);
    }
}
#method_after
private SnapshotVDSCommandParameters buildLiveSnapshotParameters(Snapshot snapshot) {
    List<Disk> pluggedDisksForVm = getDiskDao().getAllForVm(getVm().getId(), true);
    List<DiskImage> filteredPluggedDisksForVm = ImagesHandler.filterImageDisks(pluggedDisksForVm, false, true, true);
    // 'filteredPluggedDisks' should contain only disks from 'getDisksList()' that are plugged to the VM.
    List<DiskImage> filteredPluggedDisks = ImagesHandler.imagesIntersection(filteredPluggedDisksForVm, getDisksList());
    if (FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion())) {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks, snapshot.getMemoryVolume());
    } else {
        return new SnapshotVDSCommandParameters(getVm().getRunOnVds(), getVm().getId(), filteredPluggedDisks);
    }
}
#end_block

#method_before
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    model.getLatch().setEntity(false);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#method_after
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#end_block

#method_before
private void onMaintenance() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase();
        parameters.setStorageDomainId(getEntity().getId());
        if (a.getStoragePoolId() != null) {
            parameters.setStoragePoolId(a.getStoragePoolId());
        }
        list.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void onMaintenance() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        StorageDomain a = (StorageDomain) item;
        StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase();
        parameters.setStorageDomainId(getEntity().getId());
        if (a.getStoragePoolId() != null) {
            parameters.setStoragePoolId(a.getStoragePoolId());
        }
        list.add(parameters);
    }
    final ConfirmationModel confirmationModel = (ConfirmationModel) getWindow();
    confirmationModel.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            confirmationModel.stopProgress();
            setWindow(null);
        }
    }, null);
}
#end_block

#method_before
public void onMaintenance() {
    // Frontend.RunMultipleActions(VdcActionType.DeactivateStorageDomain,
    // SelectedItems.Cast<storage_domains>()
    // .Select(a => (VdcActionParametersBase)new StorageDomainPoolParametersBase(a.id, Entity.id))
    // .ToList()
    // );
    ArrayList<VdcActionParametersBase> pb = new ArrayList<VdcActionParametersBase>();
    for (StorageDomain a : Linq.<StorageDomain>cast(getSelectedItems())) {
        pb.add(new StorageDomainPoolParametersBase(a.getId(), getEntity().getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, pb);
}
#method_after
public void onMaintenance() {
    // Frontend.RunMultipleActions(VdcActionType.DeactivateStorageDomain,
    // SelectedItems.Cast<storage_domains>()
    // .Select(a => (VdcActionParametersBase)new StorageDomainPoolParametersBase(a.id, Entity.id))
    // .ToList()
    // );
    ArrayList<VdcActionParametersBase> pb = new ArrayList<VdcActionParametersBase>();
    for (StorageDomain a : Linq.<StorageDomain>cast(getSelectedItems())) {
        pb.add(new StorageDomainPoolParametersBase(a.getId(), getEntity().getId()));
    }
    final ConfirmationModel confirmationModel = (ConfirmationModel) getWindow();
    confirmationModel.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.DeactivateStorageDomain, pb, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            confirmationModel.stopProgress();
            setWindow(null);
        }
    });
}
#end_block

#method_before
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    model.getLatch().setEntity(false);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#method_after
private void maintenance() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceStorageDomainsTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingStorageDomainsIntoMaintenanceModeMsg());
    // $NON-NLS-1$
    model.setHashName("maintenance_storage_domain");
    setWindow(model);
    ArrayList<String> items = new ArrayList<String>();
    for (Object selected : getSelectedItems()) {
        items.add(((StorageDomain) selected).getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand maintenance = new UICommand("OnMaintenance", this);
    maintenance.setTitle(ConstantsManager.getInstance().getConstants().ok());
    maintenance.setIsDefault(true);
    model.getCommands().add(maintenance);
    // $NON-NLS-1$
    UICommand cancel = new UICommand("Cancel", this);
    cancel.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancel.setIsCancel(true);
    model.getCommands().add(cancel);
}
#end_block

#method_before
@Override
public void onLoad() {
    super.onLoad();
    // Defer size calculations until sizes are available.
    Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

        @Override
        public void execute() {
            int minWidth = calculateWidgetMinWidthNeeded();
            contentPanel.getElement().getStyle().setProperty(MIN_WIDTH, minWidth, Unit.PX);
            if (widgetMinWidth > 0) {
                siblingWidth = calculateSiblingWidth();
            }
            for (int i = 0; i < contentPanel.getWidgetCount() - 1; i++) {
                originallyVisible.add(contentPanel.getWidget(i).isVisible());
            }
            initializeCascadeMenuPanel();
        }
    });
    resizeHandlerRegistration = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent resizeEvent) {
            initializeCascadeMenuPanel();
        }
    });
    eventBus.addHandler(HeaderOffsetChangeEvent.getType(), new HeaderOffsetChangeEvent.HeaderOffsetChangeHandler() {

        @Override
        public void onHeaderOffsetChange(HeaderOffsetChangeEvent event) {
            initializeCascadeMenuPanel();
            // Unregister the resize handler, we don't need it because resizes trigger the
            // HeaderOffsetChangeEvents.
            unregisterResizeHandler();
        }
    });
}
#method_after
@Override
public void onLoad() {
    super.onLoad();
    // Defer size calculations until sizes are available.
    Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

        @Override
        public void execute() {
            int minWidth = calculateWidgetMinWidthNeeded();
            contentPanel.getElement().getStyle().setProperty(MIN_WIDTH, minWidth, Unit.PX);
            if (widgetMinWidth > 0) {
                siblingWidth = calculateSiblingWidth();
            }
            initializeCascadeMenuPanel();
        }
    });
    resizeHandlerRegistration = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent resizeEvent) {
            initializeCascadeMenuPanel();
        }
    });
    eventBus.addHandler(HeaderOffsetChangeEvent.getType(), new HeaderOffsetChangeEvent.HeaderOffsetChangeHandler() {

        @Override
        public void onHeaderOffsetChange(HeaderOffsetChangeEvent event) {
            initializeCascadeMenuPanel();
            // Unregister the resize handler, we don't need it because resizes trigger the
            // HeaderOffsetChangeEvents.
            unregisterResizeHandler();
        }
    });
}
#end_block

#method_before
private void toggleVisibleWidgets(int currentWidth) {
    int widgetWidth = 0;
    boolean foundEdge = false;
    if (contentPanel.getWidgetCount() > 1) {
        for (int i = 0; i < contentPanel.getWidgetCount() - 1; i++) {
            if (!originallyVisible.get(i)) {
                continue;
            }
            Widget widget = contentPanel.getWidget(i);
            // temporarily show the widget, so we get the actual width of the widget.
            widget.setVisible(true);
            if (foundEdge || (widgetWidth + widget.getOffsetWidth() > currentWidth)) {
                widget.setVisible(false);
                toolbarOnlyActionButtonList.get(i).setCascaded(true);
                foundEdge = true;
            } else {
                toolbarOnlyActionButtonList.get(i).setCascaded(false);
                widgetWidth += widget.getOffsetWidth();
            }
        }
    }
}
#method_after
private void toggleVisibleWidgets(int currentWidth) {
    int widgetWidth = 0;
    boolean foundEdge = false;
    if (contentPanel.getWidgetCount() > 1) {
        for (int i = 0; i < contentPanel.getWidgetCount() - 1; i++) {
            Widget widget = contentPanel.getWidget(i);
            if (originallyVisible.get(widget)) {
                // temporarily show the widget, so we get the actual width of the widget.
                widget.setVisible(true);
                if (foundEdge || (widgetWidth + widget.getOffsetWidth() > currentWidth)) {
                    widget.setVisible(false);
                    toolbarOnlyActionButtonList.get(i).setCascaded(true);
                    foundEdge = true;
                } else {
                    toolbarOnlyActionButtonList.get(i).setCascaded(false);
                    widgetWidth += widget.getOffsetWidth();
                }
            }
        }
    }
}
#end_block

#method_before
void updateActionButton(ActionButton button, ActionButtonDefinition<T> buttonDef) {
    button.asWidget().setVisible(buttonDef.isAccessible(getSelectedItems()) && buttonDef.isVisible(getSelectedItems()) && !buttonDef.isCascaded());
    button.setEnabled(buttonDef.isEnabled(getSelectedItems()));
    button.setTitle(buttonDef.getButtonToolTip() != null ? buttonDef.getButtonToolTip() : buttonDef.getTitle());
}
#method_after
void updateActionButton(ActionButton button, ActionButtonDefinition<T> buttonDef) {
    button.asWidget().setVisible(buttonDef.isAccessible(getSelectedItems()) && buttonDef.isVisible(getSelectedItems()) && !buttonDef.isCascaded());
    button.setEnabled(buttonDef.isEnabled(getSelectedItems()));
    button.setTitle(buttonDef.getButtonToolTip() != null ? buttonDef.getButtonToolTip() : buttonDef.getTitle());
    originallyVisible.put(button.asWidget(), buttonDef.isAccessible(getSelectedItems()) && buttonDef.isVisible(getSelectedItems()));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (ObjectUtils.notEqual(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            VmDeviceUtils.clearNicAddress(getInterface().getVmId(), getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getCompensationContext().snapshotEntity(oldIface);
                getVmNicDao().update(getInterface());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool) {
            if (succeeded) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            } else {
                MacPoolManager.getInstance().freeMac(getMacAddress());
            }
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (ObjectUtils.notEqual(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            getVmDeviceDao().clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getCompensationContext().snapshotEntity(oldIface);
                getVmNicDao().update(getInterface());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool) {
            if (succeeded) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            } else {
                MacPoolManager.getInstance().freeMac(getMacAddress());
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean mustChangeAddress(int oldType, int newType) {
    return (oldType == VmInterfaceType.spaprVlan.getValue() && newType != VmInterfaceType.spaprVlan.getValue()) || (oldType != VmInterfaceType.spaprVlan.getValue() && newType == VmInterfaceType.spaprVlan.getValue());
}
#method_after
private boolean mustChangeAddress(int oldType, int newType) {
    int spaprVlanType = VmInterfaceType.spaprVlan.getValue();
    return oldType == spaprVlanType ^ newType == spaprVlanType;
}
#end_block

