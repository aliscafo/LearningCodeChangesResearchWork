9
#method_before
private void resolveGroupsMemberships(List<ExtMap> groupsToResolve, Set<String> resolvedGroups) throws IOException, SQLException {
    if (groupsToResolve != null) {
        for (ExtMap groupRecord : groupsToResolve) {
            if (!resolvedGroups.contains(groupRecord.<String>get(Authz.GroupRecord.ID))) {
                resolvedGroups.add(groupRecord.<String>get(Authz.GroupRecord.ID));
                groupRecord.put(Authz.GroupRecord.GROUPS, getGroupMemberships(groupRecord));
                resolveGroupsMemberships(groupRecord.<List<ExtMap>>get(Authz.PrincipalRecord.GROUPS), resolvedGroups);
            }
        }
    }
}
#method_after
private void resolveGroupsMemberships(List<ExtMap> groupsToResolve, Set<String> resolvedGroups) throws IOException, SQLException {
    if (groupsToResolve != null) {
        for (ExtMap groupRecord : groupsToResolve) {
            if (!resolvedGroups.contains(groupRecord.<String>get(Authz.GroupRecord.ID))) {
                resolvedGroups.add(groupRecord.<String>get(Authz.GroupRecord.ID));
                groupRecord.put(Authz.GroupRecord.GROUPS, getGroupMemberships(groupRecord));
                resolveGroupsMemberships(groupRecord.<List<ExtMap>>get(Authz.GroupRecord.GROUPS), resolvedGroups);
            }
        }
    }
}
#end_block

#method_before
private void addBondOptionIfMissing(String candidateOption, boolean doesBondHaveVmNetworkAttached) {
    if (doesBondHaveVmNetworkAttached && BondMode.isBondModeValidForVmNetwork(candidateOption)) {
        return;
    }
    if (!pairForBondOption.containsKey(candidateOption)) {
        EntityModel<String> entityModel = new EntityModel<String>();
        entityModel.setEntity(candidateOption);
        // $NON-NLS-1$
        Entry<String, EntityModel<String>> newPair = new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel);
        bondOptions.add(newPair);
        pairForBondOption.put(candidateOption, newPair);
    }
}
#method_after
private void addBondOptionIfMissing(String candidateOption, boolean doesBondHaveVmNetworkAttached) {
    if (doesBondHaveVmNetworkAttached && !BondMode.isBondModeValidForVmNetwork(candidateOption)) {
        return;
    }
    if (!pairForBondOption.containsKey(candidateOption)) {
        EntityModel<String> entityModel = new EntityModel<String>();
        entityModel.setEntity(candidateOption);
        // $NON-NLS-1$
        Entry<String, EntityModel<String>> newPair = new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel);
        bondOptions.add(newPair);
        pairForBondOption.put(candidateOption, newPair);
    }
}
#end_block

#method_before
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    StorageFormatType targetFormat = updatePoolAndDomainsFormat(spVersion);
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade process of Storage Pool '{}' has encountered a problem due to following reason: {}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
            // and return.
            if (e.getVdsError() != null && e.getErrorCode() == VdcBllErrors.PoolUpgradeInProgress) {
                updatePoolAndDomainsFormat(oldSpVersion);
                return;
            }
        }
    }
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), new ArrayList<Guid>());
}
#method_after
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    StorageFormatType targetFormat = updatePoolAndDomainsFormat(spVersion);
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade process of Storage Pool '{0}' has encountered a problem due to following reason: {1}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
            // and return.
            if (e.getVdsError() != null && e.getErrorCode() == VdcBllErrors.PoolUpgradeInProgress) {
                updatePoolAndDomainsFormat(oldSpVersion);
                return;
            }
        }
    }
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), new ArrayList<Guid>());
}
#end_block

#method_before
private void updateMemberDomainsFormat(StorageFormatType targetFormat) {
    Guid spId = getStoragePool().getId();
    StorageDomainStaticDAO sdStatDao = DbFacade.getInstance().getStorageDomainStaticDao();
    List<StorageDomainStatic> domains = sdStatDao.getAllForStoragePool(spId);
    for (StorageDomainStatic domain : domains) {
        StorageDomainType sdType = domain.getStorageDomainType();
        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
            log.infoFormat("Setting storage domain '{}' (type '{}') to format '{}'", domain.getId(), sdType, targetFormat);
            domain.setStorageFormat(targetFormat);
            sdStatDao.update(domain);
        }
    }
}
#method_after
private void updateMemberDomainsFormat(StorageFormatType targetFormat) {
    Guid spId = getStoragePool().getId();
    StorageDomainStaticDAO sdStatDao = DbFacade.getInstance().getStorageDomainStaticDao();
    List<StorageDomainStatic> domains = sdStatDao.getAllForStoragePool(spId);
    for (StorageDomainStatic domain : domains) {
        StorageDomainType sdType = domain.getStorageDomainType();
        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
            log.infoFormat("Setting storage domain '{0}' (type '{1}') to format '{2}'", domain.getId(), sdType, targetFormat);
            domain.setStorageFormat(targetFormat);
            sdStatDao.update(domain);
        }
    }
}
#end_block

#method_before
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        if (isStoragePoolMemoryBackend(storagePool)) {
            connectStoragePool(selectedVds, storagePool);
        }
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        boolean ignoreSpmStatusResult = returnValueFromVds.getVdsError() != null && returnValueFromVds.getVdsError().getCode() == VdcBllErrors.InquireNotSupportedError;
        if (spmStatus != null || ignoreSpmStatusResult) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - '{}', spmStatus '{}', storage pool '{}', storage pool version '{}'", selectedVds.getName(), spmStatus != null ? spmStatus.getSpmStatus() : "unknown", storagePool.getName(), storagePool.getcompatibility_version());
            if (ignoreSpmStatusResult) {
                spmStatus = startSpm(storagePool, selectedVds, DEFAULT_PREV_ID, DEFAULT_LVER, DEFAULT_PREV_ID);
            } else {
                if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                    connectStoragePool(selectedVds, storagePool);
                    performedPoolConnect = true;
                    // refresh spmStatus result
                    spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                    log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {}, spmStatus {}, storage pool {}", selectedVds.getName(), spmStatus.getSpmStatus(), storagePool.getName());
                }
                RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
                spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
                selectedVds = tempRefObject.argvalue;
            }
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        if (isStoragePoolMemoryBackend(storagePool)) {
            connectStoragePool(selectedVds, storagePool);
        }
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        boolean ignoreSpmStatusResult = returnValueFromVds.getVdsError() != null && returnValueFromVds.getVdsError().getCode() == VdcBllErrors.InquireNotSupportedError;
        if (spmStatus != null || ignoreSpmStatusResult) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - '{0}', spmStatus '{1}', storage pool '{2}', storage pool version '{3}'", selectedVds.getName(), spmStatus != null ? spmStatus.getSpmStatus() : "unknown", storagePool.getName(), storagePool.getcompatibility_version());
            if (ignoreSpmStatusResult) {
                spmStatus = startSpm(storagePool, selectedVds, DEFAULT_PREV_ID, DEFAULT_LVER, DEFAULT_PREV_ID);
            } else {
                if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                    connectStoragePool(selectedVds, storagePool);
                    performedPoolConnect = true;
                    // refresh spmStatus result
                    spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                    log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus(), storagePool.getName());
                }
                RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
                spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
                selectedVds = tempRefObject.argvalue;
            }
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private SpmStatusResult startSpm(final StoragePool storagePool, VDS selectedVds, int prevId, String lver, int vdsSpmIdToFence) {
    storagePool.setStatus(StoragePoolStatus.Contend);
    storagePool.setspm_vds_id(selectedVds.getId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            DbFacade.getInstance().getStoragePoolDao().update(storagePool);
            return null;
        }
    });
    log.infoFormat("starting spm on vds '{}', storage pool '{}', prevId '{}', LVER '{}'", selectedVds.getName(), storagePool.getName(), prevId, lver);
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.getId(), _storagePoolId, prevId, lver, storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
    if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
        ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        if (spmStatus != null) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                    pool.setspm_vds_id(null);
                    DbFacade.getInstance().getStoragePoolDao().update(pool);
                    return null;
                }
            });
        }
        throw new IrsSpmStartFailedException();
    }
    return spmStatus;
}
#method_after
private SpmStatusResult startSpm(final StoragePool storagePool, VDS selectedVds, int prevId, String lver, int vdsSpmIdToFence) {
    storagePool.setStatus(StoragePoolStatus.Contend);
    storagePool.setspm_vds_id(selectedVds.getId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            DbFacade.getInstance().getStoragePoolDao().update(storagePool);
            return null;
        }
    });
    log.infoFormat("starting spm on vds '{0}', storage pool '{1}', prevId '{2}', LVER '{3}'", selectedVds.getName(), storagePool.getName(), prevId, lver);
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.getId(), _storagePoolId, prevId, lver, storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
    if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
        ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        if (spmStatus != null) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                    pool.setspm_vds_id(null);
                    DbFacade.getInstance().getStoragePoolDao().update(pool);
                    return null;
                }
            });
        }
        throw new IrsSpmStartFailedException();
    }
    return spmStatus;
}
#end_block

#method_before
void processMessage(Message message) {
    String command = message.getCommand();
    CommandExecutor executor = this.commandFactory.getCommandExecutor(command);
    Message response = executor.execute(message);
    if (Command.CONNECT.toString().equals(command)) {
        policy.setIdentifier(message.getHeaders().get(HEADER_HOST));
    }
    if (response != null) {
        this.send(response.build());
    }
    if (Command.DISCONNECT.toString().equals(command)) {
        try {
            channel.close();
        } catch (IOException ignored) {
        }
    }
}
#method_after
void processMessage(Message message) {
    String command = message.getCommand();
    CommandExecutor executor = this.commandFactory.getCommandExecutor(command);
    Message response = executor.execute(message);
    if (Command.CONNECT.toString().equals(command)) {
        if (message.getHeaders().get(HEADER_HOST) != null) {
            policy.setIdentifier(message.getHeaders().get(HEADER_HOST));
        }
    }
    if (response != null) {
        this.send(response.build());
    }
    if (Command.DISCONNECT.toString().equals(command)) {
        try {
            channel.close();
        } catch (IOException ignored) {
        }
    }
}
#end_block

#method_before
void processMessage(Message message) {
    String command = message.getCommand();
    CommandExecutor executor = this.commandFactory.getCommandExecutor(command);
    Message response = executor.execute(message);
    if (Command.CONNECT.toString().equals(command)) {
        policy.setIdentifier(message.getHeaders().get(HEADER_HOST));
    }
    if (response != null) {
        this.send(response.build());
    }
    if (Command.DISCONNECT.toString().equals(command)) {
        try {
            channel.close();
        } catch (IOException ignored) {
        // we do not care about IOE after disconnecting
        }
    }
}
#method_after
void processMessage(Message message) {
    String command = message.getCommand();
    CommandExecutor executor = this.commandFactory.getCommandExecutor(command);
    Message response = executor.execute(message);
    if (Command.CONNECT.toString().equals(command)) {
        if (message.getHeaders().get(HEADER_HOST) != null) {
            policy.setIdentifier(message.getHeaders().get(HEADER_HOST));
        }
    }
    if (response != null) {
        this.send(response.build());
    }
    if (Command.DISCONNECT.toString().equals(command)) {
        try {
            channel.close();
        } catch (IOException ignored) {
        // we do not care about IOE after disconnecting
        }
    }
}
#end_block

#method_before
private Response getSchema() {
    ByteArrayOutputStream baos = null;
    InputStream is = null;
    byte[] buffer = new byte[4096];
    try {
        baos = new ByteArrayOutputStream();
        is = Thread.currentThread().getContextClassLoader().getResourceAsStream(API_SCHEMA);
        int count;
        while ((count = is.read(buffer)) != -1) {
            baos.write(buffer, 0, count);
        }
        baos.flush();
        return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM).header("content-disposition", "attachment; filename = " + SCHEMA_NAME).build();
    } catch (IOException e) {
        LOG.error("Loading api.xsd file failed.", e);
        return Response.serverError().build();
    } finally {
        try {
            if (baos != null)
                baos.close();
            if (is != null)
                is.close();
        } catch (IOException e) {
            log.error("cannot close a resource", e);
        }
    }
}
#method_after
private Response getSchema() {
    ByteArrayOutputStream baos = null;
    InputStream is = null;
    byte[] buffer = new byte[4096];
    try {
        baos = new ByteArrayOutputStream();
        is = Thread.currentThread().getContextClassLoader().getResourceAsStream(API_SCHEMA);
        int count;
        while ((count = is.read(buffer)) != -1) {
            baos.write(buffer, 0, count);
        }
        baos.flush();
        return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM).header("content-disposition", "attachment; filename = " + SCHEMA_NAME).build();
    } catch (IOException e) {
        LOG.error("Loading api.xsd file failed.", e);
        return Response.serverError().build();
    } finally {
        try {
            if (baos != null)
                baos.close();
            if (is != null)
                is.close();
        } catch (IOException e) {
            LOG.error("cannot close a resource", e);
        }
    }
}
#end_block

