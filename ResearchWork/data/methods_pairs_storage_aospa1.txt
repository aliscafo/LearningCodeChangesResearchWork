102
#method_before
private boolean shouldListenForFingerprint() {
    return (mKeyguardIsVisible || !mDeviceInteractive || (mBouncer && !mKeyguardGoingAway) || mGoingToSleep || shouldListenForFingerprintAssistant() || (mKeyguardOccluded && mIsDreaming)) && !mSwitchingUser && !isFingerprintDisabled(getCurrentUser() && !mIsDeviceInPocket) && !mKeyguardGoingAway;
}
#method_after
private boolean shouldListenForFingerprint() {
    return (mKeyguardIsVisible || !mDeviceInteractive || (mBouncer && !mKeyguardGoingAway) || mGoingToSleep || shouldListenForFingerprintAssistant() || (mKeyguardOccluded && mIsDreaming)) && !mSwitchingUser && !isFingerprintDisabled(getCurrentUser()) && !mKeyguardGoingAway && !mIsDeviceInPocket;
}
#end_block

#method_before
Drawable getResetIconDrawable(Context context, LauncherActivityInfoCompat app, ItemInfo info) {
    Drawable icon = new BitmapDrawable(context.getResources(), getDrawableIconForPackage(info.getTargetComponent()));
    return new BitmapDrawable(context.getResources(), Utilities.createBadgedIconBitmap(icon, info.user, context, 0));
}
#method_after
Drawable getResetIconDrawable(Context context, LauncherActivityInfoCompat app, ItemInfo info) {
    final Drawable icon = new BitmapDrawable(context.getResources(), getDrawableIconForPackage(info.getTargetComponent()));
    return new BitmapDrawable(context.getResources(), Utilities.createBadgedIconBitmap(icon, info.user, context, 0));
}
#end_block

#method_before
Bitmap getAppliedIconBitmap(Context context, IconCache iconCache, LauncherActivityInfoCompat app, ItemInfo info) {
    Drawable defaultIcon = new BitmapDrawable(context.getResources(), iconCache.getNonNullIcon(iconCache.getCacheEntry(app), info.user));
    return Utilities.createBadgedIconBitmap(defaultIcon, info.user, context, 0);
}
#method_after
Bitmap getAppliedIconBitmap(Context context, IconCache iconCache, LauncherActivityInfoCompat app, ItemInfo info) {
    final Drawable defaultIcon = new BitmapDrawable(context.getResources(), iconCache.getNonNullIcon(iconCache.getCacheEntry(app), info.user));
    return Utilities.createBadgedIconBitmap(defaultIcon, info.user, context, 0);
}
#end_block

#method_before
void toggleSelection(ActionBar actionBar, int position, String packageName) {
    if (mSelections.contains(packageName)) {
        mSelections.remove(packageName);
    } else {
        mSelections.add(packageName);
    }
    if (mSelections.size() != 0) {
        actionBar.setTitle(String.valueOf(mSelections.size()) + mContext.getString(R.string.hide_app_selected));
    } else {
        actionBar.setTitle(mContext.getString(R.string.hidden_app));
    }
    notifyItemChanged(position);
}
#method_after
void toggleSelection(ActionBar actionBar, int position, String packageName) {
    if (mSelections.contains(packageName)) {
        mSelections.remove(packageName);
    } else {
        mSelections.add(packageName);
    }
    if (!mSelections.isEmpty()) {
        actionBar.setTitle(String.valueOf(mSelections.size()) + mContext.getString(R.string.hide_app_selected));
    } else {
        actionBar.setTitle(mContext.getString(R.string.hidden_app));
    }
    notifyItemChanged(position);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.beginSection("Launcher-onCreate");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    mThemeManager = (ThemeManager) getSystemService(Context.THEME_SERVICE);
    if (mThemeManager != null) {
        mThemeManager.addCallback(mThemeCallback);
    }
    getTheme().applyStyle(R.style.LauncherTheme, true);
    getTheme().applyStyle(mAccentColor, true);
    getTheme().applyStyle(R.style.LauncherThemeNoParent, true);
    super.onCreate(savedInstanceState);
    LauncherAppState app = LauncherAppState.getInstance();
    // Load configuration-specific DeviceProfile
    mDeviceProfile = getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE ? app.getInvariantDeviceProfile().landscapeProfile : app.getInvariantDeviceProfile().portraitProfile;
    mSharedPrefs = Utilities.getPrefs(this);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mModel = app.setLauncher(this);
    mIconCache = app.getIconCache();
    mAccessibilityDelegate = new LauncherAccessibilityDelegate(this);
    mDragController = new DragController(this);
    mAllAppsController = new AllAppsTransitionController(this);
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this, mAllAppsController);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this, false);
    mExtractedColors = new ExtractedColors();
    loadExtractedColorsAndColorItems();
    ((AccessibilityManager) getSystemService(ACCESSIBILITY_SERVICE)).addAccessibilityStateChangeListener(this);
    lockAllApps();
    mIconsHandler = IconCache.getIconsHandler(this);
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.endSection();
    }
    // configuration change) while launcher is in the foreground
    if (!mModel.startLoader(mWorkspace.getRestorePage())) {
        // If we are not binding synchronously, show a fade in animation when
        // the first page bind completes.
        mDragLayer.setAlpha(0);
    } else {
        setWorkspaceLoading(true);
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(ACTION_APPWIDGET_HOST_RESET);
    registerReceiver(mUiBroadcastReceiver, filter);
    mLauncherTab = new LauncherTab(this);
    mRotationEnabled = getResources().getBoolean(R.bool.allow_rotation);
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext());
        mRotationPrefChangeHandler = new RotationPrefChangeHandler();
        mSharedPrefs.registerOnSharedPreferenceChangeListener(mRotationPrefChangeHandler);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    mTextColor = getColor(android.R.color.white);
    mOriginalTextColor = getColor(R.color.quantum_panel_text_color);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.beginSection("Launcher-onCreate");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    mThemeManager = (ThemeManager) getSystemService(Context.THEME_SERVICE);
    if (mThemeManager != null) {
        mThemeManager.addCallback(mThemeCallback);
    }
    getTheme().applyStyle(R.style.LauncherTheme, true);
    getTheme().applyStyle(mAccentColor, true);
    getTheme().applyStyle(R.style.LauncherThemeNoParent, true);
    super.onCreate(savedInstanceState);
    LauncherAppState app = LauncherAppState.getInstance();
    // Load configuration-specific DeviceProfile
    mDeviceProfile = getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE ? app.getInvariantDeviceProfile().landscapeProfile : app.getInvariantDeviceProfile().portraitProfile;
    mSharedPrefs = Utilities.getPrefs(this);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mModel = app.setLauncher(this);
    mIconCache = app.getIconCache();
    mAccessibilityDelegate = new LauncherAccessibilityDelegate(this);
    mDragController = new DragController(this);
    mAllAppsController = new AllAppsTransitionController(this);
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this, mAllAppsController);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    mHotseatAccentColor = Utilities.getColorAccent(this);
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this, false);
    mExtractedColors = new ExtractedColors();
    loadExtractedColorsAndColorItems();
    ((AccessibilityManager) getSystemService(ACCESSIBILITY_SERVICE)).addAccessibilityStateChangeListener(this);
    lockAllApps();
    mIconsHandler = IconCache.getIconsHandler(this);
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.endSection();
    }
    // configuration change) while launcher is in the foreground
    if (!mModel.startLoader(mWorkspace.getRestorePage())) {
        // If we are not binding synchronously, show a fade in animation when
        // the first page bind completes.
        mDragLayer.setAlpha(0);
    } else {
        setWorkspaceLoading(true);
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(ACTION_APPWIDGET_HOST_RESET);
    registerReceiver(mUiBroadcastReceiver, filter);
    mLauncherTab = new LauncherTab(this);
    mRotationEnabled = getResources().getBoolean(R.bool.allow_rotation);
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext());
        mRotationPrefChangeHandler = new RotationPrefChangeHandler();
        mSharedPrefs.registerOnSharedPreferenceChangeListener(mRotationPrefChangeHandler);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    mTextColor = getColor(android.R.color.white);
    mOriginalTextColor = getColor(R.color.quantum_panel_text_color);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.launcher_customization);
    mPackageManager = getActivity().getPackageManager();
    mDefaultIconPack = getString(R.string.default_iconpack_title);
    mIconsHandler = IconCache.getIconsHandler(getActivity().getApplicationContext());
    mIconPack = (Preference) findPreference(Utilities.KEY_ICON_PACK);
    reloadIconPackSummary();
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.launcher_customization);
    mPackageManager = getActivity().getPackageManager();
    mDefaultIconPack = getString(R.string.default_iconpack_title);
    mIconsHandler = IconCache.getIconsHandler(getActivity().getApplicationContext());
    mIconPack = (Preference) findPreference(Utilities.KEY_ICON_PACK);
    mHiddenApp = (Preference) findPreference(Utilities.KEY_HIDDEN_APPS);
    reloadIconPackSummary();
}
#end_block

#method_before
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference pref) {
    if (pref == mIconPack) {
        mIconsHandler.showDialog(getActivity());
        return true;
    }
    if (pref == mHiddenApps) {
        Intent intent = new Intent(getActivity(), MultiSelectRecyclerViewActivity.class);
        startActivity(intent);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference pref) {
    if (pref == mIconPack) {
        mIconsHandler.showDialog(getActivity());
        return true;
    }
    if (pref == mHiddenApp) {
        Intent intent = new Intent(getActivity(), MultiSelectRecyclerViewActivity.class);
        startActivity(intent);
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle item selection
    switch(item.getItemId()) {
        case R.id.hide:
            updateHiddenApps();
            break;
    }
    return super.onOptionsItemSelected(item);
}
#method_after
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    updateHiddenApps();
    return super.onOptionsItemSelected(item);
}
#end_block

#method_before
private void updateHiddenApps() {
    mAdapter.addSelectionsToHideList(this);
    LauncherAppState appState = LauncherAppState.getInstance();
    if (appState != null) {
        appState.getModel().forceReload();
    }
    navigateUpTo(new Intent(this, Launcher.class));
}
#method_after
private void updateHiddenApps() {
    mAdapter.addSelectionsToHideList(MultiSelectRecyclerViewActivity.this);
    LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
    if (appState != null) {
        appState.getModel().forceReload();
    }
    navigateUpTo(new Intent(MultiSelectRecyclerViewActivity.this, Launcher.class));
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_multiselect);
    mActionBar = getActionBar();
    Set<String> mSelectedApps = PreferenceManager.getDefaultSharedPreferences(this).getStringSet(Utilities.KEY_HIDDEN_APPS_SET, null);
    if (mSelectedApps != null) {
        if (mSelectedApps.size() != 0) {
            mActionBar.setTitle(String.valueOf(mSelectedApps.size()) + getString(R.string.hide_app_selected));
        } else {
            mActionBar.setTitle(getString(R.string.hidden_app));
        }
    }
    mInstalledPackages = getInstalledApps();
    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.my_recycler_view);
    recyclerView.setHasFixedSize(true);
    recyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false));
    mAdapter = new MultiSelectRecyclerViewAdapter(MultiSelectRecyclerViewActivity.this, mInstalledPackages, this);
    recyclerView.setAdapter(mAdapter);
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_multiselect);
    mActionBar = getActionBar();
    Set<String> hiddenApps = PreferenceManager.getDefaultSharedPreferences(MultiSelectRecyclerViewActivity.this).getStringSet(Utilities.KEY_HIDDEN_APPS_SET, null);
    if (hiddenApps != null) {
        if (!hiddenApps.isEmpty()) {
            mActionBar.setTitle(String.valueOf(hiddenApps.size()) + getString(R.string.hide_app_selected));
        } else {
            mActionBar.setTitle(getString(R.string.hidden_app));
        }
    }
    mInstalledPackages = getInstalledApps();
    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
    recyclerView.setHasFixedSize(true);
    recyclerView.setLayoutManager(new LinearLayoutManager(MultiSelectRecyclerViewActivity.this, LinearLayoutManager.VERTICAL, false));
    mAdapter = new MultiSelectRecyclerViewAdapter(MultiSelectRecyclerViewActivity.this, mInstalledPackages, this);
    recyclerView.setAdapter(mAdapter);
}
#end_block

#method_before
static Bitmap getEditIconBitmap(Context context, IconCache mIconCache, LauncherActivityInfoCompat app, ItemInfo info) {
    Drawable defaultIcon = new BitmapDrawable(context.getResources(), mIconCache.getNonNullIcon(mIconCache.getCacheEntry(app), info.user));
    return createBadgedIconBitmap(defaultIcon, info.user, context, 0);
}
#method_after
static Bitmap getEditIconBitmap(Context context, IconCache iconCache, LauncherActivityInfoCompat app, ItemInfo info) {
    Drawable defaultIcon = new BitmapDrawable(context.getResources(), iconCache.getNonNullIcon(iconCache.getCacheEntry(app), info.user));
    return createBadgedIconBitmap(defaultIcon, info.user, context, 0);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.beginSection("Launcher-onCreate");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    mThemeManager = (ThemeManager) getSystemService(Context.THEME_SERVICE);
    if (mThemeManager != null) {
        mThemeManager.addCallback(mThemeCallback);
    }
    getTheme().applyStyle(R.style.LauncherTheme, true);
    getTheme().applyStyle(mAccentColor, true);
    getTheme().applyStyle(R.style.LauncherThemeNoParent, true);
    super.onCreate(savedInstanceState);
    LauncherAppState app = LauncherAppState.getInstance();
    // Load configuration-specific DeviceProfile
    mDeviceProfile = getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE ? app.getInvariantDeviceProfile().landscapeProfile : app.getInvariantDeviceProfile().portraitProfile;
    mSharedPrefs = Utilities.getPrefs(this);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mModel = app.setLauncher(this);
    mIconCache = app.getIconCache();
    mAccessibilityDelegate = new LauncherAccessibilityDelegate(this);
    mDragController = new DragController(this);
    mAllAppsController = new AllAppsTransitionController(this);
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this, mAllAppsController);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this, false);
    mExtractedColors = new ExtractedColors();
    loadExtractedColorsAndColorItems();
    ((AccessibilityManager) getSystemService(ACCESSIBILITY_SERVICE)).addAccessibilityStateChangeListener(this);
    lockAllApps();
    mIconsHandler = IconCache.getIconsHandler(this);
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.endSection();
    }
    // configuration change) while launcher is in the foreground
    if (!mModel.startLoader(mWorkspace.getRestorePage())) {
        // If we are not binding synchronously, show a fade in animation when
        // the first page bind completes.
        mDragLayer.setAlpha(0);
    } else {
        setWorkspaceLoading(true);
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(ACTION_APPWIDGET_HOST_RESET);
    registerReceiver(mUiBroadcastReceiver, filter);
    mLauncherTab = new LauncherTab(this);
    mRotationEnabled = getResources().getBoolean(R.bool.allow_rotation);
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext());
        mRotationPrefChangeHandler = new RotationPrefChangeHandler();
        mSharedPrefs.registerOnSharedPreferenceChangeListener(mRotationPrefChangeHandler);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    mTextColor = getColor(android.R.color.white);
    mOriginalTextColor = getColor(R.color.quantum_panel_text_color);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.beginSection("Launcher-onCreate");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    mThemeManager = (ThemeManager) getSystemService(Context.THEME_SERVICE);
    if (mThemeManager != null) {
        mThemeManager.addCallback(mThemeCallback);
    }
    getTheme().applyStyle(R.style.LauncherTheme, true);
    getTheme().applyStyle(mAccentColor, true);
    getTheme().applyStyle(R.style.LauncherThemeNoParent, true);
    super.onCreate(savedInstanceState);
    LauncherAppState app = LauncherAppState.getInstance();
    // Load configuration-specific DeviceProfile
    mDeviceProfile = getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE ? app.getInvariantDeviceProfile().landscapeProfile : app.getInvariantDeviceProfile().portraitProfile;
    mSharedPrefs = Utilities.getPrefs(this);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mModel = app.setLauncher(this);
    mIconCache = app.getIconCache();
    mAccessibilityDelegate = new LauncherAccessibilityDelegate(this);
    mDragController = new DragController(this);
    mAllAppsController = new AllAppsTransitionController(this);
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this, mAllAppsController);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    mHotseatAccentColor = Utilities.getColorAccent(this);
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this, false);
    mExtractedColors = new ExtractedColors();
    loadExtractedColorsAndColorItems();
    ((AccessibilityManager) getSystemService(ACCESSIBILITY_SERVICE)).addAccessibilityStateChangeListener(this);
    lockAllApps();
    mIconsHandler = IconCache.getIconsHandler(this);
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (LauncherAppState.PROFILE_STARTUP) {
        Trace.endSection();
    }
    // configuration change) while launcher is in the foreground
    if (!mModel.startLoader(mWorkspace.getRestorePage())) {
        // If we are not binding synchronously, show a fade in animation when
        // the first page bind completes.
        mDragLayer.setAlpha(0);
    } else {
        setWorkspaceLoading(true);
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(ACTION_APPWIDGET_HOST_RESET);
    registerReceiver(mUiBroadcastReceiver, filter);
    mLauncherTab = new LauncherTab(this);
    mRotationEnabled = getResources().getBoolean(R.bool.allow_rotation);
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext());
        mRotationPrefChangeHandler = new RotationPrefChangeHandler();
        mSharedPrefs.registerOnSharedPreferenceChangeListener(mRotationPrefChangeHandler);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    mTextColor = getColor(android.R.color.white);
    mOriginalTextColor = getColor(R.color.quantum_panel_text_color);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
    }
}
#end_block

#method_before
public static void setUpdateHotseatColor() {
    updateHotseatColor = true;
}
#method_after
public static void setUpdateHotseatColor() {
    sUpdateHotseatColor = true;
}
#end_block

#method_before
@Override
protected void onResume() {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
        Log.v(TAG, "Launcher.onResume()");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnResume();
    }
    super.onResume();
    getUserEventDispatcher().resetElapsedSessionMillis();
    // bind unread number service
    mModel.bindUnreadService();
    // Restore the previous launcher state
    if (mOnResumeState == State.WORKSPACE) {
        showWorkspace(false);
    } else if (mOnResumeState == State.APPS) {
        boolean launchedFromApp = (mWaitingForResume != null);
        // Don't update the predicted apps if the user is returning to launcher in the apps
        // view after launching an app, as they may be depending on the UI to be static to
        // switch to another app, otherwise, if it was
        showAppsView(false, /* animated */
        !launchedFromApp, /* updatePredictedApps */
        mAppsView.shouldRestoreImeState());
    } else if (mOnResumeState == State.WIDGETS) {
        showWidgetsView(false, false);
    }
    mOnResumeState = State.NONE;
    mPaused = false;
    if (mOnResumeNeedsLoad) {
        setWorkspaceLoading(true);
        mModel.startLoader(getCurrentWorkspaceScreen());
        mOnResumeNeedsLoad = false;
    }
    if (mBindOnResumeCallbacks.size() > 0) {
        // We might have postponed some bind calls until onResume (see waitUntilResume) --
        // execute them here
        long startTimeCallbacks = 0;
        if (DEBUG_RESUME_TIME) {
            startTimeCallbacks = System.currentTimeMillis();
        }
        for (int i = 0; i < mBindOnResumeCallbacks.size(); i++) {
            mBindOnResumeCallbacks.get(i).run();
        }
        mBindOnResumeCallbacks.clear();
        if (DEBUG_RESUME_TIME) {
            Log.d(TAG, "Time spent processing callbacks in onResume: " + (System.currentTimeMillis() - startTimeCallbacks));
        }
    }
    if (mOnResumeCallbacks.size() > 0) {
        for (int i = 0; i < mOnResumeCallbacks.size(); i++) {
            mOnResumeCallbacks.get(i).run();
        }
        mOnResumeCallbacks.clear();
    }
    // were launching
    if (mWaitingForResume != null) {
        // Resets the previous workspace icon press state
        mWaitingForResume.setStayPressed(false);
    }
    // orientation.
    if (!isWorkspaceLoading()) {
        getWorkspace().reinflateWidgetsIfNecessary();
    }
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onResume: " + (System.currentTimeMillis() - startTime));
    }
    // suppress here.
    if (mWorkspace.getCustomContentCallbacks() != null && !mMoveToDefaultScreenFromNewIntent) {
        // if PagedView#setRestorePage was set to the custom content page in onCreate().
        if (mWorkspace.isOnOrMovingToCustomContent()) {
            mWorkspace.getCustomContentCallbacks().onShow(true);
        }
    }
    mMoveToDefaultScreenFromNewIntent = false;
    updateInteraction(Workspace.State.NORMAL, mWorkspace.getState());
    mWorkspace.onResume();
    if (!isWorkspaceLoading()) {
        // Process any items that were added while Launcher was away.
        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
        // Refresh shortcuts if the permission changed.
        mModel.refreshShortcutsIfRequired();
        // update hotseat color
        if (updateHotseatColor) {
            updateHotseatColor = false;
            mHotseat.updateColor(mExtractedColors, !mPaused);
        }
    }
    if (shouldShowDiscoveryBounce()) {
        mAllAppsController.showDiscoveryBounce();
    }
    mIsResumeFromActionScreenOff = false;
    mLauncherTab.getClient().onResume();
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onResume();
    }
}
#method_after
@Override
protected void onResume() {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
        Log.v(TAG, "Launcher.onResume()");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnResume();
    }
    super.onResume();
    getUserEventDispatcher().resetElapsedSessionMillis();
    // bind unread number service
    mModel.bindUnreadService();
    // Restore the previous launcher state
    if (mOnResumeState == State.WORKSPACE) {
        showWorkspace(false);
    } else if (mOnResumeState == State.APPS) {
        boolean launchedFromApp = (mWaitingForResume != null);
        // Don't update the predicted apps if the user is returning to launcher in the apps
        // view after launching an app, as they may be depending on the UI to be static to
        // switch to another app, otherwise, if it was
        showAppsView(false, /* animated */
        !launchedFromApp, /* updatePredictedApps */
        mAppsView.shouldRestoreImeState());
    } else if (mOnResumeState == State.WIDGETS) {
        showWidgetsView(false, false);
    }
    mOnResumeState = State.NONE;
    mPaused = false;
    if (mOnResumeNeedsLoad) {
        setWorkspaceLoading(true);
        mModel.startLoader(getCurrentWorkspaceScreen());
        mOnResumeNeedsLoad = false;
    }
    if (mBindOnResumeCallbacks.size() > 0) {
        // We might have postponed some bind calls until onResume (see waitUntilResume) --
        // execute them here
        long startTimeCallbacks = 0;
        if (DEBUG_RESUME_TIME) {
            startTimeCallbacks = System.currentTimeMillis();
        }
        for (int i = 0; i < mBindOnResumeCallbacks.size(); i++) {
            mBindOnResumeCallbacks.get(i).run();
        }
        mBindOnResumeCallbacks.clear();
        if (DEBUG_RESUME_TIME) {
            Log.d(TAG, "Time spent processing callbacks in onResume: " + (System.currentTimeMillis() - startTimeCallbacks));
        }
    }
    if (mOnResumeCallbacks.size() > 0) {
        for (int i = 0; i < mOnResumeCallbacks.size(); i++) {
            mOnResumeCallbacks.get(i).run();
        }
        mOnResumeCallbacks.clear();
    }
    // were launching
    if (mWaitingForResume != null) {
        // Resets the previous workspace icon press state
        mWaitingForResume.setStayPressed(false);
    }
    // orientation.
    if (!isWorkspaceLoading()) {
        getWorkspace().reinflateWidgetsIfNecessary();
    }
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onResume: " + (System.currentTimeMillis() - startTime));
    }
    // suppress here.
    if (mWorkspace.getCustomContentCallbacks() != null && !mMoveToDefaultScreenFromNewIntent) {
        // if PagedView#setRestorePage was set to the custom content page in onCreate().
        if (mWorkspace.isOnOrMovingToCustomContent()) {
            mWorkspace.getCustomContentCallbacks().onShow(true);
        }
    }
    mMoveToDefaultScreenFromNewIntent = false;
    updateInteraction(Workspace.State.NORMAL, mWorkspace.getState());
    mWorkspace.onResume();
    if (!isWorkspaceLoading()) {
        // Process any items that were added while Launcher was away.
        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
        // Refresh shortcuts if the permission changed.
        mModel.refreshShortcutsIfRequired();
        // update hotseat color
        if (sUpdateHotseatColor) {
            sUpdateHotseatColor = false;
            mHotseat.updateColor(mExtractedColors, !mPaused);
        }
    }
    if (shouldShowDiscoveryBounce()) {
        mAllAppsController.showDiscoveryBounce();
    }
    mIsResumeFromActionScreenOff = false;
    mLauncherTab.getClient().onResume();
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onResume();
    }
}
#end_block

#method_before
public void updateColor(ExtractedColors extractedColors, boolean animate) {
    if (!mHasVerticalHotseat) {
        int selectedIndex = Utilities.resolveHotseatColor(mLauncher);
        int color = Utilities.isAccentColoredHotseatPrefEnabled(mLauncher) ? ColorUtils.setAlphaComponent(mLauncher.mAccentColor, (int) (0.18f * 255)) : extractedColors.getColor(selectedIndex, Color.TRANSPARENT);
        if (mBackgroundColorAnimator != null) {
            mBackgroundColorAnimator.cancel();
        }
        if (!animate) {
            setBackgroundColor(color);
        } else {
            mBackgroundColorAnimator = ValueAnimator.ofInt(mBackgroundColor, color);
            mBackgroundColorAnimator.setEvaluator(new ArgbEvaluator());
            mBackgroundColorAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    mBackground.setColor((Integer) animation.getAnimatedValue());
                }
            });
            mBackgroundColorAnimator.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    mBackgroundColorAnimator = null;
                }
            });
            mBackgroundColorAnimator.start();
        }
        mBackgroundColor = color;
    }
}
#method_after
public void updateColor(ExtractedColors extractedColors, boolean animate) {
    if (!mHasVerticalHotseat) {
        int selectedIndex = Utilities.resolveHotseatColor(mLauncher);
        int color = Utilities.isAccentColoredHotseatPrefEnabled(mLauncher) ? ColorUtils.setAlphaComponent(mLauncher.mHotseatAccentColor, (int) (0.18f * 255)) : extractedColors.getColor(selectedIndex, Color.TRANSPARENT);
        if (mBackgroundColorAnimator != null) {
            mBackgroundColorAnimator.cancel();
        }
        if (!animate) {
            setBackgroundColor(color);
        } else {
            mBackgroundColorAnimator = ValueAnimator.ofInt(mBackgroundColor, color);
            mBackgroundColorAnimator.setEvaluator(new ArgbEvaluator());
            mBackgroundColorAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    mBackground.setColor((Integer) animation.getAnimatedValue());
                }
            });
            mBackgroundColorAnimator.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    mBackgroundColorAnimator = null;
                }
            });
            mBackgroundColorAnimator.start();
        }
        mBackgroundColor = color;
    }
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.System.USE_EDGE_SERVICE_FOR_GESTURES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_DESIGN_FLAGS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLBTN_MUSIC_CONTROLS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ALERT_SLIDER_ORDER), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.System.USE_EDGE_SERVICE_FOR_GESTURES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_DESIGN_FLAGS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLBTN_MUSIC_CONTROLS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ALERT_SLIDER_ORDER), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.PIE_STATE), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
private void updateEdgeGestureListenerState() {
    int flags = 0;
    if (mUsingEdgeGestureServiceForGestures) {
        flags = EdgeServiceConstants.LONG_LIVING | EdgeServiceConstants.UNRESTRICTED;
        if (mStatusBar != null && !mStatusBar.isVisibleLw()) {
            flags |= EdgeGesturePosition.TOP.FLAG;
        }
        if (mNavigationBar != null && !mNavigationBar.isVisibleLw()) {
            if (mNavigationBarPosition == NAV_BAR_BOTTOM) {
                flags |= EdgeGesturePosition.BOTTOM.FLAG;
            } else if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                flags |= EdgeGesturePosition.RIGHT.FLAG;
            } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                flags |= EdgeGesturePosition.LEFT.FLAG;
            }
        }
    }
    if (mEdgeListenerActivated) {
        mEdgeGestureActivationListener.restoreListenerState();
        mEdgeListenerActivated = false;
    }
    if (flags != mLastEdgePositions) {
        mEdgeGestureManager.updateEdgeGestureActivationListener(mEdgeGestureActivationListener, flags);
        mLastEdgePositions = flags;
    }
}
#method_after
private void updateEdgeGestureListenerState() {
    int flags = 0;
    if (mUsingEdgeGestureServiceForGestures) {
        flags = EdgeServiceConstants.LONG_LIVING | EdgeServiceConstants.UNRESTRICTED;
        if (mStatusBar != null && !mStatusBar.isVisibleLw()) {
            flags |= EdgeGesturePosition.TOP.FLAG;
        }
        if (mNavigationBar != null && !mNavigationBar.isVisibleLw() && !immersiveModeImplementsPie() && !isStatusBarKeyguard()) {
            if (mNavigationBarPosition == NAV_BAR_BOTTOM) {
                flags |= EdgeGesturePosition.BOTTOM.FLAG;
            } else if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                flags |= EdgeGesturePosition.RIGHT.FLAG;
            } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                flags |= EdgeGesturePosition.LEFT.FLAG;
            }
        }
    }
    if (mEdgeListenerActivated) {
        mEdgeGestureActivationListener.restoreListenerState();
        mEdgeListenerActivated = false;
    }
    if (flags != mLastEdgePositions) {
        mEdgeGestureManager.updateEdgeGestureActivationListener(mEdgeGestureActivationListener, flags);
        mLastEdgePositions = flags;
    }
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasAlertSlider = mContext.getResources().getBoolean(R.bool.config_hasAlertSlider) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_state_path)) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_uevent_match_path));
    // Initialise Keypress Boost
    mBoostParamValWeak = context.getResources().getIntArray(com.android.internal.R.array.qboost_weak_param_value);
    mBoostParamValStrong = context.getResources().getIntArray(com.android.internal.R.array.qboost_strong_param_value);
    lIsPerfBoostEnabled = mBoostParamValWeak.length != 0 && mBoostParamValStrong.length != 0;
    if (lIsPerfBoostEnabled) {
        mPerfKey = new BoostFramework();
        mPerfRotation = new BoostFramework();
    }
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    // Custom input policy settings.
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        mKeyPressed.put(keyCode, false);
        mKeyConsumed.put(keyCode, false);
        mKeyDoubleTapPending.put(keyCode, false);
        mKeyDoubleTapRunnable.put(keyCode, createDoubleTapTimeoutRunnable(keyCode));
        mKeyDoubleTapBehaviorDefaultResId.put(keyCode, getKeyDoubleTapBehaviorResId(keyCode));
        mKeyLongPressBehaviorDefaultResId.put(keyCode, getKeyLongPressBehaviorResId(keyCode));
    }
    boolean enableKeyHandler = context.getResources().getBoolean(com.android.internal.R.bool.config_enableKeyHandler);
    if (enableKeyHandler) {
        mKeyHandler = new KeyHandler(mContext);
    }
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasAlertSlider = mContext.getResources().getBoolean(R.bool.config_hasAlertSlider) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_state_path)) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_uevent_match_path));
    // Initialise Keypress Boost
    mBoostParamValWeak = context.getResources().getIntArray(com.android.internal.R.array.qboost_weak_param_value);
    mBoostParamValStrong = context.getResources().getIntArray(com.android.internal.R.array.qboost_strong_param_value);
    lIsPerfBoostEnabled = mBoostParamValWeak.length != 0 && mBoostParamValStrong.length != 0;
    if (lIsPerfBoostEnabled) {
        mPerfKey = new BoostFramework();
        mPerfRotation = new BoostFramework();
    }
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM && !immersiveModeImplementsPie()) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT && !immersiveModeImplementsPie()) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT && !immersiveModeImplementsPie()) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    // Custom input policy settings.
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        mKeyPressed.put(keyCode, false);
        mKeyConsumed.put(keyCode, false);
        mKeyDoubleTapPending.put(keyCode, false);
        mKeyDoubleTapRunnable.put(keyCode, createDoubleTapTimeoutRunnable(keyCode));
        mKeyDoubleTapBehaviorDefaultResId.put(keyCode, getKeyDoubleTapBehaviorResId(keyCode));
        mKeyLongPressBehaviorDefaultResId.put(keyCode, getKeyLongPressBehaviorResId(keyCode));
    }
    boolean enableKeyHandler = context.getResources().getBoolean(com.android.internal.R.bool.config_enableKeyHandler);
    if (enableKeyHandler) {
        mKeyHandler = new KeyHandler(mContext);
    }
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources resources = mContext.getResources();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mVolBtnMusicControls = (Settings.System.getIntForUser(resolver, Settings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        final boolean useEdgeService = Settings.System.getIntForUser(resolver, Settings.System.USE_EDGE_SERVICE_FOR_GESTURES, 1, UserHandle.USER_CURRENT) == 1;
        if (useEdgeService ^ mUsingEdgeGestureServiceForGestures && mSystemReady) {
            if (!mUsingEdgeGestureServiceForGestures && useEdgeService) {
                mUsingEdgeGestureServiceForGestures = true;
                mWindowManagerFuncs.unregisterPointerEventListener(mSystemGestures);
            } else if (mUsingEdgeGestureServiceForGestures && !useEdgeService) {
                mUsingEdgeGestureServiceForGestures = false;
                mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
            }
            updateEdgeGestureListenerState();
        }
        final boolean defaultToNavigationBar = resources.getBoolean(com.android.internal.R.bool.config_defaultToNavigationBar);
        final boolean navBarEnabled = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_ENABLED, defaultToNavigationBar ? 1 : 0, UserHandle.USER_CURRENT) == 1;
        if (navBarEnabled != mNavBarEnabled) {
            mNavBarEnabled = navBarEnabled;
            SystemProperties.set("qemu.hw.mainkeys", mNavBarEnabled ? "0" : "1");
        }
        readConfigurationDependentBehaviors();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mSystemDesignFlags = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_DESIGN_FLAGS, 0, UserHandle.USER_CURRENT);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources resources = mContext.getResources();
    boolean updateRotation = false;
    boolean forceRelayout = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mVolBtnMusicControls = (Settings.System.getIntForUser(resolver, Settings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
        mPieState = Settings.Secure.getIntForUser(resolver, Settings.Secure.PIE_STATE, 0, UserHandle.USER_CURRENT) == 1;
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        final boolean useEdgeService = Settings.System.getIntForUser(resolver, Settings.System.USE_EDGE_SERVICE_FOR_GESTURES, 1, UserHandle.USER_CURRENT) == 1;
        if (useEdgeService ^ mUsingEdgeGestureServiceForGestures && mSystemReady) {
            if (!mUsingEdgeGestureServiceForGestures && useEdgeService) {
                mUsingEdgeGestureServiceForGestures = true;
                mWindowManagerFuncs.unregisterPointerEventListener(mSystemGestures);
            } else if (mUsingEdgeGestureServiceForGestures && !useEdgeService) {
                mUsingEdgeGestureServiceForGestures = false;
                mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
            }
            updateEdgeGestureListenerState();
        }
        final boolean defaultToNavigationBar = resources.getBoolean(com.android.internal.R.bool.config_defaultToNavigationBar);
        final boolean navBarEnabled = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_ENABLED, defaultToNavigationBar ? 1 : 0, UserHandle.USER_CURRENT) == 1;
        if (navBarEnabled != mNavBarEnabled) {
            mNavBarEnabled = navBarEnabled;
            SystemProperties.set("qemu.hw.mainkeys", mNavBarEnabled ? "0" : "1");
        // updateRotation = forceRelayout = true;
        }
        readConfigurationDependentBehaviors();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        final int systemDesignFlags = mSystemDesignFlags;
        mSystemDesignFlags = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_DESIGN_FLAGS, 0, UserHandle.USER_CURRENT);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true, forceRelayout);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode) {
    if (hasNavigationBar() && shouldNavigationBarOccupySpace()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            return fullWidth - getNavigationBarWidth(rotation, uiMode);
        }
    }
    return fullWidth;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode) {
    if (hasNavigationBar() && mNavigationBar != null && !shouldForceNavigationBarImmersive()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            return fullWidth - getNavigationBarWidth(rotation, uiMode);
        }
    }
    return fullWidth;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode) {
    if (hasNavigationBar() && shouldNavigationBarOccupySpace()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            return fullHeight - getNavigationBarHeight(rotation, uiMode);
        }
    }
    return fullHeight;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode) {
    if (hasNavigationBar() && mNavigationBar != null && !shouldForceNavigationBarImmersive()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            return fullHeight - getNavigationBarHeight(rotation, uiMode);
        }
    }
    return fullHeight;
}
#end_block

#method_before
@Override
public int getConfigDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode) {
    // of the screen.
    return getNonDecorDisplayHeight(fullWidth, fullHeight, rotation, uiMode) - (shouldStatusBarOccupySpace() ? mStatusBarHeight : 0);
}
#method_after
@Override
public int getConfigDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode) {
    // of the screen.
    return getNonDecorDisplayHeight(fullWidth, fullHeight, rotation, uiMode) - (!shouldForceStatusBarImmersive() ? mStatusBarHeight : 0);
}
#end_block

#method_before
@Override
public boolean getInsetHintLw(WindowManager.LayoutParams attrs, Rect taskBounds, int displayRotation, int displayWidth, int displayHeight, Rect outContentInsets, Rect outStableInsets, Rect outOutsets) {
    final int fl = PolicyControl.getWindowFlags(null, attrs);
    final int sysuiVis = PolicyControl.getSystemUiVisibility(null, attrs);
    final int systemUiVisibility = (sysuiVis | attrs.subtreeSystemUiVisibility);
    final boolean useOutsets = outOutsets != null && shouldUseOutsets(attrs, fl);
    if (useOutsets) {
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            if (displayRotation == Surface.ROTATION_0) {
                outOutsets.bottom += outset;
            } else if (displayRotation == Surface.ROTATION_90) {
                outOutsets.right += outset;
            } else if (displayRotation == Surface.ROTATION_180) {
                outOutsets.top += outset;
            } else if (displayRotation == Surface.ROTATION_270) {
                outOutsets.left += outset;
            }
        }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
        int availRight, availBottom;
        if (canHideNavigationBar() && (systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0) {
            availRight = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
            availBottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        } else {
            availRight = mRestrictedScreenLeft + mRestrictedScreenWidth;
            availBottom = mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
            if ((fl & FLAG_FULLSCREEN) != 0) {
                outContentInsets.set(mStableFullscreenLeft, mStableFullscreenTop, availRight - mStableFullscreenRight, availBottom - mStableFullscreenBottom);
            } else {
                outContentInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
            }
        } else if ((fl & FLAG_FULLSCREEN) != 0 || (fl & FLAG_LAYOUT_IN_OVERSCAN) != 0) {
            outContentInsets.setEmpty();
        } else if ((systemUiVisibility & (View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN)) == 0) {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        } else {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        }
        outStableInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
        if (taskBounds != null) {
            calculateRelevantTaskInsets(taskBounds, outContentInsets, displayWidth, displayHeight);
            calculateRelevantTaskInsets(taskBounds, outStableInsets, displayWidth, displayHeight);
        }
        return mForceShowSystemBars;
    }
    outContentInsets.setEmpty();
    outStableInsets.setEmpty();
    return mForceShowSystemBars;
}
#method_after
@Override
public boolean getInsetHintLw(WindowManager.LayoutParams attrs, Rect taskBounds, int displayRotation, int displayWidth, int displayHeight, Rect outContentInsets, Rect outStableInsets, Rect outOutsets) {
    final int fl = PolicyControl.getWindowFlags(null, attrs);
    final int sysuiVis = PolicyControl.getSystemUiVisibility(null, attrs);
    final int systemUiVisibility = (sysuiVis | attrs.subtreeSystemUiVisibility);
    final boolean forceNavBarImmersive = shouldForceNavigationBarImmersive();
    final boolean useOutsets = outOutsets != null && shouldUseOutsets(attrs, fl);
    if (useOutsets) {
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            if (displayRotation == Surface.ROTATION_0) {
                outOutsets.bottom += outset;
            } else if (displayRotation == Surface.ROTATION_90) {
                outOutsets.right += outset;
            } else if (displayRotation == Surface.ROTATION_180) {
                outOutsets.top += outset;
            } else if (displayRotation == Surface.ROTATION_270) {
                outOutsets.left += outset;
            }
        }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
        int availRight, availBottom;
        if (canHideNavigationBar() && (systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0) {
            availRight = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
            availBottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        } else {
            availRight = mRestrictedScreenLeft + mRestrictedScreenWidth;
            availBottom = mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
            if ((fl & FLAG_FULLSCREEN) != 0) {
                outContentInsets.set(mStableFullscreenLeft, mStableFullscreenTop, availRight - mStableFullscreenRight, availBottom - mStableFullscreenBottom);
            } else {
                outContentInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
            }
        } else if ((fl & FLAG_FULLSCREEN) != 0 || (fl & FLAG_LAYOUT_IN_OVERSCAN) != 0) {
            outContentInsets.setEmpty();
        } else if ((systemUiVisibility & (View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN)) == 0) {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        } else {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        }
        outStableInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
        if (taskBounds != null) {
            calculateRelevantTaskInsets(taskBounds, outContentInsets, displayWidth, displayHeight);
            calculateRelevantTaskInsets(taskBounds, outStableInsets, displayWidth, displayHeight);
        }
        return mForceShowSystemBars || forceNavBarImmersive;
    }
    outContentInsets.setEmpty();
    outStableInsets.setEmpty();
    return mForceShowSystemBars || forceNavBarImmersive;
}
#end_block

#method_before
@Override
public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation, int uiMode) {
    mDisplayRotation = displayRotation;
    final int overscanLeft, overscanTop, overscanRight, overscanBottom;
    if (isDefaultDisplay) {
        switch(displayRotation) {
            case Surface.ROTATION_90:
                overscanLeft = mOverscanTop;
                overscanTop = mOverscanRight;
                overscanRight = mOverscanBottom;
                overscanBottom = mOverscanLeft;
                break;
            case Surface.ROTATION_180:
                overscanLeft = mOverscanRight;
                overscanTop = mOverscanBottom;
                overscanRight = mOverscanLeft;
                overscanBottom = mOverscanTop;
                break;
            case Surface.ROTATION_270:
                overscanLeft = mOverscanBottom;
                overscanTop = mOverscanLeft;
                overscanRight = mOverscanTop;
                overscanBottom = mOverscanRight;
                break;
            default:
                overscanLeft = mOverscanLeft;
                overscanTop = mOverscanTop;
                overscanRight = mOverscanRight;
                overscanBottom = mOverscanBottom;
                break;
        }
    } else {
        overscanLeft = 0;
        overscanTop = 0;
        overscanRight = 0;
        overscanBottom = 0;
    }
    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0;
    mOverscanScreenTop = mRestrictedOverscanScreenTop = 0;
    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;
    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;
    mSystemLeft = 0;
    mSystemTop = 0;
    mSystemRight = displayWidth;
    mSystemBottom = displayHeight;
    mUnrestrictedScreenLeft = overscanLeft;
    mUnrestrictedScreenTop = overscanTop;
    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;
    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;
    mRestrictedScreenLeft = mUnrestrictedScreenLeft;
    mRestrictedScreenTop = mUnrestrictedScreenTop;
    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;
    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;
    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft;
    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop;
    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight;
    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom;
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    pf.left = df.left = of.left = vf.left = mDockLeft;
    pf.top = df.top = of.top = vf.top = mDockTop;
    pf.right = df.right = of.right = vf.right = mDockRight;
    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (isDefaultDisplay) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mHideLockScreen;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        boolean statusBarExpandedNotKeyguard = !isKeyguardShowing && mStatusBar != null && mStatusBar.getAttrs().height == MATCH_PARENT && mStatusBar.getAttrs().width == MATCH_PARENT;
        // bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mInputConsumer != null) {
                mHandler.sendMessage(mHandler.obtainMessage(MSG_DISPOSE_INPUT_CONSUMER, mInputConsumer));
                mInputConsumer = null;
            }
        } else if (mInputConsumer == null) {
            mInputConsumer = mWindowManagerFuncs.addInputConsumer(mHandler.getLooper(), mHideNavInputEventReceiverFactory);
        }
        // For purposes of positioning and showing the nav bar, if we have
        // decided that it can't be hidden (because of the screen aspect ratio),
        // then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight, displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent, navAllowedHidden, statusBarExpandedNotKeyguard);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)", mDockLeft, mDockTop, mDockRight, mDockBottom));
        updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing);
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
}
#method_after
@Override
public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation, int uiMode) {
    mDisplayRotation = displayRotation;
    final int overscanLeft, overscanTop, overscanRight, overscanBottom;
    if (isDefaultDisplay) {
        switch(displayRotation) {
            case Surface.ROTATION_90:
                overscanLeft = mOverscanTop;
                overscanTop = mOverscanRight;
                overscanRight = mOverscanBottom;
                overscanBottom = mOverscanLeft;
                break;
            case Surface.ROTATION_180:
                overscanLeft = mOverscanRight;
                overscanTop = mOverscanBottom;
                overscanRight = mOverscanLeft;
                overscanBottom = mOverscanTop;
                break;
            case Surface.ROTATION_270:
                overscanLeft = mOverscanBottom;
                overscanTop = mOverscanLeft;
                overscanRight = mOverscanTop;
                overscanBottom = mOverscanRight;
                break;
            default:
                overscanLeft = mOverscanLeft;
                overscanTop = mOverscanTop;
                overscanRight = mOverscanRight;
                overscanBottom = mOverscanBottom;
                break;
        }
    } else {
        overscanLeft = 0;
        overscanTop = 0;
        overscanRight = 0;
        overscanBottom = 0;
    }
    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0;
    mOverscanScreenTop = mRestrictedOverscanScreenTop = 0;
    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;
    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;
    mSystemLeft = 0;
    mSystemTop = 0;
    mSystemRight = displayWidth;
    mSystemBottom = displayHeight;
    mUnrestrictedScreenLeft = overscanLeft;
    mUnrestrictedScreenTop = overscanTop;
    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;
    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;
    mRestrictedScreenLeft = mUnrestrictedScreenLeft;
    mRestrictedScreenTop = mUnrestrictedScreenTop;
    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;
    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;
    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft;
    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop;
    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight;
    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom;
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    pf.left = df.left = of.left = vf.left = mDockLeft;
    pf.top = df.top = of.top = vf.top = mDockTop;
    pf.right = df.right = of.right = vf.right = mDockRight;
    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (isDefaultDisplay) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mHideLockScreen;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        boolean statusBarExpandedNotKeyguard = !isKeyguardShowing && mStatusBar != null && mStatusBar.getAttrs().height == MATCH_PARENT && mStatusBar.getAttrs().width == MATCH_PARENT;
        // However, if EdgeGestureService is in use, this is useless for us. carlosavignano@aospa.co
        if (!mUsingEdgeGestureServiceForGestures && hasNavigationBar()) {
            if (navVisible || navAllowedHidden) {
                if (mInputConsumer != null) {
                    mHandler.sendMessage(mHandler.obtainMessage(MSG_DISPOSE_INPUT_CONSUMER, mInputConsumer));
                    mInputConsumer = null;
                }
            } else if (mInputConsumer == null) {
                mInputConsumer = mWindowManagerFuncs.addInputConsumer(mHandler.getLooper(), mHideNavInputEventReceiverFactory);
            }
        }
        // For purposes of positioning and showing the nav bar, if we have
        // decided that it can't be hidden (because of the screen aspect ratio),
        // then take that into account.
        // navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight, displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent, navAllowedHidden, statusBarExpandedNotKeyguard);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)", mDockLeft, mDockTop, mDockRight, mDockBottom));
        updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing);
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
}
#end_block

#method_before
private boolean layoutStatusBar(Rect pf, Rect df, Rect of, Rect vf, Rect dcf, int sysui, boolean isKeyguardShowing) {
    // decide where the status bar goes ahead of time
    if (mStatusBar != null) {
        final int statusBarHeight = shouldStatusBarOccupySpace() ? mStatusBarHeight : 0;
        // apply any navigation bar insets
        // If global immersive is enabled we need to tell status bar to not occupy full display width
        // when on landscape, since everything thinks that space is available based on our setted
        // params (check layoutNavigationBar(), especially immersive comments).
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        vf.left = shouldNavigationBarOccupySpace() ? mStableLeft : mNavigationBarPosition == NAV_BAR_LEFT ? mStableLeft + getNavigationBarHeight(mDisplayRotation, mUiMode) : mStableLeft;
        vf.top = mStableTop;
        vf.right = shouldNavigationBarOccupySpace() ? mStableRight : mNavigationBarPosition == NAV_BAR_RIGHT ? mStableRight - getNavigationBarHeight(mDisplayRotation, mUiMode) : mStableRight;
        vf.bottom = mStableBottom;
        mStatusBarLayer = mStatusBar.getSurfaceLayer();
        // Let the status bar determine its size.
        mStatusBar.computeFrameLw(pf, /* parentFrame */
        df, /* displayFrame */
        vf, /* overlayFrame */
        vf, /* contentFrame */
        vf, /* visibleFrame */
        dcf, /* decorFrame */
        vf, /* stableFrame */
        vf);
        // For layout, the status bar is always at the top with our fixed height.
        mStableTop = mUnrestrictedScreenTop + statusBarHeight;
        boolean statusBarTransient = (sysui & View.STATUS_BAR_TRANSIENT) != 0;
        boolean statusBarTranslucent = (sysui & (View.STATUS_BAR_TRANSLUCENT | View.STATUS_BAR_TRANSPARENT)) != 0;
        if (!isKeyguardShowing) {
            statusBarTranslucent &= areTranslucentBarsAllowed();
        }
        // windows behind it to scroll.
        if (mStatusBar.isVisibleLw() && !statusBarTransient) {
            // Status bar may go away, so the screen area it occupies
            // is available to apps but just covering them when the
            // status bar is visible.
            mDockTop = mUnrestrictedScreenTop + statusBarHeight;
            mContentTop = mVoiceContentTop = mCurTop = mDockTop;
            mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
            mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
            mContentRight = mVoiceContentRight = mCurRight = mDockRight;
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Status bar: " + String.format("dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom));
        }
        if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw() && !statusBarTransient && !statusBarTranslucent && !mStatusBarController.wasRecentlyTranslucent()) {
            // If the opaque status bar is currently requested to be visible,
            // and not in the process of animating on or off, then
            // we can tell the app that it is covered by it.
            mSystemTop = mUnrestrictedScreenTop + statusBarHeight;
        }
        if (mStatusBarController.checkHiddenLw()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean layoutStatusBar(Rect pf, Rect df, Rect of, Rect vf, Rect dcf, int sysui, boolean isKeyguardShowing) {
    // decide where the status bar goes ahead of time
    if (mStatusBar != null) {
        final boolean hasNavBar = hasNavigationBar() && mNavigationBar != null;
        final boolean forceNavBarImmersive = shouldForceNavigationBarImmersive();
        final boolean forceStatusBarImmersive = shouldForceStatusBarImmersive();
        final int statusBarHeight = !forceStatusBarImmersive ? mStatusBarHeight : 0;
        // apply any navigation bar insets
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        vf.left = mStableLeft;
        vf.top = mStableTop;
        vf.right = mStableRight;
        vf.bottom = mStableBottom;
        // params (check layoutNavigationBar(), especially immersive comments). carlosavignano@aospa.co
        if (hasNavBar && forceNavBarImmersive) {
            if (isLandscapeOrSeascape(mDisplayRotation)) {
                if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                    vf.right -= getNavigationBarWidth(mDisplayRotation, mUiMode);
                } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                    vf.left += getNavigationBarWidth(mDisplayRotation, mUiMode);
                }
            }
        }
        mStatusBarLayer = mStatusBar.getSurfaceLayer();
        // Let the status bar determine its size.
        mStatusBar.computeFrameLw(pf, /* parentFrame */
        df, /* displayFrame */
        vf, /* overlayFrame */
        vf, /* contentFrame */
        vf, /* visibleFrame */
        dcf, /* decorFrame */
        vf, /* stableFrame */
        vf);
        // For layout, the status bar is always at the top with our fixed height.
        mStableTop = mUnrestrictedScreenTop + statusBarHeight;
        boolean statusBarTransient = (sysui & View.STATUS_BAR_TRANSIENT) != 0;
        boolean statusBarTranslucent = (sysui & (View.STATUS_BAR_TRANSLUCENT | View.STATUS_BAR_TRANSPARENT)) != 0;
        if (!isKeyguardShowing) {
            statusBarTranslucent &= areTranslucentBarsAllowed();
        }
        // windows behind it to scroll.
        if (mStatusBar.isVisibleLw() && !statusBarTransient) {
            // Status bar may go away, so the screen area it occupies
            // is available to apps but just covering them when the
            // status bar is visible.
            mDockTop = mUnrestrictedScreenTop + statusBarHeight;
            mContentTop = mVoiceContentTop = mCurTop = mDockTop;
            mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
            mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
            mContentRight = mVoiceContentRight = mCurRight = mDockRight;
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Status bar: " + String.format("dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom));
        }
        if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw() && !statusBarTransient && !statusBarTranslucent && !mStatusBarController.wasRecentlyTranslucent()) {
            // If the opaque status bar is currently requested to be visible,
            // and not in the process of animating on or off, then
            // we can tell the app that it is covered by it.
            mSystemTop = mUnrestrictedScreenTop + statusBarHeight;
        }
        if (mStatusBarController.checkHiddenLw()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private boolean layoutNavigationBar(int displayWidth, int displayHeight, int displayRotation, int uiMode, int overscanLeft, int overscanRight, int overscanBottom, Rect dcf, boolean navVisible, boolean navTranslucent, boolean navAllowedHidden, boolean statusBarExpandedNotKeyguard) {
    final int navBarWidth = getNavigationBarWidth(displayRotation, uiMode);
    final int navBarHeight = getNavigationBarHeight(displayRotation, uiMode);
    if (mNavigationBar != null) {
        boolean transientNavBarShowing = mNavigationBarController.isTransientShowing();
        final boolean navOccupySpace = shouldNavigationBarOccupySpace();
        // Force the navigation bar to its appropriate place and
        // size.  We need to do this directly, instead of relying on
        // it to bubble up from the nav bar, because this needs to
        // change atomically with screen rotations.
        mNavigationBarPosition = navigationBarPosition(displayWidth, displayHeight, displayRotation);
        if (mNavigationBarPosition == NAV_BAR_BOTTOM) {
            // It's a system nav bar or a portrait screen; nav bar goes on bottom.
            // When global immersive is enabled (!navOccupySpace), we let the system think that
            // navigation bar is not occupying space while we update some of the key coordinates
            // the display uses to determine where to position borders for drawable content.
            int top = displayHeight - overscanBottom - (navOccupySpace ? navBarHeight : 0);
            mTmpNavigationFrame.set(0, top, displayWidth, displayHeight - overscanBottom);
            mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
            if (transientNavBarShowing) {
                mNavigationBarController.setBarShowingLw(true);
            } else if (navVisible) {
                mNavigationBarController.setBarShowingLw(true);
                mDockBottom = mTmpNavigationFrame.top;
                mRestrictedScreenHeight = mDockBottom - mRestrictedScreenTop;
                mRestrictedOverscanScreenHeight = mDockBottom - mRestrictedOverscanScreenTop;
            } else {
                // We currently want to hide the navigation UI - unless we expanded the status
                // bar.
                mNavigationBarController.setBarShowingLw(statusBarExpandedNotKeyguard);
            }
            if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                // If the opaque nav bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemBottom = mTmpNavigationFrame.top;
            }
            // Restore navigation bar frame params.
            if (!navOccupySpace) {
                mTmpNavigationFrame.top -= navBarHeight;
            }
        } else if (mNavigationBarPosition == NAV_BAR_RIGHT) {
            // Landscape screen; nav bar goes to the right.
            // When global immersive is enabled (!navOccupySpace), we let the system think that
            // navigation bar is not occupying space while we update some of the key coordinates
            // the display uses to determine where to position borders for drawable content.
            int left = displayWidth - overscanRight - (navOccupySpace ? navBarWidth : 0);
            mTmpNavigationFrame.set(left, 0, displayWidth - overscanRight, displayHeight);
            mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
            if (transientNavBarShowing) {
                mNavigationBarController.setBarShowingLw(true);
            } else if (navVisible) {
                mNavigationBarController.setBarShowingLw(true);
                mDockRight = mTmpNavigationFrame.left;
                mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
            } else {
                // We currently want to hide the navigation UI - unless we expanded the status
                // bar.
                mNavigationBarController.setBarShowingLw(statusBarExpandedNotKeyguard);
            }
            if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                // If the nav bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemRight = mTmpNavigationFrame.left;
            }
            // Restore navigation bar frame params.
            if (!navOccupySpace) {
                mTmpNavigationFrame.left -= navBarWidth;
            }
        } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
            // Seascape screen; nav bar goes to the left.
            // When global immersive is enabled (!navOccupySpace), we let the system think that
            // navigation bar is not occupying space while we update some of the key coordinates
            // the display uses to determine where to position borders for drawable content.
            int right = overscanLeft + (navOccupySpace ? navBarWidth : 0);
            mTmpNavigationFrame.set(overscanLeft, 0, right, displayHeight);
            mStableLeft = mStableFullscreenLeft = mTmpNavigationFrame.right;
            if (transientNavBarShowing || (navVisible && !navOccupySpace)) {
                mNavigationBarController.setBarShowingLw(true);
            } else if (navVisible) {
                mNavigationBarController.setBarShowingLw(true);
                mDockLeft = mTmpNavigationFrame.right;
                // TODO: not so sure about those:
                mRestrictedScreenLeft = mRestrictedOverscanScreenLeft = mDockLeft;
                mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
            } else {
                // We currently want to hide the navigation UI - unless we expanded the status
                // bar.
                mNavigationBarController.setBarShowingLw(statusBarExpandedNotKeyguard);
            }
            if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                // If the nav bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemLeft = mTmpNavigationFrame.right;
            }
            // Restore navigation bar frame params.
            if (!navOccupySpace) {
                mTmpNavigationFrame.right += navBarWidth;
            }
        }
        // Make sure the content and current rectangles are updated to
        // account for the restrictions from the navigation bar.
        mContentTop = mVoiceContentTop = mCurTop = mDockTop;
        mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
        mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
        mContentRight = mVoiceContentRight = mCurRight = mDockRight;
        mStatusBarLayer = mNavigationBar.getSurfaceLayer();
        // And compute the final frame.
        mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf, mTmpNavigationFrame, mTmpNavigationFrame);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
        if (mNavigationBarController.checkHiddenLw()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean layoutNavigationBar(int displayWidth, int displayHeight, int displayRotation, int uiMode, int overscanLeft, int overscanRight, int overscanBottom, Rect dcf, boolean navVisible, boolean navTranslucent, boolean navAllowedHidden, boolean statusBarExpandedNotKeyguard) {
    if (mNavigationBar != null) {
        boolean transientNavBarShowing = mNavigationBarController.isTransientShowing();
        final boolean forceNavBarImmersive = shouldForceNavigationBarImmersive();
        final int navBarWidth = getNavigationBarWidth(displayRotation, uiMode);
        final int navBarHeight = getNavigationBarHeight(displayRotation, uiMode);
        // Force the navigation bar to its appropriate place and
        // size.  We need to do this directly, instead of relying on
        // it to bubble up from the nav bar, because this needs to
        // change atomically with screen rotations.
        mNavigationBarPosition = navigationBarPosition(displayWidth, displayHeight, displayRotation);
        if (mNavigationBarPosition == NAV_BAR_BOTTOM) {
            // It's a system nav bar or a portrait screen; nav bar goes on bottom.
            // When global immersive is enabled (forceNavBarImmersive), we let the system think that
            // navigation bar is not occupying space while we update some of the key coordinates
            // the display uses to determine where to position borders for drawable content.
            int top = displayHeight - overscanBottom - (!forceNavBarImmersive ? navBarHeight : 0);
            mTmpNavigationFrame.set(0, top, displayWidth, displayHeight - overscanBottom);
            mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
            if (transientNavBarShowing) {
                mNavigationBarController.setBarShowingLw(true);
            } else if (navVisible) {
                mNavigationBarController.setBarShowingLw(true);
                mDockBottom = mTmpNavigationFrame.top;
                mRestrictedScreenHeight = mDockBottom - mRestrictedScreenTop;
                mRestrictedOverscanScreenHeight = mDockBottom - mRestrictedOverscanScreenTop;
            } else {
                // We currently want to hide the navigation UI - unless we expanded the status
                // bar.
                mNavigationBarController.setBarShowingLw(statusBarExpandedNotKeyguard && !immersiveModeImplementsPie());
            }
            if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                // If the opaque nav bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemBottom = mTmpNavigationFrame.top;
            }
            // Restore navigation bar frame params.
            if (forceNavBarImmersive) {
                mTmpNavigationFrame.top -= navBarHeight;
            }
        } else if (mNavigationBarPosition == NAV_BAR_RIGHT) {
            // Landscape screen; nav bar goes to the right.
            // When global immersive is enabled (forceNavBarImmersive), we let the system think that
            // navigation bar is not occupying space while we update some of the key coordinates
            // the display uses to determine where to position borders for drawable content.
            int left = displayWidth - overscanRight - (!forceNavBarImmersive ? navBarWidth : 0);
            mTmpNavigationFrame.set(left, 0, displayWidth - overscanRight, displayHeight);
            mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
            if (transientNavBarShowing) {
                mNavigationBarController.setBarShowingLw(true);
            } else if (navVisible) {
                mNavigationBarController.setBarShowingLw(true);
                mDockRight = mTmpNavigationFrame.left;
                mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
            } else {
                // We currently want to hide the navigation UI - unless we expanded the status
                // bar.
                mNavigationBarController.setBarShowingLw(statusBarExpandedNotKeyguard && !immersiveModeImplementsPie());
            }
            if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                // If the nav bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemRight = mTmpNavigationFrame.left;
            }
            // Restore navigation bar frame params.
            if (forceNavBarImmersive) {
                mTmpNavigationFrame.left -= navBarWidth;
            }
        } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
            // Seascape screen; nav bar goes to the left.
            // When global immersive is enabled (forceNavBarImmersive), we let the system think that
            // navigation bar is not occupying space while we update some of the key coordinates
            // the display uses to determine where to position borders for drawable content.
            int right = overscanLeft + (!forceNavBarImmersive ? navBarWidth : 0);
            mTmpNavigationFrame.set(overscanLeft, 0, right, displayHeight);
            mStableLeft = mStableFullscreenLeft = mTmpNavigationFrame.right;
            if (transientNavBarShowing) {
                mNavigationBarController.setBarShowingLw(true);
            } else if (navVisible) {
                mNavigationBarController.setBarShowingLw(true);
                mDockLeft = mTmpNavigationFrame.right;
                // TODO: not so sure about those:
                mRestrictedScreenLeft = mRestrictedOverscanScreenLeft = mDockLeft;
                mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
            } else {
                // We currently want to hide the navigation UI - unless we expanded the status
                // bar.
                mNavigationBarController.setBarShowingLw(statusBarExpandedNotKeyguard && !immersiveModeImplementsPie());
            }
            if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                // If the nav bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemLeft = mTmpNavigationFrame.right;
            }
            // Restore navigation bar frame params.
            if (forceNavBarImmersive) {
                mTmpNavigationFrame.right += navBarWidth;
            }
        }
        // Make sure the content and current rectangles are updated to
        // account for the restrictions from the navigation bar.
        mContentTop = mVoiceContentTop = mCurTop = mDockTop;
        mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
        mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
        mContentRight = mVoiceContentRight = mCurRight = mDockRight;
        mStatusBarLayer = mNavigationBar.getSurfaceLayer();
        // And compute the final frame.
        mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf, mTmpNavigationFrame, mTmpNavigationFrame);
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
        if (mNavigationBarController.checkHiddenLw()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void layoutWindowLw(WindowState win, WindowState attached) {
    // input, we need to layout it again to accomodate for the IME window.
    if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
        return;
    }
    final WindowManager.LayoutParams attrs = win.getAttrs();
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    final int pfl = attrs.privateFlags;
    final int sim = attrs.softInputMode;
    final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null);
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect sf = mTmpStableFrame;
    Rect osf = null;
    dcf.setEmpty();
    final boolean hasNavBar = (isDefaultDisplay && hasNavigationBar() && mNavigationBar != null && mNavigationBar.isVisibleLw());
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (isDefaultDisplay) {
        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
    } else {
        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
    }
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        if (mStatusBar != null && mFocusedWindow == mStatusBar && canReceiveInput(mStatusBar)) {
            // avoids the navigation bar in that case.
            if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                pf.right = df.right = of.right = cf.right = vf.right = mStableRight;
            } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                pf.left = df.left = of.left = cf.left = vf.left = mStableLeft;
            }
        }
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else if (attrs.type == TYPE_VOICE_INTERACTION) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
            cf.left = mDockLeft;
            cf.top = mDockTop;
            cf.right = mDockRight;
            cf.bottom = mDockBottom;
        } else {
            cf.left = mContentLeft;
            cf.top = mContentTop;
            cf.right = mContentRight;
            cf.bottom = mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
            vf.left = mCurLeft;
            vf.top = mCurTop;
            vf.right = mCurRight;
            vf.bottom = mCurBottom;
        } else {
            vf.set(cf);
        }
    } else if (attrs.type == TYPE_WALLPAPER) {
        layoutWallpaper(win, pf, df, of, cf);
    } else if (win == mStatusBar) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        cf.left = vf.left = shouldNavigationBarOccupySpace() ? mStableLeft : mNavigationBarPosition == NAV_BAR_LEFT ? mStableLeft - getNavigationBarHeight(mDisplayRotation, mUiMode) : mStableLeft;
        cf.top = vf.top = mStableTop;
        cf.right = vf.right = shouldNavigationBarOccupySpace() ? mStableRight : mNavigationBarPosition == NAV_BAR_RIGHT ? mStableRight - getNavigationBarHeight(mDisplayRotation, mUiMode) : mStableRight;
        vf.bottom = mStableBottom;
        if (adjust == SOFT_INPUT_ADJUST_RESIZE) {
            cf.bottom = mContentBottom;
        } else {
            cf.bottom = mDockBottom;
            vf.bottom = mContentBottom;
        }
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0 && (pfl & PRIVATE_FLAG_FORCE_DRAW_STATUS_BAR_BACKGROUND) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    pf.left = df.left = of.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0) {
                    if (win.isVoiceInteraction()) {
                        cf.left = mVoiceContentLeft;
                        cf.top = mVoiceContentTop;
                        cf.right = mVoiceContentRight;
                        cf.bottom = mVoiceContentBottom;
                    } else {
                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                            cf.left = mDockLeft;
                            cf.top = mDockTop;
                            cf.right = mDockRight;
                            cf.bottom = mDockBottom;
                        } else {
                            cf.left = mContentLeft;
                            cf.top = mContentTop;
                            cf.right = mContentRight;
                            cf.bottom = mContentBottom;
                        }
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // gets everything, period.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                pf.left = df.left = of.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS || attrs.type == TYPE_SCREENSHOT) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for. Screenshot region
                // selection overlay should also expand to full screen.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_DOCK_DIVIDER || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) != 0) {
                pf.left = df.left = of.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    cf.left = mDockLeft;
                    cf.top = mDockTop;
                    cf.right = mDockRight;
                    cf.bottom = mDockBottom;
                } else {
                    cf.left = mContentLeft;
                    cf.top = mContentTop;
                    cf.right = mContentRight;
                    cf.bottom = mContentBottom;
                }
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                // Status bar panels and the volume dialog are the only windows who can go on
                // top of the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
                // These dialogs are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (win.isVoiceInteraction()) {
                    df.left = of.left = cf.left = mVoiceContentLeft;
                    df.top = of.top = cf.top = mVoiceContentTop;
                    df.right = of.right = cf.right = mVoiceContentRight;
                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        }
    }
    // Also, we don't allow windows in multi-window mode to extend out of the screen.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR && !win.isInMultiWindowMode()) {
        df.left = df.top = -10000;
        df.right = df.bottom = 10000;
        if (attrs.type != TYPE_WALLPAPER) {
            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
        }
    }
    // If the device has a chin (e.g. some watches), a dead area at the bottom of the screen we
    // need to provide information to the clients that want to pretend that you can draw there.
    // We only want to apply outsets to certain types of windows. For example, we never want to
    // apply the outsets to floating dialogs, because they wouldn't make sense there.
    final boolean useOutsets = shouldUseOutsets(attrs, fl);
    if (isDefaultDisplay && useOutsets) {
        osf = mTmpOutsetFrame;
        osf.set(cf.left, cf.top, cf.right, cf.bottom);
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            int rotation = mDisplayRotation;
            if (rotation == Surface.ROTATION_0) {
                osf.bottom += outset;
            } else if (rotation == Surface.ROTATION_90) {
                osf.right += outset;
            } else if (rotation == Surface.ROTATION_180) {
                osf.top -= outset;
            } else if (rotation == Surface.ROTATION_270) {
                osf.left -= outset;
            }
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "applying bottom outset of " + outset + " with rotation " + rotation + ", result: " + osf);
        }
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString() + " osf=" + (osf == null ? "null" : osf.toShortString()));
    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && win.isDisplayedLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        offsetVoiceInputWindowLw(win);
    }
}
#method_after
@Override
public void layoutWindowLw(WindowState win, WindowState attached) {
    // input, we need to layout it again to accomodate for the IME window.
    if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
        return;
    }
    final WindowManager.LayoutParams attrs = win.getAttrs();
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    final int pfl = attrs.privateFlags;
    final int sim = attrs.softInputMode;
    final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null);
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect sf = mTmpStableFrame;
    Rect osf = null;
    dcf.setEmpty();
    // IMPORTANT: I have modified this, because it does not make sense checking
    // for navigation bar availability within checking Lw visibility, we have forced
    // immersive mode and other cases that are kinda penalized by this. Don't chain
    // mNavigationBar.isVisibleLw() tothe boolean value. carlosavignano@aospa.co
    // && mNavigationBar.isVisibleLw();
    final boolean hasNavBar = isDefaultDisplay && hasNavigationBar() && mNavigationBar != null;
    final boolean forceNavBarImmersive = shouldForceNavigationBarImmersive();
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (isDefaultDisplay) {
        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
    } else {
        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
    }
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        if (mStatusBar != null && mFocusedWindow == mStatusBar && canReceiveInput(mStatusBar)) {
            // avoids the navigation bar in that case.
            if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                pf.right = df.right = of.right = cf.right = vf.right = mStableRight;
            } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                pf.left = df.left = of.left = cf.left = vf.left = mStableLeft;
            }
        }
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else if (attrs.type == TYPE_VOICE_INTERACTION) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
            cf.left = mDockLeft;
            cf.top = mDockTop;
            cf.right = mDockRight;
            cf.bottom = mDockBottom;
        } else {
            cf.left = mContentLeft;
            cf.top = mContentTop;
            cf.right = mContentRight;
            cf.bottom = mContentBottom;
        }
        if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
            vf.left = mCurLeft;
            vf.top = mCurTop;
            vf.right = mCurRight;
            vf.bottom = mCurBottom;
        } else {
            vf.set(cf);
        }
    } else if (attrs.type == TYPE_WALLPAPER) {
        layoutWallpaper(win, pf, df, of, cf);
    } else if (win == mStatusBar) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
        cf.right = vf.right = mStableRight;
        vf.bottom = mStableBottom;
        // params (check layoutNavigationBar(), especially immersive comments). carlosavignano@aospa.co
        if (hasNavBar && forceNavBarImmersive) {
            if (isLandscapeOrSeascape(mDisplayRotation)) {
                if (mNavigationBarPosition == NAV_BAR_RIGHT) {
                    cf.right = vf.right -= getNavigationBarWidth(mDisplayRotation, mUiMode);
                } else if (mNavigationBarPosition == NAV_BAR_LEFT) {
                    cf.left = vf.left += getNavigationBarWidth(mDisplayRotation, mUiMode);
                }
            }
        }
        if (adjust == SOFT_INPUT_ADJUST_RESIZE) {
            cf.bottom = mContentBottom;
        } else {
            cf.bottom = mDockBottom;
            vf.bottom = mContentBottom;
        }
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0 && (pfl & PRIVATE_FLAG_FORCE_DRAW_STATUS_BAR_BACKGROUND) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    // However^2, they should dodge it only when is not in forced immersive mode. carlosavignano@aospa.co
                    pf.left = df.left = of.left = hasNavBar && !forceNavBarImmersive ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar && !forceNavBarImmersive ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar && !forceNavBarImmersive ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0) {
                    if (win.isVoiceInteraction()) {
                        cf.left = mVoiceContentLeft;
                        cf.top = mVoiceContentTop;
                        cf.right = mVoiceContentRight;
                        cf.bottom = mVoiceContentBottom;
                    } else {
                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                            cf.left = mDockLeft;
                            cf.top = mDockTop;
                            cf.right = mDockRight;
                            cf.bottom = mDockBottom;
                        } else {
                            cf.left = mContentLeft;
                            cf.top = mContentTop;
                            cf.right = mContentRight;
                            cf.bottom = mContentBottom;
                        }
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // However, dodge navigation bar if is in forced immersive mode. carlosavignano@aospa.co
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                pf.left = df.left = of.left = cf.left = hasNavBar && !forceNavBarImmersive ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar && !forceNavBarImmersive ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar && !forceNavBarImmersive ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS || attrs.type == TYPE_SCREENSHOT) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for. Screenshot region
                // selection overlay should also expand to full screen.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_DOCK_DIVIDER || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN) != 0) {
                pf.left = df.left = of.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    cf.left = mDockLeft;
                    cf.top = mDockTop;
                    cf.right = mDockRight;
                    cf.bottom = mDockBottom;
                } else {
                    cf.left = mContentLeft;
                    cf.top = mContentTop;
                    cf.right = mContentRight;
                    cf.bottom = mContentBottom;
                }
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                // Status bar panels and the volume dialog are the only windows who can go on
                // top of the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
                // These dialogs are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (win.isVoiceInteraction()) {
                    df.left = of.left = cf.left = mVoiceContentLeft;
                    df.top = of.top = cf.top = mVoiceContentTop;
                    df.right = of.right = cf.right = mVoiceContentRight;
                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        }
    }
    // Also, we don't allow windows in multi-window mode to extend out of the screen.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR && !win.isInMultiWindowMode()) {
        df.left = df.top = -10000;
        df.right = df.bottom = 10000;
        if (attrs.type != TYPE_WALLPAPER) {
            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
        }
    }
    // If the device has a chin (e.g. some watches), a dead area at the bottom of the screen we
    // need to provide information to the clients that want to pretend that you can draw there.
    // We only want to apply outsets to certain types of windows. For example, we never want to
    // apply the outsets to floating dialogs, because they wouldn't make sense there.
    final boolean useOutsets = shouldUseOutsets(attrs, fl);
    if (isDefaultDisplay && useOutsets) {
        osf = mTmpOutsetFrame;
        osf.set(cf.left, cf.top, cf.right, cf.bottom);
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            int rotation = mDisplayRotation;
            if (rotation == Surface.ROTATION_0) {
                osf.bottom += outset;
            } else if (rotation == Surface.ROTATION_90) {
                osf.right += outset;
            } else if (rotation == Surface.ROTATION_180) {
                osf.top -= outset;
            } else if (rotation == Surface.ROTATION_270) {
                osf.left -= outset;
            }
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "applying bottom outset of " + outset + " with rotation " + rotation + ", result: " + osf);
        }
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString() + " osf=" + (osf == null ? "null" : osf.toShortString()));
    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && win.isDisplayedLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        offsetVoiceInputWindowLw(win);
    }
}
#end_block

#method_before
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached) {
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
            mShowingLockscreen = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
    final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
    final int stackId = win.getStackId();
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final IApplicationToken appToken = win.getAppToken();
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty()) {
                    if (dismissKeyguard && !mKeyguardSecure) {
                        mAppsThatDismissKeyguard.add(appToken);
                    } else if (win.isDrawnLw() || win.hasAppShownWindows()) {
                        mWinShowWhenLocked = win;
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                }
            } else if (dismissKeyguard) {
                if (mKeyguardSecure) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (isFullscreen(attrs) && StackId.normallyFullscreenWindows(stackId)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = (mWinDismissingKeyguard == win && mSecureDismissingKeyguard == mKeyguardSecure) ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mSecureDismissingKeyguard = mKeyguardSecure;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked && (win.isDrawnLw() || win.hasAppShownWindows())) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (!mKeyguardHidden && mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken() && (attrs.flags & FLAG_SHOW_WHEN_LOCKED) == 0) {
                win.hideLw(false);
            }
        }
    } else if (mTopFullscreenOpaqueWindowState == null && mWinShowWhenLocked == null) {
        // we know whether to show the keyguard or not.
        if (win.isAnimatingLw() && appWindow && showWhenLocked && mKeyguardHidden) {
            mHideLockScreen = true;
            mWinShowWhenLocked = win;
        }
    }
    final boolean reallyVisible = win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw();
    // Voice interaction overrides both top fullscreen and top docked.
    if (reallyVisible && win.getAttrs().type == TYPE_VOICE_INTERACTION) {
        if (mTopFullscreenOpaqueWindowState == null) {
            mTopFullscreenOpaqueWindowState = win;
            if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                mTopFullscreenOpaqueOrDimmingWindowState = win;
            }
        }
        if (mTopDockedOpaqueWindowState == null) {
            mTopDockedOpaqueWindowState = win;
            if (mTopDockedOpaqueOrDimmingWindowState == null) {
                mTopDockedOpaqueOrDimmingWindowState = win;
            }
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && StackId.normallyFullscreenWindows(stackId)) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && reallyVisible && appWindow && attached == null && isFullscreen(attrs) && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
}
#method_after
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached) {
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win=" + win + " : isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw() + " : FLAG_FORCE_NOT_FULLSCREEN=" + ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0));
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD && !immersiveModeImplementsPie()) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
            mShowingLockscreen = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
    final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
    final int stackId = win.getStackId();
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final IApplicationToken appToken = win.getAppToken();
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty()) {
                    if (dismissKeyguard && !mKeyguardSecure) {
                        mAppsThatDismissKeyguard.add(appToken);
                    } else if (win.isDrawnLw() || win.hasAppShownWindows()) {
                        mWinShowWhenLocked = win;
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                }
            } else if (dismissKeyguard) {
                if (mKeyguardSecure) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (isFullscreen(attrs) && StackId.normallyFullscreenWindows(stackId)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = (mWinDismissingKeyguard == win && mSecureDismissingKeyguard == mKeyguardSecure) ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mSecureDismissingKeyguard = mKeyguardSecure;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked && (win.isDrawnLw() || win.hasAppShownWindows())) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (!mKeyguardHidden && mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken() && (attrs.flags & FLAG_SHOW_WHEN_LOCKED) == 0) {
                win.hideLw(false);
            }
        }
    } else if (mTopFullscreenOpaqueWindowState == null && mWinShowWhenLocked == null) {
        // we know whether to show the keyguard or not.
        if (win.isAnimatingLw() && appWindow && showWhenLocked && mKeyguardHidden) {
            mHideLockScreen = true;
            mWinShowWhenLocked = win;
        }
    }
    final boolean reallyVisible = win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw();
    // Voice interaction overrides both top fullscreen and top docked.
    if (reallyVisible && win.getAttrs().type == TYPE_VOICE_INTERACTION) {
        if (mTopFullscreenOpaqueWindowState == null) {
            mTopFullscreenOpaqueWindowState = win;
            if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                mTopFullscreenOpaqueOrDimmingWindowState = win;
            }
        }
        if (mTopDockedOpaqueWindowState == null) {
            mTopDockedOpaqueWindowState = win;
            if (mTopDockedOpaqueOrDimmingWindowState == null) {
                mTopDockedOpaqueOrDimmingWindowState = win;
            }
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && StackId.normallyFullscreenWindows(stackId)) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && reallyVisible && appWindow && attached == null && isFullscreen(attrs) && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
}
#end_block

#method_before
@Override
public int finishPostLayoutPolicyLw() {
    if (mWinShowWhenLocked != null && mTopFullscreenOpaqueWindowState != null && mWinShowWhenLocked.getAppToken() != mTopFullscreenOpaqueWindowState.getAppToken() && isKeyguardLocked()) {
        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
        // fullscreen window.
        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        mTopFullscreenOpaqueWindowState.hideLw(false);
        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
    }
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        WindowManager.LayoutParams statusBarAttrs = mStatusBar.getAttrs();
        boolean statusBarExpanded = statusBarAttrs.height == MATCH_PARENT && statusBarAttrs.width == MATCH_PARENT;
        if (mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent || statusBarExpanded) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
            if (statusBarExpanded && mNavigationBar != null) {
                if (mNavigationBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            final int fl = PolicyControl.getWindowFlags(null, lp);
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown position: " + mTopFullscreenOpaqueWindowState.getShownPositionLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
            }
            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen && !mWindowManagerInternal.isStackVisible(FREEFORM_WORKSPACE_STACK_ID) && !mWindowManagerInternal.isStackVisible(DOCKED_STACK_ID)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        }
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    // displayed when the screen is locked.
    if (mKeyguardDelegate != null && mStatusBar != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardSecure) {
            mKeyguardHidden = true;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            mKeyguardHidden = true;
            mWinDismissingKeyguard = null;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            mKeyguardHidden = false;
            boolean dismissKeyguard = false;
            final boolean trusted = mKeyguardDelegate.isTrusted();
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                final boolean willDismiss = trusted && mKeyguardOccluded && mKeyguardDelegate != null && mKeyguardDelegate.isShowing();
                if (willDismiss) {
                    mCurrentlyDismissingKeyguard = true;
                }
                dismissKeyguard = true;
            }
            // If we are currently dismissing Keyguard, there is no need to unocclude it.
            if (!mCurrentlyDismissingKeyguard) {
                if (setKeyguardOccludedLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
                }
            }
            if (dismissKeyguard) {
                // Only launch the next keyguard unlock window once per window.
                mHandler.post(() -> mKeyguardDelegate.dismiss(trusted));
            }
        } else {
            mWinDismissingKeyguard = null;
            mSecureDismissingKeyguard = false;
            mKeyguardHidden = false;
            if (setKeyguardOccludedLw(false)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    updateEdgeGestureListenerState();
    return changes;
}
#method_after
@Override
public int finishPostLayoutPolicyLw() {
    if (mWinShowWhenLocked != null && mTopFullscreenOpaqueWindowState != null && mWinShowWhenLocked.getAppToken() != mTopFullscreenOpaqueWindowState.getAppToken() && isKeyguardLocked()) {
        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
        // fullscreen window.
        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        mTopFullscreenOpaqueWindowState.hideLw(false);
        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
    }
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState + " forcetransp=" + mForceStatusBarTransparent);
        boolean forceStatusBarImmersive = shouldForceStatusBarImmersive();
        boolean forceNavBarImmersive = shouldForceNavigationBarImmersive();
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard && !forceStatusBarImmersive;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        WindowManager.LayoutParams statusBarAttrs = mStatusBar.getAttrs();
        boolean statusBarExpanded = statusBarAttrs.height == MATCH_PARENT && statusBarAttrs.width == MATCH_PARENT;
        if (forceStatusBarImmersive ? mForceStatusBarFromKeyguard || statusBarExpanded : mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent || statusBarExpanded) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
            if (statusBarExpanded && !immersiveModeImplementsPie()) {
                if (mStatusBar != null) {
                    if (forceStatusBarImmersive) {
                    // TODO> Fix status bar hiding when enabling immersive and status bar is still expanded.
                    // mStatusBarController.showTransient();
                    }
                }
                if (mNavigationBar != null) {
                    if (forceNavBarImmersive) {
                    // TODO> Fix navigation bar hiding when enabling immersive and status bar is still expanded.
                    // mNavigationBarController.showTransient();
                    }
                    if (mNavigationBarController.setBarShowingLw(true)) {
                        changes |= FINISH_LAYOUT_REDO_LAYOUT;
                    }
                }
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            final int fl = PolicyControl.getWindowFlags(null, lp);
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown position: " + mTopFullscreenOpaqueWindowState.getShownPositionLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
            }
            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else {
                boolean isMultiWindowStackTypeVisible = mWindowManagerInternal.isStackVisible(FREEFORM_WORKSPACE_STACK_ID) || mWindowManagerInternal.isStackVisible(DOCKED_STACK_ID);
                boolean hide = topIsFullscreen && (forceStatusBarImmersive || !isMultiWindowStackTypeVisible);
                if (hide) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "** HIDING status bar");
                    if (mStatusBarController.setBarShowingLw(false)) {
                        changes |= FINISH_LAYOUT_REDO_LAYOUT;
                    } else {
                        if (DEBUG_LAYOUT)
                            Slog.v(TAG, "Status bar already hiding");
                    }
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                    if (mStatusBarController.setBarShowingLw(true)) {
                        changes |= FINISH_LAYOUT_REDO_LAYOUT;
                    }
                }
            }
        }
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    // displayed when the screen is locked.
    if (mKeyguardDelegate != null && mStatusBar != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardSecure) {
            mKeyguardHidden = true;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            mKeyguardHidden = true;
            mWinDismissingKeyguard = null;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            mKeyguardHidden = false;
            boolean dismissKeyguard = false;
            final boolean trusted = mKeyguardDelegate.isTrusted();
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                final boolean willDismiss = trusted && mKeyguardOccluded && mKeyguardDelegate != null && mKeyguardDelegate.isShowing();
                if (willDismiss) {
                    mCurrentlyDismissingKeyguard = true;
                }
                dismissKeyguard = true;
            }
            // If we are currently dismissing Keyguard, there is no need to unocclude it.
            if (!mCurrentlyDismissingKeyguard) {
                if (setKeyguardOccludedLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
                }
            }
            if (dismissKeyguard) {
                // Only launch the next keyguard unlock window once per window.
                mHandler.post(() -> mKeyguardDelegate.dismiss(trusted));
            }
        } else {
            mWinDismissingKeyguard = null;
            mSecureDismissingKeyguard = false;
            mKeyguardHidden = false;
            if (setKeyguardOccludedLw(false)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    updateEdgeGestureListenerState();
    return changes;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    // Request haptic feedback for hw keys finger down events.
    boolean hapticFeedbackRequested = false;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeQueueing(): event =" + event.toString() + ", interactive =" + interactive + ", keyguardActive =" + keyguardActive + ", policyFlags =" + Integer.toHexString(policyFlags) + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", canApplyCustomPolicy = " + canApplyCustomPolicy(keyCode));
    }
    /**
     * Handle gestures input earlier then anything when screen is off.
     * @author Carlo Savignano
     */
    if (!interactive) {
        if (mKeyHandler != null && mKeyHandler.handleKeyEvent(event)) {
            return 0;
        }
    }
    // Apply custom policy for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if (mNavBarEnabled && !navBarKey) /* TODO> && !isADBVirtualKeyOrAnyOtherKeyThatWeNeedToHandleAKAWhenMonkeyTestOrWHATEVER! */
        {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: mNavBarEnabled, discard hw event.");
            }
            // Don't allow key events from hw keys when navbar is enabled.
            return 0;
        } else if (!interactive) {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: screen not interactive, discard hw event.");
            }
            // Ensure nav keys are handled on full interactive screen only.
            return 0;
        } else if (interactive) {
            if (!down) {
                // Make sure we consume hw key events properly. Discard them
                // here if the event is already been consumed. This case can
                // happen when we send virtual key events and the virtual
                // ACTION_UP is sent before the hw ACTION_UP resulting in
                // handling twice an action up event.
                final boolean consumed = isKeyConsumed(keyCode);
                if (consumed) {
                    if (DEBUG_INPUT) {
                        Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: event already consumed, discard hw event.");
                    }
                    setKeyConsumed(keyCode, !consumed);
                    return 0;
                }
            } else {
                hapticFeedbackRequested = true;
            }
        }
    }
    // Intercept the Keypress event for Keypress boost
    if (lIsPerfBoostEnabled && !isCustomSource) {
        if (down && !longPress && repeatCount == 0 || down && longPress && repeatCount == 1) {
            final long boostEventTime = mBoostEventTime;
            mBoostEventTime = SystemClock.uptimeMillis();
            if (boostEventTime != 0L) {
                // we had a previous boost
                final long boostEventTimeDiff = mBoostEventTime - boostEventTime;
                final boolean reBoostByDiff = boostEventTimeDiff >= ((long) mLastBoostDuration - 150L) && boostEventTimeDiff <= ((long) mLastBoostDuration - 50L);
                if (mKeypressBoostBlocked && mLastBoostDuration != 0 && reBoostByDiff) {
                    // We have a few milliseconds remaining from our previous boost, release current boost before triggering next one.
                    mHandler.removeMessages(MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK);
                    mPerfKey.perfLockRelease();
                    mKeypressBoostBlocked = false;
                }
            }
            dispatchKeypressBoost(keyCode);
        }
    }
    // Pre-basic policy based on interactive and pocket lock state.
    if (mIsDeviceInPocket && (!interactive || mPocketLockShowing)) {
        if (keyCode != KeyEvent.KEYCODE_POWER) {
            return 0;
        }
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // If not requested by our custom policy, then check if the key is virtual.
    hapticFeedbackRequested |= (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0;
    boolean useHapticFeedback = down && hapticFeedbackRequested && repeatCount == 0 && // Trigger haptic feedback only for "real" events.
    source != InputDevice.SOURCE_CUSTOM;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeDownKeyTriggered = true;
                        mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                        mScreenshotChordVolumeDownKeyConsumed = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mScreenshotChordVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeUpKeyTriggered = true;
                        cancelPendingPowerKeyAction();
                        cancelPendingScreenshotChordAction();
                    }
                } else {
                    mScreenshotChordVolumeUpKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            }
            if (down) {
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null) {
                    if (telecomManager.isRinging()) {
                        // If an incoming call is ringing, either VOLUME key means
                        // "silence ringer".  We handle these keys here, rather than
                        // in the InCallScreen, to make sure we'll respond to them
                        // even if the InCallScreen hasn't come to the foreground yet.
                        // Look for the DOWN event here, to agree with the "fallback"
                        // behavior in the InCallScreen.
                        Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                        // Silence the ringer.  (It's safe to call this
                        // even if the ringer has already been silenced.)
                        telecomManager.silenceRinger();
                        // And *don't* pass this key thru to the current activity
                        // (which is probably the InCallScreen.)
                        result &= ~ACTION_PASS_TO_USER;
                        break;
                    }
                    if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                        break;
                    }
                }
            }
            if ((result & ACTION_PASS_TO_USER) == 0) {
                boolean mayChangeVolume = false;
                if (isMusicActive()) {
                    if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        // Detect long key presses.
                        if (down) {
                            mVolBtnLongPress = false;
                            int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                            scheduleLongPressKeyEvent(event, newKeyCode);
                            // Consume key down events of all presses.
                            break;
                        } else {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            // Consume key up events of long presses only.
                            if (mVolBtnLongPress) {
                                break;
                            }
                            // Change volume only on key up events of short presses.
                            mayChangeVolume = true;
                        }
                    } else {
                        // Long key press detection not applicable, change volume only
                        // on key down events
                        mayChangeVolume = down;
                    }
                }
                if (mayChangeVolume) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to figure
                    // out.
                    // Rewrite the event to use key-down as sendVolumeKeyEvent will
                    // only change the volume on key down.
                    KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                }
                break;
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    // Request haptic feedback for hw keys finger down events.
    boolean hapticFeedbackRequested = false;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeQueueing(): event =" + event.toString() + ", interactive =" + interactive + ", keyguardActive =" + keyguardActive + ", policyFlags =" + Integer.toHexString(policyFlags) + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", canApplyCustomPolicy = " + canApplyCustomPolicy(keyCode));
    }
    /**
     * Handle gestures input earlier then anything when screen is off.
     * @author Carlo Savignano
     */
    if (!interactive) {
        if (mKeyHandler != null && mKeyHandler.handleKeyEvent(event)) {
            return 0;
        }
    }
    // Apply custom policy for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if (mNavBarEnabled && !navBarKey) /* TODO> && !isADBVirtualKeyOrAnyOtherKeyThatWeNeedToHandleAKAWhenMonkeyTestOrWHATEVER! */
        {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: mNavBarEnabled, discard hw event.");
            }
            // Don't allow key events from hw keys when navbar is enabled.
            return 0;
        } else if (!interactive) {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: screen not interactive, discard hw event.");
            }
            // Ensure nav keys are handled on full interactive screen only.
            return 0;
        } else if (interactive) {
            if (!down) {
                // Make sure we consume hw key events properly. Discard them
                // here if the event is already been consumed. This case can
                // happen when we send virtual key events and the virtual
                // ACTION_UP is sent before the hw ACTION_UP resulting in
                // handling twice an action up event.
                final boolean consumed = isKeyConsumed(keyCode);
                if (consumed) {
                    if (DEBUG_INPUT) {
                        Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: event already consumed, discard hw event.");
                    }
                    setKeyConsumed(keyCode, !consumed);
                    return 0;
                }
            } else {
                hapticFeedbackRequested = true;
            }
        }
    }
    // Pre-basic policy based on interactive and pocket lock state.
    if (mIsDeviceInPocket && (!interactive || mPocketLockShowing)) {
        if (keyCode != KeyEvent.KEYCODE_POWER && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_MEDIA_PLAY && keyCode != KeyEvent.KEYCODE_MEDIA_PAUSE && keyCode != KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE && keyCode != KeyEvent.KEYCODE_HEADSETHOOK && keyCode != KeyEvent.KEYCODE_MEDIA_STOP && keyCode != KeyEvent.KEYCODE_MEDIA_NEXT && keyCode != KeyEvent.KEYCODE_MEDIA_PREVIOUS && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE) {
            return 0;
        }
    }
    // Intercept the Keypress event for Keypress boost
    if (lIsPerfBoostEnabled && !isCustomSource) {
        if (down && !longPress && repeatCount == 0 || down && longPress && repeatCount == 1) {
            final long boostEventTime = mBoostEventTime;
            mBoostEventTime = SystemClock.uptimeMillis();
            if (boostEventTime != 0L) {
                // we had a previous boost
                final long boostEventTimeDiff = mBoostEventTime - boostEventTime;
                final boolean reBoostByDiff = boostEventTimeDiff >= ((long) mLastBoostDuration - 150L) && boostEventTimeDiff <= ((long) mLastBoostDuration - 50L);
                if (mKeypressBoostBlocked && mLastBoostDuration != 0 && reBoostByDiff) {
                    // We have a few milliseconds remaining from our previous boost, release current boost before triggering next one.
                    mHandler.removeMessages(MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK);
                    mPerfKey.perfLockRelease();
                    mKeypressBoostBlocked = false;
                }
            }
            dispatchKeypressBoost(keyCode);
        }
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // If not requested by our custom policy, then check if the key is virtual.
    hapticFeedbackRequested |= (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0;
    boolean useHapticFeedback = down && hapticFeedbackRequested && repeatCount == 0 && // Trigger haptic feedback only for "real" events.
    source != InputDevice.SOURCE_CUSTOM;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeDownKeyTriggered = true;
                        mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                        mScreenshotChordVolumeDownKeyConsumed = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mScreenshotChordVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeUpKeyTriggered = true;
                        cancelPendingPowerKeyAction();
                        cancelPendingScreenshotChordAction();
                    }
                } else {
                    mScreenshotChordVolumeUpKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            }
            if (down) {
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null) {
                    if (telecomManager.isRinging()) {
                        // If an incoming call is ringing, either VOLUME key means
                        // "silence ringer".  We handle these keys here, rather than
                        // in the InCallScreen, to make sure we'll respond to them
                        // even if the InCallScreen hasn't come to the foreground yet.
                        // Look for the DOWN event here, to agree with the "fallback"
                        // behavior in the InCallScreen.
                        Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                        // Silence the ringer.  (It's safe to call this
                        // even if the ringer has already been silenced.)
                        telecomManager.silenceRinger();
                        // And *don't* pass this key thru to the current activity
                        // (which is probably the InCallScreen.)
                        result &= ~ACTION_PASS_TO_USER;
                        break;
                    }
                    if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                        break;
                    }
                }
            }
            if ((result & ACTION_PASS_TO_USER) == 0) {
                boolean mayChangeVolume = false;
                if (isMusicActive()) {
                    if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        // Detect long key presses.
                        if (down) {
                            mVolBtnLongPress = false;
                            int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                            scheduleLongPressKeyEvent(event, newKeyCode);
                            // Consume key down events of all presses.
                            break;
                        } else {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            // Consume key up events of long presses only.
                            if (mVolBtnLongPress) {
                                break;
                            }
                            // Change volume only on key up events of short presses.
                            mayChangeVolume = true;
                        }
                    } else {
                        // Long key press detection not applicable, change volume only
                        // on key down events
                        mayChangeVolume = down;
                    }
                }
                if (mayChangeVolume) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to figure
                    // out.
                    // Rewrite the event to use key-down as sendVolumeKeyEvent will
                    // only change the volume on key down.
                    KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                }
                break;
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#end_block

#method_before
private void requestTransientBars(WindowState swipeTarget) {
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        if (!isUserSetupComplete()) {
            // Swipe-up for navigation bar is disabled during setup
            return;
        }
        boolean sb = mStatusBarController.checkShowTransientBarLw();
        boolean nb = mNavigationBarController.checkShowTransientBarLw() && !isNavBarEmpty(mLastSystemUiFlags);
        if (sb || nb) {
            // Don't show status bar when swiping on already visible navigation bar
            if (!nb && swipeTarget == mNavigationBar) {
                if (DEBUG)
                    Slog.d(TAG, "Not showing transient bar, wrong swipe target");
                return;
            }
            if (sb)
                mStatusBarController.showTransient();
            if (nb)
                mNavigationBarController.showTransient();
            mImmersiveModeConfirmation.confirmCurrentPrompt();
            updateSystemUiVisibilityLw();
        }
    }
}
#method_after
private void requestTransientBars(WindowState swipeTarget) {
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        if (!isUserSetupComplete()) {
            // Swipe-up for navigation bar is disabled during setup
            return;
        }
        boolean sb = mStatusBarController.checkShowTransientBarLw();
        boolean nb = mNavigationBarController.checkShowTransientBarLw() && !isNavBarEmpty(mLastSystemUiFlags);
        if (sb || nb) {
            // Don't show status bar when swiping on already visible navigation bar
            if (!nb && swipeTarget == mNavigationBar) {
                if (DEBUG)
                    Slog.d(TAG, "Not showing transient bar, wrong swipe target");
                return;
            }
            if (sb)
                mStatusBarController.showTransient();
            if (nb && !immersiveModeImplementsPie()) {
                mNavigationBarController.showTransient();
            }
            mImmersiveModeConfirmation.confirmCurrentPrompt();
            updateSystemUiVisibilityLw();
        }
    }
}
#end_block

#method_before
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
            if (mBootMessageNeedsHiding) {
                mBootMessageNeedsHiding = false;
                hideBootMessages();
            }
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
}
#method_after
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
            if (mBootMessageNeedsHiding) {
                mBootMessageNeedsHiding = false;
                hideBootMessages();
            }
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
    toggleOrientationListener(true);
}
#end_block

#method_before
@Override
public void getStableInsetsLw(int displayRotation, int displayWidth, int displayHeight, Rect outInsets) {
    outInsets.setEmpty();
    // Navigation bar and status bar.
    getNonDecorInsetsLw(displayRotation, displayWidth, displayHeight, outInsets);
    if (mStatusBar != null) {
        outInsets.top = mStatusBarHeight;
    }
}
#method_after
@Override
public void getStableInsetsLw(int displayRotation, int displayWidth, int displayHeight, Rect outInsets) {
    outInsets.setEmpty();
    // Navigation bar and status bar.
    getNonDecorInsetsLw(displayRotation, displayWidth, displayHeight, outInsets);
    if (mStatusBar != null) {
        final int statusBarHeight = shouldForceStatusBarImmersive() ? 0 : mStatusBarHeight;
        outInsets.top = statusBarHeight;
    }
}
#end_block

#method_before
@Override
public void getNonDecorInsetsLw(int displayRotation, int displayWidth, int displayHeight, Rect outInsets) {
    outInsets.setEmpty();
    // Only navigation bar
    if (mNavigationBar != null) {
        int position = navigationBarPosition(displayWidth, displayHeight, displayRotation);
        if (position == NAV_BAR_BOTTOM) {
            outInsets.bottom = getNavigationBarHeight(displayRotation, mUiMode);
        } else if (position == NAV_BAR_RIGHT) {
            outInsets.right = getNavigationBarWidth(displayRotation, mUiMode);
        } else if (position == NAV_BAR_LEFT) {
            outInsets.left = getNavigationBarWidth(displayRotation, mUiMode);
        }
    }
}
#method_after
@Override
public void getNonDecorInsetsLw(int displayRotation, int displayWidth, int displayHeight, Rect outInsets) {
    outInsets.setEmpty();
    final boolean hasNavBar = hasNavigationBar() && mNavigationBar != null;
    final boolean forceNavBarImmersive = shouldForceNavigationBarImmersive();
    // provide full screen to foreground apps. carlosavignano@aospa.co
    if (hasNavBar && !forceNavBarImmersive) {
        int position = navigationBarPosition(displayWidth, displayHeight, displayRotation);
        if (position == NAV_BAR_BOTTOM) {
            outInsets.bottom = getNavigationBarHeight(displayRotation, mUiMode);
        } else if (position == NAV_BAR_RIGHT) {
            outInsets.right = getNavigationBarWidth(displayRotation, mUiMode);
        } else if (position == NAV_BAR_LEFT) {
            outInsets.left = getNavigationBarWidth(displayRotation, mUiMode);
        }
    }
}
#end_block

#method_before
@Override
public boolean isNavBarForcedShownLw(WindowState windowState) {
    return mForceShowSystemBars;
}
#method_after
@Override
public boolean isNavBarForcedShownLw(WindowState windowState) {
    return mForceShowSystemBars && hasNavigationBar() && !shouldForceNavigationBarImmersive();
}
#end_block

#method_before
private int updateSystemUiVisibilityLw() {
    // If there is no window focused, there will be nobody to handle the events
    // anyway, so just hang on in whatever state we're in until things settle down.
    WindowState winCandidate = mFocusedWindow != null ? mFocusedWindow : mTopFullscreenOpaqueWindowState;
    if (winCandidate == null) {
        return 0;
    }
    if (winCandidate.getAttrs().token == mImmersiveModeConfirmation.getWindowToken()) {
        // The immersive mode confirmation should never affect the system bar visibility,
        // otherwise it will unhide the navigation bar and hide itself.
        winCandidate = isStatusBarKeyguard() ? mStatusBar : mTopFullscreenOpaqueWindowState;
        if (winCandidate == null) {
            return 0;
        }
    }
    final WindowState win = winCandidate;
    if ((win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0 && mHideLockScreen == true) {
        // will quickly lose focus once it correctly gets hidden.
        return 0;
    }
    int tmpVisibility = PolicyControl.getSystemUiVisibility(win, null) & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
    if (mForcingShowNavBar && win.getSurfaceLayer() < mForcingShowNavBarLayer) {
        tmpVisibility &= ~PolicyControl.adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
    }
    final int fullscreenVisibility = updateLightStatusBarLw(0, /* vis */
    mTopFullscreenOpaqueWindowState, mTopFullscreenOpaqueOrDimmingWindowState);
    final int dockedVisibility = updateLightStatusBarLw(0, /* vis */
    mTopDockedOpaqueWindowState, mTopDockedOpaqueOrDimmingWindowState);
    mWindowManagerFuncs.getStackBounds(HOME_STACK_ID, mNonDockedStackBounds);
    mWindowManagerFuncs.getStackBounds(DOCKED_STACK_ID, mDockedStackBounds);
    final boolean topWindowWasKeyguard = mTopWindowIsKeyguard;
    mTopWindowIsKeyguard = (win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0;
    if ((mSystemDesignFlags & View.SYSTEM_DESIGN_FLAG_IMMERSIVE_NAV) != 0 && !mForcingShowNavBar) {
        // Enforce Immersive mode on the navigation bar.
        tmpVisibility |= View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
        if (topWindowWasKeyguard && !mTopWindowIsKeyguard) {
            mNavigationBarController.showTransient();
            tmpVisibility |= View.NAVIGATION_BAR_TRANSIENT;
        }
    }
    if ((mSystemDesignFlags & View.SYSTEM_DESIGN_FLAG_IMMERSIVE_STATUS) != 0) {
        // Enforce Immersive mode on the status bar.
        tmpVisibility |= View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_FULLSCREEN;
        if (topWindowWasKeyguard && !mTopWindowIsKeyguard) {
            mStatusBarController.showTransient();
            tmpVisibility |= View.STATUS_BAR_TRANSIENT;
        }
    }
    final int visibility = updateSystemBarsLw(win, mLastSystemUiFlags, tmpVisibility);
    final int diff = visibility ^ mLastSystemUiFlags;
    final int fullscreenDiff = fullscreenVisibility ^ mLastFullscreenStackSysUiFlags;
    final int dockedDiff = dockedVisibility ^ mLastDockedStackSysUiFlags;
    final boolean needsMenu = win.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
    if (diff == 0 && fullscreenDiff == 0 && dockedDiff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == win.getAppToken() && mLastNonDockedStackBounds.equals(mNonDockedStackBounds) && mLastDockedStackBounds.equals(mDockedStackBounds)) {
        return 0;
    }
    mLastSystemUiFlags = visibility;
    mLastFullscreenStackSysUiFlags = fullscreenVisibility;
    mLastDockedStackSysUiFlags = dockedVisibility;
    mLastFocusNeedsMenu = needsMenu;
    mFocusedApp = win.getAppToken();
    final Rect fullscreenStackBounds = new Rect(mNonDockedStackBounds);
    final Rect dockedStackBounds = new Rect(mDockedStackBounds);
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
            if (statusbar != null) {
                statusbar.setSystemUiVisibility(visibility, fullscreenVisibility, dockedVisibility, 0xffffffff, fullscreenStackBounds, dockedStackBounds, win.toString());
                statusbar.topAppWindowChanged(needsMenu);
            }
        }
    });
    return diff;
}
#method_after
private int updateSystemUiVisibilityLw() {
    // If there is no window focused, there will be nobody to handle the events
    // anyway, so just hang on in whatever state we're in until things settle down.
    WindowState winCandidate = mFocusedWindow != null ? mFocusedWindow : mTopFullscreenOpaqueWindowState;
    if (winCandidate == null) {
        return 0;
    }
    if (winCandidate.getAttrs().token == mImmersiveModeConfirmation.getWindowToken()) {
        // The immersive mode confirmation should never affect the system bar visibility,
        // otherwise it will unhide the navigation bar and hide itself.
        winCandidate = isStatusBarKeyguard() ? mStatusBar : mTopFullscreenOpaqueWindowState;
        if (winCandidate == null) {
            return 0;
        }
    }
    final WindowState win = winCandidate;
    if ((win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0 && mHideLockScreen == true) {
        // will quickly lose focus once it correctly gets hidden.
        return 0;
    }
    int tmpVisibility = PolicyControl.getSystemUiVisibility(win, null) & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
    if (mForcingShowNavBar && win.getSurfaceLayer() < mForcingShowNavBarLayer) {
        tmpVisibility &= ~PolicyControl.adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
    }
    final int fullscreenVisibility = updateLightStatusBarLw(0, /* vis */
    mTopFullscreenOpaqueWindowState, mTopFullscreenOpaqueOrDimmingWindowState);
    final int dockedVisibility = updateLightStatusBarLw(0, /* vis */
    mTopDockedOpaqueWindowState, mTopDockedOpaqueOrDimmingWindowState);
    mWindowManagerFuncs.getStackBounds(HOME_STACK_ID, mNonDockedStackBounds);
    mWindowManagerFuncs.getStackBounds(DOCKED_STACK_ID, mDockedStackBounds);
    final int visibility = updateSystemBarsLw(win, mLastSystemUiFlags, tmpVisibility);
    final int diff = visibility ^ mLastSystemUiFlags;
    final int fullscreenDiff = fullscreenVisibility ^ mLastFullscreenStackSysUiFlags;
    final int dockedDiff = dockedVisibility ^ mLastDockedStackSysUiFlags;
    final boolean needsMenu = win.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
    if (diff == 0 && fullscreenDiff == 0 && dockedDiff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == win.getAppToken() && mLastNonDockedStackBounds.equals(mNonDockedStackBounds) && mLastDockedStackBounds.equals(mDockedStackBounds)) {
        return 0;
    }
    mLastSystemUiFlags = visibility;
    mLastFullscreenStackSysUiFlags = fullscreenVisibility;
    mLastDockedStackSysUiFlags = dockedVisibility;
    mLastFocusNeedsMenu = needsMenu;
    mFocusedApp = win.getAppToken();
    final Rect fullscreenStackBounds = new Rect(mNonDockedStackBounds);
    final Rect dockedStackBounds = new Rect(mDockedStackBounds);
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
            if (statusbar != null) {
                statusbar.setSystemUiVisibility(visibility, fullscreenVisibility, dockedVisibility, 0xffffffff, fullscreenStackBounds, dockedStackBounds, win.toString());
                statusbar.topAppWindowChanged(needsMenu);
            }
        }
    });
    return diff;
}
#end_block

#method_before
private int updateSystemBarsLw(WindowState win, int oldVis, int vis) {
    final boolean dockedStackVisible = mWindowManagerInternal.isStackVisible(DOCKED_STACK_ID);
    final boolean freeformStackVisible = mWindowManagerInternal.isStackVisible(FREEFORM_WORKSPACE_STACK_ID);
    final boolean resizing = mWindowManagerInternal.isDockedDividerResizing();
    // We need to force system bars when the docked stack is visible, when the freeform stack
    // is visible but also when we are resizing for the transitions when docked stack
    // visibility changes.
    mForceShowSystemBars = dockedStackVisible || freeformStackVisible || resizing;
    final boolean forceOpaqueStatusBar = mForceShowSystemBars && !mForceStatusBarFromKeyguard;
    // apply translucent bar vis flags
    WindowState fullscreenTransWin = isStatusBarKeyguard() && !mHideLockScreen ? mStatusBar : mTopFullscreenOpaqueWindowState;
    vis = mStatusBarController.applyTranslucentFlagLw(fullscreenTransWin, vis, oldVis);
    vis = mNavigationBarController.applyTranslucentFlagLw(fullscreenTransWin, vis, oldVis);
    final int dockedVis = mStatusBarController.applyTranslucentFlagLw(mTopDockedOpaqueWindowState, 0, 0);
    final boolean fullscreenDrawsStatusBarBackground = (drawsSystemBarBackground(mTopFullscreenOpaqueWindowState) && (vis & View.STATUS_BAR_TRANSLUCENT) == 0) || forcesDrawStatusBarBackground(mTopFullscreenOpaqueWindowState);
    final boolean dockedDrawsStatusBarBackground = (drawsSystemBarBackground(mTopDockedOpaqueWindowState) && (dockedVis & View.STATUS_BAR_TRANSLUCENT) == 0) || forcesDrawStatusBarBackground(mTopDockedOpaqueWindowState);
    // prevent status bar interaction from clearing certain flags
    int type = win.getAttrs().type;
    boolean statusBarHasFocus = type == TYPE_STATUS_BAR;
    if (statusBarHasFocus && !isStatusBarKeyguard()) {
        int flags = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        if (mHideLockScreen) {
            flags |= View.STATUS_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSLUCENT;
        }
        vis = (vis & ~flags) | (oldVis & flags);
    }
    if (fullscreenDrawsStatusBarBackground && dockedDrawsStatusBarBackground) {
        vis |= View.STATUS_BAR_TRANSPARENT;
        vis &= ~View.STATUS_BAR_TRANSLUCENT;
    } else if ((!areTranslucentBarsAllowed() && fullscreenTransWin != mStatusBar) || forceOpaqueStatusBar) {
        vis &= ~(View.STATUS_BAR_TRANSLUCENT | View.STATUS_BAR_TRANSPARENT);
    }
    vis = configureNavBarOpacity(vis, dockedStackVisible, freeformStackVisible, resizing);
    // update status bar
    boolean immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    final boolean hideStatusBarWM = mTopFullscreenOpaqueWindowState != null && (PolicyControl.getWindowFlags(mTopFullscreenOpaqueWindowState, null) & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
    final boolean hideStatusBarSysui = (vis & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
    final boolean hideNavBarSysui = (vis & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0;
    final boolean transientStatusBarAllowed = mStatusBar != null && (statusBarHasFocus || (!mForceShowSystemBars && (hideStatusBarWM || (hideStatusBarSysui && immersiveSticky))));
    final boolean transientNavBarAllowed = mNavigationBar != null && !mForceShowSystemBars && hideNavBarSysui && immersiveSticky;
    final long now = SystemClock.uptimeMillis();
    final boolean pendingPanic = mPendingPanicGestureUptime != 0 && now - mPendingPanicGestureUptime <= PANIC_GESTURE_EXPIRATION;
    if (pendingPanic && hideNavBarSysui && !isStatusBarKeyguard() && mKeyguardDrawComplete) {
        // The user performed the panic gesture recently, we're about to hide the bars,
        // we're no longer on the Keyguard and the screen is ready. We can now request the bars.
        mPendingPanicGestureUptime = 0;
        mStatusBarController.showTransient();
        if (!isNavBarEmpty(vis)) {
            mNavigationBarController.showTransient();
        }
    }
    final boolean denyTransientStatus = mStatusBarController.isTransientShowRequested() && !transientStatusBarAllowed && hideStatusBarSysui;
    final boolean denyTransientNav = mNavigationBarController.isTransientShowRequested() && !transientNavBarAllowed;
    if (denyTransientStatus || denyTransientNav || mForceShowSystemBars) {
        // clear the clearable flags instead
        clearClearableFlagsLw();
        vis &= ~View.SYSTEM_UI_CLEARABLE_FLAGS;
    }
    final boolean immersive = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
    immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    final boolean navAllowedHidden = immersive || immersiveSticky;
    if (hideNavBarSysui && !navAllowedHidden && windowTypeToLayerLw(win.getBaseType()) > windowTypeToLayerLw(TYPE_INPUT_CONSUMER)) {
        // We can't hide the navbar from this window otherwise the input consumer would not get
        // the input events.
        vis = (vis & ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
    }
    vis = mStatusBarController.updateVisibilityLw(transientStatusBarAllowed, oldVis, vis);
    // update navigation bar
    boolean oldImmersiveMode = isImmersiveMode(oldVis);
    boolean newImmersiveMode = isImmersiveMode(vis);
    if (win != null && oldImmersiveMode != newImmersiveMode) {
        final String pkg = win.getOwningPackage();
        mImmersiveModeConfirmation.immersiveModeChangedLw(pkg, newImmersiveMode, isUserSetupComplete(), isNavBarEmpty(win.getSystemUiVisibility()));
    }
    vis = mNavigationBarController.updateVisibilityLw(transientNavBarAllowed, oldVis, vis);
    return vis;
}
#method_after
private int updateSystemBarsLw(WindowState win, int oldVis, int vis) {
    final boolean dockedStackVisible = mWindowManagerInternal.isStackVisible(DOCKED_STACK_ID);
    final boolean freeformStackVisible = mWindowManagerInternal.isStackVisible(FREEFORM_WORKSPACE_STACK_ID);
    final boolean resizing = mWindowManagerInternal.isDockedDividerResizing();
    final boolean hasNavBar = hasNavigationBar() && mNavigationBar != null;
    final boolean forceNavBarImmersive = shouldForceNavigationBarImmersive();
    final boolean forceStatusBarImmersive = shouldForceStatusBarImmersive();
    final boolean isKeyguardShowing = isStatusBarKeyguard() && !mHideLockScreen;
    final boolean topWindowWasKeyguard = mTopWindowIsKeyguard;
    mTopWindowIsKeyguard = (win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0;
    // We need to force system bars when the docked stack is visible, when the freeform stack
    // is visible but also when we are resizing for the transitions when docked stack
    // visibility changes.
    mForceShowSystemBars = dockedStackVisible || freeformStackVisible || resizing;
    final boolean forceOpaqueStatusBar = mForceShowSystemBars && !mForceStatusBarFromKeyguard && !forceStatusBarImmersive;
    // apply translucent bar vis flags
    WindowState fullscreenTransWin = isKeyguardShowing ? mStatusBar : mTopFullscreenOpaqueWindowState;
    vis = mStatusBarController.applyTranslucentFlagLw(fullscreenTransWin, vis, oldVis);
    vis = mNavigationBarController.applyTranslucentFlagLw(fullscreenTransWin, vis, oldVis);
    final int dockedVis = mStatusBarController.applyTranslucentFlagLw(mTopDockedOpaqueWindowState, 0, 0);
    final boolean fullscreenDrawsStatusBarBackground = (drawsSystemBarBackground(mTopFullscreenOpaqueWindowState) && (vis & View.STATUS_BAR_TRANSLUCENT) == 0) || forcesDrawStatusBarBackground(mTopFullscreenOpaqueWindowState);
    final boolean dockedDrawsStatusBarBackground = (drawsSystemBarBackground(mTopDockedOpaqueWindowState) && (dockedVis & View.STATUS_BAR_TRANSLUCENT) == 0) || forcesDrawStatusBarBackground(mTopDockedOpaqueWindowState);
    // prevent status bar interaction from clearing certain flags
    int type = win.getAttrs().type;
    boolean statusBarHasFocus = type == TYPE_STATUS_BAR;
    if (statusBarHasFocus && !isStatusBarKeyguard()) {
        int flags = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        if (mHideLockScreen) {
            flags |= View.STATUS_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSLUCENT;
        }
        vis = (vis & ~flags) | (oldVis & flags);
    }
    if (!forceStatusBarImmersive && fullscreenDrawsStatusBarBackground && dockedDrawsStatusBarBackground) {
        vis |= View.STATUS_BAR_TRANSPARENT;
        vis &= ~View.STATUS_BAR_TRANSLUCENT;
    } else if ((!areTranslucentBarsAllowed() && fullscreenTransWin != mStatusBar) || forceOpaqueStatusBar) {
        vis &= ~(View.STATUS_BAR_TRANSLUCENT | View.STATUS_BAR_TRANSPARENT);
    }
    vis = configureNavBarOpacity(vis, dockedStackVisible, freeformStackVisible, resizing);
    // check whether we need to enforce immersive flags
    if (!isKeyguardShowing && hasNavBar && forceNavBarImmersive) {
        // Enforce Immersive mode on the navigation bar.
        vis |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
        if (topWindowWasKeyguard && !mTopWindowIsKeyguard && !immersiveModeImplementsPie()) {
            mNavigationBarController.showTransient();
            vis |= View.NAVIGATION_BAR_TRANSIENT;
        }
    }
    if (!isKeyguardShowing && forceStatusBarImmersive) {
        // Enforce Immersive mode on the status bar.
        vis |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_FULLSCREEN;
        if (topWindowWasKeyguard && !mTopWindowIsKeyguard) {
            mStatusBarController.showTransient();
            vis |= View.STATUS_BAR_TRANSIENT;
        }
    }
    // update status bar
    boolean immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    final boolean hideStatusBarWM = mTopFullscreenOpaqueWindowState != null && (PolicyControl.getWindowFlags(mTopFullscreenOpaqueWindowState, null) & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
    final boolean hideStatusBarSysui = (vis & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
    final boolean hideNavBarSysui = (vis & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0;
    final boolean transientStatusBarAllowed = mStatusBar != null && (statusBarHasFocus || ((!mForceShowSystemBars || forceStatusBarImmersive) && (hideStatusBarWM || (hideStatusBarSysui && immersiveSticky))));
    final boolean transientNavBarAllowed = mNavigationBar != null && (!mForceShowSystemBars || forceNavBarImmersive) && hideNavBarSysui && immersiveSticky;
    final long now = SystemClock.uptimeMillis();
    final boolean pendingPanic = mPendingPanicGestureUptime != 0 && now - mPendingPanicGestureUptime <= PANIC_GESTURE_EXPIRATION;
    if (pendingPanic && hideNavBarSysui && !isStatusBarKeyguard() && mKeyguardDrawComplete) {
        // The user performed the panic gesture recently, we're about to hide the bars,
        // we're no longer on the Keyguard and the screen is ready. We can now request the bars.
        mPendingPanicGestureUptime = 0;
        mStatusBarController.showTransient();
        if (!isNavBarEmpty(vis) && !immersiveModeImplementsPie()) {
            mNavigationBarController.showTransient();
        }
    }
    final boolean denyTransientStatus = mStatusBarController.isTransientShowRequested() && !transientStatusBarAllowed && hideStatusBarSysui;
    final boolean denyTransientNav = mNavigationBarController.isTransientShowRequested() && !transientNavBarAllowed;
    if (denyTransientStatus || denyTransientNav || mForceShowSystemBars) {
        // clear the clearable flags instead
        clearClearableFlagsLw();
        if (true) {
            // laziness
            vis &= ~View.SYSTEM_UI_FLAG_LOW_PROFILE;
            if (!shouldForceStatusBarImmersive()) {
                vis &= ~View.SYSTEM_UI_FLAG_FULLSCREEN;
            }
            if (!shouldForceNavigationBarImmersive()) {
                vis &= ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
            }
        } else {
            vis &= ~View.SYSTEM_UI_CLEARABLE_FLAGS;
        }
    }
    final boolean immersive = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
    immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    final boolean navAllowedHidden = immersive || immersiveSticky;
    if (!mUsingEdgeGestureServiceForGestures && !forceNavBarImmersive && hideNavBarSysui && !navAllowedHidden && windowTypeToLayerLw(win.getBaseType()) > windowTypeToLayerLw(TYPE_INPUT_CONSUMER)) {
        // We can't hide the navbar from this window otherwise the input consumer would not get
        // the input events.
        vis = (vis & ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
    }
    vis = mStatusBarController.updateVisibilityLw(transientStatusBarAllowed, oldVis, vis);
    // update navigation bar
    boolean oldImmersiveMode = isImmersiveMode(oldVis);
    boolean newImmersiveMode = isImmersiveMode(vis);
    if (win != null && oldImmersiveMode != newImmersiveMode) {
        final String pkg = win.getOwningPackage();
        mImmersiveModeConfirmation.immersiveModeChangedLw(pkg, newImmersiveMode, isUserSetupComplete(), isNavBarEmpty(win.getSystemUiVisibility()));
    }
    vis = mNavigationBarController.updateVisibilityLw(transientNavBarAllowed, oldVis, vis);
    return vis;
}
#end_block

#method_before
private void clearClearableFlagsLw() {
    int newVal = mResettingSystemUiFlags | View.SYSTEM_UI_CLEARABLE_FLAGS;
    if (newVal != mResettingSystemUiFlags) {
        mResettingSystemUiFlags = newVal;
        mWindowManagerFuncs.reevaluateStatusBarVisibility();
    }
}
#method_after
private void clearClearableFlagsLw() {
    int newVal;
    if (true) {
        // laziness
        newVal = mResettingSystemUiFlags | View.SYSTEM_UI_FLAG_LOW_PROFILE;
        if (!shouldForceStatusBarImmersive()) {
            newVal = mResettingSystemUiFlags | View.SYSTEM_UI_FLAG_FULLSCREEN;
        }
        if (!shouldForceNavigationBarImmersive()) {
            newVal = mResettingSystemUiFlags | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
        }
    } else {
        newVal = mResettingSystemUiFlags | View.SYSTEM_UI_CLEARABLE_FLAGS;
    }
    if (newVal != mResettingSystemUiFlags) {
        mResettingSystemUiFlags = newVal;
        mWindowManagerFuncs.reevaluateStatusBarVisibility();
    }
}
#end_block

#method_before
private boolean isImmersiveMode(int vis) {
    final int flags = View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
    return mNavigationBar != null && (vis & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0 && (vis & flags) != 0 && canHideNavigationBar();
}
#method_after
private boolean isImmersiveMode(int vis) {
    return mNavigationBar != null && (vis & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0 && ((vis & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0 || (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0) && canHideNavigationBar();
}
#end_block

#method_before
public void show(final boolean animate) {
    if (mAttached) {
        return;
    }
    final Runnable r = new Runnable() {

        @Override
        public void run() {
            if (mAnimating) {
                mView.animate().cancel();
            }
            if (animate) {
                mView.setAlpha(0.0f);
                addView();
                mView.animate().alpha(1.0f).setListener(new Animator.AnimatorListener() {

                    @Override
                    public void onAnimationStart(Animator animator) {
                        mAnimating = true;
                    }

                    @Override
                    public void onAnimationEnd(Animator animator) {
                        if (mAnimating) {
                            mAnimating = false;
                            // just in case
                            mView.setAlpha(1.0f);
                        }
                    }

                    @Override
                    public void onAnimationCancel(Animator animator) {
                    }

                    @Override
                    public void onAnimationRepeat(Animator animator) {
                    }
                }).start();
            } else {
                mView.setAlpha(1.0f);
                addView();
            }
        }
    };
    mHandler.post(r);
}
#method_after
public void show(final boolean animate) {
    final Runnable r = new Runnable() {

        @Override
        public void run() {
            if (mAttached) {
                return;
            }
            if (mAnimating) {
                mView.animate().cancel();
            }
            if (animate) {
                mView.animate().alpha(1.0f).setListener(new Animator.AnimatorListener() {

                    @Override
                    public void onAnimationStart(Animator animator) {
                        mAnimating = true;
                    }

                    @Override
                    public void onAnimationEnd(Animator animator) {
                        mAnimating = false;
                    }

                    @Override
                    public void onAnimationCancel(Animator animator) {
                    }

                    @Override
                    public void onAnimationRepeat(Animator animator) {
                    }
                }).withStartAction(new Runnable() {

                    @Override
                    public void run() {
                        mView.setAlpha(0.0f);
                        addView();
                    }
                }).start();
            } else {
                mView.setAlpha(1.0f);
                addView();
            }
        }
    };
    mHandler.post(r);
}
#end_block

#method_before
public void hide(final boolean animate) {
    if (!mAttached) {
        return;
    }
    final Runnable r = new Runnable() {

        @Override
        public void run() {
            if (mAnimating) {
                mView.animate().cancel();
            }
            if (animate) {
                mView.animate().alpha(0.0f).setListener(new Animator.AnimatorListener() {

                    @Override
                    public void onAnimationStart(Animator animator) {
                        mAnimating = true;
                    }

                    @Override
                    public void onAnimationEnd(Animator animator) {
                        if (mAnimating) {
                            mAnimating = false;
                            removeView();
                        }
                    }

                    @Override
                    public void onAnimationCancel(Animator animator) {
                    }

                    @Override
                    public void onAnimationRepeat(Animator animator) {
                    }
                }).start();
            } else {
                removeView();
            }
        }
    };
    mHandler.post(r);
}
#method_after
public void hide(final boolean animate) {
    final Runnable r = new Runnable() {

        @Override
        public void run() {
            if (!mAttached) {
                return;
            }
            if (mAnimating) {
                mView.animate().cancel();
            }
            if (animate) {
                mView.animate().alpha(0.0f).setListener(new Animator.AnimatorListener() {

                    @Override
                    public void onAnimationStart(Animator animator) {
                        mAnimating = true;
                    }

                    @Override
                    public void onAnimationEnd(Animator animator) {
                        mAnimating = false;
                        removeView();
                    }

                    @Override
                    public void onAnimationCancel(Animator animator) {
                    }

                    @Override
                    public void onAnimationRepeat(Animator animator) {
                    }
                }).start();
            } else {
                removeView();
                mView.setAlpha(0.0f);
            }
        }
    };
    mHandler.post(r);
}
#end_block

#method_before
private void addView() {
    if (mWindowManager != null) {
        mWindowManager.addView(mView, mLayoutParams);
        mAttached = true;
    }
}
#method_after
private void addView() {
    if (mWindowManager != null && !mAttached) {
        mWindowManager.addView(mView, mLayoutParams);
        mAttached = true;
    }
}
#end_block

#method_before
private void removeView() {
    if (mWindowManager != null) {
        mWindowManager.removeView(mView);
        mAnimating = false;
        mAttached = false;
    }
}
#method_after
private void removeView() {
    if (mWindowManager != null && mAttached) {
        mWindowManager.removeView(mView);
        mAnimating = false;
        mAttached = false;
    }
}
#end_block

#method_before
@Override
public void binderDied() {
    for (int i = mCallbacks.size() - 1; i >= 0; i--) {
        final IThemeCallback callback = mCallbacks.get(i);
        try {
            returnToDefaultTheme(mContext);
            if (callback != null) {
                callback.onThemeChanged(getThemeMode(), getTheme(getAccentColor()));
            }
        } catch (DeadObjectException e) {
            Log.w(TAG, "Death object while calling onStateChanged: ", e);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed to call onStateChanged: ", e);
        }
    }
    mCallbacks.clear();
    mObserver.unregister();
}
#method_after
@Override
public void binderDied() {
    for (int i = mCallbacks.size() - 1; i >= 0; i--) {
        final IThemeCallback callback = mCallbacks.get(i);
        try {
            returnToDefaultTheme(mContext);
            if (callback != null) {
                callback.onThemeChanged(getThemeMode(), getTheme(getAccentColor()));
            }
        } catch (DeadObjectException e) {
            Log.w(TAG, "Death object while calling onThemeChanged: ", e);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed to call onThemeChanged: ", e);
        } catch (NullPointerException e) {
            Log.w(TAG, "NullPointer while calling onThemeChanged: ", e);
        }
    }
    mCallbacks.clear();
    mObserver.unregister();
}
#end_block

#method_before
private int getTheme(int color) {
    final boolean isDarkMode = getThemeMode() == 1;
    switch(color) {
        case 1:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Green : R.style.Theme_DeviceDefault_White_Green;
        case 2:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Cyan : R.style.Theme_DeviceDefault_White_Cyan;
        case 3:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Blue : R.style.Theme_DeviceDefault_White_Blue;
        case 4:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Yellow : R.style.Theme_DeviceDefault_White_Yellow;
        case 5:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Orange : R.style.Theme_DeviceDefault_White_Orange;
        case 6:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Red : R.style.Theme_DeviceDefault_White_Red;
        case 7:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Pink : R.style.Theme_DeviceDefault_White_Pink;
        case 8:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Purple : R.style.Theme_DeviceDefault_White_Purple;
        case 0:
        default:
            return getPrimaryTheme(getThemeMode());
    }
}
#method_after
private int getTheme(int color) {
    final boolean isDarkMode = getThemeMode() == 3;
    final boolean isGreymode = getThemeMode() == 1;
    switch(color) {
        case 1:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Green : isGreymode ? R.style.Theme_DeviceDefault_Grey_Green : R.style.Theme_DeviceDefault_White_Green;
        case 2:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Cyan : isGreymode ? R.style.Theme_DeviceDefault_Grey_Cyan : R.style.Theme_DeviceDefault_White_Cyan;
        case 3:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Blue : isGreymode ? R.style.Theme_DeviceDefault_Grey_Blue : R.style.Theme_DeviceDefault_White_Blue;
        case 4:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Yellow : isGreymode ? R.style.Theme_DeviceDefault_Grey_Yellow : R.style.Theme_DeviceDefault_White_Yellow;
        case 5:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Orange : isGreymode ? R.style.Theme_DeviceDefault_Grey_Orange : R.style.Theme_DeviceDefault_White_Orange;
        case 6:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Red : isGreymode ? R.style.Theme_DeviceDefault_Grey_Red : R.style.Theme_DeviceDefault_White_Red;
        case 7:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Pink : isGreymode ? R.style.Theme_DeviceDefault_Grey_Pink : R.style.Theme_DeviceDefault_White_Pink;
        case 8:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Purple : isGreymode ? R.style.Theme_DeviceDefault_Grey_Purple : R.style.Theme_DeviceDefault_White_Purple;
        case 9:
            return isDarkMode ? R.style.Theme_DeviceDefault_Dark_Grey : isGreymode ? R.style.Theme_DeviceDefault_Grey_Grey : R.style.Theme_DeviceDefault_White_Grey;
        case 0:
        default:
            return getPrimaryTheme(getThemeMode());
    }
}
#end_block

#method_before
private int getPrimaryTheme(int color) {
    switch(color) {
        case 1:
            return R.style.Theme_DeviceDefault_Dark;
        case 0:
        default:
            return R.style.Theme_DeviceDefault_White;
    }
}
#method_after
private int getPrimaryTheme(int color) {
    switch(color) {
        case // dark theme
        3:
            return R.style.Theme_DeviceDefault_Dark;
        case // grey theme
        1:
            return R.style.Theme_DeviceDefault_Grey;
        // default theme
        case 0:
        // pixel theme
        case 2:
        default:
            return R.style.Theme_DeviceDefault_White;
    }
}
#end_block

#method_before
private int getThemeMode() {
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.THEME_PRIMARY_COLOR, 0);
}
#method_after
private int getThemeMode() {
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.THEME_PRIMARY_COLOR, 2);
}
#end_block

#method_before
private int getAccentColor() {
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.THEME_ACCENT_COLOR, 0);
}
#method_after
private int getAccentColor() {
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.THEME_ACCENT_COLOR, 1);
}
#end_block

#method_before
private void dispatchCallbackAdded() {
    if (!mSystemReady)
        return;
    for (int i = 0; i < mCallbacks.size(); i++) {
        IThemeCallback callback = mCallbacks.get(i);
        try {
            if (callback != null) {
                callback.onCallbackAdded(getThemeMode(), getTheme(getAccentColor()));
            }
        } catch (RemoteException ex) {
        // Callback is dead
        }
    }
}
#method_after
private void dispatchCallbackAdded() {
    for (int i = 0; i < mCallbacks.size(); i++) {
        IThemeCallback callback = mCallbacks.get(i);
        try {
            if (callback != null) {
                callback.onCallbackAdded(getThemeMode(), getTheme(getAccentColor()));
            }
        } catch (RemoteException ex) {
        // Callback is dead
        } catch (NullPointerException e) {
            Log.e(TAG, "NullPointer while calling onCallbackAdded: ", e);
        }
    }
}
#end_block

#method_before
private void dispatchThemeSettingChanged() {
    if (!mSystemReady)
        return;
    for (int i = 0; i < mCallbacks.size(); i++) {
        IThemeCallback callback = mCallbacks.get(i);
        try {
            if (callback != null) {
                callback.onThemeChanged(getThemeMode(), getTheme(getAccentColor()));
            }
        } catch (RemoteException ex) {
        // Callback is dead
        }
    }
}
#method_after
private void dispatchThemeSettingChanged() {
    for (int i = 0; i < mCallbacks.size(); i++) {
        IThemeCallback callback = mCallbacks.get(i);
        try {
            if (callback != null) {
                callback.onThemeChanged(getThemeMode(), getTheme(getAccentColor()));
            }
        } catch (RemoteException ex) {
        // Callback is dead
        } catch (NullPointerException e) {
            Log.e(TAG, "NullPointer while calling onCallbackAdded: ", e);
        }
    }
}
#end_block

#method_before
private static void beginShutdownSequence(Context context) {
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Shutdown sequence already running, returning.");
            return;
        }
        sIsStarted = true;
    }
    // Throw up a system dialog to indicate the device is rebooting / shutting down.
    ProgressDialog pd = new ProgressDialog(context);
    // UI: spinning circle only (no progress bar)
    if (PowerManager.REBOOT_RECOVERY_UPDATE.equals(mReason)) {
        // We need the progress bar if uncrypt will be invoked during the
        // reboot, which might be time-consuming.
        mRebootHasProgressBar = RecoverySystem.UNCRYPT_PACKAGE_FILE.exists() && !(RecoverySystem.BLOCK_MAP_FILE.exists());
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));
        if (mRebootHasProgressBar) {
            pd.setMax(100);
            pd.setProgress(0);
            pd.setIndeterminate(false);
            pd.setProgressNumberFormat(null);
            pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_prepare));
        } else {
            pd.setIndeterminate(true);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_reboot));
        }
    } else if (PowerManager.REBOOT_RECOVERY.equals(mReason)) {
        // Factory reset path. Set the dialog message accordingly.
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_reset_message));
        pd.setIndeterminate(true);
    } else if (PowerManager.REBOOT_RECOVERY_USER.equals(mReason)) {
        pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        pd.setIndeterminate(true);
    } else if (PowerManager.REBOOT_REQUESTED_BY_DEVICE_OWNER.equals(mReason)) {
        pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        pd.setIndeterminate(true);
    } else if (PowerManager.REBOOT_BOOTLOADER.equals(mReason)) {
        pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        pd.setIndeterminate(true);
    } else {
        // PowerManager.SHUTDOWN_USER_REQUESTED
        if (mReboot) {
            pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        } else {
            pd.setTitle(context.getText(com.android.internal.R.string.power_off));
            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
        }
        pd.setIndeterminate(true);
    }
    pd.setCancelable(false);
    pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    pd.show();
    sInstance.mProgressDialog = pd;
    sInstance.mContext = context;
    sInstance.mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    // make sure we never fall asleep again
    sInstance.mCpuWakeLock = null;
    try {
        sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG + "-cpu");
        sInstance.mCpuWakeLock.setReferenceCounted(false);
        sInstance.mCpuWakeLock.acquire();
    } catch (SecurityException e) {
        Log.w(TAG, "No permission to acquire wake lock", e);
        sInstance.mCpuWakeLock = null;
    }
    // also make sure the screen stays on for better user experience
    sInstance.mScreenWakeLock = null;
    if (sInstance.mPowerManager.isScreenOn()) {
        try {
            sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, TAG + "-screen");
            sInstance.mScreenWakeLock.setReferenceCounted(false);
            sInstance.mScreenWakeLock.acquire();
        } catch (SecurityException e) {
            Log.w(TAG, "No permission to acquire wake lock", e);
            sInstance.mScreenWakeLock = null;
        }
    }
    // start the thread that initiates shutdown
    sInstance.mHandler = new Handler() {
    };
    sInstance.start();
}
#method_after
private static void beginShutdownSequence(Context context) {
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Shutdown sequence already running, returning.");
            return;
        }
        sIsStarted = true;
    }
    // Throw up a system dialog to indicate the device is rebooting / shutting down.
    ProgressDialog pd = new ProgressDialog(context);
    // UI: spinning circle only (no progress bar)
    if (PowerManager.REBOOT_RECOVERY_UPDATE.equals(mReason)) {
        // We need the progress bar if uncrypt will be invoked during the
        // reboot, which might be time-consuming.
        mRebootHasProgressBar = RecoverySystem.UNCRYPT_PACKAGE_FILE.exists() && !(RecoverySystem.BLOCK_MAP_FILE.exists());
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));
        if (mRebootHasProgressBar) {
            pd.setMax(100);
            pd.setProgress(0);
            pd.setIndeterminate(false);
            pd.setProgressNumberFormat(null);
            pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_prepare));
        } else {
            pd.setIndeterminate(true);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_reboot));
        }
    } else if ((PowerManager.REBOOT_RECOVERY_USER.equals(mReason)) || (PowerManager.REBOOT_RECOVERY.equals(mReason))) {
        pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        pd.setIndeterminate(true);
    } else if (PowerManager.REBOOT_REQUESTED_BY_DEVICE_OWNER.equals(mReason)) {
        pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        pd.setIndeterminate(true);
    } else if (PowerManager.REBOOT_BOOTLOADER.equals(mReason)) {
        pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        pd.setIndeterminate(true);
    } else {
        // PowerManager.SHUTDOWN_USER_REQUESTED
        if (mReboot) {
            pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        } else {
            pd.setTitle(context.getText(com.android.internal.R.string.power_off));
            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
        }
        pd.setIndeterminate(true);
    }
    pd.setCancelable(false);
    pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    pd.show();
    sInstance.mProgressDialog = pd;
    sInstance.mContext = context;
    sInstance.mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    // make sure we never fall asleep again
    sInstance.mCpuWakeLock = null;
    try {
        sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG + "-cpu");
        sInstance.mCpuWakeLock.setReferenceCounted(false);
        sInstance.mCpuWakeLock.acquire();
    } catch (SecurityException e) {
        Log.w(TAG, "No permission to acquire wake lock", e);
        sInstance.mCpuWakeLock = null;
    }
    // also make sure the screen stays on for better user experience
    sInstance.mScreenWakeLock = null;
    if (sInstance.mPowerManager.isScreenOn()) {
        try {
            sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, TAG + "-screen");
            sInstance.mScreenWakeLock.setReferenceCounted(false);
            sInstance.mScreenWakeLock.acquire();
        } catch (SecurityException e) {
            Log.w(TAG, "No permission to acquire wake lock", e);
            sInstance.mScreenWakeLock = null;
        }
    }
    // start the thread that initiates shutdown
    sInstance.mHandler = new Handler() {
    };
    sInstance.start();
}
#end_block

#method_before
@Override
protected void performRemoveNotification(StatusBarNotification n) {
    Entry entry = mNotificationData.get(n.getKey());
    if (mRemoteInputController.isRemoteInputActive(entry)) {
        mRemoteInputController.removeRemoteInput(entry, null);
    }
    super.performRemoveNotification(n);
}
#method_after
@Override
public void performRemoveNotification(StatusBarNotification n) {
    Entry entry = mNotificationData.get(n.getKey());
    if (mRemoteInputController.isRemoteInputActive(entry)) {
        mRemoteInputController.removeRemoteInput(entry, null);
    }
    super.performRemoveNotification(n);
}
#end_block

#method_before
@Override
protected void updateNotifications() {
    mNotificationData.filterAndSort();
    updateNotificationShade();
    mIconController.updateNotificationIcons(mNotificationData);
}
#method_after
@Override
protected void updateNotifications() {
    mNotificationData.filterAndSort();
    updateNotificationShade();
    mIconController.updateNotificationIcons(mNotificationData);
    if (mPieController != null) {
        mPieController.updateNotifications();
    }
}
#end_block

#method_before
public void updateMediaMetaData(boolean metaDataChanged, boolean allowEnterAnimation) {
    Trace.beginSection("PhoneStatusBar#updateMediaMetaData");
    if (!SHOW_LOCKSCREEN_MEDIA_ARTWORK) {
        Trace.endSection();
        return;
    }
    if (mBackdrop == null) {
        Trace.endSection();
        // called too early
        return;
    }
    if (mLaunchTransitionFadingAway) {
        mBackdrop.setVisibility(View.INVISIBLE);
        Trace.endSection();
        return;
    }
    if (DEBUG_MEDIA) {
        Log.v(TAG, "DEBUG_MEDIA: updating album art for notification " + mMediaNotificationKey + " metadata=" + mMediaMetadata + " metaDataChanged=" + metaDataChanged + " state=" + mState);
    }
    Drawable artworkDrawable = null;
    if (mMediaMetadata != null) {
        Bitmap artworkBitmap = null;
        artworkBitmap = mMediaMetadata.getBitmap(MediaMetadata.METADATA_KEY_ART);
        if (artworkBitmap == null) {
            artworkBitmap = mMediaMetadata.getBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART);
        // might still be null
        }
        if (artworkBitmap != null) {
            artworkDrawable = new BitmapDrawable(mBackdropBack.getResources(), artworkBitmap);
        }
    }
    boolean allowWhenShade = false;
    if (ENABLE_LOCKSCREEN_WALLPAPER && artworkDrawable == null) {
        Bitmap lockWallpaper = mLockscreenWallpaper.getBitmap();
        if (lockWallpaper != null) {
            artworkDrawable = new LockscreenWallpaper.WallpaperDrawable(mBackdropBack.getResources(), lockWallpaper);
            // We're in the SHADE mode on the SIM screen - yet we still need to show
            // the lockscreen wallpaper in that mode.
            allowWhenShade = mStatusBarKeyguardViewManager != null && mStatusBarKeyguardViewManager.isShowing();
        }
    }
    boolean hideBecauseOccluded = mStatusBarKeyguardViewManager != null && mStatusBarKeyguardViewManager.isOccluded();
    final boolean hasArtwork = artworkDrawable != null;
    if ((hasArtwork || DEBUG_MEDIA_FAKE_ARTWORK) && (mState != StatusBarState.SHADE || allowWhenShade) && mFingerprintUnlockController.getMode() != FingerprintUnlockController.MODE_WAKE_AND_UNLOCK_PULSING && !hideBecauseOccluded) {
        // time to show some art!
        if (mBackdrop.getVisibility() != View.VISIBLE) {
            mBackdrop.setVisibility(View.VISIBLE);
            if (allowEnterAnimation) {
                mBackdrop.setAlpha(SRC_MIN_ALPHA);
                mBackdrop.animate().alpha(1f);
            } else {
                mBackdrop.animate().cancel();
                mBackdrop.setAlpha(1f);
            }
            mStatusBarWindowManager.setBackdropShowing(true);
            metaDataChanged = true;
            if (DEBUG_MEDIA) {
                Log.v(TAG, "DEBUG_MEDIA: Fading in album artwork");
            }
        }
        if (metaDataChanged) {
            if (mBackdropBack.getDrawable() != null) {
                Drawable drawable = mBackdropBack.getDrawable().getConstantState().newDrawable(mBackdropFront.getResources()).mutate();
                mBackdropFront.setImageDrawable(drawable);
                if (mScrimSrcModeEnabled) {
                    mBackdropFront.getDrawable().mutate().setXfermode(mSrcOverXferMode);
                }
                mBackdropFront.setAlpha(1f);
                mBackdropFront.setVisibility(View.VISIBLE);
            } else {
                mBackdropFront.setVisibility(View.INVISIBLE);
            }
            if (DEBUG_MEDIA_FAKE_ARTWORK) {
                final int c = 0xFF000000 | (int) (Math.random() * 0xFFFFFF);
                Log.v(TAG, String.format("DEBUG_MEDIA: setting new color: 0x%08x", c));
                mBackdropBack.setBackgroundColor(0xFFFFFFFF);
                mBackdropBack.setImageDrawable(new ColorDrawable(c));
            } else {
                mBackdropBack.setImageDrawable(artworkDrawable);
            }
            if (mScrimSrcModeEnabled) {
                mBackdropBack.getDrawable().mutate().setXfermode(mSrcXferMode);
            }
            if (mBackdropFront.getVisibility() == View.VISIBLE) {
                if (DEBUG_MEDIA) {
                    Log.v(TAG, "DEBUG_MEDIA: Crossfading album artwork from " + mBackdropFront.getDrawable() + " to " + mBackdropBack.getDrawable());
                }
                mBackdropFront.animate().setDuration(250).alpha(0f).withEndAction(mHideBackdropFront);
            }
        }
    } else {
        // the metadata isn't there to support it
        if (mBackdrop.getVisibility() != View.GONE) {
            if (DEBUG_MEDIA) {
                Log.v(TAG, "DEBUG_MEDIA: Fading out album artwork");
            }
            if (mFingerprintUnlockController.getMode() == FingerprintUnlockController.MODE_WAKE_AND_UNLOCK_PULSING || hideBecauseOccluded) {
                // We are unlocking directly - no animation!
                mBackdrop.setVisibility(View.GONE);
                mBackdropBack.setImageDrawable(null);
                mStatusBarWindowManager.setBackdropShowing(false);
            } else {
                mStatusBarWindowManager.setBackdropShowing(false);
                mBackdrop.animate().alpha(SRC_MIN_ALPHA).setInterpolator(Interpolators.ACCELERATE_DECELERATE).setDuration(300).setStartDelay(0).withEndAction(new Runnable() {

                    @Override
                    public void run() {
                        mBackdrop.setVisibility(View.GONE);
                        mBackdropFront.animate().cancel();
                        mBackdropBack.setImageDrawable(null);
                        mHandler.post(mHideBackdropFront);
                    }
                });
                if (mKeyguardFadingAway) {
                    mBackdrop.animate().setDuration(mKeyguardFadingAwayDuration / 2).setStartDelay(mKeyguardFadingAwayDelay).setInterpolator(Interpolators.LINEAR).start();
                }
            }
        }
    }
    Trace.endSection();
}
#method_after
public void updateMediaMetaData(boolean metaDataChanged, boolean allowEnterAnimation) {
    Trace.beginSection("PhoneStatusBar#updateMediaMetaData");
    if (!SHOW_LOCKSCREEN_MEDIA_ARTWORK) {
        Trace.endSection();
        return;
    }
    if (mBackdrop == null) {
        Trace.endSection();
        // called too early
        return;
    }
    if (mLaunchTransitionFadingAway) {
        mBackdrop.setVisibility(View.INVISIBLE);
        Trace.endSection();
        return;
    }
    if (DEBUG_MEDIA) {
        Log.v(TAG, "DEBUG_MEDIA: updating album art for notification " + mMediaNotificationKey + " metadata=" + mMediaMetadata + " metaDataChanged=" + metaDataChanged + " state=" + mState);
    }
    Drawable artworkDrawable = null;
    if (mMediaMetadata != null) {
        Bitmap artworkBitmap = null;
        artworkBitmap = mMediaMetadata.getBitmap(MediaMetadata.METADATA_KEY_ART);
        if (artworkBitmap == null) {
            artworkBitmap = mMediaMetadata.getBitmap(MediaMetadata.METADATA_KEY_ALBUM_ART);
        // might still be null
        }
        if (artworkBitmap != null) {
            artworkDrawable = new BitmapDrawable(mBackdropBack.getResources(), artworkBitmap);
        }
    }
    boolean allowWhenShade = false;
    if (ENABLE_LOCKSCREEN_WALLPAPER && artworkDrawable == null) {
        Bitmap lockWallpaper = mLockscreenWallpaper.getBitmap();
        if (lockWallpaper != null) {
            artworkDrawable = new LockscreenWallpaper.WallpaperDrawable(mBackdropBack.getResources(), lockWallpaper);
            // We're in the SHADE mode on the SIM screen - yet we still need to show
            // the lockscreen wallpaper in that mode.
            allowWhenShade = mStatusBarKeyguardViewManager != null && mStatusBarKeyguardViewManager.isShowing();
        }
    }
    boolean hideBecauseOccluded = mStatusBarKeyguardViewManager != null && mStatusBarKeyguardViewManager.isOccluded();
    final boolean hasArtwork = artworkDrawable != null;
    if ((hasArtwork || DEBUG_MEDIA_FAKE_ARTWORK) && (mState != StatusBarState.SHADE || allowWhenShade) && mFingerprintUnlockController.getMode() != FingerprintUnlockController.MODE_WAKE_AND_UNLOCK_PULSING && !hideBecauseOccluded) {
        // time to show some art!
        if (mBackdrop.getVisibility() != View.VISIBLE) {
            mBackdrop.setVisibility(View.VISIBLE);
            if (allowEnterAnimation) {
                mBackdrop.setAlpha(SRC_MIN_ALPHA);
                mBackdrop.animate().alpha(1f);
            } else {
                mBackdrop.animate().cancel();
                mBackdrop.setAlpha(1f);
            }
            mStatusBarWindowManager.setBackdropShowing(true);
            metaDataChanged = true;
            if (DEBUG_MEDIA) {
                Log.v(TAG, "DEBUG_MEDIA: Fading in album artwork");
            }
        }
        if (metaDataChanged) {
            if (mBackdropBack.getDrawable() != null) {
                Drawable drawable = mBackdropBack.getDrawable().getConstantState().newDrawable(mBackdropFront.getResources()).mutate();
                mBackdropFront.setImageDrawable(drawable);
                if (mScrimSrcModeEnabled) {
                    mBackdropFront.getDrawable().mutate().setXfermode(mSrcOverXferMode);
                }
                mBackdropFront.setAlpha(1f);
                mBackdropFront.setVisibility(View.VISIBLE);
            } else {
                mBackdropFront.setVisibility(View.INVISIBLE);
            }
            if (DEBUG_MEDIA_FAKE_ARTWORK) {
                final int c = 0xFF000000 | (int) (Math.random() * 0xFFFFFF);
                Log.v(TAG, String.format("DEBUG_MEDIA: setting new color: 0x%08x", c));
                mBackdropBack.setBackgroundColor(0xFFFFFFFF);
                mBackdropBack.setImageDrawable(new ColorDrawable(c));
            } else {
                mBackdropBack.setImageDrawable(artworkDrawable);
            }
            if (mScrimSrcModeEnabled) {
                mBackdropBack.getDrawable().mutate().setXfermode(mSrcXferMode);
            }
            if (mBackdropFront.getVisibility() == View.VISIBLE) {
                if (DEBUG_MEDIA) {
                    Log.v(TAG, "DEBUG_MEDIA: Crossfading album artwork from " + mBackdropFront.getDrawable() + " to " + mBackdropBack.getDrawable());
                }
                mBackdropFront.animate().setDuration(250).alpha(0f).withEndAction(mHideBackdropFront);
            }
        }
    } else {
        // the metadata isn't there to support it
        if (mBackdrop.getVisibility() != View.GONE) {
            if (DEBUG_MEDIA) {
                Log.v(TAG, "DEBUG_MEDIA: Fading out album artwork");
            }
            int fpMode = mFingerprintUnlockController.getMode();
            if (fpMode == FingerprintUnlockController.MODE_WAKE_AND_UNLOCK_PULSING || fpMode == FingerprintUnlockController.MODE_WAKE_AND_UNLOCK || hideBecauseOccluded) {
                // We are unlocking directly - no animation!
                mBackdrop.setVisibility(View.GONE);
                mBackdropBack.setImageDrawable(null);
                mStatusBarWindowManager.setBackdropShowing(false);
            } else {
                mStatusBarWindowManager.setBackdropShowing(false);
                mBackdrop.animate().alpha(SRC_MIN_ALPHA).setInterpolator(Interpolators.ACCELERATE_DECELERATE).setDuration(300).setStartDelay(0).withEndAction(new Runnable() {

                    @Override
                    public void run() {
                        mBackdrop.setVisibility(View.GONE);
                        mBackdropFront.animate().cancel();
                        mBackdropBack.setImageDrawable(null);
                        mHandler.post(mHideBackdropFront);
                    }
                });
                if (mKeyguardFadingAway) {
                    mBackdrop.animate().setDuration(mKeyguardFadingAwayDuration / 2).setStartDelay(mKeyguardFadingAwayDelay).setInterpolator(Interpolators.LINEAR).start();
                }
            }
        }
    }
    Trace.endSection();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel((String) m.obj);
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
private void setNavigationIconHints(int hints) {
    if (hints == mNavigationIconHints)
        return;
    mNavigationIconHints = hints;
    if (mNavigationBarView != null) {
        mNavigationBarView.setNavigationIconHints(hints);
    }
    checkBarModes();
}
#method_after
private void setNavigationIconHints(int hints) {
    if (hints == mNavigationIconHints)
        return;
    mNavigationIconHints = hints;
    if (mNavigationBarView != null) {
        mNavigationBarView.setNavigationIconHints(hints);
    }
    if (mPieController != null) {
        mPieController.setNavigationIconHints(hints);
    }
    checkBarModes();
}
#end_block

#method_before
@Override
public void onCameraLaunchGestureDetected(int source) {
    mLastCameraLaunchSource = source;
    if (mStartedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = true;
        return;
    }
    if (!mNotificationPanel.canCameraGestureBeLaunched(mStatusBarKeyguardViewManager.isShowing() && mExpandedVisible)) {
        return;
    }
    if (!mDeviceInteractive) {
        PowerManager pm = mContext.getSystemService(PowerManager.class);
        pm.wakeUp(SystemClock.uptimeMillis(), "com.android.systemui:CAMERA_GESTURE");
        mStatusBarKeyguardViewManager.notifyDeviceWakeUpRequested();
    }
    vibrateForCameraGesture();
    if (!mStatusBarKeyguardViewManager.isShowing()) {
        startActivity(KeyguardBottomAreaView.INSECURE_CAMERA_INTENT, true);
    } else {
        if (!mDeviceInteractive) {
            // Avoid flickering of the scrim when we instant launch the camera and the bouncer
            // comes on.
            mScrimController.dontAnimateBouncerChangesUntilNextFrame();
            mGestureWakeLock.acquire(LAUNCH_TRANSITION_TIMEOUT_MS + 1000L);
        }
        if (mScreenTurningOn || mStatusBarKeyguardViewManager.isScreenTurnedOn()) {
            mNotificationPanel.launchCamera(mDeviceInteractive, /* animate */
            source);
        } else {
            // We need to defer the camera launch until the screen comes on, since otherwise
            // we will dismiss us too early since we are waiting on an activity to be drawn and
            // incorrectly get notified because of the screen on event (which resumes and pauses
            // some activities)
            mLaunchCameraOnScreenTurningOn = true;
        }
    }
}
#method_after
@Override
public void onCameraLaunchGestureDetected(int source) {
    mLastCameraLaunchSource = source;
    if (mStartedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = true;
        return;
    }
    if (!mNotificationPanel.canCameraGestureBeLaunched(mStatusBarKeyguardViewManager.isShowing() && mExpandedVisible)) {
        return;
    }
    if (!mDeviceInteractive) {
        PowerManager pm = mContext.getSystemService(PowerManager.class);
        pm.wakeUp(SystemClock.uptimeMillis(), "com.android.systemui:CAMERA_GESTURE");
        mStatusBarKeyguardViewManager.notifyDeviceWakeUpRequested();
    }
    if (source != StatusBarManager.CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE) {
        vibrateForCameraGesture();
    }
    if (!mStatusBarKeyguardViewManager.isShowing()) {
        startActivity(KeyguardBottomAreaView.INSECURE_CAMERA_INTENT, true);
    } else {
        if (!mDeviceInteractive) {
            // Avoid flickering of the scrim when we instant launch the camera and the bouncer
            // comes on.
            mScrimController.dontAnimateBouncerChangesUntilNextFrame();
            mGestureWakeLock.acquire(LAUNCH_TRANSITION_TIMEOUT_MS + 1000L);
        }
        if (mScreenTurningOn || mStatusBarKeyguardViewManager.isScreenTurnedOn()) {
            mNotificationPanel.launchCamera(mDeviceInteractive, /* animate */
            source);
        } else {
            // We need to defer the camera launch until the screen comes on, since otherwise
            // we will dismiss us too early since we are waiting on an activity to be drawn and
            // incorrectly get notified because of the screen on event (which resumes and pauses
            // some activities)
            mLaunchCameraOnScreenTurningOn = true;
        }
    }
}
#end_block

#method_before
private void initDialog() {
    mDialog = new CustomDialog(mContext);
    mSpTexts = new SpTexts(mContext);
    mHovering = false;
    mShowing = false;
    mWindow = mDialog.getWindow();
    mWindow.requestFeature(Window.FEATURE_NO_TITLE);
    mWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
    mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
    mWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
    mDialog.setCanceledOnTouchOutside(true);
    final Resources res = mContext.getResources();
    final WindowManager.LayoutParams lp = mWindow.getAttributes();
    lp.type = mWindowType;
    lp.format = PixelFormat.TRANSLUCENT;
    lp.setTitle(VolumeDialog.class.getSimpleName());
    lp.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL;
    lp.y = res.getDimensionPixelSize(R.dimen.volume_offset_top);
    lp.gravity = Gravity.TOP;
    lp.windowAnimations = -1;
    mWindow.setAttributes(lp);
    mWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING);
    mDialog.setContentView(R.layout.volume_dialog);
    mDialogView = (ViewGroup) mDialog.findViewById(R.id.volume_dialog);
    mDialogView.setOnHoverListener(new View.OnHoverListener() {

        @Override
        public boolean onHover(View v, MotionEvent event) {
            int action = event.getActionMasked();
            mHovering = (action == MotionEvent.ACTION_HOVER_ENTER) || (action == MotionEvent.ACTION_HOVER_MOVE);
            rescheduleTimeoutH();
            return true;
        }
    });
    mDialogContentView = (ViewGroup) mDialog.findViewById(R.id.volume_dialog_content);
    mDialogRowsView = (ViewGroup) mDialogContentView.findViewById(R.id.volume_dialog_rows);
    mExpanded = false;
    mExpandButton = (ImageButton) mDialogView.findViewById(R.id.volume_expand_button);
    mExpandButton.setOnClickListener(mClickExpand);
    updateWindowWidthH();
    updateExpandButtonH();
    mMotion = new VolumeDialogMotion(mDialog, mDialogView, mDialogContentView, mExpandButton, new VolumeDialogMotion.Callback() {

        @Override
        public void onAnimatingChanged(boolean animating) {
            if (animating)
                return;
            if (mPendingStateChanged) {
                mHandler.sendEmptyMessage(H.STATE_CHANGED);
                mPendingStateChanged = false;
            }
            if (mPendingRecheckAll) {
                mHandler.sendEmptyMessage(H.RECHECK_ALL);
                mPendingRecheckAll = false;
            }
        }
    });
    if (mRows.isEmpty()) {
        addRow(AudioManager.STREAM_RING, R.drawable.ic_volume_ringer, R.drawable.ic_volume_ringer_mute, true);
        addRow(AudioManager.STREAM_MUSIC, R.drawable.ic_volume_media, R.drawable.ic_volume_media_mute, true);
        addRow(AudioManager.STREAM_ALARM, R.drawable.ic_volume_alarm, R.drawable.ic_volume_alarm_mute, false);
        addRow(AudioManager.STREAM_VOICE_CALL, R.drawable.ic_volume_voice, R.drawable.ic_volume_voice, false);
        addRow(AudioManager.STREAM_BLUETOOTH_SCO, R.drawable.ic_volume_bt_sco, R.drawable.ic_volume_bt_sco, false);
        addRow(AudioManager.STREAM_SYSTEM, R.drawable.ic_volume_system, R.drawable.ic_volume_system_mute, false);
    } else {
        addExistingRows();
    }
    mExpandButtonAnimationDuration = res.getInteger(R.integer.volume_expand_animation_duration);
    mZenFooter = (ZenFooter) mDialog.findViewById(R.id.volume_zen_footer);
    mZenFooter.init(mZenModeController);
    mZenPanel = (TunerZenModePanel) mDialog.findViewById(R.id.tuner_zen_mode_panel);
    mZenPanel.init(mZenModeController);
    mZenPanel.setCallback(mZenPanelCallback);
}
#method_after
private void initDialog() {
    mDialog = new CustomDialog(mContext);
    mSpTexts = new SpTexts(mContext);
    mHovering = false;
    mShowing = false;
    mWindow = mDialog.getWindow();
    mWindow.requestFeature(Window.FEATURE_NO_TITLE);
    mWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
    mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);
    mWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
    mDialog.setCanceledOnTouchOutside(true);
    final Resources res = mContext.getResources();
    final WindowManager.LayoutParams lp = mWindow.getAttributes();
    lp.type = mWindowType;
    lp.format = PixelFormat.TRANSLUCENT;
    lp.setTitle(VolumeDialog.class.getSimpleName());
    lp.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL;
    lp.y = res.getDimensionPixelSize(R.dimen.volume_offset_top);
    lp.gravity = Gravity.TOP;
    lp.windowAnimations = -1;
    mWindow.setAttributes(lp);
    mWindow.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_NOTHING);
    mDialog.setContentView(R.layout.volume_dialog);
    mDialogView = (ViewGroup) mDialog.findViewById(R.id.volume_dialog);
    mDialogView.setOnHoverListener(new View.OnHoverListener() {

        @Override
        public boolean onHover(View v, MotionEvent event) {
            int action = event.getActionMasked();
            mHovering = (action == MotionEvent.ACTION_HOVER_ENTER) || (action == MotionEvent.ACTION_HOVER_MOVE);
            rescheduleTimeoutH();
            return true;
        }
    });
    mDialogContentView = (ViewGroup) mDialog.findViewById(R.id.volume_dialog_content);
    mDialogRowsView = (ViewGroup) mDialogContentView.findViewById(R.id.volume_dialog_rows);
    mExpanded = false;
    mExpandButton = (ImageButton) mDialogView.findViewById(R.id.volume_expand_button);
    mExpandButton.setOnClickListener(mClickExpand);
    updateWindowWidthH();
    updateExpandButtonH();
    mMotion = new VolumeDialogMotion(mDialog, mDialogView, mDialogContentView, mExpandButton, new VolumeDialogMotion.Callback() {

        @Override
        public void onAnimatingChanged(boolean animating) {
            if (animating)
                return;
            if (mPendingStateChanged) {
                mHandler.sendEmptyMessage(H.STATE_CHANGED);
                mPendingStateChanged = false;
            }
            if (mPendingRecheckAll) {
                mHandler.sendEmptyMessage(H.RECHECK_ALL);
                mPendingRecheckAll = false;
            }
        }
    });
    if (mRows.isEmpty()) {
        addRow(AudioManager.STREAM_RING, R.drawable.ic_volume_ringer, R.drawable.ic_volume_ringer_mute, true);
        addRow(AudioManager.STREAM_MUSIC, R.drawable.ic_volume_media, R.drawable.ic_volume_media_mute, true);
        addRow(AudioManager.STREAM_ALARM, R.drawable.ic_volume_alarm, R.drawable.ic_volume_alarm_mute, false);
        addRow(AudioManager.STREAM_VOICE_CALL, R.drawable.ic_volume_voice, R.drawable.ic_volume_voice, false);
        addRow(AudioManager.STREAM_BLUETOOTH_SCO, R.drawable.ic_volume_bt_sco, R.drawable.ic_volume_bt_sco, false);
        addRow(AudioManager.STREAM_SYSTEM, R.drawable.ic_volume_system, R.drawable.ic_volume_system_mute, false);
    } else {
        addExistingRows();
    }
    mExpandButtonAnimationDuration = res.getInteger(R.integer.volume_expand_animation_duration);
    mZenFooter = (ZenFooter) mDialog.findViewById(R.id.volume_zen_footer);
    mZenFooter.init(mZenModeController);
    mZenPanel = (TunerZenModePanel) mDialog.findViewById(R.id.tuner_zen_mode_panel);
    mZenPanel.init(mZenModeController);
    mZenPanel.setCallback(mZenPanelCallback);
    updateDialog();
}
#end_block

#method_before
protected void updateDialog() {
    final TypedArray ta = mContext.obtainStyledAttributes(new int[] { android.R.attr.colorPrimary });
    mDialog.dismiss();
    mDialogView.setBackgroundColor(ta.getColor(0, 0));
    mActiveSliderTint = ColorStateList.valueOf(Utils.getColorAccent(mContext));
    mInactiveSliderTint = ColorStateList.valueOf(Utils.getColorAccent(mContext));
    ta.recycle();
}
#method_after
protected void updateDialog() {
    final TypedArray ta = mContext.obtainStyledAttributes(new int[] { android.R.attr.colorPrimary, android.R.attr.colorAccent });
    TextView endText = (TextView) mDialog.findViewById(R.id.volume_zen_end_now);
    mDialog.dismiss();
    mDialogView.setBackgroundColor(ta.getColor(0, 0));
    mActiveSliderTint = ColorStateList.valueOf(Utils.getColorAccent(mContext));
    mInactiveSliderTint = ColorStateList.valueOf(Utils.getColorAccent(mContext));
    endText.setTextColor(ta.getColor(1, 0));
    ta.recycle();
}
#end_block

#method_before
private void startOtherServices() {
    final Context context = mSystemContext;
    VibratorService vibrator = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    MmsServiceBroker mmsService = null;
    HardwarePropertiesManagerService hardwarePropertiesService = null;
    Object wigigP2pService = null;
    Object wigigService = null;
    ThemeService themeService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean disableRtt = SystemProperties.getBoolean("config.disable_rtt", false);
    boolean disableMediaProjection = SystemProperties.getBoolean("config.disable_mediaproj", false);
    boolean disableSerial = SystemProperties.getBoolean("config.disable_serial", false);
    boolean disableSearchManager = SystemProperties.getBoolean("config.disable_searchmanager", false);
    boolean disableTrustManager = SystemProperties.getBoolean("config.disable_trustmanager", false);
    boolean disableTextServices = SystemProperties.getBoolean("config.disable_textservices", false);
    boolean disableSamplingProfiler = SystemProperties.getBoolean("config.disable_samplingprof", false);
    boolean disableConsumerIr = SystemProperties.getBoolean("config.disable_consumerir", false);
    boolean disableVrManager = SystemProperties.getBoolean("config.disable_vrmanager", false);
    boolean disableCameraService = SystemProperties.getBoolean("config.disable_cameraservice", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    boolean enableWigig = SystemProperties.getBoolean("persist.wigig.enable", false);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        traceBeginAndSlog("StartSchedulingPolicyService");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        mSystemServiceManager.startService(TelecomLoaderService.class);
        traceBeginAndSlog("StartTelephonyRegistry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartEntropyMixer");
        mEntropyMixer = new EntropyMixer(context);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        mContentResolver = context.getContentResolver();
        if (!disableCameraService) {
            Slog.i(TAG, "Camera Service");
            mSystemServiceManager.startService(CameraService.class);
        }
        // The AccountManager must come before the ContentService
        traceBeginAndSlog("StartAccountManagerService");
        mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartContentService");
        mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("InstallSystemProviders");
        mActivityManagerService.installSystemProviders();
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("ThemeService");
        themeService = new ThemeService(context);
        ServiceManager.addService(Context.THEME_SERVICE, themeService);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartVibratorService");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableConsumerIr) {
            traceBeginAndSlog("StartConsumerIrService");
            consumerIr = new ConsumerIrService(context);
            ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        traceBeginAndSlog("StartAlarmManagerService");
        mSystemServiceManager.startService(AlarmManagerService.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("InitWatchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartInputManagerService");
        inputManager = new InputManagerService(context);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartWindowManagerService");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableVrManager) {
            traceBeginAndSlog("StartVrManagerService");
            mSystemServiceManager.startService(VrManagerService.class);
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooth Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            mSystemServiceManager.startService(BluetoothService.class);
        }
        traceBeginAndSlog("ConnectivityMetricsLoggerService");
        mSystemServiceManager.startService(MetricsLoggerService.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("IpConnectivityMetrics");
        mSystemServiceManager.startService(IpConnectivityMetrics.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("PinnerService");
        mSystemServiceManager.startService(PinnerService.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    ILockSettings lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    EdgeGestureService edgeGestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class);
        traceBeginAndSlog("StartAccessibilityManagerService");
        try {
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    if (!mOnlyCore) {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "UpdatePackagesIfNeeded");
        try {
            mPackageManagerService.updatePackagesIfNeeded();
        } catch (Throwable e) {
            reportWtf("update packages", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "PerformFstrimIfNeeded");
    try {
        mPackageManagerService.performFstrimIfNeeded();
    } catch (Throwable e) {
        reportWtf("performing fstrim", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartLockSettingsService");
            try {
                mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS);
                lockSettings = ILockSettings.Stub.asInterface(ServiceManager.getService("lock_settings"));
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            traceBeginAndSlog("StartStatusBarManagerService");
            try {
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartClipboardService");
            try {
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNetwork) {
            traceBeginAndSlog("StartNetworkManagementService");
            try {
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices && !disableTextServices) {
            mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class);
        }
        if (!disableNetwork) {
            traceBeginAndSlog("StartNetworkScoreService");
            try {
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartNetworkStatsService");
            try {
                networkStats = NetworkStatsService.create(context, networkManagement);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartNetworkPolicyManagerService");
            try {
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_NAN)) {
                mSystemServiceManager.startService(WIFI_NAN_SERVICE_CLASS);
            } else {
                Slog.i(TAG, "No Wi-Fi NAN Service (NAN support Not Present)");
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.scanner.WifiScanningService");
            if (!disableRtt) {
                mSystemServiceManager.startService("com.android.server.wifi.RttService");
            }
            if (enableWigig) {
                try {
                    Slog.i(TAG, "Wigig Service");
                    PathClassLoader wigigClassLoader = new PathClassLoader("/system/framework/wigig-service.jar", "/system/lib64:/system/vendor/lib64", getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass("com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, "Successfully loaded WigigP2pServiceImpl class");
                    ServiceManager.addService("wigigp2p", (IBinder) wigigP2pService);
                    Class wigigClass = wigigClassLoader.loadClass("com.qualcomm.qti.server.wigig.WigigService");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, "Successfully loaded WigigService class");
                    ServiceManager.addService("wigig", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf("starting WigigService", e);
                }
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            traceBeginAndSlog("StartConnectivityService");
            try {
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartNsdService");
            try {
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartUpdateLockService");
            try {
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(RecoverySystemService.class);
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "WaitForAsecScan");
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            traceBeginAndSlog("StartLocationManagerService");
            try {
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartCountryDetectorService");
            try {
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices && !disableSearchManager) {
            traceBeginAndSlog("StartSearchManagerService");
            try {
                mSystemServiceManager.startService(SEARCH_MANAGER_SERVICE_CLASS);
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mSystemServiceManager.startService(DropBoxManagerService.class);
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            traceBeginAndSlog("StartWallpaperManagerService");
            mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        traceBeginAndSlog("StartAudioService");
        mSystemServiceManager.startService(AudioService.Lifecycle.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            // #Fixme:mSystemServiceManager.startService(THERMAL_OBSERVER_CLASS);
            }
        }
        traceBeginAndSlog("StartWiredAccessoryManager");
        try {
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartUsbService");
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            }
            if (!disableSerial) {
                traceBeginAndSlog("StartSerialService");
                try {
                    // Serial port support
                    serial = new SerialService(context);
                    ServiceManager.addService(Context.SERIAL_SERVICE, serial);
                } catch (Throwable e) {
                    Slog.e(TAG, "Failure starting SerialService", e);
                }
                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            }
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartHardwarePropertiesManagerService");
            try {
                hardwarePropertiesService = new HardwarePropertiesManagerService(context);
                ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE, hardwarePropertiesService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting HardwarePropertiesManagerService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mSystemServiceManager.startService(TwilightService.class);
        if (NightDisplayController.isAvailable(context)) {
            mSystemServiceManager.startService(NightDisplayService.class);
        }
        mSystemServiceManager.startService(JobSchedulerService.class);
        mSystemServiceManager.startService(SoundTriggerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
            mSystemServiceManager.startService(SensorNotificationService.class);
            mSystemServiceManager.startService(ContextHubSystemService.class);
        }
        traceBeginAndSlog("StartDiskStatsService");
        try {
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableSamplingProfiler) {
            traceBeginAndSlog("StartSamplingProfilerService");
            try {
                // need to add this service even if SamplingProfilerIntegration.isEnabled()
                // is false, because it is this service that detects system property change and
                // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
                // there is little overhead for running this service.
                ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
            } catch (Throwable e) {
                reportWtf("starting SamplingProfiler Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNetwork && !disableNetworkTime) {
            traceBeginAndSlog("StartNetworkTimeUpdateService");
            try {
                networkTimeUpdater = new NetworkTimeUpdateService(context);
                ServiceManager.addService("network_time_update_service", networkTimeUpdater);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        traceBeginAndSlog("StartCommonTimeManagementService");
        try {
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableNetwork) {
            traceBeginAndSlog("CertBlacklister");
            try {
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNetwork && !disableNonCoreServices && EmergencyAffordanceManager.ENABLED) {
            // EmergencyMode sevice
            mSystemServiceManager.startService(EmergencyAffordanceService.class);
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices && ZygoteInit.PRELOAD_RESOURCES) {
            traceBeginAndSlog("StartAssetAtlasService");
            try {
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE)) {
            mSystemServiceManager.startService(MediaResourceMonitorService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            mSystemServiceManager.startService(TvRemoteService.class);
        }
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartMediaRouterService");
            try {
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (!disableTrustManager) {
                mSystemServiceManager.startService(TrustManagerService.class);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
                mSystemServiceManager.startService(FingerprintService.class);
            }
            traceBeginAndSlog("StartBackgroundDexOptService");
            try {
                BackgroundDexOptService.schedule(context);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        // LauncherAppsService uses ShortcutService.
        mSystemServiceManager.startService(ShortcutService.Lifecycle.class);
        mSystemServiceManager.startService(LauncherAppsService.class);
        try {
            Slog.i(TAG, "EdgeGesture service");
            edgeGestureService = new EdgeGestureService(context, inputManager);
            ServiceManager.addService("edgegestureservice", edgeGestureService);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting EdgeGesture service", e);
        }
    }
    if (!disableNonCoreServices && !disableMediaProjection) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
    // #Fixme:mSystemServiceManager.startService(WEAR_BLUETOOTH_SERVICE_CLASS);
    /* #These Wear Services are part of google.clockwork project
               #and actually these are not present in the code
            mSystemServiceManager.startService(WEAR_BLUETOOTH_SERVICE_CLASS);
            mSystemServiceManager.startService(WEAR_WIFI_MEDIATOR_SERVICE_CLASS);
            if (SystemProperties.getBoolean("config.enable_cellmediator", false)) {
                mSystemServiceManager.startService(WEAR_CELLULAR_MEDIATOR_SERVICE_CLASS);
            }
          if (!disableNonCoreServices) {
              mSystemServiceManager.startService(WEAR_TIME_SERVICE_CLASS);
          }*/
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    if (Settings.Global.getInt(mContentResolver, Settings.Global.DEVICE_PROVISIONED, 0) == 0 || UserManager.isDeviceInDemoMode(mSystemContext)) {
        mSystemServiceManager.startService(RetailDemoModeService.class);
    }
    // It is now time to start up the app processes...
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeVibratorServiceReady");
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeLockSettingsServiceReady");
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeWindowManagerServiceReady");
    // limitations, send boot phase notification separately
    if (enableWigig) {
        try {
            Slog.i(TAG, "calling onBootPhase for Wigig Services");
            Class wigigP2pClass = wigigP2pService.getClass();
            Method m = wigigP2pClass.getMethod("onBootPhase", int.class);
            m.invoke(wigigP2pService, new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
            Class wigigClass = wigigService.getClass();
            m = wigigClass.getMethod("onBootPhase", int.class);
            m.invoke(wigigService, new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
        } catch (Throwable e) {
            reportWtf("Wigig services ready", e);
        }
    }
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Let's check whether we should disable all theme overlays
    final boolean disableOverlays = wm.detectDisableOverlays();
    if (disableOverlays) {
        mActivityManagerService.disableOverlays();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakePowerManagerServiceReady");
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakePackageManagerServiceReady");
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeDisplayManagerServiceReady");
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (edgeGestureService != null) {
        try {
            edgeGestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making EdgeGesture service ready", e);
        }
    }
    try {
        themeService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Theme Service ready", e);
    }
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "PhaseActivityManagerReady");
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartObservingNativeCrashes");
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (!mOnlyCore) {
                Slog.i(TAG, "WebViewFactory preparation");
                Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "WebViewFactoryPreparation");
                mWebViewUpdateService.prepareWebViewInSystemServer();
                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            }
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartSystemUI");
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkScoreReady");
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkManagementServiceReady");
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkStatsServiceReady");
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkPolicyServiceReady");
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeConnectivityServiceReady");
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "PhaseThirdPartyAppsCanStart");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkScoreService running", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
    });
}
#method_after
private void startOtherServices() {
    final Context context = mSystemContext;
    VibratorService vibrator = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    MmsServiceBroker mmsService = null;
    HardwarePropertiesManagerService hardwarePropertiesService = null;
    Object wigigP2pService = null;
    Object wigigService = null;
    ThemeService themeService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean disableRtt = SystemProperties.getBoolean("config.disable_rtt", false);
    boolean disableMediaProjection = SystemProperties.getBoolean("config.disable_mediaproj", false);
    boolean disableSerial = SystemProperties.getBoolean("config.disable_serial", false);
    boolean disableSearchManager = SystemProperties.getBoolean("config.disable_searchmanager", false);
    boolean disableTrustManager = SystemProperties.getBoolean("config.disable_trustmanager", false);
    boolean disableTextServices = SystemProperties.getBoolean("config.disable_textservices", false);
    boolean disableSamplingProfiler = SystemProperties.getBoolean("config.disable_samplingprof", false);
    boolean disableConsumerIr = SystemProperties.getBoolean("config.disable_consumerir", false);
    boolean disableVrManager = SystemProperties.getBoolean("config.disable_vrmanager", false);
    boolean disableCameraService = SystemProperties.getBoolean("config.disable_cameraservice", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    boolean enableWigig = SystemProperties.getBoolean("persist.wigig.enable", false);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        traceBeginAndSlog("StartSchedulingPolicyService");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        mSystemServiceManager.startService(TelecomLoaderService.class);
        traceBeginAndSlog("StartTelephonyRegistry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartEntropyMixer");
        mEntropyMixer = new EntropyMixer(context);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        mContentResolver = context.getContentResolver();
        if (!disableCameraService) {
            Slog.i(TAG, "Camera Service");
            mSystemServiceManager.startService(CameraService.class);
        }
        // The AccountManager must come before the ContentService
        traceBeginAndSlog("StartAccountManagerService");
        mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartContentService");
        mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("InstallSystemProviders");
        mActivityManagerService.installSystemProviders();
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("ThemeService");
        themeService = new ThemeService(context);
        ServiceManager.addService(Context.THEME_SERVICE, themeService);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartVibratorService");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableConsumerIr) {
            traceBeginAndSlog("StartConsumerIrService");
            consumerIr = new ConsumerIrService(context);
            ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        traceBeginAndSlog("StartAlarmManagerService");
        mSystemServiceManager.startService(AlarmManagerService.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("InitWatchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartInputManagerService");
        inputManager = new InputManagerService(context);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("StartWindowManagerService");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableVrManager) {
            traceBeginAndSlog("StartVrManagerService");
            mSystemServiceManager.startService(VrManagerService.class);
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooth Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            mSystemServiceManager.startService(BluetoothService.class);
        }
        traceBeginAndSlog("ConnectivityMetricsLoggerService");
        mSystemServiceManager.startService(MetricsLoggerService.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("IpConnectivityMetrics");
        mSystemServiceManager.startService(IpConnectivityMetrics.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        traceBeginAndSlog("PinnerService");
        mSystemServiceManager.startService(PinnerService.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    ILockSettings lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    EdgeGestureService edgeGestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class);
        traceBeginAndSlog("StartAccessibilityManagerService");
        try {
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    if (!mOnlyCore) {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "UpdatePackagesIfNeeded");
        try {
            mPackageManagerService.updatePackagesIfNeeded();
        } catch (Throwable e) {
            reportWtf("update packages", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "PerformFstrimIfNeeded");
    try {
        mPackageManagerService.performFstrimIfNeeded();
    } catch (Throwable e) {
        reportWtf("performing fstrim", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartLockSettingsService");
            try {
                mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS);
                lockSettings = ILockSettings.Stub.asInterface(ServiceManager.getService("lock_settings"));
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            traceBeginAndSlog("StartStatusBarManagerService");
            try {
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartClipboardService");
            try {
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNetwork) {
            traceBeginAndSlog("StartNetworkManagementService");
            try {
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices && !disableTextServices) {
            mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class);
        }
        if (!disableNetwork) {
            traceBeginAndSlog("StartNetworkScoreService");
            try {
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartNetworkStatsService");
            try {
                networkStats = NetworkStatsService.create(context, networkManagement);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartNetworkPolicyManagerService");
            try {
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_NAN)) {
                mSystemServiceManager.startService(WIFI_NAN_SERVICE_CLASS);
            } else {
                Slog.i(TAG, "No Wi-Fi NAN Service (NAN support Not Present)");
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.scanner.WifiScanningService");
            if (!disableRtt) {
                mSystemServiceManager.startService("com.android.server.wifi.RttService");
            }
            if (enableWigig) {
                try {
                    Slog.i(TAG, "Wigig Service");
                    PathClassLoader wigigClassLoader = new PathClassLoader("/system/framework/wigig-service.jar", "/system/lib64:/system/vendor/lib64", getClass().getClassLoader());
                    Class wigigP2pClass = wigigClassLoader.loadClass("com.qualcomm.qti.server.wigig.p2p.WigigP2pServiceImpl");
                    Constructor<Class> ctor = wigigP2pClass.getConstructor(Context.class);
                    wigigP2pService = ctor.newInstance(context);
                    Slog.i(TAG, "Successfully loaded WigigP2pServiceImpl class");
                    ServiceManager.addService("wigigp2p", (IBinder) wigigP2pService);
                    Class wigigClass = wigigClassLoader.loadClass("com.qualcomm.qti.server.wigig.WigigService");
                    ctor = wigigClass.getConstructor(Context.class);
                    wigigService = ctor.newInstance(context);
                    Slog.i(TAG, "Successfully loaded WigigService class");
                    ServiceManager.addService("wigig", (IBinder) wigigService);
                } catch (Throwable e) {
                    reportWtf("starting WigigService", e);
                }
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            traceBeginAndSlog("StartConnectivityService");
            try {
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartNsdService");
            try {
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartUpdateLockService");
            try {
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(RecoverySystemService.class);
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "WaitForAsecScan");
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            traceBeginAndSlog("StartLocationManagerService");
            try {
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            traceBeginAndSlog("StartCountryDetectorService");
            try {
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices && !disableSearchManager) {
            traceBeginAndSlog("StartSearchManagerService");
            try {
                mSystemServiceManager.startService(SEARCH_MANAGER_SERVICE_CLASS);
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mSystemServiceManager.startService(DropBoxManagerService.class);
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            traceBeginAndSlog("StartWallpaperManagerService");
            mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        traceBeginAndSlog("StartAudioService");
        mSystemServiceManager.startService(AudioService.Lifecycle.class);
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            // #Fixme:mSystemServiceManager.startService(THERMAL_OBSERVER_CLASS);
            }
        }
        traceBeginAndSlog("StartWiredAccessoryManager");
        try {
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartUsbService");
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            }
            if (!disableSerial) {
                traceBeginAndSlog("StartSerialService");
                try {
                    // Serial port support
                    serial = new SerialService(context);
                    ServiceManager.addService(Context.SERIAL_SERVICE, serial);
                } catch (Throwable e) {
                    Slog.e(TAG, "Failure starting SerialService", e);
                }
                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            }
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartHardwarePropertiesManagerService");
            try {
                hardwarePropertiesService = new HardwarePropertiesManagerService(context);
                ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE, hardwarePropertiesService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting HardwarePropertiesManagerService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        mSystemServiceManager.startService(TwilightService.class);
        if (NightDisplayController.isAvailable(context)) {
            mSystemServiceManager.startService(NightDisplayService.class);
        }
        mSystemServiceManager.startService(JobSchedulerService.class);
        mSystemServiceManager.startService(SoundTriggerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
            mSystemServiceManager.startService(SensorNotificationService.class);
            mSystemServiceManager.startService(ContextHubSystemService.class);
        }
        traceBeginAndSlog("StartDiskStatsService");
        try {
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableSamplingProfiler) {
            traceBeginAndSlog("StartSamplingProfilerService");
            try {
                // need to add this service even if SamplingProfilerIntegration.isEnabled()
                // is false, because it is this service that detects system property change and
                // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
                // there is little overhead for running this service.
                ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
            } catch (Throwable e) {
                reportWtf("starting SamplingProfiler Service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNetwork && !disableNetworkTime) {
            traceBeginAndSlog("StartNetworkTimeUpdateService");
            try {
                networkTimeUpdater = new NetworkTimeUpdateService(context);
                ServiceManager.addService("network_time_update_service", networkTimeUpdater);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        traceBeginAndSlog("StartCommonTimeManagementService");
        try {
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        if (!disableNetwork) {
            traceBeginAndSlog("CertBlacklister");
            try {
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNetwork && !disableNonCoreServices && EmergencyAffordanceManager.ENABLED) {
            // EmergencyMode sevice
            mSystemServiceManager.startService(EmergencyAffordanceService.class);
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices && ZygoteInit.PRELOAD_RESOURCES) {
            traceBeginAndSlog("StartAssetAtlasService");
            try {
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE)) {
            mSystemServiceManager.startService(MediaResourceMonitorService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            mSystemServiceManager.startService(TvRemoteService.class);
        }
        if (!disableNonCoreServices) {
            traceBeginAndSlog("StartMediaRouterService");
            try {
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (!disableTrustManager) {
                mSystemServiceManager.startService(TrustManagerService.class);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FINGERPRINT)) {
                mSystemServiceManager.startService(FingerprintService.class);
            }
            traceBeginAndSlog("StartBackgroundDexOptService");
            try {
                BackgroundDexOptService.schedule(context);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
        // LauncherAppsService uses ShortcutService.
        mSystemServiceManager.startService(ShortcutService.Lifecycle.class);
        mSystemServiceManager.startService(LauncherAppsService.class);
        try {
            Slog.i(TAG, "EdgeGesture service");
            edgeGestureService = new EdgeGestureService(context, inputManager);
            ServiceManager.addService("edgegestureservice", edgeGestureService);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting EdgeGesture service", e);
        }
    }
    if (!disableNonCoreServices && !disableMediaProjection) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
    // #Fixme:mSystemServiceManager.startService(WEAR_BLUETOOTH_SERVICE_CLASS);
    /* #These Wear Services are part of google.clockwork project
               #and actually these are not present in the code
            mSystemServiceManager.startService(WEAR_BLUETOOTH_SERVICE_CLASS);
            mSystemServiceManager.startService(WEAR_WIFI_MEDIATOR_SERVICE_CLASS);
            if (SystemProperties.getBoolean("config.enable_cellmediator", false)) {
                mSystemServiceManager.startService(WEAR_CELLULAR_MEDIATOR_SERVICE_CLASS);
            }
          if (!disableNonCoreServices) {
              mSystemServiceManager.startService(WEAR_TIME_SERVICE_CLASS);
          }*/
    }
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    if (Settings.Global.getInt(mContentResolver, Settings.Global.DEVICE_PROVISIONED, 0) == 0 || UserManager.isDeviceInDemoMode(mSystemContext)) {
        mSystemServiceManager.startService(RetailDemoModeService.class);
    }
    // It is now time to start up the app processes...
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeVibratorServiceReady");
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeLockSettingsServiceReady");
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeWindowManagerServiceReady");
    // limitations, send boot phase notification separately
    if (enableWigig) {
        try {
            Slog.i(TAG, "calling onBootPhase for Wigig Services");
            Class wigigP2pClass = wigigP2pService.getClass();
            Method m = wigigP2pClass.getMethod("onBootPhase", int.class);
            m.invoke(wigigP2pService, new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
            Class wigigClass = wigigService.getClass();
            m = wigigClass.getMethod("onBootPhase", int.class);
            m.invoke(wigigService, new Integer(SystemService.PHASE_SYSTEM_SERVICES_READY));
        } catch (Throwable e) {
            reportWtf("Wigig services ready", e);
        }
    }
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Let's check whether we should disable all theme overlays
    final boolean disableOverlays = wm.detectDisableOverlays();
    if (disableOverlays) {
        mActivityManagerService.disableOverlays();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakePowerManagerServiceReady");
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakePackageManagerServiceReady");
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeDisplayManagerServiceReady");
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    if (edgeGestureService != null) {
        try {
            edgeGestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making EdgeGesture service ready", e);
        }
    }
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "PhaseActivityManagerReady");
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartObservingNativeCrashes");
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            if (!mOnlyCore) {
                Slog.i(TAG, "WebViewFactory preparation");
                Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "WebViewFactoryPreparation");
                mWebViewUpdateService.prepareWebViewInSystemServer();
                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            }
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartSystemUI");
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkScoreReady");
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkManagementServiceReady");
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkStatsServiceReady");
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeNetworkPolicyServiceReady");
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "MakeConnectivityServiceReady");
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "PhaseThirdPartyAppsCanStart");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkScoreService running", e);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        }
    });
}
#end_block

#method_before
public static Context getContext(Context context) {
    context.getTheme().applyStyle(sAccentColor, true);
    return context;
}
#method_after
public static Context getContext(Context context) {
    int themeMode = Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.THEME_PRIMARY_COLOR, 2);
    int accentColor = Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.THEME_ACCENT_COLOR, 1);
    if (themeMode == 0 && accentColor == 0) {
        context.setTheme(R.style.Theme_DeviceDefault_Light_Dialog_Alert);
    } else {
        context.getTheme().applyStyle(sTheme, true);
    }
    return context;
}
#end_block

#method_before
public View create(Context context, View convertView, ViewGroup parent, LayoutInflater inflater) {
    View v = inflater.inflate(R.layout.global_actions_item, parent, false);
    final int color = context.getColor(android.R.color.white);
    ImageView icon = (ImageView) v.findViewById(R.id.icon);
    TextView messageView = (TextView) v.findViewById(R.id.message);
    TextView statusView = (TextView) v.findViewById(R.id.status);
    final String status = getStatus();
    if (!TextUtils.isEmpty(status)) {
        statusView.setText(status);
    } else {
        statusView.setVisibility(View.GONE);
    }
    if (mIcon != null) {
        icon.setImageDrawable(mIcon);
        icon.setScaleType(ScaleType.CENTER_CROP);
    } else if (mIconResId != 0) {
        icon.setImageDrawable(context.getDrawable(mIconResId));
    }
    if (sThemeEnabled) {
        icon.setColorFilter(color, Mode.SRC_ATOP);
    } else {
        messageView.setTextColor(Color.BLACK);
        icon.setColorFilter(Color.BLACK, Mode.SRC_ATOP);
    }
    if (mMessage != null) {
        messageView.setText(mMessage);
    } else {
        messageView.setText(mMessageResId);
    }
    return v;
}
#method_after
public View create(Context context, View convertView, ViewGroup parent, LayoutInflater inflater) {
    View v = inflater.inflate(R.layout.global_actions_item, parent, false);
    ImageView icon = (ImageView) v.findViewById(R.id.icon);
    TextView messageView = (TextView) v.findViewById(R.id.message);
    TextView statusView = (TextView) v.findViewById(R.id.status);
    final String status = getStatus();
    if (!TextUtils.isEmpty(status)) {
        statusView.setText(status);
    } else {
        statusView.setVisibility(View.GONE);
    }
    if (mIcon != null) {
        icon.setImageDrawable(mIcon);
        icon.setScaleType(ScaleType.CENTER_CROP);
    } else if (mIconResId != 0) {
        icon.setImageDrawable(context.getDrawable(mIconResId));
    }
    if (mMessage != null) {
        messageView.setText(mMessage);
    } else {
        messageView.setText(mMessageResId);
    }
    return v;
}
#end_block

#method_before
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    mSettingsObserver.observe();
    mDoubleTapGesture = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTap(MotionEvent e) {
            PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
            Log.d(TAG, "Gesture!!");
            if (pm != null)
                pm.goToSleep(e.getEventTime());
            else
                Log.d(TAG, "getSystemService returned null PowerManager");
            return true;
        }
    });
    // the scrim, we don't need the window to be cleared in the beginning.
    if (mService.isScrimSrcModeEnabled()) {
        IBinder windowToken = getWindowToken();
        WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
        lp.token = windowToken;
        setLayoutParams(lp);
        WindowManagerGlobal.getInstance().changeCanvasOpacity(windowToken, true);
        setWillNotDraw(false);
    } else {
        setWillNotDraw(!DEBUG);
    }
}
#method_after
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    mSettingsObserver.observe();
    mDoubleTapGesture = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTap(MotionEvent e) {
            mPowerManager.goToSleep(e.getEventTime());
            return true;
        }
    });
    // the scrim, we don't need the window to be cleared in the beginning.
    if (mService.isScrimSrcModeEnabled()) {
        IBinder windowToken = getWindowToken();
        WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
        lp.token = windowToken;
        setLayoutParams(lp);
        WindowManagerGlobal.getInstance().changeCanvasOpacity(windowToken, true);
        setWillNotDraw(false);
    } else {
        setWillNotDraw(!DEBUG);
    }
}
#end_block

#method_before
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    boolean intercept = false;
    if (mDoubleTapToSleepEnabled && ev.getY() < mStatusBarHeaderHeight) {
        if (DEBUG)
            Log.w(TAG, "logging double tap gesture");
        mDoubleTapGesture.onTouchEvent(ev);
    }
    if (mNotificationPanel.isFullyExpanded() && mStackScrollLayout.getVisibility() == View.VISIBLE && mService.getBarState() == StatusBarState.KEYGUARD && !mService.isBouncerShowing()) {
        intercept = mDragDownHelper.onInterceptTouchEvent(ev);
        // wake up on a touch down event, if dozing
        if (ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
            mService.wakeUpIfDozing(ev.getEventTime(), ev);
        }
    }
    if (!intercept) {
        super.onInterceptTouchEvent(ev);
    }
    if (intercept) {
        MotionEvent cancellation = MotionEvent.obtain(ev);
        cancellation.setAction(MotionEvent.ACTION_CANCEL);
        mStackScrollLayout.onInterceptTouchEvent(cancellation);
        mNotificationPanel.onInterceptTouchEvent(cancellation);
        cancellation.recycle();
    }
    return intercept;
}
#method_after
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    boolean intercept = false;
    if (mDoubleTapToSleepEnabled && ev.getY() < mStatusBarHeaderHeight) {
        mDoubleTapGesture.onTouchEvent(ev);
    }
    if (mNotificationPanel.isFullyExpanded() && mStackScrollLayout.getVisibility() == View.VISIBLE && mService.getBarState() == StatusBarState.KEYGUARD && !mService.isBouncerShowing()) {
        intercept = mDragDownHelper.onInterceptTouchEvent(ev);
        // wake up on a touch down event, if dozing
        if (ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
            mService.wakeUpIfDozing(ev.getEventTime(), ev);
        }
    }
    if (!intercept) {
        super.onInterceptTouchEvent(ev);
    }
    if (intercept) {
        MotionEvent cancellation = MotionEvent.obtain(ev);
        cancellation.setAction(MotionEvent.ACTION_CANCEL);
        mStackScrollLayout.onInterceptTouchEvent(cancellation);
        mNotificationPanel.onInterceptTouchEvent(cancellation);
        cancellation.recycle();
    }
    return intercept;
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_GESTURE), false, this, UserHandle.USER_ALL);
    update();
}
#method_after
void observe() {
    mResolver.registerContentObserver(Settings.System.getUriFor(Settings.System.GESTURE_DOUBLE_TAP_SLEEP), false, this, UserHandle.USER_ALL);
    update();
}
#end_block

#method_before
void unobserve() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.unregisterContentObserver(this);
}
#method_after
void unobserve() {
    mResolver.unregisterContentObserver(this);
}
#end_block

#method_before
public void update() {
    ContentResolver resolver = mContext.getContentResolver();
    mDoubleTapToSleepEnabled = Settings.System.getIntForUser(resolver, Settings.System.DOUBLE_TAP_SLEEP_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
}
#method_after
public void update() {
    mDoubleTapToSleepEnabled = Settings.System.getIntForUser(mResolver, Settings.System.GESTURE_DOUBLE_TAP_SLEEP, 0, UserHandle.USER_CURRENT) == 1;
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.gestures_settings);
    Context context = getActivity();
    mOnScreenGestures = (PreferenceCategory) findPreference(KEY_OFFSCREEN_GESTURES);
    mSystemGestures = (PreferenceCategory) findPreference(KEY_SYSTEM_GESTURES);
    mPreferences = new ArrayList();
    // Double tap power for camera
    if (isCameraDoubleTapPowerGestureAvailable(getResources())) {
        int cameraDisabled = Settings.Secure.getInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED, 0);
        addPreference(KEY_DOUBLE_TAP_POWER, cameraDisabled == 0);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_DOUBLE_TAP_POWER));
    }
    // Ambient Display
    mAmbientConfig = new AmbientDisplayConfiguration(context);
    if (mAmbientConfig.pulseOnPickupAvailable()) {
        boolean pickup = mAmbientConfig.pulseOnPickupEnabled(UserHandle.myUserId());
        addPreference(KEY_PICK_UP, pickup);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_PICK_UP));
    }
    if (mAmbientConfig.pulseOnDoubleTapAvailable()) {
        boolean doubleTap = mAmbientConfig.pulseOnDoubleTapEnabled(UserHandle.myUserId());
        addPreference(KEY_DOUBLE_TAP_SCREEN, doubleTap);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_DOUBLE_TAP_SCREEN));
    }
    // Fingerprint slide for notifications
    if (isSystemUINavigationAvailable(context)) {
        addPreference(KEY_SWIPE_DOWN_FINGERPRINT, isSystemUINavigationEnabled(context));
    } else {
        mSystemGestures.removePreference(findPreference(KEY_SWIPE_DOWN_FINGERPRINT));
    }
    // Double twist for camera mode
    if (isDoubleTwistAvailable(context)) {
        int doubleTwistEnabled = Settings.Secure.getInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED, 1);
        addPreference(KEY_DOUBLE_TWIST, doubleTwistEnabled != 0);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_DOUBLE_TWIST));
    }
    for (String gestureKey : mGesturesKeyCodes.keySet()) {
        if (getResources().getInteger(mGesturesKeyCodes.get(gestureKey)) > 0) {
            findPreference(gestureKey).setOnPreferenceChangeListener(this);
        } else {
            mOnScreenGestures.removePreference(findPreference(gestureKey));
        }
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.gestures_settings);
    Context context = getActivity();
    mOnScreenGestures = (PreferenceCategory) findPreference(KEY_OFFSCREEN_GESTURES);
    mSystemGestures = (PreferenceCategory) findPreference(KEY_SYSTEM_GESTURES);
    mPreferences = new ArrayList();
    // Double tap power for camera
    if (isCameraDoubleTapPowerGestureAvailable(getResources())) {
        int cameraDisabled = Settings.Secure.getInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED, 0);
        addPreference(KEY_DOUBLE_TAP_POWER, cameraDisabled == 0);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_DOUBLE_TAP_POWER));
    }
    // Double tap to sleep
    int tapToSleep = Settings.System.getInt(getContentResolver(), Settings.System.GESTURE_DOUBLE_TAP_SLEEP, 0);
    addPreference(KEY_DOUBLE_TAP_SLEEP, tapToSleep != 0);
    // Ambient Display
    mAmbientConfig = new AmbientDisplayConfiguration(context);
    if (mAmbientConfig.pulseOnPickupAvailable()) {
        boolean pickup = mAmbientConfig.pulseOnPickupEnabled(UserHandle.myUserId());
        addPreference(KEY_PICK_UP, pickup);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_PICK_UP));
    }
    if (mAmbientConfig.pulseOnDoubleTapAvailable()) {
        boolean doubleTap = mAmbientConfig.pulseOnDoubleTapEnabled(UserHandle.myUserId());
        addPreference(KEY_DOUBLE_TAP_SCREEN, doubleTap);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_DOUBLE_TAP_SCREEN));
    }
    // Fingerprint slide for notifications
    if (isSystemUINavigationAvailable(context)) {
        addPreference(KEY_SWIPE_DOWN_FINGERPRINT, isSystemUINavigationEnabled(context));
    } else {
        mSystemGestures.removePreference(findPreference(KEY_SWIPE_DOWN_FINGERPRINT));
    }
    // Double twist for camera mode
    if (isDoubleTwistAvailable(context)) {
        int doubleTwistEnabled = Settings.Secure.getInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED, 1);
        addPreference(KEY_DOUBLE_TWIST, doubleTwistEnabled != 0);
    } else {
        mSystemGestures.removePreference(findPreference(KEY_DOUBLE_TWIST));
    }
    for (String gestureKey : mGesturesKeyCodes.keySet()) {
        if (getResources().getInteger(mGesturesKeyCodes.get(gestureKey)) > 0) {
            findPreference(gestureKey).setOnPreferenceChangeListener(this);
        } else {
            mOnScreenGestures.removePreference(findPreference(gestureKey));
        }
    }
}
#end_block

#method_before
@Override
public boolean onPreferenceChange(Preference preference, Object newValue) {
    String key = preference.getKey();
    if (KEY_DOUBLE_TAP_POWER.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED, enabled ? 0 : 1);
    } else if (KEY_PICK_UP.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.DOZE_PULSE_ON_PICK_UP, enabled ? 1 : 0);
    } else if (KEY_DOUBLE_TAP_SLEEP.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), enabled ? 1 : 0);
    } else if (KEY_DOUBLE_TAP_SCREEN.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.DOZE_PULSE_ON_DOUBLE_TAP, enabled ? 1 : 0);
    } else if (KEY_SWIPE_DOWN_FINGERPRINT.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, enabled ? 1 : 0);
    } else if (KEY_DOUBLE_TWIST.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED, enabled ? 1 : 0);
    } else if (mGesturesSettings.containsKey(key)) {
        Settings.System.putInt(getContentResolver(), mGesturesSettings.get(key), Integer.parseInt((String) newValue));
    }
    return true;
}
#method_after
@Override
public boolean onPreferenceChange(Preference preference, Object newValue) {
    String key = preference.getKey();
    if (KEY_DOUBLE_TAP_POWER.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED, enabled ? 0 : 1);
    } else if (KEY_DOUBLE_TAP_SLEEP.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.System.putInt(getContentResolver(), Settings.System.GESTURE_DOUBLE_TAP_SLEEP, enabled ? 1 : 0);
    } else if (KEY_PICK_UP.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.DOZE_PULSE_ON_PICK_UP, enabled ? 1 : 0);
    } else if (KEY_DOUBLE_TAP_SCREEN.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.DOZE_PULSE_ON_DOUBLE_TAP, enabled ? 1 : 0);
    } else if (KEY_SWIPE_DOWN_FINGERPRINT.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.SYSTEM_NAVIGATION_KEYS_ENABLED, enabled ? 1 : 0);
    } else if (KEY_DOUBLE_TWIST.equals(key)) {
        boolean enabled = (boolean) newValue;
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.CAMERA_DOUBLE_TWIST_TO_FLIP_ENABLED, enabled ? 1 : 0);
    } else if (mGesturesSettings.containsKey(key)) {
        Settings.System.putInt(getContentResolver(), mGesturesSettings.get(key), Integer.parseInt((String) newValue));
    }
    return true;
}
#end_block

#method_before
public long[] readDelta() {
    // Return if we encountered too many read failures already
    if (failurecount >= MAX_READ_TRIES) {
        Arrays.fill(mDeltaSpeedTimes, 0);
        return mDeltaSpeedTimes;
    }
    try (BufferedReader reader = new BufferedReader(new FileReader(mProcFile))) {
        TextUtils.SimpleStringSplitter splitter = new TextUtils.SimpleStringSplitter(' ');
        String line;
        int speedIndex = 0;
        while (speedIndex < mLastSpeedTimes.length && (line = reader.readLine()) != null) {
            splitter.setString(line);
            Long.parseLong(splitter.next());
            long time = Long.parseLong(splitter.next()) * mJiffyMillis;
            if (time < mLastSpeedTimes[speedIndex]) {
                // The stats reset when the cpu hotplugged. That means that the time
                // we read is offset from 0, so the time is the delta.
                mDeltaSpeedTimes[speedIndex] = time;
            } else {
                mDeltaSpeedTimes[speedIndex] = time - mLastSpeedTimes[speedIndex];
            }
            mLastSpeedTimes[speedIndex] = time;
            speedIndex++;
        }
    } catch (IOException e) {
        Slog.e(TAG, "Failed to read cpu-freq: " + e.getMessage());
        Arrays.fill(mDeltaSpeedTimes, 0);
        failurecount++;
    }
    return mDeltaSpeedTimes;
}
#method_after
public long[] readDelta() {
    // Return if we encountered too many read failures already
    if (mFailureCount >= MAX_READ_TRIES) {
        Arrays.fill(mDeltaSpeedTimes, 0);
        return mDeltaSpeedTimes;
    }
    try (BufferedReader reader = new BufferedReader(new FileReader(mProcFile))) {
        TextUtils.SimpleStringSplitter splitter = new TextUtils.SimpleStringSplitter(' ');
        String line;
        int speedIndex = 0;
        while (speedIndex < mLastSpeedTimes.length && (line = reader.readLine()) != null) {
            splitter.setString(line);
            Long.parseLong(splitter.next());
            long time = Long.parseLong(splitter.next()) * mJiffyMillis;
            if (time < mLastSpeedTimes[speedIndex]) {
                // The stats reset when the cpu hotplugged. That means that the time
                // we read is offset from 0, so the time is the delta.
                mDeltaSpeedTimes[speedIndex] = time;
            } else {
                mDeltaSpeedTimes[speedIndex] = time - mLastSpeedTimes[speedIndex];
            }
            mLastSpeedTimes[speedIndex] = time;
            speedIndex++;
        }
    } catch (IOException e) {
        Slog.e(TAG, "Failed to read cpu-freq: " + e.getMessage());
        Arrays.fill(mDeltaSpeedTimes, 0);
        mFailureCount++;
    }
    return mDeltaSpeedTimes;
}
#end_block

#method_before
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (mDragBoostPossible == -1) {
        mDragBoostPossible = 0;
        String currentActivity = getPackageName();
        String[] activityList = getResources().getStringArray(com.android.internal.R.array.boost_activityList);
        if (activityList != null) {
            for (String match : activityList) {
                if (currentActivity.indexOf(match) != -1) {
                    mDragBoostPossible = 1;
                    break;
                }
            }
        }
    }
    Context context = getApplicationContext();
    if (mPerf == null && mDragBoostPossible == 1) {
        final boolean override = context.getResources().getBoolean(R.bool.config_debugBoost);
        mPerf = new BoostFramework();
        if (!override) {
            if (mPerfLockDuration == -1) {
                mPerfLockDuration = getResources().getInteger(com.android.internal.R.integer.ascrollboost_timeout);
                mAsParamVal = getResources().getIntArray(com.android.internal.R.array.ascrollboost_param_value);
            }
            if (mPerfLockDuration != 0 && mAsParamVal.length != 0) {
                mPerf.perfLockAcquireTouch(ev, getResources().getDisplayMetrics(), mPerfLockDuration, mAsParamVal);
            }
        } else {
            mPerf.enableDebugBoost(context, ev, getResources().getDisplayMetrics());
        }
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
#method_after
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (mDragBoostPossible == -1) {
        mDragBoostPossible = 0;
        String currentActivity = getPackageName();
        String[] activityList = getResources().getStringArray(com.android.internal.R.array.boost_activityList);
        if (activityList != null) {
            for (String match : activityList) {
                if (currentActivity.indexOf(match) != -1) {
                    mDragBoostPossible = 1;
                    break;
                }
            }
        }
    }
    Context context = getApplicationContext();
    if (mDragBoostPossible == 1) {
        final boolean override = context.getResources().getBoolean(com.android.internal.R.bool.config_debugBoost);
        if (mPerf == null) {
            mPerf = new BoostFramework();
        }
        if (!override) {
            if (mPerfLockDuration == -1) {
                mPerfLockDuration = getResources().getInteger(com.android.internal.R.integer.ascrollboost_timeout);
                mAsParamVal = getResources().getIntArray(com.android.internal.R.array.ascrollboost_param_value);
            }
            if (mPerfLockDuration != 0 && mAsParamVal.length != 0) {
                mPerf.perfLockAcquireTouch(ev, getResources().getDisplayMetrics(), mPerfLockDuration, mAsParamVal);
            }
        } else {
            mPerf.enableDebugBoost(context, ev, getResources().getDisplayMetrics());
        }
    }
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
#end_block

#method_before
static void shutdownInner(final Context context, boolean confirm) {
    // any additional calls are just returned
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Request to shutdown already running, returning.");
            return;
        }
    }
    final int longPressBehavior = context.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    final int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm);
    Log.d(TAG, "Notifying thread to start shutdown longPressBehavior=" + longPressBehavior);
    if (confirm) {
        final CloseDialogReceiver closer = new CloseDialogReceiver(context);
        if (sConfirmDialog != null) {
            sConfirmDialog.dismiss();
        }
        if (mReboot && !mRebootSafeMode) {
            sConfirmDialog = new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.reboot_title).setMessage(com.android.internal.R.string.reboot_confirm).setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    mReboot = true;
                    beginShutdownSequence(context);
                }
            }).setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    mReboot = true;
                    beginShutdownSequence(context);
                }
            }).setNegativeButton(com.android.internal.R.string.no, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    mReboot = false;
                    dialog.cancel();
                }
            }).create();
            sConfirmDialog.setOnKeyListener(new DialogInterface.OnKeyListener() {

                public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                    if (keyCode == KeyEvent.KEYCODE_BACK) {
                        mReboot = false;
                        dialog.cancel();
                    }
                    return true;
                }
            });
        } else {
            sConfirmDialog = new AlertDialog.Builder(context).setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : com.android.internal.R.string.power_off).setMessage(resourceId).setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    beginShutdownSequence(context);
                }
            }).setNegativeButton(com.android.internal.R.string.no, null).create();
        }
        closer.dialog = sConfirmDialog;
        sConfirmDialog.setOnDismissListener(closer);
        sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
        sConfirmDialog.show();
    } else {
        beginShutdownSequence(context);
    }
}
#method_after
static void shutdownInner(final Context context, boolean confirm) {
    // any additional calls are just returned
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Request to shutdown already running, returning.");
            return;
        }
    }
    final int longPressBehavior = context.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    final int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : mReboot ? com.android.internal.R.string.reboot_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm);
    Log.d(TAG, "Notifying thread to start shutdown longPressBehavior=" + longPressBehavior);
    if (confirm) {
        final CloseDialogReceiver closer = new CloseDialogReceiver(context);
        if (sConfirmDialog != null) {
            sConfirmDialog.dismiss();
        }
        if (mReboot && !mRebootSafeMode) {
            sConfirmDialog = new AlertDialog.Builder(context).setTitle(com.android.internal.R.string.global_action_restart).setMessage(com.android.internal.R.string.reboot_confirm).setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    mReboot = true;
                    beginShutdownSequence(context);
                }
            }).setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    mReboot = true;
                    beginShutdownSequence(context);
                }
            }).setNegativeButton(com.android.internal.R.string.no, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    mReboot = false;
                    dialog.cancel();
                }
            }).create();
            sConfirmDialog.setOnKeyListener(new DialogInterface.OnKeyListener() {

                public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                    if (keyCode == KeyEvent.KEYCODE_BACK) {
                        mReboot = false;
                        dialog.cancel();
                    }
                    return true;
                }
            });
        } else {
            sConfirmDialog = new AlertDialog.Builder(context).setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : com.android.internal.R.string.power_off).setMessage(resourceId).setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

                public void onClick(DialogInterface dialog, int which) {
                    beginShutdownSequence(context);
                }
            }).setNegativeButton(com.android.internal.R.string.no, null).create();
        }
        closer.dialog = sConfirmDialog;
        sConfirmDialog.setOnDismissListener(closer);
        sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
        sConfirmDialog.show();
    } else {
        beginShutdownSequence(context);
    }
}
#end_block

#method_before
private static void beginShutdownSequence(Context context) {
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Shutdown sequence already running, returning.");
            return;
        }
        sIsStarted = true;
    }
    // Throw up a system dialog to indicate the device is rebooting / shutting down.
    ProgressDialog pd = new ProgressDialog(context);
    // UI: spinning circle only (no progress bar)
    if (PowerManager.REBOOT_RECOVERY_UPDATE.equals(mReason)) {
        // We need the progress bar if uncrypt will be invoked during the
        // reboot, which might be time-consuming.
        mRebootHasProgressBar = RecoverySystem.UNCRYPT_PACKAGE_FILE.exists() && !(RecoverySystem.BLOCK_MAP_FILE.exists());
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));
        if (mRebootHasProgressBar) {
            pd.setMax(100);
            pd.setProgress(0);
            pd.setIndeterminate(false);
            pd.setProgressNumberFormat(null);
            pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_prepare));
        } else {
            pd.setIndeterminate(true);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_reboot));
        }
    } else if (PowerManager.REBOOT_RECOVERY.equals(mReason)) {
        // Factory reset path. Set the dialog message accordingly.
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_reset_message));
        pd.setIndeterminate(true);
    } else if (mReboot) {
        pd.setTitle(context.getText(com.android.internal.R.string.reboot));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
    } else {
        pd.setTitle(context.getText(com.android.internal.R.string.power_off));
        pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
        pd.setIndeterminate(true);
    }
    pd.setCancelable(false);
    pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    pd.show();
    sInstance.mProgressDialog = pd;
    sInstance.mContext = context;
    sInstance.mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    // make sure we never fall asleep again
    sInstance.mCpuWakeLock = null;
    try {
        sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG + "-cpu");
        sInstance.mCpuWakeLock.setReferenceCounted(false);
        sInstance.mCpuWakeLock.acquire();
    } catch (SecurityException e) {
        Log.w(TAG, "No permission to acquire wake lock", e);
        sInstance.mCpuWakeLock = null;
    }
    // also make sure the screen stays on for better user experience
    sInstance.mScreenWakeLock = null;
    if (sInstance.mPowerManager.isScreenOn()) {
        try {
            sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, TAG + "-screen");
            sInstance.mScreenWakeLock.setReferenceCounted(false);
            sInstance.mScreenWakeLock.acquire();
        } catch (SecurityException e) {
            Log.w(TAG, "No permission to acquire wake lock", e);
            sInstance.mScreenWakeLock = null;
        }
    }
    // start the thread that initiates shutdown
    sInstance.mHandler = new Handler() {
    };
    sInstance.start();
}
#method_after
private static void beginShutdownSequence(Context context) {
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Shutdown sequence already running, returning.");
            return;
        }
        sIsStarted = true;
    }
    // Throw up a system dialog to indicate the device is rebooting / shutting down.
    ProgressDialog pd = new ProgressDialog(context);
    // UI: spinning circle only (no progress bar)
    if (PowerManager.REBOOT_RECOVERY_UPDATE.equals(mReason)) {
        // We need the progress bar if uncrypt will be invoked during the
        // reboot, which might be time-consuming.
        mRebootHasProgressBar = RecoverySystem.UNCRYPT_PACKAGE_FILE.exists() && !(RecoverySystem.BLOCK_MAP_FILE.exists());
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));
        if (mRebootHasProgressBar) {
            pd.setMax(100);
            pd.setProgress(0);
            pd.setIndeterminate(false);
            pd.setProgressNumberFormat(null);
            pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_prepare));
        } else {
            pd.setIndeterminate(true);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_reboot));
        }
    } else if (PowerManager.REBOOT_RECOVERY.equals(mReason)) {
        // Factory reset path. Set the dialog message accordingly.
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_reset_message));
        pd.setIndeterminate(true);
    } else if (mReboot) {
        pd.setTitle(context.getText(com.android.internal.R.string.global_action_restart));
        pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
    } else {
        pd.setTitle(context.getText(com.android.internal.R.string.power_off));
        pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
        pd.setIndeterminate(true);
    }
    pd.setCancelable(false);
    pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    pd.show();
    sInstance.mProgressDialog = pd;
    sInstance.mContext = context;
    sInstance.mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    // make sure we never fall asleep again
    sInstance.mCpuWakeLock = null;
    try {
        sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG + "-cpu");
        sInstance.mCpuWakeLock.setReferenceCounted(false);
        sInstance.mCpuWakeLock.acquire();
    } catch (SecurityException e) {
        Log.w(TAG, "No permission to acquire wake lock", e);
        sInstance.mCpuWakeLock = null;
    }
    // also make sure the screen stays on for better user experience
    sInstance.mScreenWakeLock = null;
    if (sInstance.mPowerManager.isScreenOn()) {
        try {
            sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, TAG + "-screen");
            sInstance.mScreenWakeLock.setReferenceCounted(false);
            sInstance.mScreenWakeLock.acquire();
        } catch (SecurityException e) {
            Log.w(TAG, "No permission to acquire wake lock", e);
            sInstance.mScreenWakeLock = null;
        }
    }
    // start the thread that initiates shutdown
    sInstance.mHandler = new Handler() {
    };
    sInstance.start();
}
#end_block

#method_before
public void register(boolean register) {
    final ContentResolver cr = mContext.getContentResolver();
    if (register) {
        cr.registerContentObserver(SCREENSHOT_SHUTTER_SOUND_URI, false, this);
    } else {
        cr.unregisterContentObserver(this);
    }
}
#method_after
public void register() {
    final ContentResolver cr = mContext.getContentResolver();
    cr.registerContentObserver(SCREENSHOT_SHUTTER_SOUND_URI, false, this);
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange, Uri uri) {
    super.onChange(selfChange, uri);
    if (SCREENSHOT_SHUTTER_SOUND_URI.equals(uri)) {
        GlobalScreenshot.this.updateCameraSound();
    }
}
#method_after
@Override
public void onChange(boolean selfChange, Uri uri) {
    super.onChange(selfChange, uri);
    GlobalScreenshot.this.updateCameraSound();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_ENABLE_POINTER_LOCATION:
            enablePointerLocation();
            break;
        case MSG_DISABLE_POINTER_LOCATION:
            disablePointerLocation();
            break;
        case MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK:
            dispatchMediaKeyWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK:
            dispatchMediaKeyRepeatWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_SHOW_RECENTS:
            showRecentApps(false, msg.arg1 != 0);
            break;
        case MSG_DISPATCH_SHOW_GLOBAL_ACTIONS:
            showGlobalActionsInternal();
            break;
        case MSG_KEYGUARD_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_KEYGUARD_DRAWN_TIMEOUT:
            Slog.w(TAG, "Keyguard drawn timeout. Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_WINDOW_MANAGER_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mWindowManagerDrawComplete");
            finishWindowsDrawn();
            break;
        case MSG_HIDE_BOOT_MESSAGE:
            handleHideBootMessage();
            break;
        case MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK:
            launchVoiceAssistWithWakeLock(msg.arg1 != 0);
            break;
        case MSG_POWER_DELAYED_PRESS:
            powerPress((Long) msg.obj, msg.arg1 != 0, msg.arg2);
            finishPowerKeyPress();
            break;
        case MSG_POWER_LONG_PRESS:
            powerLongPress();
            break;
        case MSG_UPDATE_DREAMING_SLEEP_TOKEN:
            updateDreamingSleepToken(msg.arg1 != 0);
            break;
        case MSG_REQUEST_TRANSIENT_BARS:
            WindowState targetBar = (msg.arg1 == MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS) ? mStatusBar : mNavigationBar;
            if (targetBar != null) {
                requestTransientBars(targetBar);
            }
            break;
        case MSG_SHOW_TV_PICTURE_IN_PICTURE_MENU:
            showTvPictureInPictureMenuInternal();
            break;
        case MSG_BACK_LONG_PRESS:
            backLongPress();
            break;
        case MSG_DISPOSE_INPUT_CONSUMER:
            disposeInputConsumer((InputConsumer) msg.obj);
            break;
        case MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                mVolBtnLongPress = true;
                dispatchMediaKeyWithWakeLockToAudioService(event);
                dispatchMediaKeyWithWakeLockToAudioService(KeyEvent.changeAction(event, KeyEvent.ACTION_UP));
                break;
            }
        case MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK:
            mKeypressBoostBlocked = false;
            break;
        case MSG_RELEASE_ROTATION_LOCK:
            mPerf_rotation.perfLockRelease();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_ENABLE_POINTER_LOCATION:
            enablePointerLocation();
            break;
        case MSG_DISABLE_POINTER_LOCATION:
            disablePointerLocation();
            break;
        case MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK:
            dispatchMediaKeyWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_MEDIA_KEY_REPEAT_WITH_WAKE_LOCK:
            dispatchMediaKeyRepeatWithWakeLock((KeyEvent) msg.obj);
            break;
        case MSG_DISPATCH_SHOW_RECENTS:
            showRecentApps(false, msg.arg1 != 0);
            break;
        case MSG_DISPATCH_SHOW_GLOBAL_ACTIONS:
            showGlobalActionsInternal();
            break;
        case MSG_KEYGUARD_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_KEYGUARD_DRAWN_TIMEOUT:
            Slog.w(TAG, "Keyguard drawn timeout. Setting mKeyguardDrawComplete");
            finishKeyguardDrawn();
            break;
        case MSG_WINDOW_MANAGER_DRAWN_COMPLETE:
            if (DEBUG_WAKEUP)
                Slog.w(TAG, "Setting mWindowManagerDrawComplete");
            finishWindowsDrawn();
            break;
        case MSG_HIDE_BOOT_MESSAGE:
            handleHideBootMessage();
            break;
        case MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK:
            launchVoiceAssistWithWakeLock(msg.arg1 != 0);
            break;
        case MSG_POWER_DELAYED_PRESS:
            powerPress((Long) msg.obj, msg.arg1 != 0, msg.arg2);
            finishPowerKeyPress();
            break;
        case MSG_POWER_LONG_PRESS:
            powerLongPress();
            break;
        case MSG_UPDATE_DREAMING_SLEEP_TOKEN:
            updateDreamingSleepToken(msg.arg1 != 0);
            break;
        case MSG_REQUEST_TRANSIENT_BARS:
            WindowState targetBar = (msg.arg1 == MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS) ? mStatusBar : mNavigationBar;
            if (targetBar != null) {
                requestTransientBars(targetBar);
            }
            break;
        case MSG_SHOW_TV_PICTURE_IN_PICTURE_MENU:
            showTvPictureInPictureMenuInternal();
            break;
        case MSG_BACK_LONG_PRESS:
            backLongPress();
            break;
        case MSG_DISPOSE_INPUT_CONSUMER:
            disposeInputConsumer((InputConsumer) msg.obj);
            break;
        case MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK:
            {
                KeyEvent event = (KeyEvent) msg.obj;
                mVolBtnLongPress = true;
                dispatchMediaKeyWithWakeLockToAudioService(event);
                dispatchMediaKeyWithWakeLockToAudioService(KeyEvent.changeAction(event, KeyEvent.ACTION_UP));
                break;
            }
        case MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK:
            mKeypressBoostBlocked = false;
            break;
        case MSG_RELEASE_ROTATION_LOCK:
            mPerfRotation.perfLockRelease();
            break;
    }
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasAlertSlider = mContext.getResources().getBoolean(R.bool.config_hasAlertSlider) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_state_path)) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_uevent_match_path));
    // Initialise Keypress Boost
    lIsPerfBoostEnabled = mBoostParamValWeak.length != 0 && mBoostParamValStrong.length != 0;
    mBoostParamValWeak = context.getResources().getIntArray(com.android.internal.R.array.qboost_weak_param_value);
    mBoostParamValStrong = context.getResources().getIntArray(com.android.internal.R.array.qboost_strong_param_value);
    if (lIsPerfBoostEnabled) {
        mPerf_key = new BoostFramework();
        mPerf_rotation = new BoostFramework();
    }
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    // Custom input policy settings.
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        mKeyPressed.put(keyCode, false);
        mKeyConsumed.put(keyCode, false);
        mKeyDoubleTapPending.put(keyCode, false);
        mKeyDoubleTapRunnable.put(keyCode, createDoubleTapTimeoutRunnable(keyCode));
        mKeyDoubleTapBehaviorDefaultResId.put(keyCode, getKeyDoubleTapBehaviorResId(keyCode));
        mKeyLongPressBehaviorDefaultResId.put(keyCode, getKeyLongPressBehaviorResId(keyCode));
    }
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasAlertSlider = mContext.getResources().getBoolean(R.bool.config_hasAlertSlider) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_state_path)) && !TextUtils.isEmpty(mContext.getResources().getString(R.string.alert_slider_uevent_match_path));
    // Initialise Keypress Boost
    lIsPerfBoostEnabled = mBoostParamValWeak.length != 0 && mBoostParamValStrong.length != 0;
    mBoostParamValWeak = context.getResources().getIntArray(com.android.internal.R.array.qboost_weak_param_value);
    mBoostParamValStrong = context.getResources().getIntArray(com.android.internal.R.array.qboost_strong_param_value);
    if (lIsPerfBoostEnabled) {
        mPerfKey = new BoostFramework();
        mPerfRotation = new BoostFramework();
    }
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    // Custom input policy settings.
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        mKeyPressed.put(keyCode, false);
        mKeyConsumed.put(keyCode, false);
        mKeyDoubleTapPending.put(keyCode, false);
        mKeyDoubleTapRunnable.put(keyCode, createDoubleTapTimeoutRunnable(keyCode));
        mKeyDoubleTapBehaviorDefaultResId.put(keyCode, getKeyDoubleTapBehaviorResId(keyCode));
        mKeyLongPressBehaviorDefaultResId.put(keyCode, getKeyLongPressBehaviorResId(keyCode));
    }
}
#end_block

#method_before
private void dispatchKeypressBoost(int keyCode) {
    int boostDuration = 0;
    int[] boostParamVal = mBoostParamValWeak;
    // Calculate the duration of the boost
    switch(keyCode) {
        case KeyEvent.KEYCODE_UNKNOWN:
            mLastBoostDuration = 0;
            return;
        case KeyEvent.KEYCODE_APP_SWITCH:
        case KeyEvent.KEYCODE_BACK:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_HOME:
        case KeyEvent.KEYCODE_SOFT_LEFT:
        case KeyEvent.KEYCODE_SOFT_RIGHT:
            boostDuration = 300;
            break;
        case KeyEvent.KEYCODE_CAMERA:
        case KeyEvent.KEYCODE_POWER:
            boostDuration = 500;
            boostParamVal = mBoostParamValStrong;
            break;
        case KeyEvent.KEYCODE_MEDIA_PLAY:
            boostDuration = 650;
            break;
    }
    // Dispatch the boost
    if (boostDuration != 0) {
        mLastBoostDuration = boostDuration;
        Slog.i(TAG, "Dispatching Keypress boost for " + boostDuration + " ms.");
        mPerf_key.perfLockAcquire(boostDuration, boostParamVal);
        // Block Keypress boost
        mKeypressBoostBlocked = true;
        // Calculate unblock time and dispatch delayed unblock MSG
        int boostBlockTime = boostDuration + 50;
        mHandler.sendEmptyMessageDelayed(MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK, boostBlockTime);
    }
}
#method_after
private void dispatchKeypressBoost(int keyCode) {
    int boostDuration = 0;
    int[] boostParamVal = mBoostParamValWeak;
    // Calculate the duration of the boost
    switch(keyCode) {
        case KeyEvent.KEYCODE_UNKNOWN:
            mLastBoostDuration = 0;
            return;
        case KeyEvent.KEYCODE_APP_SWITCH:
        case KeyEvent.KEYCODE_BACK:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_HOME:
        case KeyEvent.KEYCODE_SOFT_LEFT:
        case KeyEvent.KEYCODE_SOFT_RIGHT:
            boostDuration = 300;
            break;
        case KeyEvent.KEYCODE_CAMERA:
        case KeyEvent.KEYCODE_POWER:
            boostDuration = 500;
            boostParamVal = mBoostParamValStrong;
            break;
        case KeyEvent.KEYCODE_MEDIA_PLAY:
            boostDuration = 650;
            break;
    }
    // Dispatch the boost
    if (boostDuration != 0) {
        mLastBoostDuration = boostDuration;
        Slog.i(TAG, "Dispatching Keypress boost for " + boostDuration + " ms.");
        mPerfKey.perfLockAcquire(boostDuration, boostParamVal);
        // Block Keypress boost
        mKeypressBoostBlocked = true;
        // Calculate unblock time and dispatch delayed unblock MSG
        int boostBlockTime = boostDuration + 50;
        mHandler.sendEmptyMessageDelayed(MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK, boostBlockTime);
    }
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    // Request haptic feedback for hw keys finger down events.
    boolean hapticFeedbackRequested = false;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeQueueing(): event =" + event.toString() + ", interactive =" + interactive + ", keyguardActive =" + keyguardActive + ", policyFlags =" + Integer.toHexString(policyFlags) + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", canApplyCustomPolicy = " + canApplyCustomPolicy(keyCode));
    }
    // Apply custom policy for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if (mNavBarEnabled && !navBarKey) /* TODO> && !isADBVirtualKeyOrAnyOtherKeyThatWeNeedToHandleAKAWhenMonkeyTestOrWHATEVER! */
        {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: mNavBarEnabled, discard hw event.");
            }
            // Don't allow key events from hw keys when navbar is enabled.
            return 0;
        } else if (!interactive) {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: screen not interactive, discard hw event.");
            }
            // Ensure nav keys are handled on full interactive screen only.
            return 0;
        } else if (interactive) {
            if (!down) {
                // Make sure we consume hw key events properly. Discard them
                // here if the event is already been consumed. This case can
                // happen when we send virtual key events and the virtual
                // ACTION_UP is sent before the hw ACTION_UP resulting in
                // handling twice an action up event.
                final boolean consumed = isKeyConsumed(keyCode);
                if (consumed) {
                    if (DEBUG_INPUT) {
                        Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: event already consumed, discard hw event.");
                    }
                    setKeyConsumed(keyCode, !consumed);
                    return 0;
                }
            } else {
                hapticFeedbackRequested = true;
            }
        }
    }
    // Intercept the Keypress event for Keypress boost
    if (lIsPerfBoostEnabled && !isCustomSource) {
        if (down && !longPress && repeatCount == 0 || down && longPress && repeatCount == 1) {
            final long boostEventTime = mBoostEventTime;
            mBoostEventTime = SystemClock.uptimeMillis();
            if (boostEventTime != 0L) {
                // we had a previous boost
                final long boostEventTimeDiff = mBoostEventTime - boostEventTime;
                final boolean reBoostByDiff = boostEventTimeDiff >= ((long) mLastBoostDuration - 150L) && boostEventTimeDiff <= ((long) mLastBoostDuration - 50L);
                if (mKeypressBoostBlocked && mLastBoostDuration != 0 && reBoostByDiff) {
                    // We have a few milliseconds remaining from our previous boost, release current boost before triggering next one.
                    mHandler.removeMessages(MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK);
                    mPerf_key.perfLockRelease();
                    mKeypressBoostBlocked = false;
                }
            }
            dispatchKeypressBoost(keyCode);
        }
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // If not requested by our custom policy, then check if the key is virtual.
    hapticFeedbackRequested |= (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0;
    boolean useHapticFeedback = down && hapticFeedbackRequested && repeatCount == 0 && // Trigger haptic feedback only for "real" events.
    source != InputDevice.SOURCE_CUSTOM;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeDownKeyTriggered = true;
                        mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                        mScreenshotChordVolumeDownKeyConsumed = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mScreenshotChordVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeUpKeyTriggered = true;
                        cancelPendingPowerKeyAction();
                        cancelPendingScreenshotChordAction();
                    }
                } else {
                    mScreenshotChordVolumeUpKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            }
            if (down) {
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null) {
                    if (telecomManager.isRinging()) {
                        // If an incoming call is ringing, either VOLUME key means
                        // "silence ringer".  We handle these keys here, rather than
                        // in the InCallScreen, to make sure we'll respond to them
                        // even if the InCallScreen hasn't come to the foreground yet.
                        // Look for the DOWN event here, to agree with the "fallback"
                        // behavior in the InCallScreen.
                        Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                        // Silence the ringer.  (It's safe to call this
                        // even if the ringer has already been silenced.)
                        telecomManager.silenceRinger();
                        // And *don't* pass this key thru to the current activity
                        // (which is probably the InCallScreen.)
                        result &= ~ACTION_PASS_TO_USER;
                        break;
                    }
                    if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                        break;
                    }
                }
            }
            if ((result & ACTION_PASS_TO_USER) == 0) {
                boolean mayChangeVolume = false;
                if (isMusicActive()) {
                    if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        // Detect long key presses.
                        if (down) {
                            mVolBtnLongPress = false;
                            int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                            scheduleLongPressKeyEvent(event, newKeyCode);
                            // Consume key down events of all presses.
                            break;
                        } else {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            // Consume key up events of long presses only.
                            if (mVolBtnLongPress) {
                                break;
                            }
                            // Change volume only on key up events of short presses.
                            mayChangeVolume = true;
                        }
                    } else {
                        // Long key press detection not applicable, change volume only
                        // on key down events
                        mayChangeVolume = down;
                    }
                }
                if (mayChangeVolume) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to figure
                    // out.
                    // Rewrite the event to use key-down as sendVolumeKeyEvent will
                    // only change the volume on key down.
                    KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                }
                break;
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    // Request haptic feedback for hw keys finger down events.
    boolean hapticFeedbackRequested = false;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeQueueing(): event =" + event.toString() + ", interactive =" + interactive + ", keyguardActive =" + keyguardActive + ", policyFlags =" + Integer.toHexString(policyFlags) + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", canApplyCustomPolicy = " + canApplyCustomPolicy(keyCode));
    }
    // Apply custom policy for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if (mNavBarEnabled && !navBarKey) /* TODO> && !isADBVirtualKeyOrAnyOtherKeyThatWeNeedToHandleAKAWhenMonkeyTestOrWHATEVER! */
        {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: mNavBarEnabled, discard hw event.");
            }
            // Don't allow key events from hw keys when navbar is enabled.
            return 0;
        } else if (!interactive) {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: screen not interactive, discard hw event.");
            }
            // Ensure nav keys are handled on full interactive screen only.
            return 0;
        } else if (interactive) {
            if (!down) {
                // Make sure we consume hw key events properly. Discard them
                // here if the event is already been consumed. This case can
                // happen when we send virtual key events and the virtual
                // ACTION_UP is sent before the hw ACTION_UP resulting in
                // handling twice an action up event.
                final boolean consumed = isKeyConsumed(keyCode);
                if (consumed) {
                    if (DEBUG_INPUT) {
                        Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: event already consumed, discard hw event.");
                    }
                    setKeyConsumed(keyCode, !consumed);
                    return 0;
                }
            } else {
                hapticFeedbackRequested = true;
            }
        }
    }
    // Intercept the Keypress event for Keypress boost
    if (lIsPerfBoostEnabled && !isCustomSource) {
        if (down && !longPress && repeatCount == 0 || down && longPress && repeatCount == 1) {
            final long boostEventTime = mBoostEventTime;
            mBoostEventTime = SystemClock.uptimeMillis();
            if (boostEventTime != 0L) {
                // we had a previous boost
                final long boostEventTimeDiff = mBoostEventTime - boostEventTime;
                final boolean reBoostByDiff = boostEventTimeDiff >= ((long) mLastBoostDuration - 150L) && boostEventTimeDiff <= ((long) mLastBoostDuration - 50L);
                if (mKeypressBoostBlocked && mLastBoostDuration != 0 && reBoostByDiff) {
                    // We have a few milliseconds remaining from our previous boost, release current boost before triggering next one.
                    mHandler.removeMessages(MSG_DISPATCH_KEYPRESS_BOOST_UNBLOCK);
                    mPerfKey.perfLockRelease();
                    mKeypressBoostBlocked = false;
                }
            }
            dispatchKeypressBoost(keyCode);
        }
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // If not requested by our custom policy, then check if the key is virtual.
    hapticFeedbackRequested |= (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0;
    boolean useHapticFeedback = down && hapticFeedbackRequested && repeatCount == 0 && // Trigger haptic feedback only for "real" events.
    source != InputDevice.SOURCE_CUSTOM;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeDownKeyTriggered = true;
                        mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                        mScreenshotChordVolumeDownKeyConsumed = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mScreenshotChordVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeUpKeyTriggered = true;
                        cancelPendingPowerKeyAction();
                        cancelPendingScreenshotChordAction();
                    }
                } else {
                    mScreenshotChordVolumeUpKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            }
            if (down) {
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null) {
                    if (telecomManager.isRinging()) {
                        // If an incoming call is ringing, either VOLUME key means
                        // "silence ringer".  We handle these keys here, rather than
                        // in the InCallScreen, to make sure we'll respond to them
                        // even if the InCallScreen hasn't come to the foreground yet.
                        // Look for the DOWN event here, to agree with the "fallback"
                        // behavior in the InCallScreen.
                        Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                        // Silence the ringer.  (It's safe to call this
                        // even if the ringer has already been silenced.)
                        telecomManager.silenceRinger();
                        // And *don't* pass this key thru to the current activity
                        // (which is probably the InCallScreen.)
                        result &= ~ACTION_PASS_TO_USER;
                        break;
                    }
                    if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                        break;
                    }
                }
            }
            if ((result & ACTION_PASS_TO_USER) == 0) {
                boolean mayChangeVolume = false;
                if (isMusicActive()) {
                    if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        // Detect long key presses.
                        if (down) {
                            mVolBtnLongPress = false;
                            int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                            scheduleLongPressKeyEvent(event, newKeyCode);
                            // Consume key down events of all presses.
                            break;
                        } else {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            // Consume key up events of long presses only.
                            if (mVolBtnLongPress) {
                                break;
                            }
                            // Change volume only on key up events of short presses.
                            mayChangeVolume = true;
                        }
                    } else {
                        // Long key press detection not applicable, change volume only
                        // on key down events
                        mayChangeVolume = down;
                    }
                }
                if (mayChangeVolume) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to figure
                    // out.
                    // Rewrite the event to use key-down as sendVolumeKeyEvent will
                    // only change the volume on key down.
                    KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                }
                break;
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#end_block

#method_before
private void triggerVirtualKeypress(final int keyCode, final boolean repeat) {
    final InputManager im = InputManager.getInstance();
    final Runnable r = new Runnable() {

        @Override
        public void run() {
            long now = SystemClock.uptimeMillis();
            final KeyEvent downEvent = new KeyEvent(now, now, KeyEvent.ACTION_DOWN, keyCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_CUSTOM);
            final KeyEvent upEvent = KeyEvent.changeAction(downEvent, KeyEvent.ACTION_UP);
            im.injectInputEvent(downEvent, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
            im.injectInputEvent(upEvent, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
        }
    };
    mHandler.post(r);
    if (repeat) {
        mHandler.postDelayed(r, 75);
    }
}
#method_after
private void triggerVirtualKeypress(final int keyCode, final boolean repeat) {
    final InputManager im = InputManager.getInstance();
    final Runnable r = new Runnable() {

        @Override
        public void run() {
            long now = SystemClock.uptimeMillis();
            final KeyEvent downEvent = new KeyEvent(now, now, KeyEvent.ACTION_DOWN, keyCode, 0, 0, KeyCharacterMap.VIRTUAL_KEYBOARD, 0, KeyEvent.FLAG_FROM_SYSTEM, InputDevice.SOURCE_CUSTOM);
            final KeyEvent upEvent = KeyEvent.changeAction(downEvent, KeyEvent.ACTION_UP);
            im.injectInputEvent(downEvent, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
            im.injectInputEvent(upEvent, InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
        }
    };
    mHandler.post(r);
    if (repeat) {
        mHandler.postDelayed(r, 125);
    }
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    // Custom input policy settings.
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        mKeyPressed.put(keyCode, false);
        mKeyConsumed.put(keyCode, false);
        mKeyDoubleTapPending.put(keyCode, false);
        mKeyDoubleTapRunnable.put(keyCode, createDoubleTapTimeoutRunnable(keyCode));
        mKeyDoubleTapBehaviorDefaultResId.put(keyCode, getKeyDoubleTapBehaviorResId(keyCode));
        mKeyLongPressBehaviorDefaultResId.put(keyCode, getKeyLongPressBehaviorResId(keyCode));
    }
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    // Initialise Keypress Boost
    lIsPerfBoostEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableKeypressBoost);
    mBoostParamValWeak = context.getResources().getIntArray(com.android.internal.R.array.keypressboost_weak_param_value);
    mBoostParamValStrong = context.getResources().getIntArray(com.android.internal.R.array.keypressboost_strong_param_value);
    if (lIsPerfBoostEnabled) {
        mPerf = new BoostFramework();
    }
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    // Custom input policy settings.
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        mKeyPressed.put(keyCode, false);
        mKeyConsumed.put(keyCode, false);
        mKeyDoubleTapPending.put(keyCode, false);
        mKeyDoubleTapRunnable.put(keyCode, createDoubleTapTimeoutRunnable(keyCode));
        mKeyDoubleTapBehaviorDefaultResId.put(keyCode, getKeyDoubleTapBehaviorResId(keyCode));
        mKeyLongPressBehaviorDefaultResId.put(keyCode, getKeyLongPressBehaviorResId(keyCode));
    }
}
#end_block

#method_before
private void readConfigurationDependentBehaviors() {
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    mLongPressOnHomeBehavior = res.getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
    if (mLongPressOnHomeBehavior < LONG_PRESS_HOME_NOTHING || mLongPressOnHomeBehavior > LAST_LONG_PRESS_HOME_BEHAVIOR) {
        mLongPressOnHomeBehavior = LONG_PRESS_HOME_NOTHING;
    }
    mDoubleTapOnHomeBehavior = res.getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
    if (mDoubleTapOnHomeBehavior < DOUBLE_TAP_HOME_NOTHING || mDoubleTapOnHomeBehavior > DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        mDoubleTapOnHomeBehavior = LONG_PRESS_HOME_NOTHING;
    }
    mShortPressWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
    // Read custom policy settings.
    final boolean hasHome = mNavBarEnabled || (mDeviceHardwareKeys & KEY_MASK_HOME) != 0;
    final boolean hasAppSwitch = mNavBarEnabled || (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final boolean hasBack = mNavBarEnabled || (mDeviceHardwareKeys & KEY_MASK_BACK) != 0;
    final boolean hasMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasCamera = (mDeviceHardwareKeys & KEY_MASK_CAMERA) != 0;
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        int behavior;
        // long press
        behavior = res.getInteger(getKeyLongPressBehaviorResId(keyCode));
        if (behavior < KEY_ACTION_NOTHING || behavior > KEY_ACTION_SPLIT_SCREEN) {
            behavior = KEY_ACTION_NOTHING;
        }
        mKeyLongPressBehavior.put(keyCode, behavior);
        // double tap
        behavior = res.getInteger(getKeyDoubleTapBehaviorResId(keyCode));
        if (behavior < KEY_ACTION_NOTHING || behavior > KEY_ACTION_SPLIT_SCREEN) {
            behavior = KEY_ACTION_NOTHING;
        }
        mKeyDoubleTapBehavior.put(keyCode, behavior);
    }
    if (hasHome) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_HOME, Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_HOME), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_HOME, Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_HOME), UserHandle.USER_CURRENT));
    }
    if (hasMenu) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_MENU, Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_MENU), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_MENU, Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_MENU), UserHandle.USER_CURRENT));
    }
    if (hasBack) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_BACK, Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_BACK), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_BACK, Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_BACK), UserHandle.USER_CURRENT));
    }
    if (hasAssist) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_ASSIST, Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_ASSIST), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_ASSIST, Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_ASSIST), UserHandle.USER_CURRENT));
    }
    if (hasAppSwitch) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_APP_SWITCH, Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_APP_SWITCH), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_APP_SWITCH, Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_APP_SWITCH), UserHandle.USER_CURRENT));
    }
    if (hasCamera) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_CAMERA, Settings.System.getIntForUser(resolver, Settings.System.KEY_CAMERA_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_CAMERA), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_CAMERA, Settings.System.getIntForUser(resolver, Settings.System.KEY_CAMERA_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_CAMERA), UserHandle.USER_CURRENT));
    }
}
#method_after
private void readConfigurationDependentBehaviors() {
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    mLongPressOnHomeBehavior = res.getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
    if (mLongPressOnHomeBehavior < LONG_PRESS_HOME_NOTHING || mLongPressOnHomeBehavior > LAST_LONG_PRESS_HOME_BEHAVIOR) {
        mLongPressOnHomeBehavior = LONG_PRESS_HOME_NOTHING;
    }
    mDoubleTapOnHomeBehavior = res.getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
    if (mDoubleTapOnHomeBehavior < DOUBLE_TAP_HOME_NOTHING || mDoubleTapOnHomeBehavior > DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        mDoubleTapOnHomeBehavior = LONG_PRESS_HOME_NOTHING;
    }
    mShortPressWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
    // Read custom policy settings.
    final boolean hasHome = mNavBarEnabled || (mDeviceHardwareKeys & KEY_MASK_HOME) != 0;
    final boolean hasAppSwitch = mNavBarEnabled || (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final boolean hasBack = mNavBarEnabled || (mDeviceHardwareKeys & KEY_MASK_BACK) != 0;
    final boolean hasMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasCamera = (mDeviceHardwareKeys & KEY_MASK_CAMERA) != 0;
    for (int i = 0; i < SUPPORTED_KEYCODE_LIST.length; i++) {
        final int keyCode = SUPPORTED_KEYCODE_LIST[i];
        int behavior;
        // long press
        behavior = res.getInteger(getKeyLongPressBehaviorResId(keyCode));
        if (behavior < KEY_ACTION_NOTHING || behavior > SUPPORTED_KEY_ACTIONS.length) {
            behavior = KEY_ACTION_NOTHING;
        }
        mKeyLongPressBehavior.put(keyCode, behavior);
        // double tap
        behavior = res.getInteger(getKeyDoubleTapBehaviorResId(keyCode));
        if (behavior < KEY_ACTION_NOTHING || behavior > SUPPORTED_KEY_ACTIONS.length) {
            behavior = KEY_ACTION_NOTHING;
        }
        mKeyDoubleTapBehavior.put(keyCode, behavior);
    }
    if (hasHome) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_HOME, Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_HOME), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_HOME, Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_HOME), UserHandle.USER_CURRENT));
    }
    if (hasMenu) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_MENU, Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_MENU), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_MENU, Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_MENU), UserHandle.USER_CURRENT));
    }
    if (hasBack) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_BACK, Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_BACK), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_BACK, Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_BACK), UserHandle.USER_CURRENT));
    }
    if (hasAssist) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_ASSIST, Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_ASSIST), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_ASSIST, Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_ASSIST), UserHandle.USER_CURRENT));
    }
    if (hasAppSwitch) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_APP_SWITCH, Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_APP_SWITCH), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_APP_SWITCH, Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_APP_SWITCH), UserHandle.USER_CURRENT));
    }
    if (hasCamera) {
        mKeyLongPressBehavior.put(KeyEvent.KEYCODE_CAMERA, Settings.System.getIntForUser(resolver, Settings.System.KEY_CAMERA_LONG_PRESS_ACTION, mKeyLongPressBehavior.get(KeyEvent.KEYCODE_CAMERA), UserHandle.USER_CURRENT));
        mKeyDoubleTapBehavior.put(KeyEvent.KEYCODE_CAMERA, Settings.System.getIntForUser(resolver, Settings.System.KEY_CAMERA_DOUBLE_TAP_ACTION, mKeyDoubleTapBehavior.get(KeyEvent.KEYCODE_CAMERA), UserHandle.USER_CURRENT));
    }
}
#end_block

#method_before
private void runBehaviorAction(int keyCode, int behavior) {
    switch(behavior) {
        case KEY_ACTION_NOTHING:
            break;
        case KEY_ACTION_HOME:
            launchHomeFromHotKey();
            break;
        case KEY_ACTION_BACK:
        case KEY_ACTION_MENU:
        case KEY_ACTION_IN_APP_SEARCH:
            triggerVirtualKeypress(keyCode, false);
            break;
        case KEY_ACTION_APP_SWITCH:
            toggleRecentApps();
            break;
        case KEY_ACTION_SEARCH:
            launchAssistAction(null, -1);
            break;
        case KEY_ACTION_VOICE_SEARCH:
            launchAssistLongPressAction(false, false);
            break;
        case KEY_ACTION_CAMERA:
            launchCamera();
            break;
        case KEY_ACTION_LAST_APP:
            awakenDreams();
            triggerVirtualKeypress(KeyEvent.KEYCODE_APP_SWITCH, !mRecentsVisible);
            break;
        case KEY_ACTION_SPLIT_SCREEN:
            toggleSplitScreen();
            break;
    }
}
#method_after
private void runBehaviorAction(int keyCode, int behavior) {
    switch(behavior) {
        case KEY_ACTION_NOTHING:
            break;
        case KEY_ACTION_HOME:
            launchHomeFromHotKey();
            break;
        case KEY_ACTION_BACK:
        case KEY_ACTION_MENU:
        case KEY_ACTION_IN_APP_SEARCH:
            triggerVirtualKeypress(keyCode, false);
            break;
        case KEY_ACTION_APP_SWITCH:
            toggleRecentApps();
            break;
        case KEY_ACTION_SEARCH:
            launchAssistAction(null, -1);
            break;
        case KEY_ACTION_VOICE_SEARCH:
            launchAssistLongPressAction(false, false);
            break;
        case KEY_ACTION_CAMERA:
            launchCamera();
            break;
        case KEY_ACTION_LAST_APP:
            awakenDreams();
            // TODO> handle no recent apps
            triggerVirtualKeypress(KeyEvent.KEYCODE_APP_SWITCH, !mRecentsVisible);
            break;
        case KEY_ACTION_SPLIT_SCREEN:
            toggleSplitScreen();
            break;
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int metaState = event.getMetaState();
    final int repeatCount = event.getRepeatCount();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean appSwitchKey = keyCode == KeyEvent.KEYCODE_APP_SWITCH;
    final boolean homeKey = keyCode == KeyEvent.KEYCODE_HOME;
    final boolean menuKey = keyCode == KeyEvent.KEYCODE_MENU;
    final boolean keyguardOn = keyguardOn();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeDispatching(): event = " + event.toString() + ", keyguardOn = " + keyguardOn + ", canceled = " + canceled + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", longPress = " + longPress);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // Custom event handling for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if ((menuKey || appSwitchKey) && keyguardOn) {
            // Don't handle the key.
            return -1;
        }
        final Runnable doubleTapRunnable = getDoubleTapTimeoutRunnable(keyCode);
        // We have released the keyCode's key, decide what and if run our key's action.
        if (!down) {
            cancelPreloadRecentApps();
            setKeyPressed(keyCode, false);
            if (isKeyConsumed(keyCode)) {
                setKeyConsumed(keyCode, false);
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring; " + "keyCode: " + keyCode + ", event canceled.");
                return -1;
            }
            if (homeKey) {
                // If an incoming call is ringing, HOME is totally disabled.
                // (The user is already on the InCallUI at this point,
                // and his ONLY options are to answer or reject the call.)
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null && telecomManager.isRinging()) {
                    Log.i(TAG, "Ignoring; " + "keyCode: " + keyCode + "there's a ringing incoming call.");
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            final int doubleTapBehavior = getKeyDoubleTapBehavior(keyCode);
            if (doubleTapBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(doubleTapRunnable);
                setKeyDoubleTapPending(keyCode, true);
                mHandler.postDelayed(doubleTapRunnable, ViewConfiguration.getDoubleTapTimeout() / 2);
                return -1;
            }
            handleShortPressOnKeyCode(keyCode);
            return -1;
        }
        if (homeKey) {
            // If a system window has focus, then it doesn't make sense
            // right now to interact with applications.
            WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
            if (attrs != null) {
                final int type = attrs.type;
                if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                    // the "app" is keyguard, so give it the key
                    return 0;
                }
                final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
                for (int i = 0; i < typeCount; i++) {
                    if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                        // don't do anything, but also don't pass it to the app
                        return -1;
                    }
                }
            }
        }
        // Remember that keyCode's key is pressed and handle special actions.
        if (repeatCount == 0) {
            setKeyPressed(keyCode, true);
            setKeyConsumed(keyCode, false);
            final boolean doubleTapPending = isKeyDoubleTapPending(keyCode);
            final int longPressBehavior = getKeyLongPressBehavior(keyCode);
            final int doubleTapBehavior = getKeyDoubleTapBehavior(keyCode);
            if (doubleTapPending) {
                setKeyDoubleTapPending(keyCode, false);
                mHandler.removeCallbacks(doubleTapRunnable);
                setKeyConsumed(keyCode, true);
                if (!keyguardOn) {
                    handleDoubleTapOnKeyCode(keyCode);
                }
            } else {
                if (keyCode == KeyEvent.KEYCODE_APP_SWITCH || longPressBehavior == KEY_ACTION_APP_SWITCH || doubleTapBehavior == KEY_ACTION_APP_SWITCH) {
                    preloadRecentApps();
                }
            }
        } else if (longPress) {
            if (DEBUG_INPUT) {
                Log.i(TAG, "longPress happened! " + ", keyguardOn=" + keyguardOn);
            }
            setKeyConsumed(keyCode, true);
            if (!keyguardOn) {
                handleLongPressOnKeyCode(keyCode);
            }
        }
        return -1;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int metaState = event.getMetaState();
    final int repeatCount = event.getRepeatCount();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean appSwitchKey = keyCode == KeyEvent.KEYCODE_APP_SWITCH;
    final boolean homeKey = keyCode == KeyEvent.KEYCODE_HOME;
    final boolean menuKey = keyCode == KeyEvent.KEYCODE_MENU;
    final boolean keyguardOn = keyguardOn();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeDispatching(): event = " + event.toString() + ", keyguardOn = " + keyguardOn + ", canceled = " + canceled + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", longPress = " + longPress);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // Custom event handling for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if ((menuKey || appSwitchKey) && keyguardOn) {
            // Don't handle the key.
            return -1;
        }
        final Runnable doubleTapRunnable = getDoubleTapTimeoutRunnable(keyCode);
        // We have released the keyCode's key, decide what and if run our key's action.
        if (!down) {
            cancelPreloadRecentApps();
            setKeyPressed(keyCode, false);
            if (isKeyConsumed(keyCode)) {
                setKeyConsumed(keyCode, false);
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring; " + "keyCode: " + keyCode + ", event canceled.");
                return -1;
            }
            if (homeKey) {
                // If an incoming call is ringing, HOME is totally disabled.
                // (The user is already on the InCallUI at this point,
                // and his ONLY options are to answer or reject the call.)
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null && telecomManager.isRinging()) {
                    Log.i(TAG, "Ignoring; " + "keyCode: " + keyCode + "there's a ringing incoming call.");
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            final int doubleTapBehavior = getKeyDoubleTapBehavior(keyCode);
            if (doubleTapBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(doubleTapRunnable);
                setKeyDoubleTapPending(keyCode, true);
                mHandler.postDelayed(doubleTapRunnable, ViewConfiguration.getDoubleTapTimeout() / 2);
                return -1;
            }
            handleShortPressOnKeyCode(keyCode);
            return -1;
        }
        if (homeKey) {
            // If a system window has focus, then it doesn't make sense
            // right now to interact with applications.
            WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
            if (attrs != null) {
                final int type = attrs.type;
                if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                    // the "app" is keyguard, so give it the key
                    return 0;
                }
                final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
                for (int i = 0; i < typeCount; i++) {
                    if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                        // don't do anything, but also don't pass it to the app
                        return -1;
                    }
                }
            }
        }
        // Remember that keyCode's key is pressed and handle special actions.
        if (repeatCount == 0) {
            setKeyPressed(keyCode, true);
            setKeyConsumed(keyCode, false);
            final boolean doubleTapPending = isKeyDoubleTapPending(keyCode);
            final int longPressBehavior = getKeyLongPressBehavior(keyCode);
            final int doubleTapBehavior = getKeyDoubleTapBehavior(keyCode);
            if (doubleTapPending) {
                setKeyDoubleTapPending(keyCode, false);
                mHandler.removeCallbacks(doubleTapRunnable);
                setKeyConsumed(keyCode, true);
                if (!keyguardOn) {
                    handleDoubleTapOnKeyCode(keyCode);
                }
            } else {
                if (keyCode == KeyEvent.KEYCODE_APP_SWITCH || longPressBehavior == KEY_ACTION_APP_SWITCH || doubleTapBehavior == KEY_ACTION_APP_SWITCH || longPressBehavior == KEY_ACTION_SPLIT_SCREEN || doubleTapBehavior == KEY_ACTION_SPLIT_SCREEN || longPressBehavior == KEY_ACTION_LAST_APP || doubleTapBehavior == KEY_ACTION_LAST_APP) {
                    preloadRecentApps();
                }
            }
        } else if (longPress) {
            if (DEBUG_INPUT) {
                Log.i(TAG, "longPress happened! " + ", keyguardOn=" + keyguardOn);
            }
            setKeyConsumed(keyCode, true);
            if (!keyguardOn) {
                handleLongPressOnKeyCode(keyCode);
            }
        }
        return -1;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    // Request haptic feedback for hw keys finger down events.
    boolean hapticFeedbackRequested = false;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeQueueing(): event =" + event.toString() + ", interactive =" + interactive + ", keyguardActive =" + keyguardActive + ", policyFlags =" + Integer.toHexString(policyFlags) + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", canApplyCustomPolicy = " + canApplyCustomPolicy(keyCode));
    }
    // Apply custom policy for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if (mNavBarEnabled && !navBarKey) /* TODO> && !isADBVirtualKeyOrAnyOtherKeyThatWeNeedToHandleAKAWhenMonkeyTestOrWHATEVER! */
        {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: mNavBarEnabled, discard hw event.");
            }
            // Don't allow key events from hw keys when navbar is enabled.
            return 0;
        } else if (!interactive) {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: screen not interactive, discard hw event.");
            }
            // Ensure nav keys are handled on full interactive screen only.
            return 0;
        } else if (interactive) {
            if (!down) {
                // Make sure we consume hw key events properly. Discard them
                // here if the event is already been consumed. This case can
                // happen when we send virtual key events and the virtual
                // ACTION_UP is sent before the hw ACTION_UP resulting in
                // handling twice an action up event.
                final boolean consumed = isKeyConsumed(keyCode);
                if (consumed) {
                    if (DEBUG_INPUT) {
                        Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: event already consumed, discard hw event.");
                    }
                    setKeyConsumed(keyCode, !consumed);
                    return 0;
                }
            } else {
                hapticFeedbackRequested = true;
            }
        }
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // If not requested by our custom policy, then check if the key is virtual.
    hapticFeedbackRequested |= (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0;
    boolean useHapticFeedback = down && hapticFeedbackRequested && event.getRepeatCount() == 0 && // Trigger haptic feedback only for "real" events.
    source != InputDevice.SOURCE_CUSTOM;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeDownKeyTriggered = true;
                        mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                        mScreenshotChordVolumeDownKeyConsumed = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mScreenshotChordVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeUpKeyTriggered = true;
                        cancelPendingPowerKeyAction();
                        cancelPendingScreenshotChordAction();
                    }
                } else {
                    mScreenshotChordVolumeUpKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            }
            if (down) {
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null) {
                    if (telecomManager.isRinging()) {
                        // If an incoming call is ringing, either VOLUME key means
                        // "silence ringer".  We handle these keys here, rather than
                        // in the InCallScreen, to make sure we'll respond to them
                        // even if the InCallScreen hasn't come to the foreground yet.
                        // Look for the DOWN event here, to agree with the "fallback"
                        // behavior in the InCallScreen.
                        Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                        // Silence the ringer.  (It's safe to call this
                        // even if the ringer has already been silenced.)
                        telecomManager.silenceRinger();
                        // And *don't* pass this key thru to the current activity
                        // (which is probably the InCallScreen.)
                        result &= ~ACTION_PASS_TO_USER;
                        break;
                    }
                    if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                        break;
                    }
                }
            }
            if ((result & ACTION_PASS_TO_USER) == 0) {
                boolean mayChangeVolume = false;
                if (isMusicActive()) {
                    if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        // Detect long key presses.
                        if (down) {
                            mVolBtnLongPress = false;
                            int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                            scheduleLongPressKeyEvent(event, newKeyCode);
                            // Consume key down events of all presses.
                            break;
                        } else {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            // Consume key up events of long presses only.
                            if (mVolBtnLongPress) {
                                break;
                            }
                            // Change volume only on key up events of short presses.
                            mayChangeVolume = true;
                        }
                    } else {
                        // Long key press detection not applicable, change volume only
                        // on key down events
                        mayChangeVolume = down;
                    }
                }
                if (mayChangeVolume) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to figure
                    // out.
                    // Rewrite the event to use key-down as sendVolumeKeyEvent will
                    // only change the volume on key down.
                    KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                }
                break;
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final int action = event.getAction();
    final int flags = event.getFlags();
    final int keyCode = event.getKeyCode();
    final int source = event.getSource();
    final boolean down = action == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean fromSystem = (flags & KeyEvent.FLAG_FROM_SYSTEM) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    final boolean virtualHardKey = (flags & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0;
    final boolean navBarKey = source == InputDevice.SOURCE_NAVIGATION_BAR;
    final boolean isCustomSource = source == InputDevice.SOURCE_CUSTOM;
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    // Request haptic feedback for hw keys finger down events.
    boolean hapticFeedbackRequested = false;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyBeforeQueueing(): event =" + event.toString() + ", interactive =" + interactive + ", keyguardActive =" + keyguardActive + ", policyFlags =" + Integer.toHexString(policyFlags) + ", virtualKey = " + virtualKey + ", virtualHardKey = " + virtualHardKey + ", navBarKey = " + navBarKey + ", fromSystem = " + fromSystem + ", canApplyCustomPolicy = " + canApplyCustomPolicy(keyCode));
    }
    // Apply custom policy for supported key codes.
    if (canApplyCustomPolicy(keyCode) && !isCustomSource) {
        if (mNavBarEnabled && !navBarKey) /* TODO> && !isADBVirtualKeyOrAnyOtherKeyThatWeNeedToHandleAKAWhenMonkeyTestOrWHATEVER! */
        {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: mNavBarEnabled, discard hw event.");
            }
            // Don't allow key events from hw keys when navbar is enabled.
            return 0;
        } else if (!interactive) {
            if (DEBUG_INPUT) {
                Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: screen not interactive, discard hw event.");
            }
            // Ensure nav keys are handled on full interactive screen only.
            return 0;
        } else if (interactive) {
            if (!down) {
                // Make sure we consume hw key events properly. Discard them
                // here if the event is already been consumed. This case can
                // happen when we send virtual key events and the virtual
                // ACTION_UP is sent before the hw ACTION_UP resulting in
                // handling twice an action up event.
                final boolean consumed = isKeyConsumed(keyCode);
                if (consumed) {
                    if (DEBUG_INPUT) {
                        Log.d(TAG, "interceptKeyBeforeQueueing(): key policy: event already consumed, discard hw event.");
                    }
                    setKeyConsumed(keyCode, !consumed);
                    return 0;
                }
            } else {
                hapticFeedbackRequested = true;
            }
        }
    }
    // Intercept the Keypress event for Keypress boost
    if (lIsPerfBoostEnabled) {
        dispatchKeypressBoost(keyCode);
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // If not requested by our custom policy, then check if the key is virtual.
    hapticFeedbackRequested |= (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0;
    boolean useHapticFeedback = down && hapticFeedbackRequested && event.getRepeatCount() == 0 && // Trigger haptic feedback only for "real" events.
    source != InputDevice.SOURCE_CUSTOM;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeDownKeyTriggered = true;
                        mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                        mScreenshotChordVolumeDownKeyConsumed = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mScreenshotChordVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeUpKeyTriggered = true;
                        cancelPendingPowerKeyAction();
                        cancelPendingScreenshotChordAction();
                    }
                } else {
                    mScreenshotChordVolumeUpKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            }
            if (down) {
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null) {
                    if (telecomManager.isRinging()) {
                        // If an incoming call is ringing, either VOLUME key means
                        // "silence ringer".  We handle these keys here, rather than
                        // in the InCallScreen, to make sure we'll respond to them
                        // even if the InCallScreen hasn't come to the foreground yet.
                        // Look for the DOWN event here, to agree with the "fallback"
                        // behavior in the InCallScreen.
                        Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                        // Silence the ringer.  (It's safe to call this
                        // even if the ringer has already been silenced.)
                        telecomManager.silenceRinger();
                        // And *don't* pass this key thru to the current activity
                        // (which is probably the InCallScreen.)
                        result &= ~ACTION_PASS_TO_USER;
                        break;
                    }
                    if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                        break;
                    }
                }
            }
            if ((result & ACTION_PASS_TO_USER) == 0) {
                boolean mayChangeVolume = false;
                if (isMusicActive()) {
                    if (mVolBtnMusicControls && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        // Detect long key presses.
                        if (down) {
                            mVolBtnLongPress = false;
                            int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                            scheduleLongPressKeyEvent(event, newKeyCode);
                            // Consume key down events of all presses.
                            break;
                        } else {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            // Consume key up events of long presses only.
                            if (mVolBtnLongPress) {
                                break;
                            }
                            // Change volume only on key up events of short presses.
                            mayChangeVolume = true;
                        }
                    } else {
                        // Long key press detection not applicable, change volume only
                        // on key down events
                        mayChangeVolume = down;
                    }
                }
                if (mayChangeVolume) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to figure
                    // out.
                    // Rewrite the event to use key-down as sendVolumeKeyEvent will
                    // only change the volume on key down.
                    KeyEvent newEvent = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(newEvent, true);
                }
                break;
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#end_block

#method_before
private int updateSystemUiVisibilityLw() {
    // If there is no window focused, there will be nobody to handle the events
    // anyway, so just hang on in whatever state we're in until things settle down.
    WindowState winCandidate = mFocusedWindow != null ? mFocusedWindow : mTopFullscreenOpaqueWindowState;
    if (winCandidate == null) {
        return 0;
    }
    if (winCandidate.getAttrs().token == mImmersiveModeConfirmation.getWindowToken()) {
        // The immersive mode confirmation should never affect the system bar visibility,
        // otherwise it will unhide the navigation bar and hide itself.
        winCandidate = isStatusBarKeyguard() ? mStatusBar : mTopFullscreenOpaqueWindowState;
        if (winCandidate == null) {
            return 0;
        }
    }
    final WindowState win = winCandidate;
    if ((win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0 && mHideLockScreen == true) {
        // will quickly lose focus once it correctly gets hidden.
        return 0;
    }
    int tmpVisibility = PolicyControl.getSystemUiVisibility(win, null) & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
    if (mForcingShowNavBar && win.getSurfaceLayer() < mForcingShowNavBarLayer) {
        tmpVisibility &= ~PolicyControl.adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
    }
    final int fullscreenVisibility = updateLightStatusBarLw(0, /* vis */
    mTopFullscreenOpaqueWindowState, mTopFullscreenOpaqueOrDimmingWindowState);
    final int dockedVisibility = updateLightStatusBarLw(0, /* vis */
    mTopDockedOpaqueWindowState, mTopDockedOpaqueOrDimmingWindowState);
    mWindowManagerFuncs.getStackBounds(HOME_STACK_ID, mNonDockedStackBounds);
    mWindowManagerFuncs.getStackBounds(DOCKED_STACK_ID, mDockedStackBounds);
    if ((mSystemDesignFlags & View.SYSTEM_DESIGN_FLAG_IMMERSIVE_NAV) != 0 && !mForcingShowNavBar) {
        // Enforce Immersive mode on the navigation bar.
        tmpVisibility |= View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
    }
    if ((mSystemDesignFlags & View.SYSTEM_DESIGN_FLAG_IMMERSIVE_STATUS) != 0) {
        // Enforce Immersive mode on the status bar.
        tmpVisibility |= View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_FULLSCREEN;
    }
    final int visibility = updateSystemBarsLw(win, mLastSystemUiFlags, tmpVisibility);
    final int diff = visibility ^ mLastSystemUiFlags;
    final int fullscreenDiff = fullscreenVisibility ^ mLastFullscreenStackSysUiFlags;
    final int dockedDiff = dockedVisibility ^ mLastDockedStackSysUiFlags;
    final boolean needsMenu = win.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
    if (diff == 0 && fullscreenDiff == 0 && dockedDiff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == win.getAppToken() && mLastNonDockedStackBounds.equals(mNonDockedStackBounds) && mLastDockedStackBounds.equals(mDockedStackBounds)) {
        return 0;
    }
    mLastSystemUiFlags = visibility;
    mLastFullscreenStackSysUiFlags = fullscreenVisibility;
    mLastDockedStackSysUiFlags = dockedVisibility;
    mLastFocusNeedsMenu = needsMenu;
    mFocusedApp = win.getAppToken();
    final Rect fullscreenStackBounds = new Rect(mNonDockedStackBounds);
    final Rect dockedStackBounds = new Rect(mDockedStackBounds);
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
            if (statusbar != null) {
                statusbar.setSystemUiVisibility(visibility, fullscreenVisibility, dockedVisibility, 0xffffffff, fullscreenStackBounds, dockedStackBounds, win.toString());
                statusbar.topAppWindowChanged(needsMenu);
            }
        }
    });
    return diff;
}
#method_after
private int updateSystemUiVisibilityLw() {
    // If there is no window focused, there will be nobody to handle the events
    // anyway, so just hang on in whatever state we're in until things settle down.
    WindowState winCandidate = mFocusedWindow != null ? mFocusedWindow : mTopFullscreenOpaqueWindowState;
    if (winCandidate == null) {
        return 0;
    }
    if (winCandidate.getAttrs().token == mImmersiveModeConfirmation.getWindowToken()) {
        // The immersive mode confirmation should never affect the system bar visibility,
        // otherwise it will unhide the navigation bar and hide itself.
        winCandidate = isStatusBarKeyguard() ? mStatusBar : mTopFullscreenOpaqueWindowState;
        if (winCandidate == null) {
            return 0;
        }
    }
    final WindowState win = winCandidate;
    if ((win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0 && mHideLockScreen == true) {
        // will quickly lose focus once it correctly gets hidden.
        return 0;
    }
    int tmpVisibility = PolicyControl.getSystemUiVisibility(win, null) & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
    if (mForcingShowNavBar && win.getSurfaceLayer() < mForcingShowNavBarLayer) {
        tmpVisibility &= ~PolicyControl.adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
    }
    final int fullscreenVisibility = updateLightStatusBarLw(0, /* vis */
    mTopFullscreenOpaqueWindowState, mTopFullscreenOpaqueOrDimmingWindowState);
    final int dockedVisibility = updateLightStatusBarLw(0, /* vis */
    mTopDockedOpaqueWindowState, mTopDockedOpaqueOrDimmingWindowState);
    mWindowManagerFuncs.getStackBounds(HOME_STACK_ID, mNonDockedStackBounds);
    mWindowManagerFuncs.getStackBounds(DOCKED_STACK_ID, mDockedStackBounds);
    final boolean topWindowWasKeyguard = mTopWindowIsKeyguard;
    mTopWindowIsKeyguard = (win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0;
    if ((mSystemDesignFlags & View.SYSTEM_DESIGN_FLAG_IMMERSIVE_NAV) != 0 && !mForcingShowNavBar) {
        // Enforce Immersive mode on the navigation bar.
        tmpVisibility |= View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
        if (topWindowWasKeyguard && !mTopWindowIsKeyguard) {
            mNavigationBarController.showTransient();
            tmpVisibility |= View.NAVIGATION_BAR_TRANSIENT;
        }
    }
    if ((mSystemDesignFlags & View.SYSTEM_DESIGN_FLAG_IMMERSIVE_STATUS) != 0) {
        // Enforce Immersive mode on the status bar.
        tmpVisibility |= View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_FULLSCREEN;
        if (topWindowWasKeyguard && !mTopWindowIsKeyguard) {
            mStatusBarController.showTransient();
            tmpVisibility |= View.STATUS_BAR_TRANSIENT;
        }
    }
    final int visibility = updateSystemBarsLw(win, mLastSystemUiFlags, tmpVisibility);
    final int diff = visibility ^ mLastSystemUiFlags;
    final int fullscreenDiff = fullscreenVisibility ^ mLastFullscreenStackSysUiFlags;
    final int dockedDiff = dockedVisibility ^ mLastDockedStackSysUiFlags;
    final boolean needsMenu = win.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
    if (diff == 0 && fullscreenDiff == 0 && dockedDiff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == win.getAppToken() && mLastNonDockedStackBounds.equals(mNonDockedStackBounds) && mLastDockedStackBounds.equals(mDockedStackBounds)) {
        return 0;
    }
    mLastSystemUiFlags = visibility;
    mLastFullscreenStackSysUiFlags = fullscreenVisibility;
    mLastDockedStackSysUiFlags = dockedVisibility;
    mLastFocusNeedsMenu = needsMenu;
    mFocusedApp = win.getAppToken();
    final Rect fullscreenStackBounds = new Rect(mNonDockedStackBounds);
    final Rect dockedStackBounds = new Rect(mDockedStackBounds);
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            StatusBarManagerInternal statusbar = getStatusBarManagerInternal();
            if (statusbar != null) {
                statusbar.setSystemUiVisibility(visibility, fullscreenVisibility, dockedVisibility, 0xffffffff, fullscreenStackBounds, dockedStackBounds, win.toString());
                statusbar.topAppWindowChanged(needsMenu);
            }
        }
    });
    return diff;
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    inflateStatusBarWindow(context);
    mStatusBarWindow.setService(this);
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanel.setGroupManager(mGroupManager);
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    mStatusBarView.setPanel(mNotificationPanel);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow, mGroupManager);
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mHeadsUpManager.addListener(mGroupManager);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setHeadsUpManager(mHeadsUpManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            createNavigationBarView(context);
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    mAssistManager = SystemUIFactory.getInstance().createAssistManager(this, context);
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    inflateOverflowContainer();
    inflateEmptyShadeView();
    inflateDismissView();
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindow.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    if (ENABLE_LOCKSCREEN_WALLPAPER) {
        mLockscreenWallpaper = new LockscreenWallpaper(mContext, this, mHandler);
    }
    ScrimView scrimBehind = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindow.findViewById(R.id.heads_up_scrim);
    mScrimController = SystemUIFactory.getInstance().createScrimController(scrimBehind, scrimInFront, headsUpScrim, mLockscreenWallpaper);
    if (mScrimSrcModeEnabled) {
        Runnable runnable = new Runnable() {

            @Override
            public void run() {
                boolean asSrc = mBackdrop.getVisibility() != View.VISIBLE;
                mScrimController.setDrawBehindAsSrc(asSrc);
                mStackScroller.setDrawBackgroundAsSrc(asSrc);
            }
        };
        mBackdrop.setOnVisibilityChangedRunnable(runnable);
        runnable.run();
    }
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindow.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindow.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindow.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the initial view visibility
    setAreThereNotifications();
    createIconController();
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    // Other icons
    mLocationController = new LocationControllerImpl(mContext, // will post a notification
    mHandlerThread.getLooper());
    mBatteryController = createBatteryController();
    mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

        @Override
        public void onPowerSaveChanged(boolean isPowerSave) {
            mHandler.post(mCheckBarModes);
            if (mDozeServiceHost != null) {
                mDozeServiceHost.firePowerSaveChanged(isPowerSave);
            }
        }

        @Override
        public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
        // noop
        }
    });
    mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    mNetworkController.setUserSetupComplete(mUserSetup);
    mHotspotController = new HotspotControllerImpl(mContext);
    mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    mSecurityController = new SecurityControllerImpl(mContext);
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        mRotationLockController = new RotationLockControllerImpl(mContext);
    }
    mUserInfoController = new UserInfoController(mContext);
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        mZenModeController = mVolumeComponent.getZenController();
    }
    mCastController = new CastControllerImpl(mContext);
    initSignalCluster(mStatusBarView);
    initSignalCluster(mKeyguardStatusBar);
    initEmergencyCryptkeeperText();
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    final boolean showCarrierLabel = mContext.getResources().getBoolean(R.bool.config_showCarrierLabel);
    mShowCarrierInPanel = showCarrierLabel && (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mShowCarrierInPanel ? View.VISIBLE : View.INVISIBLE);
    }
    // make sure carrier label is not covered by navigation bar
    if (mCarrierLabel != null && mNavigationBarView != null) {
        MarginLayoutParams mlp = (MarginLayoutParams) mCarrierLabel.getLayoutParams();
        if (mlp != null && mlp.bottomMargin < mNavigationBarView.mBarSize) {
            mlp.bottomMargin = mNavigationBarView.mBarSize;
            mCarrierLabel.setLayoutParams(mlp);
        }
    }
    mFlashlightController = new FlashlightController(mContext);
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    mAccessibilityController = new AccessibilityController(mContext);
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    mNextAlarmController = new NextAlarmController(mContext);
    mLightStatusBarController = new LightStatusBarController(mIconController, mBatteryController);
    mKeyguardMonitor = new KeyguardMonitor(mContext);
    mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler, this);
    if (UserManager.get(mContext).isUserSwitcherEnabled()) {
        createUserSwitcher();
    }
    // Set up the quick settings tile panel
    AutoReinflateContainer container = (AutoReinflateContainer) mStatusBarWindow.findViewById(R.id.qs_auto_reinflate_container);
    if (container != null) {
        final QSTileHost qsh = SystemUIFactory.getInstance().createQSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mUserInfoController, mKeyguardMonitor, mSecurityController, mBatteryController, mIconController, mNextAlarmController);
        mBrightnessMirrorController = new BrightnessMirrorController(mStatusBarWindow);
        container.addInflateListener(new InflateListener() {

            @Override
            public void onInflated(View v) {
                QSContainer qsContainer = (QSContainer) v.findViewById(R.id.quick_settings_container);
                qsContainer.setHost(qsh);
                mQSPanel = qsContainer.getQsPanel();
                mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
                mKeyguardStatusBar.setQSPanel(mQSPanel);
                mHeader = qsContainer.getHeader();
                initSignalCluster(mHeader);
                mHeader.setActivityStarter(PhoneStatusBar.this);
            }
        });
    }
    // User info. Trigger first load.
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    ((BatteryMeterView) mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
    ((BatteryLevelTextView) mStatusBarView.findViewById(R.id.battery_level)).setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mReportRejectedTouch = mStatusBarWindow.findViewById(R.id.report_rejected_touch);
    if (mReportRejectedTouch != null) {
        updateReportRejectedTouchVisibility();
        mReportRejectedTouch.setOnClickListener(v -> {
            Uri session = mFalsingManager.reportRejectedTouch();
            if (session == null) {
                return;
            }
            StringWriter message = new StringWriter();
            message.write("Build info: ");
            message.write(SystemProperties.get("ro.build.description"));
            message.write("\nSerial number: ");
            message.write(SystemProperties.get("ro.serialno"));
            message.write("\n");
            PrintWriter falsingPw = new PrintWriter(message);
            FalsingLog.dump(falsingPw);
            falsingPw.flush();
            startActivityDismissingKeyguard(Intent.createChooser(new Intent(Intent.ACTION_SEND).setType("*/*").putExtra(Intent.EXTRA_SUBJECT, "Rejected touch report").putExtra(Intent.EXTRA_STREAM, session).putExtra(Intent.EXTRA_TEXT, message.toString()), "Share rejected touch report").addFlags(Intent.FLAG_ACTIVITY_NEW_TASK), true, /* onlyProvisioned */
            true);
        });
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    showOperatorName();
    // listen for NAVIGATION_BAR_ENABLED setting (per-user)
    resetNavBarObserver();
    return mStatusBarView;
}
#method_after
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    inflateStatusBarWindow(context);
    mStatusBarWindow.setService(this);
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanel.setGroupManager(mGroupManager);
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    mStatusBarView.setPanel(mNotificationPanel);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow, mGroupManager);
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mHeadsUpManager.addListener(mGroupManager);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setHeadsUpManager(mHeadsUpManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    mBurnInProtectionController = new BurnInProtectionController(mContext, mStatusBarView);
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            createNavigationBarView(context);
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    mAssistManager = SystemUIFactory.getInstance().createAssistManager(this, context);
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    inflateOverflowContainer();
    inflateEmptyShadeView();
    inflateDismissView();
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindow.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    if (ENABLE_LOCKSCREEN_WALLPAPER) {
        mLockscreenWallpaper = new LockscreenWallpaper(mContext, this, mHandler);
    }
    ScrimView scrimBehind = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindow.findViewById(R.id.heads_up_scrim);
    mScrimController = SystemUIFactory.getInstance().createScrimController(scrimBehind, scrimInFront, headsUpScrim, mLockscreenWallpaper);
    if (mScrimSrcModeEnabled) {
        Runnable runnable = new Runnable() {

            @Override
            public void run() {
                boolean asSrc = mBackdrop.getVisibility() != View.VISIBLE;
                mScrimController.setDrawBehindAsSrc(asSrc);
                mStackScroller.setDrawBackgroundAsSrc(asSrc);
            }
        };
        mBackdrop.setOnVisibilityChangedRunnable(runnable);
        runnable.run();
    }
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindow.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindow.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindow.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the initial view visibility
    setAreThereNotifications();
    createIconController();
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    // Other icons
    mLocationController = new LocationControllerImpl(mContext, // will post a notification
    mHandlerThread.getLooper());
    mBatteryController = createBatteryController();
    mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

        @Override
        public void onPowerSaveChanged(boolean isPowerSave) {
            mHandler.post(mCheckBarModes);
            if (mDozeServiceHost != null) {
                mDozeServiceHost.firePowerSaveChanged(isPowerSave);
            }
        }

        @Override
        public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
        // noop
        }
    });
    mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    mNetworkController.setUserSetupComplete(mUserSetup);
    mHotspotController = new HotspotControllerImpl(mContext);
    mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    mSecurityController = new SecurityControllerImpl(mContext);
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        mRotationLockController = new RotationLockControllerImpl(mContext);
    }
    mUserInfoController = new UserInfoController(mContext);
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        mZenModeController = mVolumeComponent.getZenController();
    }
    mCastController = new CastControllerImpl(mContext);
    initSignalCluster(mStatusBarView);
    initSignalCluster(mKeyguardStatusBar);
    initEmergencyCryptkeeperText();
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    final boolean showCarrierLabel = mContext.getResources().getBoolean(R.bool.config_showCarrierLabel);
    mShowCarrierInPanel = showCarrierLabel && (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mShowCarrierInPanel ? View.VISIBLE : View.INVISIBLE);
    }
    // make sure carrier label is not covered by navigation bar
    if (mCarrierLabel != null && mNavigationBarView != null) {
        MarginLayoutParams mlp = (MarginLayoutParams) mCarrierLabel.getLayoutParams();
        if (mlp != null && mlp.bottomMargin < mNavigationBarView.mBarSize) {
            mlp.bottomMargin = mNavigationBarView.mBarSize;
            mCarrierLabel.setLayoutParams(mlp);
        }
    }
    mFlashlightController = new FlashlightController(mContext);
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    mAccessibilityController = new AccessibilityController(mContext);
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    mNextAlarmController = new NextAlarmController(mContext);
    mLightStatusBarController = new LightStatusBarController(mIconController, mBatteryController);
    mKeyguardMonitor = new KeyguardMonitor(mContext);
    mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler, this);
    if (UserManager.get(mContext).isUserSwitcherEnabled()) {
        createUserSwitcher();
    }
    // Set up the quick settings tile panel
    AutoReinflateContainer container = (AutoReinflateContainer) mStatusBarWindow.findViewById(R.id.qs_auto_reinflate_container);
    if (container != null) {
        final QSTileHost qsh = SystemUIFactory.getInstance().createQSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mUserInfoController, mKeyguardMonitor, mSecurityController, mBatteryController, mIconController, mNextAlarmController);
        mBrightnessMirrorController = new BrightnessMirrorController(mStatusBarWindow);
        container.addInflateListener(new InflateListener() {

            @Override
            public void onInflated(View v) {
                QSContainer qsContainer = (QSContainer) v.findViewById(R.id.quick_settings_container);
                qsContainer.setHost(qsh);
                mQSPanel = qsContainer.getQsPanel();
                mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
                mKeyguardStatusBar.setQSPanel(mQSPanel);
                mHeader = qsContainer.getHeader();
                initSignalCluster(mHeader);
                mHeader.setActivityStarter(PhoneStatusBar.this);
            }
        });
    }
    // User info. Trigger first load.
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    ((BatteryMeterView) mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
    ((BatteryLevelTextView) mStatusBarView.findViewById(R.id.battery_level)).setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mReportRejectedTouch = mStatusBarWindow.findViewById(R.id.report_rejected_touch);
    if (mReportRejectedTouch != null) {
        updateReportRejectedTouchVisibility();
        mReportRejectedTouch.setOnClickListener(v -> {
            Uri session = mFalsingManager.reportRejectedTouch();
            if (session == null) {
                return;
            }
            StringWriter message = new StringWriter();
            message.write("Build info: ");
            message.write(SystemProperties.get("ro.build.description"));
            message.write("\nSerial number: ");
            message.write(SystemProperties.get("ro.serialno"));
            message.write("\n");
            PrintWriter falsingPw = new PrintWriter(message);
            FalsingLog.dump(falsingPw);
            falsingPw.flush();
            startActivityDismissingKeyguard(Intent.createChooser(new Intent(Intent.ACTION_SEND).setType("*/*").putExtra(Intent.EXTRA_SUBJECT, "Rejected touch report").putExtra(Intent.EXTRA_STREAM, session).putExtra(Intent.EXTRA_TEXT, message.toString()), "Share rejected touch report").addFlags(Intent.FLAG_ACTIVITY_NEW_TASK), true, /* onlyProvisioned */
            true);
        });
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    showOperatorName();
    // listen for NAVIGATION_BAR_ENABLED setting (per-user)
    resetNavBarObserver();
    return mStatusBarView;
}
#end_block

#method_before
private void setNavBarEnabled(boolean enabled) {
    if (enabled) {
        addNavigationBar();
        if (RESET_SYSTEMUI_VISIBILITY_FOR_NAVBAR) {
            resetSystemUIVisibility();
        }
    } else {
        removeNavigationBar();
    }
}
#method_after
private void setNavBarEnabled(boolean enabled) {
    if (enabled) {
        addNavigationBar();
        if (RESET_SYSTEMUI_VISIBILITY_FOR_NAVBAR) {
            resetSystemUIVisibility();
        }
    } else {
        removeNavigationBar();
    }
    mBurnInProtectionController.setNavigationBarView(enabled ? mNavigationBarView : null);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel((String) m.obj);
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
public void onFinishedGoingToSleep() {
    mNotificationPanel.onAffordanceLaunchEnded();
    releaseGestureWakeLock();
    mLaunchCameraOnScreenTurningOn = false;
    mStartedGoingToSleep = false;
    mDeviceInteractive = false;
    mWakeUpComingFromTouch = false;
    mWakeUpTouchLocation = null;
    mStackScroller.setAnimationsEnabled(false);
    updateVisibleToUser();
    if (mStatusBarView != null && mStatusBarView.shouldEnableSwift()) {
        mStatusBarView.clearSwiftHandlerCallbacks();
    }
    if (mLaunchCameraOnFinishedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = false;
        // This gets executed before we will show Keyguard, so post it in order that the state
        // is correct.
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                onCameraLaunchGestureDetected(mLastCameraLaunchSource);
            }
        });
    }
}
#method_after
public void onFinishedGoingToSleep() {
    mNotificationPanel.onAffordanceLaunchEnded();
    releaseGestureWakeLock();
    mLaunchCameraOnScreenTurningOn = false;
    mStartedGoingToSleep = false;
    mDeviceInteractive = false;
    mWakeUpComingFromTouch = false;
    mWakeUpTouchLocation = null;
    mStackScroller.setAnimationsEnabled(false);
    updateVisibleToUser();
    if (mBurnInProtectionController != null) {
        mBurnInProtectionController.stopSwiftTimer();
    }
    if (mLaunchCameraOnFinishedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = false;
        // This gets executed before we will show Keyguard, so post it in order that the state
        // is correct.
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                onCameraLaunchGestureDetected(mLastCameraLaunchSource);
            }
        });
    }
}
#end_block

#method_before
public void onStartedWakingUp() {
    mDeviceInteractive = true;
    mStackScroller.setAnimationsEnabled(true);
    mNotificationPanel.setTouchDisabled(false);
    updateVisibleToUser();
    if (mStatusBarView != null && mStatusBarView.shouldEnableSwift()) {
        mStatusBarView.initSwiftHandlerCallbacks();
    }
}
#method_after
public void onStartedWakingUp() {
    mDeviceInteractive = true;
    mStackScroller.setAnimationsEnabled(true);
    mNotificationPanel.setTouchDisabled(false);
    updateVisibleToUser();
    if (mBurnInProtectionController != null) {
        mBurnInProtectionController.startSwiftTimer();
    }
}
#end_block

#method_before
public void swiftStatusBarItems() {
    if (mStatusBarContents == null) {
        return;
    }
    mHorizontalShift += mHorizontalDirection;
    if ((mHorizontalShift >= mHorizontalMaxShift) || (mHorizontalShift <= -mHorizontalMaxShift)) {
        mHorizontalDirection *= -1;
    }
    mVerticalShift += mVerticalDirection;
    if ((mVerticalShift >= mVerticalMaxShift) || (mVerticalShift <= -mVerticalMaxShift)) {
        mVerticalDirection *= -1;
    }
    mStatusBarContents.setPaddingRelative(mBasePaddingLeft + mHorizontalShift, mBasePaddingTop + mVerticalShift, mBasePaddingRight + mHorizontalShift, mBasePaddingBottom - mVerticalShift);
    invalidate();
}
#method_after
public void swiftStatusBarItems(int horizontalShift, int verticalShift) {
    if (mStatusBarContents == null) {
        return;
    }
    mStatusBarContents.setPaddingRelative(mBasePaddingLeft + horizontalShift, mBasePaddingTop + verticalShift, mBasePaddingRight + horizontalShift, mBasePaddingBottom - verticalShift);
    invalidate();
}
#end_block

#method_before
@Override
public void onFinishInflate() {
    mBarTransitions.init();
    mSwiftEnabled = SystemProperties.getBoolean("ro.systemui.burn_in_protection", false);
    mStatusBarContents = ((ViewGroup) findViewById(R.id.status_bar_contents));
    mBasePaddingLeft = mStatusBarContents.getPaddingStart();
    mBasePaddingTop = mStatusBarContents.getPaddingTop();
    mBasePaddingRight = mStatusBarContents.getPaddingEnd();
    mBasePaddingBottom = mStatusBarContents.getPaddingBottom();
    mHorizontalMaxShift = getContext().getResources().getDimensionPixelSize(R.dimen.horizontal_max_swift);
    // total of ((vertical_max_swift - 1) * 2) pixels can be moved
    mVerticalMaxShift = getContext().getResources().getDimensionPixelSize(R.dimen.vertical_max_swift) - 1;
}
#method_after
@Override
public void onFinishInflate() {
    mBarTransitions.init();
    mStatusBarContents = (ViewGroup) findViewById(R.id.status_bar_contents);
    mBasePaddingLeft = mStatusBarContents.getPaddingStart();
    mBasePaddingTop = mStatusBarContents.getPaddingTop();
    mBasePaddingRight = mStatusBarContents.getPaddingEnd();
    mBasePaddingBottom = mStatusBarContents.getPaddingBottom();
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.System.USE_EDGE_SERVICE_FOR_GESTURES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_DESIGN_FLAGS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.PIE_STATE), false, this, UserHandle.USER_ALL);
    /*
            resolver.registerContentObserver(Settings.System.getUriFor(
                    Settings.System.VOLBTN_MUSIC_CONTROLS), false, this,
                    UserHandle.USER_ALL);
            */
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.System.USE_EDGE_SERVICE_FOR_GESTURES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SYSTEM_DESIGN_FLAGS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLBTN_MUSIC_CONTROLS), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
private void updateEdgeGestureListenerState() {
    int flags = 0;
    if (mUsingEdgeGestureServiceForGestures) {
        flags = EdgeServiceConstants.LONG_LIVING | EdgeServiceConstants.UNRESTRICTED;
        if (mStatusBar != null && !mStatusBar.isVisibleLw()) {
            flags |= EdgeGesturePosition.TOP.FLAG;
        }
        if (mNavigationBar != null && !mNavigationBar.isVisibleLw() && !immersiveModeImplementsPie() && !isStatusBarKeyguard()) {
            if (mNavigationBarOnBottom) {
                flags |= EdgeGesturePosition.BOTTOM.FLAG;
            } else {
                flags |= EdgeGesturePosition.RIGHT.FLAG;
            }
        }
    }
    if (mEdgeListenerActivated) {
        mEdgeGestureActivationListener.restoreListenerState();
        mEdgeListenerActivated = false;
    }
    if (flags != mLastEdgePositions) {
        mEdgeGestureManager.updateEdgeGestureActivationListener(mEdgeGestureActivationListener, flags);
        mLastEdgePositions = flags;
    }
}
#method_after
private void updateEdgeGestureListenerState() {
    int flags = 0;
    if (mUsingEdgeGestureServiceForGestures) {
        flags = EdgeServiceConstants.LONG_LIVING | EdgeServiceConstants.UNRESTRICTED;
        if (mStatusBar != null && !mStatusBar.isVisibleLw()) {
            flags |= EdgeGesturePosition.TOP.FLAG;
        }
        if (mNavigationBar != null && !mNavigationBar.isVisibleLw()) {
            if (mNavigationBarOnBottom) {
                flags |= EdgeGesturePosition.BOTTOM.FLAG;
            } else {
                flags |= EdgeGesturePosition.RIGHT.FLAG;
            }
        }
    }
    if (mEdgeListenerActivated) {
        mEdgeGestureActivationListener.restoreListenerState();
        mEdgeListenerActivated = false;
    }
    if (flags != mLastEdgePositions) {
        mEdgeGestureManager.updateEdgeGestureActivationListener(mEdgeGestureActivationListener, flags);
        mLastEdgePositions = flags;
    }
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom && !immersiveModeImplementsPie()) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom && !immersiveModeImplementsPie()) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mPieState = (Settings.Secure.getIntForUser(resolver, Settings.Secure.PIE_STATE, 0, UserHandle.USER_CURRENT) == 1);
        /*
            mVolBtnMusicControls = (Settings.System.getIntForUser(resolver,
                    Settings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
            */
        mVolBtnMusicControls = true;
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        final boolean useEdgeService = Settings.System.getIntForUser(resolver, Settings.System.USE_EDGE_SERVICE_FOR_GESTURES, 1, UserHandle.USER_CURRENT) == 1;
        if (useEdgeService ^ mUsingEdgeGestureServiceForGestures && mSystemReady) {
            if (!mUsingEdgeGestureServiceForGestures && useEdgeService) {
                mUsingEdgeGestureServiceForGestures = true;
                mWindowManagerFuncs.unregisterPointerEventListener(mSystemGestures);
            } else if (mUsingEdgeGestureServiceForGestures && !useEdgeService) {
                mUsingEdgeGestureServiceForGestures = false;
                mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
            }
            updateEdgeGestureListenerState();
        }
        final boolean navBarEnabled = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        if (navBarEnabled != mNavBarEnabled) {
            mNavBarEnabled = navBarEnabled;
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mSystemDesignFlags = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_DESIGN_FLAGS, 0, UserHandle.USER_CURRENT);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mVolBtnMusicControls = (Settings.System.getIntForUser(resolver, Settings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        final boolean useEdgeService = Settings.System.getIntForUser(resolver, Settings.System.USE_EDGE_SERVICE_FOR_GESTURES, 1, UserHandle.USER_CURRENT) == 1;
        if (useEdgeService ^ mUsingEdgeGestureServiceForGestures && mSystemReady) {
            if (!mUsingEdgeGestureServiceForGestures && useEdgeService) {
                mUsingEdgeGestureServiceForGestures = true;
                mWindowManagerFuncs.unregisterPointerEventListener(mSystemGestures);
            } else if (mUsingEdgeGestureServiceForGestures && !useEdgeService) {
                mUsingEdgeGestureServiceForGestures = false;
                mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
            }
            updateEdgeGestureListenerState();
        }
        final boolean navBarEnabled = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_ENABLED, 0, UserHandle.USER_CURRENT) == 1;
        if (navBarEnabled != mNavBarEnabled) {
            mNavBarEnabled = navBarEnabled;
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mSystemDesignFlags = Settings.Secure.getIntForUser(resolver, Settings.Secure.SYSTEM_DESIGN_FLAGS, 0, UserHandle.USER_CURRENT);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // Any key that is not Alt or Meta cancels Caps Lock combo tracking.
    if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
        mPendingCapsLockToggle = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down) {
            cancelPreloadRecentApps();
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            handleShortPressOnHome();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            mHomePressed = true;
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                handleDoubleTapOnHome();
            } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
                preloadRecentApps();
            }
        } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
            if (!keyguardOn) {
                handleLongPressOnHome(event.getDeviceId());
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down && repeatCount == 0) {
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT, null, null, null, 0, null, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (!keyguardOn) {
            if (down && repeatCount == 0) {
                preloadRecentApps();
            } else if (!down) {
                toggleRecentApps();
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
        if (down && repeatCount == 0) {
            int type = event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
            mScreenshotRunnable.setScreenshotType(type);
            mHandler.post(mScreenshotRunnable);
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
        if (down && repeatCount == 0 && !isKeyguardLocked()) {
            toggleKeyboardShortcutsMenu(event.getDeviceId());
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (repeatCount == 1) {
                mAssistKeyLongPressed = true;
                if (!keyguardOn) {
                    launchAssistLongPressAction();
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (!keyguardOn) {
                    launchAssistAction(null, event.getDeviceId());
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
        if (mUseTvRouting) {
            // On TVs volume keys never go to the foreground app.
            dispatchDirectAudioEvent(event);
            return -1;
        }
    }
    // Toggle Caps Lock on META-ALT.
    boolean actionTriggered = false;
    if (KeyEvent.isModifierKey(keyCode)) {
        if (!mPendingCapsLockToggle) {
            // Start tracking meta state for combo.
            mInitialMetaState = mMetaState;
            mPendingCapsLockToggle = true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            int altOnMask = mMetaState & KeyEvent.META_ALT_MASK;
            int metaOnMask = mMetaState & KeyEvent.META_META_MASK;
            // Check for Caps Lock toggle
            if ((metaOnMask != 0) && (altOnMask != 0)) {
                // Check if nothing else is pressed
                if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
                    // Handle Caps Lock Toggle
                    mInputManagerInternal.toggleCapsLock(event.getDeviceId());
                    actionTriggered = true;
                }
            }
            // Always stop tracking when key goes up.
            mPendingCapsLockToggle = false;
        }
    }
    // Store current meta state to be able to evaluate it later.
    mMetaState = metaState;
    if (actionTriggered) {
        return -1;
    }
    if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                        dismissKeyboardShortcutsMenu();
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    dismissKeyboardShortcutsMenu();
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
                dismissKeyboardShortcutsMenu();
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true, false);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle input method switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
        final boolean forwardDirection = (metaState & KeyEvent.META_SHIFT_MASK) == 0;
        mWindowManagerFuncs.switchInputMethod(forwardDirection);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    if (down) {
        long shortcutCode = keyCode;
        if (event.isCtrlPressed()) {
            shortcutCode |= ((long) KeyEvent.META_CTRL_ON) << Integer.SIZE;
        }
        if (event.isAltPressed()) {
            shortcutCode |= ((long) KeyEvent.META_ALT_ON) << Integer.SIZE;
        }
        if (event.isShiftPressed()) {
            shortcutCode |= ((long) KeyEvent.META_SHIFT_ON) << Integer.SIZE;
        }
        if (event.isMetaPressed()) {
            shortcutCode |= ((long) KeyEvent.META_META_ON) << Integer.SIZE;
        }
        IShortcutService shortcutService = mShortcutKeyServices.get(shortcutCode);
        if (shortcutService != null) {
            try {
                if (isUserSetupComplete()) {
                    shortcutService.notifyShortcutKeyPressed(shortcutCode);
                }
            } catch (RemoteException e) {
                mShortcutKeyServices.delete(shortcutCode);
            }
            return -1;
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached) {
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD && !immersiveModeImplementsPie()) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
            mShowingLockscreen = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
    final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
    final int stackId = win.getStackId();
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final IApplicationToken appToken = win.getAppToken();
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty()) {
                    if (dismissKeyguard && !mKeyguardSecure) {
                        mAppsThatDismissKeyguard.add(appToken);
                    } else if (win.isDrawnLw() || win.hasAppShownWindows()) {
                        mWinShowWhenLocked = win;
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                }
            } else if (dismissKeyguard) {
                if (mKeyguardSecure) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (isFullscreen(attrs) && StackId.normallyFullscreenWindows(stackId)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = (mWinDismissingKeyguard == win && mSecureDismissingKeyguard == mKeyguardSecure) ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mSecureDismissingKeyguard = mKeyguardSecure;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked && (win.isDrawnLw() || win.hasAppShownWindows())) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (!mKeyguardHidden && mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken() && (attrs.flags & FLAG_SHOW_WHEN_LOCKED) == 0) {
                win.hideLw(false);
            }
        }
    } else if (mTopFullscreenOpaqueWindowState == null && mWinShowWhenLocked == null) {
        // we know whether to show the keyguard or not.
        if (win.isAnimatingLw() && appWindow && showWhenLocked && mKeyguardHidden) {
            mHideLockScreen = true;
            mWinShowWhenLocked = win;
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    final boolean reallyVisible = win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw();
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && StackId.normallyFullscreenWindows(stackId)) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && reallyVisible && appWindow && attached == null && isFullscreen(attrs) && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
}
#method_after
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached) {
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
            mShowingLockscreen = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
    final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
    final int stackId = win.getStackId();
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final IApplicationToken appToken = win.getAppToken();
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty()) {
                    if (dismissKeyguard && !mKeyguardSecure) {
                        mAppsThatDismissKeyguard.add(appToken);
                    } else if (win.isDrawnLw() || win.hasAppShownWindows()) {
                        mWinShowWhenLocked = win;
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                }
            } else if (dismissKeyguard) {
                if (mKeyguardSecure) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (isFullscreen(attrs) && StackId.normallyFullscreenWindows(stackId)) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = (mWinDismissingKeyguard == win && mSecureDismissingKeyguard == mKeyguardSecure) ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mSecureDismissingKeyguard = mKeyguardSecure;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked && (win.isDrawnLw() || win.hasAppShownWindows())) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (!mKeyguardHidden && mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken() && (attrs.flags & FLAG_SHOW_WHEN_LOCKED) == 0) {
                win.hideLw(false);
            }
        }
    } else if (mTopFullscreenOpaqueWindowState == null && mWinShowWhenLocked == null) {
        // we know whether to show the keyguard or not.
        if (win.isAnimatingLw() && appWindow && showWhenLocked && mKeyguardHidden) {
            mHideLockScreen = true;
            mWinShowWhenLocked = win;
        }
    }
    // Keep track of the window if it's dimming but not necessarily fullscreen.
    final boolean reallyVisible = win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw();
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && StackId.normallyFullscreenWindows(stackId)) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
    // stack can control View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.
    if (mTopDockedOpaqueWindowState == null && reallyVisible && appWindow && attached == null && isFullscreen(attrs) && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueWindowState = win;
        if (mTopDockedOpaqueOrDimmingWindowState == null) {
            mTopDockedOpaqueOrDimmingWindowState = win;
        }
    }
    // docked stack.
    if (mTopDockedOpaqueOrDimmingWindowState == null && reallyVisible && win.isDimming() && stackId == DOCKED_STACK_ID) {
        mTopDockedOpaqueOrDimmingWindowState = win;
    }
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                }
                if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
                    if (mVolBtnMusicControls && down && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        mIsLongPress = false;
                        int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                        Message msg = mHandler.obtainMessage(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK, new KeyEvent(event.getDownTime(), event.getEventTime(), event.getAction(), newKeyCode, 0));
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
                        break;
                    } else {
                        if (mVolBtnMusicControls && !down) {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            if (mIsLongPress) {
                                break;
                            }
                        }
                    }
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    if (mUseTvRouting) {
                        dispatchDirectAudioEvent(event);
                    } else {
                        // If we aren't passing to the user and no one else
                        // handled it send it to the session manager to
                        // figure out.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                    }
                    break;
                }
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    mBackKeyHandled = false;
                    if (hasLongPressOnBackBehavior()) {
                        Message msg = mHandler.obtainMessage(MSG_BACK_LONG_PRESS);
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    }
                } else {
                    boolean handled = mBackKeyHandled;
                    // Reset back key state
                    cancelPendingBackKeyAction();
                    // Don't pass back press to app if we've already handled it
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeDownKeyTriggered = true;
                        mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                        mScreenshotChordVolumeDownKeyConsumed = false;
                        cancelPendingPowerKeyAction();
                        interceptScreenshotChord();
                    }
                } else {
                    mScreenshotChordVolumeDownKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                if (down) {
                    if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mScreenshotChordVolumeUpKeyTriggered = true;
                        cancelPendingPowerKeyAction();
                        cancelPendingScreenshotChordAction();
                    }
                } else {
                    mScreenshotChordVolumeUpKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                }
            }
            if (down) {
                TelecomManager telecomManager = getTelecommService();
                if (telecomManager != null) {
                    if (telecomManager.isRinging()) {
                        // If an incoming call is ringing, either VOLUME key means
                        // "silence ringer".  We handle these keys here, rather than
                        // in the InCallScreen, to make sure we'll respond to them
                        // even if the InCallScreen hasn't come to the foreground yet.
                        // Look for the DOWN event here, to agree with the "fallback"
                        // behavior in the InCallScreen.
                        Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                        // Silence the ringer.  (It's safe to call this
                        // even if the ringer has already been silenced.)
                        telecomManager.silenceRinger();
                        // And *don't* pass this key thru to the current activity
                        // (which is probably the InCallScreen.)
                        result &= ~ACTION_PASS_TO_USER;
                        break;
                    }
                    if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                        break;
                    }
                }
            }
            if ((result & ACTION_PASS_TO_USER) == 0) {
                if (isMusicActive()) {
                    if (mVolBtnMusicControls && down && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        mVolBtnLongPress = false;
                        int newKeyCode = event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP ? KeyEvent.KEYCODE_MEDIA_NEXT : KeyEvent.KEYCODE_MEDIA_PREVIOUS;
                        Message msg = mHandler.obtainMessage(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK, new KeyEvent(event.getDownTime(), event.getEventTime(), event.getAction(), newKeyCode, 0));
                        msg.setAsynchronous(true);
                        mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
                        break;
                    } else {
                        if (mVolBtnMusicControls && !down) {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            if (mVolBtnLongPress) {
                                break;
                            }
                        }
                    }
                }
                if (mUseTvRouting) {
                    dispatchDirectAudioEvent(event);
                } else {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                }
                break;
            }
            break;
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mTvPictureInPictureVisible) {
                        // to customize PIP key behavior.
                        if (!down) {
                            showTvPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#end_block

#method_before
private void requestTransientBars(WindowState swipeTarget) {
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        if (!isUserSetupComplete()) {
            // Swipe-up for navigation bar is disabled during setup
            return;
        }
        boolean sb = mStatusBarController.checkShowTransientBarLw();
        boolean nb = mNavigationBarController.checkShowTransientBarLw();
        if (sb || nb) {
            // Don't show status bar when swiping on already visible navigation bar
            if (!nb && swipeTarget == mNavigationBar) {
                if (DEBUG)
                    Slog.d(TAG, "Not showing transient bar, wrong swipe target");
                return;
            }
            if (sb)
                mStatusBarController.showTransient();
            if (nb && !immersiveModeImplementsPie())
                mNavigationBarController.showTransient();
            mImmersiveModeConfirmation.confirmCurrentPrompt();
            updateSystemUiVisibilityLw();
        }
    }
}
#method_after
private void requestTransientBars(WindowState swipeTarget) {
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        if (!isUserSetupComplete()) {
            // Swipe-up for navigation bar is disabled during setup
            return;
        }
        boolean sb = mStatusBarController.checkShowTransientBarLw();
        boolean nb = mNavigationBarController.checkShowTransientBarLw();
        if (sb || nb) {
            // Don't show status bar when swiping on already visible navigation bar
            if (!nb && swipeTarget == mNavigationBar) {
                if (DEBUG)
                    Slog.d(TAG, "Not showing transient bar, wrong swipe target");
                return;
            }
            if (sb)
                mStatusBarController.showTransient();
            if (nb)
                mNavigationBarController.showTransient();
            mImmersiveModeConfirmation.confirmCurrentPrompt();
            updateSystemUiVisibilityLw();
        }
    }
}
#end_block

#method_before
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
            if (mBootMessageNeedsHiding) {
                mBootMessageNeedsHiding = false;
                hideBootMessages();
            }
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
    toggleOrientationListener(true);
}
#method_after
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
            if (mBootMessageNeedsHiding) {
                mBootMessageNeedsHiding = false;
                hideBootMessages();
            }
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
}
#end_block

