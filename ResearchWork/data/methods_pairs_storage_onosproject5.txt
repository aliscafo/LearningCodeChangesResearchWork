914
#method_before
public void modifyHostDetails(PropertyPanel pp, HostId hostId) {
    pp.title(MY_HOST_TITLE);
    pp.removeAllProps();
    pp.addProp("SF host Address", hostId.toString());
}
#method_after
@Override
public void modifyHostDetails(PropertyPanel pp, HostId hostId) {
    pp.title(MY_HOST_TITLE);
    pp.removeAllProps();
    pp.addProp("SF host Address", hostId.toString());
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    log.debug("Stop Display");
    cancelTask();
    clearState();
    clearForMode();
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    log.debug("Stop Display");
    clearState();
    clearForMode();
    cancelTask();
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String id = string(payload, ID);
    ServiceDirectory serviceDirectory = new DefaultServiceDirectory();
    if (null == serviceDirectory) {
        log.info("serviceDirectory is null");
    }
    vtnRscService = serviceDirectory.get(VtnRscService.class);
    virtualPortService = serviceDirectory.get(VirtualPortService.class);
    Highlights highlights = new Highlights();
    PortChainId portChainId = PortChainId.of(id);
    if (null == portChainId) {
        log.info("portChainId is null");
    }
    PortChain portChain = portChainService.getPortChain(portChainId);
    if (null == portChain) {
        log.info("portChain is null");
    }
    List<PortPairGroupId> llPortPairGroupIdList = portChain.portPairGroups();
    ListIterator<PortPairGroupId> portPairGroupIdListIterator = llPortPairGroupIdList.listIterator();
    while (portPairGroupIdListIterator.hasNext()) {
        PortPairGroupId portPairGroupId = portPairGroupIdListIterator.next();
        PortPairGroup portPairGroup = portPairGroupService.getPortPairGroup(portPairGroupId);
        List<PortPairId> llPortPairIdList = portPairGroup.portPairs();
        ListIterator<PortPairId> portPairListIterator = llPortPairIdList.listIterator();
        while (portPairListIterator.hasNext()) {
            PortPairId portPairId = portPairListIterator.next();
            if (null == portPairId) {
                log.info("portPair is null");
            }
            PortPair portPair = portPairService.getPortPair(portPairId);
            if (null == portPair) {
                log.info("portPair is null");
            }
            DeviceId deviceId = vtnRscService.getSfToSffMaping(VirtualPortId.portId(portPair.egress()));
            Device device = deviceService.getDevice(deviceId);
            DeviceHighlight dh = new DeviceHighlight(device.id().toString());
            dh.setBadge(NodeBadge.text("SFC"));
            MacAddress dstMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.egress())).macAddress();
            Host host = hostService.getHost(HostId.hostId(dstMacAddress));
            HostHighlight hhDst = new HostHighlight(host.id().toString());
            hhDst.setBadge(NodeBadge.text("SFC"));
            MacAddress srcMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.ingress())).macAddress();
            Host hostSrc = hostService.getHost(HostId.hostId(srcMacAddress));
            HostHighlight hhSrc = new HostHighlight(hostSrc.id().toString());
            hhSrc.setBadge(NodeBadge.text("SFC"));
            highlights.add(dh);
            highlights.add(hhSrc);
            highlights.add(hhDst);
        }
    }
    sendHighlights(highlights);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String id = string(payload, ID);
    ServiceDirectory serviceDirectory = new DefaultServiceDirectory();
    vtnRscService = serviceDirectory.get(VtnRscService.class);
    virtualPortService = serviceDirectory.get(VirtualPortService.class);
    Highlights highlights = new Highlights();
    PortChainId portChainId = PortChainId.of(id);
    boolean portChainIdExist = portChainService.exists(portChainId);
    if (!portChainIdExist) {
        log.info("portchain id doesn't exist");
        return;
    }
    PortChain portChain = portChainService.getPortChain(portChainId);
    List<PortPairGroupId> llPortPairGroupIdList = portChain.portPairGroups();
    ListIterator<PortPairGroupId> portPairGroupIdListIterator = llPortPairGroupIdList.listIterator();
    while (portPairGroupIdListIterator.hasNext()) {
        PortPairGroupId portPairGroupId = portPairGroupIdListIterator.next();
        PortPairGroup portPairGroup = portPairGroupService.getPortPairGroup(portPairGroupId);
        List<PortPairId> llPortPairIdList = portPairGroup.portPairs();
        ListIterator<PortPairId> portPairListIterator = llPortPairIdList.listIterator();
        while (portPairListIterator.hasNext()) {
            PortPairId portPairId = portPairListIterator.next();
            PortPair portPair = portPairService.getPortPair(portPairId);
            DeviceId deviceId = vtnRscService.getSfToSffMaping(VirtualPortId.portId(portPair.egress()));
            Device device = deviceService.getDevice(deviceId);
            DeviceHighlight dh = new DeviceHighlight(device.id().toString());
            dh.setBadge(NodeBadge.text(SFC_ID));
            MacAddress dstMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.egress())).macAddress();
            Host host = hostService.getHost(HostId.hostId(dstMacAddress));
            HostHighlight hhDst = new HostHighlight(host.id().toString());
            hhDst.setBadge(NodeBadge.text(SFC_ID));
            MacAddress srcMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.ingress())).macAddress();
            Host hostSrc = hostService.getHost(HostId.hostId(srcMacAddress));
            HostHighlight hhSrc = new HostHighlight(hostSrc.id().toString());
            hhSrc.setBadge(NodeBadge.text(SFC_ID));
            highlights.add(dh);
            highlights.add(hhSrc);
            highlights.add(hhDst);
        }
    }
    sendHighlights(highlights);
}
#end_block

#method_before
@Activate
public void activate() {
    log.debug("BgpTopologyProvider activate");
    deviceProviderService = deviceProviderRegistry.register(this);
    linkProviderService = linkProviderRegistry.register(this);
    controller.addListener(listener);
    controller.addLinkListener(listener);
}
#method_after
@Activate
public void activate() {
    log.debug("BgpTopologyProvider activate");
    deviceProviderService = deviceProviderRegistry.register(this);
    linkProviderService = linkProviderRegistry.register(this);
    controller.addListener(listener);
    mastershipService.addListener(masterListener);
    controller.addLinkListener(listener);
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    log.debug("BgpTopologyProvider deactivate");
    deviceProviderRegistry.unregister(this);
    deviceProviderService = null;
    linkProviderRegistry.unregister(this);
    linkProviderService = null;
    controller.removeListener(listener);
    controller.removeLinkListener(listener);
}
#method_after
@Deactivate
public void deactivate() {
    log.debug("BgpTopologyProvider deactivate");
    deviceProviderRegistry.unregister(this);
    deviceProviderService = null;
    linkProviderRegistry.unregister(this);
    linkProviderService = null;
    controller.removeListener(listener);
    controller.removeLinkListener(listener);
    mastershipService.removeListener(masterListener);
}
#end_block

#method_before
@Override
public void addNode(BgpNodeLSNlriVer4 nodeNlri, PathAttrNlriDetails details) {
    log.debug("Add node {}", nodeNlri.toString());
    if (deviceProviderService == null) {
        return;
    }
    Device.Type deviceType = ROUTER;
    BgpDpid nodeUri = new BgpDpid(nodeNlri);
    DeviceId deviceId = deviceId(uri(nodeUri.toString()));
    ChassisId cId = new ChassisId();
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    newBuilder.set(ROUTING_UNIVERSE, Long.toString(nodeNlri.getIdentifier()));
    List<BgpValueType> tlvs = nodeNlri.getLocalNodeDescriptors().getNodedescriptors().getSubTlvs();
    for (BgpValueType tlv : tlvs) {
        if (tlv instanceof AutonomousSystemTlv) {
            newBuilder.set(AS_NUMBER, Integer.toString(((AutonomousSystemTlv) tlv).getAsNum()));
        } else if (tlv instanceof BgpLSIdentifierTlv) {
            newBuilder.set(DOMAIN_IDENTIFIER, Integer.toString(((BgpLSIdentifierTlv) tlv).getBgpLsIdentifier()));
        }
        if (tlv.getType() == NodeDescriptors.IGP_ROUTERID_TYPE) {
            if (tlv instanceof IsIsPseudonode) {
                deviceType = VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, new String(((IsIsPseudonode) tlv).getIsoNodeId()));
            } else if (tlv instanceof OspfPseudonode) {
                deviceType = VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfPseudonode) tlv).getrouterID()));
            } else if (tlv instanceof IsIsNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, new String(((IsIsNonPseudonode) tlv).getIsoNodeId()));
            } else if (tlv instanceof OspfNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfNonPseudonode) tlv).getrouterID()));
            }
        }
    }
    DefaultAnnotations.Builder anntotations = getAnnotations(newBuilder, true, details);
    DeviceDescription description = new DefaultDeviceDescription(uri(nodeUri.toString()), deviceType, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cId, anntotations.build());
    deviceProviderService.deviceConnected(deviceId, description);
    Device device = deviceService.getDevice(deviceId);
    // Reserve label resource pool for each devices
    if (device == null) {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        Future<?> future = executor.submit(new CreateDevicePool(deviceId));
        try {
            // future.get() null means successful execution
            if (future.get() != null) {
                // Execution [creating device label pool] is not successful submit same task again
                executor.submit(new CreateDevicePool(deviceId));
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception while creating a device label pool");
        }
        executor.shutdown();
    } else {
        createDevicePool(deviceId);
    }
}
#method_after
@Override
public void addNode(BgpNodeLSNlriVer4 nodeNlri, PathAttrNlriDetails details) {
    log.debug("Add node {}", nodeNlri.toString());
    if (deviceProviderService == null || deviceService == null) {
        return;
    }
    Device.Type deviceType = ROUTER;
    BgpDpid nodeUri = new BgpDpid(nodeNlri);
    DeviceId deviceId = deviceId(uri(nodeUri.toString()));
    ChassisId cId = new ChassisId();
    /*
             * Check if device is already there (available) , if yes not updating to core.
             */
    if (deviceService.isAvailable(deviceId)) {
        return;
    }
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    newBuilder.set(ROUTING_UNIVERSE, Long.toString(nodeNlri.getIdentifier()));
    List<BgpValueType> tlvs = nodeNlri.getLocalNodeDescriptors().getNodedescriptors().getSubTlvs();
    for (BgpValueType tlv : tlvs) {
        if (tlv instanceof AutonomousSystemTlv) {
            newBuilder.set(AS_NUMBER, Integer.toString(((AutonomousSystemTlv) tlv).getAsNum()));
        } else if (tlv instanceof BgpLSIdentifierTlv) {
            newBuilder.set(DOMAIN_IDENTIFIER, Integer.toString(((BgpLSIdentifierTlv) tlv).getBgpLsIdentifier()));
        }
        if (tlv.getType() == NodeDescriptors.IGP_ROUTERID_TYPE) {
            if (tlv instanceof IsIsPseudonode) {
                deviceType = VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, new String(((IsIsPseudonode) tlv).getIsoNodeId()));
            } else if (tlv instanceof OspfPseudonode) {
                deviceType = VIRTUAL;
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfPseudonode) tlv).getrouterID()));
            } else if (tlv instanceof IsIsNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, new String(((IsIsNonPseudonode) tlv).getIsoNodeId()));
            } else if (tlv instanceof OspfNonPseudonode) {
                newBuilder.set(AnnotationKeys.ROUTER_ID, Integer.toString(((OspfNonPseudonode) tlv).getrouterID()));
            }
        }
    }
    DefaultAnnotations.Builder anntotations = DefaultAnnotations.builder();
    anntotations = getAnnotations(newBuilder, true, details);
    DeviceDescription description = new DefaultDeviceDescription(uri(nodeUri.toString()), deviceType, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cId, anntotations.build());
    deviceProviderService.deviceConnected(deviceId, description);
}
#end_block

#method_before
@Override
public void deleteNode(BgpNodeLSNlriVer4 nodeNlri) {
    log.debug("Delete node {}", nodeNlri.toString());
    if (deviceProviderService == null) {
        return;
    }
    BgpDpid deviceUri = new BgpDpid(nodeNlri);
    DeviceId deviceId = deviceId(uri(deviceUri.toString()));
    /*
             * Only master for that device will destroy the label pool for that device.
             */
    if (labelResourceAdminService != null && mastershipService.isLocalMaster(deviceId)) {
        // Destroy local device label pool reserved for that device
        labelResourceAdminService.destroyDevicePool(deviceId);
    }
    deviceProviderService.deviceDisconnected(deviceId);
}
#method_after
@Override
public void deleteNode(BgpNodeLSNlriVer4 nodeNlri) {
    log.debug("Delete node {}", nodeNlri.toString());
    if (deviceProviderService == null) {
        return;
    }
    BgpDpid deviceUri = new BgpDpid(nodeNlri);
    DeviceId deviceId = deviceId(uri(deviceUri.toString()));
    if (labelResourceAdminService != null) {
        // Destroy local device label pool reserved for that device
        labelResourceAdminService.destroyDevicePool(deviceId);
    }
    deviceProviderService.deviceDisconnected(deviceId);
}
#end_block

#method_before
@Override
public void addLink(BgpLinkLsNlriVer4 linkNlri, PathAttrNlriDetails details) throws BgpParseException {
    log.debug("Addlink {}", linkNlri.toString());
    if (linkProviderService == null) {
        return;
    }
    LinkDescription linkDes = buildLinkDes(linkNlri, details, true);
    linkProviderService.linkDetected(linkDes);
    if (linkService.getLink(linkDes.src(), linkDes.dst()) == null) {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        Future<?> future = executor.submit(new RegisterBandwidth(details, linkDes.src().deviceId(), linkDes.src().port()));
        try {
            // future.get() null means successful execution
            if (future.get() != null) {
                // Execution [registering for bandwidth resource] is not successful submit same task again
                executor.submit(new RegisterBandwidth(details, linkDes.src().deviceId(), linkDes.src().port()));
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception while creating a device label pool");
        }
        executor.shutdown();
    } else {
        registerBandwidth(details, linkDes.src().deviceId(), linkDes.src().port());
    }
}
#method_after
@Override
public void addLink(BgpLinkLsNlriVer4 linkNlri, PathAttrNlriDetails details) throws BgpParseException {
    log.debug("Addlink {}", linkNlri.toString());
    if (linkProviderService == null) {
        return;
    }
    LinkDescription linkDes = buildLinkDes(linkNlri, details, true);
    /*
             * Update link ports and configure bandwidth on source and destination port using networkConfig service
             * Only master of source link registers for bandwidth
             */
    if (mastershipService.isLocalMaster(linkDes.src().deviceId())) {
        registerBandwidth(linkDes, details);
    }
    // Updating ports of the link
    List<PortDescription> srcPortDescriptions = new LinkedList<>();
    srcPortDescriptions.add(new DefaultPortDescription(linkDes.src().port(), true));
    deviceProviderService.updatePorts(linkDes.src().deviceId(), srcPortDescriptions);
    List<PortDescription> dstPortDescriptions = new LinkedList<>();
    dstPortDescriptions.add(new DefaultPortDescription(linkDes.dst().port(), true));
    deviceProviderService.updatePorts(linkDes.dst().deviceId(), dstPortDescriptions);
    linkProviderService.linkDetected(linkDes);
}
#end_block

#method_before
@Override
public void deleteLink(BgpLinkLsNlriVer4 linkNlri) throws BgpParseException {
    log.debug("Delete link {}", linkNlri.toString());
    if (linkProviderService == null) {
        return;
    }
    LinkDescription linkDes = buildLinkDes(linkNlri, null, false);
    /*
             * Only master for that device will release the bandwidth resource.
             */
    if (resourceAdminService != null && mastershipService.isLocalMaster(linkDes.src().deviceId())) {
        // Releases registered resource for this link
        releaseResource(linkDes.src().deviceId(), linkDes.src().port());
    }
    linkProviderService.linkVanished(linkDes);
}
#method_after
@Override
public void deleteLink(BgpLinkLsNlriVer4 linkNlri) throws BgpParseException {
    log.debug("Delete link {}", linkNlri.toString());
    if (linkProviderService == null) {
        return;
    }
    LinkDescription linkDes = buildLinkDes(linkNlri, null, false);
    /*
             * Only master for the link src will release the bandwidth resource.
             */
    if (networkConfigService != null && mastershipService.isLocalMaster(linkDes.src().deviceId())) {
        // Releases registered resource for this link
        networkConfigService.removeConfig(linkDes.src(), BandwidthCapacity.class);
        networkConfigService.removeConfig(linkDes.dst(), BandwidthCapacity.class);
    }
    linkProviderService.linkVanished(linkDes);
}
#end_block

#method_before
private void createDevicePool(DeviceId deviceId) {
    /*
         * Only master for that device will create the label pool for that device.
         */
    if (labelResourceAdminService == null || !mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    labelResourceAdminService.createDevicePool(deviceId, beginLabel, endLabel);
}
#method_after
private void createDevicePool(DeviceId deviceId) {
    if (labelResourceAdminService == null) {
        return;
    }
    labelResourceAdminService.createDevicePool(deviceId, beginLabel, endLabel);
}
#end_block

#method_before
private void registerBandwidth(PathAttrNlriDetails details, DeviceId deviceId, PortNumber portNum) {
    List<BgpValueType> attribute = details.pathAttributes().stream().filter(attr -> attr instanceof LinkStateAttributes).collect(toList());
    if (attribute.isEmpty()) {
        return;
    }
    List<BgpValueType> tlvs = ((LinkStateAttributes) attribute.iterator().next()).linkStateAttributes();
    float maxReservableBw = 0;
    for (BgpValueType tlv : tlvs) {
        switch(tlv.getType()) {
            case LinkStateAttributes.ATTR_LINK_MAX_RES_BANDWIDTH:
                maxReservableBw = ((BgpLinkAttrMaxLinkBandwidth) tlv).linkAttrMaxLinkBandwidth();
                break;
            // do nothing
            default:
        }
    }
    if (maxReservableBw != 0 && resourceAdminService != null && mastershipService.isLocalMaster(deviceId)) {
        Resource bandwidthRes = Resources.continuous(deviceId, portNum, Bandwidth.class).resource(maxReservableBw);
        // Only master of that device will register for bandwidth resource
        resourceAdminService.register(bandwidthRes);
    }
}
#method_after
private void registerBandwidth(LinkDescription linkDes, PathAttrNlriDetails details) {
    if (details == null) {
        log.error("Couldnot able to register bandwidth ");
        return;
    }
    List<BgpValueType> attribute = details.pathAttributes().stream().filter(attr -> attr instanceof LinkStateAttributes).collect(toList());
    if (attribute.isEmpty()) {
        return;
    }
    List<BgpValueType> tlvs = ((LinkStateAttributes) attribute.iterator().next()).linkStateAttributes();
    float maxReservableBw = 0;
    for (BgpValueType tlv : tlvs) {
        switch(tlv.getType()) {
            case LinkStateAttributes.ATTR_LINK_MAX_RES_BANDWIDTH:
                maxReservableBw = ((BgpLinkAttrMaxLinkBandwidth) tlv).linkAttrMaxLinkBandwidth();
                break;
            // do nothing
            default:
        }
    }
    if (maxReservableBw == 0.0) {
        return;
    }
    // Configure bandwidth for src and dst port
    BandwidthCapacity config = networkConfigService.addConfig(linkDes.src(), BandwidthCapacity.class);
    config.capacity(Bandwidth.bps(maxReservableBw)).apply();
    config = networkConfigService.addConfig(linkDes.dst(), BandwidthCapacity.class);
    config.capacity(Bandwidth.bps(maxReservableBw)).apply();
}
#end_block

#method_before
@Before
public void startUp() {
    provider.deviceProviderRegistry = nodeRegistry;
    provider.linkProviderRegistry = linkRegistry;
    provider.controller = controller;
    provider.deviceService = deviceService;
    provider.linkService = linkService;
    provider.resourceAdminService = resourceAdminService;
    provider.mastershipService = mastershipService;
    provider.activate();
    assertThat("device provider should be registered", not(nodeRegistry.provider));
    assertThat("link provider should be registered", not(linkRegistry.linkProvider));
    assertThat("node listener should be registered", not(controller.nodeListener));
    assertThat("link listener should be registered", not(controller.linkListener));
}
#method_after
@Before
public void startUp() throws TestUtilsException {
    provider.deviceProviderRegistry = nodeRegistry;
    provider.linkProviderRegistry = linkRegistry;
    provider.controller = controller;
    provider.deviceService = deviceService;
    provider.linkService = linkService;
    provider.labelResourceAdminService = labelResourceAdminService;
    provider.mastershipService = mastershipService;
    provider.networkConfigService = networkConfigService;
    listener = TestUtils.getField(provider, "masterListener");
    provider.activate();
    assertThat("device provider should be registered", not(nodeRegistry.provider));
    assertThat("link provider should be registered", not(linkRegistry.linkProvider));
    assertThat("node listener should be registered", not(controller.nodeListener));
    assertThat("link listener should be registered", not(controller.linkListener));
}
#end_block

#method_before
@After
public void tearDown() {
    provider.deactivate();
    provider.controller = null;
    provider.deviceService = null;
    provider.deviceProviderRegistry = null;
    provider.linkService = null;
    provider.mastershipService = null;
    provider.resourceAdminService = null;
    assertThat(controller.nodeListener, is(new HashSet<BgpNodeListener>()));
    assertThat(controller.linkListener, is(new HashSet<BgpLinkListener>()));
}
#method_after
@After
public void tearDown() {
    provider.deactivate();
    provider.controller = null;
    provider.deviceService = null;
    provider.deviceProviderRegistry = null;
    provider.linkService = null;
    provider.mastershipService = null;
    provider.networkConfigService = null;
    provider.labelResourceAdminService = null;
    assertThat(controller.nodeListener, is(new HashSet<BgpNodeListener>()));
    assertThat(controller.linkListener, is(new HashSet<BgpLinkListener>()));
}
#end_block

#method_before
@Override
public LinkProvider provider() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DeviceProvider provider() {
    return null;
}
#end_block

#method_before
@Override
public void updatePorts(DeviceId deviceId, List<PortDescription> portDescriptions) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void updatePorts(DeviceId deviceId, List<PortDescription> portDescriptions) {
    portUpdated.put(deviceId, portDescriptions);
}
#end_block

#method_before
@Test
public void bgpTopologyProviderTestAddLink3() throws BgpParseException {
    LinkedList<BgpValueType> localTlvs = new LinkedList<>();
    LinkedList<BgpValueType> remoteTlvs = new LinkedList<>();
    LinkedList<BgpValueType> linkdes = new LinkedList<>();
    BgpValueType tlv = new AutonomousSystemTlv(10);
    short deslength = AutonomousSystemTlv.LENGTH;
    short desType = AutonomousSystemTlv.TYPE;
    localTlvs.add(tlv);
    remoteTlvs.add(tlv);
    tlv = IsIsNonPseudonode.of(new byte[] { 20, 20, 20, 20, 00, 20 });
    localTlvs.add(tlv);
    tlv = IsIsNonPseudonode.of(new byte[] { 30, 30, 30, 30, 00, 30 });
    remoteTlvs.add(tlv);
    NodeDescriptors localNode = new NodeDescriptors(localTlvs, deslength, desType);
    NodeDescriptors remoteNode = new NodeDescriptors(remoteTlvs, deslength, desType);
    BgpNodeLSIdentifier localNodeDescriptors = new BgpNodeLSIdentifier(localNode);
    BgpNodeLSNlriVer4 nodeNlri = new BgpNodeLSNlriVer4(0, (byte) Constants.DIRECT, localNodeDescriptors, false, new RouteDistinguisher());
    BgpNodeLSIdentifier remoteNodeDescriptors = new BgpNodeLSIdentifier(remoteNode);
    BgpNodeLSNlriVer4 remNodeNlri = new BgpNodeLSNlriVer4(0, (byte) Constants.DIRECT, remoteNodeDescriptors, false, new RouteDistinguisher());
    PathAttrNlriDetails details = new PathAttrNlriDetails();
    details.setIdentifier(0);
    details.setProtocolID(ProtocolType.DIRECT);
    List<BgpValueType> pathAttributes = new LinkedList<>();
    details.setPathAttribute(pathAttributes);
    tlv = LinkLocalRemoteIdentifiersTlv.of(99, 100);
    linkdes.add(tlv);
    BgpLinkLSIdentifier linkId = new BgpLinkLSIdentifier(localNode, remoteNode, linkdes);
    BgpLinkLsNlriVer4 linkNlri = new BgpLinkLsNlriVer4((byte) Constants.DIRECT, 0, linkId, new RouteDistinguisher(), false);
    for (BgpNodeListener l : controller.nodeListener) {
        l.addNode(nodeNlri, details);
        assertThat(nodeRegistry.connected.size(), is(1));
        l.addNode(remNodeNlri, details);
        assertThat(nodeRegistry.connected.size(), is(2));
        l.deleteNode(nodeNlri);
        assertThat(nodeRegistry.connected.size(), is(1));
    }
    List<BgpValueType> linkPathAttributes = new LinkedList<>();
    List<BgpValueType> linkStateAttr = new LinkedList<>();
    tlv = BgpLinkAttrIgpMetric.of(10, 4);
    linkStateAttr.add(tlv);
    tlv = BgpLinkAttrTeDefaultMetric.of(20);
    linkStateAttr.add(tlv);
    tlv = BgpLinkAttrMaxLinkBandwidth.of(30, LinkStateAttributes.ATTR_LINK_MAX_RES_BANDWIDTH);
    linkStateAttr.add(tlv);
    linkPathAttributes.add(new LinkStateAttributes(linkStateAttr));
    details.setPathAttribute(linkPathAttributes);
    for (BgpLinkListener l : controller.linkListener) {
        l.addLink(linkNlri, details);
        assertThat(linkRegistry.links.size(), is(1));
        assertThat(linkRegistry.links.iterator().next().annotations().value(BgpTopologyProvider.COST), is("10"));
        assertThat(linkRegistry.links.iterator().next().annotations().value(BgpTopologyProvider.TE_COST), is("20"));
        Resource res = resourceAdminService.registeredRes.values().iterator().next().iterator().next();
        assertThat(((ContinuousResource) res).value(), is(30.0));
        l.deleteLink(linkNlri);
        assertThat(linkRegistry.links.size(), is(0));
        assertThat(resourceAdminService.registeredRes.size(), is(0));
    }
}
#method_after
@Test
public void bgpTopologyProviderTestAddLink3() throws BgpParseException, InterruptedException {
    LinkedList<BgpValueType> localTlvs = new LinkedList<>();
    LinkedList<BgpValueType> remoteTlvs = new LinkedList<>();
    LinkedList<BgpValueType> linkdes = new LinkedList<>();
    BgpValueType tlv = new AutonomousSystemTlv(10);
    short deslength = AutonomousSystemTlv.LENGTH;
    short desType = AutonomousSystemTlv.TYPE;
    localTlvs.add(tlv);
    remoteTlvs.add(tlv);
    tlv = IsIsNonPseudonode.of(new byte[] { 20, 20, 20, 20, 00, 20 });
    localTlvs.add(tlv);
    tlv = IsIsNonPseudonode.of(new byte[] { 30, 30, 30, 30, 00, 30 });
    remoteTlvs.add(tlv);
    NodeDescriptors localNode = new NodeDescriptors(localTlvs, deslength, desType);
    NodeDescriptors remoteNode = new NodeDescriptors(remoteTlvs, deslength, desType);
    BgpNodeLSIdentifier localNodeDescriptors = new BgpNodeLSIdentifier(localNode);
    BgpNodeLSNlriVer4 nodeNlri = new BgpNodeLSNlriVer4(0, (byte) Constants.DIRECT, localNodeDescriptors, false, new RouteDistinguisher());
    BgpNodeLSIdentifier remoteNodeDescriptors = new BgpNodeLSIdentifier(remoteNode);
    BgpNodeLSNlriVer4 remNodeNlri = new BgpNodeLSNlriVer4(0, (byte) Constants.DIRECT, remoteNodeDescriptors, false, new RouteDistinguisher());
    PathAttrNlriDetails details = new PathAttrNlriDetails();
    details.setIdentifier(0);
    details.setProtocolID(ProtocolType.DIRECT);
    List<BgpValueType> pathAttributes = new LinkedList<>();
    details.setPathAttribute(pathAttributes);
    tlv = LinkLocalRemoteIdentifiersTlv.of(99, 100);
    linkdes.add(tlv);
    BgpLinkLSIdentifier linkId = new BgpLinkLSIdentifier(localNode, remoteNode, linkdes);
    BgpLinkLsNlriVer4 linkNlri = new BgpLinkLsNlriVer4((byte) Constants.DIRECT, 0, linkId, new RouteDistinguisher(), false);
    for (BgpNodeListener l : controller.nodeListener) {
        l.addNode(nodeNlri, details);
        assertThat(nodeRegistry.connected.size(), is(1));
        l.addNode(remNodeNlri, details);
        assertThat(nodeRegistry.connected.size(), is(2));
        l.deleteNode(remNodeNlri);
        assertThat(nodeRegistry.connected.size(), is(1));
    }
    List<BgpValueType> linkPathAttributes = new LinkedList<>();
    List<BgpValueType> linkStateAttr = new LinkedList<>();
    tlv = BgpLinkAttrIgpMetric.of(10, 4);
    linkStateAttr.add(tlv);
    tlv = BgpLinkAttrTeDefaultMetric.of(20);
    linkStateAttr.add(tlv);
    tlv = BgpLinkAttrMaxLinkBandwidth.of(30, LinkStateAttributes.ATTR_LINK_MAX_RES_BANDWIDTH);
    linkStateAttr.add(tlv);
    linkPathAttributes.add(new LinkStateAttributes(linkStateAttr));
    details.setPathAttribute(linkPathAttributes);
    for (BgpLinkListener l : controller.linkListener) {
        l.addLink(linkNlri, details);
        assertThat(linkRegistry.links.size(), is(1));
        assertThat(linkRegistry.links.iterator().next().annotations().value(BgpTopologyProvider.COST), is("10"));
        assertThat(linkRegistry.links.iterator().next().annotations().value(BgpTopologyProvider.TE_COST), is("20"));
        l.deleteLink(linkNlri);
        assertThat(linkRegistry.links.size(), is(0));
    }
}
#end_block

#method_before
@Override
public void resolveSelfFileLinking(boolean isGroupingCodeGenFlagSet) throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    resolveLinkingForResolutionList(resolutionList, this, isGroupingCodeGenFlagSet);
}
#method_after
@Override
public void resolveSelfFileLinking() throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    resolveLinkingForResolutionList(resolutionList, this);
}
#end_block

#method_before
@Override
public void resolveInterFileLinking(boolean isGroupingCodeGenFlagSet) throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    linkInterFileReferences(resolutionList, this, isGroupingCodeGenFlagSet);
}
#method_after
@Override
public void resolveInterFileLinking() throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    linkInterFileReferences(resolutionList, this);
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
    try {
        if (getJavaFileInfo().getPluginConfig().isGroupingCodeGenFlagSet()) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
        }
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for container node " + this.getName());
    }
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
    try {
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for container node " + this.getName());
    }
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    try {
        if (yangPlugin.isGroupingCodeGenFlagSet()) {
            addCurNodeInfoInParentTempFile(this, false, yangPlugin);
        }
    } catch (IOException e) {
        throw new TranslatorException("Failed to prepare generate code entry for container node " + this.getName());
    }
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
    try {
        addCurNodeInfoInParentTempFile(this, false, yangPlugin);
    } catch (IOException e) {
        throw new TranslatorException("Failed to prepare generate code entry for container node " + this.getName());
    }
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
// no code generation will be done for uses.
}
#end_block

#method_before
private JavaAttributeInfo processNodeWhenOnlyOneChildNodeIsPresent(YangNode node, YangPluginConfig yangPluginConfig) {
    JavaFileInfo rpcInfo = getJavaFileInfo();
    String clsInfo = "";
    JavaQualifiedTypeInfo childInfo = new JavaQualifiedTypeInfo();
    if (node.getChild() instanceof YangJavaUses && yangPluginConfig.isGroupingCodeGenFlagSet()) {
        childInfo = resolveGroupingsQuailifiedInfo(((YangJavaUses) node.getChild()).getRefGroup(), yangPluginConfig);
        clsInfo = getCapitalCase(getCamelCase(((YangJavaUses) node.getChild()).getRefGroup().getName(), yangPluginConfig.getConflictResolver()));
    } else {
        String pkg = (rpcInfo.getPackage() + "." + rpcInfo.getJavaName() + "." + getCamelCase(node.getName(), yangPluginConfig.getConflictResolver())).toLowerCase();
        clsInfo = getCapitalCase(getCamelCase(node.getChild().getName(), yangPluginConfig.getConflictResolver()));
        childInfo.setPkgInfo(pkg);
        childInfo.setClassInfo(clsInfo);
    }
    boolean isList = false;
    if (node.getChild().getNodeType().equals(LIST_NODE)) {
        isList = true;
    }
    boolean isQualified = addImportToService(childInfo);
    JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(childInfo, clsInfo, null, isQualified, isList);
    setLeafHolderFlag(node, false);
    setSingleChildHolderFlag(node, true);
    return javaAttributeInfo;
}
#method_after
private JavaAttributeInfo processNodeWhenOnlyOneChildNodeIsPresent(YangNode node, YangPluginConfig yangPluginConfig) {
    JavaFileInfo rpcInfo = getJavaFileInfo();
    String clsInfo = "";
    JavaQualifiedTypeInfo childInfo = new JavaQualifiedTypeInfo();
    if (node.getChild() instanceof YangJavaUses) {
        childInfo = resolveGroupingsQuailifiedInfo(((YangJavaUses) node.getChild()).getRefGroup(), yangPluginConfig);
        clsInfo = getCapitalCase(getCamelCase(((YangJavaUses) node.getChild()).getRefGroup().getName(), yangPluginConfig.getConflictResolver()));
    } else {
        String pkg = (rpcInfo.getPackage() + "." + rpcInfo.getJavaName() + "." + getCamelCase(node.getName(), yangPluginConfig.getConflictResolver())).toLowerCase();
        clsInfo = getCapitalCase(getCamelCase(node.getChild().getName(), yangPluginConfig.getConflictResolver()));
        childInfo.setPkgInfo(pkg);
        childInfo.setClassInfo(clsInfo);
    }
    boolean isList = false;
    if (node.getChild().getNodeType().equals(LIST_NODE)) {
        isList = true;
    }
    boolean isQualified = addImportToService(childInfo);
    JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(childInfo, clsInfo, null, isQualified, isList);
    setLeafHolderFlag(node, false);
    setSingleChildHolderFlag(node, true);
    return javaAttributeInfo;
}
#end_block

#method_before
public void resolveLinkingForResolutionInfo(YangReferenceResolver dataModelRootNode, boolean isGroupingCodeGenFlagSet) throws DataModelException {
    if (isGroupingCodeGenFlagSet) {
        setGroupingCodeGenFlagSet(true);
    }
    setCurReferenceResolver(dataModelRootNode);
    // Current node to resolve, it can be a YANG type or YANG uses.
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            /**
             * entity is already resolved, so nothing to do
             */
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    linkAndResolvePartialResolvedStack();
}
#method_after
public void resolveLinkingForResolutionInfo(YangReferenceResolver dataModelRootNode) throws DataModelException {
    setCurReferenceResolver(dataModelRootNode);
    // Current node to resolve, it can be a YANG type or YANG uses.
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            /**
             * entity is already resolved, so nothing to do
             */
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    linkAndResolvePartialResolvedStack();
}
#end_block

#method_before
private void resolveTopOfStack() throws DataModelException {
    if (isGroupingCodeGenFlagSet() && getCurrentEntityToResolveFromStack() instanceof YangUses) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(RESOLVED);
        return;
    }
    ((Resolvable) getCurrentEntityToResolveFromStack()).resolve();
    if (((Resolvable) getCurrentEntityToResolveFromStack()).getResolvableStatus() != INTRA_FILE_RESOLVED) {
        // Sets the resolution status in inside the type/uses.
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(RESOLVED);
    }
}
#method_after
private void resolveTopOfStack() throws DataModelException {
    ((Resolvable) getCurrentEntityToResolveFromStack()).resolve();
    if (((Resolvable) getCurrentEntityToResolveFromStack()).getResolvableStatus() != INTRA_FILE_RESOLVED) {
        // Sets the resolution status in inside the type/uses.
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(RESOLVED);
    }
}
#end_block

#method_before
public void linkInterFile(YangReferenceResolver dataModelRootNode, boolean isGroupingCodeGenFlagSet) throws DataModelException {
    setCurReferenceResolver(dataModelRootNode);
    // Current node to resolve, it can be a YANG type or YANG uses.
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is not Resolvable");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    // Inter file linking and resolution.
    linkInterFileAndResolve();
}
#method_after
public void linkInterFile(YangReferenceResolver dataModelRootNode) throws DataModelException {
    setCurReferenceResolver(dataModelRootNode);
    // Current node to resolve, it can be a YANG type or YANG uses.
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is not Resolvable");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    // Inter file linking and resolution.
    linkInterFileAndResolve();
}
#end_block

#method_before
@Override
public void resolveSelfFileLinking(boolean isGroupingCodeGenFlagSet) throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    resolveLinkingForResolutionList(resolutionList, this, isGroupingCodeGenFlagSet);
}
#method_after
@Override
public void resolveSelfFileLinking() throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    resolveLinkingForResolutionList(resolutionList, this);
}
#end_block

#method_before
@Override
public void resolveInterFileLinking(boolean isGroupingCodeGenFlagSet) throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    linkInterFileReferences(resolutionList, this, isGroupingCodeGenFlagSet);
}
#method_after
@Override
public void resolveInterFileLinking() throws DataModelException {
    // Get the list to be resolved.
    List<YangResolutionInfo> resolutionList = getUnresolvedResolutionList();
    // Resolve linking for a resolution list.
    linkInterFileReferences(resolutionList, this);
}
#end_block

#method_before
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
    topologyService = directory.get(TopologyService.class);
    tunnelService = directory.get(TunnelService.class);
    pceService = directory.get(PceService.class);
    addListeners();
}
#method_after
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
    topologyService = directory.get(TopologyService.class);
    tunnelService = directory.get(TunnelService.class);
    pceService = directory.get(PceService.class);
    deviceService = directory.get(DeviceService.class);
    topologyService.addListener(topologyListener);
    tunnelService.addListener(tunnelListener);
}
#end_block

#method_before
@Override
protected Collection<RequestHandler> createRequestHandlers() {
    return ImmutableSet.of(new ClearHandler(), new SetSrcHandler(), new SetDstHandler(), new SetPathHandler(), new UpdatePathQueryHandler(), new UpdatePathHandler(), new RemovePathQueryHandler(), new RemovePathHandler());
}
#method_after
@Override
protected Collection<RequestHandler> createRequestHandlers() {
    return ImmutableSet.of(new ClearHandler(), new SetSrcHandler(), new SetDstHandler(), new SetPathHandler(), new UpdatePathQueryHandler(), new UpdatePathHandler(), new RemovePathQueryHandler(), new RemovePathHandler(), new ShowTunnelHandler());
}
#end_block

#method_before
@Override
public void destroy() {
    removeListeners();
    super.destroy();
}
#method_after
@Override
public void destroy() {
    topologyService.removeListener(topologyListener);
    tunnelService.removeListener(tunnelListener);
    super.destroy();
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String bandWidth = string(payload, BANDWIDTH);
    String bandWidthType = string(payload, BANDWIDTHTYPE);
    String costType = string(payload, COSTTYPE);
    String lspType = string(payload, LSPTYPE);
    String tunnelName = string(payload, TUNNEL_ID);
    if (lspType == null) {
        log.error("PCE setup path is failed.");
    }
    findAndSendPaths(bandWidth, bandWidthType, costType, lspType, tunnelName);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String bandWidth = string(payload, BANDWIDTH);
    String bandWidthType = string(payload, BANDWIDTHTYPE);
    String costType = string(payload, COSTTYPE);
    String lspType = string(payload, LSPTYPE);
    String tunnelName = string(payload, TUNNEL_NAME);
    if (tunnelName.equals(STRING_NULL)) {
        log.error("tunnel name should not be empty");
        return;
    }
    if (pceService == null) {
        log.error("PCE service is not active");
        return;
    }
    if (lspType == null) {
        log.error("PCE setup path is failed.");
    }
    if ((src != null) && (dst != null)) {
        findAndSendPaths(src, dst, bandWidth, bandWidthType, costType, lspType, tunnelName);
    }
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Collection<Tunnel> tunnelSet = tunnelService.queryAllTunnels();
    if (tunnelSet != null) {
        ObjectNode result = objectNode();
        ArrayNode arrayNode = arrayNode();
        for (Tunnel tunnel : tunnelSet) {
            if (tunnel.path().src().deviceId().equals((DeviceId) src) && tunnel.path().dst().deviceId().equals((DeviceId) dst)) {
                arrayNode.add(tunnel.tunnelId().toString());
            }
        }
        result.putArray(BUFFER_ARRAY).addAll(arrayNode);
        sendMessage(PCEWEB_SHOW_TUNNEL, sid, result);
    }
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Device srcDevice = deviceService.getDevice((DeviceId) src);
    Device dstDevice = deviceService.getDevice((DeviceId) dst);
    TunnelEndPoint tunSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcDevice.annotations().value("lsrId")));
    TunnelEndPoint tunDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstDevice.annotations().value("lsrId")));
    Collection<Tunnel> tunnelSet = tunnelService.queryTunnel(tunSrc, tunDst);
    if (tunnelSet != null) {
        ObjectNode result = objectNode();
        ArrayNode arrayNode = arrayNode();
        for (Tunnel tunnel : tunnelSet) {
            if (tunnel.type() == MPLS) {
                arrayNode.add(tunnel.tunnelId().toString());
            }
        }
        result.putArray(BUFFER_ARRAY).addAll(arrayNode);
        sendMessage(PCEWEB_SHOW_TUNNEL, sid, result);
    }
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Collection<Tunnel> tunnelSet = tunnelService.queryAllTunnels();
    if (tunnelSet != null) {
        ObjectNode result = objectNode();
        ArrayNode arrayNode = arrayNode();
        for (Tunnel tunnel : tunnelSet) {
            if (tunnel.path().src().deviceId().equals((DeviceId) src) && tunnel.path().dst().deviceId().equals((DeviceId) dst)) {
                arrayNode.add(tunnel.tunnelId().toString());
            }
        }
        result.putArray(BUFFER_ARRAY).addAll(arrayNode);
        sendMessage(PCEWEB_SHOW_TUNNEL_REMOVE, sid, result);
    }
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Device srcDevice = deviceService.getDevice((DeviceId) src);
    Device dstDevice = deviceService.getDevice((DeviceId) dst);
    TunnelEndPoint tunSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcDevice.annotations().value("lsrId")));
    TunnelEndPoint tunDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstDevice.annotations().value("lsrId")));
    Collection<Tunnel> tunnelSet = tunnelService.queryTunnel(tunSrc, tunDst);
    if (tunnelSet != null) {
        ObjectNode result = objectNode();
        ArrayNode arrayNode = arrayNode();
        for (Tunnel tunnel : tunnelSet) {
            if (tunnel.type() == MPLS) {
                arrayNode.add(tunnel.tunnelId().toString());
            }
        }
        result.putArray(BUFFER_ARRAY).addAll(arrayNode);
        sendMessage(PCEWEB_SHOW_TUNNEL_REMOVE, sid, result);
    }
}
#end_block

#method_before
private void findAndSendPaths(String bandWidth, String bandWidthType, String costType, String lspType, String tunnelName) {
    log.debug("src={}; dst={};", src, dst);
    boolean path;
    Collection<Tunnel> tunnelSet = null;
    if ((src != null) && (dst != null)) {
        List<Constraint> listConstrnt = new LinkedList<>();
        if (tunnelName.equals(STRING_NULL)) {
            log.error("setup path is failed");
            return;
        }
        if (pceService == null) {
            log.error("PCE service is not active");
            return;
        }
        listConstrnt = addBandwidthCostTypeConstraints(bandWidth, bandWidthType, costType, listConstrnt);
        // LSP type
        LspType lspTypeVal = null;
        switch(lspType) {
            case LSP_TYPE_CR:
                lspTypeVal = LspType.WITH_SIGNALLING;
                break;
            case LSP_TYPE_SRBE:
                lspTypeVal = LspType.WITHOUT_SIGNALLING_AND_WITHOUT_SR;
                break;
            case LSP_TYPE_SRTE:
                lspTypeVal = LspType.SR_WITHOUT_SIGNALLING;
                break;
            default:
                log.error("Invalid LSP type");
                break;
        }
        path = pceService.setupPath((DeviceId) src, (DeviceId) dst, tunnelName, listConstrnt, lspTypeVal);
        if (!path) {
            log.error("setup path is failed");
            return;
        }
        tunnelSet = tunnelService.queryAllTunnels();
        if (tunnelSet != null) {
            for (Tunnel tunnel : tunnelSet) {
                if (tunnel.path() == null) {
                    log.error("path does not exist");
                    return;
                }
                paths.add(tunnel.path());
            }
            ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
            allPathLinks = buildPaths(builder).build();
            hilightAndSendPaths();
        }
    }
}
#method_after
private void findAndSendPaths(ElementId src, ElementId dst, String bandWidth, String bandWidthType, String costType, String lspType, String tunnelName) {
    log.debug("src={}; dst={};", src, dst);
    boolean path;
    List<Constraint> listConstrnt;
    listConstrnt = addBandwidthCostTypeConstraints(bandWidth, bandWidthType, costType);
    // LSP type
    LspType lspTypeVal = null;
    switch(lspType) {
        case LSP_TYPE_CR:
            lspTypeVal = LspType.WITH_SIGNALLING;
            break;
        case LSP_TYPE_SRBE:
            lspTypeVal = LspType.WITHOUT_SIGNALLING_AND_WITHOUT_SR;
            break;
        case LSP_TYPE_SRTE:
            lspTypeVal = LspType.SR_WITHOUT_SIGNALLING;
            break;
        default:
            log.error("Invalid LSP type");
            break;
    }
    path = pceService.setupPath((DeviceId) src, (DeviceId) dst, tunnelName, listConstrnt, lspTypeVal);
    if (!path) {
        log.error("setup path is failed");
        return;
    }
    return;
}
#end_block

#method_before
private void findAndSendPathsUpdate(String bandWidth, String bandWidthType, String costType, String tunnelName) {
    if (tunnelName != null) {
        List<Constraint> listConstrnt = new LinkedList<>();
        Collection<Tunnel> tunnelSet = null;
        if (tunnelName.equals(STRING_NULL)) {
            log.error("update path is failed");
            return;
        }
        if (pceService == null) {
            log.error("PCE service is not active");
            return;
        }
        listConstrnt = addBandwidthCostTypeConstraints(bandWidth, bandWidthType, costType, listConstrnt);
        TunnelId tunnelId = TunnelId.valueOf(tunnelName);
        boolean path = pceService.updatePath(tunnelId, listConstrnt);
        if (!path) {
            log.error("update path is failed");
            return;
        }
        tunnelSet = tunnelService.queryAllTunnels();
        if (tunnelSet != null) {
            for (Tunnel tunnel : tunnelSet) {
                if (tunnel.path() == null) {
                    log.info("path does not exist");
                    return;
                }
                paths.add(tunnel.path());
            }
            ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
            allPathLinks = buildPaths(builder).build();
            hilightAndSendPaths();
        }
    }
}
#method_after
private void findAndSendPathsUpdate(String bandWidth, String bandWidthType, String costType, String tunnelIdStr) {
    if (tunnelIdStr != null) {
        List<Constraint> listConstrnt;
        if (tunnelIdStr.equals(STRING_NULL)) {
            log.error("update path is failed");
            return;
        }
        if (pceService == null) {
            log.error("PCE service is not active");
            return;
        }
        listConstrnt = addBandwidthCostTypeConstraints(bandWidth, bandWidthType, costType);
        TunnelId tunnelId = TunnelId.valueOf(tunnelIdStr);
        boolean path = pceService.updatePath(tunnelId, listConstrnt);
        if (!path) {
            log.error("update path is failed");
            return;
        }
    }
    return;
}
#end_block

#method_before
private void findAndSendPathsRemove(String tunnelIdName) {
    Collection<Tunnel> tunnelSet = null;
    if (tunnelIdName != null) {
        if (pceService == null) {
            log.error("PCE service is not active");
            return;
        }
        TunnelId tunnelId = TunnelId.valueOf(tunnelIdName);
        boolean path = pceService.releasePath(tunnelId);
        if (!path) {
            log.error("remove path is failed");
            return;
        }
        tunnelSet = tunnelService.queryAllTunnels();
        for (Tunnel tunnel : tunnelSet) {
            if (tunnel.path() == null) {
                log.info("path does not exist");
                return;
            }
            paths.add(tunnel.path());
        }
        ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
        allPathLinks = buildPaths(builder).build();
        hilightAndSendPaths();
    }
}
#method_after
private void findAndSendPathsRemove(String tunnelIdStr) {
    if (tunnelIdStr != null) {
        if (pceService == null) {
            log.error("PCE service is not active");
            return;
        }
        TunnelId tunnelId = TunnelId.valueOf(tunnelIdStr);
        boolean path = pceService.releasePath(tunnelId);
        if (!path) {
            log.error("remove path is failed");
            return;
        }
    }
    return;
}
#end_block

#method_before
private List<Constraint> addBandwidthCostTypeConstraints(String bandWidth, String bandWidthType, String costType, List<Constraint> listConstrnt) {
    // bandwidth
    double bwValue = 0.0;
    if (!bandWidth.equals(STRING_NULL)) {
        bwValue = Double.parseDouble(bandWidth);
    }
    if (bandWidthType.equals(BANDWIDTH_TYPE_KBPS)) {
        bwValue = bwValue * BANDWIDTH_KBPS;
    } else {
        bwValue = bwValue * BANDWIDTH_MBPS;
    }
    // Cost type
    CostConstraint.Type costTypeVal = null;
    switch(costType) {
        case COST_TYPE_IGP:
            costTypeVal = CostConstraint.Type.COST;
            break;
        case COST_TYPE_TE:
            costTypeVal = CostConstraint.Type.TE_COST;
            break;
        default:
            log.error("Invalid cost type");
            break;
    }
    if (bwValue != 0.0) {
        listConstrnt.add((Constraint) Bandwidth.of(bwValue, DataRateUnit.valueOf(BANDWIDTH_BPS)));
    }
    if (null != costTypeVal) {
        listConstrnt.add(CostConstraint.of(costTypeVal));
    }
    return listConstrnt;
}
#method_after
private List<Constraint> addBandwidthCostTypeConstraints(String bandWidth, String bandWidthType, String costType) {
    List<Constraint> listConstrnt = new LinkedList<>();
    // bandwidth
    double bwValue = 0.0;
    if (!bandWidth.equals(STRING_NULL)) {
        bwValue = Double.parseDouble(bandWidth);
    }
    if (bandWidthType.equals(BANDWIDTH_TYPE_KBPS)) {
        bwValue = bwValue * BANDWIDTH_KBPS;
    } else {
        bwValue = bwValue * BANDWIDTH_MBPS;
    }
    // Cost type
    CostConstraint.Type costTypeVal = null;
    switch(costType) {
        case COST_TYPE_IGP:
            costTypeVal = CostConstraint.Type.COST;
            break;
        case COST_TYPE_TE:
            costTypeVal = CostConstraint.Type.TE_COST;
            break;
        default:
            log.error("Invalid cost type");
            break;
    }
    if (bwValue != 0.0) {
        listConstrnt.add(BandwidthConstraint.of(bwValue, DataRateUnit.valueOf(BANDWIDTH_BPS)));
    }
    if (costTypeVal != null) {
        listConstrnt.add(CostConstraint.of(costTypeVal));
    }
    return listConstrnt;
}
#end_block

#method_before
private void findTunnelAndHighlights() {
    Collection<Tunnel> tunnelSet = null;
    tunnelSet = tunnelService.queryAllTunnels();
    if (tunnelSet != null) {
        for (Tunnel tunnel : tunnelSet) {
            if (tunnel.path() == null) {
                log.info("path does not exist");
                return;
            }
            paths.add(tunnel.path());
        }
        ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
        allPathLinks = buildPaths(builder).build();
        hilightAndSendPaths();
    }
}
#method_after
private void findTunnelAndHighlights() {
    Collection<Tunnel> tunnelSet = null;
    tunnelSet = tunnelService.queryTunnel(MPLS);
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.path() == null) {
            log.info("path does not exist");
            return;
        }
        paths.add(tunnel.path());
    }
    ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
    allPathLinks = buildPaths(builder).build();
    hilightAndSendPaths();
}
#end_block

#method_before
@Override
public void sendPacketIn(PccId pccId) {
    Ethernet eth;
    IPv4 ipv4;
    ipv4 = new IPv4();
    eth = new Ethernet();
    eth.setEtherType(Ethernet.TYPE_IPV4);
    eth.setPayload(ipv4);
    eth.setSourceMACAddress(mac + srcHost).setDestinationMACAddress(mac + dstHost);
    // Get lsrId of the PCEP client from the PCC ID. Session info is based on lsrID.
    String lsrId = String.valueOf(pccId.ipAddress());
    DeviceId pccDeviceId = null;
    // Find PCC deviceID from lsrId stored as annotations
    Iterable<Device> devices = deviceService.getAvailableDevices();
    for (Device dev : devices) {
        if ("L3".equals(dev.annotations().value(AnnotationKeys.TYPE)) && lsrId.equals(dev.annotations().value(LSRID))) {
            pccDeviceId = dev.id();
        }
    }
    if (pccDeviceId == null) {
        return;
    }
    InboundPacket inPkt = new DefaultInboundPacket(new ConnectPoint(pccDeviceId, PortNumber.portNumber(srcHost)), eth, ByteBuffer.wrap(eth.serialize()));
    packetProviderService.processPacket(new PcepPacketContext(inPkt, null));
}
#method_after
@Override
public void sendPacketIn(PccId pccId) {
    TCP tcp = new TCP();
    // Set the well known PCEP port. To be used to decide to process/discard the packet while processing.
    tcp.setDestinationPort(PCEP_PORT);
    IPv4 ipv4 = new IPv4();
    ipv4.setProtocol(IPv4.PROTOCOL_TCP);
    ipv4.setPayload(tcp);
    Ethernet eth = new Ethernet();
    eth.setEtherType(Ethernet.TYPE_IPV4);
    eth.setPayload(ipv4);
    // Get lsrId of the PCEP client from the PCC ID. Session info is based on lsrID.
    String lsrId = String.valueOf(pccId.ipAddress());
    DeviceId pccDeviceId = null;
    // Find PCC deviceID from lsrId stored as annotations
    Iterable<Device> devices = deviceService.getAvailableDevices();
    for (Device dev : devices) {
        if ("L3".equals(dev.annotations().value(AnnotationKeys.TYPE)) && lsrId.equals(dev.annotations().value(LSRID))) {
            pccDeviceId = dev.id();
            break;
        }
    }
    if (pccDeviceId == null) {
        return;
    }
    InboundPacket inPkt = new DefaultInboundPacket(new ConnectPoint(pccDeviceId, PortNumber.portNumber(PCEP_PORT)), eth, null);
    packetProviderService.processPacket(new PcepPacketContext(inPkt, null));
}
#end_block

#method_before
@Override
public void send() {
// We don't send anything out.
}
#method_after
@Override
public void send() {
    // We don't send anything out.
    return;
}
#end_block

#method_before
@Override
public void emit(OutboundPacket packet) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void emit(OutboundPacket packet) {
    // Nothing to emit
    return;
}
#end_block

#method_before
@Override
public void processClientMessage(PccId pccId, PcepMessage msg) {
    PcepClient pc = getClient(pccId);
    switch(msg.getType()) {
        case NONE:
            break;
        case OPEN:
            break;
        case KEEP_ALIVE:
            break;
        case PATH_COMPUTATION_REQUEST:
            break;
        case PATH_COMPUTATION_REPLY:
            break;
        case NOTIFICATION:
            break;
        case ERROR:
            break;
        case INITIATE:
            if (!pc.capability().pcInstantiationCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case UPDATE:
            if (!pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case LABEL_UPDATE:
            if (!pc.capability().pceccCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case CLOSE:
            log.info("Sending Close Message  to {" + pccId.toString() + "}");
            pc.sendMessage(Collections.singletonList(pc.factory().buildCloseMsg().build()));
            // now disconnect client
            pc.disconnectClient();
            break;
        case REPORT:
            // Only update the listener if respective capability is supported else send PCEP-ERR msg
            if (pc.capability().statefulPceCapability()) {
                ListIterator<PcepStateReport> listIterator = ((PcepReportMsg) msg).getStateReportList().listIterator();
                while (listIterator.hasNext()) {
                    PcepStateReport stateRpt = listIterator.next();
                    if (stateRpt.getLspObject().getSFlag()) {
                        if (pc.lspDbSyncStatus() != PcepSyncStatus.IN_SYNC) {
                            pc.setLspDbSyncStatus(PcepSyncStatus.IN_SYNC);
                            pc.initializeSyncMsgList(pccId);
                        }
                        // Store stateRpt in temporary cache.
                        pc.addSyncMsgToList(pccId, stateRpt);
                        // Don't send to provider as of now.
                        continue;
                    } else {
                        if (pc.lspDbSyncStatus() == PcepSyncStatus.IN_SYNC) {
                            // Means end of sync.
                            pc.setLspDbSyncStatus(PcepSyncStatus.SYNCED);
                            if (pc.capability().pceccCapability()) {
                                pc.setLabelDbSyncStatus(IN_SYNC);
                                // Call packet provider to initiate label DB sync.
                                for (PcepPacketListener l : pcepPacketListener) {
                                    l.sendPacketIn(pccId);
                                }
                            } else {
                                // Handle end of LSPDB sync actions.
                                agent.analyzeSyncMsgList(pccId);
                            }
                            continue;
                        }
                    }
                    LinkedList<PcepStateReport> llPcRptList = new LinkedList<>();
                    llPcRptList.add(stateRpt);
                    PcepMessage pcReportMsg = pc.factory().buildReportMsg().setStateReportList((llPcRptList)).build();
                    for (PcepEventListener l : pcepEventListener) {
                        l.handleMessage(pccId, pcReportMsg);
                    }
                }
            } else {
                // Send PCEP-ERROR message.
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case LABEL_RANGE_RESERV:
            break;
        case // TODO: need to handle LS report to add or remove node
        LS_REPORT:
            break;
        case MAX:
            break;
        case END:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void processClientMessage(PccId pccId, PcepMessage msg) {
    PcepClient pc = getClient(pccId);
    switch(msg.getType()) {
        case NONE:
            break;
        case OPEN:
            break;
        case KEEP_ALIVE:
            break;
        case PATH_COMPUTATION_REQUEST:
            break;
        case PATH_COMPUTATION_REPLY:
            break;
        case NOTIFICATION:
            break;
        case ERROR:
            break;
        case INITIATE:
            if (!pc.capability().pcInstantiationCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case UPDATE:
            if (!pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case LABEL_UPDATE:
            if (!pc.capability().pceccCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case CLOSE:
            log.info("Sending Close Message  to {" + pccId.toString() + "}");
            pc.sendMessage(Collections.singletonList(pc.factory().buildCloseMsg().build()));
            // now disconnect client
            pc.disconnectClient();
            break;
        case REPORT:
            // Only update the listener if respective capability is supported else send PCEP-ERR msg
            if (pc.capability().statefulPceCapability()) {
                ListIterator<PcepStateReport> listIterator = ((PcepReportMsg) msg).getStateReportList().listIterator();
                while (listIterator.hasNext()) {
                    PcepStateReport stateRpt = listIterator.next();
                    if (stateRpt.getLspObject().getSFlag()) {
                        if (pc.lspDbSyncStatus() != PcepSyncStatus.IN_SYNC) {
                            // Initialize LSP DB sync and temporary cache.
                            pc.setLspDbSyncStatus(PcepSyncStatus.IN_SYNC);
                            pc.initializeSyncMsgList(pccId);
                        }
                        // Store stateRpt in temporary cache.
                        pc.addSyncMsgToList(pccId, stateRpt);
                        // Don't send to provider as of now.
                        continue;
                    } else {
                        if (pc.lspDbSyncStatus() == PcepSyncStatus.IN_SYNC) {
                            // Set end of LSPDB sync.
                            pc.setLspDbSyncStatus(PcepSyncStatus.SYNCED);
                            // Call packet provider to initiate label DB sync (only if PCECC capable).
                            if (pc.capability().pceccCapability()) {
                                pc.setLabelDbSyncStatus(IN_SYNC);
                                for (PcepPacketListener l : pcepPacketListener) {
                                    l.sendPacketIn(pccId);
                                }
                            } else {
                                // If label db sync is not to be done, handle end of LSPDB sync actions.
                                agent.analyzeSyncMsgList(pccId);
                            }
                            continue;
                        }
                    }
                    // It's a usual report message while sync is not undergoing. So process it immediately.
                    LinkedList<PcepStateReport> llPcRptList = new LinkedList<>();
                    llPcRptList.add(stateRpt);
                    PcepMessage pcReportMsg = pc.factory().buildReportMsg().setStateReportList((llPcRptList)).build();
                    for (PcepEventListener l : pcepEventListener) {
                        l.handleMessage(pccId, pcReportMsg);
                    }
                }
            } else {
                // Send PCEP-ERROR message.
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case LABEL_RANGE_RESERV:
            break;
        case // TODO: need to handle LS report to add or remove node
        LS_REPORT:
            break;
        case MAX:
            break;
        case END:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public boolean analyzeSyncMsgList(PccId pccId) {
    PcepClient pc = getClient(pccId);
    Map<TunnelId, Tunnel> preSyncLspDb = new HashMap<>();
    Collection<Tunnel> queriedTunnels = tunnelService.queryTunnel(Tunnel.Type.MPLS);
    for (Tunnel tunnel : queriedTunnels) {
        if (((IpTunnelEndPoint) tunnel.src()).ip().equals(pccId.ipAddress())) {
            preSyncLspDb.put(tunnel.tunnelId(), tunnel);
        }
    }
    List<PcepStateReport> syncStateRptList = pc.getSyncMsgList(pccId);
    Iterator<PcepStateReport> stateRptListIterator = syncStateRptList.iterator();
    while (syncStateRptList.iterator().hasNext()) {
        PcepStateReport stateRpt = stateRptListIterator.next();
        Tunnel tunnel = null;
        PcepLspObject lspObj = stateRpt.getLspObject();
        ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
        StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
        SymbolicPathNameTlv pathNameTlv = null;
        while (listTlvIterator.hasNext()) {
            PcepValueType tlv = listTlvIterator.next();
            switch(tlv.getType()) {
                case StatefulIPv4LspIdentifiersTlv.TYPE:
                    ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                    break;
                case SymbolicPathNameTlv.TYPE:
                    pathNameTlv = (SymbolicPathNameTlv) tlv;
                    break;
                default:
                    break;
            }
        }
        for (Tunnel tunnelObj : preSyncLspDb.values()) {
            if (tunnelObj.annotations().value(PLSP_ID) == null) {
                /*
                         * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is
                         * allocated by PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and
                         * hence symbolic path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME
                         * TLV "MUST" be included in the LSP object in the LSP State Report (PCRpt) message when during
                         * a given PCEP session an LSP is "first" reported to a PCE.
                         */
                if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                    tunnel = tunnelObj;
                    break;
                }
                continue;
            }
            if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Short.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
                tunnel = tunnelObj;
                break;
            }
        }
        if (tunnel == null) {
            if (lspObj.getCFlag() && !lspObj.getRFlag()) {
                // For initiated LSP, need to send PCInit delete msg.
                try {
                    PcInitiatedLspRequest releaseLspRequest = pc.factory().buildPcInitiatedLspRequest().setLspObject(lspObj).build();
                    LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
                    llPcInitiatedLspRequestList.add(releaseLspRequest);
                    PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
                    for (PcepEventListener l : pcepEventListener) {
                        l.handleEndOfSyncAction(pccId, pcInitiateMsg, SEND_DELETE);
                    }
                } catch (PcepParseException e) {
                    log.error("Exception occured while sending initiate delete message {}", e.getMessage());
                }
            }
            continue;
        }
        // PCE tunnel is matched with PCRpt LSP. Now delete it from the preSyncLspDb list as the residual
        // non-matching list will be processed at the end.
        preSyncLspDb.remove(tunnel.tunnelId());
        if (!lspObj.getCFlag()) {
            // For learned LSP process both add/update PCRpt.
            LinkedList<PcepStateReport> llPcRptList = new LinkedList<>();
            llPcRptList.add(stateRpt);
            PcepMessage pcReportMsg = pc.factory().buildReportMsg().setStateReportList((llPcRptList)).build();
            for (PcepEventListener l : pcepEventListener) {
                l.handleMessage(pccId, pcReportMsg);
            }
            continue;
        }
        // Implied that tunnel != null and lspObj.getCFlag() is set
        // State different for PCC sent LSP and PCE known LSP, send PCUpd msg.
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
        if (tunnelState != tunnel.state()) {
            for (PcepEventListener l : pcepEventListener) {
                l.handleEndOfSyncAction(tunnel, SEND_UPDATE);
            }
        }
    }
    // Check which tunnels are extra at PCE that were not reported by PCC.
    for (Tunnel pceExtraTunnel : preSyncLspDb.values()) {
        if (pceExtraTunnel.annotations().value(PCE_INIT) == null || "false".equalsIgnoreCase(pceExtraTunnel.annotations().value(PCE_INIT))) {
            for (PcepEventListener l : pcepEventListener) {
                l.handleEndOfSyncAction(pceExtraTunnel, REMOVE);
            }
        } else {
            for (PcepEventListener l : pcepEventListener) {
                l.handleEndOfSyncAction(pceExtraTunnel, UNSTABLE);
            }
        }
    }
    pc.removeSyncMsgList(pccId);
    return true;
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
@Override
public boolean analyzeSyncMsgList(PccId pccId) {
    PcepClient pc = getClient(pccId);
    /*
             * PLSP_ID is null while tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by PCC and
             * in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic path name must be
             * carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be included in the LSP object in
             * the LSP State Report (PCRpt) message when during a given PCEP session an LSP is "first" reported to a
             * PCE. So two separate lists with separate keys are maintained.
             */
    Map<LspKey, Tunnel> preSyncLspDbByKey = new HashMap<>();
    Map<String, Tunnel> preSyncLspDbByName = new HashMap<>();
    // Query tunnel service and fetch all the tunnels with this PCC as ingress.
    // Organize into two maps, with LSP key if known otherwise with symbolic path name, for quick search.
    Collection<Tunnel> queriedTunnels = tunnelService.queryTunnel(Tunnel.Type.MPLS);
    for (Tunnel tunnel : queriedTunnels) {
        if (((IpTunnelEndPoint) tunnel.src()).ip().equals(pccId.ipAddress())) {
            String pLspId = tunnel.annotations().value(PLSP_ID);
            if (pLspId != null) {
                String localLspId = tunnel.annotations().value(LOCAL_LSP_ID);
                checkNotNull(localLspId);
                LspKey lspKey = new LspKey(Integer.valueOf(pLspId), Short.valueOf(localLspId));
                preSyncLspDbByKey.put(lspKey, tunnel);
            } else {
                preSyncLspDbByName.put(tunnel.tunnelName().value(), tunnel);
            }
        }
    }
    List<PcepStateReport> syncStateRptList = pc.getSyncMsgList(pccId);
    Iterator<PcepStateReport> stateRptListIterator = syncStateRptList.iterator();
    // For every report, fetch PLSP id, local LSP id and symbolic path name from the message.
    while (syncStateRptList.iterator().hasNext()) {
        PcepStateReport stateRpt = stateRptListIterator.next();
        Tunnel tunnel = null;
        PcepLspObject lspObj = stateRpt.getLspObject();
        ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
        StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
        SymbolicPathNameTlv pathNameTlv = null;
        while (listTlvIterator.hasNext()) {
            PcepValueType tlv = listTlvIterator.next();
            switch(tlv.getType()) {
                case StatefulIPv4LspIdentifiersTlv.TYPE:
                    ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                    break;
                case SymbolicPathNameTlv.TYPE:
                    pathNameTlv = (SymbolicPathNameTlv) tlv;
                    break;
                default:
                    break;
            }
        }
        LspKey lspKeyOfRpt = new LspKey(lspObj.getPlspId(), ipv4LspIdenTlv.getLspId());
        tunnel = preSyncLspDbByKey.get(lspKeyOfRpt);
        // non-matching list will be processed at the end.
        if (tunnel != null) {
            preSyncLspDbByKey.remove(lspKeyOfRpt);
        } else if (pathNameTlv != null) {
            tunnel = preSyncLspDbByName.get(Arrays.toString(pathNameTlv.getValue()));
            if (tunnel != null) {
                preSyncLspDbByName.remove(tunnel.tunnelName());
            }
        }
        if (tunnel == null) {
            // If remove flag is set, and tunnel is not known to PCE, ignore it.
            if (lspObj.getCFlag() && !lspObj.getRFlag()) {
                // For initiated LSP, need to send PCInit delete msg.
                try {
                    PcInitiatedLspRequest releaseLspRequest = pc.factory().buildPcInitiatedLspRequest().setLspObject(lspObj).build();
                    LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
                    llPcInitiatedLspRequestList.add(releaseLspRequest);
                    PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
                    for (PcepEventListener l : pcepEventListener) {
                        l.handleEndOfSyncAction(pccId, pcInitiateMsg, SEND_DELETE);
                    }
                } catch (PcepParseException e) {
                    log.error("Exception occured while sending initiate delete message {}", e.getMessage());
                }
            }
            continue;
        }
        if (!lspObj.getCFlag()) {
            // For learned LSP process both add/update PCRpt.
            LinkedList<PcepStateReport> llPcRptList = new LinkedList<>();
            llPcRptList.add(stateRpt);
            PcepMessage pcReportMsg = pc.factory().buildReportMsg().setStateReportList((llPcRptList)).build();
            for (PcepEventListener l : pcepEventListener) {
                l.handleMessage(pccId, pcReportMsg);
            }
            continue;
        }
        // Implied that tunnel != null and lspObj.getCFlag() is set
        // State different for PCC sent LSP and PCE known LSP, send PCUpd msg.
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
        if (tunnelState != tunnel.state()) {
            for (PcepEventListener l : pcepEventListener) {
                l.handleEndOfSyncAction(tunnel, SEND_UPDATE);
            }
        }
    }
    // Check which tunnels are extra at PCE that were not reported by PCC.
    Map<Object, Tunnel> preSyncLspDb = (Map) preSyncLspDbByKey;
    handleResidualTunnels(preSyncLspDb);
    preSyncLspDbByKey = null;
    preSyncLspDb = (Map) preSyncLspDbByName;
    handleResidualTunnels(preSyncLspDb);
    preSyncLspDbByName = null;
    preSyncLspDb = null;
    pc.removeSyncMsgList(pccId);
    return true;
}
#end_block

#method_before
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    String costType = null;
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    ListIterator<PcepMetricObject> iterator = msgPath.getPcepAttribute().getMetricObjectList().listIterator();
    PcepMetricObject metricObj = iterator.next();
    int cost = 0;
    while (metricObj != null) {
        if (metricObj.getBType() == IGP_METRIC) {
            costType = "COST";
        } else if (metricObj.getBType() == TE_METRIC) {
            costType = "TE_COST";
        }
        if (costType != null) {
            cost = metricObj.getMetricVal();
            log.debug("Path cost {}", cost);
        }
    }
    Path path = buildPathFromEroObj(eroObj, providerId, cost);
    float bandwidth = 0;
    if (msgPath.getBandwidthObject() != null) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    /*
             * To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
             * from PCE.
             */
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = getLspType(srpObj);
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    // not present then non-delegated , if present it is delegated.
    if (lspObj.getDFlag()) {
        pcepClientController.getClient(pccId).setLspAndDelegationInfo(new LspKey(lspObj.getPlspId(), ipv4LspIdenTlv.getLspId()), lspObj.getDFlag());
    }
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    SparseAnnotations annotations = null;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        DeviceId deviceId = getDevice(pccId);
        if (deviceId == null) {
            log.error("Ingress deviceId not found");
            return;
        }
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, costType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        // Do not support PCC initiated LSP after LSP DB sync is completed.
        if (!lspObj.getSFlag() && !lspObj.getCFlag()) {
            log.error("Received PCC initiated LSP while not in sync.");
            return;
        }
        /*
                 * If ONOS instance is master for PCC then set delegated flag as annotation and add the tunnel to store.
                 * Because all LSPs need not be delegated, hence mastership for the PCC is confirmed whereas not the
                 * delegation set to all LSPs.If ONOS is not the master for that PCC then check if D flag is set, if yes
                 * wait for 2 seconds [while master has added the tunnel to the store] then update the tunnel. Tunnel is
                 * updated because in case of resilency only delegated LSPs are recomputed and only delegated PCE can
                 * send update message to that client.
                 *
                 * 1)Master can 1st get the Rpt message
                 * a)Master adds the tunnel into core.
                 * b)If a non-master for ingress gets Rpt message with D flag set[as delegation owner]
                 *  after master, then runs timer then update the tunnel with D flag set.
                 * 2)Non-Master can 1st get the Rpt message
                 * a)Non-Master runs the timer check for the tunnel then updates the tunnel with D flag set
                 * b)Master would have got the message while the non-master running timer, hence master adds
                 *  tunnel to core
                 *
                 * In general always master adds the tunnel to the core
                 * while delegated owner [master or non-master with D flag set] always updates the tunnel running timer
                 */
        if (mastershipService.isLocalMaster(deviceId)) {
            TunnelId tId = tunnelAdded(td, tunnelState);
            Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        } else if (!mastershipService.isLocalMaster(deviceId) && lspObj.getDFlag()) {
            // Start timer then update the tunnel with D flag
            tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
        }
        return;
    }
    // delegated owner will update can be a master or non-master
    if (lspObj.getDFlag()) {
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, costType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
    }
    removeOrUpdatetunnel(tunnel, pccId, lspObj, providerId, tunnelState);
    return;
}
#method_after
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    String costType = null;
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    PcepAttribute attributes = msgPath.getPcepAttribute();
    int cost = 0;
    if (attributes != null && attributes.getMetricObjectList() != null) {
        ListIterator<PcepMetricObject> iterator = attributes.getMetricObjectList().listIterator();
        PcepMetricObject metricObj = iterator.next();
        while (metricObj != null) {
            if (metricObj.getBType() == IGP_METRIC) {
                costType = "COST";
            } else if (metricObj.getBType() == TE_METRIC) {
                costType = "TE_COST";
            }
            if (costType != null) {
                cost = metricObj.getMetricVal();
                log.debug("Path cost {}", cost);
                break;
            }
            metricObj = iterator.next();
        }
    }
    Path path = buildPathFromEroObj(eroObj, providerId, cost);
    float bandwidth = 0;
    if (msgPath.getBandwidthObject() != null) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    /*
             * To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
             * from PCE.
             */
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = getLspType(srpObj);
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    // not present then non-delegated , if present it is delegated.
    if (lspObj.getDFlag()) {
        pcepClientController.getClient(pccId).setLspAndDelegationInfo(new LspKey(lspObj.getPlspId(), ipv4LspIdenTlv.getLspId()), lspObj.getDFlag());
    }
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    SparseAnnotations annotations = null;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        DeviceId deviceId = getDevice(pccId);
        if (deviceId == null) {
            log.error("Ingress deviceId not found");
            return;
        }
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, costType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        // Do not support PCC initiated LSP after LSP DB sync is completed.
        if (!lspObj.getSFlag() && !lspObj.getCFlag()) {
            log.error("Received PCC initiated LSP while not in sync.");
            return;
        }
        /*
                 * If ONOS instance is master for PCC then set delegated flag as annotation and add the tunnel to store.
                 * Because all LSPs need not be delegated, hence mastership for the PCC is confirmed whereas not the
                 * delegation set to all LSPs.If ONOS is not the master for that PCC then check if D flag is set, if yes
                 * wait for 2 seconds [while master has added the tunnel to the store] then update the tunnel. Tunnel is
                 * updated because in case of resilency only delegated LSPs are recomputed and only delegated PCE can
                 * send update message to that client.
                 *
                 * 1)Master can 1st get the Rpt message
                 * a)Master adds the tunnel into core.
                 * b)If a non-master for ingress gets Rpt message with D flag set[as delegation owner]
                 *  after master, then runs timer then update the tunnel with D flag set.
                 * 2)Non-Master can 1st get the Rpt message
                 * a)Non-Master runs the timer check for the tunnel then updates the tunnel with D flag set
                 * b)Master would have got the message while the non-master running timer, hence master adds
                 *  tunnel to core
                 *
                 * In general always master adds the tunnel to the core
                 * while delegated owner [master or non-master with D flag set] always updates the tunnel running timer
                 */
        if (mastershipService.isLocalMaster(deviceId)) {
            TunnelId tId = tunnelAdded(td, tunnelState);
            Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        } else if (!mastershipService.isLocalMaster(deviceId) && lspObj.getDFlag()) {
            // Start timer then update the tunnel with D flag
            tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
        }
        return;
    }
    // delegated owner will update can be a master or non-master
    if (lspObj.getDFlag()) {
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, costType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
    }
    removeOrUpdatetunnel(tunnel, pccId, lspObj, providerId, tunnelState);
    return;
}
#end_block

#method_before
@Override
public boolean setupPath(DeviceId src, DeviceId dst, String tunnelName, List<Constraint> constraints, LspType lspType) {
    checkNotNull(src);
    checkNotNull(dst);
    checkNotNull(tunnelName);
    checkNotNull(constraints);
    checkNotNull(lspType);
    // Convert from DeviceId to TunnelEndPoint
    Device srcDevice = deviceService.getDevice(src);
    Device dstDevice = deviceService.getDevice(dst);
    if (srcDevice == null || dstDevice == null) {
        // Device is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    // In future projections instead of annotations will be used to fetch LSR ID.
    String srcLsrId = srcDevice.annotations().value(LSRID);
    String dstLsrId = dstDevice.annotations().value(LSRID);
    if (srcLsrId == null || dstLsrId == null) {
        // LSR id is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    TunnelEndPoint srcEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcLsrId));
    TunnelEndPoint dstEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstLsrId));
    double bwConstraintValue = 0;
    constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspType.name())));
    Iterator<Constraint> iterator = constraints.iterator();
    CostConstraint costConstraint = null;
    while (iterator.hasNext()) {
        Constraint constraint = iterator.next();
        if (constraint instanceof BandwidthConstraint) {
            bwConstraintValue = ((BandwidthConstraint) constraint).bandwidth().bps();
        } else if (constraint instanceof CostConstraint) {
            // Add cost at the end of the list of constraints.
            costConstraint = (CostConstraint) constraint;
        }
    }
    if (costConstraint != null) {
        constraints.remove(costConstraint);
        constraints.add(costConstraint);
    }
    Set<Path> computedPathSet = computePath(src, dst, constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    annotationBuilder.set(LSP_SIG_TYPE, lspType.name());
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    annotationBuilder.set(COST_TYPE, String.valueOf(costConstraint.type()));
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    if (lspType == SR_WITHOUT_SIGNALLING) {
        labelStack = srTeHandler.computeLabelStack(computedPath);
        // Failed to form a label stack.
        if (labelStack == null) {
            pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
            return false;
        }
    }
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(getNextLocalLspId()));
    }
    // For SR-TE tunnels, call SR manager for label stack and put it inside tunnel.
    Tunnel tunnel = new DefaultTunnel(null, srcEndPoint, dstEndPoint, MPLS, INIT, null, null, TunnelName.tunnelName(tunnelName), computedPath, labelStack, annotationBuilder.build());
    TunnelId tunnelId = tunnelService.setupTunnel(appId, src, tunnel, computedPath);
    if (tunnelId == null) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    // Allocate bandwidth.
    if (bwConstraintValue != 0) {
        TunnelConsumerId consumerId = reserveBandwidth(computedPath, bwConstraintValue, null);
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(tunnelId, pceccTunnelInfo);
    }
    return true;
}
#method_after
@Override
public boolean setupPath(DeviceId src, DeviceId dst, String tunnelName, List<Constraint> constraints, LspType lspType) {
    checkNotNull(src);
    checkNotNull(dst);
    checkNotNull(tunnelName);
    checkNotNull(lspType);
    // Convert from DeviceId to TunnelEndPoint
    Device srcDevice = deviceService.getDevice(src);
    Device dstDevice = deviceService.getDevice(dst);
    if (srcDevice == null || dstDevice == null) {
        // Device is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    // In future projections instead of annotations will be used to fetch LSR ID.
    String srcLsrId = srcDevice.annotations().value(LSRID);
    String dstLsrId = dstDevice.annotations().value(LSRID);
    if (srcLsrId == null || dstLsrId == null) {
        // LSR id is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    TunnelEndPoint srcEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcLsrId));
    TunnelEndPoint dstEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstLsrId));
    double bwConstraintValue = 0;
    CostConstraint costConstraint = null;
    if (constraints != null) {
        constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspType.name())));
        Iterator<Constraint> iterator = constraints.iterator();
        while (iterator.hasNext()) {
            Constraint constraint = iterator.next();
            if (constraint instanceof BandwidthConstraint) {
                bwConstraintValue = ((BandwidthConstraint) constraint).bandwidth().bps();
            } else if (constraint instanceof CostConstraint) {
                costConstraint = (CostConstraint) constraint;
            }
        }
        /*
             * Add cost at the end of the list of constraints. The path computation algorithm also computes cumulative
             * cost. The function which checks the limiting/capability constraints also returns per link cost. This
             * function can either return the result of limiting/capability constraint validation or the value of link
             * cost, depending upon what is the last constraint in the loop.
             */
        if (costConstraint != null) {
            constraints.remove(costConstraint);
            constraints.add(costConstraint);
        }
    } else {
        constraints = new LinkedList<>();
        constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspType.name())));
    }
    Set<Path> computedPathSet = computePath(src, dst, constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    if (bwConstraintValue != 0) {
        annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    }
    if (costConstraint != null) {
        annotationBuilder.set(COST_TYPE, String.valueOf(costConstraint.type()));
    }
    annotationBuilder.set(LSP_SIG_TYPE, lspType.name());
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    if (lspType == SR_WITHOUT_SIGNALLING) {
        labelStack = srTeHandler.computeLabelStack(computedPath);
        // Failed to form a label stack.
        if (labelStack == null) {
            pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
            return false;
        }
    }
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(getNextLocalLspId()));
    }
    // For SR-TE tunnels, call SR manager for label stack and put it inside tunnel.
    Tunnel tunnel = new DefaultTunnel(null, srcEndPoint, dstEndPoint, MPLS, INIT, null, null, TunnelName.tunnelName(tunnelName), computedPath, labelStack, annotationBuilder.build());
    // Allocate bandwidth.
    TunnelConsumerId consumerId = null;
    if (bwConstraintValue != 0) {
        consumerId = reserveBandwidth(computedPath, bwConstraintValue, null);
        if (consumerId == null) {
            pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
            return false;
        }
    }
    TunnelId tunnelId = tunnelService.setupTunnel(appId, src, tunnel, computedPath);
    if (tunnelId == null) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        if (consumerId != null) {
            resourceService.release(consumerId);
        }
        return false;
    }
    if (consumerId != null) {
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(tunnelId, pceccTunnelInfo);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean updatePath(TunnelId tunnelId, List<Constraint> constraints) {
    checkNotNull(tunnelId);
    checkNotNull(constraints);
    Set<Path> computedPathSet = null;
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel == null) {
        return false;
    }
    if (FALSE.equalsIgnoreCase(tunnel.annotations().value(DELEGATE))) {
        // Only delegated LSPs can be updated.
        return false;
    }
    List<Link> links = tunnel.path().links();
    String lspSigType = tunnel.annotations().value(LSP_SIG_TYPE);
    double bwConstraintValue = 0;
    String costType = null;
    SharedBandwidthConstraint shBwConstraint = null;
    BandwidthConstraint bwConstraint = null;
    // Call path computation in shared bandwidth mode.
    Iterator<Constraint> iterator = constraints.iterator();
    CostConstraint costConstraint = null;
    while (iterator.hasNext()) {
        Constraint constraint = iterator.next();
        if (constraint instanceof BandwidthConstraint) {
            bwConstraint = (BandwidthConstraint) constraint;
            bwConstraintValue = bwConstraint.bandwidth().bps();
        } else if (constraint instanceof CostConstraint) {
            costConstraint = (CostConstraint) constraint;
            costType = costConstraint.type().name();
        }
    }
    // Remove and keep the cost constraint at the end of the list of constraints.
    if (costConstraint != null) {
        constraints.remove(costConstraint);
    }
    Bandwidth sharedBwValue = null;
    if (tunnel.annotations().value(BANDWIDTH) != null) {
        sharedBwValue = Bandwidth.bps(Double.parseDouble(tunnel.annotations().value(BANDWIDTH)));
        /*
             * The computation is a shared bandwidth constraint based, so need to remove bandwidth constraint which
             * has been utilized to create shared bandwidth constraint.
             */
        if (bwConstraint != null) {
            constraints.remove(bwConstraint);
        }
    }
    if (sharedBwValue != null) {
        shBwConstraint = new SharedBandwidthConstraint(links, sharedBwValue, bwConstraint.bandwidth());
        constraints.add(shBwConstraint);
    }
    constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspSigType)));
    if (costConstraint != null) {
        constraints.add(costConstraint);
    }
    computedPathSet = computePath(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    if (costType != null) {
        annotationBuilder.set(COST_TYPE, costType);
    }
    annotationBuilder.set(LSP_SIG_TYPE, lspSigType);
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    annotationBuilder.set(PLSP_ID, tunnel.annotations().value(PLSP_ID));
    annotationBuilder.set(PCC_TUNNEL_ID, tunnel.annotations().value(PCC_TUNNEL_ID));
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    TunnelConsumerId consumerId = null;
    LspType lspType = LspType.valueOf(lspSigType);
    long localLspId = 0;
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        localLspId = getNextLocalLspId();
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(localLspId));
        if (lspType == SR_WITHOUT_SIGNALLING) {
            labelStack = srTeHandler.computeLabelStack(computedPath);
            // Failed to form a label stack.
            if (labelStack == null) {
                return false;
            }
        }
    }
    Tunnel updatedTunnel = new DefaultTunnel(null, tunnel.src(), tunnel.dst(), MPLS, INIT, null, null, tunnel.tunnelName(), computedPath, labelStack, annotationBuilder.build());
    TunnelId updatedTunnelId = tunnelService.setupTunnel(appId, links.get(0).src().deviceId(), updatedTunnel, computedPath);
    if (updatedTunnelId == null) {
        return false;
    }
    // Allocate shared bandwidth.
    if (bwConstraintValue != 0) {
        consumerId = reserveBandwidth(computedPath, bwConstraintValue, shBwConstraint);
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(updatedTunnelId, pceccTunnelInfo);
    }
    return true;
}
#method_after
@Override
public boolean updatePath(TunnelId tunnelId, List<Constraint> constraints) {
    checkNotNull(tunnelId);
    Set<Path> computedPathSet = null;
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel == null) {
        return false;
    }
    if (tunnel.type() != MPLS || FALSE.equalsIgnoreCase(tunnel.annotations().value(DELEGATE))) {
        // Only delegated LSPs can be updated.
        return false;
    }
    List<Link> links = tunnel.path().links();
    String lspSigType = tunnel.annotations().value(LSP_SIG_TYPE);
    double bwConstraintValue = 0;
    String costType = null;
    SharedBandwidthConstraint shBwConstraint = null;
    BandwidthConstraint bwConstraint = null;
    CostConstraint costConstraint = null;
    if (constraints != null) {
        // Call path computation in shared bandwidth mode.
        Iterator<Constraint> iterator = constraints.iterator();
        while (iterator.hasNext()) {
            Constraint constraint = iterator.next();
            if (constraint instanceof BandwidthConstraint) {
                bwConstraint = (BandwidthConstraint) constraint;
                bwConstraintValue = bwConstraint.bandwidth().bps();
            } else if (constraint instanceof CostConstraint) {
                costConstraint = (CostConstraint) constraint;
                costType = costConstraint.type().name();
            }
        }
        // Remove and keep the cost constraint at the end of the list of constraints.
        if (costConstraint != null) {
            constraints.remove(costConstraint);
        }
        Bandwidth existingBwValue = null;
        String existingBwAnnotation = tunnel.annotations().value(BANDWIDTH);
        if (existingBwAnnotation != null) {
            existingBwValue = Bandwidth.bps(Double.parseDouble(existingBwAnnotation));
            /*
                 * The computation is a shared bandwidth constraint based, so need to remove bandwidth constraint which
                 * has been utilized to create shared bandwidth constraint.
                 */
            if (bwConstraint != null) {
                constraints.remove(bwConstraint);
            }
        }
        if (existingBwValue != null) {
            shBwConstraint = new SharedBandwidthConstraint(links, existingBwValue, bwConstraint.bandwidth());
            constraints.add(shBwConstraint);
        }
    } else {
        constraints = new LinkedList<>();
    }
    constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspSigType)));
    if (costConstraint != null) {
        constraints.add(costConstraint);
    }
    computedPathSet = computePath(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    if (costType != null) {
        annotationBuilder.set(COST_TYPE, costType);
    }
    annotationBuilder.set(LSP_SIG_TYPE, lspSigType);
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    annotationBuilder.set(PLSP_ID, tunnel.annotations().value(PLSP_ID));
    annotationBuilder.set(PCC_TUNNEL_ID, tunnel.annotations().value(PCC_TUNNEL_ID));
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    TunnelConsumerId consumerId = null;
    LspType lspType = LspType.valueOf(lspSigType);
    long localLspId = 0;
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        localLspId = getNextLocalLspId();
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(localLspId));
        if (lspType == SR_WITHOUT_SIGNALLING) {
            labelStack = srTeHandler.computeLabelStack(computedPath);
            // Failed to form a label stack.
            if (labelStack == null) {
                return false;
            }
        }
    }
    Tunnel updatedTunnel = new DefaultTunnel(null, tunnel.src(), tunnel.dst(), MPLS, INIT, null, null, tunnel.tunnelName(), computedPath, labelStack, annotationBuilder.build());
    // Allocate shared bandwidth.
    if (bwConstraintValue != 0) {
        consumerId = reserveBandwidth(computedPath, bwConstraintValue, shBwConstraint);
        if (consumerId == null) {
            return false;
        }
    }
    TunnelId updatedTunnelId = tunnelService.setupTunnel(appId, links.get(0).src().deviceId(), updatedTunnel, computedPath);
    if (updatedTunnelId == null) {
        if (consumerId != null) {
            resourceService.release(consumerId);
        }
        return false;
    }
    if (consumerId != null) {
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(updatedTunnelId, pceccTunnelInfo);
    }
    return true;
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    event.reasons().forEach(e -> {
        // If event type is device removed, get the impacted tunnels
        if (e instanceof DeviceEvent) {
            DeviceEvent deviceEvent = (DeviceEvent) e;
            if (deviceEvent.type() == DeviceEvent.Type.DEVICE_REMOVED || deviceEvent.type() == DeviceEvent.Type.DEVICE_SUSPENDED || deviceEvent.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED) {
                if (!deviceService.isAvailable(((Device) e.subject()).id())) {
                    tunnelService.getTunnels(((Device) e.subject()).id()).forEach(t -> {
                        if (t.type() == Tunnel.Type.MPLS) {
                            // Check whether this ONOS instance is master for ingress device if yes, recompute
                            checkForMasterAndRecompute(t.path().src().deviceId(), t);
                        }
                    });
                }
            }
        }
        // If event type is link removed, get the impacted tunnel
        if (e instanceof LinkEvent) {
            LinkEvent linkEvent = (LinkEvent) e;
            if (linkEvent.type() == LinkEvent.Type.LINK_REMOVED) {
                tunnelService.queryAllTunnels().forEach(t -> {
                    if (t.type() == Tunnel.Type.MPLS && t.path().links().contains(((Link) e.subject()))) {
                        checkForMasterAndRecompute(t.path().src().deviceId(), t);
                    }
                });
            }
        }
    });
}
#method_after
@Override
public void event(TopologyEvent event) {
    event.reasons().forEach(e -> {
        // If event type is link removed, get the impacted tunnel
        if (e instanceof LinkEvent) {
            LinkEvent linkEvent = (LinkEvent) e;
            if (linkEvent.type() == LinkEvent.Type.LINK_REMOVED) {
                tunnelService.queryTunnel(MPLS).forEach(t -> {
                    if (t.path().links().contains(((Link) e.subject()))) {
                        // Check whether this ONOS instance is master for ingress device if yes,
                        // recompute and send update
                        checkForMasterAndUpdateTunnel(t.path().src().deviceId(), t);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
private TunnelConsumerId reserveBandwidth(Path computedPath, double bandwidthConstraint, SharedBandwidthConstraint shBwConstraint) {
    checkNotNull(computedPath);
    checkNotNull(bandwidthConstraint);
    Resource resource = null;
    double bwToAllocate = 0;
    TunnelConsumerId consumer = TunnelConsumerId.valueOf(tunnelConsumerIdGen.getNewId());
    /**
     * Shared bandwidth sub-case : Lesser bandwidth required than original -
     * No reservation required.
     */
    Double additionalBwValue = null;
    if (shBwConstraint != null) {
        additionalBwValue = ((bandwidthConstraint - shBwConstraint.sharedBwValue().bps()) <= 0) ? null : (bandwidthConstraint - shBwConstraint.sharedBwValue().bps());
    }
    for (Link link : computedPath.links()) {
        bwToAllocate = 0;
        if ((shBwConstraint != null) && (shBwConstraint.links().contains(link))) {
            if (additionalBwValue != null) {
                bwToAllocate = bandwidthConstraint - additionalBwValue;
            }
        } else {
            bwToAllocate = bandwidthConstraint;
        }
        /**
         *  In shared bandwidth cases, where new BW is lesser than old BW, it
         *  is not required to allocate anything.
         */
        if (bwToAllocate != 0) {
            resource = Resources.continuous(link.src().deviceId(), link.src().port(), Bandwidth.class).resource(bwToAllocate);
            resourceService.allocate(consumer, resource);
        }
    }
    /*
         * Note: Storing of tunnel consumer id is done by caller of bandwidth reservation function. So deleting tunnel
         * consumer id should be done by caller of bandwidth releasing function. This will prevent ambiguities related
         * to who is supposed to store/delete.
         */
    return consumer;
}
#method_after
private TunnelConsumerId reserveBandwidth(Path computedPath, double bandwidthConstraint, SharedBandwidthConstraint shBwConstraint) {
    checkNotNull(computedPath);
    checkNotNull(bandwidthConstraint);
    Resource resource = null;
    double bwToAllocate = 0;
    TunnelConsumerId consumer = TunnelConsumerId.valueOf(tunnelConsumerIdGen.getNewId());
    /**
     * Shared bandwidth sub-case : Lesser bandwidth required than original -
     * No reservation required.
     */
    Double additionalBwValue = null;
    if (shBwConstraint != null) {
        additionalBwValue = ((bandwidthConstraint - shBwConstraint.sharedBwValue().bps()) <= 0) ? null : (bandwidthConstraint - shBwConstraint.sharedBwValue().bps());
    }
    Optional<ResourceAllocation> resAlloc = null;
    for (Link link : computedPath.links()) {
        bwToAllocate = 0;
        if ((shBwConstraint != null) && (shBwConstraint.links().contains(link))) {
            if (additionalBwValue != null) {
                bwToAllocate = bandwidthConstraint - additionalBwValue;
            }
        } else {
            bwToAllocate = bandwidthConstraint;
        }
        /**
         *  In shared bandwidth cases, where new BW is lesser than old BW, it
         *  is not required to allocate anything.
         */
        if (bwToAllocate != 0) {
            resource = Resources.continuous(link.src().deviceId(), link.src().port(), Bandwidth.class).resource(bwToAllocate);
            resAlloc = resourceService.allocate(consumer, resource);
            // If allocation for any link fails, then release the partially allocated bandwidth.
            if (!resAlloc.isPresent()) {
                resourceService.release(consumer);
                return null;
            }
        }
    }
    /*
         * Note: Storing of tunnel consumer id is done by caller of bandwidth reservation function. So deleting tunnel
         * consumer id should be done by caller of bandwidth releasing function. This will prevent ambiguities related
         * to who is supposed to store/delete.
         */
    return consumer;
}
#end_block

#method_before
@Override
public void event(TunnelEvent event) {
    // Event gets generated with old tunnel object.
    Tunnel tunnel = event.subject();
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    String tunnelBandwidth = tunnel.annotations().value(BANDWIDTH);
    String tunnelDelegation = tunnel.annotations().value(DELEGATE);
    double bwConstraintValue = 0;
    if (tunnelBandwidth != null) {
        bwConstraintValue = Double.parseDouble(tunnelBandwidth);
    }
    switch(event.type()) {
        case TUNNEL_ADDED:
            // Allocate bandwidth for non-initiated, delegated LSPs with non-zero bandwidth (learned LSPs).
            String pceInit = tunnel.annotations().value(PCE_INIT);
            if (FALSE.equalsIgnoreCase(pceInit) && TRUE.equalsIgnoreCase(tunnelDelegation) && bwConstraintValue != 0) {
                reserveBandwidth(tunnel.path(), bwConstraintValue, null);
            }
            break;
        case TUNNEL_UPDATED:
            // Allocate/send labels for basic PCECC tunnels.
            if ((tunnel.state() == ESTABLISHED) && (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR)) {
                crHandler.allocateLabel(tunnel);
            }
            if (tunnel.state() == UNSTABLE) {
                /*
                     * During LSP DB sync if PCC doesn't report LSP which was PCE initiated, it's state is turned into
                     * unstable so that it can be setup again. Add into failed path store so that it can be recomputed
                     * and setup while global reoptimization.
                     */
                List<Constraint> constraints = new LinkedList<>();
                constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(tunnel.annotations().value(BANDWIDTH)))));
                String costType = tunnel.annotations().value(COST_TYPE);
                CostConstraint costConstraint = new CostConstraint(CostConstraint.Type.valueOf(costType));
                constraints.add(costConstraint);
                constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE))));
                List<Link> links = tunnel.path().links();
                pceStore.addFailedPathInfo(new PcePathInfo(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), tunnel.tunnelName().value(), constraints, lspType));
            }
            break;
        case TUNNEL_REMOVED:
            if (lspType != WITH_SIGNALLING) {
                localLspIdFreeList.add(Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)));
            }
            // If not zero bandwidth, and delegated (initiated LSPs will also be delegated).
            if ((bwConstraintValue != 0) && (TRUE.equalsIgnoreCase(tunnelDelegation))) {
                releaseBandwidth(event.subject());
                // Release basic PCECC labels.
                if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
                    // Delete stored tunnel consumer id from PCE store (while still retaining label list.)
                    PceccTunnelInfo pceccTunnelInfo = pceStore.getTunnelInfo(tunnel.tunnelId());
                    pceccTunnelInfo.tunnelConsumerId(null);
                    crHandler.releaseLabel(tunnel);
                } else {
                    pceStore.removeTunnelInfo(tunnel.tunnelId());
                }
            }
            break;
        default:
            break;
    }
    return;
}
#method_after
@Override
public void event(TunnelEvent event) {
    // Event gets generated with old tunnel object.
    Tunnel tunnel = event.subject();
    if (tunnel.type() != MPLS) {
        return;
    }
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    String tunnelBandwidth = tunnel.annotations().value(BANDWIDTH);
    double bwConstraintValue = 0;
    if (tunnelBandwidth != null) {
        bwConstraintValue = Double.parseDouble(tunnelBandwidth);
    }
    switch(event.type()) {
        case TUNNEL_ADDED:
            // Allocate bandwidth for non-initiated, delegated LSPs with non-zero bandwidth (learned LSPs).
            String pceInit = tunnel.annotations().value(PCE_INIT);
            if (FALSE.equalsIgnoreCase(pceInit) && bwConstraintValue != 0) {
                reserveBandwidth(tunnel.path(), bwConstraintValue, null);
            }
            break;
        case TUNNEL_UPDATED:
            // Allocate/send labels for basic PCECC tunnels.
            if ((tunnel.state() == ESTABLISHED) && (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR)) {
                crHandler.allocateLabel(tunnel);
            }
            if (tunnel.state() == UNSTABLE) {
                /*
                     * During LSP DB sync if PCC doesn't report LSP which was PCE initiated, it's state is turned into
                     * unstable so that it can be setup again. Add into failed path store so that it can be recomputed
                     * and setup while global reoptimization.
                     */
                List<Constraint> constraints = new LinkedList<>();
                String bandwidth = tunnel.annotations().value(BANDWIDTH);
                if (bandwidth != null) {
                    constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(bandwidth))));
                }
                String costType = tunnel.annotations().value(COST_TYPE);
                if (costType != null) {
                    CostConstraint costConstraint = new CostConstraint(CostConstraint.Type.valueOf(costType));
                    constraints.add(costConstraint);
                }
                constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE))));
                List<Link> links = tunnel.path().links();
                pceStore.addFailedPathInfo(new PcePathInfo(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), tunnel.tunnelName().value(), constraints, lspType));
            }
            break;
        case TUNNEL_REMOVED:
            if (lspType != WITH_SIGNALLING) {
                localLspIdFreeList.add(Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)));
            }
            // If not zero bandwidth, and delegated (initiated LSPs will also be delegated).
            if (bwConstraintValue != 0) {
                releaseBandwidth(event.subject());
                // Release basic PCECC labels.
                if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
                    // Delete stored tunnel consumer id from PCE store (while still retaining label list.)
                    PceccTunnelInfo pceccTunnelInfo = pceStore.getTunnelInfo(tunnel.tunnelId());
                    pceccTunnelInfo.tunnelConsumerId(null);
                    crHandler.releaseLabel(tunnel);
                } else {
                    pceStore.removeTunnelInfo(tunnel.tunnelId());
                }
            }
            break;
        default:
            break;
    }
    return;
}
#end_block

#method_before
private boolean syncLabelDb(DeviceId deviceId) {
    checkNotNull(deviceId);
    Map<DeviceId, LabelResourceId> globalNodeLabelMap = pceStore.getGlobalNodeLabels();
    for (Entry<DeviceId, LabelResourceId> entry : globalNodeLabelMap.entrySet()) {
        // Convert from DeviceId to TunnelEndPoint
        Device srcDevice = deviceService.getDevice(entry.getKey());
        checkNotNull(srcDevice);
        String srcLsrId = srcDevice.annotations().value(LSRID);
        if (srcLsrId == null) {
            continue;
        }
        srTeHandler.advertiseNodeLabelRule(deviceId, entry.getValue(), IpPrefix.valueOf(IpAddress.valueOf(srcLsrId), PREFIX_LENGTH), Objective.Operation.ADD, false);
    }
    Map<Link, LabelResourceId> adjLabelMap = pceStore.getAdjLabels();
    for (Entry<Link, LabelResourceId> entry : adjLabelMap.entrySet()) {
        if (entry.getKey().src().deviceId().equals(deviceId)) {
            srTeHandler.installAdjLabelRule(deviceId, entry.getValue(), entry.getKey().src().port(), entry.getKey().dst().port(), Objective.Operation.ADD);
        }
    }
    srTeHandler.advertiseNodeLabelRule(deviceId, LabelResourceId.labelResourceId(0), IpPrefix.valueOf("0.0.0.0/32"), Objective.Operation.ADD, true);
    return true;
}
#method_after
private boolean syncLabelDb(DeviceId deviceId) {
    checkNotNull(deviceId);
    Map<DeviceId, LabelResourceId> globalNodeLabelMap = pceStore.getGlobalNodeLabels();
    for (Entry<DeviceId, LabelResourceId> entry : globalNodeLabelMap.entrySet()) {
        // Convert from DeviceId to TunnelEndPoint
        Device srcDevice = deviceService.getDevice(entry.getKey());
        /*
             * If there is a slight difference in timing such that if device subsystem has removed the device but PCE
             * store still has it, just ignore such devices.
             */
        if (srcDevice == null) {
            continue;
        }
        String srcLsrId = srcDevice.annotations().value(LSRID);
        if (srcLsrId == null) {
            continue;
        }
        srTeHandler.advertiseNodeLabelRule(deviceId, entry.getValue(), IpPrefix.valueOf(IpAddress.valueOf(srcLsrId), PREFIX_LENGTH), Objective.Operation.ADD, false);
    }
    Map<Link, LabelResourceId> adjLabelMap = pceStore.getAdjLabels();
    for (Entry<Link, LabelResourceId> entry : adjLabelMap.entrySet()) {
        if (entry.getKey().src().deviceId().equals(deviceId)) {
            srTeHandler.installAdjLabelRule(deviceId, entry.getValue(), entry.getKey().src().port(), entry.getKey().dst().port(), Objective.Operation.ADD);
        }
    }
    srTeHandler.advertiseNodeLabelRule(deviceId, LabelResourceId.labelResourceId(0), IpPrefix.valueOf(END_OF_SYNC_IP_PREFIX), Objective.Operation.ADD, true);
    return true;
}
#end_block

#method_before
private void callForOptimization() {
    // Recompute the LSPs for which it was delegated [LSPs stored in tunnel store]
    tunnelService.queryAllTunnels().forEach(t -> {
        if (t.state().equals(Tunnel.State.FAILED)) {
            // If tunnel is failed and computation fails nothing to do because tunnel status will be same[Failed]
            checkForMasterAndRecompute(t.path().src().deviceId(), t);
        } else {
            // PCIntiate(remove)
            if (!checkForMasterAndRecompute(t.path().src().deviceId(), t)) {
                List<Constraint> constraints = new LinkedList<>();
                if (t.annotations().value(COST_TYPE) != null) {
                    constraints.add(CostConstraint.of(CostConstraint.Type.valueOf(t.annotations().value(COST_TYPE))));
                }
                if (t.annotations().value(BANDWIDTH) != null) {
                    constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(t.annotations().value(PcepAnnotationKeys.BANDWIDTH)))));
                }
                pceStore.addFailedPathInfo(new PcePathInfo(t.path().src().deviceId(), t.path().dst().deviceId(), t.tunnelName().value(), constraints, LspType.valueOf(t.annotations().value(LSP_SIG_TYPE))));
                // Release that tunnel calling PCInitiate
                releasePath(t.tunnelId());
            }
        }
    });
    // Recompute the LSPs which it was delegated [LSPs stored in PCE store (failed paths)]
    for (PcePathInfo failedPathInfo : pceStore.getFailedPathInfos()) {
        if (checkForMasterAndSetupPath(failedPathInfo)) {
            // If computation is success remove that path
            pceStore.removeFailedPathInfo(failedPathInfo);
        }
    }
}
#method_after
private void callForOptimization() {
    // Recompute the LSPs which it was delegated [LSPs stored in PCE store (failed paths)]
    for (PcePathInfo failedPathInfo : pceStore.getFailedPathInfos()) {
        checkForMasterAndSetupPath(failedPathInfo);
    }
    // Recompute the LSPs for which it was delegated [LSPs stored in tunnel store]
    tunnelService.queryTunnel(MPLS).forEach(t -> {
        checkForMasterAndUpdateTunnel(t.path().src().deviceId(), t);
    });
}
#end_block

#method_before
private boolean checkForMasterAndSetupPath(PcePathInfo failedPathInfo) {
    /**
     * Master of ingress node will setup the path failed stored in PCE store.
     */
    if (mastershipService.isLocalMaster(failedPathInfo.src())) {
        return setupPath(failedPathInfo.src(), failedPathInfo.dst(), failedPathInfo.name(), failedPathInfo.constraints(), failedPathInfo.lspType());
    }
    return false;
}
#method_after
private boolean checkForMasterAndSetupPath(PcePathInfo failedPathInfo) {
    /**
     * Master of ingress node will setup the path failed stored in PCE store.
     */
    if (mastershipService.isLocalMaster(failedPathInfo.src())) {
        if (setupPath(failedPathInfo.src(), failedPathInfo.dst(), failedPathInfo.name(), failedPathInfo.constraints(), failedPathInfo.lspType())) {
            // If computation is success remove that path
            pceStore.removeFailedPathInfo(failedPathInfo);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void build4RouterTopo(boolean setCost, boolean setPceccCap, boolean setSrCap, boolean setLabelStackCap, int bandwidth) {
    if (setCost) {
        link1 = PathComputationTest.addLink(DEVICE1, 10, DEVICE2, 20, true, 50);
        link2 = PathComputationTest.addLink(DEVICE2, 30, DEVICE4, 40, true, 20);
        link3 = PathComputationTest.addLink(DEVICE1, 80, DEVICE3, 70, true, 100);
        link4 = PathComputationTest.addLink(DEVICE3, 60, DEVICE4, 50, true, 80);
    } else {
        link1 = PathComputationTest.addLink(DEVICE1, 10, DEVICE2, 20, false, 50);
        link2 = PathComputationTest.addLink(DEVICE2, 30, DEVICE4, 40, false, 20);
        link3 = PathComputationTest.addLink(DEVICE1, 80, DEVICE3, 70, false, 100);
        link4 = PathComputationTest.addLink(DEVICE3, 60, DEVICE4, 50, false, 80);
    }
    Set<TopologyVertex> vertexes = new HashSet<TopologyVertex>();
    vertexes.add(D1);
    vertexes.add(D2);
    vertexes.add(D3);
    vertexes.add(D4);
    this.vertexes = vertexes;
    Set<TopologyEdge> edges = new HashSet<TopologyEdge>();
    TopologyEdge edge1 = new DefaultTopologyEdge(D1, D2, link1);
    edges.add(edge1);
    TopologyEdge edge2 = new DefaultTopologyEdge(D2, D4, link2);
    edges.add(edge2);
    TopologyEdge edge3 = new DefaultTopologyEdge(D1, D3, link3);
    edges.add(edge3);
    TopologyEdge edge4 = new DefaultTopologyEdge(D3, D4, link4);
    edges.add(edge4);
    this.edges = edges;
    graph = new DefaultTopologyGraph(vertexes, edges);
    DefaultAnnotations.Builder builderDev1 = DefaultAnnotations.builder();
    DefaultAnnotations.Builder builderDev2 = DefaultAnnotations.builder();
    DefaultAnnotations.Builder builderDev3 = DefaultAnnotations.builder();
    DefaultAnnotations.Builder builderDev4 = DefaultAnnotations.builder();
    builderDev1.set(AnnotationKeys.TYPE, L3);
    builderDev1.set(LSRID, "1.1.1.1");
    builderDev2.set(AnnotationKeys.TYPE, L3);
    builderDev2.set(LSRID, "2.2.2.2");
    builderDev3.set(AnnotationKeys.TYPE, L3);
    builderDev3.set(LSRID, "3.3.3.3");
    builderDev4.set(AnnotationKeys.TYPE, L3);
    builderDev4.set(LSRID, "4.4.4.4");
    if (setSrCap) {
        builderDev1.set(SR_CAPABILITY, "true");
        builderDev2.set(SR_CAPABILITY, "true");
        builderDev3.set(SR_CAPABILITY, "true");
        builderDev4.set(SR_CAPABILITY, "true");
    }
    if (setPceccCap) {
        builderDev1.set(PCECC_CAPABILITY, "true");
        builderDev2.set(PCECC_CAPABILITY, "true");
        builderDev3.set(PCECC_CAPABILITY, "true");
        builderDev4.set(PCECC_CAPABILITY, "true");
    }
    if (setLabelStackCap) {
        builderDev1.set(LABEL_STACK_CAPABILITY, "true");
        builderDev2.set(LABEL_STACK_CAPABILITY, "true");
        builderDev3.set(LABEL_STACK_CAPABILITY, "true");
        builderDev4.set(LABEL_STACK_CAPABILITY, "true");
    }
    deviceD1 = new MockDevice(D1.deviceId(), builderDev1.build());
    deviceD2 = new MockDevice(D2.deviceId(), builderDev2.build());
    deviceD3 = new MockDevice(D3.deviceId(), builderDev3.build());
    deviceD4 = new MockDevice(D4.deviceId(), builderDev4.build());
    deviceService.addDevice(deviceD1);
    deviceService.addDevice(deviceD2);
    deviceService.addDevice(deviceD3);
    deviceService.addDevice(deviceD4);
    pcepDeviceD1 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE1), builderDev1.build());
    deviceService.addDevice(pcepDeviceD1);
    pcepDeviceD2 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE2), builderDev1.build());
    deviceService.addDevice(pcepDeviceD2);
    pcepDeviceD3 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE3), builderDev1.build());
    deviceService.addDevice(pcepDeviceD3);
    pcepDeviceD4 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE4), builderDev1.build());
    deviceService.addDevice(pcepDeviceD4);
    if (bandwidth != 0) {
        List<Resource> resources = new LinkedList<>();
        resources.add(continuous(link1.src().deviceId(), link1.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link2.src().deviceId(), link2.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link3.src().deviceId(), link3.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link4.src().deviceId(), link4.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link1.dst().deviceId(), link1.dst().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link2.dst().deviceId(), link2.dst().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link3.dst().deviceId(), link3.dst().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link4.dst().deviceId(), link4.dst().port(), Bandwidth.class).resource(bandwidth));
        resourceService.allocate(IntentId.valueOf(bandwidth), resources);
    }
}
#method_after
private void build4RouterTopo(boolean setCost, boolean setPceccCap, boolean setSrCap, boolean setLabelStackCap, int bandwidth) {
    link1 = PathComputationTest.addLink(DEVICE1, 10, DEVICE2, 20, setCost, 50);
    link2 = PathComputationTest.addLink(DEVICE2, 30, DEVICE4, 40, setCost, 20);
    link3 = PathComputationTest.addLink(DEVICE1, 80, DEVICE3, 70, setCost, 100);
    link4 = PathComputationTest.addLink(DEVICE3, 60, DEVICE4, 50, setCost, 80);
    Set<TopologyVertex> vertexes = new HashSet<TopologyVertex>();
    vertexes.add(D1);
    vertexes.add(D2);
    vertexes.add(D3);
    vertexes.add(D4);
    this.vertexes = vertexes;
    Set<TopologyEdge> edges = new HashSet<TopologyEdge>();
    TopologyEdge edge1 = new DefaultTopologyEdge(D1, D2, link1);
    edges.add(edge1);
    TopologyEdge edge2 = new DefaultTopologyEdge(D2, D4, link2);
    edges.add(edge2);
    TopologyEdge edge3 = new DefaultTopologyEdge(D1, D3, link3);
    edges.add(edge3);
    TopologyEdge edge4 = new DefaultTopologyEdge(D3, D4, link4);
    edges.add(edge4);
    this.edges = edges;
    graph = new DefaultTopologyGraph(vertexes, edges);
    DefaultAnnotations.Builder builderDev1 = DefaultAnnotations.builder();
    DefaultAnnotations.Builder builderDev2 = DefaultAnnotations.builder();
    DefaultAnnotations.Builder builderDev3 = DefaultAnnotations.builder();
    DefaultAnnotations.Builder builderDev4 = DefaultAnnotations.builder();
    builderDev1.set(AnnotationKeys.TYPE, L3);
    builderDev1.set(LSRID, "1.1.1.1");
    builderDev2.set(AnnotationKeys.TYPE, L3);
    builderDev2.set(LSRID, "2.2.2.2");
    builderDev3.set(AnnotationKeys.TYPE, L3);
    builderDev3.set(LSRID, "3.3.3.3");
    builderDev4.set(AnnotationKeys.TYPE, L3);
    builderDev4.set(LSRID, "4.4.4.4");
    if (setSrCap) {
        builderDev1.set(SR_CAPABILITY, "true");
        builderDev2.set(SR_CAPABILITY, "true");
        builderDev3.set(SR_CAPABILITY, "true");
        builderDev4.set(SR_CAPABILITY, "true");
    }
    if (setPceccCap) {
        builderDev1.set(PCECC_CAPABILITY, "true");
        builderDev2.set(PCECC_CAPABILITY, "true");
        builderDev3.set(PCECC_CAPABILITY, "true");
        builderDev4.set(PCECC_CAPABILITY, "true");
    }
    if (setLabelStackCap) {
        builderDev1.set(LABEL_STACK_CAPABILITY, "true");
        builderDev2.set(LABEL_STACK_CAPABILITY, "true");
        builderDev3.set(LABEL_STACK_CAPABILITY, "true");
        builderDev4.set(LABEL_STACK_CAPABILITY, "true");
    }
    deviceD1 = new MockDevice(D1.deviceId(), builderDev1.build());
    deviceD2 = new MockDevice(D2.deviceId(), builderDev2.build());
    deviceD3 = new MockDevice(D3.deviceId(), builderDev3.build());
    deviceD4 = new MockDevice(D4.deviceId(), builderDev4.build());
    deviceService.addDevice(deviceD1);
    deviceService.addDevice(deviceD2);
    deviceService.addDevice(deviceD3);
    deviceService.addDevice(deviceD4);
    pcepDeviceD1 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE1), builderDev1.build());
    deviceService.addDevice(pcepDeviceD1);
    pcepDeviceD2 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE2), builderDev1.build());
    deviceService.addDevice(pcepDeviceD2);
    pcepDeviceD3 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE3), builderDev1.build());
    deviceService.addDevice(pcepDeviceD3);
    pcepDeviceD4 = new MockDevice(DeviceId.deviceId(PathComputationTest.PCEPDEVICE4), builderDev1.build());
    deviceService.addDevice(pcepDeviceD4);
    if (bandwidth != 0) {
        List<Resource> resources = new LinkedList<>();
        resources.add(continuous(link1.src().deviceId(), link1.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link2.src().deviceId(), link2.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link3.src().deviceId(), link3.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link4.src().deviceId(), link4.src().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link1.dst().deviceId(), link1.dst().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link2.dst().deviceId(), link2.dst().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link3.dst().deviceId(), link3.dst().port(), Bandwidth.class).resource(bandwidth));
        resources.add(continuous(link4.dst().deviceId(), link4.dst().port(), Bandwidth.class).resource(bandwidth));
        resourceService.allocate(IntentId.valueOf(bandwidth), resources);
    }
}
#end_block

#method_before
@Test
public void setupPathTest7() {
    build4RouterTopo(false, false, false, false, 0);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(TE_COST);
    constraints.add(costConstraint);
    boolean result = pceManager.setupPath(D1.deviceId(), D2.deviceId(), "T123", constraints, WITHOUT_SIGNALLING_AND_WITHOUT_SR);
    assertThat(result, is(false));
}
#method_after
@Test
public void setupPathTest7() {
    build4RouterTopo(true, false, false, false, 0);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(TE_COST);
    constraints.add(costConstraint);
    boolean result = pceManager.setupPath(D1.deviceId(), D2.deviceId(), "T123", constraints, WITHOUT_SIGNALLING_AND_WITHOUT_SR);
    assertThat(result, is(false));
}
#end_block

#method_before
@Test
public void resilencyTest3() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    devices.add(D1.deviceId());
    devices.add(D3.deviceId());
    devices.add(D4.deviceId());
    deviceService.setDevices(devices);
    DefaultDevice device = new DefaultDevice(ProviderId.NONE, D2.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    DeviceEvent deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, device);
    reasons.add(deviceEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device2 , link1 and link2
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D2);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    List<Link> links = new LinkedList<>();
    links.add(link3);
    links.add(link4);
    // Path is D1-D3-D4
    assertThat(pathService.paths().iterator().next().links(), is(links));
    assertThat(pathService.paths().iterator().next().cost(), is((double) 180));
}
#method_after
@Test
public void resilencyTest3() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    LinkEvent linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link2);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link1);
    reasons.add(linkEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove link2 and link1
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    topologyService.changeInTopology(getGraph(null, tempEdges));
    listener.event(event);
    List<Link> links = new LinkedList<>();
    links.add(link3);
    links.add(link4);
    // Path is D1-D3-D4
    assertThat(pathService.paths().iterator().next().links(), is(links));
    assertThat(pathService.paths().iterator().next().cost(), is((double) 180));
}
#end_block

#method_before
@Test
public void resilencyTest4() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    devices.add(D3.deviceId());
    devices.add(D4.deviceId());
    deviceService.setDevices(devices);
    DefaultDevice device = new DefaultDevice(ProviderId.NONE, D1.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    DeviceEvent deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, device);
    reasons.add(deviceEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device1 , link1 and link3
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D1, D3, link3));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D1);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#method_after
@Test
public void resilencyTest4() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    LinkEvent linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link3);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link1);
    reasons.add(linkEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove link2 and link1
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D3, link3));
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    topologyService.changeInTopology(getGraph(null, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#end_block

#method_before
@Test
public void resilencyTest5() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    devices.add(D1.deviceId());
    devices.add(D3.deviceId());
    devices.add(D4.deviceId());
    deviceService.setDevices(devices);
    DefaultDevice device = new DefaultDevice(ProviderId.NONE, D2.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    DeviceEvent deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, device);
    reasons.add(deviceEvent);
    device = new DefaultDevice(ProviderId.NONE, D3.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, device);
    reasons.add(deviceEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device2, device3 and all links
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    tempEdges.add(new DefaultTopologyEdge(D1, D3, link3));
    tempEdges.add(new DefaultTopologyEdge(D3, D4, link4));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D2);
    tempVertexes.add(D3);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#method_after
@Test
public void resilencyTest5() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    LinkEvent linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link2);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link1);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link3);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link4);
    reasons.add(linkEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device2, device3 and all links
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    tempEdges.add(new DefaultTopologyEdge(D1, D3, link3));
    tempEdges.add(new DefaultTopologyEdge(D3, D4, link4));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D2);
    tempVertexes.add(D3);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#end_block

#method_before
@Test
public void resilencyTest6() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    devices.add(D1.deviceId());
    devices.add(D2.deviceId());
    devices.add(D3.deviceId());
    deviceService.setDevices(devices);
    DefaultDevice device = new DefaultDevice(ProviderId.NONE, D4.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    DeviceEvent deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, device);
    reasons.add(deviceEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device4 , link2 and link4
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    tempEdges.add(new DefaultTopologyEdge(D3, D4, link4));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D4);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#method_after
@Test
public void resilencyTest6() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    LinkEvent linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link2);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link4);
    reasons.add(linkEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device4 , link2 and link4
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    tempEdges.add(new DefaultTopologyEdge(D3, D4, link4));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D4);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#end_block

#method_before
@Test
public void resilencyTest7() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    devices.add(D1.deviceId());
    devices.add(D2.deviceId());
    devices.add(D3.deviceId());
    deviceService.setDevices(devices);
    DefaultDevice device = new DefaultDevice(ProviderId.NONE, D4.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    DeviceEvent deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_REMOVED, device);
    reasons.add(deviceEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device4 , link2 and link4
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    tempEdges.add(new DefaultTopologyEdge(D3, D4, link4));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D4);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#method_after
@Test
public void resilencyTest7() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    LinkEvent linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link2);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link4);
    reasons.add(linkEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device4 , link2 and link4
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    tempEdges.add(new DefaultTopologyEdge(D3, D4, link4));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D4);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    // No path
    assertThat(pathService.paths().size(), is(0));
}
#end_block

#method_before
@Test
public void resilencyTest8() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    devices.add(D1.deviceId());
    devices.add(D3.deviceId());
    devices.add(D4.deviceId());
    deviceService.setDevices(devices);
    DefaultDevice device = new DefaultDevice(ProviderId.NONE, D2.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    DeviceEvent deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_SUSPENDED, device);
    reasons.add(deviceEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device2 , link1 and link2
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D2);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    List<Link> links = new LinkedList<>();
    links.add(link3);
    links.add(link4);
    // Path is D1-D3-D4
    assertThat(pathService.paths().iterator().next().links(), is(links));
    assertThat(pathService.paths().iterator().next().cost(), is((double) 180));
}
#method_after
@Test
public void resilencyTest8() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    LinkEvent linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link1);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link2);
    reasons.add(linkEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device2 , link1 and link2
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D2);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    List<Link> links = new LinkedList<>();
    links.add(link3);
    links.add(link4);
    // Path is D1-D3-D4
    assertThat(pathService.paths().iterator().next().links(), is(links));
    assertThat(pathService.paths().iterator().next().cost(), is((double) 180));
}
#end_block

#method_before
@Test
public void resilencyTest11() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    List<DeviceId> devices = new LinkedList<>();
    devices.add(D1.deviceId());
    devices.add(D3.deviceId());
    devices.add(D4.deviceId());
    deviceService.setDevices(devices);
    DefaultDevice device = new DefaultDevice(ProviderId.NONE, D2.deviceId(), Device.Type.ROUTER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, new ChassisId(), DefaultAnnotations.EMPTY);
    DeviceEvent deviceEvent = new DeviceEvent(DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED, device);
    reasons.add(deviceEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device2 , link1 and link2
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D2);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    List<Link> links = new LinkedList<>();
    links.add(link3);
    links.add(link4);
    // Path is D1-D3-D4
    assertThat(pathService.paths().iterator().next().links(), is(links));
    assertThat(pathService.paths().iterator().next().cost(), is((double) 180));
}
#method_after
@Test
public void resilencyTest11() {
    build4RouterTopo(true, false, false, false, 10);
    List<Constraint> constraints = new LinkedList<Constraint>();
    CostConstraint costConstraint = new CostConstraint(COST);
    constraints.add(costConstraint);
    BandwidthConstraint localBwConst = new BandwidthConstraint(Bandwidth.bps(10));
    constraints.add(localBwConst);
    // Setup the path , tunnel created
    boolean result = pceManager.setupPath(D1.deviceId(), D4.deviceId(), "T123", constraints, WITH_SIGNALLING);
    assertThat(result, is(true));
    List<Event> reasons = new LinkedList<>();
    LinkEvent linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link1);
    reasons.add(linkEvent);
    linkEvent = new LinkEvent(LinkEvent.Type.LINK_REMOVED, link2);
    reasons.add(linkEvent);
    final TopologyEvent event = new TopologyEvent(TopologyEvent.Type.TOPOLOGY_CHANGED, topology, reasons);
    // Change Topology : remove device2 , link1 and link2
    Set<TopologyEdge> tempEdges = new HashSet<>();
    tempEdges.add(new DefaultTopologyEdge(D1, D2, link1));
    tempEdges.add(new DefaultTopologyEdge(D2, D4, link2));
    Set<TopologyVertex> tempVertexes = new HashSet<>();
    tempVertexes.add(D2);
    topologyService.changeInTopology(getGraph(tempVertexes, tempEdges));
    listener.event(event);
    List<Link> links = new LinkedList<>();
    links.add(link3);
    links.add(link4);
    // Path is D1-D3-D4
    assertThat(pathService.paths().iterator().next().links(), is(links));
    assertThat(pathService.paths().iterator().next().cost(), is((double) 180));
}
#end_block

#method_before
@Override
public boolean setupPath(DeviceId src, DeviceId dst, String tunnelName, List<Constraint> constraints, LspType lspType) {
    checkNotNull(src);
    checkNotNull(dst);
    checkNotNull(tunnelName);
    checkNotNull(constraints);
    checkNotNull(lspType);
    // Convert from DeviceId to TunnelEndPoint
    Device srcDevice = deviceService.getDevice(src);
    Device dstDevice = deviceService.getDevice(dst);
    if (srcDevice == null || dstDevice == null) {
        // Device is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    // In future projections instead of annotations will be used to fetch LSR ID.
    String srcLsrId = srcDevice.annotations().value(LSRID);
    String dstLsrId = dstDevice.annotations().value(LSRID);
    if (srcLsrId == null || dstLsrId == null) {
        // LSR id is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    TunnelEndPoint srcEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcLsrId));
    TunnelEndPoint dstEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstLsrId));
    double bwConstraintValue = 0;
    constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspType.name())));
    Iterator<Constraint> iterator = constraints.iterator();
    CostConstraint costConstraint = null;
    while (iterator.hasNext()) {
        Constraint constraint = iterator.next();
        if (constraint instanceof BandwidthConstraint) {
            bwConstraintValue = ((BandwidthConstraint) constraint).bandwidth().bps();
        } else if (constraint instanceof CostConstraint) {
            // Add cost at the end of the list of constraints.
            costConstraint = (CostConstraint) constraint;
        }
    }
    if (costConstraint != null) {
        constraints.remove(costConstraint);
        constraints.add(costConstraint);
    }
    Set<Path> computedPathSet = computePath(src, dst, constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    annotationBuilder.set(LSP_SIG_TYPE, lspType.name());
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    annotationBuilder.set(COST_TYPE, String.valueOf(costConstraint.type()));
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    if (lspType == SR_WITHOUT_SIGNALLING) {
        labelStack = srTeHandler.computeLabelStack(computedPath);
        // Failed to form a label stack.
        if (labelStack == null) {
            pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
            return false;
        }
    }
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(getNextLocalLspId()));
    }
    // For SR-TE tunnels, call SR manager for label stack and put it inside tunnel.
    Tunnel tunnel = new DefaultTunnel(null, srcEndPoint, dstEndPoint, MPLS, INIT, null, null, TunnelName.tunnelName(tunnelName), computedPath, labelStack, annotationBuilder.build());
    TunnelId tunnelId = tunnelService.setupTunnel(appId, src, tunnel, computedPath);
    if (tunnelId == null) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    // Allocate bandwidth.
    if (bwConstraintValue != 0) {
        TunnelConsumerId consumerId = reserveBandwidth(computedPath, bwConstraintValue, null);
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(tunnelId, pceccTunnelInfo);
    }
    return true;
}
#method_after
@Override
public boolean setupPath(DeviceId src, DeviceId dst, String tunnelName, List<Constraint> constraints, LspType lspType) {
    checkNotNull(src);
    checkNotNull(dst);
    checkNotNull(tunnelName);
    checkNotNull(lspType);
    // Convert from DeviceId to TunnelEndPoint
    Device srcDevice = deviceService.getDevice(src);
    Device dstDevice = deviceService.getDevice(dst);
    if (srcDevice == null || dstDevice == null) {
        // Device is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    // In future projections instead of annotations will be used to fetch LSR ID.
    String srcLsrId = srcDevice.annotations().value(LSRID);
    String dstLsrId = dstDevice.annotations().value(LSRID);
    if (srcLsrId == null || dstLsrId == null) {
        // LSR id is not known.
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    TunnelEndPoint srcEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcLsrId));
    TunnelEndPoint dstEndPoint = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstLsrId));
    double bwConstraintValue = 0;
    CostConstraint costConstraint = null;
    if (constraints != null) {
        constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspType.name())));
        Iterator<Constraint> iterator = constraints.iterator();
        while (iterator.hasNext()) {
            Constraint constraint = iterator.next();
            if (constraint instanceof BandwidthConstraint) {
                bwConstraintValue = ((BandwidthConstraint) constraint).bandwidth().bps();
            } else if (constraint instanceof CostConstraint) {
                costConstraint = (CostConstraint) constraint;
            }
        }
        /*
             * Add cost at the end of the list of constraints. The path computation algorithm also computes cumulative
             * cost. The function which checks the limiting/capability constraints also returns per link cost. This
             * function can either return the result of limiting/capability constraint validation or the value of link
             * cost, depending upon what is the last constraint in the loop.
             */
        if (costConstraint != null) {
            constraints.remove(costConstraint);
            constraints.add(costConstraint);
        }
    } else {
        constraints = new LinkedList<>();
        constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspType.name())));
    }
    Set<Path> computedPathSet = computePath(src, dst, constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    if (bwConstraintValue != 0) {
        annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    }
    if (costConstraint != null) {
        annotationBuilder.set(COST_TYPE, String.valueOf(costConstraint.type()));
    }
    annotationBuilder.set(LSP_SIG_TYPE, lspType.name());
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    if (lspType == SR_WITHOUT_SIGNALLING) {
        labelStack = srTeHandler.computeLabelStack(computedPath);
        // Failed to form a label stack.
        if (labelStack == null) {
            pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
            return false;
        }
    }
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(getNextLocalLspId()));
    }
    // For SR-TE tunnels, call SR manager for label stack and put it inside tunnel.
    Tunnel tunnel = new DefaultTunnel(null, srcEndPoint, dstEndPoint, MPLS, INIT, null, null, TunnelName.tunnelName(tunnelName), computedPath, labelStack, annotationBuilder.build());
    // Allocate bandwidth.
    TunnelConsumerId consumerId = null;
    if (bwConstraintValue != 0) {
        consumerId = reserveBandwidth(computedPath, bwConstraintValue, null);
        if (consumerId == null) {
            pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
            return false;
        }
    }
    TunnelId tunnelId = tunnelService.setupTunnel(appId, src, tunnel, computedPath);
    if (tunnelId == null) {
        pceStore.addFailedPathInfo(new PcePathInfo(src, dst, tunnelName, constraints, lspType));
        if (consumerId != null) {
            resourceService.release(consumerId);
        }
        return false;
    }
    if (consumerId != null) {
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(tunnelId, pceccTunnelInfo);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean updatePath(TunnelId tunnelId, List<Constraint> constraints) {
    checkNotNull(tunnelId);
    checkNotNull(constraints);
    Set<Path> computedPathSet = null;
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel == null) {
        return false;
    }
    if (FALSE.equalsIgnoreCase(tunnel.annotations().value(DELEGATE))) {
        // Only delegated LSPs can be updated.
        return false;
    }
    List<Link> links = tunnel.path().links();
    String lspSigType = tunnel.annotations().value(LSP_SIG_TYPE);
    double bwConstraintValue = 0;
    String costType = null;
    SharedBandwidthConstraint shBwConstraint = null;
    BandwidthConstraint bwConstraint = null;
    // Call path computation in shared bandwidth mode.
    Iterator<Constraint> iterator = constraints.iterator();
    CostConstraint costConstraint = null;
    while (iterator.hasNext()) {
        Constraint constraint = iterator.next();
        if (constraint instanceof BandwidthConstraint) {
            bwConstraint = (BandwidthConstraint) constraint;
            bwConstraintValue = bwConstraint.bandwidth().bps();
        } else if (constraint instanceof CostConstraint) {
            costConstraint = (CostConstraint) constraint;
            costType = costConstraint.type().name();
        }
    }
    // Remove and keep the cost constraint at the end of the list of constraints.
    if (costConstraint != null) {
        constraints.remove(costConstraint);
    }
    Bandwidth sharedBwValue = null;
    if (tunnel.annotations().value(BANDWIDTH) != null) {
        sharedBwValue = Bandwidth.bps(Double.parseDouble(tunnel.annotations().value(BANDWIDTH)));
        /*
             * The computation is a shared bandwidth constraint based, so need to remove bandwidth constraint which
             * has been utilized to create shared bandwidth constraint.
             */
        if (bwConstraint != null) {
            constraints.remove(bwConstraint);
        }
    }
    if (sharedBwValue != null) {
        shBwConstraint = new SharedBandwidthConstraint(links, sharedBwValue, bwConstraint.bandwidth());
        constraints.add(shBwConstraint);
    }
    constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspSigType)));
    if (costConstraint != null) {
        constraints.add(costConstraint);
    }
    computedPathSet = computePath(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    if (costType != null) {
        annotationBuilder.set(COST_TYPE, costType);
    }
    annotationBuilder.set(LSP_SIG_TYPE, lspSigType);
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    annotationBuilder.set(PLSP_ID, tunnel.annotations().value(PLSP_ID));
    annotationBuilder.set(PCC_TUNNEL_ID, tunnel.annotations().value(PCC_TUNNEL_ID));
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    TunnelConsumerId consumerId = null;
    LspType lspType = LspType.valueOf(lspSigType);
    long localLspId = 0;
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        localLspId = getNextLocalLspId();
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(localLspId));
        if (lspType == SR_WITHOUT_SIGNALLING) {
            labelStack = srTeHandler.computeLabelStack(computedPath);
            // Failed to form a label stack.
            if (labelStack == null) {
                return false;
            }
        }
    }
    Tunnel updatedTunnel = new DefaultTunnel(null, tunnel.src(), tunnel.dst(), MPLS, INIT, null, null, tunnel.tunnelName(), computedPath, labelStack, annotationBuilder.build());
    TunnelId updatedTunnelId = tunnelService.setupTunnel(appId, links.get(0).src().deviceId(), updatedTunnel, computedPath);
    if (updatedTunnelId == null) {
        return false;
    }
    // Allocate shared bandwidth.
    if (bwConstraintValue != 0) {
        consumerId = reserveBandwidth(computedPath, bwConstraintValue, shBwConstraint);
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(updatedTunnelId, pceccTunnelInfo);
    }
    return true;
}
#method_after
@Override
public boolean updatePath(TunnelId tunnelId, List<Constraint> constraints) {
    checkNotNull(tunnelId);
    Set<Path> computedPathSet = null;
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel == null) {
        return false;
    }
    if (tunnel.type() != MPLS || FALSE.equalsIgnoreCase(tunnel.annotations().value(DELEGATE))) {
        // Only delegated LSPs can be updated.
        return false;
    }
    List<Link> links = tunnel.path().links();
    String lspSigType = tunnel.annotations().value(LSP_SIG_TYPE);
    double bwConstraintValue = 0;
    String costType = null;
    SharedBandwidthConstraint shBwConstraint = null;
    BandwidthConstraint bwConstraint = null;
    CostConstraint costConstraint = null;
    if (constraints != null) {
        // Call path computation in shared bandwidth mode.
        Iterator<Constraint> iterator = constraints.iterator();
        while (iterator.hasNext()) {
            Constraint constraint = iterator.next();
            if (constraint instanceof BandwidthConstraint) {
                bwConstraint = (BandwidthConstraint) constraint;
                bwConstraintValue = bwConstraint.bandwidth().bps();
            } else if (constraint instanceof CostConstraint) {
                costConstraint = (CostConstraint) constraint;
                costType = costConstraint.type().name();
            }
        }
        // Remove and keep the cost constraint at the end of the list of constraints.
        if (costConstraint != null) {
            constraints.remove(costConstraint);
        }
        Bandwidth existingBwValue = null;
        String existingBwAnnotation = tunnel.annotations().value(BANDWIDTH);
        if (existingBwAnnotation != null) {
            existingBwValue = Bandwidth.bps(Double.parseDouble(existingBwAnnotation));
            /*
                 * The computation is a shared bandwidth constraint based, so need to remove bandwidth constraint which
                 * has been utilized to create shared bandwidth constraint.
                 */
            if (bwConstraint != null) {
                constraints.remove(bwConstraint);
            }
        }
        if (existingBwValue != null) {
            shBwConstraint = new SharedBandwidthConstraint(links, existingBwValue, bwConstraint.bandwidth());
            constraints.add(shBwConstraint);
        }
    } else {
        constraints = new LinkedList<>();
    }
    constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(lspSigType)));
    if (costConstraint != null) {
        constraints.add(costConstraint);
    }
    computedPathSet = computePath(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), constraints);
    // NO-PATH
    if (computedPathSet.isEmpty()) {
        return false;
    }
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.set(BANDWIDTH, String.valueOf(bwConstraintValue));
    if (costType != null) {
        annotationBuilder.set(COST_TYPE, costType);
    }
    annotationBuilder.set(LSP_SIG_TYPE, lspSigType);
    annotationBuilder.set(PCE_INIT, TRUE);
    annotationBuilder.set(DELEGATE, TRUE);
    annotationBuilder.set(PLSP_ID, tunnel.annotations().value(PLSP_ID));
    annotationBuilder.set(PCC_TUNNEL_ID, tunnel.annotations().value(PCC_TUNNEL_ID));
    Path computedPath = computedPathSet.iterator().next();
    LabelStack labelStack = null;
    TunnelConsumerId consumerId = null;
    LspType lspType = LspType.valueOf(lspSigType);
    long localLspId = 0;
    if (lspType != WITH_SIGNALLING) {
        /*
             * Local LSP id which is assigned by RSVP for RSVP signalled LSPs, will be assigned by
             * PCE for non-RSVP signalled LSPs.
             */
        localLspId = getNextLocalLspId();
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(localLspId));
        if (lspType == SR_WITHOUT_SIGNALLING) {
            labelStack = srTeHandler.computeLabelStack(computedPath);
            // Failed to form a label stack.
            if (labelStack == null) {
                return false;
            }
        }
    }
    Tunnel updatedTunnel = new DefaultTunnel(null, tunnel.src(), tunnel.dst(), MPLS, INIT, null, null, tunnel.tunnelName(), computedPath, labelStack, annotationBuilder.build());
    // Allocate shared bandwidth.
    if (bwConstraintValue != 0) {
        consumerId = reserveBandwidth(computedPath, bwConstraintValue, shBwConstraint);
        if (consumerId == null) {
            return false;
        }
    }
    TunnelId updatedTunnelId = tunnelService.setupTunnel(appId, links.get(0).src().deviceId(), updatedTunnel, computedPath);
    if (updatedTunnelId == null) {
        if (consumerId != null) {
            resourceService.release(consumerId);
        }
        return false;
    }
    if (consumerId != null) {
        // Store tunnel consumer id in LSP-Label store.
        PceccTunnelInfo pceccTunnelInfo = new PceccTunnelInfo(null, consumerId);
        pceStore.addTunnelInfo(updatedTunnelId, pceccTunnelInfo);
    }
    return true;
}
#end_block

#method_before
@Override
public void event(TopologyEvent event) {
    event.reasons().forEach(e -> {
        // If event type is device removed, get the impacted tunnels
        if (e instanceof DeviceEvent) {
            DeviceEvent deviceEvent = (DeviceEvent) e;
            if (deviceEvent.type() == DeviceEvent.Type.DEVICE_REMOVED || deviceEvent.type() == DeviceEvent.Type.DEVICE_SUSPENDED || deviceEvent.type() == DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED) {
                if (!deviceService.isAvailable(((Device) e.subject()).id())) {
                    tunnelService.getTunnels(((Device) e.subject()).id()).forEach(t -> {
                        if (t.type() == Tunnel.Type.MPLS) {
                            // recompute
                            if (!checkForMasterAndRecompute(t.path().src().deviceId(), t)) {
                                // If computation fails store in PCE store as failed path
                                // then PCInitiate (Remove)
                                List<Constraint> constraints = new LinkedList<>();
                                if (t.annotations().value(COST_TYPE) != null) {
                                    constraints.add(CostConstraint.of(CostConstraint.Type.valueOf(t.annotations().value(COST_TYPE))));
                                }
                                if (t.annotations().value(BANDWIDTH) != null) {
                                    constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(t.annotations().value(PcepAnnotationKeys.BANDWIDTH)))));
                                }
                                pceStore.addFailedPathInfo(new PcePathInfo(t.path().src().deviceId(), t.path().dst().deviceId(), t.tunnelName().value(), constraints, LspType.valueOf(t.annotations().value(LSP_SIG_TYPE))));
                                // Release that tunnel calling PCInitiate
                                releasePath(t.tunnelId());
                            }
                        }
                    });
                }
            }
        }
        // If event type is link removed, get the impacted tunnel
        if (e instanceof LinkEvent) {
            LinkEvent linkEvent = (LinkEvent) e;
            if (linkEvent.type() == LinkEvent.Type.LINK_REMOVED) {
                tunnelService.queryAllTunnels().forEach(t -> {
                    if (t.type() == Tunnel.Type.MPLS && t.path().links().contains(((Link) e.subject()))) {
                        // recompute
                        if (!checkForMasterAndRecompute(t.path().src().deviceId(), t)) {
                            // If computation fails store in PCE store as failed path
                            // then PCInitiate (Remove)
                            List<Constraint> constraints = new LinkedList<>();
                            if (t.annotations().value(COST_TYPE) != null) {
                                constraints.add(CostConstraint.of(CostConstraint.Type.valueOf(t.annotations().value(COST_TYPE))));
                            }
                            if (t.annotations().value(BANDWIDTH) != null) {
                                constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(t.annotations().value(PcepAnnotationKeys.BANDWIDTH)))));
                            }
                            pceStore.addFailedPathInfo(new PcePathInfo(t.path().src().deviceId(), t.path().dst().deviceId(), t.tunnelName().value(), constraints, LspType.valueOf(t.annotations().value(LSP_SIG_TYPE))));
                            // Release that tunnel calling PCInitiate
                            releasePath(t.tunnelId());
                        }
                    }
                });
            }
        }
    });
}
#method_after
@Override
public void event(TopologyEvent event) {
    event.reasons().forEach(e -> {
        // If event type is link removed, get the impacted tunnel
        if (e instanceof LinkEvent) {
            LinkEvent linkEvent = (LinkEvent) e;
            if (linkEvent.type() == LinkEvent.Type.LINK_REMOVED) {
                tunnelService.queryTunnel(MPLS).forEach(t -> {
                    if (t.path().links().contains(((Link) e.subject()))) {
                        // Check whether this ONOS instance is master for ingress device if yes,
                        // recompute and send update
                        checkForMasterAndUpdateTunnel(t.path().src().deviceId(), t);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
private TunnelConsumerId reserveBandwidth(Path computedPath, double bandwidthConstraint, SharedBandwidthConstraint shBwConstraint) {
    checkNotNull(computedPath);
    checkNotNull(bandwidthConstraint);
    Resource resource = null;
    double bwToAllocate = 0;
    TunnelConsumerId consumer = TunnelConsumerId.valueOf(tunnelConsumerIdGen.getNewId());
    /**
     * Shared bandwidth sub-case : Lesser bandwidth required than original -
     * No reservation required.
     */
    Double additionalBwValue = null;
    if (shBwConstraint != null) {
        additionalBwValue = ((bandwidthConstraint - shBwConstraint.sharedBwValue().bps()) <= 0) ? null : (bandwidthConstraint - shBwConstraint.sharedBwValue().bps());
    }
    for (Link link : computedPath.links()) {
        bwToAllocate = 0;
        if ((shBwConstraint != null) && (shBwConstraint.links().contains(link))) {
            if (additionalBwValue != null) {
                bwToAllocate = bandwidthConstraint - additionalBwValue;
            }
        } else {
            bwToAllocate = bandwidthConstraint;
        }
        /**
         *  In shared bandwidth cases, where new BW is lesser than old BW, it
         *  is not required to allocate anything.
         */
        if (bwToAllocate != 0) {
            resource = Resources.continuous(link.src().deviceId(), link.src().port(), Bandwidth.class).resource(bwToAllocate);
            resourceService.allocate(consumer, resource);
        }
    }
    /*
         * Note: Storing of tunnel consumer id is done by caller of bandwidth reservation function. So deleting tunnel
         * consumer id should be done by caller of bandwidth releasing function. This will prevent ambiguities related
         * to who is supposed to store/delete.
         */
    return consumer;
}
#method_after
private TunnelConsumerId reserveBandwidth(Path computedPath, double bandwidthConstraint, SharedBandwidthConstraint shBwConstraint) {
    checkNotNull(computedPath);
    checkNotNull(bandwidthConstraint);
    Resource resource = null;
    double bwToAllocate = 0;
    TunnelConsumerId consumer = TunnelConsumerId.valueOf(tunnelConsumerIdGen.getNewId());
    /**
     * Shared bandwidth sub-case : Lesser bandwidth required than original -
     * No reservation required.
     */
    Double additionalBwValue = null;
    if (shBwConstraint != null) {
        additionalBwValue = ((bandwidthConstraint - shBwConstraint.sharedBwValue().bps()) <= 0) ? null : (bandwidthConstraint - shBwConstraint.sharedBwValue().bps());
    }
    Optional<ResourceAllocation> resAlloc = null;
    for (Link link : computedPath.links()) {
        bwToAllocate = 0;
        if ((shBwConstraint != null) && (shBwConstraint.links().contains(link))) {
            if (additionalBwValue != null) {
                bwToAllocate = bandwidthConstraint - additionalBwValue;
            }
        } else {
            bwToAllocate = bandwidthConstraint;
        }
        /**
         *  In shared bandwidth cases, where new BW is lesser than old BW, it
         *  is not required to allocate anything.
         */
        if (bwToAllocate != 0) {
            resource = Resources.continuous(link.src().deviceId(), link.src().port(), Bandwidth.class).resource(bwToAllocate);
            resAlloc = resourceService.allocate(consumer, resource);
            // If allocation for any link fails, then release the partially allocated bandwidth.
            if (!resAlloc.isPresent()) {
                resourceService.release(consumer);
                return null;
            }
        }
    }
    /*
         * Note: Storing of tunnel consumer id is done by caller of bandwidth reservation function. So deleting tunnel
         * consumer id should be done by caller of bandwidth releasing function. This will prevent ambiguities related
         * to who is supposed to store/delete.
         */
    return consumer;
}
#end_block

#method_before
@Override
public void event(TunnelEvent event) {
    // Event gets generated with old tunnel object.
    Tunnel tunnel = event.subject();
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    String tunnelBandwidth = tunnel.annotations().value(BANDWIDTH);
    String tunnelDelegation = tunnel.annotations().value(DELEGATE);
    double bwConstraintValue = 0;
    if (tunnelBandwidth != null) {
        bwConstraintValue = Double.parseDouble(tunnelBandwidth);
    }
    switch(event.type()) {
        case TUNNEL_ADDED:
            // Allocate bandwidth for non-initiated, delegated LSPs with non-zero bandwidth (learned LSPs).
            String pceInit = tunnel.annotations().value(PCE_INIT);
            if (FALSE.equalsIgnoreCase(pceInit) && TRUE.equalsIgnoreCase(tunnelDelegation) && bwConstraintValue != 0) {
                reserveBandwidth(tunnel.path(), bwConstraintValue, null);
            }
            break;
        case TUNNEL_UPDATED:
            // Allocate/send labels for basic PCECC tunnels.
            if ((tunnel.state() == ESTABLISHED) && (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR)) {
                crHandler.allocateLabel(tunnel);
            }
            if (tunnel.state() == UNSTABLE) {
                /*
                     * During LSP DB sync if PCC doesn't report LSP which was PCE initiated, it's state is turned into
                     * unstable so that it can be setup again. Add into failed path store so that it can be recomputed
                     * and setup while global reoptimization.
                     */
                List<Constraint> constraints = new LinkedList<>();
                constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(tunnel.annotations().value(BANDWIDTH)))));
                String costType = tunnel.annotations().value(COST_TYPE);
                CostConstraint costConstraint = new CostConstraint(CostConstraint.Type.valueOf(costType));
                constraints.add(costConstraint);
                constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE))));
                List<Link> links = tunnel.path().links();
                pceStore.addFailedPathInfo(new PcePathInfo(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), tunnel.tunnelName().value(), constraints, lspType));
            }
            break;
        case TUNNEL_REMOVED:
            if (lspType != WITH_SIGNALLING) {
                localLspIdFreeList.add(Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)));
            }
            // If not zero bandwidth, and delegated (initiated LSPs will also be delegated).
            if ((bwConstraintValue != 0) && (TRUE.equalsIgnoreCase(tunnelDelegation))) {
                releaseBandwidth(event.subject());
                // Release basic PCECC labels.
                if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
                    // Delete stored tunnel consumer id from PCE store (while still retaining label list.)
                    PceccTunnelInfo pceccTunnelInfo = pceStore.getTunnelInfo(tunnel.tunnelId());
                    pceccTunnelInfo.tunnelConsumerId(null);
                    crHandler.releaseLabel(tunnel);
                } else {
                    pceStore.removeTunnelInfo(tunnel.tunnelId());
                }
            }
            break;
        default:
            break;
    }
    return;
}
#method_after
@Override
public void event(TunnelEvent event) {
    // Event gets generated with old tunnel object.
    Tunnel tunnel = event.subject();
    if (tunnel.type() != MPLS) {
        return;
    }
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    String tunnelBandwidth = tunnel.annotations().value(BANDWIDTH);
    double bwConstraintValue = 0;
    if (tunnelBandwidth != null) {
        bwConstraintValue = Double.parseDouble(tunnelBandwidth);
    }
    switch(event.type()) {
        case TUNNEL_ADDED:
            // Allocate bandwidth for non-initiated, delegated LSPs with non-zero bandwidth (learned LSPs).
            String pceInit = tunnel.annotations().value(PCE_INIT);
            if (FALSE.equalsIgnoreCase(pceInit) && bwConstraintValue != 0) {
                reserveBandwidth(tunnel.path(), bwConstraintValue, null);
            }
            break;
        case TUNNEL_UPDATED:
            // Allocate/send labels for basic PCECC tunnels.
            if ((tunnel.state() == ESTABLISHED) && (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR)) {
                crHandler.allocateLabel(tunnel);
            }
            if (tunnel.state() == UNSTABLE) {
                /*
                     * During LSP DB sync if PCC doesn't report LSP which was PCE initiated, it's state is turned into
                     * unstable so that it can be setup again. Add into failed path store so that it can be recomputed
                     * and setup while global reoptimization.
                     */
                List<Constraint> constraints = new LinkedList<>();
                String bandwidth = tunnel.annotations().value(BANDWIDTH);
                if (bandwidth != null) {
                    constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(bandwidth))));
                }
                String costType = tunnel.annotations().value(COST_TYPE);
                if (costType != null) {
                    CostConstraint costConstraint = new CostConstraint(CostConstraint.Type.valueOf(costType));
                    constraints.add(costConstraint);
                }
                constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE))));
                List<Link> links = tunnel.path().links();
                pceStore.addFailedPathInfo(new PcePathInfo(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), tunnel.tunnelName().value(), constraints, lspType));
            }
            break;
        case TUNNEL_REMOVED:
            if (lspType != WITH_SIGNALLING) {
                localLspIdFreeList.add(Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)));
            }
            // If not zero bandwidth, and delegated (initiated LSPs will also be delegated).
            if (bwConstraintValue != 0) {
                releaseBandwidth(event.subject());
                // Release basic PCECC labels.
                if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
                    // Delete stored tunnel consumer id from PCE store (while still retaining label list.)
                    PceccTunnelInfo pceccTunnelInfo = pceStore.getTunnelInfo(tunnel.tunnelId());
                    pceccTunnelInfo.tunnelConsumerId(null);
                    crHandler.releaseLabel(tunnel);
                } else {
                    pceStore.removeTunnelInfo(tunnel.tunnelId());
                }
            }
            break;
        default:
            break;
    }
    return;
}
#end_block

#method_before
private boolean syncLabelDb(DeviceId deviceId) {
    checkNotNull(deviceId);
    Map<DeviceId, LabelResourceId> globalNodeLabelMap = pceStore.getGlobalNodeLabels();
    for (Entry<DeviceId, LabelResourceId> entry : globalNodeLabelMap.entrySet()) {
        // Convert from DeviceId to TunnelEndPoint
        Device srcDevice = deviceService.getDevice(entry.getKey());
        checkNotNull(srcDevice);
        String srcLsrId = srcDevice.annotations().value(LSRID);
        if (srcLsrId == null) {
            continue;
        }
        srTeHandler.advertiseNodeLabelRule(deviceId, entry.getValue(), IpPrefix.valueOf(IpAddress.valueOf(srcLsrId), PREFIX_LENGTH), Objective.Operation.ADD, false);
    }
    Map<Link, LabelResourceId> adjLabelMap = pceStore.getAdjLabels();
    for (Entry<Link, LabelResourceId> entry : adjLabelMap.entrySet()) {
        if (entry.getKey().src().deviceId().equals(deviceId)) {
            srTeHandler.installAdjLabelRule(deviceId, entry.getValue(), entry.getKey().src().port(), entry.getKey().dst().port(), Objective.Operation.ADD);
        }
    }
    srTeHandler.advertiseNodeLabelRule(deviceId, LabelResourceId.labelResourceId(0), IpPrefix.valueOf("0.0.0.0/32"), Objective.Operation.ADD, true);
    return true;
}
#method_after
private boolean syncLabelDb(DeviceId deviceId) {
    checkNotNull(deviceId);
    Map<DeviceId, LabelResourceId> globalNodeLabelMap = pceStore.getGlobalNodeLabels();
    for (Entry<DeviceId, LabelResourceId> entry : globalNodeLabelMap.entrySet()) {
        // Convert from DeviceId to TunnelEndPoint
        Device srcDevice = deviceService.getDevice(entry.getKey());
        /*
             * If there is a slight difference in timing such that if device subsystem has removed the device but PCE
             * store still has it, just ignore such devices.
             */
        if (srcDevice == null) {
            continue;
        }
        String srcLsrId = srcDevice.annotations().value(LSRID);
        if (srcLsrId == null) {
            continue;
        }
        srTeHandler.advertiseNodeLabelRule(deviceId, entry.getValue(), IpPrefix.valueOf(IpAddress.valueOf(srcLsrId), PREFIX_LENGTH), Objective.Operation.ADD, false);
    }
    Map<Link, LabelResourceId> adjLabelMap = pceStore.getAdjLabels();
    for (Entry<Link, LabelResourceId> entry : adjLabelMap.entrySet()) {
        if (entry.getKey().src().deviceId().equals(deviceId)) {
            srTeHandler.installAdjLabelRule(deviceId, entry.getValue(), entry.getKey().src().port(), entry.getKey().dst().port(), Objective.Operation.ADD);
        }
    }
    srTeHandler.advertiseNodeLabelRule(deviceId, LabelResourceId.labelResourceId(0), IpPrefix.valueOf(END_OF_SYNC_IP_PREFIX), Objective.Operation.ADD, true);
    return true;
}
#end_block

#method_before
@Before
public void setUp() throws IOException {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
}
#method_after
@Before
public void setUp() throws IOException {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.deviceService = deviceService;
    tunnelProvider.mastershipService = mastershipService;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepSetupTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010103);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010103))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#method_after
@Test
public void testCasePcepSetupTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010103);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010103))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#end_block

#method_before
@Test
public void testCasePcepSetupSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepSetupSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepSetupTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@After
public void tearDown() throws IOException {
    tunnelProvider.deactivate();
    tunnelProvider.controller = null;
    tunnelProvider.pcepClientController = null;
    tunnelProvider.tunnelProviderRegistry = null;
}
#method_after
@After
public void tearDown() throws IOException {
    tunnelProvider.deactivate();
    tunnelProvider.controller = null;
    tunnelProvider.pcepClientController = null;
    tunnelProvider.tunnelProviderRegistry = null;
    tunnelProvider.deviceService = null;
    tunnelProvider.mastershipService = null;
}
#end_block

#method_before
@Before
public void setUp() throws IOException {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.pcepTunnelApiMapper = pcepTunnelAPIMapper;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.activate();
}
#method_after
@Before
public void setUp() throws IOException {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.deviceService = deviceService;
    tunnelProvider.mastershipService = mastershipService;
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.pcepTunnelApiMapper = pcepTunnelAPIMapper;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.activate();
}
#end_block

#method_before
@Test
public void testCasePcepReleaseTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E20))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepReleaseTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E20))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepReleaseTunnel2() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E22);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E22))).setCapability(new ClientCapability(true, false, false));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#method_after
@Test
public void testCasePcepReleaseTunnel2() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E22);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E22))).setCapability(new ClientCapability(true, false, false, true, true));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#end_block

#method_before
@Test
public void testCasePcepReleaseSrTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E20))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepReleaseSrTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E20))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepReleaseTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E20))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepReleaseTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xB6024E20))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@After
public void tearDown() throws IOException {
    tunnelProvider.deactivate();
    tunnelProvider.controller = null;
    tunnelProvider.pcepClientController = null;
    tunnelProvider.tunnelProviderRegistry = null;
}
#method_after
@After
public void tearDown() throws IOException {
    tunnelProvider.deactivate();
    tunnelProvider.controller = null;
    tunnelProvider.pcepClientController = null;
    tunnelProvider.tunnelProviderRegistry = null;
    tunnelProvider.deviceService = null;
    tunnelProvider.mastershipService = null;
}
#end_block

#method_before
@Override
public void setLspAndDelegationInfo(boolean dFlag, LspInfo lspInfo) {
    lspDelegationInfo.put(lspInfo, dFlag);
}
#method_after
@Override
public void setLspAndDelegationInfo(LspKey lspKey, boolean dFlag) {
    lspDelegationInfo.put(lspKey, dFlag);
}
#end_block

#method_before
@Override
public Boolean delegationInfo(LspInfo lspInfo) {
    return lspDelegationInfo.get(lspInfo);
}
#method_after
@Override
public Boolean delegationInfo(LspKey lspKey) {
    return lspDelegationInfo.get(lspKey);
}
#end_block

#method_before
@Override
public void setLspAndDelegationInfo(boolean dFlag, LspInfo lspInfo) {
    lspDelegationInfo.put(lspInfo, dFlag);
}
#method_after
@Override
public void setLspAndDelegationInfo(LspKey lspKey, boolean dFlag) {
    lspDelegationInfo.put(lspKey, dFlag);
}
#end_block

#method_before
@Override
public Boolean delegationInfo(LspInfo lspInfo) {
    return lspDelegationInfo.get(lspInfo);
}
#method_after
@Override
public Boolean delegationInfo(LspKey lspKey) {
    return lspDelegationInfo.get(lspKey);
}
#end_block

#method_before
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    tunnelService.tunnelIdAsKeyStore.put(tunnel.tunnelId(), tunnel);
}
#method_after
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnelService.tunnelIdAsKeyStore.containsKey(tunnel.tunnelId())) {
        tunnelService.tunnelIdAsKeyStore.replace(tunnel.tunnelId(), tunnel);
    }
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    controller.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1"))).setCapability(new ClientCapability(true, true, true));
    masterShipService.setMaster(true);
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#method_after
@Test
public void tunnelProviderAddedTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    controller.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1"))).setCapability(new ClientCapability(true, true, true, true, true));
    masterShipService.setMaster(true);
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x4e, 0x1f, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x4e, 0x1f, 0x04, 0x00, 0x4e, 0x20, 0x04, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0xb6, // ERO IPv4 sub objects
    0x02, // ERO IPv4 sub objects
    0x4e, // ERO IPv4 sub objects
    0x1f, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // create an existing tunnel.
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e1f0400));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e200400));
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(1)).toString()).set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PCC_TUNNEL_ID, String.valueOf(1)).set(PLSP_ID, String.valueOf(1)).set(LOCAL_LSP_ID, String.valueOf(1)).build();
    Tunnel tunnel = new DefaultTunnel(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, INIT, null, null, TunnelName.tunnelName("T123"), null, annotations);
    tunnelService.setupTunnel(null, null, tunnel, null);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0x4e1f0400));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.getClient(pccId).setLspDbSyncStatus(SYNCED);
    // Process update message.
    controller.processClientMessage(pccId, message);
    assertThat(tunnelService.queryAllTunnels().size(), is(1));
}
#method_after
@Test
public void tunnelProviderAddedTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x4e, 0x1f, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x4e, 0x1f, 0x04, 0x00, 0x4e, 0x20, 0x04, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0xb6, // ERO IPv4 sub objects
    0x02, // ERO IPv4 sub objects
    0x4e, // ERO IPv4 sub objects
    0x1f, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // create an existing tunnel.
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e1f0400));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e200400));
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(1)).toString()).set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PCC_TUNNEL_ID, String.valueOf(1)).set(PLSP_ID, String.valueOf(1)).set(LOCAL_LSP_ID, String.valueOf(1)).set(DELEGATE, String.valueOf("true")).build();
    Tunnel tunnel = new DefaultTunnel(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, INIT, null, null, TunnelName.tunnelName("T123"), null, annotations);
    tunnelService.setupTunnel(null, null, tunnel, null);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0x4e1f0400));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    masterShipService.setMaster(true);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(1, (short) 1), true);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    controller.getClient(pccId).setLspDbSyncStatus(SYNCED);
    // Process update message.
    controller.processClientMessage(pccId, message);
    assertThat(tunnelService.queryAllTunnels().size(), is(1));
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setLspDbSyncStatus(SYNCED);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(true, new LspInfo(1, (short) 1));
    masterShipService.setMaster(true);
    controller.processClientMessage(pccId, message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#method_after
@Test
public void tunnelProviderAddedTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setLspDbSyncStatus(SYNCED);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(1, (short) 1), true);
    masterShipService.setMaster(true);
    controller.processClientMessage(pccId, message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest4() throws PcepParseException, PcepOutOfBoundMessageException, InterruptedException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x02, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // PCC 1.1.1.1, D=0, ONOS as master
    masterShipService.setMaster(true);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    controller.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1"))).setCapability(new ClientCapability(true, true, true));
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    assertThat(tunnelService.tunnelIdAsKeyStore.values().iterator().next().annotations().value(DELEGATE), is("false"));
    // PCC 1.1.1.1, D=1, non-master
    masterShipService.setMaster(false);
    reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    reader = PcepFactories.getGenericReader();
    message = reader.readFrom(buffer);
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
    assertThat(tunnelService.tunnelIdAsKeyStore.values().iterator().next().annotations().value(DELEGATE), is("true"));
}
#method_after
@Test
public void tunnelProviderAddedTest4() throws PcepParseException, PcepOutOfBoundMessageException, InterruptedException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x02, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // PCC 1.1.1.1, D=0, ONOS as master
    masterShipService.setMaster(true);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    controller.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1"))).setCapability(new ClientCapability(true, true, true, true, true));
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    assertThat(tunnelService.tunnelIdAsKeyStore.values().iterator().next().annotations().value(DELEGATE), is("false"));
    // PCC 1.1.1.1, D=1, non-master
    masterShipService.setMaster(false);
    reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    reader = PcepFactories.getGenericReader();
    message = reader.readFrom(buffer);
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    TimeUnit.MILLISECONDS.sleep(4000);
    assertThat(registry.tunnelIdCounter, is((long) 1));
    assertThat(tunnelService.tunnelIdAsKeyStore.values().iterator().next().annotations().value(DELEGATE), is("true"));
}
#end_block

#method_before
@Test
public void testCaseLspDbSync1() throws PcepParseException, PcepOutOfBoundMessageException {
    /* Step 1 create 2 LSPs */
    byte[] reportMsg1 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer1 = ChannelBuffers.dynamicBuffer();
    buffer1.writeBytes(reportMsg1);
    PcepMessageReader<PcepMessage> reader1 = PcepFactories.getGenericReader();
    PcepMessage message1 = reader1.readFrom(buffer1);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(true, new LspInfo(2, (short) 2));
    masterShipService.setMaster(true);
    controller.processClientMessage(pccId, message1);
    /* create 2nd LSP */
    byte[] reportMsg2 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x20, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0x00, 0x02, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer2 = ChannelBuffers.dynamicBuffer();
    buffer2.writeBytes(reportMsg2);
    PcepMessageReader<PcepMessage> reader2 = PcepFactories.getGenericReader();
    PcepMessage message2 = reader2.readFrom(buffer2);
    controller.processClientMessage(pccId, message2);
    /* Assert number of LSPs in DB to be 2. */
    assertThat(registry.tunnelIdCounter, is((long) 2));
    /* Step 2 send sync begin message and LSP 1. */
    byte[] reportMsg3 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x1B, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer3 = ChannelBuffers.dynamicBuffer();
    buffer3.writeBytes(reportMsg3);
    PcepMessageReader<PcepMessage> reader3 = PcepFactories.getGenericReader();
    PcepMessage message3 = reader3.readFrom(buffer3);
    controller.processClientMessage(pccId, message3);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(IN_SYNC));
    /* Step 3 send end of sync marker */
    byte[] reportMsg4 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x24, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, 0x00, 0x00, 0x10, 0x19, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04 };
    ChannelBuffer buffer4 = ChannelBuffers.dynamicBuffer();
    buffer4.writeBytes(reportMsg4);
    PcepMessageReader<PcepMessage> reader4 = PcepFactories.getGenericReader();
    PcepMessage message4 = reader4.readFrom(buffer4);
    controller.processClientMessage(pccId, message4);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(SYNCED));
}
#method_after
@Test
public void testCaseLspDbSync1() throws PcepParseException, PcepOutOfBoundMessageException {
    /* Step 1 create 2 LSPs */
    byte[] reportMsg1 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer1 = ChannelBuffers.dynamicBuffer();
    buffer1.writeBytes(reportMsg1);
    PcepMessageReader<PcepMessage> reader1 = PcepFactories.getGenericReader();
    PcepMessage message1 = reader1.readFrom(buffer1);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(2, (short) 2), true);
    masterShipService.setMaster(true);
    controller.processClientMessage(pccId, message1);
    /* create 2nd LSP */
    byte[] reportMsg2 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x20, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0x00, 0x02, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer2 = ChannelBuffers.dynamicBuffer();
    buffer2.writeBytes(reportMsg2);
    PcepMessageReader<PcepMessage> reader2 = PcepFactories.getGenericReader();
    PcepMessage message2 = reader2.readFrom(buffer2);
    controller.processClientMessage(pccId, message2);
    /* Assert number of LSPs in DB to be 2. */
    assertThat(registry.tunnelIdCounter, is((long) 2));
    /* Step 2 send sync begin message and LSP 1. */
    byte[] reportMsg3 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x1B, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer3 = ChannelBuffers.dynamicBuffer();
    buffer3.writeBytes(reportMsg3);
    PcepMessageReader<PcepMessage> reader3 = PcepFactories.getGenericReader();
    PcepMessage message3 = reader3.readFrom(buffer3);
    controller.processClientMessage(pccId, message3);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(IN_SYNC));
    /* Step 3 send end of sync marker */
    byte[] reportMsg4 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x24, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, 0x00, 0x00, 0x10, 0x19, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04 };
    ChannelBuffer buffer4 = ChannelBuffers.dynamicBuffer();
    buffer4.writeBytes(reportMsg4);
    PcepMessageReader<PcepMessage> reader4 = PcepFactories.getGenericReader();
    PcepMessage message4 = reader4.readFrom(buffer4);
    controller.processClientMessage(pccId, message4);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(SYNCED));
}
#end_block

#method_before
@Test
public void testCaseLspDbSync2() throws PcepParseException, PcepOutOfBoundMessageException {
    /* Step 1 create 2 LSPs */
    byte[] reportMsg1 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer1 = ChannelBuffers.dynamicBuffer();
    buffer1.writeBytes(reportMsg1);
    PcepMessageReader<PcepMessage> reader1 = PcepFactories.getGenericReader();
    PcepMessage message1 = reader1.readFrom(buffer1);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    masterShipService.setMaster(true);
    controller.getClient(pccId).setLspAndDelegationInfo(true, new LspInfo(2, (short) 2));
    controller.processClientMessage(pccId, message1);
    /* create 2nd LSP */
    byte[] reportMsg2 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x20, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0x00, 0x02, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer2 = ChannelBuffers.dynamicBuffer();
    buffer2.writeBytes(reportMsg2);
    PcepMessageReader<PcepMessage> reader2 = PcepFactories.getGenericReader();
    PcepMessage message2 = reader2.readFrom(buffer2);
    controller.processClientMessage(pccId, message2);
    /* Assert number of LSPs in DB to be 2. */
    assertThat(registry.tunnelIdCounter, is((long) 2));
    /* Step 2 send sync begin message and LSP 1. */
    byte[] reportMsg3 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x9B, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer3 = ChannelBuffers.dynamicBuffer();
    buffer3.writeBytes(reportMsg3);
    PcepMessageReader<PcepMessage> reader3 = PcepFactories.getGenericReader();
    PcepMessage message3 = reader3.readFrom(buffer3);
    controller.processClientMessage(pccId, message3);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(IN_SYNC));
    /* Step 3 send end of sync marker */
    byte[] reportMsg4 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x24, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, 0x00, 0x00, 0x10, 0x19, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04 };
    ChannelBuffer buffer4 = ChannelBuffers.dynamicBuffer();
    buffer4.writeBytes(reportMsg4);
    PcepMessageReader<PcepMessage> reader4 = PcepFactories.getGenericReader();
    PcepMessage message4 = reader4.readFrom(buffer4);
    controller.processClientMessage(pccId, message4);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(SYNCED));
}
#method_after
@Test
public void testCaseLspDbSync2() throws PcepParseException, PcepOutOfBoundMessageException {
    /* Step 1 create 2 LSPs */
    byte[] reportMsg1 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer1 = ChannelBuffers.dynamicBuffer();
    buffer1.writeBytes(reportMsg1);
    PcepMessageReader<PcepMessage> reader1 = PcepFactories.getGenericReader();
    PcepMessage message1 = reader1.readFrom(buffer1);
    DefaultAnnotations.Builder newBuilder = DefaultAnnotations.builder();
    newBuilder.set(PcepTunnelProvider.LSRID, "1.1.1.1");
    newBuilder.set(AnnotationKeys.TYPE, "L3");
    Device device = new DefaultDevice(ProviderId.NONE, DeviceId.deviceId("1.1.1.1"), ROUTER, UNKOWN, UNKOWN, UNKOWN, UNKOWN, new ChassisId(), newBuilder.build());
    deviceService.addDevice(device);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    masterShipService.setMaster(true);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(2, (short) 2), true);
    controller.processClientMessage(pccId, message1);
    /* create 2nd LSP */
    byte[] reportMsg2 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x20, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0x00, 0x02, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer2 = ChannelBuffers.dynamicBuffer();
    buffer2.writeBytes(reportMsg2);
    PcepMessageReader<PcepMessage> reader2 = PcepFactories.getGenericReader();
    PcepMessage message2 = reader2.readFrom(buffer2);
    controller.processClientMessage(pccId, message2);
    /* Assert number of LSPs in DB to be 2. */
    assertThat(registry.tunnelIdCounter, is((long) 2));
    /* Step 2 send sync begin message and LSP 1. */
    byte[] reportMsg3 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x9B, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x04, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer3 = ChannelBuffers.dynamicBuffer();
    buffer3.writeBytes(reportMsg3);
    PcepMessageReader<PcepMessage> reader3 = PcepFactories.getGenericReader();
    PcepMessage message3 = reader3.readFrom(buffer3);
    controller.processClientMessage(pccId, message3);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(IN_SYNC));
    /* Step 3 send end of sync marker */
    byte[] reportMsg4 = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x24, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, 0x00, 0x00, 0x10, 0x19, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04 };
    ChannelBuffer buffer4 = ChannelBuffers.dynamicBuffer();
    buffer4.writeBytes(reportMsg4);
    PcepMessageReader<PcepMessage> reader4 = PcepFactories.getGenericReader();
    PcepMessage message4 = reader4.readFrom(buffer4);
    controller.processClientMessage(pccId, message4);
    assertThat(controller.getClient(pccId).lspDbSyncStatus(), is(SYNCED));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnel() {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepSetupTunnel() {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.deviceService = deviceService;
    tunnelProvider.mastershipService = mastershipService;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    controller.getClient(PccId.pccId(IpAddress.valueOf(0xC010101))).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@After
public void tearDown() throws IOException {
    tunnelProvider.deactivate();
    tunnelProvider.controller = null;
    tunnelProvider.pcepClientController = null;
    tunnelProvider.tunnelProviderRegistry = null;
}
#method_after
@After
public void tearDown() throws IOException {
    tunnelProvider.deactivate();
    tunnelProvider.controller = null;
    tunnelProvider.deviceService = null;
    tunnelProvider.mastershipService = null;
    tunnelProvider.pcepClientController = null;
    tunnelProvider.tunnelProviderRegistry = null;
}
#end_block

#method_before
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // Get the pcc client
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // If stateful and PC Initiation capability is not supported by client not sending Initiate msg
    if (pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#method_after
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // Get the pcc client
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // Only master will initiate setup tunnel
    if (pc.capability().pcInstantiationCapability() && mastershipService.isLocalMaster(getDevice(pc.getPccId()))) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.annotations().value(PLSP_ID) != null) {
        updateTunnel(tunnel, path);
        return;
    }
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#method_after
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.annotations().value(PLSP_ID) != null) {
        updateTunnel(tunnel, path);
        return;
    }
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    // Only master will initiate setup tunnel
    if (pc.capability().pcInstantiationCapability() && mastershipService.isLocalMaster(getDevice(pc.getPccId()))) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void releaseTunnel(Tunnel tunnel) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#method_after
@Override
public void releaseTunnel(Tunnel tunnel) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // Only master will release tunnel
    if (pc.capability().pcInstantiationCapability() && mastershipService.isLocalMaster(getDevice(pc.getPccId()))) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#end_block

#method_before
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#method_after
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    // Only master will release tunnel
    if (pc.capability().pcInstantiationCapability() && mastershipService.isLocalMaster(getDevice(pc.getPccId()))) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#end_block

#method_before
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // LSP].
    if (pc.capability().statefulPceCapability() && pc.delegationInfo(new LspInfo(Integer.valueOf(tunnel.annotations().value(PLSP_ID)), Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)))).booleanValue()) {
        pcepUpdateTunnel(tunnel, path, pc);
    }
}
#method_after
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // LSP].If annotation is null D flag is not set else it is set.
    if (pc.capability().statefulPceCapability() && pc.delegationInfo(new LspKey(Integer.valueOf(tunnel.annotations().value(PLSP_ID)), Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)))) != null) {
        pcepUpdateTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    // LSP].
    if (pc.capability().statefulPceCapability() && pc.delegationInfo(new LspInfo(Integer.valueOf(tunnel.annotations().value(PLSP_ID)), Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)))).booleanValue()) {
        pcepUpdateTunnel(tunnel, path, pc);
    }
}
#method_after
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    // LSP].If annotation is null D flag is not set else it is set.
    if (pc.capability().statefulPceCapability() && pc.delegationInfo(new LspKey(Integer.valueOf(tunnel.annotations().value(PLSP_ID)), Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)))) != null) {
        pcepUpdateTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
private SparseAnnotations getAnnotations(PcepLspObject lspObj, StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv, int bandwidth, LspType lspType) {
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(ipv4LspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(ipv4LspIdenTlv.getLspId())).set(DELEGATE, String.valueOf(lspObj.getDFlag())).build();
    return annotations;
}
#method_after
private SparseAnnotations getAnnotations(PcepLspObject lspObj, StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv, float bandwidth, LspType lspType) {
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Float(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(ipv4LspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(ipv4LspIdenTlv.getLspId())).set(DELEGATE, String.valueOf(lspObj.getDFlag())).build();
    return annotations;
}
#end_block

#method_before
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId, PcepSyncStatus syncStatus) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    Path path = buildPathFromEroObj(eroObj, providerId);
    int bandwidth = 0;
    if (msgPath.getBandwidthObject() != null) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    /*
             * To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
             * from PCE.
             */
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = getLspType(srpObj);
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    // Store delegation flag info and that LSP info because only delegated PCE sends update message
    pcepClientController.getClient(pccId).setLspAndDelegationInfo(lspObj.getDFlag(), new LspInfo(lspObj.getPlspId(), ipv4LspIdenTlv.getLspId()));
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    SparseAnnotations annotations = null;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        if (lspObj.getCFlag()) {
            /*
                     * While in sync, if PCRpt is received for PCE init LSP and PCE doesn't have entry, mark to send
                     * delete message on end of sync.
                     */
            annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType);
            // Generate tunnel id for the temporary tunnel.
            String onosTunnelId = "PCC" + String.valueOf(ipv4LspIdenTlv.getTunnelId());
            Tunnel tunnelToBeDeleted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), TunnelId.valueOf(onosTunnelId), TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            /*
                     * Need to send PCInitiate delete msg for a tunnel which does not exist at PCE. For that some dummy
                     * data-structures need to be populated.
                     */
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelToBeDeleted, path, RequestType.DELETE);
            pcepTunnelData.setPlspId(lspObj.getPlspId());
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
            pcepTunnelApiMapper.handleCreateTunnelRequestQueue(0, pcepTunnelData);
            /*
                     * Add to the list of tunnels for which PCInit delete will be sent at the end of sync.
                     */
            List<Tunnel> tunnelToBeDeletedList = syncCompleteDeleteList.get(pccId.ipAddress());
            tunnelToBeDeletedList.add(tunnelToBeDeleted);
            syncCompleteDeleteList.put(pccId.ipAddress(), tunnelToBeDeletedList);
            return;
        }
        DeviceId deviceId = getDevice(pccId);
        if (deviceId == null) {
            log.error("Ingress deviceId not found");
            return;
        }
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        /*
                 * If ONOS instance is master for PCC then set delegated flag as annotation and add the tunnel to store.
                 * Because all LSPs need not be delegated, hence mastership for the PCC is confirmed whereas not the
                 * delegation set to all LSPs.If ONOS is not the master for that PCC then check if D flag is set, if yes
                 * wait for 2 seconds [while master has added the tunnel to the store] then update the tunnel. Tunnel is
                 * updated because in case of resilency only delegated LSPs are recomputed and only delegated PCE can
                 * send update message to that client.
                 */
        if (mastershipService.isLocalMaster(deviceId)) {
            TunnelId tId = tunnelAdded(td, tunnelState);
            Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        }
    } else {
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        tunnelUpdateInDelegatedCase(pccId, annotations, td, tunnelQueryResult, providerId, lspObj.getDFlag());
        return;
    }
    if ((syncStatus == IN_SYNC) && (lspObj.getCFlag()) && (tunnelState != tunnel.state())) {
        // Mark to send PCUpd msg with state known at PCE.
        List<Tunnel> tunnelToBeUpdateList = syncCompleteUpdateList.get(pccId.ipAddress());
        tunnelToBeUpdateList.add(tunnel);
        syncCompleteUpdateList.put(pccId.ipAddress(), tunnelToBeUpdateList);
        return;
    }
    td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), tunnel.path(), (SparseAnnotations) tunnel.annotations());
    if (lspObj.getRFlag()) {
        tunnelRemoved(td);
    } else {
        if (syncStatus == IN_SYNC) {
            markLspDbEntryAsLatest(pccId, tunnel.tunnelId());
        }
        tunnelUpdated(td, tunnelState);
    }
    return;
}
#method_after
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId, PcepSyncStatus syncStatus) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    Path path = buildPathFromEroObj(eroObj, providerId);
    float bandwidth = 0;
    if (msgPath.getBandwidthObject() != null) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    /*
             * To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
             * from PCE.
             */
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = getLspType(srpObj);
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    // not present then non-delegated , if present it is delegated.
    if (lspObj.getDFlag()) {
        pcepClientController.getClient(pccId).setLspAndDelegationInfo(new LspKey(lspObj.getPlspId(), ipv4LspIdenTlv.getLspId()), lspObj.getDFlag());
    }
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    SparseAnnotations annotations = null;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        if (lspObj.getCFlag()) {
            /*
                     * While in sync, if PCRpt is received for PCE init LSP and PCE doesn't have entry, mark to send
                     * delete message on end of sync.
                     */
            annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType);
            // Generate tunnel id for the temporary tunnel.
            String onosTunnelId = "PCC" + String.valueOf(ipv4LspIdenTlv.getTunnelId());
            Tunnel tunnelToBeDeleted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), TunnelId.valueOf(onosTunnelId), TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            /*
                     * Need to send PCInitiate delete msg for a tunnel which does not exist at PCE. For that some dummy
                     * data-structures need to be populated.
                     */
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelToBeDeleted, path, RequestType.DELETE);
            pcepTunnelData.setPlspId(lspObj.getPlspId());
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
            pcepTunnelApiMapper.handleCreateTunnelRequestQueue(0, pcepTunnelData);
            /*
                     * Add to the list of tunnels for which PCInit delete will be sent at the end of sync.
                     */
            List<Tunnel> tunnelToBeDeletedList = syncCompleteDeleteList.get(pccId.ipAddress());
            tunnelToBeDeletedList.add(tunnelToBeDeleted);
            syncCompleteDeleteList.put(pccId.ipAddress(), tunnelToBeDeletedList);
            return;
        }
        DeviceId deviceId = getDevice(pccId);
        if (deviceId == null) {
            log.error("Ingress deviceId not found");
            return;
        }
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        /*
                 * If ONOS instance is master for PCC then set delegated flag as annotation and add the tunnel to store.
                 * Because all LSPs need not be delegated, hence mastership for the PCC is confirmed whereas not the
                 * delegation set to all LSPs.If ONOS is not the master for that PCC then check if D flag is set, if yes
                 * wait for 2 seconds [while master has added the tunnel to the store] then update the tunnel. Tunnel is
                 * updated because in case of resilency only delegated LSPs are recomputed and only delegated PCE can
                 * send update message to that client.
                 *
                 * 1)Master can 1st get the Rpt message
                 * a)Master adds the tunnel into core.
                 * b)If a non-master for ingress gets Rpt message with D flag set[as delegation owner]
                 *  after master, then runs timer then update the tunnel with D flag set.
                 * 2)Non-Master can 1st get the Rpt message
                 * a)Non-Master runs the timer check for the tunnel then updates the tunnel with D flag set
                 * b)Master would have got the message while the non-master running timer, hence master adds
                 *  tunnel to core
                 *
                 * In general always master adds the tunnel to the core
                 * while delegated owner [master or non-master with D flag set] always updates the tunnel running timer
                 */
        if (mastershipService.isLocalMaster(deviceId)) {
            TunnelId tId = tunnelAdded(td, tunnelState);
            Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        } else if (!mastershipService.isLocalMaster(deviceId) && lspObj.getDFlag()) {
            // Start timer then update the tunnel with D flag
            tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
        }
        return;
    }
    // delegated owner will update can be a master or non-master
    if (lspObj.getDFlag()) {
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, annotations);
        tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
    }
    if ((syncStatus == IN_SYNC) && (lspObj.getCFlag()) && (tunnelState != tunnel.state())) {
        // Mark to send PCUpd msg with state known at PCE.
        List<Tunnel> tunnelToBeUpdateList = syncCompleteUpdateList.get(pccId.ipAddress());
        tunnelToBeUpdateList.add(tunnel);
        syncCompleteUpdateList.put(pccId.ipAddress(), tunnelToBeUpdateList);
        return;
    }
    removeOrUpdatetunnel(tunnel, pccId, lspObj, providerId, syncStatus, tunnelState);
    return;
}
#end_block

#method_before
private void tunnelUpdateInDelegatedCase(PccId pccId, SparseAnnotations annotations, DefaultTunnelDescription td, Collection<Tunnel> tunnelQueryResult, ProviderId providerId, boolean dFlag) {
    DeviceId deviceId = getDevice(pccId);
    TunnelId tempTunnelId = null;
    /*
             * If ONOS is not the master for that PCC then check if D flag is set, if yes wait for 2 seconds
             * [while master has added the tunnel to the store] then update the tunnel.
             */
    if (!mastershipService.isLocalMaster(deviceId) && dFlag) {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        for (Tunnel t : tunnelQueryResult) {
            if (t.tunnelName().equals(td.tunnelName()) && t.annotations().value(PLSP_ID).equals(td.annotations().value(PLSP_ID))) {
                tempTunnelId = t.tunnelId();
            }
        }
        if (tempTunnelId == null) {
            log.error("Tunnel ID not found ");
            return;
        }
        Tunnel tunnel = new DefaultTunnel(providerId, td.src(), td.dst(), MPLS, new DefaultGroupId(0), tempTunnelId, td.tunnelName(), td.path(), annotations);
        // Thread is started after 2 seconds to update the tunnel
        ScheduledFuture<?> future = executor.schedule(new UpdateDelegation(tunnel, td.path()), DELAY, TimeUnit.SECONDS);
        try {
            if (future.get() == null) {
                executor.shutdown();
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception while updating tunnel with D flag");
        }
    }
}
#method_after
private void tunnelUpdateInDelegatedCase(PccId pccId, SparseAnnotations annotations, DefaultTunnelDescription td, ProviderId providerId) {
    // Wait for 2sec then query tunnel based on ingress PLSP-ID and local LSP-ID
    /*
             * If ONOS is not the master for that PCC then check if D flag is set, if yes wait [while
             * master has added the tunnel to the store] then update the tunnel.
             */
    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
    // Thread is started after 2 seconds first time later periodically after 2 seconds to update the tunnel
    executor.scheduleAtFixedRate(new UpdateDelegation(td, providerId, annotations, pccId, executor), DELAY, DELAY, TimeUnit.SECONDS);
}
#end_block

#method_before
@Override
public void run() {
    tunnelUpdated(tunnel, path);
}
#method_after
@Override
public void run() {
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(td.src(), td.dst());
    TunnelId tempTunnelId = null;
    for (Tunnel t : tunnelQueryResult) {
        if (t.annotations().value(LOCAL_LSP_ID) == null || t.annotations().value(PLSP_ID) == null) {
            continue;
        }
        if (t.annotations().value(LOCAL_LSP_ID).equals(td.annotations().value(LOCAL_LSP_ID)) && t.annotations().value(PLSP_ID).equals(td.annotations().value(PLSP_ID)) && ((IpTunnelEndPoint) t.src()).ip().equals(pccId.id())) {
            tempTunnelId = t.tunnelId();
            break;
        }
    }
    // periodically
    if (tempTunnelId != null) {
        Tunnel tunnel = new DefaultTunnel(providerId, td.src(), td.dst(), MPLS, new DefaultGroupId(0), tempTunnelId, td.tunnelName(), td.path(), annotations);
        tunnelUpdated(tunnel, td.path());
        executor.shutdown();
        try {
            executor.awaitTermination(WAIT_TIME, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("updating delegation failed");
        }
    }
}
#end_block

#method_before
@Test
public void testCasePcepUpdateTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(true, new LspInfo(1, (short) 1));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepUpdateTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(1, (short) 1), true);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepUpdateTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(true, new LspInfo(1, (short) 1));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#method_after
@Test
public void testCasePcepUpdateTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(1, (short) 1), true);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#end_block

#method_before
@Test
public void testCasePcepUpdateSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(true, new LspInfo(1, (short) 1));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepUpdateSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(1, (short) 1), true);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepUpdateTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(true, new LspInfo(1, (short) 1));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepUpdateTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10024));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PcepAnnotationKeys.PLSP_ID, "1").set(PcepAnnotationKeys.LOCAL_LSP_ID, "1").build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0xD010101));
    PcepClientAdapter pc = new PcepClientAdapter();
    pc.init(pccId, PcepVersion.PCEP_1);
    controller.getClient(pccId).setLspAndDelegationInfo(new LspKey(1, (short) 1), true);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true, true, true));
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Override
public void addNode(PcepClient pc) {
    if (deviceProviderService == null) {
        return;
    }
    // Right now device URI for PCEP devices is their LSRID
    DeviceId deviceId = deviceId(uri(new PcepDpid(pc.getPccId().id().toString())));
    ChassisId cId = new ChassisId();
    Device.Type deviceType = Device.Type.ROUTER;
    DefaultAnnotations.Builder annotationBuilder = DefaultAnnotations.builder();
    // Device type PCEP
    annotationBuilder.set(AnnotationKeys.TYPE, "pcep");
    // PCC capabilities (SR, PCECC and PCECC-SR)
    annotationBuilder.set(SR_CAPABILITY, String.valueOf(pc.capability().srCapability()));
    annotationBuilder.set(PCECC_CAPABILITY, String.valueOf(pc.capability().pceccCapability()));
    annotationBuilder.set(LABEL_STACK_CAPABILITY, String.valueOf(pc.capability().labelStackCapability()));
    // PccId is the lsrId contained in openMsg, if not present it will be the socket address
    annotationBuilder.set(LSRID, String.valueOf(pc.getPccId().id().getIp4Address().toInt()));
    DeviceDescription description = new DefaultDeviceDescription(deviceId.uri(), deviceType, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cId, annotationBuilder.build());
    deviceProviderService.deviceConnected(deviceId, description);
}
#method_after
@Override
public void addNode(PcepClient pc) {
    if (deviceProviderService == null) {
        return;
    }
    // Right now device URI for PCEP devices is their LSRID
    DeviceId deviceId = deviceId(uri(new PcepDpid(pc.getPccId().id().getIp4Address().toInt())));
    ChassisId cId = new ChassisId();
    Device.Type deviceType = Device.Type.ROUTER;
    DefaultAnnotations.Builder annotationBuilder = DefaultAnnotations.builder();
    // PCC capabilities (SR, PCECC and PCECC-SR)
    annotationBuilder.set(SR_CAPABILITY, String.valueOf(pc.capability().srCapability()));
    annotationBuilder.set(PCECC_CAPABILITY, String.valueOf(pc.capability().pceccCapability()));
    annotationBuilder.set(LABEL_STACK_CAPABILITY, String.valueOf(pc.capability().labelStackCapability()));
    // PccId is the lsrId contained in openMsg, if not present it will be the socket address
    annotationBuilder.set(LSRID, String.valueOf(pc.getPccId().id()));
    DeviceDescription description = new DefaultDeviceDescription(deviceId.uri(), deviceType, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cId, annotationBuilder.build());
    deviceProviderService.deviceConnected(deviceId, description);
}
#end_block

#method_before
@Override
public void deleteNode(PccId pccId) {
    if (deviceProviderService == null || deviceService == null) {
        return;
    }
    // TODO: In device manager, in deviceDisconnected() method, get the device but null check is not validated
    if (deviceService.getDevice(DeviceId.deviceId(uri(new PcepDpid(pccId.id().toString())))) == null) {
        return;
    }
    deviceProviderService.deviceDisconnected(deviceId(uri(new PcepDpid(pccId.id().toString()))));
}
#method_after
@Override
public void deleteNode(PccId pccId) {
    if (deviceProviderService == null || deviceService == null) {
        return;
    }
    // TODO: In device manager, in deviceDisconnected() method, get the device but null check is not validated
    if (deviceService.getDevice(DeviceId.deviceId(uri(new PcepDpid(pccId.id().getIp4Address().toInt())))) == null) {
        return;
    }
    deviceProviderService.deviceDisconnected(deviceId(uri(new PcepDpid(pccId.id().getIp4Address().toInt()))));
}
#end_block

#method_before
@Override
public AccessDeviceData getAccessDevice(DeviceId deviceId) {
    checkNotNull(deviceId, "Device ID cannot be null");
    return accessDevices.get(deviceId);
}
#method_after
@Override
public Optional<AccessDeviceData> getAccessDevice(DeviceId deviceId) {
    checkNotNull(deviceId, "Device ID cannot be null");
    return Optional.ofNullable(accessDevices.get(deviceId));
}
#end_block

#method_before
@Override
public AccessAgentData getAccessAgent(DeviceId deviceId) {
    checkNotNull(deviceId, "Device ID cannot be null");
    return accessAgents.get(deviceId);
}
#method_after
@Override
public Optional<AccessAgentData> getAccessAgent(DeviceId deviceId) {
    checkNotNull(deviceId, "Device ID cannot be null");
    return Optional.ofNullable(accessAgents.get(deviceId));
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            if (event.configClass().equals(ACCESS_DEVICE_CONFIG_CLASS)) {
                // XXX assumes we know we have the right subject
                addAccessDeviceConfig((DeviceId) event.subject());
            } else if (event.configClass().equals(ACCESS_AGENT_CONFIG_CLASS)) {
                addAccessAgentConfig((DeviceId) event.subject());
            }
            break;
        case CONFIG_REMOVED:
            if (event.configClass().equals(ACCESS_DEVICE_CONFIG_CLASS)) {
                removeAccessDeviceConfig((DeviceId) event.subject());
            } else if (event.configClass().equals(ACCESS_AGENT_CONFIG_CLASS)) {
                removeAccessAgentConfig((DeviceId) event.subject());
            }
            break;
        case CONFIG_REGISTERED:
        case CONFIG_UNREGISTERED:
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_ADDED:
        case CONFIG_UPDATED:
            if (event.configClass().equals(ACCESS_DEVICE_CONFIG_CLASS)) {
                addAccessDeviceConfig((DeviceId) event.subject());
            } else if (event.configClass().equals(ACCESS_AGENT_CONFIG_CLASS)) {
                addAccessAgentConfig((DeviceId) event.subject());
            }
            break;
        case CONFIG_REMOVED:
            if (event.configClass().equals(ACCESS_DEVICE_CONFIG_CLASS)) {
                removeAccessDeviceConfig((DeviceId) event.subject());
            } else if (event.configClass().equals(ACCESS_AGENT_CONFIG_CLASS)) {
                removeAccessAgentConfig((DeviceId) event.subject());
            }
            break;
        case CONFIG_REGISTERED:
        case CONFIG_UNREGISTERED:
        default:
            break;
    }
}
#end_block

#method_before
@Before
public void setUp() {
    manager = new SdxL2Manager();
    manager.appId = new TestApplicationId("sdxl2-test");
    manager.sdxL2Store = new SdxL2TestStore();
}
#method_after
@Before
public void setUp() {
    manager = new SdxL2Manager();
    manager.appId = new TestApplicationId("sdxl2-test");
    SdxL2DistributedStore store = new SdxL2DistributedStore();
    store.initForTest();
    manager.sdxL2Store = store;
}
#end_block

#method_before
@Override
public void createSdxL2(String sdxl2) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    checkState(!sdxl2.contains(","), "sdxl2 names cannot contain commas");
    checkState(!sdxl2.contains("|"), "sdxl2 names cannot contain pipe");
    checkState(!sdxl2.contains("-"), "sdxl2 names cannot contain dash");
    checkState(!sdxl2.contains(":"), "sdxl2 names cannot contain colon");
    try {
        this.sdxL2Store.putSdxL2(sdxl2);
    } catch (SdxL2Exception e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void createSdxL2(String sdxl2) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    checkState(!sdxl2.contains(","), "sdxl2 names cannot contain commas");
    checkState(!sdxl2.contains("|"), "sdxl2 names cannot contain pipe");
    checkState(!sdxl2.contains("-"), "sdxl2 names cannot contain dash");
    checkState(!sdxl2.contains(":"), "sdxl2 names cannot contain colon");
    try {
        this.sdxL2Store.putSdxL2(sdxl2);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void deleteSdxL2(String sdxl2) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    try {
        this.sdxL2Store.removeSdxL2(sdxl2);
    } catch (SdxL2Exception e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void deleteSdxL2(String sdxl2) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    try {
        this.sdxL2Store.removeSdxL2(sdxl2);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void addSdxL2ConnectionPoint(String sdxl2, SdxL2ConnectionPoint sdxl2cp) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    checkNotNull(sdxl2cp, "SdxL2ConnectionPoint cannot be null");
    try {
        this.sdxL2Store.addSdxL2ConnectionPoint(sdxl2, sdxl2cp);
    } catch (SdxL2Exception e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void addSdxL2ConnectionPoint(String sdxl2, SdxL2ConnectionPoint sdxl2cp) {
    checkNotNull(sdxl2, "sdxl2 name cannot be null");
    checkNotNull(sdxl2cp, "SdxL2ConnectionPoint cannot be null");
    try {
        this.sdxL2Store.addSdxL2ConnectionPoint(sdxl2, sdxl2cp);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Set<String> getSdxL2ConnectionPoints(Optional<String> sdxl2) {
    try {
        return this.sdxL2Store.getSdxL2ConnectionPoints(sdxl2);
    } catch (SdxL2Exception e) {
        e.printStackTrace();
    }
    return Collections.emptySet();
}
#method_after
@Override
public Set<String> getSdxL2ConnectionPoints(Optional<String> sdxl2) {
    try {
        return this.sdxL2Store.getSdxL2ConnectionPoints(sdxl2);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public void removeSdxL2ConnectionPoint(String sdxl2cp) {
    checkNotNull(sdxl2cp, "SdxL2ConnectionPoint name cannot be null");
    try {
        this.sdxL2Store.removeSdxL2ConnectionPoint(sdxl2cp);
    } catch (SdxL2Exception e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void removeSdxL2ConnectionPoint(String sdxl2cp) {
    checkNotNull(sdxl2cp, "SdxL2ConnectionPoint name cannot be null");
    try {
        this.sdxL2Store.removeSdxL2ConnectionPoint(sdxl2cp);
    } catch (SdxL2Exception e) {
        log.info(e.getMessage());
    }
}
#end_block

#method_before
private KryoSerializer createSerializer(KryoNamespace.Builder builder) {
    return new KryoSerializer() {

        @Override
        protected void setupKryoPool() {
            // Add the map's internal helper classes to the user-supplied serializer
            serializerPool = builder.register(KryoNamespaces.BASIC).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).register(LogicalTimestamp.class).register(WallClockTimestamp.class).register(AntiEntropyAdvertisement.class).register(AntiEntropyResponse.class).register(UpdateEntry.class).register(MapValue.class).register(MapValue.Digest.class).build();
        }
    };
}
#method_after
private StoreSerializer createSerializer(KryoNamespace ns) {
    return StoreSerializer.using(KryoNamespace.newBuilder().register(ns).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID + 100).register(KryoNamespaces.BASIC).register(LogicalTimestamp.class).register(WallClockTimestamp.class).register(AntiEntropyAdvertisement.class).register(AntiEntropyResponse.class).register(UpdateEntry.class).register(MapValue.class).register(MapValue.Digest.class).build(name() + "-ecmap"));
}
#end_block

#method_before
@Override
public void put(K key, V value) {
    checkState(!destroyed, destroyedMessage);
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    MapValue<V> newValue = new MapValue<>(value, timestampProvider.apply(key, value));
    if (putInternal(key, newValue)) {
        notifyPeers(new UpdateEntry<K, V>(key, newValue), peerUpdateFunction.apply(key, value));
        notifyListeners(new EventuallyConsistentMapEvent<>(mapName, PUT, key, value));
    }
}
#method_after
@Override
public void put(K key, V value) {
    checkState(!destroyed, destroyedMessage);
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    MapValue<V> newValue = new MapValue<>(value, timestampProvider.apply(key, value));
    if (putInternal(key, newValue)) {
        notifyPeers(new UpdateEntry<>(key, newValue), peerUpdateFunction.apply(key, value));
        notifyListeners(new EventuallyConsistentMapEvent<>(mapName, PUT, key, value));
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Void> destroy() {
    destroyed = true;
    executor.shutdown();
    backgroundExecutor.shutdown();
    communicationExecutor.shutdown();
    listeners.clear();
    clusterCommunicator.removeSubscriber(updateMessageSubject);
    clusterCommunicator.removeSubscriber(antiEntropyAdvertisementSubject);
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> destroy() {
    destroyed = true;
    executor.shutdown();
    backgroundExecutor.shutdown();
    communicationExecutor.shutdown();
    listeners.clear();
    clusterCommunicator.removeSubscriber(updateMessageSubject);
    clusterCommunicator.removeSubscriber(updateRequestSubject);
    clusterCommunicator.removeSubscriber(antiEntropyAdvertisementSubject);
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
private AntiEntropyAdvertisement<K> createAdvertisement() {
    return new AntiEntropyAdvertisement<K>(localNodeId, ImmutableMap.copyOf(Maps.transformValues(items, MapValue::digest)));
}
#method_after
private AntiEntropyAdvertisement<K> createAdvertisement() {
    return new AntiEntropyAdvertisement<>(localNodeId, ImmutableMap.copyOf(Maps.transformValues(items, MapValue::digest)));
}
#end_block

#method_before
private List<EventuallyConsistentMapEvent<K, V>> antiEntropyCheckLocalItems(AntiEntropyAdvertisement<K> ad) {
    final List<EventuallyConsistentMapEvent<K, V>> externalEvents = Lists.newLinkedList();
    final NodeId sender = ad.sender();
    Set<K> staleOrMissing = new HashSet<>();
    Set<K> remoteKeys = ad.digest().keySet();
    items.forEach((key, localValue) -> {
        MapValue.Digest remoteValueDigest = ad.digest().get(key);
        if (remoteValueDigest == null || localValue.isNewerThan(remoteValueDigest.timestamp())) {
            // local value is more recent, push to sender
            queueUpdate(new UpdateEntry<>(key, localValue), ImmutableList.of(sender));
        } else if (remoteValueDigest != null && remoteValueDigest.isNewerThan(localValue.digest()) && remoteValueDigest.isTombstone()) {
            // remote value is more recent and a tombstone: update local value
            MapValue<V> tombstone = MapValue.tombstone(remoteValueDigest.timestamp());
            MapValue<V> previousValue = removeInternal(key, Optional.empty(), Optional.of(tombstone));
            if (previousValue != null && previousValue.isAlive()) {
                externalEvents.add(new EventuallyConsistentMapEvent<>(mapName, REMOVE, key, previousValue.get()));
            }
        } else if (remoteValueDigest.isNewerThan(localValue.digest())) {
            // Not a tombstone and remote is newer
            staleOrMissing.add(key);
        }
    });
    // Keys missing in local map
    Sets.difference(remoteKeys, items.keySet()).forEach((key) -> staleOrMissing.add(key));
    // Request updates that we missed out on
    sendRequestToPeer(sender, staleOrMissing);
    return externalEvents;
}
#method_after
private List<EventuallyConsistentMapEvent<K, V>> antiEntropyCheckLocalItems(AntiEntropyAdvertisement<K> ad) {
    final List<EventuallyConsistentMapEvent<K, V>> externalEvents = Lists.newLinkedList();
    final NodeId sender = ad.sender();
    final List<NodeId> peers = ImmutableList.of(sender);
    Set<K> staleOrMissing = new HashSet<>();
    Set<K> locallyUnknown = new HashSet<>(ad.digest().keySet());
    items.forEach((key, localValue) -> {
        locallyUnknown.remove(key);
        MapValue.Digest remoteValueDigest = ad.digest().get(key);
        if (remoteValueDigest == null || localValue.isNewerThan(remoteValueDigest.timestamp())) {
            // local value is more recent, push to sender
            queueUpdate(new UpdateEntry<>(key, localValue), peers);
        } else if (remoteValueDigest != null && remoteValueDigest.isNewerThan(localValue.digest()) && remoteValueDigest.isTombstone()) {
            // remote value is more recent and a tombstone: update local value
            MapValue<V> tombstone = MapValue.tombstone(remoteValueDigest.timestamp());
            MapValue<V> previousValue = removeInternal(key, Optional.empty(), Optional.of(tombstone));
            if (previousValue != null && previousValue.isAlive()) {
                externalEvents.add(new EventuallyConsistentMapEvent<>(mapName, REMOVE, key, previousValue.get()));
            }
        } else if (remoteValueDigest.isNewerThan(localValue.digest())) {
            // Not a tombstone and remote is newer
            staleOrMissing.add(key);
        }
    });
    // Keys missing in local map
    staleOrMissing.addAll(locallyUnknown);
    // Request updates that we missed out on
    sendUpdateRequestToPeer(sender, staleOrMissing);
    return externalEvents;
}
#end_block

#method_before
private void handleUpdateRequests(UpdateRequest<K> request) {
    final Set<K> keys = request.keys();
    final NodeId sender = request.sender();
    keys.forEach(key -> queueUpdate(new UpdateEntry<>(key, items.get(key)), ImmutableList.of(sender)));
}
#method_after
private void handleUpdateRequests(UpdateRequest<K> request) {
    final Set<K> keys = request.keys();
    final NodeId sender = request.sender();
    final List<NodeId> peers = ImmutableList.of(sender);
    keys.forEach(key -> queueUpdate(new UpdateEntry<>(key, items.get(key)), peers));
}
#end_block

#method_before
@Test
public void testDestroy() throws Exception {
    clusterCommunicator.removeSubscriber(UPDATE_MESSAGE_SUBJECT);
    clusterCommunicator.removeSubscriber(ANTI_ENTROPY_MESSAGE_SUBJECT);
    replay(clusterCommunicator);
    ecMap.destroy();
    verify(clusterCommunicator);
    try {
        ecMap.get(KEY1);
        fail("get after destroy should throw exception");
    } catch (IllegalStateException e) {
        assertTrue(true);
    }
    try {
        ecMap.put(KEY1, VALUE1);
        fail("put after destroy should throw exception");
    } catch (IllegalStateException e) {
        assertTrue(true);
    }
}
#method_after
@Test
public void testDestroy() throws Exception {
    clusterCommunicator.removeSubscriber(UPDATE_MESSAGE_SUBJECT);
    clusterCommunicator.removeSubscriber(UPDATE_REQUEST_SUBJECT);
    clusterCommunicator.removeSubscriber(ANTI_ENTROPY_MESSAGE_SUBJECT);
    replay(clusterCommunicator);
    ecMap.destroy();
    verify(clusterCommunicator);
    try {
        ecMap.get(KEY1);
        fail("get after destroy should throw exception");
    } catch (IllegalStateException e) {
        assertTrue(true);
    }
    try {
        ecMap.put(KEY1, VALUE1);
        fail("put after destroy should throw exception");
    } catch (IllegalStateException e) {
        assertTrue(true);
    }
}
#end_block

#method_before
private boolean isValidProbe(String mac, ONOSLLDP probe) {
    // don't consider ourselves valid if we're using DEFAULT_MAC
    String ourMac = buildMac();
    if (mac.equalsIgnoreCase(ourMac) || ProbedLinkProvider.defaultMac().equalsIgnoreCase(ourMac)) {
        return false;
    }
    return probe.getDeviceString().contains("bigswitch");
}
#method_after
private boolean isValidProbe(String mac, ONOSLLDP probe) {
    // don't consider ourselves valid if we're using DEFAULT_MAC
    String ourMac = buildMac();
    if (mac.equalsIgnoreCase(ourMac) || ProbedLinkProvider.defaultMac().equalsIgnoreCase(ourMac)) {
        return false;
    }
    // TODO Come up with more rubust way to identify bigswitch probe?
    return probe.getDeviceString().contains("bigswitch");
}
#end_block

#method_before
private Collection<PointToPointIntent> buildIntents(ConnectPoint portOne, VlanId vlanOne, IpAddress ipOne, ConnectPoint portTwo, VlanId vlanTwo, IpAddress ipTwo) {
    List<PointToPointIntent> intents = new ArrayList<>();
    TrafficTreatment.Builder treatmentToPeer = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder treatmentToSpeaker = DefaultTrafficTreatment.builder();
    TrafficSelector selector;
    Key key;
    byte tcpProtocol;
    byte icmpProtocol;
    if (ipOne.isIp4()) {
        tcpProtocol = IPv4.PROTOCOL_TCP;
        icmpProtocol = IPv4.PROTOCOL_ICMP;
    } else {
        tcpProtocol = IPv6.PROTOCOL_TCP;
        icmpProtocol = IPv6.PROTOCOL_ICMP6;
    }
    // Add treatment for VLAN for traffic going from BGP speaker to BGP peer
    if (!vlanTwo.equals(VlanId.NONE) && !vlanOne.equals(vlanTwo)) {
        treatmentToPeer.setVlanId(vlanTwo);
    }
    // Path from BGP speaker to BGP peer matching destination TCP port 179
    selector = buildSelector(tcpProtocol, vlanOne, ipOne, ipTwo, null, BGP_PORT);
    key = buildKey(ipOne, ipTwo, SUFFIX_DST);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToPeer.build()).ingressPoint(portOne).egressPoint(portTwo).priority(PRIORITY_OFFSET).build());
    // Path from BGP speaker to BGP peer matching source TCP port 179
    selector = buildSelector(tcpProtocol, vlanOne, ipOne, ipTwo, BGP_PORT, null);
    key = buildKey(ipOne, ipTwo, SUFFIX_SRC);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToPeer.build()).ingressPoint(portOne).egressPoint(portTwo).priority(PRIORITY_OFFSET).build());
    // ICMP path from BGP speaker to BGP peer
    selector = buildSelector(icmpProtocol, vlanOne, ipOne, ipTwo, null, null);
    key = buildKey(ipOne, ipTwo, SUFFIX_ICMP);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToPeer.build()).ingressPoint(portOne).egressPoint(portTwo).priority(PRIORITY_OFFSET).build());
    // Add treatment for VLAN for traffic going from BGP peer to BGP speaker
    if (!vlanOne.equals(VlanId.NONE) && !vlanOne.equals(vlanTwo)) {
        treatmentToSpeaker.setVlanId(vlanOne);
    }
    // Path from BGP peer to BGP speaker matching destination TCP port 179
    selector = buildSelector(tcpProtocol, vlanTwo, ipTwo, ipOne, null, BGP_PORT);
    key = buildKey(ipTwo, ipOne, SUFFIX_DST);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToSpeaker.build()).ingressPoint(portTwo).egressPoint(portOne).priority(PRIORITY_OFFSET).build());
    // Path from BGP peer to BGP speaker matching source TCP port 179
    selector = buildSelector(tcpProtocol, vlanTwo, ipTwo, ipOne, BGP_PORT, null);
    key = buildKey(ipTwo, ipOne, SUFFIX_SRC);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToSpeaker.build()).ingressPoint(portTwo).egressPoint(portOne).priority(PRIORITY_OFFSET).build());
    // ICMP path from BGP peer to BGP speaker
    selector = buildSelector(icmpProtocol, vlanTwo, ipTwo, ipOne, null, null);
    key = buildKey(ipTwo, ipOne, SUFFIX_ICMP);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToSpeaker.build()).ingressPoint(portTwo).egressPoint(portOne).priority(PRIORITY_OFFSET).build());
    return intents;
}
#method_after
private Collection<PointToPointIntent> buildIntents(ConnectPoint portOne, VlanId vlanOne, IpAddress ipOne, ConnectPoint portTwo, VlanId vlanTwo, IpAddress ipTwo) {
    List<PointToPointIntent> intents = new ArrayList<>();
    TrafficTreatment.Builder treatmentToPeer = DefaultTrafficTreatment.builder();
    TrafficTreatment.Builder treatmentToSpeaker = DefaultTrafficTreatment.builder();
    TrafficSelector selector;
    Key key;
    byte tcpProtocol;
    byte icmpProtocol;
    if (ipOne.isIp4()) {
        tcpProtocol = IPv4.PROTOCOL_TCP;
        icmpProtocol = IPv4.PROTOCOL_ICMP;
    } else {
        tcpProtocol = IPv6.PROTOCOL_TCP;
        icmpProtocol = IPv6.PROTOCOL_ICMP6;
    }
    // Add VLAN treatment for traffic going from BGP speaker to BGP peer
    if (!vlanOne.equals(vlanTwo)) {
        if (vlanTwo.equals(VlanId.NONE)) {
            treatmentToPeer.popVlan();
        } else {
            treatmentToPeer.setVlanId(vlanTwo);
        }
    }
    // Path from BGP speaker to BGP peer matching destination TCP port 179
    selector = buildSelector(tcpProtocol, vlanOne, ipOne, ipTwo, null, BGP_PORT);
    key = buildKey(ipOne, ipTwo, SUFFIX_DST);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToPeer.build()).ingressPoint(portOne).egressPoint(portTwo).priority(PRIORITY_OFFSET).build());
    // Path from BGP speaker to BGP peer matching source TCP port 179
    selector = buildSelector(tcpProtocol, vlanOne, ipOne, ipTwo, BGP_PORT, null);
    key = buildKey(ipOne, ipTwo, SUFFIX_SRC);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToPeer.build()).ingressPoint(portOne).egressPoint(portTwo).priority(PRIORITY_OFFSET).build());
    // ICMP path from BGP speaker to BGP peer
    selector = buildSelector(icmpProtocol, vlanOne, ipOne, ipTwo, null, null);
    key = buildKey(ipOne, ipTwo, SUFFIX_ICMP);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToPeer.build()).ingressPoint(portOne).egressPoint(portTwo).priority(PRIORITY_OFFSET).build());
    // Add VLAN treatment for traffic going from BGP peer to BGP speaker
    if (!vlanTwo.equals(vlanOne)) {
        if (vlanOne.equals(VlanId.NONE)) {
            treatmentToSpeaker.popVlan();
        } else {
            treatmentToSpeaker.setVlanId(vlanOne);
        }
    }
    // Path from BGP peer to BGP speaker matching destination TCP port 179
    selector = buildSelector(tcpProtocol, vlanTwo, ipTwo, ipOne, null, BGP_PORT);
    key = buildKey(ipTwo, ipOne, SUFFIX_DST);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToSpeaker.build()).ingressPoint(portTwo).egressPoint(portOne).priority(PRIORITY_OFFSET).build());
    // Path from BGP peer to BGP speaker matching source TCP port 179
    selector = buildSelector(tcpProtocol, vlanTwo, ipTwo, ipOne, BGP_PORT, null);
    key = buildKey(ipTwo, ipOne, SUFFIX_SRC);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToSpeaker.build()).ingressPoint(portTwo).egressPoint(portOne).priority(PRIORITY_OFFSET).build());
    // ICMP path from BGP peer to BGP speaker
    selector = buildSelector(icmpProtocol, vlanTwo, ipTwo, ipOne, null, null);
    key = buildKey(ipTwo, ipOne, SUFFIX_ICMP);
    intents.add(PointToPointIntent.builder().appId(appId).key(key).selector(selector).treatment(treatmentToSpeaker.build()).ingressPoint(portTwo).egressPoint(portOne).priority(PRIORITY_OFFSET).build());
    return intents;
}
#end_block

#method_before
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    ConnectPoint egressPort = egressInterface.connectPoint();
    Set<Interface> ingressInterfaces = new HashSet<>();
    Set<ConnectPoint> ingressPorts = new HashSet<>();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    // Get ingress interfaces and ports
    // TODO get only interfaces that have IPs in the same subnet of the prefix
    interfaceService.getInterfaces().stream().filter(intf -> !intf.equals(egressInterface)).forEach(intf -> {
        ingressInterfaces.add(intf);
        ConnectPoint ingressPort = intf.connectPoint();
        ingressPorts.add(ingressPort);
    });
    // By default the ingress traffic is not tagged
    VlanId ingressVlanId = VlanId.NONE;
    // TODO need to be able to set a different VLAN Id per ingress interface
    for (Interface intf : ingressInterfaces) {
        if (!intf.vlan().equals(VlanId.NONE)) {
            selector.matchVlanId(VlanId.ANY);
            ingressVlanId = VlanId.ANY;
        }
    }
    // Match the destination IP prefix at the first hop
    if (prefix.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPDst(prefix);
        }
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPv6Dst(prefix);
        }
    }
    // Rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    // TODO need to make the comparison with different ingress VLAN Ids
    if (!egressInterface.vlan().equals(VlanId.NONE) && !(ingressVlanId.equals(VlanId.NONE)) && !(ingressVlanId.equals(egressInterface.vlan()))) {
        treatment.setVlanId(egressInterface.vlan());
    }
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    Key key = Key.of(prefix.toString(), appId);
    return MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(ingressPorts).egressPoint(egressPort).priority(priority).constraints(CONSTRAINTS).build();
}
#method_after
private MultiPointToSinglePointIntent generateRouteIntent(IpPrefix prefix, IpAddress nextHopIpAddress, MacAddress nextHopMacAddress) {
    // Find the attachment point (egress interface) of the next hop
    Interface egressInterface = interfaceService.getMatchingInterface(nextHopIpAddress);
    if (egressInterface == null) {
        log.warn("No outgoing interface found for {}", nextHopIpAddress);
        return null;
    }
    ConnectPoint egressPort = egressInterface.connectPoint();
    Set<Interface> ingressInterfaces = new HashSet<>();
    Set<ConnectPoint> ingressPorts = new HashSet<>();
    log.debug("Generating intent for prefix {}, next hop mac {}", prefix, nextHopMacAddress);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    // Get ingress interfaces and ports
    // TODO this should be only peering interfaces
    interfaceService.getInterfaces().stream().filter(intf -> !intf.equals(egressInterface)).forEach(intf -> {
        ingressInterfaces.add(intf);
        ConnectPoint ingressPort = intf.connectPoint();
        ingressPorts.add(ingressPort);
    });
    // By default the ingress traffic is not tagged
    VlanId ingressVlanId = VlanId.NONE;
    // TODO need to be able to set a different VLAN Id per ingress interface
    for (Interface intf : ingressInterfaces) {
        if (!intf.vlan().equals(VlanId.NONE)) {
            selector.matchVlanId(VlanId.ANY);
            ingressVlanId = intf.vlan();
        }
    }
    // Match the destination IP prefix at the first hop
    if (prefix.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPDst(prefix);
        }
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
        // IP address
        if (prefix.prefixLength() != 0) {
            selector.matchIPv6Dst(prefix);
        }
    }
    // Rewrite the destination MAC address
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(nextHopMacAddress);
    // TODO need to make the comparison with different ingress VLAN Ids
    if (!ingressVlanId.equals(egressInterface.vlan())) {
        if (egressInterface.vlan().equals(VlanId.NONE)) {
            treatment.popVlan();
        } else {
            treatment.setVlanId(egressInterface.vlan());
        }
    }
    // Set priority
    int priority = prefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    // Set key
    Key key = Key.of(prefix.toString(), appId);
    return MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(ingressPorts).egressPoint(egressPort).priority(priority).constraints(CONSTRAINTS).build();
}
#end_block

#method_before
private Optional<LinkDiscovery> updateDevice(Device device) {
    if (device == null) {
        return Optional.empty();
    }
    LinkDiscovery ld = discoverers.computeIfAbsent(device.id(), did -> new LinkDiscovery(device, LinkProvider.defaultMac(), context));
    if (ld.isStopped()) {
        ld.start();
    }
    return Optional.of(ld);
}
#method_after
private Optional<LinkDiscovery> updateDevice(Device device) {
    if (device == null) {
        return Optional.empty();
    }
    LinkDiscovery ld = discoverers.computeIfAbsent(device.id(), did -> new LinkDiscovery(device, context));
    if (ld.isStopped()) {
        ld.start();
    }
    return Optional.of(ld);
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (event.configClass().equals(BasicLinkConfig.class)) {
        log.info("net config event of type {} for basic link {}", event.type(), event.subject());
        LinkKey linkKey = (LinkKey) event.subject();
        if (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED) {
            addLink(linkKey);
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_REMOVED) {
            removeLink(linkKey);
        }
    }
    log.info("Reconfigured");
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (event.configClass().equals(BasicLinkConfig.class)) {
        log.info("net config event of type {} for basic link {}", event.type(), event.subject());
        LinkKey linkKey = (LinkKey) event.subject();
        if (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED) {
            addLink(linkKey);
        } else if (event.type() == NetworkConfigEvent.Type.CONFIG_REMOVED) {
            removeLink(linkKey);
        }
        log.info("Link reconfigured");
    }
}
#end_block

#method_before
private final void buildSrcMac(ClusterMetadata cm) {
    if (cm == null) {
        log.warn("Couldn't generate fingerprint. Using default value {}", LinkProvider.defaultMac());
        srcMac = LinkProvider.defaultMac();
        return;
    }
    int unqf = cm.hashCode();
    StringBuilder sb = new StringBuilder();
    sb.append("02:eb");
    for (int i = 0; i < 4; i++) {
        byte b = (byte) (unqf >> i * 8);
        sb.append(String.format(":%02X", b));
    }
    srcMac = sb.toString();
}
#method_after
private final String buildSrcMac() {
    String srcMac = ProbedLinkProvider.fingerprintMac(clusterMetadataService.getClusterMetadata());
    String defMac = ProbedLinkProvider.defaultMac();
    if (srcMac.equals(defMac)) {
        log.warn("Couldn't generate fingerprint. Using default value {}", defMac);
        return defMac;
    }
    log.trace("Generated MAC address {}", srcMac);
    return srcMac;
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    buildSrcMac(clusterMetadataService.getClusterMetadata());
    clusterMetadataService.addListener(clusterListener);
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    cfgRegistry.addListener(cfgListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
    SuppressionConfig cfg = Tools.retryable(() -> cfgRegistry.getConfig(appId, SuppressionConfig.class), ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY).get();
    if (cfg == null) {
        // If no configuration is found, register default.
        cfg = Tools.retryable(this::setDefaultSuppressionConfig, ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY).get();
    }
    cfgListener.reconfigureSuppressionRules(cfg);
    modified(context);
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    appId = coreService.registerApplication(PROVIDER_NAME);
    cfgRegistry.addListener(cfgListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
    SuppressionConfig cfg = Tools.retryable(() -> cfgRegistry.getConfig(appId, SuppressionConfig.class), ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY).get();
    if (cfg == null) {
        // If no configuration is found, register default.
        cfg = Tools.retryable(this::setDefaultSuppressionConfig, ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY).get();
    }
    cfgListener.reconfigureSuppressionRules(cfg);
    modified(context);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgRegistry.removeListener(cfgListener);
    factories.forEach(cfgRegistry::unregisterConfigFactory);
    cfgService.unregisterProperties(getClass(), false);
    disable();
    clusterMetadataService.removeListener(clusterListener);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgRegistry.removeListener(cfgListener);
    factories.forEach(cfgRegistry::unregisterConfigFactory);
    cfgService.unregisterProperties(getClass(), false);
    disable();
    log.info("Stopped");
}
#end_block

#method_before
private Optional<LinkDiscovery> updateDevice(Device device) {
    if (device == null) {
        return Optional.empty();
    }
    if (rules.isSuppressed(device) || isBlacklisted(device.id())) {
        log.trace("LinkDiscovery from {} disabled by configuration", device.id());
        removeDevice(device.id());
        return Optional.empty();
    }
    LinkDiscovery ld = discoverers.computeIfAbsent(device.id(), did -> new LinkDiscovery(device, srcMac, context));
    if (ld.isStopped()) {
        ld.start();
    }
    return Optional.of(ld);
}
#method_after
private Optional<LinkDiscovery> updateDevice(Device device) {
    if (device == null) {
        return Optional.empty();
    }
    if (rules.isSuppressed(device) || isBlacklisted(device.id())) {
        log.trace("LinkDiscovery from {} disabled by configuration", device.id());
        removeDevice(device.id());
        return Optional.empty();
    }
    LinkDiscovery ld = discoverers.computeIfAbsent(device.id(), did -> new LinkDiscovery(device, context));
    if (ld.isStopped()) {
        ld.start();
    }
    return Optional.of(ld);
}
#end_block

#method_before
private boolean notMy(String mac) {
    // if we are using DEFAULT_MAC, clustering hadn't initialized, so conservative 'yes'
    if (LinkProvider.defaultMac().equals(probeMac)) {
        return true;
    }
    return !mac.equalsIgnoreCase(probeMac);
}
#method_after
private boolean notMy(String mac) {
    // if we are using DEFAULT_MAC, clustering hadn't initialized, so conservative 'yes'
    String ourMac = context.fingerprint();
    if (ProbedLinkProvider.defaultMac().equalsIgnoreCase(ourMac)) {
        return true;
    }
    return !mac.equalsIgnoreCase(ourMac);
}
#end_block

#method_before
@Override
public void run(Timeout t) {
    if (isStopped()) {
        return;
    }
    if (context.mastershipService().isLocalMaster(device.id())) {
        log.warn("Sending probes from {}", device.id());
        ports.forEach(this::sendProbes);
    }
    if (!isStopped()) {
        timeout = Timer.getTimer().newTimeout(this, context.probeRate(), MILLISECONDS);
    }
}
#method_after
@Override
public void run(Timeout t) {
    if (isStopped()) {
        return;
    }
    if (context.mastershipService().isLocalMaster(device.id())) {
        log.trace("Sending probes from {}", device.id());
        ports.forEach(this::sendProbes);
    }
    if (!isStopped()) {
        timeout = Timer.getTimer().newTimeout(this, context.probeRate(), MILLISECONDS);
    }
}
#end_block

#method_before
private OutboundPacket createOutBoundLldp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(port);
    ethPacket.setSourceMACAddress(probeMac).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(ethPacket.serialize()));
}
#method_after
private OutboundPacket createOutBoundLldp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(port);
    ethPacket.setSourceMACAddress(context.fingerprint()).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(ethPacket.serialize()));
}
#end_block

#method_before
private OutboundPacket createOutBoundBddp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(port);
    bddpEth.setSourceMACAddress(probeMac).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(bddpEth.serialize()));
}
#method_after
private OutboundPacket createOutBoundBddp(Long port) {
    if (port == null) {
        return null;
    }
    ONOSLLDP lldp = getLinkProbe(port);
    bddpEth.setSourceMACAddress(context.fingerprint()).setPayload(lldp);
    return new DefaultOutboundPacket(device.id(), builder().setOutput(portNumber(port)).build(), ByteBuffer.wrap(bddpEth.serialize()));
}
#end_block

#method_before
@Override
public Builder of(Tunnel tunnel) {
    this.id = TunnelId.valueOf(tunnel.tunnelId().id());
    this.source = tunnel.src().toString();
    this.destination = tunnel.dst().toString();
    // TODO: Need to remove below hard-coded value and uncomment the line
    // TODO: once LSP_SIG_TYPE is added to AnnotationKeys.
    // = LspType.valueOf(tunnel.annotations()
    this.lspType = LspType.SR_WITHOUT_SIGNALLING;
    // .value(AnnotationKeys.LSP_SIG_TYPE));
    this.name = tunnel.tunnelName().toString();
    // TODO: uncomment below lines once CostConstraint and LocalBandwidthConstraint classes are ready
    // TODO: Need to remove below hard-coded value and uncomment the line.
    this.costConstraint = BandwidthConstraint.of(200, DataRateUnit.valueOf("BPS"));
    // = CostConstraint.of(tunnel.path().cost());
    // TODO: Need to remove below hard-coded value and uncomment the line.
    this.bandwidthConstraint = BandwidthConstraint.of(200, DataRateUnit.valueOf("BPS"));
    // .value(AnnotationKeys.BANDWIDTH));
    return this;
}
#method_after
@Override
public Builder of(Tunnel tunnel) {
    this.id = TunnelId.valueOf(tunnel.tunnelId().id());
    this.source = tunnel.src().toString();
    this.destination = tunnel.dst().toString();
    // TODO: need to uncomment below line once LSP_SIG_TYPE is added to AnnotationKeys.
    // = LspType.valueOf(tunnel.annotations()
    this.lspType = null;
    // .value(AnnotationKeys.LSP_SIG_TYPE));
    this.name = tunnel.tunnelName().toString();
    // TODO: uncomment below lines once CostConstraint and LocalBandwidthConstraint classes are ready
    // = CostConstraint.of(tunnel.path().cost());
    this.costConstraint = null;
    // = LocalBandwidthConstraint.of(tunnel.annotations()
    this.bandwidthConstraint = null;
    // .value(AnnotationKeys.BANDWIDTH));
    return this;
}
#end_block

#method_before
@Test
public void testGetTunnelId() {
    expect(pceService.queryPath(anyObject())).andReturn(tunnel).anyTimes();
    replay(pceService);
    WebTarget wt = target();
    String response = wt.path("path/1").request().get(String.class);
    JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
}
#method_after
@Test
public void testGetTunnelId() {
// TODO: uncomment below lines once TODO in DefaultPcePath class are removed
// expect(pceService.queryPath(anyObject()))
// .andReturn(tunnel)
// .anyTimes();
// replay(pceService);
// WebTarget wt = target();
// String response = wt.path("path/1").request().get(String.class);
// JsonObject result = Json.parse(response).asObject();
// assertThat(result, notNullValue());
}
#end_block

#method_before
private Key encodeKey(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    String key = String.format(KEY_FORMAT, networkId.toString(), src.toString(), dst.toString());
    return Key.of(key, appId);
}
#method_after
private Key encodeKey(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    String key = String.format(KEY_FORMAT, networkId, src, dst);
    return Key.of(key, appId);
}
#end_block

#method_before
@Override
public void event(IntentEvent event) {
    PointToPointIntent intent = (PointToPointIntent) event.subject();
    Key intentKey = intent.key();
    // Ignore intent events that are not for this appId.
    if (!intent.appId().equals(appId)) {
        return;
    }
    NetworkId networkId = decodeNetworkIdFromKey(intentKey);
    ConnectPoint src = intent.ingressPoint();
    ConnectPoint dst = intent.egressPoint();
    switch(event.type()) {
        case INSTALLED:
            providerService.tunnelUp(networkId, src, dst, TunnelId.valueOf(intentKey.toString()));
            break;
        case WITHDRAWN:
            intentService.purge(intent);
        // for both WITHDRAWN and FAILED intent event types.
        case FAILED:
            providerService.tunnelDown(networkId, src, dst, TunnelId.valueOf(intentKey.toString()));
            break;
        case INSTALL_REQ:
        case CORRUPT:
        case PURGED:
            // Not sure what do with these events, ignore for now.
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(IntentEvent event) {
    PointToPointIntent intent = (PointToPointIntent) event.subject();
    Key intentKey = intent.key();
    // Ignore intent events that are not relevant.
    if (!isRelevant(event)) {
        return;
    }
    NetworkId networkId = decodeNetworkIdFromKey(intentKey);
    ConnectPoint src = intent.ingressPoint();
    ConnectPoint dst = intent.egressPoint();
    switch(event.type()) {
        case INSTALLED:
            providerService.tunnelUp(networkId, src, dst, TunnelId.valueOf(intentKey.toString()));
            break;
        case WITHDRAWN:
            intentService.purge(intent);
        // for both WITHDRAWN and FAILED intent event types.
        case FAILED:
            providerService.tunnelDown(networkId, src, dst, TunnelId.valueOf(intentKey.toString()));
            break;
        case INSTALL_REQ:
        case CORRUPT:
        case PURGED:
            // Not sure what do with these events, ignore for now.
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void removeNetwork(NetworkId networkId) {
    // Make sure that the virtual network exists before attempting to remove it.
    if (networkExists(networkId)) {
        // TODO update both maps in one transaction.
        VirtualNetwork virtualNetwork = networkIdVirtualNetworkMap.remove(networkId);
        if (virtualNetwork == null) {
            return;
        }
        TenantId tenantId = virtualNetwork.tenantId();
        Set<NetworkId> networkIdSet = new HashSet<>();
        tenantIdNetworkIdSetMap.get(tenantId).forEach(networkId1 -> {
            if (networkId1.id().equals(networkId.id())) {
                networkIdSet.add(networkId1);
            }
        });
        tenantIdNetworkIdSetMap.compute(virtualNetwork.tenantId(), (id, existingNetworkIds) -> {
            if (existingNetworkIds == null || existingNetworkIds.isEmpty()) {
                return new HashSet<NetworkId>();
            } else {
                return new HashSet<NetworkId>(Sets.difference(existingNetworkIds, networkIdSet));
            }
        });
    }
}
#method_after
@Override
public void removeNetwork(NetworkId networkId) {
    // Make sure that the virtual network exists before attempting to remove it.
    if (networkExists(networkId)) {
        // TODO update both maps in one transaction.
        VirtualNetwork virtualNetwork = networkIdVirtualNetworkMap.remove(networkId);
        if (virtualNetwork == null) {
            return;
        }
        TenantId tenantId = virtualNetwork.tenantId();
        Set<NetworkId> networkIdSet = new HashSet<>();
        tenantIdNetworkIdSetMap.get(tenantId).forEach(networkId1 -> {
            if (networkId1.id().equals(networkId.id())) {
                networkIdSet.add(networkId1);
            }
        });
        tenantIdNetworkIdSetMap.compute(virtualNetwork.tenantId(), (id, existingNetworkIds) -> {
            if (existingNetworkIds == null || existingNetworkIds.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingNetworkIds, networkIdSet));
            }
        });
    }
}
#end_block

#method_before
@Override
public void removeDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    // TODO update both maps in one transaction.
    Set<DeviceId> deviceIdSet = new HashSet<>();
    networkIdDeviceIdSetMap.get(networkId).forEach(deviceId1 -> {
        if (deviceId1.equals(deviceId)) {
            deviceIdSet.add(deviceId1);
        }
    });
    if (deviceIdSet != null) {
        networkIdDeviceIdSetMap.compute(networkId, (id, existingDeviceIds) -> {
            if (existingDeviceIds == null || existingDeviceIds.isEmpty()) {
                return new HashSet<DeviceId>();
            } else {
                return new HashSet<DeviceId>(Sets.difference(existingDeviceIds, deviceIdSet));
            }
        });
        deviceIdVirtualDeviceMap.remove(deviceId);
    }
}
#method_after
@Override
public void removeDevice(NetworkId networkId, DeviceId deviceId) {
    checkState(networkExists(networkId), "The network has not been added.");
    // TODO update both maps in one transaction.
    Set<DeviceId> deviceIdSet = new HashSet<>();
    networkIdDeviceIdSetMap.get(networkId).forEach(deviceId1 -> {
        if (deviceId1.equals(deviceId)) {
            deviceIdSet.add(deviceId1);
        }
    });
    if (deviceIdSet != null) {
        networkIdDeviceIdSetMap.compute(networkId, (id, existingDeviceIds) -> {
            if (existingDeviceIds == null || existingDeviceIds.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingDeviceIds, deviceIdSet));
            }
        });
        deviceIdVirtualDeviceMap.remove(deviceId);
    }
}
#end_block

#method_before
@Override
public VirtualLink removeLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    checkState(networkExists(networkId), "The network has not been added.");
    final VirtualLink virtualLink = getLink(networkId, src, dst);
    if (virtualLink == null) {
        return null;
    }
    Set<VirtualLink> virtualLinkSet = new HashSet<>();
    virtualLinkSet.add(virtualLink);
    if (virtualLinkSet != null) {
        networkIdVirtualLinkSetMap.compute(networkId, (id, existingVirtualLinks) -> {
            if (existingVirtualLinks == null || existingVirtualLinks.isEmpty()) {
                return new HashSet<VirtualLink>();
            } else {
                return new HashSet<VirtualLink>(Sets.difference(existingVirtualLinks, virtualLinkSet));
            }
        });
    }
    return virtualLink;
}
#method_after
@Override
public VirtualLink removeLink(NetworkId networkId, ConnectPoint src, ConnectPoint dst) {
    checkState(networkExists(networkId), "The network has not been added.");
    final VirtualLink virtualLink = getLink(networkId, src, dst);
    if (virtualLink == null) {
        return null;
    }
    Set<VirtualLink> virtualLinkSet = new HashSet<>();
    virtualLinkSet.add(virtualLink);
    if (virtualLinkSet != null) {
        networkIdVirtualLinkSetMap.compute(networkId, (id, existingVirtualLinks) -> {
            if (existingVirtualLinks == null || existingVirtualLinks.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingVirtualLinks, virtualLinkSet));
            }
        });
    }
    return virtualLink;
}
#end_block

#method_before
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = new HashSet<>();
    networkIdVirtualPortSetMap.get(networkId).forEach(port -> {
        if (port.element().id().equals(deviceId) && port.number().equals(portNumber)) {
            virtualPortSet.add(port);
        }
    });
    if (virtualPortSet != null) {
        networkIdVirtualPortSetMap.compute(networkId, (id, existingVirtualPorts) -> {
            if (existingVirtualPorts == null || existingVirtualPorts.isEmpty()) {
                return new HashSet<VirtualPort>();
            } else {
                return new HashSet<VirtualPort>(Sets.difference(existingVirtualPorts, virtualPortSet));
            }
        });
    }
}
#method_after
@Override
public void removePort(NetworkId networkId, DeviceId deviceId, PortNumber portNumber) {
    checkState(networkExists(networkId), "The network has not been added.");
    Set<VirtualPort> virtualPortSet = new HashSet<>();
    networkIdVirtualPortSetMap.get(networkId).forEach(port -> {
        if (port.element().id().equals(deviceId) && port.number().equals(portNumber)) {
            virtualPortSet.add(port);
        }
    });
    if (virtualPortSet != null) {
        networkIdVirtualPortSetMap.compute(networkId, (id, existingVirtualPorts) -> {
            if (existingVirtualPorts == null || existingVirtualPorts.isEmpty()) {
                return new HashSet<>();
            } else {
                return new HashSet<>(Sets.difference(existingVirtualPorts, virtualPortSet));
            }
        });
    }
}
#end_block

#method_before
public static void processRangeRestrictionExit(TreeWalkListener listener, GeneratedYangParser.RangeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, RANGE_DATA, ctx.range().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangRangeRestriction) {
        listener.getParsedDataStack().pop();
    } else if (listener.getParsedDataStack().peek() instanceof YangType && ((YangType) listener.getParsedDataStack().peek()).getDataType() == DERIVED) {
    // TODO : need to handle in linker
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, RANGE_DATA, ctx.range().getText(), EXIT));
    }
}
#method_after
public static void processRangeRestrictionExit(TreeWalkListener listener, GeneratedYangParser.RangeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, RANGE_DATA, ctx.range().getText(), EXIT);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangRangeRestriction) {
        listener.getParsedDataStack().pop();
    } else if (tmpData instanceof YangType && ((YangType) tmpData).getDataType() == DERIVED) {
    // TODO : need to handle in linker
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, RANGE_DATA, ctx.range().getText(), EXIT));
    }
}
#end_block

#method_before
public static void processLengthRestrictionExit(TreeWalkListener listener, GeneratedYangParser.LengthStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LENGTH_DATA, ctx.length().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangRangeRestriction) {
        listener.getParsedDataStack().pop();
    } else if (listener.getParsedDataStack().peek() instanceof YangType && ((YangType) listener.getParsedDataStack().peek()).getDataType() == DERIVED) {
    // TODO : need to handle in linker
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, LENGTH_DATA, ctx.length().getText(), EXIT));
    }
}
#method_after
public static void processLengthRestrictionExit(TreeWalkListener listener, GeneratedYangParser.LengthStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LENGTH_DATA, ctx.length().getText(), EXIT);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangRangeRestriction) {
        listener.getParsedDataStack().pop();
    } else if (tmpData instanceof YangType && ((YangType) tmpData).getDataType() == DERIVED) {
    // TODO : need to handle in linker
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, LENGTH_DATA, ctx.length().getText(), EXIT));
    }
}
#end_block

#method_before
public static void processPatternRestrictionExit(TreeWalkListener listener, GeneratedYangParser.PatternStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, PATTERN_DATA, ctx.string().getText(), EXIT);
    if (listener.getParsedDataStack().peek() instanceof YangStringRestriction) {
        listener.getParsedDataStack().pop();
    } else if (listener.getParsedDataStack().peek() instanceof YangType && ((YangType) listener.getParsedDataStack().peek()).getDataType() == DERIVED) {
    // TODO : need to handle in linker
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, PATTERN_DATA, ctx.string().getText(), EXIT));
    }
}
#method_after
public static void processPatternRestrictionExit(TreeWalkListener listener, GeneratedYangParser.PatternStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, PATTERN_DATA, ctx.string().getText(), EXIT);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if (tmpData instanceof YangStringRestriction) {
        listener.getParsedDataStack().pop();
    } else if (tmpData instanceof YangType && ((YangType) tmpData).getDataType() == DERIVED) {
    // TODO : need to handle in linker
    } else {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, PATTERN_DATA, ctx.string().getText(), EXIT));
    }
}
#end_block

#method_before
public DeviceId src() {
    return src;
}
#method_after
public void src(DeviceId id) {
    this.src = id;
}
#end_block

#method_before
public DeviceId dst() {
    return dst;
}
#method_after
public void dst(DeviceId id) {
    this.dst = id;
}
#end_block

#method_before
public String name() {
    return name;
}
#method_after
public void name(String name) {
    this.name = name;
}
#end_block

#method_before
public List<Constraint> constraints() {
    return constraints;
}
#method_after
public void constraints(List<Constraint> constraints) {
    this.constraints = constraints;
}
#end_block

#method_before
public LspType lspType() {
    return lspType;
}
#method_after
public void lspType(LspType lspType) {
    this.lspType = lspType;
}
#end_block

#method_before
@Test
public void testEquals() {
    // create same two objects.
    DeviceId src1 = DeviceId.deviceId("foo1");
    DeviceId dst1 = DeviceId.deviceId("goo1");
    String name1 = "pcc1";
    LspType lspType1 = LspType.WITH_SIGNALLING;
    List<Constraint> constraints1 = new LinkedList<>();
    Constraint bandwidth1 = BandwidthConstraint.of(200, DataRateUnit.BPS);
    constraints1.add(bandwidth1);
    PcePathInfo pathInfo1 = PcePathInfo.builder().src(src1).dst(dst1).name(name1).constraints(constraints1).lspType(lspType1).build();
    // create same object as above object
    PcePathInfo samePathInfo1 = PcePathInfo.builder().src(src1).dst(dst1).name(name1).constraints(constraints1).lspType(lspType1).build();
    // Create different object.
    DeviceId src2 = DeviceId.deviceId("foo2");
    DeviceId dst2 = DeviceId.deviceId("goo2");
    String name2 = "pcc2";
    LspType lspType2 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints2 = new LinkedList<>();
    Constraint bandwidth2 = BandwidthConstraint.of(400, DataRateUnit.BPS);
    constraints2.add(bandwidth2);
    PcePathInfo pathInfo2 = PcePathInfo.builder().src(src2).dst(dst2).name(name2).constraints(constraints2).lspType(lspType2).build();
    new EqualsTester().addEqualityGroup(pathInfo1, samePathInfo1).addEqualityGroup(pathInfo2).testEquals();
}
#method_after
@Test
public void testEquals() {
    // create same two objects.
    DeviceId src1 = DeviceId.deviceId("foo1");
    DeviceId dst1 = DeviceId.deviceId("goo1");
    String name1 = "pcc1";
    LspType lspType1 = LspType.WITH_SIGNALLING;
    List<Constraint> constraints1 = new LinkedList<>();
    Constraint bandwidth11 = BandwidthConstraint.of(100, DataRateUnit.BPS);
    constraints1.add(bandwidth11);
    Constraint bandwidth12 = BandwidthConstraint.of(200, DataRateUnit.BPS);
    constraints1.add(bandwidth12);
    Constraint bandwidth13 = BandwidthConstraint.of(300, DataRateUnit.BPS);
    constraints1.add(bandwidth13);
    PcePathInfo pathInfo1 = new PcePathInfo(src1, dst1, name1, constraints1, lspType1);
    // create same object as above object
    PcePathInfo samePathInfo1 = new PcePathInfo(src1, dst1, name1, constraints1, lspType1);
    // Create different object.
    DeviceId src2 = DeviceId.deviceId("foo2");
    DeviceId dst2 = DeviceId.deviceId("goo2");
    String name2 = "pcc2";
    LspType lspType2 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints2 = new LinkedList<>();
    Constraint bandwidth21 = BandwidthConstraint.of(400, DataRateUnit.BPS);
    constraints2.add(bandwidth21);
    Constraint bandwidth22 = BandwidthConstraint.of(800, DataRateUnit.BPS);
    constraints2.add(bandwidth22);
    PcePathInfo pathInfo2 = new PcePathInfo(src2, dst2, name2, constraints2, lspType2);
    new EqualsTester().addEqualityGroup(pathInfo1, samePathInfo1).addEqualityGroup(pathInfo2).testEquals();
}
#end_block

#method_before
@Test
public void testConstruction() {
    DeviceId src = DeviceId.deviceId("foo2");
    DeviceId dst = DeviceId.deviceId("goo2");
    String name = "pcc2";
    LspType lspType = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints = new LinkedList<>();
    Constraint bandwidth = BandwidthConstraint.of(400, DataRateUnit.BPS);
    constraints.add(bandwidth);
    PcePathInfo pathInfo = PcePathInfo.builder().src(src).dst(dst).name(name).constraints(constraints).lspType(lspType).build();
    assertThat(src, is(pathInfo.src()));
    assertThat(dst, is(pathInfo.dst()));
    assertThat(name, is(pathInfo.name()));
    assertThat(constraints, is(pathInfo.constraints()));
    assertThat(lspType, is(pathInfo.lspType()));
}
#method_after
@Test
public void testConstruction() {
    DeviceId src = DeviceId.deviceId("foo2");
    DeviceId dst = DeviceId.deviceId("goo2");
    String name = "pcc2";
    LspType lspType = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints = new LinkedList<>();
    Constraint bandwidth1 = BandwidthConstraint.of(100, DataRateUnit.BPS);
    constraints.add(bandwidth1);
    Constraint bandwidth2 = BandwidthConstraint.of(200, DataRateUnit.BPS);
    constraints.add(bandwidth2);
    Constraint bandwidth3 = BandwidthConstraint.of(300, DataRateUnit.BPS);
    constraints.add(bandwidth3);
    PcePathInfo pathInfo = new PcePathInfo(src, dst, name, constraints, lspType);
    assertThat(src, is(pathInfo.src()));
    assertThat(dst, is(pathInfo.dst()));
    assertThat(name, is(pathInfo.name()));
    assertThat(constraints, is(pathInfo.constraints()));
    assertThat(lspType, is(pathInfo.lspType()));
}
#end_block

#method_before
@Activate
protected void activate() {
    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName("onos-pce-globalnodelabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();
    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName("onos-pce-adjlabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();
    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName("onos-pce-tunnelinfomap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, // TunnelConsumerId.class,
    LabelResourceId.class).build())).build();
    pathInfoSet = storageService.<PcePathInfo>setBuilder().withName("path-info").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(PcePathInfo.class).build())).build().asDistributedSet();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName("onos-pce-globalnodelabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();
    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName("onos-pce-adjlabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResource.class, LabelResourceId.class).build())).build();
    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName("onos-pce-tunnelinfomap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();
    failedPathSet = storageService.<PcePathInfo>setBuilder().withName("failed-path-info").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(PcePathInfo.class, // TODO: BandwidthConstraint.class. Will be added once it is confirmed.
    Constraint.class, LspType.class).build())).build().asDistributedSet();
    log.info("Started");
}
#end_block

#method_before
@Override
public void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(pceccTunnelInfo, DEVICE_LABEL_STORE_INFO_NULL);
    tunnelInfoMap.put(tunnelId, pceccTunnelInfo);
}
#method_after
@Override
public void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(pceccTunnelInfo, PCECC_TUNNEL_INFO_NULL);
    tunnelInfoMap.put(tunnelId, pceccTunnelInfo);
}
#end_block

#method_before
@Override
public boolean updateTunnelInfo(TunnelId tunnelId, List<LspLocalLabelInfo> lspLocalLabelInfoList) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(lspLocalLabelInfoList, DEVICE_LABEL_STORE_INFO_NULL);
    if (!tunnelInfoMap.containsKey((tunnelId))) {
        log.debug("Tunnel info does not exist whose tunnel id is {}.", tunnelId.toString());
        return false;
    }
    PceccTunnelInfo labelStoreInfo = tunnelInfoMap.get(tunnelId).value();
    labelStoreInfo.lspLocalLabelInfoList(lspLocalLabelInfoList);
    tunnelInfoMap.put(tunnelId, labelStoreInfo);
    if (!labelStoreInfo.equals(tunnelInfoMap.get(tunnelId).value())) {
        log.debug("Tunnel info updation is failed whose tunnel id is {} ", tunnelId.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean updateTunnelInfo(TunnelId tunnelId, List<LspLocalLabelInfo> lspLocalLabelInfoList) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(lspLocalLabelInfoList, LSP_LOCAL_LABEL_INFO_NULL);
    if (!tunnelInfoMap.containsKey((tunnelId))) {
        log.debug("Tunnel info does not exist whose tunnel id is {}.", tunnelId.toString());
        return false;
    }
    PceccTunnelInfo tunnelInfo = tunnelInfoMap.get(tunnelId).value();
    tunnelInfo.lspLocalLabelInfoList(lspLocalLabelInfoList);
    tunnelInfoMap.put(tunnelId, tunnelInfo);
    return true;
}
#end_block

#method_before
@Override
public boolean updateTunnelInfo(TunnelId tunnelId, List<LspLocalLabelInfo> lspLocalLabelInfoList) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(lspLocalLabelInfoList, DEVICE_LABEL_STORE_INFO_NULL);
    if (!tunnelInfoMap.containsKey((tunnelId))) {
        log.debug("Tunnel info does not exist whose tunnel id is {}.", tunnelId.toString());
        return false;
    }
    PceccTunnelInfo labelStoreInfo = tunnelInfoMap.get(tunnelId).value();
    labelStoreInfo.lspLocalLabelInfoList(lspLocalLabelInfoList);
    tunnelInfoMap.put(tunnelId, labelStoreInfo);
    if (!labelStoreInfo.equals(tunnelInfoMap.get(tunnelId).value())) {
        log.debug("Tunnel info updation is failed whose tunnel id is {} ", tunnelId.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean updateTunnelInfo(TunnelId tunnelId, ResourceConsumer tunnelConsumerId) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(tunnelConsumerId, TUNNEL_CONSUMER_ID_NULL);
    if (!tunnelInfoMap.containsKey((tunnelId))) {
        log.debug("Tunnel info does not exist whose tunnel id is {}.", tunnelId.toString());
        return false;
    }
    PceccTunnelInfo tunnelInfo = tunnelInfoMap.get(tunnelId).value();
    tunnelInfo.tunnelConsumerId(tunnelConsumerId);
    tunnelInfoMap.put(tunnelId, tunnelInfo);
    return true;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    distrPceStore = new DistributedPceStore();
    // Initialization of member variables
    link1 = DefaultLink.builder().providerId(new ProviderId("eth", "1")).annotations(DefaultAnnotations.builder().set("key1", "yahoo").build()).src(srcConnectionPoint1).dst(dstConnectionPoint2).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    link2 = DefaultLink.builder().providerId(new ProviderId("mac", "2")).annotations(DefaultAnnotations.builder().set("key2", "google").build()).src(srcConnectionPoint3).dst(dstConnectionPoint4).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    labelList1.add(labelResource1);
    labelList1.add(labelResource2);
    labelList2.add(labelResource3);
    labelList2.add(labelResource4);
    // Create pceccTunnelInfo1
    List<LspLocalLabelInfo> lspLocalLabelInfoList1 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId1;
    DeviceId deviceId1 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId1 = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId1 = LabelResourceId.labelResourceId(2);
    LspLocalLabelInfo lspLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).build();
    lspLocalLabelInfoList1.add(lspLocalLabel1);
    pceccTunnelInfo1 = new PceccTunnelInfo(lspLocalLabelInfoList1);
    // Create pceccTunnelInfo2
    List<LspLocalLabelInfo> lspLocalLabelInfoList2 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId2;
    DeviceId deviceId2 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId2 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId2 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel2 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId2).inLabelId(inLabelId2).outLabelId(outLabelId2).build();
    lspLocalLabelInfoList2.add(lspLocalLabel2);
    pceccTunnelInfo2 = new PceccTunnelInfo(lspLocalLabelInfoList2);
    // Creates pathInfo1
    DeviceId src1 = DeviceId.deviceId("foo1");
    DeviceId dst1 = DeviceId.deviceId("goo1");
    String name1 = "pcc1";
    LspType lspType1 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints1 = new LinkedList<>();
    Constraint bandwidth1 = BandwidthConstraint.of(200, DataRateUnit.BPS);
    constraints1.add(bandwidth1);
    pathInfo1 = PcePathInfo.builder().src(src1).dst(dst1).name(name1).constraints(constraints1).lspType(lspType1).build();
    // Creates pathInfo2
    DeviceId src2 = DeviceId.deviceId("foo2");
    DeviceId dst2 = DeviceId.deviceId("goo2");
    String name2 = "pcc2";
    LspType lspType2 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints2 = new LinkedList<>();
    Constraint bandwidth2 = BandwidthConstraint.of(400, DataRateUnit.BPS);
    constraints2.add(bandwidth2);
    pathInfo2 = PcePathInfo.builder().src(src2).dst(dst2).name(name2).constraints(constraints2).lspType(lspType2).build();
    // Creates pathInfo3
    DeviceId src3 = DeviceId.deviceId("foo3");
    DeviceId dst3 = DeviceId.deviceId("goo3");
    String name3 = "pcc3";
    LspType lspType3 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints3 = new LinkedList<>();
    Constraint bandwidth3 = BandwidthConstraint.of(500, DataRateUnit.BPS);
    constraints3.add(bandwidth3);
    pathInfo3 = PcePathInfo.builder().src(src3).dst(dst3).name(name3).constraints(constraints3).lspType(lspType3).build();
    // Creates pathInfo4
    DeviceId src4 = DeviceId.deviceId("foo4");
    DeviceId dst4 = DeviceId.deviceId("goo4");
    String name4 = "pcc4";
    LspType lspType4 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints4 = new LinkedList<>();
    Constraint bandwidth4 = BandwidthConstraint.of(600, DataRateUnit.BPS);
    constraints4.add(bandwidth4);
    pathInfo4 = PcePathInfo.builder().src(src4).dst(dst4).name(name4).constraints(constraints4).lspType(lspType4).build();
}
#method_after
@Before
public void setUp() throws Exception {
    distrPceStore = new DistributedPceStore();
    // Initialization of member variables
    link1 = DefaultLink.builder().providerId(new ProviderId("eth", "1")).annotations(DefaultAnnotations.builder().set("key1", "yahoo").build()).src(srcConnectionPoint1).dst(dstConnectionPoint2).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    link2 = DefaultLink.builder().providerId(new ProviderId("mac", "2")).annotations(DefaultAnnotations.builder().set("key2", "google").build()).src(srcConnectionPoint3).dst(dstConnectionPoint4).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    labelList1.add(labelResource1);
    labelList1.add(labelResource2);
    labelList2.add(labelResource3);
    labelList2.add(labelResource4);
    // Create pceccTunnelInfo1
    List<LspLocalLabelInfo> lspLocalLabelInfoList1 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId1 = TunnelConsumerId.valueOf(10);
    DeviceId deviceId1 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId1 = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId1 = LabelResourceId.labelResourceId(2);
    LspLocalLabelInfo lspLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).build();
    lspLocalLabelInfoList1.add(lspLocalLabel1);
    pceccTunnelInfo1 = new PceccTunnelInfo(lspLocalLabelInfoList1, tunnelConsumerId1);
    // Create pceccTunnelInfo2
    List<LspLocalLabelInfo> lspLocalLabelInfoList2 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId2 = TunnelConsumerId.valueOf(20);
    DeviceId deviceId2 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId2 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId2 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel2 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId2).inLabelId(inLabelId2).outLabelId(outLabelId2).build();
    lspLocalLabelInfoList2.add(lspLocalLabel2);
    pceccTunnelInfo2 = new PceccTunnelInfo(lspLocalLabelInfoList2, tunnelConsumerId2);
    // Creates failedPathInfo1
    DeviceId src1 = DeviceId.deviceId("foo1");
    DeviceId dst1 = DeviceId.deviceId("goo1");
    String name1 = "pcc1";
    LspType lspType1 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints1 = new LinkedList<>();
    Constraint bandwidth1 = BandwidthConstraint.of(200, DataRateUnit.BPS);
    constraints1.add(bandwidth1);
    failedPathInfo1 = new PcePathInfo(src1, dst1, name1, constraints1, lspType1);
    // Creates failedPathInfo2
    DeviceId src2 = DeviceId.deviceId("foo2");
    DeviceId dst2 = DeviceId.deviceId("goo2");
    String name2 = "pcc2";
    LspType lspType2 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints2 = new LinkedList<>();
    Constraint bandwidth2 = BandwidthConstraint.of(400, DataRateUnit.BPS);
    constraints2.add(bandwidth2);
    failedPathInfo2 = new PcePathInfo(src2, dst2, name2, constraints2, lspType2);
    // Creates failedPathInfo3
    DeviceId src3 = DeviceId.deviceId("foo3");
    DeviceId dst3 = DeviceId.deviceId("goo3");
    String name3 = "pcc3";
    LspType lspType3 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints3 = new LinkedList<>();
    Constraint bandwidth3 = BandwidthConstraint.of(500, DataRateUnit.BPS);
    constraints3.add(bandwidth3);
    failedPathInfo3 = new PcePathInfo(src3, dst3, name3, constraints3, lspType3);
    // Creates failedPathInfo4
    DeviceId src4 = DeviceId.deviceId("foo4");
    DeviceId dst4 = DeviceId.deviceId("goo4");
    String name4 = "pcc4";
    LspType lspType4 = LspType.SR_WITHOUT_SIGNALLING;
    List<Constraint> constraints4 = new LinkedList<>();
    Constraint bandwidth4 = BandwidthConstraint.of(600, DataRateUnit.BPS);
    constraints4.add(bandwidth4);
    failedPathInfo4 = new PcePathInfo(src4, dst4, name4, constraints4, lspType4);
}
#end_block

#method_before
@Test
public void testUpdateTunnelInfo() {
    // add tunnel info
    testAddTunnelInfo();
    // new updates
    // Create pceccTunnelInfo3
    List<LspLocalLabelInfo> lspLocalLabelInfoList3 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId3;
    DeviceId deviceId3 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId3 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId3 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel3 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId3).inLabelId(inLabelId3).outLabelId(outLabelId3).build();
    lspLocalLabelInfoList3.add(lspLocalLabel3);
    PceccTunnelInfo pceccTunnelInfo3 = new PceccTunnelInfo(lspLocalLabelInfoList3);
    // Create pceccTunnelInfo4
    List<LspLocalLabelInfo> lspLocalLabelInfoList4 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId4;
    DeviceId deviceId4 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId4 = LabelResourceId.labelResourceId(4);
    LabelResourceId outLabelId4 = LabelResourceId.labelResourceId(5);
    LspLocalLabelInfo lspLocalLabel4 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId4).inLabelId(inLabelId4).outLabelId(outLabelId4).build();
    lspLocalLabelInfoList4.add(lspLocalLabel4);
    PceccTunnelInfo pceccTunnelInfo4 = new PceccTunnelInfo(lspLocalLabelInfoList4);
    assertThat(distrPceStore.updateTunnelInfo(tunnelId1, lspLocalLabelInfoList3), is(true));
    assertThat(distrPceStore.updateTunnelInfo(tunnelId2, lspLocalLabelInfoList4), is(true));
}
#method_after
@Test
public void testUpdateTunnelInfo() {
    // add tunnel info
    testAddTunnelInfo();
    // new updates
    // Create pceccTunnelInfo3
    List<LspLocalLabelInfo> lspLocalLabelInfoList3 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId3 = TunnelConsumerId.valueOf(30);
    DeviceId deviceId3 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId3 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId3 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel3 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId3).inLabelId(inLabelId3).outLabelId(outLabelId3).build();
    lspLocalLabelInfoList3.add(lspLocalLabel3);
    PceccTunnelInfo pceccTunnelInfo3 = new PceccTunnelInfo(lspLocalLabelInfoList3, tunnelConsumerId3);
    // Create pceccTunnelInfo4
    List<LspLocalLabelInfo> lspLocalLabelInfoList4 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId4 = TunnelConsumerId.valueOf(40);
    DeviceId deviceId4 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId4 = LabelResourceId.labelResourceId(4);
    LabelResourceId outLabelId4 = LabelResourceId.labelResourceId(5);
    LspLocalLabelInfo lspLocalLabel4 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId4).inLabelId(inLabelId4).outLabelId(outLabelId4).build();
    lspLocalLabelInfoList4.add(lspLocalLabel4);
    PceccTunnelInfo pceccTunnelInfo4 = new PceccTunnelInfo(lspLocalLabelInfoList4, tunnelConsumerId4);
    // update only lspLocalLabelInfoList
    assertThat(distrPceStore.updateTunnelInfo(tunnelId1, lspLocalLabelInfoList3), is(true));
    assertThat(distrPceStore.updateTunnelInfo(tunnelId2, lspLocalLabelInfoList4), is(true));
    // update only tunnelConsumerId
    assertThat(distrPceStore.updateTunnelInfo(tunnelId1, tunnelConsumerId3), is(true));
    assertThat(distrPceStore.updateTunnelInfo(tunnelId2, tunnelConsumerId4), is(true));
    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo3));
    assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo4));
}
#end_block

#method_before
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion p;
    EthCriterion e = null;
    VlanIdCriterion v = null;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        p = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST || c.type() == Criterion.Type.ETH_DST_MASKED) {
            e = (EthCriterion) c;
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            v = (VlanIdCriterion) c;
        } else {
            log.error("Unsupported filter {}", c);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    if (e == null || e.mac().equals(MacAddress.NONE)) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        if (e.mask() != null) {
            // Mcast traffic based filtering objective for interface
            for (FlowRule tmacRule : processMcastEthDstFilter(e, p, v, applicationId)) {
                log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
                ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
            }
        } else {
            for (FlowRule rule : processEthDstFilter(e, p, v, applicationId)) {
                // adding Port/VLAN/MAC filtering rules in filter table
                log.debug("adding Port/VLAN/MAC filtering rules in filter table: {}/{}/{}", p.port(), v.vlanId(), e.mac());
                ops = install ? ops.add(rule) : ops.remove(rule);
            }
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied filtering rules");
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply filtering rules");
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion p;
    EthCriterion e = null;
    VlanIdCriterion v = null;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        p = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion c : filt.conditions()) {
        if (c.type() == Criterion.Type.ETH_DST || c.type() == Criterion.Type.ETH_DST_MASKED) {
            e = (EthCriterion) c;
        } else if (c.type() == Criterion.Type.VLAN_VID) {
            v = (VlanIdCriterion) c;
        } else {
            log.error("Unsupported filter {}", c);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    log.debug("adding Port/VLAN/MAC filtering rules in filter table: {}/{}/{}", p.port(), v.vlanId(), e.mac());
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchInPort(p.port());
    // Multicast MAC
    if (e.mask() != null) {
        selector.matchEthDstMasked(e.mac(), e.mask());
    } else {
        selector.matchEthDst(e.mac());
    }
    selector.matchVlanId(v.vlanId());
    selector.matchEthType(Ethernet.TYPE_IPV4);
    if (!v.vlanId().equals(VlanId.NONE)) {
        treatment.popVlan();
    }
    treatment.transition(FIB_TABLE);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(FILTER_TABLE).build();
    ops = ops.add(rule);
    ops = install ? ops.add(rule) : ops.remove(rule);
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied filtering rules");
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply filtering rules");
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
@Test
public void testGetFlowByAppId() {
    setupMockFlowRules();
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    expect(mockFlowService.getFlowRulesById(APP_ID)).andReturn(flowRules).anyTimes();
    replay(mockFlowService);
    final WebTarget wt = target();
    final String response = wt.path("flows/1/application").request().get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("flows"));
    final JsonArray jsonFlows = result.get("flows").asArray();
    assertThat(jsonFlows, notNullValue());
    assertThat(jsonFlows, hasFlowRule(flowRule1));
    assertThat(jsonFlows, hasFlowRule(flowRule2));
    assertThat(jsonFlows, hasFlowRule(flowRule3));
    assertThat(jsonFlows, hasFlowRule(flowRule4));
}
#method_after
@Test
public void testGetFlowByAppId() {
    setupMockFlowRules();
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    expect(mockFlowService.getFlowRulesById(APP_ID)).andReturn(flowRules).anyTimes();
    replay(mockFlowService);
    final WebTarget wt = target();
    final String response = wt.path("flows/application/1").request().get(String.class);
    final JsonObject result = Json.parse(response).asObject();
    assertThat(result, notNullValue());
    assertThat(result.names(), hasSize(1));
    assertThat(result.names().get(0), is("flows"));
    final JsonArray jsonFlows = result.get("flows").asArray();
    assertThat(jsonFlows, notNullValue());
    assertThat(jsonFlows, hasFlowRule(flowRule1));
    assertThat(jsonFlows, hasFlowRule(flowRule2));
    assertThat(jsonFlows, hasFlowRule(flowRule3));
    assertThat(jsonFlows, hasFlowRule(flowRule4));
}
#end_block

#method_before
@Test
public void testRemoveFlowByAppId() {
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    mockFlowService.removeFlowRulesById(APP_ID);
    expectLastCall();
    replay(mockFlowService);
    WebTarget wt = target();
    String location = "/flows/1/application";
    Response deleteResponse = wt.path(location).request().delete();
    assertThat(deleteResponse.getStatus(), is(HttpURLConnection.HTTP_NO_CONTENT));
}
#method_after
@Test
public void testRemoveFlowByAppId() {
    expect(mockApplicationService.getId(anyObject())).andReturn(APP_ID).anyTimes();
    replay(mockApplicationService);
    mockFlowService.removeFlowRulesById(APP_ID);
    expectLastCall();
    replay(mockFlowService);
    WebTarget wt = target();
    String location = "/flows/application/1";
    Response deleteResponse = wt.path(location).request().delete();
    assertThat(deleteResponse.getStatus(), is(HttpURLConnection.HTTP_NO_CONTENT));
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{appId}/application")
public Response getFlowByAppId(@PathParam("appId") String appId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    final Iterable<FlowRule> flowRules = service.getFlowRulesById(idInstant);
    flowRules.forEach(flow -> flowsNode.add(codec(FlowRule.class).encode(flow, this)));
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response getFlowByAppId(@PathParam("appId") String appId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    final Iterable<FlowRule> flowRules = service.getFlowRulesById(idInstant);
    flowRules.forEach(flow -> flowsNode.add(codec(FlowRule.class).encode(flow, this)));
    return ok(root).build();
}
#end_block

#method_before
@DELETE
@Produces(MediaType.APPLICATION_JSON)
@Path("{appId}/application")
public Response removeFlowByAppId(@PathParam("appId") String appId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    service.removeFlowRulesById(idInstant);
    return Response.noContent().build();
}
#method_after
@DELETE
@Produces(MediaType.APPLICATION_JSON)
@Path("application/{appId}")
public Response removeFlowByAppId(@PathParam("appId") String appId) {
    final ApplicationService appService = get(ApplicationService.class);
    final ApplicationId idInstant = nullIsNotFound(appService.getId(appId), APP_ID_NOT_FOUND);
    service.removeFlowRulesById(idInstant);
    return Response.noContent().build();
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    imports = getJavaImportData().getImports();
    createPackage(curNode);
    /**
     * Creates rpc interface file.
     */
    if (!validateForEmptyfiles(getRpcInterfaceImplTempFileHandle())) {
        setRpcInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(RPC_INTERFACE_FILE_NAME_SUFFIX)));
        generateRpcInterfaceFile(getRpcInterfaceJavaFileHandle(), curNode, imports);
    }
    /**
     * Close all the file handles.
     */
    close(false);
}
#method_after
@Override
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    imports = getJavaImportData().getImports();
    createPackage(curNode);
    /**
     * Creates rpc interface file.
     */
    setServiceInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(SERVICE_FILE_NAME_SUFFIX)));
    generateServiceInterfaceFile(getServiceInterfaceJavaFileHandle(), curNode, imports, isAttributePresent());
    if (isHasAugmentationExtended(getExtendsList())) {
        addAugmentedInfoImport(curNode, imports, true);
        addArrayListImport(curNode, imports, true);
    }
    /**
     * Create builder class file.
     */
    setManagerJavaFileHandle(getJavaFileHandle(getJavaClassName(MANAGER_FILE_NAME_SUFFIX)));
    generateManagerClassFile(getManagerJavaFileHandle(), imports, curNode, isAttributePresent());
    insertDataIntoJavaFile(getManagerJavaFileHandle(), getJavaClassDefClose());
    /**
     * Close all the file handles.
     */
    freeTemporaryResources(false);
}
#end_block

#method_before
private void addRpcString(JavaAttributeInfo javaAttributeInfoOfInput, JavaAttributeInfo javaAttributeInfoOfOutput, String rpcName) throws IOException {
    String rpcInput = "";
    String rpcOutput = "void";
    if (javaAttributeInfoOfInput != null) {
        rpcInput = javaAttributeInfoOfInput.getAttributeName();
    }
    if (javaAttributeInfoOfOutput != null) {
        rpcOutput = javaAttributeInfoOfOutput.getAttributeName();
    }
    appendToFile(getRpcInterfaceImplTempFileHandle(), generateJavaDocForRpc(rpcName, rpcInput, rpcOutput) + getRpcStringMethod(rpcName, rpcInput, rpcOutput) + NEW_LINE);
}
#method_after
private void addRpcString(JavaAttributeInfo javaAttributeInfoOfInput, JavaAttributeInfo javaAttributeInfoOfOutput, String rpcName) throws IOException {
    String rpcInput = EMPTY_STRING;
    String rpcOutput = VOID;
    if (javaAttributeInfoOfInput != null) {
        rpcInput = javaAttributeInfoOfInput.getAttributeName();
    }
    if (javaAttributeInfoOfOutput != null) {
        rpcOutput = javaAttributeInfoOfOutput.getAttributeName();
    }
    appendToFile(getRpcInterfaceTempFileHandle(), generateJavaDocForRpc(rpcName, RPC_INPUT_VAR_NAME, rpcOutput) + getRpcServiceMethod(rpcName, rpcInput, rpcOutput) + NEW_LINE);
    appendToFile(getRpcImplTempFileHandle(), getRpcManagerMethod(rpcName, rpcInput, rpcOutput) + NEW_LINE);
}
#end_block

#method_before
public static String generateClassDefinition(int genFileTypes, String yangName) {
    /**
     * Based on the file type and the YANG name of the file, generate the
     * class / interface definition start.
     */
    if ((genFileTypes & INTERFACE_MASK) != 0) {
        return getInterfaceDefinition(yangName);
    } else if ((genFileTypes & BUILDER_CLASS_MASK) != 0) {
        return getBuilderClassDefinition(yangName);
    } else if ((genFileTypes & IMPL_CLASS_MASK) != 0) {
        return getImplClassDefinition(yangName);
    } else if ((genFileTypes & BUILDER_INTERFACE_MASK) != 0) {
        return getBuilderInterfaceDefinition(yangName);
    } else if ((genFileTypes & GENERATE_TYPEDEF_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_UNION_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_ENUM_CLASS) != 0) {
        return getEnumClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_RPC_INTERFACE) != 0) {
        return getRpcInterfaceDefinition(yangName);
    } else if ((genFileTypes & GENERATE_EVENT_CLASS) != 0) {
        return getEventDefinition(yangName);
    } else if ((genFileTypes & GENERATE_EVENT_LISTENER_INTERFACE) != 0) {
        return getEventListenerDefinition(yangName);
    }
    return null;
}
#method_after
public static String generateClassDefinition(int genFileTypes, String yangName) {
    /**
     * Based on the file type and the YANG name of the file, generate the
     * class / interface definition start.
     */
    if ((genFileTypes & INTERFACE_MASK) != 0) {
        return getInterfaceDefinition(yangName);
    } else if ((genFileTypes & BUILDER_CLASS_MASK) != 0) {
        return getBuilderClassDefinition(yangName);
    } else if ((genFileTypes & IMPL_CLASS_MASK) != 0) {
        return getImplClassDefinition(yangName);
    } else if ((genFileTypes & BUILDER_INTERFACE_MASK) != 0) {
        return getBuilderInterfaceDefinition(yangName);
    } else if ((genFileTypes & GENERATE_TYPEDEF_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_UNION_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_ENUM_CLASS) != 0) {
        return getEnumClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_SERVICE_AND_MANAGER) != 0) {
        return getRpcInterfaceDefinition(yangName);
    } else if ((genFileTypes & GENERATE_EVENT_CLASS) != 0) {
        return getEventDefinition(yangName);
    } else if ((genFileTypes & GENERATE_EVENT_LISTENER_INTERFACE) != 0) {
        return getEventListenerDefinition(yangName);
    }
    return null;
}
#end_block

#method_before
private static String getRpcInterfaceDefinition(String yangName) {
    return PUBLIC + SPACE + INTERFACE + SPACE + yangName + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#method_after
private static String getRpcInterfaceDefinition(String yangName) {
    if (yangName.contains(SERVICE)) {
        return PUBLIC + SPACE + INTERFACE + SPACE + yangName + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    }
    return PUBLIC + SPACE + CLASS + SPACE + yangName + MANAGER + SPACE + IMPLEMENTS + SPACE + yangName + SERVICE + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
private static String getEventDefinition(String javaName) {
    String classDef = PUBLIC + SPACE + CLASS + SPACE + javaName + SPACE + "extends AbstractEvent<" + javaName + ".Type, " + javaName;
    if (classDef.length() < 5) {
        throw new RuntimeException("Event class name is error");
    }
    classDef = classDef.substring(0, (classDef.length() - 5));
    classDef = classDef + ">" + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    return classDef;
}
#method_after
private static String getEventDefinition(String javaName) {
    String classDef = PUBLIC + SPACE + CLASS + SPACE + javaName + SPACE + "extends AbstractEvent<" + javaName + ".Type, " + javaName;
    if (classDef.length() < 5) {
        throw new RuntimeException("Event class name is error");
    }
    classDef = classDef.substring(0, classDef.length() - 5);
    classDef = classDef + ">" + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    return classDef;
}
#end_block

#method_before
private static String getEventListenerDefinition(String javaName) {
    String intfDef = PUBLIC + SPACE + INTERFACE + SPACE + javaName + SPACE + "extends EventListener<" + javaName;
    if (intfDef.length() < 8) {
        throw new RuntimeException("Event listener interface name is error");
    }
    intfDef = intfDef.substring(0, (intfDef.length() - 8));
    intfDef = intfDef + "Event>" + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    return intfDef;
}
#method_after
private static String getEventListenerDefinition(String javaName) {
    String intfDef = PUBLIC + SPACE + INTERFACE + SPACE + javaName + SPACE + "extends EventListener<" + javaName;
    if (intfDef.length() < 8) {
        throw new RuntimeException("Event listener interface name is error");
    }
    intfDef = intfDef.substring(0, intfDef.length() - 8);
    intfDef = intfDef + "Event>" + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    return intfDef;
}
#end_block

#method_before
void addGeneratedTempFile(int generatedTempFile) {
    generatedTempFiles |= generatedTempFile;
}
#method_after
void addGeneratedTempFile(int generatedTempFile) {
    generatedTempFiles |= generatedTempFile;
    setGeneratedTempFiles(generatedTempFiles);
}
#end_block

#method_before
private String getGeneratedJavaClassName() {
    return getJavaFileInfo().getJavaName();
}
#method_after
String getGeneratedJavaClassName() {
    return getJavaFileInfo().getJavaName();
}
#end_block

#method_before
private void setAttributesTempFileHandle(File attributeForClass) {
    attributesTempFileHandle = attributeForClass;
}
#method_after
void setAttributesTempFileHandle(File attributeForClass) {
    attributesTempFileHandle = attributeForClass;
}
#end_block

#method_before
private void setGetterImplTempFileHandle(File getterImpl) {
    getterImplTempFileHandle = getterImpl;
}
#method_after
void setGetterImplTempFileHandle(File getterImpl) {
    getterImplTempFileHandle = getterImpl;
}
#end_block

#method_before
private void setHashCodeImplTempFileHandle(File hashCodeMethod) {
    hashCodeImplTempFileHandle = hashCodeMethod;
}
#method_after
void setHashCodeImplTempFileHandle(File hashCodeMethod) {
    hashCodeImplTempFileHandle = hashCodeMethod;
}
#end_block

#method_before
private void setEqualsImplTempFileHandle(File equalsMethod) {
    equalsImplTempFileHandle = equalsMethod;
}
#method_after
void setEqualsImplTempFileHandle(File equalsMethod) {
    equalsImplTempFileHandle = equalsMethod;
}
#end_block

#method_before
private void setToStringImplTempFileHandle(File toStringMethod) {
    toStringImplTempFileHandle = toStringMethod;
}
#method_after
void setToStringImplTempFileHandle(File toStringMethod) {
    toStringImplTempFileHandle = toStringMethod;
}
#end_block

#method_before
private List<String> getExtendsList() {
    return extendsList;
}
#method_after
List<String> getExtendsList() {
    return extendsList;
}
#end_block

#method_before
private void addGetterImpl(JavaAttributeInfo attr) throws IOException {
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0) {
        appendToFile(getGetterImplTempFileHandle(), getOverRideString() + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    } else {
        appendToFile(getGetterImplTempFileHandle(), getJavaDoc(GETTER_METHOD, attr.getAttributeName(), false) + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    }
}
#method_after
private void addGetterImpl(JavaAttributeInfo attr) throws IOException {
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0 || (getGeneratedJavaFiles() & GENERATE_SERVICE_AND_MANAGER) != 0) {
        appendToFile(getGetterImplTempFileHandle(), getOverRideString() + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    } else {
        appendToFile(getGetterImplTempFileHandle(), getJavaDoc(GETTER_METHOD, attr.getAttributeName(), false) + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    }
}
#end_block

#method_before
File getJavaFileHandle(String fileName) throws IOException {
    // createPackage(getAbsoluteDirPath(), getJavaFileInfo().getJavaName());
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, getJavaFileInfo());
}
#method_after
File getJavaFileHandle(String fileName) throws IOException {
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, getJavaFileInfo());
}
#end_block

#method_before
public static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList) throws IOException {
    YangNode parent = getParentNodeInGenCode(curNode);
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException("missing parent node to contain current node info in generated file");
    }
    JavaAttributeInfo javaAttributeInfo = getCurNodeAsAttributeInParent(curNode, parent, isList);
    if (!(parent instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException("missing parent temp file handle");
    }
    ((TempJavaCodeFragmentFilesContainer) parent).getTempJavaCodeFragmentFiles().getBeanTempFiles().addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#method_after
public static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList) throws IOException {
    YangNode parent = getParentNodeInGenCode(curNode);
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException("missing parent node to contain current node info in generated file");
    }
    JavaAttributeInfo javaAttributeInfo = getCurNodeAsAttributeInParent(curNode, parent, isList);
    if (!(parent instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException("missing parent temp file handle");
    }
    getNodesInterfaceFragmentFiles(parent).addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#end_block

#method_before
public static JavaAttributeInfo getCurNodeAsAttributeInParent(YangNode curNode, YangNode parentNode, boolean isListNode) {
    String curNodeName = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName();
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access
         */
    JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(parentNode, curNodeName);
    if (!(parentNode instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException("Parent node does not have file info");
    }
    TempJavaFragmentFiles tempJavaFragmentFiles;
    tempJavaFragmentFiles = ((TempJavaCodeFragmentFilesContainer) parentNode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    boolean isQualified = true;
    JavaImportData parentImportData = tempJavaFragmentFiles.getJavaImportData();
    if (!detectCollisionBwParentAndChildForImport(curNode, qualifiedTypeInfo)) {
        parentImportData.addImportInfo(qualifiedTypeInfo);
        isQualified = false;
    }
    return getAttributeInfoForTheData(qualifiedTypeInfo, curNodeName, null, isQualified, isListNode);
}
#method_after
public static JavaAttributeInfo getCurNodeAsAttributeInParent(YangNode curNode, YangNode parentNode, boolean isListNode) {
    String curNodeName = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName();
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access
         */
    JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(parentNode, curNodeName);
    if (!(parentNode instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException("Parent node does not have file info");
    }
    TempJavaFragmentFiles tempJavaFragmentFiles = getNodesInterfaceFragmentFiles(parentNode);
    boolean isQualified = true;
    JavaImportData parentImportData = tempJavaFragmentFiles.getJavaImportData();
    if (isListNode) {
        parentImportData.setIfListImported(true);
    }
    if (!detectCollisionBwParentAndChildForImport(curNode, qualifiedTypeInfo)) {
        parentImportData.addImportInfo(qualifiedTypeInfo);
        isQualified = false;
    }
    return getAttributeInfoForTheData(qualifiedTypeInfo, curNodeName, null, isQualified, isListNode);
}
#end_block

#method_before
private void addLeafListInfoToTempFiles(List<YangLeafList> listOfLeafList, YangPluginConfig yangPluginConfig) throws IOException {
    if (listOfLeafList != null) {
        for (YangLeafList leafList : listOfLeafList) {
            if (!(leafList instanceof JavaLeafInfoContainer)) {
                throw new TranslatorException("Leaf-list does not have java information");
            }
            JavaLeafInfoContainer javaLeaf = (JavaLeafInfoContainer) leafList;
            javaLeaf.updateJavaQualifiedInfo();
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaLeaf.getJavaQualifiedInfo(), javaLeaf.getJavaName(yangPluginConfig.getConflictResolver()), javaLeaf.getDataType(), getIsQualifiedAccessOrAddToImportList(javaLeaf.getJavaQualifiedInfo()), true);
            addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
        }
    }
}
#method_after
private void addLeafListInfoToTempFiles(List<YangLeafList> listOfLeafList, YangPluginConfig yangPluginConfig) throws IOException {
    if (listOfLeafList != null) {
        for (YangLeafList leafList : listOfLeafList) {
            if (!(leafList instanceof JavaLeafInfoContainer)) {
                throw new TranslatorException("Leaf-list does not have java information");
            }
            JavaLeafInfoContainer javaLeaf = (JavaLeafInfoContainer) leafList;
            javaLeaf.updateJavaQualifiedInfo();
            getJavaImportData().setIfListImported(true);
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaLeaf.getJavaQualifiedInfo(), javaLeaf.getJavaName(yangPluginConfig.getConflictResolver()), javaLeaf.getDataType(), getIsQualifiedAccessOrAddToImportList(javaLeaf.getJavaQualifiedInfo()), true);
            addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
        }
    }
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setAttributePresent(true);
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        addAttribute(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_INTERFACE_MASK) != 0) {
        addGetterForInterface(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_INTERFACE_MASK) != 0) {
        addSetterForInterface(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
        addGetterImpl(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_CLASS_MASK) != 0) {
        addSetterImpl(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & CONSTRUCTOR_IMPL_MASK) != 0) {
        addConstructor(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        addHashCodeMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        addEqualsMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        addToStringMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & ENUM_IMPL_MASK) != 0) {
        addAttributesForEnumClass(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & OF_STRING_IMPL_MASK) != 0) {
        addOfStringMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        addTypeConstructor(newAttrInfo);
    }
}
#method_after
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setAttributePresent(true);
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        addAttribute(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_INTERFACE_MASK) != 0) {
        addGetterForInterface(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_INTERFACE_MASK) != 0) {
        addSetterForInterface(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_CLASS_MASK) != 0) {
        addSetterImpl(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
        addGetterImpl(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        addHashCodeMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        addEqualsMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        addToStringMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & FROM_STRING_IMPL_MASK) != 0) {
        JavaQualifiedTypeInfo qualifiedInfoOfFromString = getQualifiedInfoOfFromString(newAttrInfo);
        /*
             * Create a new java attribute info with qualified information of
             * wrapper classes.
             */
        JavaAttributeInfo fromStringAttributeInfo = getAttributeInfoForTheData(qualifiedInfoOfFromString, newAttrInfo.getAttributeName(), newAttrInfo.getAttributeType(), getIsQualifiedAccessOrAddToImportList(qualifiedInfoOfFromString), false);
        addFromStringMethod(newAttrInfo, fromStringAttributeInfo);
    }
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    if (isAttributePresent()) {
        imports = getJavaImportData().getImports();
    }
    // Prepares java file generator for extends list.
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    createPackage(curNode);
    // Generate java code.
    if ((fileType & INTERFACE_MASK) != 0 | (fileType & BUILDER_INTERFACE_MASK) != 0) {
        // Adds import for case.
        if (curNode instanceof YangCase) {
            List<String> importData = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
            for (String importInfo : importData) {
                if (!imports.contains(importInfo)) {
                    imports.add(importInfo);
                }
            }
        }
        // Adds import for HasAugmentation class.
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
        }
        sortImports(imports);
        // Create interface file.
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent()));
        // Create builder interface file.
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent()));
            // Append builder interface file to interface file and close it.
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, false);
        }
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 | (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent()) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isHasAugmentationExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        sortImports(imports);
        // Create builder class file.
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent()));
        // Create impl class file.
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent()));
            // Append impl class to builder class and close it.
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    // Creates type def class file.
    if ((fileType & GENERATE_TYPEDEF_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypedefClassJavaFileHandle(getJavaFileHandle(getJavaClassName(TYPEDEF_CLASS_FILE_NAME_SUFFIX)));
        setTypedefClassJavaFileHandle(generateTypeDefClassFile(getTypedefClassJavaFileHandle(), curNode, imports));
    }
    // Creates type class file.
    if ((fileType & GENERATE_UNION_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypeClassJavaFileHandle(getJavaFileHandle(getJavaClassName(UNION_TYPE_CLASS_FILE_NAME_SUFFIX)));
        setTypeClassJavaFileHandle(generateUnionClassFile(getTypeClassJavaFileHandle(), curNode, imports));
    }
    // Creates type enum class file.
    if ((fileType & GENERATE_ENUM_CLASS) != 0) {
        setEnumClassJavaFileHandle(getJavaFileHandle(getJavaClassName(ENUM_CLASS_FILE_NAME_SUFFIX)));
        setEnumClassJavaFileHandle(generateEnumClassFile(getEnumClassJavaFileHandle(), curNode));
    }
    // Close all the file handles.
    close(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    if (isAttributePresent()) {
        imports = getJavaImportData().getImports();
    }
    /*
         * Prepares java file generator for extends list.
         */
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    createPackage(curNode);
    /*
         * Generate java code.
         */
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /*
             * Adds import for case.
             */
        if (curNode instanceof YangCase) {
            List<String> importData = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
            for (String importInfo : importData) {
                if (!imports.contains(importInfo)) {
                    imports.add(importInfo);
                }
            }
        }
        /*
             * Adds import for HasAugmentation class.
             */
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
        }
        sortImports(imports);
        /*
             * Create interface file.
             */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent()));
        /*
             * Create builder interface file.
             */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append builder interface file to interface file and close it.
                 */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, false);
        }
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent()) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isHasAugmentationExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        sortImports(imports);
        /*
             * Create builder class file.
             */
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent()));
        /*
             * Create impl class file.
             */
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append impl class to builder class and close it.
                 */
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    /*
         * Close all the file handles.
         */
    freeTemporaryResources(false);
}
#end_block

#method_before
@Test
public void cleanGeneratedDirTest() throws IOException {
    File baseDirPath = new File(BASE_DIR);
    File createNewDir = new File(BASE_DIR + File.separator + UtilConstants.YANG_GEN_DIR);
    createNewDir.mkdirs();
    File createFile = new File(createNewDir + File.separator + "check1.java");
    createFile.createNewFile();
    clean(baseDirPath.getAbsolutePath());
}
#method_after
@Test
public void cleanGeneratedDirTest() throws IOException {
    File baseDirPath = new File(BASE_DIR);
    File createNewDir = new File(BASE_DIR + File.separator + UtilConstants.YANG_GEN_DIR);
    createNewDir.mkdirs();
    File createFile = new File(createNewDir + File.separator + "check1.java");
    createFile.createNewFile();
    deleteDirectory(baseDirPath.getAbsolutePath());
}
#end_block

#method_before
@Test
public void cleanWithInvalidDirTest() throws IOException {
    File baseDirPath = new File(BASE_DIR + "invalid");
    clean(baseDirPath.getAbsolutePath());
}
#method_after
@Test
public void cleanWithInvalidDirTest() throws IOException {
    File baseDirPath = new File(BASE_DIR + "invalid");
    deleteDirectory(baseDirPath.getAbsolutePath());
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(getCamelCase(name, null));
    switch(type) {
        case IMPL_CLASS:
            {
                return generateForImplClass(name);
            }
        case BUILDER_CLASS:
            {
                return generateForBuilderClass(name);
            }
        case INTERFACE:
            {
                return generateForInterface(name);
            }
        case BUILDER_INTERFACE:
            {
                return generateForBuilderInterface(name);
            }
        case PACKAGE_INFO:
            {
                return generateForPackage(name, isList);
            }
        case GETTER_METHOD:
            {
                return generateForGetters(name, isList);
            }
        case TYPE_DEF_SETTER_METHOD:
            {
                return generateForTypeDefSetter(name);
            }
        case SETTER_METHOD:
            {
                return generateForSetters(name, isList);
            }
        case OF_METHOD:
            {
                return generateForOf(name);
            }
        case DEFAULT_CONSTRUCTOR:
            {
                return generateForDefaultConstructors(name);
            }
        case BUILD_METHOD:
            {
                return generateForBuild(name);
            }
        case TYPE_CONSTRUCTOR:
            {
                return generateForTypeConstructor(name);
            }
        case FROM_METHOD:
            {
                return generateForFromString(name);
            }
        case ENUM_CLASS:
            {
                return generateForEnum(name);
            }
        case ENUM_ATTRIBUTE:
            {
                return generateForEnumAttr(name);
            }
        case RPC_INTERFACE:
            {
                return generateForRpcInterface(name);
            }
        case EVENT:
            {
                return generateForEvent(name);
            }
        case EVENT_LISTENER:
            {
                return generateForEventListener(name);
            }
        default:
            {
                return generateForConstructors(name);
            }
    }
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(getCamelCase(name, null));
    switch(type) {
        case IMPL_CLASS:
            {
                return generateForImplClass(name);
            }
        case BUILDER_CLASS:
            {
                return generateForBuilderClass(name);
            }
        case INTERFACE:
            {
                return generateForInterface(name);
            }
        case BUILDER_INTERFACE:
            {
                return generateForBuilderInterface(name);
            }
        case PACKAGE_INFO:
            {
                return generateForPackage(name, isList);
            }
        case GETTER_METHOD:
            {
                return generateForGetters(name, isList);
            }
        case TYPE_DEF_SETTER_METHOD:
            {
                return generateForTypeDefSetter(name);
            }
        case SETTER_METHOD:
            {
                return generateForSetters(name, isList);
            }
        case MANAGER_SETTER_METHOD:
            {
                return generateForManagerSetters(name, isList);
            }
        case OF_METHOD:
            {
                return generateForOf(name);
            }
        case DEFAULT_CONSTRUCTOR:
            {
                return generateForDefaultConstructors(name);
            }
        case BUILD_METHOD:
            {
                return generateForBuild(name);
            }
        case TYPE_CONSTRUCTOR:
            {
                return generateForTypeConstructor(name);
            }
        case FROM_METHOD:
            {
                return generateForFromString(name);
            }
        case ENUM_CLASS:
            {
                return generateForEnum(name);
            }
        case ENUM_ATTRIBUTE:
            {
                return generateForEnumAttr(name);
            }
        case RPC_INTERFACE:
            {
                return generateForRpcService(name);
            }
        case RPC_MANAGER:
            {
                return generateForImplClass(name);
            }
        case EVENT:
            {
                return generateForEvent(name);
            }
        case EVENT_LISTENER:
            {
                return generateForEventListener(name);
            }
        default:
            {
                return generateForConstructors(name);
            }
    }
}
#end_block

#method_before
public static String generateJavaDocForRpc(String rpcName, String inputName, String outputName) {
    rpcName = getCamelCase(rpcName, null);
    inputName = getCaptialCase(inputName);
    outputName = getCaptialCase(outputName);
    return NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_RPC + rpcName + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ASTERISK + getInputString(inputName, rpcName) + getOutputString(outputName, rpcName) + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#method_after
public static String generateJavaDocForRpc(String rpcName, String inputName, String outputName) {
    rpcName = getCamelCase(rpcName, null);
    String javadoc = NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_RPC + rpcName + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ASTERISK + getInputString(inputName, rpcName);
    if (!outputName.equals(VOID)) {
        javadoc = javadoc + getOutputString(outputName, rpcName);
    }
    return javadoc + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#end_block

#method_before
private static String generateForFromString(String attribute) {
    return NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_OF + attribute + SPACE + FROM_STRING_METHOD_NAME + SPACE + INPUT + SPACE + STRING_DATA_TYPE + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ASTERISK + FOUR_SPACE_INDENTATION + JAVA_DOC_PARAM + FROM_STRING_PARAM_NAME + SPACE + INPUT + SPACE + STRING_DATA_TYPE + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_RETURN + OBJECT + SPACE + OF + SPACE + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#method_after
private static String generateForFromString(String attribute) {
    return NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_FIRST_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_OF + attribute + SPACE + FROM_STRING_METHOD_NAME + SPACE + INPUT + SPACE + STRING_DATA_TYPE + PERIOD + NEW_LINE + FOUR_SPACE_INDENTATION + NEW_LINE_ASTERISK + FOUR_SPACE_INDENTATION + JAVA_DOC_PARAM + FROM_STRING_PARAM_NAME + SPACE + INPUT + SPACE + STRING_DATA_TYPE + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_RETURN + OBJECT + SPACE + OF + SPACE + attribute + NEW_LINE + FOUR_SPACE_INDENTATION + JAVA_DOC_END_LINE;
}
#end_block

#method_before
public static void createPackage(YangNode curNode) throws IOException {
    if (!(curNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException("current node must have java file info");
    }
    String pkgInfo;
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String pkg = getAbsolutePackagePath(javaFileInfo.getBaseCodeGenPath(), javaFileInfo.getPackageFilePath());
    if (!doesPackageExist(pkg)) {
        try {
            File pack = createDirectories(pkg);
            if (curNode.getParent() != null) {
                pkgInfo = ((JavaFileInfoContainer) curNode.getParent()).getJavaFileInfo().getJavaName();
                addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true);
            } else {
                pkgInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName();
                addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), false);
            }
        } catch (IOException e) {
            throw new IOException("failed to create package-info file");
        }
    }
}
#method_after
public static void createPackage(YangNode yangNode) throws IOException {
    if (!(yangNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException("current node must have java file info");
    }
    String pkgInfo;
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) yangNode).getJavaFileInfo();
    String pkg = getAbsolutePackagePath(javaFileInfo.getBaseCodeGenPath(), javaFileInfo.getPackageFilePath());
    if (!doesPackageExist(pkg)) {
        try {
            File pack = createDirectories(pkg);
            YangNode parent = getParentNodeInGenCode(yangNode);
            if (parent != null) {
                pkgInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo().getJavaName();
                addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), true);
            } else {
                pkgInfo = ((JavaFileInfoContainer) yangNode).getJavaFileInfo().getJavaName();
                addPackageInfo(pack, pkgInfo, getJavaPackageFromPackagePath(pkg), false);
            }
        } catch (IOException e) {
            throw new IOException("failed to create package-info file");
        }
    }
}
#end_block

#method_before
public List<String> getImports() {
    String importString;
    List<String> imports = new ArrayList<>();
    for (JavaQualifiedTypeInfo importInfo : getImportSet()) {
        if (!importInfo.getPkgInfo().equals(EMPTY_STRING) && importInfo.getClassInfo() != null && !importInfo.getPkgInfo().equals(JAVA_LANG)) {
            importString = IMPORT + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
            imports.add(importString);
        }
    }
    if (isListToImport) {
        imports.add(getImportForList());
    }
    sort(imports);
    return imports;
}
#method_after
public List<String> getImports() {
    String importString;
    List<String> imports = new ArrayList<>();
    for (JavaQualifiedTypeInfo importInfo : getImportSet()) {
        if (!importInfo.getPkgInfo().equals(EMPTY_STRING) && importInfo.getClassInfo() != null && !importInfo.getPkgInfo().equals(JAVA_LANG)) {
            importString = IMPORT + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
            imports.add(importString);
        }
    }
    if (getIfListImported()) {
        imports.add(getImportForList());
    }
    sort(imports);
    return imports;
}
#end_block

#method_before
public static String getImportForHashAndEquals() {
    return IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_OBJECTS_IMPORT_CLASS;
}
#method_after
public String getImportForHashAndEquals() {
    return IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_OBJECTS_IMPORT_CLASS;
}
#end_block

#method_before
public static String getImportForToString() {
    return IMPORT + GOOGLE_MORE_OBJECT_IMPORT_PKG + PERIOD + GOOGLE_MORE_OBJECT_IMPORT_CLASS;
}
#method_after
public String getImportForToString() {
    return IMPORT + GOOGLE_MORE_OBJECT_IMPORT_PKG + PERIOD + GOOGLE_MORE_OBJECT_IMPORT_CLASS;
}
#end_block

#method_before
@Test
public void testTrafficTreatmentEncode() {
    Instruction output = Instructions.createOutput(PortNumber.portNumber(0));
    Instruction modL2Src = Instructions.modL2Src(MacAddress.ZERO);
    Instruction modL2Dst = Instructions.modL2Dst(MacAddress.ZERO);
    MeterId meterId = MeterId.meterId(0);
    Instruction meter = Instructions.meterTraffic(meterId);
    Instruction transition = Instructions.transition(1);
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    TrafficTreatment treatment = tBuilder.add(output).add(modL2Src).add(modL2Dst).add(meter).add(transition).build();
    ObjectNode treatmentJson = trafficTreatmentCodec.encode(treatment, context);
    assertThat(treatmentJson, TrafficTreatmentJsonMatcher.matchesTrafficTreatment(treatment));
}
#method_after
@Test
public void testTrafficTreatmentEncode() {
    Instruction output = Instructions.createOutput(PortNumber.portNumber(0));
    Instruction modL2Src = Instructions.modL2Src(MacAddress.valueOf("11:22:33:44:55:66"));
    Instruction modL2Dst = Instructions.modL2Dst(MacAddress.valueOf("44:55:66:77:88:99"));
    MeterId meterId = MeterId.meterId(0);
    Instruction meter = Instructions.meterTraffic(meterId);
    Instruction transition = Instructions.transition(1);
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    TrafficTreatment treatment = tBuilder.add(output).add(modL2Src).add(modL2Dst).add(meter).add(transition).build();
    ObjectNode treatmentJson = trafficTreatmentCodec.encode(treatment, context);
    assertThat(treatmentJson, TrafficTreatmentJsonMatcher.matchesTrafficTreatment(treatment));
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            String message = BridgeCreateException.createMessage(ovsUuid);
            throw new BridgeCreateException(message);
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#method_after
@Override
public void createBridge(String bridgeName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    Map<String, String> options = new HashMap<>();
    options.put("disable-in-band", "true");
    bridge.setOtherConfig(options);
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            String message = BridgeCreateException.createMessage(ovsUuid);
            throw new BridgeCreateException(message);
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName, String dpid, String exPortName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        if (dpid != null) {
            Map<String, String> options = new HashMap<>();
            options.put("datapath-id", dpid);
            options.put("disable-in-band", "true");
            bridge.setOtherConfig(options);
        }
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            String message = BridgeCreateException.createMessage(ovsUuid);
            throw new BridgeCreateException(message);
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    // Create external port
    if (exPortName != null) {
        createPort(bridgeName, exPortName);
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#method_after
@Override
public void createBridge(String bridgeName, String dpid, String exPortName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    Map<String, String> options = new HashMap<>();
    options.put("disable-in-band", "true");
    if (dpid != null) {
        options.put("datapath-id", dpid);
    }
    bridge.setOtherConfig(options);
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        } else {
            String message = BridgeCreateException.createMessage(ovsUuid);
            throw new BridgeCreateException(message);
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    // Create external port
    if (exPortName != null) {
        createPort(bridgeName, exPortName);
    }
    setControllerAuto(bridgeUuid);
    log.info("Create bridge success");
}
#end_block

#method_before
@Override
public boolean createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.warn("Couldn't find database Open_vSwitch");
        return false;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    Set<String> failMode = new HashSet<>(Arrays.asList("secure"));
    bridge.setFailMode(failMode);
    Set<String> protocols = new HashSet<>(Arrays.asList(OvsdbConstant.OPENFLOW13));
    bridge.setProtocols(protocols);
    Map<String, String> options = new HashMap<>();
    options.put("datapath-id", dpid);
    bridge.setOtherConfig(options);
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
    } else {
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    if (bridgeUuid != null) {
        createPort(bridgeName, bridgeName);
    } else {
        log.warn("Failed to create bridge {} on {}", bridgeName, nodeId.toString());
        return false;
    }
    setControllersWithUuid(Uuid.uuid(bridgeUuid), controllers);
    return true;
}
#method_after
@Override
public boolean createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.warn("Couldn't find database Open_vSwitch");
        return false;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    Set<String> failMode = new HashSet<>(Arrays.asList("secure"));
    bridge.setFailMode(failMode);
    Set<String> protocols = new HashSet<>(Arrays.asList(OvsdbConstant.OPENFLOW13));
    bridge.setProtocols(protocols);
    Map<String, String> options = new HashMap<>();
    options.put("disable-in-band", "true");
    if (dpid != null) {
        options.put("datapath-id", dpid);
    }
    bridge.setOtherConfig(options);
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
    } else {
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    if (bridgeUuid != null) {
        createPort(bridgeName, bridgeName);
    } else {
        log.warn("Failed to create bridge {} on {}", bridgeName, nodeId.toString());
        return false;
    }
    setControllersWithUuid(Uuid.uuid(bridgeUuid), controllers);
    return true;
}
#end_block

#method_before
@Override
public boolean addGatewayNode(GatewayNode gatewayNode) {
    if (gatewayNodeMap.get(gatewayNode.getGatewayDeviceId()) != null) {
        log.info(FAIL_ADD_GATEWAY);
        return false;
    }
    gatewayNodeMap.put(gatewayNode.getGatewayDeviceId(), gatewayNode);
    return true;
}
#method_after
@Override
public boolean addGatewayNode(GatewayNode gatewayNode) {
    gatewayNodeMap.putIfAbsent(gatewayNode.getGatewayDeviceId(), gatewayNode);
    return true;
}
#end_block

#method_before
@Override
public boolean deleteGatewayNode(GatewayNode gatewayNode) {
    if (gatewayNodeMap.get(gatewayNode.getGatewayDeviceId()) == null) {
        log.info(FAIL_REMOVE_GATEWAY);
        return false;
    }
    return gatewayNodeMap.remove(gatewayNode.getGatewayDeviceId(), gatewayNode);
}
#method_after
@Override
public boolean deleteGatewayNode(GatewayNode gatewayNode) {
    return gatewayNodeMap.remove(gatewayNode.getGatewayDeviceId(), gatewayNode);
}
#end_block

#method_before
private void readConfiguration() {
    config = configService.getConfig(appId, GatewayNodeConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    config.gatewayNodes().forEach(gatewayNode -> gatewayNodeMap.putIfAbsent(gatewayNode.getGatewayDeviceId(), gatewayNode));
    log.info("ScalableGateway configured");
}
#method_after
private void readConfiguration() {
    config = configService.getConfig(appId, GatewayNodeConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    config.gatewayNodes().forEach(gatewayNode -> addGatewayNode(gatewayNode));
    log.info("ScalableGateway configured");
}
#end_block

#method_before
@Test
public void testEquals() {
    // create same two objects.
    DeviceId deviceId1 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId1 = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId1 = LabelResourceId.labelResourceId(2);
    LspLocalLabelInfo lspLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).build();
    // create same object as above object
    LspLocalLabelInfo sameLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).build();
    // Create different object.
    DeviceId deviceId2 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId2 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId2 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel2 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId2).inLabelId(inLabelId2).outLabelId(outLabelId2).build();
    new EqualsTester().addEqualityGroup(lspLocalLabel1, sameLocalLabel1).addEqualityGroup(lspLocalLabel2).testEquals();
}
#method_after
@Test
public void testEquals() {
    // create same two objects.
    DeviceId deviceId1 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId1 = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId1 = LabelResourceId.labelResourceId(2);
    PortNumber inPort1 = PortNumber.portNumber(5122);
    PortNumber outPort1 = PortNumber.portNumber(5123);
    LspLocalLabelInfo lspLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).inPort(inPort1).outPort(outPort1).build();
    // create same object as above object
    LspLocalLabelInfo sameLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).inPort(inPort1).outPort(outPort1).build();
    // Create different object.
    DeviceId deviceId2 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId2 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId2 = LabelResourceId.labelResourceId(4);
    PortNumber inPort2 = PortNumber.portNumber(5124);
    PortNumber outPort2 = PortNumber.portNumber(5125);
    LspLocalLabelInfo lspLocalLabel2 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId2).inLabelId(inLabelId2).outLabelId(outLabelId2).inPort(inPort2).outPort(outPort2).build();
    new EqualsTester().addEqualityGroup(lspLocalLabel1, sameLocalLabel1).addEqualityGroup(lspLocalLabel2).testEquals();
}
#end_block

#method_before
@Test
public void testConstruction() {
    DeviceId deviceId = DeviceId.deviceId("foo");
    LabelResourceId inLabelId = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId = LabelResourceId.labelResourceId(2);
    LspLocalLabelInfo lspLocalLabel = DefaultLspLocalLabelInfo.builder().deviceId(deviceId).inLabelId(inLabelId).outLabelId(outLabelId).build();
    assertThat(deviceId, is(lspLocalLabel.deviceId()));
    assertThat(inLabelId, is(lspLocalLabel.inLabelId()));
    assertThat(outLabelId, is(lspLocalLabel.outLabelId()));
}
#method_after
@Test
public void testConstruction() {
    DeviceId deviceId = DeviceId.deviceId("foo");
    LabelResourceId inLabelId = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId = LabelResourceId.labelResourceId(2);
    PortNumber inPort = PortNumber.portNumber(5122);
    PortNumber outPort = PortNumber.portNumber(5123);
    LspLocalLabelInfo lspLocalLabel = DefaultLspLocalLabelInfo.builder().deviceId(deviceId).inLabelId(inLabelId).outLabelId(outLabelId).inPort(inPort).outPort(outPort).build();
    assertThat(deviceId, is(lspLocalLabel.deviceId()));
    assertThat(inLabelId, is(lspLocalLabel.inLabelId()));
    assertThat(outLabelId, is(lspLocalLabel.outLabelId()));
    assertThat(inPort, is(lspLocalLabel.inPort()));
    assertThat(outPort, is(lspLocalLabel.outPort()));
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(deviceId, inLabelId, outLabelId);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(deviceId, inLabelId, outLabelId, inPort, outPort);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof LspLocalLabelInfo) {
        final DefaultLspLocalLabelInfo other = (DefaultLspLocalLabelInfo) obj;
        return Objects.equals(this.deviceId, other.deviceId) && Objects.equals(this.inLabelId, other.inLabelId) && Objects.equals(this.outLabelId, other.outLabelId);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof LspLocalLabelInfo) {
        final DefaultLspLocalLabelInfo other = (DefaultLspLocalLabelInfo) obj;
        return Objects.equals(this.deviceId, other.deviceId) && Objects.equals(this.inLabelId, other.inLabelId) && Objects.equals(this.outLabelId, other.outLabelId) && Objects.equals(this.inPort, other.inPort) && Objects.equals(this.outPort, other.outPort);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("DeviceId", deviceId.toString()).add("InLabelId", inLabelId.toString()).add("OutLabelId", outLabelId.toString()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("DeviceId", deviceId.toString()).add("InLabelId", inLabelId.toString()).add("OutLabelId", outLabelId.toString()).add("InPort", inPort.toString()).add("OutPort", outPort.toString()).toString();
}
#end_block

#method_before
@Override
public LspLocalLabelInfo build() {
    return new DefaultLspLocalLabelInfo(deviceId, inLabelId, outLabelId);
}
#method_after
@Override
public LspLocalLabelInfo build() {
    return new DefaultLspLocalLabelInfo(deviceId, inLabelId, outLabelId, inPort, outPort);
}
#end_block

#method_before
@Activate
protected void activate() {
    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName("onos-pce-globalnodelabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(DeviceId.class, long.class, LabelResourceId.class).build())).build();
    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName("onos-pce-adjlabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, List.class, LabelResource.class, DeviceId.class, URI.class, String.class, long.class, LabelResourceId.class).build())).build();
    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName("onos-pce-tunnelinfomap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, DefaultPceccTunnelInfo.class, List.class, DefaultLspLocalLabelInfo.class, // TunnelConsumerId.class,
    DeviceId.class, URI.class, String.class, long.class, LabelResourceId.class).build())).build();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    globalNodeLabelMap = storageService.<DeviceId, LabelResourceId>consistentMapBuilder().withName("onos-pce-globalnodelabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(LabelResourceId.class).build())).build();
    adjLabelMap = storageService.<Link, LabelResourceId>consistentMapBuilder().withName("onos-pce-adjlabelmap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(Link.class, LabelResourceId.class).build())).build();
    tunnelInfoMap = storageService.<TunnelId, PceccTunnelInfo>consistentMapBuilder().withName("onos-pce-tunnelinfomap").withSerializer(Serializer.using(new KryoNamespace.Builder().register(KryoNamespaces.API).register(TunnelId.class, PceccTunnelInfo.class, DefaultLspLocalLabelInfo.class, TunnelConsumerId.class, LabelResourceId.class).build())).build();
    log.info("Started");
}
#end_block

#method_before
@Override
public Versioned<LabelResourceId> getGlobalNodeLabel(DeviceId id) {
    checkNotNull(id, DEVICE_ID_NULL);
    return globalNodeLabelMap.get(id);
}
#method_after
@Override
public LabelResourceId getGlobalNodeLabel(DeviceId id) {
    checkNotNull(id, DEVICE_ID_NULL);
    return globalNodeLabelMap.get(id).value();
}
#end_block

#method_before
@Override
public Versioned<LabelResourceId> getAdjLabel(Link link) {
    checkNotNull(link, LINK_NULL);
    return adjLabelMap.get(link);
}
#method_after
@Override
public LabelResourceId getAdjLabel(Link link) {
    checkNotNull(link, LINK_NULL);
    return adjLabelMap.get(link).value();
}
#end_block

#method_before
@Override
public Versioned<PceccTunnelInfo> getTunnelInfo(TunnelId tunnelId) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    return tunnelInfoMap.get(tunnelId);
}
#method_after
@Override
public PceccTunnelInfo getTunnelInfo(TunnelId tunnelId) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    return tunnelInfoMap.get(tunnelId).value();
}
#end_block

#method_before
@Override
public boolean addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(labelId, LABEL_RESOURCE_ID_NULL);
    globalNodeLabelMap.put(deviceId, labelId);
    if (!globalNodeLabelMap.containsKey(deviceId)) {
        log.error("Adding SR-TE node label for device id {} has failed.", deviceId.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public void addGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(labelId, LABEL_RESOURCE_ID_NULL);
    globalNodeLabelMap.put(deviceId, labelId);
}
#end_block

#method_before
@Override
public boolean addAdjLabel(Link link, LabelResourceId labelId) {
    checkNotNull(link, LINK_NULL);
    checkNotNull(labelId, LABEL_RESOURCE_ID_NULL);
    adjLabelMap.put(link, labelId);
    if (!adjLabelMap.containsKey(link)) {
        log.error("Adding adjacency label for link {} hash failed.", link.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public void addAdjLabel(Link link, LabelResourceId labelId) {
    checkNotNull(link, LINK_NULL);
    checkNotNull(labelId, LABEL_RESOURCE_ID_NULL);
    adjLabelMap.put(link, labelId);
}
#end_block

#method_before
@Override
public boolean addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(pceccTunnelInfo, DEVICE_LABEL_STORE_INFO_NULL);
    tunnelInfoMap.put(tunnelId, pceccTunnelInfo);
    if (!tunnelInfoMap.containsKey(tunnelId)) {
        log.error("Adding tunnel info for tunnel id {} has failed.", tunnelId.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public void addTunnelInfo(TunnelId tunnelId, PceccTunnelInfo pceccTunnelInfo) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(pceccTunnelInfo, PCECC_TUNNEL_INFO_NULL);
    tunnelInfoMap.put(tunnelId, pceccTunnelInfo);
}
#end_block

#method_before
@Override
public boolean updateTunnelInfo(TunnelId tunnelId, PceccTunnelInfo labelStoreInfo) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(labelStoreInfo, DEVICE_LABEL_STORE_INFO_NULL);
    if (!tunnelInfoMap.containsKey((tunnelId))) {
        log.debug("Tunnel info does not exist whose tunnel id is {}.", tunnelId.toString());
        return false;
    }
    tunnelInfoMap.put(tunnelId, labelStoreInfo);
    if (!labelStoreInfo.equals(tunnelInfoMap.get(tunnelId).value())) {
        log.debug("Tunnel info updation is failed whose tunnel id is {} ", tunnelId.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean updateTunnelInfo(TunnelId tunnelId, List<LspLocalLabelInfo> lspLocalLabelInfoList) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    checkNotNull(lspLocalLabelInfoList, LSP_LOCAL_LABEL_INFO_NULL);
    if (!tunnelInfoMap.containsKey((tunnelId))) {
        log.debug("Tunnel info does not exist whose tunnel id is {}.", tunnelId.toString());
        return false;
    }
    PceccTunnelInfo tunnelInfo = tunnelInfoMap.get(tunnelId).value();
    tunnelInfo.lspLocalLabelInfoList(lspLocalLabelInfoList);
    tunnelInfoMap.put(tunnelId, tunnelInfo);
    return true;
}
#end_block

#method_before
@Override
public boolean removeGlobalNodeLabel(DeviceId id) {
    checkNotNull(id, DEVICE_ID_NULL);
    globalNodeLabelMap.remove(id);
    if (globalNodeLabelMap.containsKey(id)) {
        log.error("SR-TE node label deletion for device {} has failed.", id.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean removeGlobalNodeLabel(DeviceId id) {
    checkNotNull(id, DEVICE_ID_NULL);
    if (globalNodeLabelMap.remove(id) == null) {
        log.error("SR-TE node label deletion for device {} has failed.", id.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean removeAdjLabel(Link link) {
    checkNotNull(link, LINK_NULL);
    adjLabelMap.remove(link);
    if (adjLabelMap.containsKey(link)) {
        log.error("Adjacency label deletion for link {} hash failed.", link.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean removeAdjLabel(Link link) {
    checkNotNull(link, LINK_NULL);
    if (adjLabelMap.remove(link) == null) {
        log.error("Adjacency label deletion for link {} hash failed.", link.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean removeTunnelInfo(TunnelId tunnelId) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    tunnelInfoMap.remove(tunnelId);
    if (tunnelInfoMap.containsKey(tunnelId)) {
        log.error("Tunnel info deletion for tunnel id {} has failed.", tunnelId.toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean removeTunnelInfo(TunnelId tunnelId) {
    checkNotNull(tunnelId, TUNNEL_ID_NULL);
    if (tunnelInfoMap.remove(tunnelId) == null) {
        log.error("Tunnel info deletion for tunnel id {} has failed.", tunnelId.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    distrPceStore = new DistributedPceStore();
    // Initialization of member variables
    link1 = DefaultLink.builder().providerId(new ProviderId("eth", "1")).annotations(DefaultAnnotations.builder().set("key1", "yahoo").build()).src(srcConnectionPoint1).dst(dstConnectionPoint2).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    link2 = DefaultLink.builder().providerId(new ProviderId("mac", "2")).annotations(DefaultAnnotations.builder().set("key2", "google").build()).src(srcConnectionPoint3).dst(dstConnectionPoint4).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    labelList1.add(labelResource1);
    labelList1.add(labelResource2);
    labelList2.add(labelResource3);
    labelList2.add(labelResource4);
    // Create pceccTunnelInfo1
    List<LspLocalLabelInfo> lspLocalLabelInfoList1 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId1;
    DeviceId deviceId1 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId1 = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId1 = LabelResourceId.labelResourceId(2);
    LspLocalLabelInfo lspLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).build();
    lspLocalLabelInfoList1.add(lspLocalLabel1);
    pceccTunnelInfo1 = DefaultPceccTunnelInfo.builder().lspLocalLabelInfoList(lspLocalLabelInfoList1).build();
    // Create pceccTunnelInfo2
    List<LspLocalLabelInfo> lspLocalLabelInfoList2 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId2;
    DeviceId deviceId2 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId2 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId2 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel2 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId2).inLabelId(inLabelId2).outLabelId(outLabelId2).build();
    lspLocalLabelInfoList2.add(lspLocalLabel2);
    pceccTunnelInfo2 = DefaultPceccTunnelInfo.builder().lspLocalLabelInfoList(lspLocalLabelInfoList2).build();
}
#method_after
@Before
public void setUp() throws Exception {
    distrPceStore = new DistributedPceStore();
    // Initialization of member variables
    link1 = DefaultLink.builder().providerId(new ProviderId("eth", "1")).annotations(DefaultAnnotations.builder().set("key1", "yahoo").build()).src(srcConnectionPoint1).dst(dstConnectionPoint2).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    link2 = DefaultLink.builder().providerId(new ProviderId("mac", "2")).annotations(DefaultAnnotations.builder().set("key2", "google").build()).src(srcConnectionPoint3).dst(dstConnectionPoint4).type(Link.Type.DIRECT).state(Link.State.ACTIVE).build();
    labelList1.add(labelResource1);
    labelList1.add(labelResource2);
    labelList2.add(labelResource3);
    labelList2.add(labelResource4);
    // Create pceccTunnelInfo1
    List<LspLocalLabelInfo> lspLocalLabelInfoList1 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId1 = TunnelConsumerId.valueOf(10);
    DeviceId deviceId1 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId1 = LabelResourceId.labelResourceId(1);
    LabelResourceId outLabelId1 = LabelResourceId.labelResourceId(2);
    LspLocalLabelInfo lspLocalLabel1 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId1).inLabelId(inLabelId1).outLabelId(outLabelId1).build();
    lspLocalLabelInfoList1.add(lspLocalLabel1);
    pceccTunnelInfo1 = new PceccTunnelInfo(lspLocalLabelInfoList1, tunnelConsumerId1);
    // Create pceccTunnelInfo2
    List<LspLocalLabelInfo> lspLocalLabelInfoList2 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId2 = TunnelConsumerId.valueOf(20);
    DeviceId deviceId2 = DeviceId.deviceId("foo");
    LabelResourceId inLabelId2 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId2 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel2 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId2).inLabelId(inLabelId2).outLabelId(outLabelId2).build();
    lspLocalLabelInfoList2.add(lspLocalLabel2);
    pceccTunnelInfo2 = new PceccTunnelInfo(lspLocalLabelInfoList2, tunnelConsumerId2);
}
#end_block

#method_before
@Test
public void testAddGlobalNodeLabel() {
    // initialization
    distrPceStore.storageService = new TestStorageService();
    distrPceStore.activate();
    // add device with label
    assertThat(distrPceStore.addGlobalNodeLabel(deviceId1, labelId1), is(true));
    assertThat(distrPceStore.addGlobalNodeLabel(deviceId2, labelId2), is(true));
}
#method_after
@Test
public void testAddGlobalNodeLabel() {
    // initialization
    distrPceStore.storageService = new TestStorageService();
    distrPceStore.activate();
    // add device with label
    distrPceStore.addGlobalNodeLabel(deviceId1, labelId1);
    assertThat(distrPceStore.existsGlobalNodeLabel(deviceId1), is(true));
    assertThat(distrPceStore.getGlobalNodeLabel(deviceId1), is(labelId1));
    distrPceStore.addGlobalNodeLabel(deviceId2, labelId2);
    assertThat(distrPceStore.existsGlobalNodeLabel(deviceId2), is(true));
    assertThat(distrPceStore.getGlobalNodeLabel(deviceId2), is(labelId2));
}
#end_block

#method_before
@Test
public void testAddAdjLabel() {
    // initialization
    distrPceStore.storageService = new TestStorageService();
    distrPceStore.activate();
    // link with list of labels
    assertThat(distrPceStore.addAdjLabel(link1, labelId1), is(true));
    assertThat(distrPceStore.addAdjLabel(link2, labelId2), is(true));
}
#method_after
@Test
public void testAddAdjLabel() {
    // initialization
    distrPceStore.storageService = new TestStorageService();
    distrPceStore.activate();
    // link with list of labels
    distrPceStore.addAdjLabel(link1, labelId1);
    assertThat(distrPceStore.existsAdjLabel(link1), is(true));
    assertThat(distrPceStore.getAdjLabel(link1), is(labelId1));
    distrPceStore.addAdjLabel(link2, labelId2);
    assertThat(distrPceStore.existsAdjLabel(link2), is(true));
    assertThat(distrPceStore.getAdjLabel(link2), is(labelId2));
}
#end_block

#method_before
@Test
public void testAddTunnelInfo() {
    // initialization
    distrPceStore.storageService = new TestStorageService();
    distrPceStore.activate();
    // TunnelId with device label store information
    assertThat(distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1), is(true));
    assertThat(distrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2), is(true));
}
#method_after
@Test
public void testAddTunnelInfo() {
    // initialization
    distrPceStore.storageService = new TestStorageService();
    distrPceStore.activate();
    // TunnelId with device label store information
    distrPceStore.addTunnelInfo(tunnelId1, pceccTunnelInfo1);
    assertThat(distrPceStore.existsTunnelInfo(tunnelId1), is(true));
    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));
    distrPceStore.addTunnelInfo(tunnelId2, pceccTunnelInfo2);
    assertThat(distrPceStore.existsTunnelInfo(tunnelId2), is(true));
    assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));
}
#end_block

#method_before
@Test
public void testGetGlobalNodeLabel() {
    testAddGlobalNodeLabel();
    // deviceId1 with labelId1
    assertThat(deviceId1, is(notNullValue()));
    assertThat(distrPceStore.getGlobalNodeLabel(deviceId1).value(), is(labelId1));
    // deviceId2 with labelId2
    assertThat(deviceId2, is(notNullValue()));
    assertThat(distrPceStore.getGlobalNodeLabel(deviceId2).value(), is(labelId2));
}
#method_after
@Test
public void testGetGlobalNodeLabel() {
    testAddGlobalNodeLabel();
    // deviceId1 with labelId1
    assertThat(deviceId1, is(notNullValue()));
    assertThat(distrPceStore.getGlobalNodeLabel(deviceId1), is(labelId1));
    // deviceId2 with labelId2
    assertThat(deviceId2, is(notNullValue()));
    assertThat(distrPceStore.getGlobalNodeLabel(deviceId2), is(labelId2));
}
#end_block

#method_before
@Test
public void testGetAdjLabel() {
    testAddAdjLabel();
    // link1 with labels
    assertThat(link1, is(notNullValue()));
    assertThat(distrPceStore.getAdjLabel(link1).value(), is(labelId1));
    // link2 with labels
    assertThat(link2, is(notNullValue()));
    assertThat(distrPceStore.getAdjLabel(link2).value(), is(labelId2));
}
#method_after
@Test
public void testGetAdjLabel() {
    testAddAdjLabel();
    // link1 with labels
    assertThat(link1, is(notNullValue()));
    assertThat(distrPceStore.getAdjLabel(link1), is(labelId1));
    // link2 with labels
    assertThat(link2, is(notNullValue()));
    assertThat(distrPceStore.getAdjLabel(link2), is(labelId2));
}
#end_block

#method_before
@Test
public void testGetTunnelInfo() {
    testAddTunnelInfo();
    // tunnelId1 with device label store info
    assertThat(tunnelId1, is(notNullValue()));
    assertThat(distrPceStore.getTunnelInfo(tunnelId1).value(), is(pceccTunnelInfo1));
    // tunnelId2 with device label store info
    assertThat(tunnelId2, is(notNullValue()));
    assertThat(distrPceStore.getTunnelInfo(tunnelId2).value(), is(pceccTunnelInfo2));
}
#method_after
@Test
public void testGetTunnelInfo() {
    testAddTunnelInfo();
    // tunnelId1 with device label store info
    assertThat(tunnelId1, is(notNullValue()));
    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo1));
    // tunnelId2 with device label store info
    assertThat(tunnelId2, is(notNullValue()));
    assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo2));
}
#end_block

#method_before
@Test
public void testUpdateTunnelInfo() {
    // add tunnel info
    testAddTunnelInfo();
    // new updates
    // Create pceccTunnelInfo3
    List<LspLocalLabelInfo> lspLocalLabelInfoList3 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId3;
    DeviceId deviceId3 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId3 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId3 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel3 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId3).inLabelId(inLabelId3).outLabelId(outLabelId3).build();
    lspLocalLabelInfoList3.add(lspLocalLabel3);
    PceccTunnelInfo pceccTunnelInfo3 = DefaultPceccTunnelInfo.builder().lspLocalLabelInfoList(lspLocalLabelInfoList3).build();
    // Create pceccTunnelInfo4
    List<LspLocalLabelInfo> lspLocalLabelInfoList4 = new LinkedList<>();
    // TODO: need to uncomment below line once TunnelConsumerId is ready
    // TunnelConsumerId tunnelConsumerId4;
    DeviceId deviceId4 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId4 = LabelResourceId.labelResourceId(4);
    LabelResourceId outLabelId4 = LabelResourceId.labelResourceId(5);
    LspLocalLabelInfo lspLocalLabel4 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId4).inLabelId(inLabelId4).outLabelId(outLabelId4).build();
    lspLocalLabelInfoList4.add(lspLocalLabel4);
    PceccTunnelInfo pceccTunnelInfo4 = DefaultPceccTunnelInfo.builder().lspLocalLabelInfoList(lspLocalLabelInfoList4).build();
    assertThat(distrPceStore.updateTunnelInfo(tunnelId1, pceccTunnelInfo3), is(true));
    assertThat(distrPceStore.updateTunnelInfo(tunnelId2, pceccTunnelInfo4), is(true));
}
#method_after
@Test
public void testUpdateTunnelInfo() {
    // add tunnel info
    testAddTunnelInfo();
    // new updates
    // Create pceccTunnelInfo3
    List<LspLocalLabelInfo> lspLocalLabelInfoList3 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId3 = TunnelConsumerId.valueOf(30);
    DeviceId deviceId3 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId3 = LabelResourceId.labelResourceId(3);
    LabelResourceId outLabelId3 = LabelResourceId.labelResourceId(4);
    LspLocalLabelInfo lspLocalLabel3 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId3).inLabelId(inLabelId3).outLabelId(outLabelId3).build();
    lspLocalLabelInfoList3.add(lspLocalLabel3);
    PceccTunnelInfo pceccTunnelInfo3 = new PceccTunnelInfo(lspLocalLabelInfoList3, tunnelConsumerId3);
    // Create pceccTunnelInfo4
    List<LspLocalLabelInfo> lspLocalLabelInfoList4 = new LinkedList<>();
    ResourceConsumer tunnelConsumerId4 = TunnelConsumerId.valueOf(40);
    DeviceId deviceId4 = DeviceId.deviceId("goo");
    LabelResourceId inLabelId4 = LabelResourceId.labelResourceId(4);
    LabelResourceId outLabelId4 = LabelResourceId.labelResourceId(5);
    LspLocalLabelInfo lspLocalLabel4 = DefaultLspLocalLabelInfo.builder().deviceId(deviceId4).inLabelId(inLabelId4).outLabelId(outLabelId4).build();
    lspLocalLabelInfoList4.add(lspLocalLabel4);
    PceccTunnelInfo pceccTunnelInfo4 = new PceccTunnelInfo(lspLocalLabelInfoList4, tunnelConsumerId4);
    // update only lspLocalLabelInfoList
    assertThat(distrPceStore.updateTunnelInfo(tunnelId1, lspLocalLabelInfoList3), is(true));
    assertThat(distrPceStore.updateTunnelInfo(tunnelId2, lspLocalLabelInfoList4), is(true));
    // update only tunnelConsumerId
    assertThat(distrPceStore.updateTunnelInfo(tunnelId1, tunnelConsumerId3), is(true));
    assertThat(distrPceStore.updateTunnelInfo(tunnelId2, tunnelConsumerId4), is(true));
    assertThat(distrPceStore.getTunnelInfo(tunnelId1), is(pceccTunnelInfo3));
    assertThat(distrPceStore.getTunnelInfo(tunnelId2), is(pceccTunnelInfo4));
}
#end_block

#method_before
private void pushGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId, IpPrefix ipPrefix, Objective.Operation type, boolean isBos) throws PcepParseException {
    checkNotNull(deviceId);
    checkNotNull(labelId);
    checkNotNull(ipPrefix);
    checkNotNull(type);
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client not found");
        return;
    }
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    PcepFecObjectIPv4 fecObject = pc.factory().buildFecObjectIpv4().setNodeID(ipPrefix.address().getIp4Address().toInt()).build();
    boolean bSFlag = false;
    if (pc.labelDbSyncStatus() == IN_SYNC) {
        if (isBos) {
            pc.setLabelDbSyncStatus(SYNCED);
        // Need to send end of label DB END OF sync msg, i.e. S flag in SRP id is reset.
        } else {
            bSFlag = true;
        }
    }
    PcepSrpObject srpObj = getSrpObject(pc, type, bSFlag);
    // Global NODE-SID as label object
    PcepLabelObject labelObject = pc.factory().buildLabelObject().setLabel((int) labelId.labelId()).build();
    PcepLabelMap labelMap = new PcepLabelMap();
    labelMap.setFecObject(fecObject);
    labelMap.setLabelObject(labelObject);
    labelMap.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelMap(labelMap).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
}
#method_after
private void pushGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId, IpPrefix ipPrefix, Objective.Operation type, boolean isBos) throws PcepParseException {
    checkNotNull(deviceId);
    checkNotNull(labelId);
    checkNotNull(ipPrefix);
    checkNotNull(type);
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client not found");
        return;
    }
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    PcepFecObjectIPv4 fecObject = pc.factory().buildFecObjectIpv4().setNodeID(ipPrefix.address().getIp4Address().toInt()).build();
    boolean bSFlag = false;
    if (pc.labelDbSyncStatus() == IN_SYNC) {
        if (isBos) {
            /*
                 * Now the sync is completed.
                 * Need to send label DB end-of-sync msg, i.e. S flag in SRP id is reset.
                 */
            pc.setLabelDbSyncStatus(SYNCED);
        } else {
            bSFlag = true;
        }
    }
    PcepSrpObject srpObj = getSrpObject(pc, type, bSFlag);
    // Global NODE-SID as label object
    PcepLabelObject labelObject = pc.factory().buildLabelObject().setLabel((int) labelId.labelId()).build();
    PcepLabelMap labelMap = new PcepLabelMap();
    labelMap.setFecObject(fecObject);
    labelMap.setLabelObject(labelObject);
    labelMap.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelMap(labelMap).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
}
#end_block

#method_before
@Activate
protected void activate() {
    deviceService = opticalView(deviceService);
    appId = coreService.registerApplication("org.onosproject.newoptical");
    idCounter = storageService.atomicCounterBuilder().withName(OPTICAL_CONNECTIVITY_ID_COUNTER).withMeteringDisabled().build().asAtomicCounter();
    eventDispatcher.addSink(OpticalPathEvent.class, listenerRegistry);
    linkService.addListener(linkListener);
    intentService.addListener(intentListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    deviceService = opticalView(deviceService);
    appId = coreService.registerApplication("org.onosproject.newoptical");
    idCounter = storageService.atomicCounterBuilder().withName(OPTICAL_CONNECTIVITY_ID_COUNTER).withMeteringDisabled().build().asAtomicCounter();
    eventDispatcher.addSink(OpticalPathEvent.class, listenerRegistry);
    listeners = new ListenerTracker();
    listeners.addListener(linkService, new InternalLinkListener()).addListener(intentService, new InternalIntentListener());
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    intentService.removeListener(intentListener);
    linkService.removeListener(linkListener);
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    listeners.removeListeners();
    eventDispatcher.removeSink(OpticalPathEvent.class);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public OpticalConnectivityId setupConnectivity(ConnectPoint ingress, ConnectPoint egress, Bandwidth bandwidth, Duration latency) {
    checkNotNull(ingress);
    checkNotNull(egress);
    log.info("setupConnectivity({}, {}, {}, {})", ingress, egress, bandwidth, latency);
    bandwidth = (bandwidth == null) ? Bandwidth.bps(0) : bandwidth;
    Set<Path> paths = pathService.getPaths(ingress.deviceId(), egress.deviceId(), new BandwidthLinkWeight(bandwidth));
    if (paths.isEmpty()) {
        log.warn("Unable to find multi-layer path.");
        return null;
    }
    // Search path with available cross connect points
    for (Path path : paths) {
        OpticalConnectivityId id = setupPath(path, bandwidth, latency);
        if (id != null) {
            log.info("Assigned OpticalConnectivityId: {}", id);
            return id;
        }
    }
    return null;
}
#method_after
@Override
public OpticalConnectivityId setupConnectivity(ConnectPoint ingress, ConnectPoint egress, Bandwidth bandwidth, Duration latency) {
    checkNotNull(ingress);
    checkNotNull(egress);
    log.info("setupConnectivity({}, {}, {}, {})", ingress, egress, bandwidth, latency);
    bandwidth = (bandwidth == null) ? Bandwidth.bps(0) : bandwidth;
    Set<Path> paths = pathService.getPaths(ingress.deviceId(), egress.deviceId(), new BandwidthLinkWeight(bandwidth));
    if (paths.isEmpty()) {
        log.warn("Unable to find multi-layer path.");
        return null;
    }
    // Search path with available cross connect points
    for (Path path : paths) {
        OpticalConnectivityId id = setupPath(path, bandwidth, latency);
        if (id != null) {
            log.info("Assigned OpticalConnectivityId: {}", id);
            return id;
        }
    }
    log.info("setupConnectivity({}, {}, {}, {}) failed.", ingress, egress, bandwidth, latency);
    return null;
}
#end_block

#method_before
@Override
public OpticalConnectivityId setupPath(Path path, Bandwidth bandwidth, Duration latency) {
    checkNotNull(path);
    log.info("setupPath({}, {}, {})", path, bandwidth, latency);
    // validate optical path
    List<Pair<ConnectPoint, ConnectPoint>> xcPointPairs = getCrossConnectPoints(path);
    if (!checkXcPoints(xcPointPairs)) {
        // Can't setup path if cross connect points are mismatched
        return null;
    }
    OpticalConnectivity connectivity = createConnectivity(path, bandwidth, latency);
    // create intents from cross connect points and set connectivity information
    List<Intent> intents = createIntents(xcPointPairs, connectivity);
    // store cross connect port usage
    path.links().stream().filter(this::isCrossConnectLink).forEach(usedCrossConnectLinks::add);
    // Submit the intents
    for (Intent i : intents) {
        intentService.submit(i);
        log.debug("Submitted an intent: {}", i);
    }
    return connectivity.id();
}
#method_after
@Override
public OpticalConnectivityId setupPath(Path path, Bandwidth bandwidth, Duration latency) {
    checkNotNull(path);
    log.info("setupPath({}, {}, {})", path, bandwidth, latency);
    // validate optical path
    List<Pair<ConnectPoint, ConnectPoint>> xcPointPairs = getCrossConnectPoints(path);
    if (!checkXcPoints(xcPointPairs)) {
        // Can't setup path if cross connect points are mismatched
        log.error("Failed to setup path because of mismatched cross connect points.");
        return null;
    }
    OpticalConnectivity connectivity = createConnectivity(path, bandwidth, latency);
    // create intents from cross connect points and set connectivity information
    List<Intent> intents = createIntents(xcPointPairs, connectivity);
    // store cross connect port usage
    path.links().stream().filter(this::isCrossConnectLink).forEach(usedCrossConnectLinks::add);
    // Submit the intents
    for (Intent i : intents) {
        intentService.submit(i);
        log.debug("Submitted an intent: {}", i);
    }
    return connectivity.id();
}
#end_block

#method_before
private OpticalConnectivity createConnectivity(Path path, Bandwidth bandwidth, Duration latency) {
    OpticalConnectivityId id = OpticalConnectivityId.valueOf(idCounter.getAndIncrement());
    OpticalConnectivity connectivity = new OpticalConnectivity(id, path, bandwidth, latency);
    ConnectPoint ingress = path.src();
    ConnectPoint egress = path.dst();
    Intent pktIntent = PointToPointIntent.builder().appId(appId).ingressPoint(ingress).egressPoint(egress).key(Key.of(id.id(), appId)).build();
    connectivity.setIntentId(pktIntent.id());
    // store connectivity information
    connectivities.put(connectivity.id(), connectivity);
    return connectivity;
}
#method_after
private OpticalConnectivity createConnectivity(Path path, Bandwidth bandwidth, Duration latency) {
    OpticalConnectivityId id = OpticalConnectivityId.of(idCounter.getAndIncrement());
    OpticalConnectivity connectivity = new OpticalConnectivity(id, path, bandwidth, latency);
    // store connectivity information
    connectivities.put(connectivity.id(), connectivity);
    return connectivity;
}
#end_block

#method_before
@Override
public boolean removeConnectivity(OpticalConnectivityId id) {
    log.info("removeConnectivity({})", id);
    OpticalConnectivity connectivity = connectivities.remove(id);
    if (connectivity == null) {
        return false;
    }
    // TODO withdraw intent only if all of connectivities that use the optical path are withdrawn
    connectivity.getRealizingLinks().forEach(l -> {
        Intent intent = intentService.getIntent(l.realizingIntentKey());
        intentService.withdraw(intent);
    });
    return true;
}
#method_after
@Override
public boolean removeConnectivity(OpticalConnectivityId id) {
    log.info("removeConnectivity({})", id);
    OpticalConnectivity connectivity = connectivities.remove(id);
    if (connectivity == null) {
        log.info("OpticalConnectivity with id {} not found.", id);
        return false;
    }
    // TODO withdraw intent only if all of connectivities that use the optical path are withdrawn
    connectivity.getRealizingLinks().forEach(l -> {
        Intent intent = intentService.getIntent(l.realizingIntentKey());
        intentService.withdraw(intent);
    });
    return true;
}
#end_block

#method_before
@Override
public List<Link> getPath(OpticalConnectivityId id) {
    OpticalConnectivity connectivity = connectivities.get(id);
    if (connectivity == null) {
        return null;
    }
    return ImmutableList.copyOf(connectivity.links());
}
#method_after
@Override
public Optional<List<Link>> getPath(OpticalConnectivityId id) {
    OpticalConnectivity connectivity = connectivities.get(id);
    if (connectivity == null) {
        log.info("OpticalConnectivity with id {} not found.", id);
        return Optional.empty();
    }
    return Optional.of(ImmutableList.copyOf(connectivity.links()));
}
#end_block

#method_before
private boolean checkXcPoints(List<Pair<ConnectPoint, ConnectPoint>> xcPointPairs) {
    checkArgument(xcPointPairs.size() % 2 == 0);
    Iterator<Pair<ConnectPoint, ConnectPoint>> itr = xcPointPairs.iterator();
    while (itr.hasNext()) {
        // checkArgument at start ensures we'll always have pairs of connect points
        Pair<ConnectPoint, ConnectPoint> src = itr.next();
        Pair<ConnectPoint, ConnectPoint> dst = itr.next();
        Device.Type srcType = deviceService.getDevice(src.getKey().deviceId()).type();
        Device.Type dstType = deviceService.getDevice(dst.getKey().deviceId()).type();
        // Only support connections between identical port types
        if (srcType != dstType) {
            log.warn("Unsupported mix of cross connect points");
            return false;
        }
    }
    return true;
}
#method_after
private boolean checkXcPoints(List<Pair<ConnectPoint, ConnectPoint>> xcPointPairs) {
    checkArgument(xcPointPairs.size() % 2 == 0);
    Iterator<Pair<ConnectPoint, ConnectPoint>> itr = xcPointPairs.iterator();
    while (itr.hasNext()) {
        // checkArgument at start ensures we'll always have pairs of connect points
        Pair<ConnectPoint, ConnectPoint> src = itr.next();
        Pair<ConnectPoint, ConnectPoint> dst = itr.next();
        Device.Type srcType = deviceService.getDevice(src.getKey().deviceId()).type();
        Device.Type dstType = deviceService.getDevice(dst.getKey().deviceId()).type();
        // Only support connections between identical port types
        if (srcType != dstType) {
            log.warn("Unsupported mix of cross connect points : {}, {}", srcType, dstType);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void updateBandwidthUsage(OpticalConnectivity connectivity) {
    IntentId intentId = connectivity.getIntentId();
    if (intentId == null) {
        return;
    }
    List<Link> links = connectivity.links();
    List<Resource> resources = links.stream().flatMap(l -> Stream.of(l.src(), l.dst())).filter(cp -> !isTransportLayer(deviceService.getDevice(cp.deviceId()).type())).map(cp -> Resources.continuous(cp.deviceId(), cp.port(), Bandwidth.class).resource(connectivity.bandwidth().bps())).collect(Collectors.toList());
    log.debug("allocating bandwidth for {} : {}", connectivity.getIntentId(), resources);
    List<ResourceAllocation> allocations = resourceService.allocate(intentId, resources);
    if (allocations.isEmpty()) {
        log.warn("Failed to allocate bandwidth {} to {}", connectivity.bandwidth().bps(), resources);
    // TODO any recovery?
    }
    log.debug("Done allocating bandwidth for {}", connectivity.getIntentId());
}
#method_after
private void updateBandwidthUsage(OpticalConnectivity connectivity) {
    OpticalConnectivityId connectivityId = connectivity.id();
    List<Link> links = connectivity.links();
    List<Resource> resources = links.stream().flatMap(l -> Stream.of(l.src(), l.dst())).filter(cp -> !isTransportLayer(deviceService.getDevice(cp.deviceId()).type())).map(cp -> Resources.continuous(cp.deviceId(), cp.port(), Bandwidth.class).resource(connectivity.bandwidth().bps())).collect(Collectors.toList());
    log.debug("allocating bandwidth for {} : {}", connectivityId, resources);
    List<ResourceAllocation> allocations = resourceService.allocate(connectivityId, resources);
    if (allocations.isEmpty()) {
        log.warn("Failed to allocate bandwidth {} to {}", connectivity.bandwidth().bps(), resources);
    // TODO any recovery?
    }
    log.debug("Done allocating bandwidth for {}", connectivityId);
}
#end_block

#method_before
private void releaseBandwidthUsage(OpticalConnectivity connectivity) {
    IntentId intentId = connectivity.getIntentId();
    if (intentId == null) {
        return;
    }
    log.debug("releasing bandwidth allocated to {}", connectivity.getIntentId());
    if (!resourceService.release(connectivity.getIntentId())) {
        log.warn("Failed to release bandwidth allocated to {}", connectivity.getIntentId());
    // TODO any recovery?
    }
    log.debug("DONE releasing bandwidth for {}", connectivity.getIntentId());
}
#method_after
private void releaseBandwidthUsage(OpticalConnectivity connectivity) {
    OpticalConnectivityId connectivityId = connectivity.id();
    log.debug("releasing bandwidth allocated to {}", connectivityId);
    if (!resourceService.release(connectivityId)) {
        log.warn("Failed to release bandwidth allocated to {}", connectivityId);
    // TODO any recovery?
    }
    log.debug("DONE releasing bandwidth for {}", connectivityId);
}
#end_block

#method_before
@Override
public double weight(TopologyEdge edge) {
    Link l = edge.link();
    // Ignore inactive links
    if (l.state() == Link.State.INACTIVE) {
        return -1.0;
    }
    // Ignore cross connect links with used ports
    if (isCrossConnectLink(l) && usedCrossConnectLinks.contains(l)) {
        return -1.0;
    }
    // Check availability of bandwidth
    if (bandwidth != null) {
        if (hasEnoughBandwidth(l.src()) && hasEnoughBandwidth(l.dst())) {
            return 1.0;
        } else {
            return -1.0;
        }
    } else {
        // TODO needs to differentiate optical and packet?
        if (l.type() == Link.Type.OPTICAL) {
            // Transport links
            return 1.0;
        } else {
            // Packet links
            return 1.0;
        }
    }
}
#method_after
@Override
public double weight(TopologyEdge edge) {
    Link l = edge.link();
    // Avoid inactive links
    if (l.state() == Link.State.INACTIVE) {
        return -1.0;
    }
    // Avoid cross connect links with used ports
    if (isCrossConnectLink(l) && usedCrossConnectLinks.contains(l)) {
        return -1.0;
    }
    // Check availability of bandwidth
    if (bandwidth != null) {
        if (hasEnoughBandwidth(l.src()) && hasEnoughBandwidth(l.dst())) {
            return 1.0;
        } else {
            return -1.0;
        }
    } else {
        // TODO needs to differentiate optical and packet?
        if (l.type() == Link.Type.OPTICAL) {
            // Transport links
            return 1.0;
        } else {
            // Packet links
            return 1.0;
        }
    }
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    switch(event.type()) {
        case LINK_REMOVED:
            Link link = event.subject();
            Set<PacketLinkRealizedByOptical> pLinks = linkPathMap.keySet().stream().filter(l -> l.equals(link.src(), link.dst()) || l.equals(link.dst(), link.src())).collect(Collectors.toSet());
            pLinks.forEach(l -> {
                OpticalConnectivity c = linkPathMap.get(l);
                // Notifies listeners if all links are gone
                if (c.isAllRealizingLinkNotEstablished()) {
                    post(new OpticalPathEvent(OpticalPathEvent.Type.PATH_REMOVED, c.id()));
                }
                linkPathMap.remove(l);
            });
        default:
            break;
    }
}
#method_after
@Override
public void event(LinkEvent event) {
    switch(event.type()) {
        case LINK_REMOVED:
            Link link = event.subject();
            Set<PacketLinkRealizedByOptical> pLinks = linkPathMap.keySet().stream().filter(l -> l.isBetween(link.src(), link.dst()) || l.isBetween(link.dst(), link.src())).collect(Collectors.toSet());
            pLinks.forEach(l -> {
                OpticalConnectivity c = linkPathMap.get(l);
                // Notifies listeners if all links are gone
                if (c.isAllRealizingLinkNotEstablished()) {
                    post(new OpticalPathEvent(OpticalPathEvent.Type.PATH_REMOVED, c.id()));
                }
                linkPathMap.remove(l);
            });
        default:
            break;
    }
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    eventDispatcher.removeSink(OpticalPathEvent.class);
    listeners.removeListeners();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    listeners.removeListeners();
    eventDispatcher.removeSink(OpticalPathEvent.class);
    log.info("Stopped");
}
#end_block

#method_before
private OpticalConnectivity createConnectivity(Path path, Bandwidth bandwidth, Duration latency) {
    OpticalConnectivityId id = OpticalConnectivityId.valueOf(idCounter.getAndIncrement());
    OpticalConnectivity connectivity = new OpticalConnectivity(id, path, bandwidth, latency);
    ConnectPoint ingress = path.src();
    ConnectPoint egress = path.dst();
    Intent pktIntent = PointToPointIntent.builder().appId(appId).ingressPoint(ingress).egressPoint(egress).key(Key.of(id.id(), appId)).build();
    connectivity.setIntentId(pktIntent.id());
    // store connectivity information
    connectivities.put(connectivity.id(), connectivity);
    return connectivity;
}
#method_after
private OpticalConnectivity createConnectivity(Path path, Bandwidth bandwidth, Duration latency) {
    OpticalConnectivityId id = OpticalConnectivityId.of(idCounter.getAndIncrement());
    OpticalConnectivity connectivity = new OpticalConnectivity(id, path, bandwidth, latency);
    ConnectPoint ingress = path.src();
    ConnectPoint egress = path.dst();
    Intent pktIntent = PointToPointIntent.builder().appId(appId).ingressPoint(ingress).egressPoint(egress).key(Key.of(id.id(), appId)).build();
    connectivity.setIntentId(pktIntent.id());
    // store connectivity information
    connectivities.put(connectivity.id(), connectivity);
    return connectivity;
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    switch(event.type()) {
        case LINK_REMOVED:
            Link link = event.subject();
            Set<PacketLinkRealizedByOptical> pLinks = linkPathMap.keySet().stream().filter(l -> l.equals(link.src(), link.dst()) || l.equals(link.dst(), link.src())).collect(Collectors.toSet());
            pLinks.forEach(l -> {
                OpticalConnectivity c = linkPathMap.get(l);
                // Notifies listeners if all links are gone
                if (c.isAllRealizingLinkNotEstablished()) {
                    post(new OpticalPathEvent(OpticalPathEvent.Type.PATH_REMOVED, c.id()));
                }
                linkPathMap.remove(l);
            });
        default:
            break;
    }
}
#method_after
@Override
public void event(LinkEvent event) {
    switch(event.type()) {
        case LINK_REMOVED:
            Link link = event.subject();
            Set<PacketLinkRealizedByOptical> pLinks = linkPathMap.keySet().stream().filter(l -> l.isBetween(link.src(), link.dst()) || l.isBetween(link.dst(), link.src())).collect(Collectors.toSet());
            pLinks.forEach(l -> {
                OpticalConnectivity c = linkPathMap.get(l);
                // Notifies listeners if all links are gone
                if (c.isAllRealizingLinkNotEstablished()) {
                    post(new OpticalPathEvent(OpticalPathEvent.Type.PATH_REMOVED, c.id()));
                }
                linkPathMap.remove(l);
            });
        default:
            break;
    }
}
#end_block

#method_before
public void setLinkEstablished(ConnectPoint src, ConnectPoint dst) {
    realizingLinks.stream().filter(l -> l.equals(src, dst)).findAny().ifPresent(l -> l.setEstablished(true));
}
#method_after
public void setLinkEstablished(ConnectPoint src, ConnectPoint dst) {
    realizingLinks.stream().filter(l -> l.isBetween(src, dst)).findAny().ifPresent(l -> l.setEstablished(true));
}
#end_block

#method_before
public void setLinkRemoved(ConnectPoint src, ConnectPoint dst) {
    realizingLinks.stream().filter(l -> l.equals(src, dst)).findAny().ifPresent(l -> l.setEstablished(false));
}
#method_after
public void setLinkRemoved(ConnectPoint src, ConnectPoint dst) {
    realizingLinks.stream().filter(l -> l.isBetween(src, dst)).findAny().ifPresent(l -> l.setEstablished(false));
}
#end_block

#method_before
@Override
protected void execute() {
    OpticalPathService opticalPathService = get(OpticalPathService.class);
    OpticalConnectivityId id = OpticalConnectivityId.valueOf(Long.valueOf(idStr));
    print("Trying to remove connectivity with id %s.", idStr);
    if (opticalPathService.removeConnectivity(id)) {
        print(" -- success");
    } else {
        print(" -- failed");
    }
}
#method_after
@Override
protected void execute() {
    OpticalPathService opticalPathService = get(OpticalPathService.class);
    OpticalConnectivityId id = OpticalConnectivityId.of(Long.valueOf(idStr));
    print("Trying to remove connectivity with id %s.", idStr);
    if (opticalPathService.removeConnectivity(id)) {
        print(" -- success");
    } else {
        print(" -- failed");
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(PCE_SERVICE_APP);
    log.info("Started");
    tunnelConsumerIdGen = coreService.getIdGenerator(TUNNEL_CONSUMER_ID_GEN_TOPIC);
    localLspIdIdGen = coreService.getIdGenerator(LOCAL_LSP_ID_GEN_TOPIC);
    localLspIdFreeList = storageService.<Short>setBuilder().withName("pcepLocalLspIdDeletedList").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(PCE_SERVICE_APP);
    log.info("Started");
    localLspIdIdGen = coreService.getIdGenerator(LOCAL_LSP_ID_GEN_TOPIC);
    localLspIdFreeList = storageService.<Short>setBuilder().withName("pcepLocalLspIdDeletedList").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
}
#end_block

#method_before
@Override
public boolean setupPath(DeviceId src, DeviceId dst, String tunnelName, List<Constraint> constraints, LspType lspType) {
    checkNotNull(src);
    checkNotNull(dst);
    checkNotNull(tunnelName);
    checkNotNull(lspType);
    return true;
}
#method_after
@Override
public boolean setupPath(DeviceId src, DeviceId dst, String tunnelName, List<Constraint> constraints, LspType lspType) {
    checkNotNull(src);
    checkNotNull(dst);
    checkNotNull(tunnelName);
    checkNotNull(constraints);
    checkNotNull(lspType);
    return true;
}
#end_block

#method_before
@Override
public boolean updatePath(TunnelId tunnelId, List<Constraint> constraints) {
    checkNotNull(tunnelId);
    return true;
}
#method_after
@Override
public boolean updatePath(TunnelId tunnelId, List<Constraint> constraints) {
    checkNotNull(tunnelId);
    checkNotNull(constraints);
    return true;
}
#end_block

#method_before
short getNextLocalLspId() {
    // If there is any free id use it. Otherwise generate new id.
    if (localLspIdFreeList.isEmpty()) {
        return (short) localLspIdIdGen.getNewId();
    }
    Iterator<Short> it = localLspIdFreeList.iterator();
    Short value = it.next();
    localLspIdFreeList.remove(value);
    return value;
}
#method_after
private short getNextLocalLspId() {
    // If there is any free id use it. Otherwise generate new id.
    if (localLspIdFreeList.isEmpty()) {
        return (short) localLspIdIdGen.getNewId();
    }
    Iterator<Short> it = localLspIdFreeList.iterator();
    Short value = it.next();
    localLspIdFreeList.remove(value);
    return value;
}
#end_block

#method_before
@Override
public void programExportPortArpClassifierRules(Port exportPort, DeviceId deviceId, Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(EtherType.ARP.ethType().toShort()).matchInPort(exportPort.number()).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.createOutput(PortNumber.CONTROLLER));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(L3_CLASSIFIER_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("PrivateArpRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("PrivateArpRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programExportPortArpClassifierRules(Port exportPort, DeviceId deviceId, Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(EtherType.ARP.ethType().toShort()).matchInPort(exportPort.number()).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.createOutput(PortNumber.CONTROLLER));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(L3_CLASSIFIER_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    classifierService = new ClassifierServiceImpl(appId);
    l2ForwardService = new L2ForwardServiceImpl(appId);
    arpService = new ArpServiceImpl(appId);
    l3ForwardService = new L3ForwardServiceImpl(appId);
    snatService = new SnatServiceImpl(appId);
    dnatService = new DnatServiceImpl(appId);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    vtnRscService.addListener(l3EventListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NetworkOfLocalHostPorts.class).register(TenantNetworkId.class).register(Host.class).register(TenantNetwork.class).register(TenantNetworkId.class).register(TenantId.class).register(SubnetId.class).register(VirtualPortId.class).register(VirtualPort.State.class).register(AllowedAddressPair.class).register(FixedIp.class).register(FloatingIp.class).register(FloatingIpId.class).register(FloatingIp.Status.class).register(UUID.class).register(DefaultFloatingIp.class).register(BindingHostId.class).register(SecurityGroup.class).register(IpAddress.class).register(DefaultVirtualPort.class).register(RouterId.class).register(TenantRouter.class);
    floatingIpStore = storageService.<IpAddress, FloatingIp>eventuallyConsistentMapBuilder().withName(FLOATINGSTORE).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    vPortStore = storageService.<VirtualPortId, VirtualPort>eventuallyConsistentMapBuilder().withName(VIRTUALPORT).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchesOfController = storageService.<IpAddress, Boolean>eventuallyConsistentMapBuilder().withName(SWITCHES_OF_CONTROLLER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchOfLocalHostPorts = storageService.<DeviceId, NetworkOfLocalHostPorts>eventuallyConsistentMapBuilder().withName(SWITCH_OF_LOCAL_HOST_PORTS).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    hostsOfSubnet = storageService.<SubnetId, Map<HostId, Host>>eventuallyConsistentMapBuilder().withName(HOSTS_OF_SUBNET).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    routerInfFlagOfTenantRouter = storageService.<TenantRouter, Boolean>eventuallyConsistentMapBuilder().withName(ROUTERINF_FLAG_OF_TENANTROUTER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    exPortOfDevice = storageService.<DeviceId, Port>eventuallyConsistentMapBuilder().withName(EX_PORT_OF_DEVICE).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    exPortMap = storageService.<String, String>consistentMapBuilder().withName(EX_PORT_MAP).withApplicationId(appId).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API))).build();
    packetService.addProcessor(arpProcessor, PacketProcessor.director(1));
    packetService.addProcessor(upstreamProcessor, PacketProcessor.director(0));
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    classifierService = new ClassifierServiceImpl(appId);
    l2ForwardService = new L2ForwardServiceImpl(appId);
    arpService = new ArpServiceImpl(appId);
    l3ForwardService = new L3ForwardServiceImpl(appId);
    snatService = new SnatServiceImpl(appId);
    dnatService = new DnatServiceImpl(appId);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    vtnRscService.addListener(l3EventListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(NetworkOfLocalHostPorts.class).register(TenantNetworkId.class).register(Host.class).register(TenantNetwork.class).register(TenantNetworkId.class).register(TenantId.class).register(SubnetId.class).register(VirtualPortId.class).register(VirtualPort.State.class).register(AllowedAddressPair.class).register(FixedIp.class).register(FloatingIp.class).register(FloatingIpId.class).register(FloatingIp.Status.class).register(UUID.class).register(DefaultFloatingIp.class).register(BindingHostId.class).register(SecurityGroup.class).register(IpAddress.class).register(DefaultVirtualPort.class).register(RouterId.class).register(TenantRouter.class);
    floatingIpStore = storageService.<IpAddress, FloatingIp>eventuallyConsistentMapBuilder().withName(FLOATINGSTORE).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    vPortStore = storageService.<VirtualPortId, VirtualPort>eventuallyConsistentMapBuilder().withName(VIRTUALPORT).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchesOfController = storageService.<IpAddress, Boolean>eventuallyConsistentMapBuilder().withName(SWITCHES_OF_CONTROLLER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    switchOfLocalHostPorts = storageService.<DeviceId, NetworkOfLocalHostPorts>eventuallyConsistentMapBuilder().withName(SWITCH_OF_LOCAL_HOST_PORTS).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    hostsOfSubnet = storageService.<SubnetId, Map<HostId, Host>>eventuallyConsistentMapBuilder().withName(HOSTS_OF_SUBNET).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    routerInfFlagOfTenantRouter = storageService.<TenantRouter, Boolean>eventuallyConsistentMapBuilder().withName(ROUTERINF_FLAG_OF_TENANTROUTER).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    exPortOfDevice = storageService.<DeviceId, Port>eventuallyConsistentMapBuilder().withName(EX_PORT_OF_DEVICE).withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    exPortMap = storageService.<String, String>consistentMapBuilder().withName(EX_PORT_MAP).withApplicationId(appId).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API))).build();
    packetService.addProcessor(l3PacketProcessor, PacketProcessor.director(0));
    log.info("Started");
}
#end_block

#method_before
@Override
public void programSnatSameSegmentRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, IpAddress dstIP, MacAddress ethDst, MacAddress ethSrc, IpAddress ipSrc, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, PREFIC_LENGTH)).matchIPDst(IpPrefix.valueOf(dstIP, PREFIC_LENGTH)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthDst(ethDst).setEthSrc(ethSrc).setIpSrc(ipSrc).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_SAME_SEG_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programSnatSameSegmentRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, IpAddress dstIP, MacAddress ethDst, MacAddress ethSrc, IpAddress ipSrc, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, PREFIC_LENGTH)).matchIPDst(IpPrefix.valueOf(dstIP, PREFIC_LENGTH)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthDst(ethDst).setEthSrc(ethSrc).setIpSrc(ipSrc).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_SAME_SEG_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Override
public void programSnatDiffSegmentRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, MacAddress ethDst, MacAddress ethSrc, IpAddress ipSrc, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, PREFIC_LENGTH)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthDst(ethDst).setEthSrc(ethSrc).setIpSrc(ipSrc).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_DIFF_SEG_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programSnatDiffSegmentRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, MacAddress ethDst, MacAddress ethSrc, IpAddress ipSrc, SegmentationId actionVni, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, PREFIC_LENGTH)).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.setEthDst(ethDst).setEthSrc(ethSrc).setIpSrc(ipSrc).setTunnelId(Long.parseLong(actionVni.segmentationId()));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_DIFF_SEG_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Override
public void programSnatSameSegmentUploadControllerRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, IpAddress dstIP, IpPrefix prefix, Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, PREFIC_LENGTH)).matchIPDst(IpPrefix.valueOf(dstIP, prefix.prefixLength())).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.createOutput(PortNumber.CONTROLLER));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_SAME_SEG_CON_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
@Override
public void programSnatSameSegmentUploadControllerRules(DeviceId deviceId, SegmentationId matchVni, IpAddress srcIP, IpAddress dstIP, IpPrefix prefix, Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(matchVni.segmentationId())).matchIPSrc(IpPrefix.valueOf(srcIP, PREFIC_LENGTH)).matchIPDst(IpPrefix.valueOf(dstIP, prefix.prefixLength())).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.createOutput(PortNumber.CONTROLLER));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(SNAT_SAME_SEG_CON_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Override
public void removeSnatRules(DeviceId deviceId, TrafficSelector selector, TrafficTreatment treatment, int priority, Objective.Operation type) {
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(priority);
    if (type.equals(Objective.Operation.ADD)) {
        log.debug("RouteRules-->ADD");
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        log.debug("RouteRules-->REMOVE");
        flowObjectiveService.forward(deviceId, objective.remove());
        log.info("rules remove in snat bob");
    }
}
#method_after
@Override
public void removeSnatRules(DeviceId deviceId, TrafficSelector selector, TrafficTreatment treatment, int priority, Objective.Operation type) {
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(priority);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#end_block

#method_before
@Override
public void handleMessage(PccId pccId, PcepMessage msg) {
    try {
        log.debug("tunnel provider handle message {}", msg.getType().toString());
        switch(msg.getType()) {
            case REPORT:
                int srpId = 0;
                LinkedList<PcepStateReport> llStateReportList = null;
                llStateReportList = ((PcepReportMsg) msg).getStateReportList();
                ListIterator<PcepStateReport> listIterator = llStateReportList.listIterator();
                PcepSrpObject srpObj = null;
                PcepLspObject lspObj = null;
                while (listIterator.hasNext()) {
                    PcepStateReport stateRpt = listIterator.next();
                    srpObj = stateRpt.getSrpObject();
                    lspObj = stateRpt.getLspObject();
                    if (srpObj instanceof PcepSrpObject) {
                        srpId = srpObj.getSrpID();
                    }
                    log.debug("Plsp ID in handle message " + lspObj.getPlspId());
                    log.debug("SRP ID in handle message " + srpId);
                    if (!(pcepTunnelApiMapper.checkFromTunnelRequestQueue(srpId))) {
                        // Check the sync status
                        if (lspObj.getSFlag()) {
                            if (pcepClientController.getClient(pccId).lspDbSyncStatus() != IN_SYNC) {
                                pcepClientController.getClient(pccId).setlspDbSyncStatus(IN_SYNC);
                                // On starting LSP-DB sync, store LSP DB locally for this PCC.
                                Map<TunnelId, Tunnel> preSyncLspDb = new HashMap<>();
                                Collection<Tunnel> queriedTunnels = tunnelService.queryTunnel(MPLS);
                                for (Tunnel tunnel : queriedTunnels) {
                                    if (((IpTunnelEndPoint) tunnel.src()).ip().equals(pccId.ipAddress())) {
                                        preSyncLspDb.put(tunnel.tunnelId(), tunnel);
                                    }
                                }
                                preSyncLspDbMap.put(pccId.ipAddress(), preSyncLspDb);
                                syncCompleteDeleteList.put(pccId.ipAddress(), new LinkedList<>());
                                syncCompleteUpdateList.put(pccId.ipAddress(), new LinkedList<>());
                            }
                            handleRptWithoutSrpId(stateRpt, pccId, IN_SYNC);
                            continue;
                        } else if (pcepClientController.getClient(pccId).lspDbSyncStatus() == IN_SYNC) {
                            // If sync flag is not set in the msg, and the
                            // previous state was "in sync" means this is
                            // end of sync message. PCRpt for end of sync
                            // does not carry any LSP report.
                            pcepClientController.getClient(pccId).setlspDbSyncStatus(SYNCED);
                            handleEndOfSyncAction(pccId);
                            continue;
                        }
                        // For PCRpt without matching SRP id not during LSPDB sync.
                        handleRptWithoutSrpId(stateRpt, pccId, SYNCED);
                        continue;
                    }
                    handleReportMessage(srpId, lspObj, stateRpt);
                }
                break;
            default:
                log.debug("Received unsupported message type {}", msg.getType().toString());
        }
    } catch (Exception e) {
        log.error("Exception occured while processing report message {}", e.getMessage());
    }
}
#method_after
@Override
public void handleMessage(PccId pccId, PcepMessage msg) {
    try {
        log.debug("tunnel provider handle message {}", msg.getType().toString());
        switch(msg.getType()) {
            case REPORT:
                int srpId = 0;
                LinkedList<PcepStateReport> llStateReportList = null;
                llStateReportList = ((PcepReportMsg) msg).getStateReportList();
                ListIterator<PcepStateReport> listIterator = llStateReportList.listIterator();
                PcepSrpObject srpObj = null;
                PcepLspObject lspObj = null;
                while (listIterator.hasNext()) {
                    PcepStateReport stateRpt = listIterator.next();
                    srpObj = stateRpt.getSrpObject();
                    lspObj = stateRpt.getLspObject();
                    if (srpObj instanceof PcepSrpObject) {
                        srpId = srpObj.getSrpID();
                    }
                    log.debug("Plsp ID in handle message " + lspObj.getPlspId());
                    log.debug("SRP ID in handle message " + srpId);
                    if (!(pcepTunnelApiMapper.checkFromTunnelRequestQueue(srpId))) {
                        // Check the sync status
                        if (lspObj.getSFlag()) {
                            if (pcepClientController.getClient(pccId).lspDbSyncStatus() != IN_SYNC) {
                                pcepClientController.getClient(pccId).setLspDbSyncStatus(IN_SYNC);
                                // On starting LSP-DB sync, store LSP DB locally for this PCC.
                                Map<TunnelId, Tunnel> preSyncLspDb = new HashMap<>();
                                Collection<Tunnel> queriedTunnels = tunnelService.queryTunnel(MPLS);
                                for (Tunnel tunnel : queriedTunnels) {
                                    if (((IpTunnelEndPoint) tunnel.src()).ip().equals(pccId.ipAddress())) {
                                        preSyncLspDb.put(tunnel.tunnelId(), tunnel);
                                    }
                                }
                                preSyncLspDbMap.put(pccId.ipAddress(), preSyncLspDb);
                                syncCompleteDeleteList.put(pccId.ipAddress(), new LinkedList<>());
                                syncCompleteUpdateList.put(pccId.ipAddress(), new LinkedList<>());
                            }
                            handleRptWithoutSrpId(stateRpt, pccId, IN_SYNC);
                            continue;
                        } else if (pcepClientController.getClient(pccId).lspDbSyncStatus() == IN_SYNC) {
                            // If sync flag is not set in the msg, and the
                            // previous state was "in sync" means this is
                            // end of sync message. PCRpt for end of sync
                            // does not carry any LSP report.
                            pcepClientController.getClient(pccId).setLspDbSyncStatus(SYNCED);
                            handleEndOfSyncAction(pccId);
                            continue;
                        }
                        // For PCRpt without matching SRP id not during LSPDB sync.
                        handleRptWithoutSrpId(stateRpt, pccId, SYNCED);
                        continue;
                    }
                    handleReportMessage(srpId, lspObj, stateRpt);
                }
                break;
            default:
                log.debug("Received unsupported message type {}", msg.getType().toString());
        }
    } catch (Exception e) {
        log.error("Exception occured while processing report message {}", e.getMessage());
    }
}
#end_block

#method_before
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId, PcepSyncStatus syncStatus) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    Path path = buildPathFromEroObj(eroObj, providerId);
    int bandwidth = 0;
    if (msgPath.getBandwidthObject() != null) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    /*
             * To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
             * from PCE.
             */
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = WITH_SIGNALLING;
    if (null != srpObj) {
        LinkedList<PcepValueType> llOptionalTlv = srpObj.getOptionalTlv();
        ListIterator<PcepValueType> listIterator = llOptionalTlv.listIterator();
        while (listIterator.hasNext()) {
            PcepValueType tlv = listIterator.next();
            switch(tlv.getType()) {
                case PathSetupTypeTlv.TYPE:
                    lspType = LspType.values()[Integer.valueOf(((PathSetupTypeTlv) tlv).getPst())];
                    break;
                default:
                    break;
            }
        }
    }
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        if (lspObj.getCFlag()) {
            /*
                     * While in sync, if PCRpt is received for PCE init LSP and PCE doesn't have entry, mark to send
                     * delete message on end of sync.
                     */
            SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(ipv4LspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(ipv4LspIdenTlv.getLspId())).build();
            // Gnenerate tunnel id for the temporary tunnel.
            String onosTunnelId = "PCC" + String.valueOf(ipv4LspIdenTlv.getTunnelId());
            Tunnel tunnelToBeDeleted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), TunnelId.valueOf(onosTunnelId), TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            /*
                     * Need to send PCInitiate delete msg for a tunnel which does not exist at PCE. For that some dummy
                     * data-structures need to be populated.
                     */
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelToBeDeleted, path, RequestType.DELETE);
            pcepTunnelData.setPlspId(lspObj.getPlspId());
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
            pcepTunnelApiMapper.handleCreateTunnelRequestQueue(0, pcepTunnelData);
            /*
                     * Add to the list of tunnels for which PCInit delete will be sent at the end of sync.
                     */
            List<Tunnel> tunnelToBeDeletedList = syncCompleteDeleteList.get(pccId.ipAddress());
            tunnelToBeDeletedList.add(tunnelToBeDeleted);
            syncCompleteDeleteList.put(pccId.ipAddress(), tunnelToBeDeletedList);
            return;
        }
        SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(ipv4LspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(ipv4LspIdenTlv.getLspId())).build();
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
        TunnelId tId = tunnelAdded(td, tunnelState);
        Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        return;
    }
    if ((syncStatus == IN_SYNC) && (lspObj.getCFlag()) && (tunnelState != tunnel.state())) {
        // Mark to send PCUpd msg with state known at PCE.
        List<Tunnel> tunnelToBeUpdateList = syncCompleteDeleteList.get(pccId.ipAddress());
        tunnelToBeUpdateList.add(tunnel);
        syncCompleteUpdateList.put(pccId.ipAddress(), tunnelToBeUpdateList);
        return;
    }
    td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), tunnel.path(), (SparseAnnotations) tunnel.annotations());
    if (lspObj.getRFlag()) {
        tunnelRemoved(td);
    } else {
        if (syncStatus == IN_SYNC) {
            markLspDbEntryAsLatest(pccId, tunnel.tunnelId());
        }
        tunnelUpdated(td, tunnelState);
    }
    return;
}
#method_after
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId, PcepSyncStatus syncStatus) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    Path path = buildPathFromEroObj(eroObj, providerId);
    int bandwidth = 0;
    if (msgPath.getBandwidthObject() != null) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    /*
             * To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
             * from PCE.
             */
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = WITH_SIGNALLING;
    if (null != srpObj) {
        LinkedList<PcepValueType> llOptionalTlv = srpObj.getOptionalTlv();
        ListIterator<PcepValueType> listIterator = llOptionalTlv.listIterator();
        while (listIterator.hasNext()) {
            PcepValueType tlv = listIterator.next();
            switch(tlv.getType()) {
                case PathSetupTypeTlv.TYPE:
                    lspType = LspType.values()[Integer.valueOf(((PathSetupTypeTlv) tlv).getPst())];
                    break;
                default:
                    break;
            }
        }
    }
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        if (lspObj.getCFlag()) {
            /*
                     * While in sync, if PCRpt is received for PCE init LSP and PCE doesn't have entry, mark to send
                     * delete message on end of sync.
                     */
            SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(ipv4LspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(ipv4LspIdenTlv.getLspId())).build();
            // Gnenerate tunnel id for the temporary tunnel.
            String onosTunnelId = "PCC" + String.valueOf(ipv4LspIdenTlv.getTunnelId());
            Tunnel tunnelToBeDeleted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), TunnelId.valueOf(onosTunnelId), TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
            /*
                     * Need to send PCInitiate delete msg for a tunnel which does not exist at PCE. For that some dummy
                     * data-structures need to be populated.
                     */
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelToBeDeleted, path, RequestType.DELETE);
            pcepTunnelData.setPlspId(lspObj.getPlspId());
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
            pcepTunnelApiMapper.handleCreateTunnelRequestQueue(0, pcepTunnelData);
            /*
                     * Add to the list of tunnels for which PCInit delete will be sent at the end of sync.
                     */
            List<Tunnel> tunnelToBeDeletedList = syncCompleteDeleteList.get(pccId.ipAddress());
            tunnelToBeDeletedList.add(tunnelToBeDeleted);
            syncCompleteDeleteList.put(pccId.ipAddress(), tunnelToBeDeletedList);
            return;
        }
        SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(ipv4LspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(ipv4LspIdenTlv.getLspId())).build();
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
        TunnelId tId = tunnelAdded(td, tunnelState);
        Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, annotations);
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        return;
    }
    if ((syncStatus == IN_SYNC) && (lspObj.getCFlag()) && (tunnelState != tunnel.state())) {
        // Mark to send PCUpd msg with state known at PCE.
        List<Tunnel> tunnelToBeUpdateList = syncCompleteUpdateList.get(pccId.ipAddress());
        tunnelToBeUpdateList.add(tunnel);
        syncCompleteUpdateList.put(pccId.ipAddress(), tunnelToBeUpdateList);
        return;
    }
    td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), tunnel.path(), (SparseAnnotations) tunnel.annotations());
    if (lspObj.getRFlag()) {
        tunnelRemoved(td);
    } else {
        if (syncStatus == IN_SYNC) {
            markLspDbEntryAsLatest(pccId, tunnel.tunnelId());
        }
        tunnelUpdated(td, tunnelState);
    }
    return;
}
#end_block

#method_before
private void handleEndOfSyncAction(PccId pccId) {
    Map<TunnelId, Tunnel> preSyncLspDb = preSyncLspDbMap.get(pccId.ipAddress());
    checkNotNull(preSyncLspDb);
    for (Tunnel tunnel : preSyncLspDb.values()) {
        TunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), tunnel.providerId(), tunnel.tunnelName(), tunnel.path(), (SparseAnnotations) tunnel.annotations());
        if ((tunnel.annotations().value(PCE_INIT) == null) || (tunnel.annotations().value(PCE_INIT).equals("false"))) {
            tunnelRemoved(td);
        } else {
            // Send PCInit msg again after global reoptimization.
            tunnelUpdated(td, UNSTABLE);
            // To remove the old tunnel from store whose PLSPID is not
            // recognized by ingress PCC.
            tunnelRemoved(td);
        }
    }
    List<Tunnel> tunnelsToBeDeletedList = syncCompleteDeleteList.get(pccId.ipAddress());
    checkNotNull(tunnelsToBeDeletedList);
    for (Tunnel tunnel : tunnelsToBeDeletedList) {
        releaseTunnel(tunnel);
    }
    List<Tunnel> tunnelsToBeUpdatedList = syncCompleteUpdateList.get(pccId.ipAddress());
    checkNotNull(tunnelsToBeUpdatedList);
    for (Tunnel tunnel : tunnelsToBeUpdatedList) {
        updateTunnel(tunnel, tunnel.path());
    }
    /* On end of sync, empty all temporary data structures. */
    preSyncLspDbMap.remove(pccId.ipAddress());
    syncCompleteDeleteList.remove(pccId.ipAddress());
    syncCompleteUpdateList.remove(pccId.ipAddress());
    // PCE APP to start label DB sync.
    if (true) {
        pcepClientController.getClient(pccId).setlabelDbSyncStatus(IN_SYNC);
    }
}
#method_after
private void handleEndOfSyncAction(PccId pccId) {
    Map<TunnelId, Tunnel> preSyncLspDb = preSyncLspDbMap.get(pccId.ipAddress());
    checkNotNull(preSyncLspDb);
    for (Tunnel tunnel : preSyncLspDb.values()) {
        TunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), tunnel.providerId(), tunnel.tunnelName(), tunnel.path(), (SparseAnnotations) tunnel.annotations());
        if ((tunnel.annotations().value(PCE_INIT) == null) || (tunnel.annotations().value(PCE_INIT).equals("false"))) {
            tunnelRemoved(td);
        } else {
            // Send PCInit msg again after global reoptimization.
            tunnelUpdated(td, UNSTABLE);
            // To remove the old tunnel from store whose PLSPID is not
            // recognized by ingress PCC.
            tunnelRemoved(td);
        }
    }
    List<Tunnel> tunnelsToBeDeletedList = syncCompleteDeleteList.get(pccId.ipAddress());
    checkNotNull(tunnelsToBeDeletedList);
    for (Tunnel tunnel : tunnelsToBeDeletedList) {
        releaseTunnel(tunnel);
    }
    List<Tunnel> tunnelsToBeUpdatedList = syncCompleteUpdateList.get(pccId.ipAddress());
    checkNotNull(tunnelsToBeUpdatedList);
    for (Tunnel tunnel : tunnelsToBeUpdatedList) {
        updateTunnel(tunnel, tunnel.path());
    }
    /* On end of sync, empty all temporary data structures. */
    preSyncLspDbMap.remove(pccId.ipAddress());
    syncCompleteDeleteList.remove(pccId.ipAddress());
    syncCompleteUpdateList.remove(pccId.ipAddress());
    // PCE APP to start label DB sync.
    if (true) {
        pcepClientController.getClient(pccId).setLabelDbSyncStatus(IN_SYNC);
    }
}
#end_block

#method_before
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    // write Object header
    int objStartIndex = cb.writerIndex();
    int objLenIndex = lspObjHeader.write(cb);
    if (objLenIndex <= 0) {
        throw new PcepParseException("Failed to write lsp object header. Index " + objLenIndex);
    }
    int iTemp = iPlspId << PLSPID_SHIFT_VALUE;
    iTemp = iTemp | (((bCFlag) ? (int) BIT_SET : BIT_RESET) << CFLAG_SHIFT_VALUE);
    iTemp = iTemp | (yOFlag << OFLAG_SHIFT_VALUE);
    byte bFlag;
    iTemp = bAFlag ? (iTemp | AFLAG_TEMP_SHIFT_VALUE) : iTemp;
    bFlag = (bRFlag) ? (byte) BIT_SET : BIT_RESET;
    iTemp = iTemp | (bFlag << RFLAG_SHIFT_VALUE);
    bFlag = (bSFlag) ? (byte) BIT_SET : BIT_RESET;
    iTemp = iTemp | (bFlag << SFLAG_SHIFT_VALUE);
    bFlag = (bDFlag) ? (byte) BIT_SET : BIT_RESET;
    iTemp = iTemp | bFlag;
    cb.writeInt(iTemp);
    // Add optional TLV
    packOptionalTlv(cb);
    // Update object length now
    int length = cb.writerIndex() - objStartIndex;
    // will be helpful during print().
    lspObjHeader.setObjLen((short) length);
    // As per RFC the length of object should be
    // multiples of 4
    cb.setShort(objLenIndex, (short) length);
    return length;
}
#method_after
@Override
public int write(ChannelBuffer cb) throws PcepParseException {
    // write Object header
    int objStartIndex = cb.writerIndex();
    int objLenIndex = lspObjHeader.write(cb);
    if (objLenIndex <= 0) {
        throw new PcepParseException("Failed to write lsp object header. Index " + objLenIndex);
    }
    int iTemp = iPlspId << PLSPID_SHIFT_VALUE;
    iTemp = iTemp | (((bCFlag) ? BIT_SET : BIT_RESET) << CFLAG_SHIFT_VALUE);
    iTemp = iTemp | (yOFlag << OFLAG_SHIFT_VALUE);
    byte bFlag;
    iTemp = bAFlag ? (iTemp | AFLAG_TEMP_SHIFT_VALUE) : iTemp;
    bFlag = (bRFlag) ? (byte) BIT_SET : BIT_RESET;
    iTemp = iTemp | (bFlag << RFLAG_SHIFT_VALUE);
    bFlag = (bSFlag) ? (byte) BIT_SET : BIT_RESET;
    iTemp = iTemp | (bFlag << SFLAG_SHIFT_VALUE);
    bFlag = (bDFlag) ? (byte) BIT_SET : BIT_RESET;
    iTemp = iTemp | bFlag;
    cb.writeInt(iTemp);
    // Add optional TLV
    packOptionalTlv(cb);
    // Update object length now
    int length = cb.writerIndex() - objStartIndex;
    // will be helpful during print().
    lspObjHeader.setObjLen((short) length);
    // As per RFC the length of object should be
    // multiples of 4
    cb.setShort(objLenIndex, (short) length);
    return length;
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x4e, 0x1f, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x4e, 0x1f, 0x04, 0x00, 0x4e, 0x20, 0x04, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0xb6, // ERO IPv4 sub objects
    0x02, // ERO IPv4 sub objects
    0x4e, // ERO IPv4 sub objects
    0x1f, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // create an existing tunnel.
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e1f0400));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e200400));
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(1)).toString()).set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PCC_TUNNEL_ID, String.valueOf(1)).set(PLSP_ID, String.valueOf(1)).set(LOCAL_LSP_ID, String.valueOf(1)).build();
    Tunnel tunnel = new DefaultTunnel(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, INIT, null, null, TunnelName.tunnelName("T123"), null, annotations);
    tunnelService.setupTunnel(null, null, tunnel, null);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0x4e1f0400));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.getClient(pccId).setlspDbSyncStatus(SYNCED);
    // Process update message.
    controller.processClientMessage(pccId, message);
    assertThat(tunnelService.queryAllTunnels().size(), is(1));
}
#method_after
@Test
public void tunnelProviderAddedTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x4e, 0x1f, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x4e, 0x1f, 0x04, 0x00, 0x4e, 0x20, 0x04, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0xb6, // ERO IPv4 sub objects
    0x02, // ERO IPv4 sub objects
    0x4e, // ERO IPv4 sub objects
    0x1f, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // create an existing tunnel.
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e1f0400));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e200400));
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(1)).toString()).set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PCC_TUNNEL_ID, String.valueOf(1)).set(PLSP_ID, String.valueOf(1)).set(LOCAL_LSP_ID, String.valueOf(1)).build();
    Tunnel tunnel = new DefaultTunnel(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, INIT, null, null, TunnelName.tunnelName("T123"), null, annotations);
    tunnelService.setupTunnel(null, null, tunnel, null);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0x4e1f0400));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.getClient(pccId).setLspDbSyncStatus(SYNCED);
    // Process update message.
    controller.processClientMessage(pccId, message);
    assertThat(tunnelService.queryAllTunnels().size(), is(1));
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setlspDbSyncStatus(SYNCED);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.processClientMessage(pccId, message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#method_after
@Test
public void tunnelProviderAddedTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setLspDbSyncStatus(SYNCED);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.processClientMessage(pccId, message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#end_block

#method_before
private void printAllocation(DeviceId did, PortNumber num, int level) {
    if (level == 0) {
        // print DeviceId when Port was directly specified.
        print("%s", did);
    }
    print("%s%s", Strings.repeat(" ", level), asVerboseString(num));
    // FIXME: This workaround induces a lot of distributed store access.
    // ResourceService should have an API to get all allocations under a parent resource.
    Set<Class<?>> subResourceTypes = ImmutableSet.<Class<?>>builder().add(OchSignal.class).add(VlanId.class).add(MplsLabel.class).add(Bandwidth.class).add(TributarySlot.class).build();
    DiscreteResourceId resourceId = Resources.discrete(did, num).id();
    for (Class<?> t : subResourceTypes) {
        resourceService.getResourceAllocations(resourceId, t).stream().filter(a -> isSubjectToPrint(a)).forEach(a -> print("%s%s allocated by %s", Strings.repeat(" ", level + 1), a.resource().valueAs(Object.class).orElse(""), asVerboseString(a.consumerEntry())));
    }
}
#method_after
private void printAllocation(DeviceId did, PortNumber num, int level) {
    if (level == 0) {
        // print DeviceId when Port was directly specified.
        print("%s", did);
    }
    print("%s%s", Strings.repeat(" ", level), asVerboseString(num));
    // FIXME: This workaround induces a lot of distributed store access.
    // ResourceService should have an API to get all allocations under a parent resource.
    Set<Class<?>> subResourceTypes = ImmutableSet.<Class<?>>builder().add(OchSignal.class).add(VlanId.class).add(MplsLabel.class).add(Bandwidth.class).add(TributarySlot.class).build();
    DiscreteResourceId resourceId = Resources.discrete(did, num).id();
    for (Class<?> t : subResourceTypes) {
        resourceService.getResourceAllocations(resourceId, t).stream().filter(a -> isSubjectToPrint(a)).forEach(a -> print("%s%s allocated by %s", Strings.repeat(" ", level + 1), a.resource().valueAs(Object.class).orElse(""), asVerboseString(a.consumerId())));
    }
}
#end_block

#method_before
private boolean isSubjectToPrint(ResourceAllocation allocation) {
    if (!intentsToPrint.isEmpty() && allocation.consumerEntry().isClassOf(IntentId.class) && !intentsToPrint.contains(allocation.consumerEntry().toString())) {
        return false;
    }
    if (!typesToPrint.isEmpty() && !typesToPrint.contains(allocation.resource().simpleTypeName())) {
        return false;
    }
    return true;
}
#method_after
private boolean isSubjectToPrint(ResourceAllocation allocation) {
    if (!intentsToPrint.isEmpty() && allocation.consumerId().isClassOf(IntentId.class) && !intentsToPrint.contains(allocation.consumerId().toString())) {
        return false;
    }
    if (!typesToPrint.isEmpty() && !typesToPrint.contains(allocation.resource().simpleTypeName())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private static String asVerboseString(ResourceConsumerEntry consumerEntry) {
    return String.format("%s:%s", consumerEntry.consumerClass(), consumerEntry.consumerId().id());
}
#method_after
private static String asVerboseString(ResourceConsumerId consumerId) {
    return String.format("%s:%s", consumerId.consumerClass(), consumerId.value());
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("org.onosproject.net.intent");
    intentManager.registerCompiler(OpticalCircuitIntent.class, this);
    cfgService.registerProperties(getClass());
    modified(context);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    deviceService = opticalView(deviceService);
    appId = coreService.registerApplication("org.onosproject.net.intent");
    intentManager.registerCompiler(OpticalCircuitIntent.class, this);
    cfgService.registerProperties(getClass());
    modified(context);
}
#end_block

#method_before
private Optional<OchPort> findAvailableOchPort(ConnectPoint oduPort, OduSignalType ochPortSignalType) {
    // First see if the port mappings are constrained
    ConnectPoint ochCP = staticPort(oduPort);
    if (ochCP != null) {
        OchPort ochPort = (OchPort) deviceService.getPort(ochCP.deviceId(), ochCP.port());
        Optional<IntentId> intentId = resourceService.getResourceAllocations(Resources.discrete(ochCP.deviceId(), ochCP.port()).id()).stream().map(ResourceAllocation::consumerEntry).map(x -> ResourceHelper.getIntentId(x)).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return Optional.of(ochPort);
        }
        return Optional.empty();
    }
    // No port constraints, so find any port that works
    List<Port> ports = deviceService.getPorts(oduPort.deviceId());
    for (Port port : ports) {
        if (!(port instanceof OchPort)) {
            continue;
        }
        // This should be the first allocation on the OCH port
        if (!resourceService.isAvailable(Resources.discrete(oduPort.deviceId(), port.number()).resource())) {
            continue;
        }
        // OchPort is required to have the requested oduSignalType
        if (((OchPort) port).signalType() != ochPortSignalType) {
            continue;
        }
        Optional<IntentId> intentId = resourceService.getResourceAllocations(Resources.discrete(oduPort.deviceId(), port.number()).id()).stream().map(ResourceAllocation::consumerEntry).map(x -> ResourceHelper.getIntentId(x)).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return Optional.of((OchPort) port);
        }
    }
    return Optional.empty();
}
#method_after
private Optional<OchPort> findAvailableOchPort(ConnectPoint oduPort, OduSignalType ochPortSignalType) {
    // First see if the port mappings are constrained
    ConnectPoint ochCP = staticPort(oduPort);
    if (ochCP != null) {
        OchPort ochPort = (OchPort) deviceService.getPort(ochCP.deviceId(), ochCP.port());
        Optional<IntentId> intentId = resourceService.getResourceAllocations(Resources.discrete(ochCP.deviceId(), ochCP.port()).id()).stream().map(ResourceAllocation::consumerId).map(ResourceHelper::getIntentId).flatMap(Tools::stream).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return Optional.of(ochPort);
        }
        return Optional.empty();
    }
    // No port constraints, so find any port that works
    List<Port> ports = deviceService.getPorts(oduPort.deviceId());
    for (Port port : ports) {
        if (!(port instanceof OchPort)) {
            continue;
        }
        // This should be the first allocation on the OCH port
        if (!resourceService.isAvailable(Resources.discrete(oduPort.deviceId(), port.number()).resource())) {
            continue;
        }
        // OchPort is required to have the requested oduSignalType
        if (((OchPort) port).signalType() != ochPortSignalType) {
            continue;
        }
        Optional<IntentId> intentId = resourceService.getResourceAllocations(Resources.discrete(oduPort.deviceId(), port.number()).id()).stream().map(ResourceAllocation::consumerId).map(ResourceHelper::getIntentId).flatMap(Tools::stream).findAny();
        if (isAvailable(intentId.orElse(null))) {
            return Optional.of((OchPort) port);
        }
    }
    return Optional.empty();
}
#end_block

#method_before
@Activate
public void activate() {
    discreteConsumers = service.<DiscreteResourceId, ResourceConsumer>consistentMapBuilder().withName(DISCRETE_CONSUMER_MAP).withSerializer(SERIALIZER).build();
    continuousConsumers = service.<ContinuousResourceId, ContinuousResourceAllocation>consistentMapBuilder().withName(CONTINUOUS_CONSUMER_MAP).withSerializer(SERIALIZER).build();
    childMap = service.<DiscreteResourceId, Set<Resource>>consistentMapBuilder().withName(CHILD_MAP).withSerializer(SERIALIZER).build();
    Tools.retryable(() -> childMap.put(Resource.ROOT.id(), new LinkedHashSet<>()), ConsistentMapException.class, MAX_RETRIES, RETRY_DELAY);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    discreteStore = new ConsistentDiscreteResourceStore(service);
    continuousStore = new ConsistentContinuousResourceStore(service);
    log.info("Started");
}
#end_block

#method_before
// Computational complexity: O(1) if the resource is discrete type.
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId id) {
    checkNotNull(id);
    checkArgument(id instanceof DiscreteResourceId || id instanceof ContinuousResourceId);
    if (id instanceof DiscreteResourceId) {
        return getResourceAllocations((DiscreteResourceId) id);
    } else {
        return getResourceAllocations((ContinuousResourceId) id);
    }
}
#method_after
// Computational complexity: O(1) if the resource is discrete type.
@Override
public List<ResourceAllocation> getResourceAllocations(ResourceId id) {
    checkNotNull(id);
    checkArgument(id instanceof DiscreteResourceId || id instanceof ContinuousResourceId);
    if (id instanceof DiscreteResourceId) {
        return discreteStore.getResourceAllocations((DiscreteResourceId) id);
    } else {
        return continuousStore.getResourceAllocations((ContinuousResourceId) id);
    }
}
#end_block

#method_before
@Override
public boolean register(List<Resource> resources) {
    checkNotNull(resources);
    if (log.isTraceEnabled()) {
        resources.forEach(r -> log.trace("registering {}", r));
    }
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    // the order is preserved by LinkedHashMap
    Map<DiscreteResource, List<Resource>> resourceMap = resources.stream().filter(x -> x.parent().isPresent()).collect(Collectors.groupingBy(x -> x.parent().get(), LinkedHashMap::new, Collectors.toList()));
    for (Map.Entry<DiscreteResource, List<Resource>> entry : resourceMap.entrySet()) {
        if (!lookup(childTxMap, entry.getKey().id()).isPresent()) {
            return abortTransaction(tx);
        }
        if (!appendValues(childTxMap, entry.getKey().id(), entry.getValue())) {
            return abortTransaction(tx);
        }
    }
    return tx.commit().whenComplete((status, error) -> {
        if (status == CommitStatus.SUCCESS) {
            log.trace("Transaction commit succeeded on registration: resources={}", resources);
            List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_ADDED, x)).collect(Collectors.toList());
            notifyDelegate(events);
        } else {
            log.warn("Transaction commit failed on registration", error);
        }
    }).join() == CommitStatus.SUCCESS;
}
#method_after
@Override
public boolean register(List<Resource> resources) {
    checkNotNull(resources);
    if (log.isTraceEnabled()) {
        resources.forEach(r -> log.trace("registering {}", r));
    }
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    // the order is preserved by LinkedHashMap
    Map<DiscreteResource, List<Resource>> resourceMap = resources.stream().filter(x -> x.parent().isPresent()).collect(Collectors.groupingBy(x -> x.parent().get(), LinkedHashMap::new, Collectors.toList()));
    TransactionalDiscreteResourceStore discreteTxStore = discreteStore.transactional(tx);
    TransactionalContinuousResourceStore continuousTxStore = continuousStore.transactional(tx);
    for (Map.Entry<DiscreteResource, List<Resource>> entry : resourceMap.entrySet()) {
        DiscreteResourceId parentId = entry.getKey().id();
        if (!discreteTxStore.lookup(parentId).isPresent()) {
            return abortTransaction(tx);
        }
        if (!register(discreteTxStore, continuousTxStore, parentId, entry.getValue())) {
            return abortTransaction(tx);
        }
    }
    return tx.commit().whenComplete((status, error) -> {
        if (status == CommitStatus.SUCCESS) {
            log.trace("Transaction commit succeeded on registration: resources={}", resources);
            List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_ADDED, x)).collect(Collectors.toList());
            notifyDelegate(events);
        } else {
            log.warn("Transaction commit failed on registration", error);
        }
    }).join() == CommitStatus.SUCCESS;
}
#end_block

#method_before
@Override
public boolean unregister(List<ResourceId> ids) {
    checkNotNull(ids);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    TransactionalMap<DiscreteResourceId, ResourceConsumer> discreteConsumerTxMap = tx.getTransactionalMap(DISCRETE_CONSUMER_MAP, SERIALIZER);
    TransactionalMap<ContinuousResourceId, ContinuousResourceAllocation> continuousConsumerTxMap = tx.getTransactionalMap(CONTINUOUS_CONSUMER_MAP, SERIALIZER);
    // Look up resources by resource IDs
    List<Resource> resources = ids.stream().filter(x -> x.parent().isPresent()).map(x -> {
        // avoid access to consistent map in the case of discrete resource
        if (x instanceof DiscreteResourceId) {
            return Optional.of(Resources.discrete((DiscreteResourceId) x).resource());
        } else {
            return lookup(childTxMap, x);
        }
    }).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
    // the order is preserved by LinkedHashMap
    Map<DiscreteResourceId, List<Resource>> resourceMap = resources.stream().collect(Collectors.groupingBy(x -> x.parent().get().id(), LinkedHashMap::new, Collectors.toList()));
    // all unregistrations are regarded as failure
    for (Map.Entry<DiscreteResourceId, List<Resource>> entry : resourceMap.entrySet()) {
        boolean allocated = entry.getValue().stream().anyMatch(x -> {
            if (x instanceof DiscreteResource) {
                return discreteConsumerTxMap.get(((DiscreteResource) x).id()) != null;
            } else if (x instanceof ContinuousResource) {
                ContinuousResourceAllocation allocations = continuousConsumerTxMap.get(((ContinuousResource) x).id());
                return allocations != null && !allocations.allocations().isEmpty();
            } else {
                return false;
            }
        });
        if (allocated) {
            log.warn("Failed to unregister {}: allocation exists", entry.getKey());
            return abortTransaction(tx);
        }
        if (!removeValues(childTxMap, entry.getKey(), entry.getValue())) {
            log.warn("Failed to unregister {}: Failed to remove {} values.", entry.getKey(), entry.getValue().size());
            log.debug("Failed to unregister {}: Failed to remove values: {}", entry.getKey(), entry.getValue());
            return abortTransaction(tx);
        }
    }
    return tx.commit().whenComplete((status, error) -> {
        if (status == CommitStatus.SUCCESS) {
            List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_REMOVED, x)).collect(Collectors.toList());
            notifyDelegate(events);
        } else {
            log.warn("Failed to unregister {}: Commit failed.", ids, error);
        }
    }).join() == CommitStatus.SUCCESS;
}
#method_after
@Override
public boolean unregister(List<ResourceId> ids) {
    checkNotNull(ids);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalDiscreteResourceStore discreteTxStore = discreteStore.transactional(tx);
    TransactionalContinuousResourceStore continuousTxStore = continuousStore.transactional(tx);
    // Look up resources by resource IDs
    List<Resource> resources = ids.stream().filter(x -> x.parent().isPresent()).map(x -> {
        // avoid access to consistent map in the case of discrete resource
        if (x instanceof DiscreteResourceId) {
            return Optional.of(Resources.discrete((DiscreteResourceId) x).resource());
        } else {
            return continuousTxStore.lookup((ContinuousResourceId) x);
        }
    }).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
    // the order is preserved by LinkedHashMap
    Map<DiscreteResourceId, List<Resource>> resourceMap = resources.stream().collect(Collectors.groupingBy(x -> x.parent().get().id(), LinkedHashMap::new, Collectors.toList()));
    for (Map.Entry<DiscreteResourceId, List<Resource>> entry : resourceMap.entrySet()) {
        if (!unregister(discreteTxStore, continuousTxStore, entry.getKey(), entry.getValue())) {
            log.warn("Failed to unregister {}: Failed to remove {} values.", entry.getKey(), entry.getValue().size());
            log.debug("Failed to unregister {}: Failed to remove values: {}", entry.getKey(), entry.getValue());
            return abortTransaction(tx);
        }
    }
    return tx.commit().whenComplete((status, error) -> {
        if (status == CommitStatus.SUCCESS) {
            List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_REMOVED, x)).collect(Collectors.toList());
            notifyDelegate(events);
        } else {
            log.warn("Failed to unregister {}: Commit failed.", ids, error);
        }
    }).join() == CommitStatus.SUCCESS;
}
#end_block

#method_before
@Override
public boolean allocate(List<Resource> resources, ResourceConsumer consumer) {
    checkNotNull(resources);
    checkNotNull(consumer);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    TransactionalMap<DiscreteResourceId, ResourceConsumer> discreteConsumerTxMap = tx.getTransactionalMap(DISCRETE_CONSUMER_MAP, SERIALIZER);
    TransactionalMap<ContinuousResourceId, ContinuousResourceAllocation> continuousConsumerTxMap = tx.getTransactionalMap(CONTINUOUS_CONSUMER_MAP, SERIALIZER);
    for (Resource resource : resources) {
        // if the resource is not registered, then abort
        Optional<Resource> lookedUp = lookup(childTxMap, resource.id());
        if (!lookedUp.isPresent()) {
            return abortTransaction(tx);
        }
        if (resource instanceof DiscreteResource) {
            ResourceConsumer oldValue = discreteConsumerTxMap.put(((DiscreteResource) resource).id(), consumer);
            if (oldValue != null) {
                return abortTransaction(tx);
            }
        } else if (resource instanceof ContinuousResource) {
            // Down cast: this must be safe as ContinuousResource is associated with ContinuousResourceId
            ContinuousResource continuous = (ContinuousResource) lookedUp.get();
            ContinuousResourceAllocation allocations = continuousConsumerTxMap.get(continuous.id());
            if (!hasEnoughResource(continuous, (ContinuousResource) resource, allocations)) {
                return abortTransaction(tx);
            }
            boolean success = appendValue(continuousConsumerTxMap, continuous, new ResourceAllocation(resource, consumer));
            if (!success) {
                return abortTransaction(tx);
            }
        }
    }
    return tx.commit().join() == CommitStatus.SUCCESS;
}
#method_after
@Override
public boolean allocate(List<Resource> resources, ResourceConsumer consumer) {
    checkNotNull(resources);
    checkNotNull(consumer);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalDiscreteResourceStore discreteTxStore = discreteStore.transactional(tx);
    TransactionalContinuousResourceStore continuousTxStore = continuousStore.transactional(tx);
    for (Resource resource : resources) {
        if (resource instanceof DiscreteResource) {
            if (!discreteTxStore.allocate(consumer.consumerId(), (DiscreteResource) resource)) {
                return abortTransaction(tx);
            }
        } else if (resource instanceof ContinuousResource) {
            if (!continuousTxStore.allocate(consumer.consumerId(), (ContinuousResource) resource)) {
                return abortTransaction(tx);
            }
        }
    }
    return tx.commit().join() == CommitStatus.SUCCESS;
}
#end_block

#method_before
@Override
public boolean release(List<ResourceAllocation> allocations) {
    checkNotNull(allocations);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, ResourceConsumerEntry> discreteConsumerTxMap = tx.getTransactionalMap(DISCRETE_CONSUMER_MAP, SERIALIZER);
    TransactionalMap<ContinuousResourceId, ContinuousResourceAllocation> continuousConsumerTxMap = tx.getTransactionalMap(CONTINUOUS_CONSUMER_MAP, SERIALIZER);
    for (ResourceAllocation allocation : allocations) {
        Resource resource = allocation.resource();
        ResourceConsumerEntry consumerEntry = allocation.consumerEntry();
        if (resource instanceof DiscreteResource) {
            // the whole release fails
            if (!discreteConsumerTxMap.remove(((DiscreteResource) resource).id(), consumerEntry)) {
                return abortTransaction(tx);
            }
        } else if (resource instanceof ContinuousResource) {
            ContinuousResource continuous = (ContinuousResource) resource;
            ContinuousResourceAllocation continuousAllocation = continuousConsumerTxMap.get(continuous.id());
            ImmutableList<ResourceAllocation> newAllocations = continuousAllocation.allocations().stream().filter(x -> !(x.consumerEntry().equals(consumerEntry) && ((ContinuousResource) x.resource()).value() == continuous.value())).collect(GuavaCollectors.toImmutableList());
            if (!continuousConsumerTxMap.replace(continuous.id(), continuousAllocation, new ContinuousResourceAllocation(continuousAllocation.original(), newAllocations))) {
                return abortTransaction(tx);
            }
        }
    }
    return tx.commit().join() == CommitStatus.SUCCESS;
}
#method_after
@Override
public boolean release(List<ResourceAllocation> allocations) {
    checkNotNull(allocations);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalDiscreteResourceStore discreteTxStore = discreteStore.transactional(tx);
    TransactionalContinuousResourceStore continuousTxStore = continuousStore.transactional(tx);
    for (ResourceAllocation allocation : allocations) {
        Resource resource = allocation.resource();
        ResourceConsumerId consumerId = allocation.consumerId();
        if (resource instanceof DiscreteResource) {
            if (!discreteTxStore.release((DiscreteResource) resource, consumerId)) {
                return abortTransaction(tx);
            }
        } else if (resource instanceof ContinuousResource) {
            if (!continuousTxStore.release((ContinuousResource) resource, consumerId)) {
                return abortTransaction(tx);
            }
        }
    }
    return tx.commit().join() == CommitStatus.SUCCESS;
}
#end_block

#method_before
// computational complexity: O(1) if the resource is discrete type.
// O(n) if the resource is continuous type where n is the number of the children of
@Override
public boolean isAvailable(Resource resource) {
    checkNotNull(resource);
    checkArgument(resource instanceof DiscreteResource || resource instanceof ContinuousResource);
    if (resource instanceof DiscreteResource) {
        // check if already consumed
        return getResourceAllocations(resource.id()).isEmpty();
    } else {
        return isAvailable((ContinuousResource) resource);
    }
}
#method_after
// computational complexity: O(1) if the resource is discrete type.
// O(n) if the resource is continuous type where n is the number of the children of
@Override
public boolean isAvailable(Resource resource) {
    checkNotNull(resource);
    checkArgument(resource instanceof DiscreteResource || resource instanceof ContinuousResource);
    if (resource instanceof DiscreteResource) {
        // check if already consumed
        return discreteStore.isAvailable((DiscreteResource) resource);
    } else {
        return continuousStore.isAvailable((ContinuousResource) resource);
    }
}
#end_block

#method_before
// computational complexity: O(n + m) where n is the number of entries in discreteConsumers
@Override
public Collection<Resource> getResources(ResourceConsumer consumer) {
    checkNotNull(consumer);
    // NOTE: getting all entries may become performance bottleneck
    // TODO: revisit for better backend data structure
    Stream<DiscreteResource> discreteStream = discreteConsumers.entrySet().stream().filter(x -> x.getValue().value().equals(consumer)).map(Map.Entry::getKey).map(x -> Resources.discrete(x).resource());
    Stream<ContinuousResource> continuousStream = continuousConsumers.values().stream().flatMap(x -> x.value().allocations().stream().map(y -> Maps.immutableEntry(x.value().original(), y))).filter(x -> x.getValue().consumerEntry().equals(consumer)).map(x -> x.getKey());
    return Stream.concat(discreteStream, continuousStream).collect(Collectors.toList());
}
#method_after
// computational complexity: O(n + m) where n is the number of entries in discreteConsumers
@Override
public Collection<Resource> getResources(ResourceConsumer consumer) {
    checkNotNull(consumer);
    ResourceConsumerId consumerId = consumer.consumerId();
    // NOTE: getting all entries may become performance bottleneck
    // TODO: revisit for better backend data structure
    Stream<DiscreteResource> discrete = discreteStore.getResources(consumer.consumerId());
    Stream<ContinuousResource> continuous = continuousStore.getResources(consumer.consumerId());
    return Stream.concat(discrete, continuous).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public Set<Resource> getChildResources(DiscreteResourceId parent) {
    checkNotNull(parent);
    Versioned<Set<Resource>> children = childMap.get(parent);
    if (children == null) {
        return ImmutableSet.of();
    }
    return children.value();
}
#method_after
@Override
public Set<Resource> getChildResources(DiscreteResourceId parent) {
    checkNotNull(parent);
    return ImmutableSet.<Resource>builder().addAll(discreteStore.getChildResources(parent)).addAll(continuousStore.getChildResources(parent)).build();
}
#end_block

#method_before
@Override
public <T> Collection<Resource> getAllocatedResources(DiscreteResourceId parent, Class<T> cls) {
    checkNotNull(parent);
    checkNotNull(cls);
    Versioned<Set<Resource>> children = childMap.get(parent);
    if (children == null) {
        return ImmutableList.of();
    }
    Stream<DiscreteResource> discrete = children.value().stream().filter(x -> x.isTypeOf(cls)).filter(x -> x instanceof DiscreteResource).map(x -> ((DiscreteResource) x)).filter(x -> discreteConsumers.containsKey(x.id()));
    Stream<ContinuousResource> continuous = children.value().stream().filter(x -> x.id().equals(parent.child(cls))).filter(x -> x instanceof ContinuousResource).map(x -> (ContinuousResource) x).filter(resource -> {
        Versioned<ContinuousResourceAllocation> allocation = continuousConsumers.get(resource.id());
        if (allocation == null) {
            return false;
        }
        return !allocation.value().allocations().isEmpty();
    });
    return Stream.concat(discrete, continuous).collect(Collectors.toList());
}
#method_after
@Override
public <T> Collection<Resource> getAllocatedResources(DiscreteResourceId parent, Class<T> cls) {
    checkNotNull(parent);
    checkNotNull(cls);
    Stream<DiscreteResource> discrete = discreteStore.getAllocatedResources(parent, cls);
    Stream<ContinuousResource> continuous = continuousStore.getAllocatedResources(parent, cls);
    return Stream.concat(discrete, continuous).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public boolean register(List<Resource> resources) {
    checkNotNull(resources);
    if (log.isTraceEnabled()) {
        resources.forEach(r -> log.trace("registering {}", r));
    }
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    // the order is preserved by LinkedHashMap
    Map<DiscreteResource, List<Resource>> resourceMap = resources.stream().filter(x -> x.parent().isPresent()).collect(Collectors.groupingBy(x -> x.parent().get(), LinkedHashMap::new, Collectors.toList()));
    for (Map.Entry<DiscreteResource, List<Resource>> entry : resourceMap.entrySet()) {
        if (!lookup(childTxMap, entry.getKey().id()).isPresent()) {
            return abortTransaction(tx);
        }
        if (!appendValues(childTxMap, entry.getKey().id(), entry.getValue())) {
            return abortTransaction(tx);
        }
    }
    return tx.commit().whenComplete((status, error) -> {
        if (status == CommitStatus.SUCCESS) {
            log.trace("Transaction commit succeeded on registration: resources={}", resources);
            List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_ADDED, x)).collect(Collectors.toList());
            notifyDelegate(events);
        } else {
            log.warn("Transaction commit failed on registration", error);
        }
    }).join() == CommitStatus.SUCCESS;
}
#method_after
/**
 * Appends the values to the existing values associated with the specified key.
 * If the map already has all the given values, appending will not happen.
 *
 * @param key    key specifying values
 * @param values values to be appended
 * @return true if the operation succeeds, false otherwise.
 */
private boolean register(TransactionalDiscreteResourceStore discreteTxStore, TransactionalContinuousResourceStore continuousTxStore, DiscreteResourceId key, List<Resource> values) {
    // it's assumed that the passed "values" is non-empty
    // This is 2-pass scan. Nicer to have 1-pass scan
    List<DiscreteResource> discreteValues = values.stream().filter(x -> x instanceof DiscreteResource).map(x -> (DiscreteResource) x).collect(Collectors.toList());
    List<ContinuousResource> continuousValues = values.stream().filter(x -> x instanceof ContinuousResource).map(x -> (ContinuousResource) x).collect(Collectors.toList());
    return discreteTxStore.register(key, discreteValues) && continuousTxStore.register(key, continuousValues);
}
#end_block

#method_before
@Override
public boolean unregister(List<ResourceId> ids) {
    checkNotNull(ids);
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    TransactionalMap<DiscreteResourceId, Set<Resource>> childTxMap = tx.getTransactionalMap(CHILD_MAP, SERIALIZER);
    TransactionalMap<DiscreteResourceId, ResourceConsumer> discreteConsumerTxMap = tx.getTransactionalMap(DISCRETE_CONSUMER_MAP, SERIALIZER);
    TransactionalMap<ContinuousResourceId, ContinuousResourceAllocation> continuousConsumerTxMap = tx.getTransactionalMap(CONTINUOUS_CONSUMER_MAP, SERIALIZER);
    // Look up resources by resource IDs
    List<Resource> resources = ids.stream().filter(x -> x.parent().isPresent()).map(x -> {
        // avoid access to consistent map in the case of discrete resource
        if (x instanceof DiscreteResourceId) {
            return Optional.of(Resources.discrete((DiscreteResourceId) x).resource());
        } else {
            return lookup(childTxMap, x);
        }
    }).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
    // the order is preserved by LinkedHashMap
    Map<DiscreteResourceId, List<Resource>> resourceMap = resources.stream().collect(Collectors.groupingBy(x -> x.parent().get().id(), LinkedHashMap::new, Collectors.toList()));
    // all unregistrations are regarded as failure
    for (Map.Entry<DiscreteResourceId, List<Resource>> entry : resourceMap.entrySet()) {
        boolean allocated = entry.getValue().stream().anyMatch(x -> {
            if (x instanceof DiscreteResource) {
                return discreteConsumerTxMap.get(((DiscreteResource) x).id()) != null;
            } else if (x instanceof ContinuousResource) {
                ContinuousResourceAllocation allocations = continuousConsumerTxMap.get(((ContinuousResource) x).id());
                return allocations != null && !allocations.allocations().isEmpty();
            } else {
                return false;
            }
        });
        if (allocated) {
            log.warn("Failed to unregister {}: allocation exists", entry.getKey());
            return abortTransaction(tx);
        }
        if (!removeValues(childTxMap, entry.getKey(), entry.getValue())) {
            log.warn("Failed to unregister {}: Failed to remove {} values.", entry.getKey(), entry.getValue().size());
            log.debug("Failed to unregister {}: Failed to remove values: {}", entry.getKey(), entry.getValue());
            return abortTransaction(tx);
        }
    }
    return tx.commit().whenComplete((status, error) -> {
        if (status == CommitStatus.SUCCESS) {
            List<ResourceEvent> events = resources.stream().filter(x -> x.parent().isPresent()).map(x -> new ResourceEvent(RESOURCE_REMOVED, x)).collect(Collectors.toList());
            notifyDelegate(events);
        } else {
            log.warn("Failed to unregister {}: Commit failed.", ids, error);
        }
    }).join() == CommitStatus.SUCCESS;
}
#method_after
private boolean unregister(TransactionalDiscreteResourceStore discreteTxStore, TransactionalContinuousResourceStore continuousTxStore, DiscreteResourceId key, List<Resource> values) {
    // it's assumed that the passed "values" is non-empty
    // This is 2-pass scan. Nicer to have 1-pass scan
    List<DiscreteResource> discreteValues = values.stream().filter(x -> x instanceof DiscreteResource).map(x -> (DiscreteResource) x).collect(Collectors.toList());
    List<ContinuousResource> continuousValues = values.stream().filter(x -> x instanceof ContinuousResource).map(x -> (ContinuousResource) x).collect(Collectors.toList());
    return discreteTxStore.unregister(key, discreteValues) && continuousTxStore.unregister(key, continuousValues);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(resource, consumerEntry);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(resource, consumerId);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof ResourceAllocation)) {
        return false;
    }
    final ResourceAllocation that = (ResourceAllocation) obj;
    return Objects.equals(this.resource, that.resource) && Objects.equals(this.consumerEntry, that.consumerEntry);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof ResourceAllocation)) {
        return false;
    }
    final ResourceAllocation that = (ResourceAllocation) obj;
    return Objects.equals(this.resource, that.resource) && Objects.equals(this.consumerId, that.consumerId);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("resource", resource).add("consumerEntry", consumerEntry).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("resource", resource).add("consumerId", consumerId).toString();
}
#end_block

#method_before
public static IntentId getIntentId(ResourceConsumerEntry consumerEntry) {
    checkNotNull(consumerEntry);
    if (!isIntentId(consumerEntry)) {
        return null;
    }
    try {
        Long id = Long.valueOf(consumerEntry.consumerId().id());
        return IntentId.valueOf(id);
    } catch (NumberFormatException e) {
        return null;
    }
}
#method_after
public static Optional<IntentId> getIntentId(ResourceConsumerId consumerId) {
    checkNotNull(consumerId);
    if (!consumerId.isClassOf(IntentId.class)) {
        return Optional.empty();
    }
    return Optional.of(IntentId.valueOf(consumerId.value()));
}
#end_block

#method_before
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // Thrift transport layer is not thread-safe (it's a wrapper on a socket), hence we need locking.
    synchronized (transport) {
        LOG.debug("Invoking client method... > method={}, fromThread={}", method.getName(), Thread.currentThread().getId());
        try {
            return method.invoke(baseClient, args);
        } catch (InvocationTargetException e) {
            if (e.getTargetException() instanceof TTransportException) {
                TTransportException cause = (TTransportException) e.getTargetException();
                if (RESTARTABLE_CAUSES.contains(cause.getType())) {
                    // Try to reconnect. If fail, a TTransportException will be thrown.
                    reconnectOrThrowException();
                    try {
                        // If here, transport has been successfully open, hence new exceptions will be thrown.
                        return method.invoke(baseClient, args);
                    } catch (InvocationTargetException e1) {
                        LOG.debug("Exception while invoking client method: {} > method={}, fromThread={}", e, method.getName(), Thread.currentThread().getId());
                        throw e.getTargetException();
                    }
                }
            }
            // Target exception is neither a TTransportException nor a restartable cause.
            LOG.debug("Exception while invoking client method: {} > method={}, fromThread={}", e, method.getName(), Thread.currentThread().getId());
            throw e.getTargetException();
        }
    }
}
#method_after
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // Thrift transport layer is not thread-safe (it's a wrapper on a socket), hence we need locking.
    synchronized (transport) {
        LOG.debug("Invoking client method... > method={}, fromThread={}", method.getName(), Thread.currentThread().getId());
        try {
            return method.invoke(baseClient, args);
        } catch (InvocationTargetException e) {
            if (e.getTargetException() instanceof TTransportException) {
                TTransportException cause = (TTransportException) e.getTargetException();
                if (RESTARTABLE_CAUSES.contains(cause.getType())) {
                    // Try to reconnect. If fail, a TTransportException will be thrown.
                    reconnectOrThrowException();
                    try {
                        // If here, transport has been successfully open, hence new exceptions will be thrown.
                        return method.invoke(baseClient, args);
                    } catch (InvocationTargetException e1) {
                        LOG.debug("Exception while invoking client method: {} > method={}, fromThread={}", e1, method.getName(), Thread.currentThread().getId());
                        throw e1.getTargetException();
                    }
                }
            }
            // Target exception is neither a TTransportException nor a restartable cause.
            LOG.debug("Exception while invoking client method: {} > method={}, fromThread={}", e, method.getName(), Thread.currentThread().getId());
            throw e.getTargetException();
        }
    }
}
#end_block

#method_before
@Path("{floatingIpUUID}")
@DELETE
public Response deleteSingleFloatingIp(@PathParam("floatingIpUUID") String id) throws IOException {
    try {
        FloatingIpId floatingIpId = FloatingIpId.of(id);
        Set<FloatingIpId> floatingIpIds = Sets.newHashSet(floatingIpId);
        Boolean result = nullIsNotFound(get(FloatingIpService.class).removeFloatingIps(floatingIpIds), DELETE_FAIL);
        if (!result) {
            return Response.status(CONFLICT).entity(DELETE_FAIL).build();
        }
        return Response.noContent().entity(DELETE_SUCCESS).build();
    } catch (Exception e) {
        return Response.status(NOT_FOUND).entity(e.getMessage()).build();
    }
}
#method_after
@DELETE
@Path("{floatingIpUUID}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deleteSingleFloatingIp(@PathParam("floatingIpUUID") String id) throws IOException {
    try {
        FloatingIpId floatingIpId = FloatingIpId.of(id);
        Set<FloatingIpId> floatingIpIds = Sets.newHashSet(floatingIpId);
        Boolean result = nullIsNotFound(get(FloatingIpService.class).removeFloatingIps(floatingIpIds), DELETE_FAIL);
        if (!result) {
            return Response.status(CONFLICT).entity(DELETE_FAIL).build();
        }
        return Response.noContent().entity(DELETE_SUCCESS).build();
    } catch (Exception e) {
        return Response.status(NOT_FOUND).entity(e.getMessage()).build();
    }
}
#end_block

#method_before
private Response response(ApplicationAdminService service, ApplicationId appId) {
    Application app = service.getApplication(appId);
    return ok(codec(Application.class).encode(app, this)).build();
}
#method_after
private Response response(ApplicationAdminService service, ApplicationId appId) {
    Application app = nullIsNotFound(service.getApplication(appId), APP_NOT_FOUND);
    return ok(codec(Application.class).encode(app, this)).build();
}
#end_block

#method_before
private Response response(ApplicationAdminService service, ApplicationId appId) {
    Application app = service.getApplication(appId);
    return ok(codec(Application.class).encode(app, this)).build();
}
#method_after
private Response response(ApplicationId appId) {
    ApplicationId checkedAppId = nullIsNotFound(appId, APP_ID_NOT_FOUND);
    return ok(codec(ApplicationId.class).encode(checkedAppId, this)).build();
}
#end_block

#method_before
@DELETE
@Path("unregister")
public Response removeKafkaListener(String appName) {
    EventExporterService service = get(EventExporterService.class);
    service.unregisterListener(appName);
    return Response.noContent().entity(DEREGISTRATION_SUCCESSFUL).build();
}
#method_after
@DELETE
@Path("unregister")
public Response removeKafkaListener(String appName) {
    EventExporterService service = get(EventExporterService.class);
    service.unregisterListener(appName);
    return ok(DEREGISTRATION_SUCCESSFUL).build();
}
#end_block

#method_before
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
@Path("unsubscribe")
public Response unsubscribe(InputStream input) {
    EventExporterService service = get(EventExporterService.class);
    try {
        EventSubscriber sub = parseSubscriptionData(input);
        service.subscribe(sub);
    } catch (Exception e) {
        log.error(e.getMessage());
        return Response.status(BAD_REQUEST).entity(e.getMessage()).build();
    }
    return Response.noContent().entity(EVENT_SUBSCRIPTION_REMOVED).build();
}
#method_after
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
@Path("unsubscribe")
public Response unsubscribe(InputStream input) {
    EventExporterService service = get(EventExporterService.class);
    try {
        EventSubscriber sub = parseSubscriptionData(input);
        service.subscribe(sub);
    } catch (Exception e) {
        log.error(e.getMessage());
        return Response.status(BAD_REQUEST).entity(e.getMessage()).build();
    }
    return ok(EVENT_SUBSCRIPTION_REMOVED).build();
}
#end_block

#method_before
@Path("{subnetUUID}")
@DELETE
public Response deleteSingleSubnet(@PathParam("subnetUUID") String id) throws IOException {
    try {
        SubnetId subId = SubnetId.subnetId(id);
        Set<SubnetId> subIds = new HashSet<>();
        subIds.add(subId);
        get(SubnetService.class).removeSubnets(subIds);
        return Response.noContent().entity("SUCCESS").build();
    } catch (Exception e) {
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@DELETE
@Path("{subnetUUID}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deleteSingleSubnet(@PathParam("subnetUUID") String id) throws IOException {
    try {
        SubnetId subId = SubnetId.subnetId(id);
        Set<SubnetId> subIds = new HashSet<>();
        subIds.add(subId);
        get(SubnetService.class).removeSubnets(subIds);
        return Response.noContent().entity("SUCCESS").build();
    } catch (Exception e) {
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
@Path("{portUUID}")
@DELETE
public Response deletePorts(@PathParam("portUUID") String id) {
    Set<VirtualPortId> vPortIds = new HashSet<>();
    try {
        if (id != null) {
            vPortIds.add(VirtualPortId.portId(id));
        }
        Boolean issuccess = nullIsNotFound(get(VirtualPortService.class).removePorts(vPortIds), VPORT_NOT_FOUND);
        if (!issuccess) {
            return Response.status(INTERNAL_SERVER_ERROR).entity(VPORT_ID_NOT_EXIST).build();
        }
        return Response.noContent().entity(issuccess.toString()).build();
    } catch (Exception e) {
        log.error("Deletes VirtualPort failed because of exception {}", e.toString());
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#method_after
@DELETE
@Path("{portUUID}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deletePorts(@PathParam("portUUID") String id) {
    Set<VirtualPortId> vPortIds = new HashSet<>();
    try {
        if (id != null) {
            vPortIds.add(VirtualPortId.portId(id));
        }
        Boolean issuccess = nullIsNotFound(get(VirtualPortService.class).removePorts(vPortIds), VPORT_NOT_FOUND);
        if (!issuccess) {
            return Response.status(INTERNAL_SERVER_ERROR).entity(VPORT_ID_NOT_EXIST).build();
        }
        return ok(issuccess.toString()).build();
    } catch (Exception e) {
        log.error("Deletes VirtualPort failed because of exception {}", e.toString());
        return Response.status(INTERNAL_SERVER_ERROR).entity(e.toString()).build();
    }
}
#end_block

#method_before
@Path("{routerUUID}")
@DELETE
public Response deleteSingleRouter(@PathParam("routerUUID") String id) throws IOException {
    try {
        RouterId routerId = RouterId.valueOf(id);
        Set<RouterId> routerIds = Sets.newHashSet(routerId);
        get(RouterService.class).removeRouters(routerIds);
        return Response.noContent().entity(DELETE_SUCCESS).build();
    } catch (Exception e) {
        return Response.status(BAD_REQUEST).entity(e.getMessage()).build();
    }
}
#method_after
@DELETE
@Path("{routerUUID}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deleteSingleRouter(@PathParam("routerUUID") String id) throws IOException {
    try {
        RouterId routerId = RouterId.valueOf(id);
        Set<RouterId> routerIds = Sets.newHashSet(routerId);
        get(RouterService.class).removeRouters(routerIds);
        return Response.noContent().entity(DELETE_SUCCESS).build();
    } catch (Exception e) {
        return Response.status(BAD_REQUEST).entity(e.getMessage()).build();
    }
}
#end_block

#method_before
@DELETE
@Path("{id}")
public Response deleteNetworks(@PathParam("id") String id) {
    log.debug("Deletes network by identifier {}.", id);
    Set<TenantNetworkId> networkSet = new HashSet<>();
    networkSet.add(TenantNetworkId.networkId(id));
    Boolean issuccess = nullIsNotFound(get(TenantNetworkService.class).removeNetworks(networkSet), NETWORK_NOT_FOUND);
    if (!issuccess) {
        log.debug("Network identifier {} is not existed", id);
        return Response.status(INTERNAL_SERVER_ERROR).entity(NETWORK_ID_NOT_EXIST).build();
    }
    return Response.noContent().entity(issuccess.toString()).build();
}
#method_after
@DELETE
@Path("{id}")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deleteNetworks(@PathParam("id") String id) {
    log.debug("Deletes network by identifier {}.", id);
    Set<TenantNetworkId> networkSet = new HashSet<>();
    networkSet.add(TenantNetworkId.networkId(id));
    Boolean issuccess = nullIsNotFound(get(TenantNetworkService.class).removeNetworks(networkSet), NETWORK_NOT_FOUND);
    if (!issuccess) {
        log.debug("Network identifier {} is not existed", id);
        return Response.status(INTERNAL_SERVER_ERROR).entity(NETWORK_ID_NOT_EXIST).build();
    }
    return ok(issuccess.toString()).build();
}
#end_block

#method_before
private void modifyBasicInterfaceForwarding(Interface intf, boolean install) {
    log.debug("Adding interface objectives for {}", intf);
    DeviceId deviceId = controlPlaneConnectPoint.deviceId();
    PortNumber controlPlanePort = controlPlaneConnectPoint.port();
    this.modifyBasicFlows(deviceId, controlPlanePort, intf, intf.ipAddresses(), install);
}
#method_after
private void modifyBasicInterfaceForwarding(Interface intf, boolean install) {
    log.debug("Adding interface objectives for {}", intf);
    DeviceId deviceId = controlPlaneConnectPoint.deviceId();
    PortNumber controlPlanePort = controlPlaneConnectPoint.port();
    for (InterfaceIpAddress ip : intf.ipAddresses()) {
        // create nextObjectives for forwarding to this interface and the
        // controlPlaneConnectPoint
        int cpNextId, intfNextId;
        if (intf.vlan() == VlanId.NONE) {
            cpNextId = modifyNextObjective(deviceId, controlPlanePort, VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN), true, install);
            intfNextId = modifyNextObjective(deviceId, intf.connectPoint().port(), VlanId.vlanId(SingleSwitchFibInstaller.ASSIGNED_VLAN), true, install);
        } else {
            cpNextId = modifyNextObjective(deviceId, controlPlanePort, intf.vlan(), false, install);
            intfNextId = modifyNextObjective(deviceId, intf.connectPoint().port(), intf.vlan(), false, install);
        }
        // IPv4 to router
        TrafficSelector toSelector = DefaultTrafficSelector.builder().matchInPort(intf.connectPoint().port()).matchEthDst(intf.mac()).matchEthType(EthType.EtherType.IPV4.ethType().toShort()).matchVlanId(intf.vlan()).matchIPDst(ip.ipAddress().toIpPrefix()).build();
        flowObjectiveService.forward(deviceId, buildForwardingObjective(toSelector, null, cpNextId, install));
        // IPv4 from router
        TrafficSelector fromSelector = DefaultTrafficSelector.builder().matchInPort(controlPlanePort).matchEthSrc(intf.mac()).matchVlanId(intf.vlan()).matchEthType(EthType.EtherType.IPV4.ethType().toShort()).matchIPSrc(ip.ipAddress().toIpPrefix()).build();
        flowObjectiveService.forward(deviceId, buildForwardingObjective(fromSelector, null, intfNextId, install));
        // ARP to router
        toSelector = DefaultTrafficSelector.builder().matchInPort(intf.connectPoint().port()).matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchVlanId(intf.vlan()).build();
        TrafficTreatment puntTreatment = DefaultTrafficTreatment.builder().punt().build();
        flowObjectiveService.forward(deviceId, buildForwardingObjective(toSelector, puntTreatment, cpNextId, install));
        // ARP from router
        fromSelector = DefaultTrafficSelector.builder().matchInPort(controlPlanePort).matchEthSrc(intf.mac()).matchVlanId(intf.vlan()).matchEthType(EthType.EtherType.ARP.ethType().toShort()).matchArpSpa(ip.ipAddress().getIp4Address()).build();
        flowObjectiveService.forward(deviceId, buildForwardingObjective(fromSelector, puntTreatment, intfNextId, install));
    }
}
#end_block

#method_before
private void updateInterface(Interface prevIntf, Interface intf) {
    if (!prevIntf.vlan().equals(intf.vlan())) {
        removeInterface(prevIntf);
        provisionInterface(intf);
    }
    if (!prevIntf.mac().equals(intf)) {
        modifyBasicInterfaceForwarding(prevIntf, false);
        modifyBasicInterfaceForwarding(intf, true);
    } else {
        List<Set<InterfaceIpAddress>> listIpAddress = this.getAddRemoveElements(prevIntf.ipAddresses(), intf.ipAddresses());
        DeviceId deviceId = controlPlaneConnectPoint.deviceId();
        PortNumber controlPlanePort = controlPlaneConnectPoint.port();
        // removing flows with match parameter present in previous subject
        modifyBasicFlows(deviceId, controlPlanePort, prevIntf, listIpAddress.get(0), false);
        // adding flows with match parameter present in event subject
        modifyBasicFlows(deviceId, controlPlanePort, intf, listIpAddress.get(1), true);
    }
}
#method_after
private void updateInterface(Interface prevIntf, Interface intf) {
    if (!prevIntf.vlan().equals(intf.vlan()) || !prevIntf.mac().equals(intf)) {
        removeInterface(prevIntf);
        provisionInterface(intf);
    } else {
        List<InterfaceIpAddress> removeIps = prevIntf.ipAddressesList().stream().filter(pre -> !intf.ipAddressesList().contains(pre)).collect(Collectors.toList());
        List<InterfaceIpAddress> addIps = intf.ipAddressesList().stream().filter(cur -> !prevIntf.ipAddressesList().contains(cur)).collect(Collectors.toList());
        // removing flows with match parameters present in previous subject
        modifyBasicInterfaceForwarding(new Interface(prevIntf.name(), prevIntf.connectPoint(), removeIps, prevIntf.mac(), prevIntf.vlan()), false);
        // adding flows with match parameters present in event subject
        modifyBasicInterfaceForwarding(new Interface(intf.name(), intf.connectPoint(), addIps, intf.mac(), intf.vlan()), true);
    }
}
#end_block

#method_before
@Override
public void event(InterfaceEvent event) {
    Interface intf = event.subject();
    Interface prevIntf = event.prevSubject();
    switch(event.type()) {
        case INTERFACE_ADDED:
            if (intf != null && !intf.connectPoint().equals(controlPlaneConnectPoint)) {
                provisionInterface(intf);
            }
            break;
        case INTERFACE_UPDATED:
            updateInterface(prevIntf, intf);
            break;
        case INTERFACE_REMOVED:
            if (intf != null && !intf.connectPoint().equals(controlPlaneConnectPoint)) {
                removeInterface(intf);
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(InterfaceEvent event) {
    Interface intf = event.subject();
    Interface prevIntf = event.prevSubject();
    switch(event.type()) {
        case INTERFACE_ADDED:
            if (intf != null && !intf.connectPoint().equals(controlPlaneConnectPoint)) {
                provisionInterface(intf);
            }
            break;
        case INTERFACE_UPDATED:
            if (intf != null && !intf.connectPoint().equals(controlPlaneConnectPoint)) {
                updateInterface(prevIntf, intf);
            }
            break;
        case INTERFACE_REMOVED:
            if (intf != null && !intf.connectPoint().equals(controlPlaneConnectPoint)) {
                removeInterface(intf);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public int cleanupTable(String tableName) throws Bmv2RuntimeException {
    LOG.debug("Starting table cleanup... > deviceId={}, tableName={}", deviceId, tableName);
    List<Long> entryIds = getInstalledEntryIds(tableName);
    int count = 0;
    for (Long entryId : entryIds) {
        try {
            deleteTableEntry(tableName, entryId);
            count++;
        } catch (Bmv2RuntimeException e) {
        // Do nothing, we log this at the end.
        }
    }
    if (count < entryIds.size()) {
        LOG.warn("Not all entries have been deleted during table cleanup ({} out of {})" + " > deviceId={}, tableName={}", count, entryIds.size(), deviceId, tableName);
    }
    return count;
}
#method_after
@Override
public int cleanupTable(String tableName) throws Bmv2RuntimeException {
    LOG.debug("Starting table cleanup... > deviceId={}, tableName={}", deviceId, tableName);
    List<Long> entryIds = getInstalledEntryIds(tableName);
    int count = 0;
    for (Long entryId : entryIds) {
        try {
            standardClient.bm_mt_delete_entry(CONTEXT_ID, tableName, entryId);
            count++;
        } catch (TException e) {
            LOG.warn("Exception while deleting entry: {} > deviceId={}, tableName={}, entryId={}", e.toString(), deviceId, tableName, entryId);
        }
    }
    return count;
}
#end_block

#method_before
public static PcepLspObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader lspObjHeader;
    int iPlspId;
    // 3-bits
    byte yOFlag;
    boolean bAFlag;
    boolean bRFlag;
    boolean bSFlag;
    boolean bDFlag;
    boolean bCFlag;
    // Optional TLV
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<>();
    lspObjHeader = PcepObjectHeader.read(cb);
    if (lspObjHeader.getObjClass() != PcepLspObjectVer1.LSP_OBJ_CLASS) {
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_6, PcepErrorDetailInfo.ERROR_VALUE_8);
    }
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(lspObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    Integer iTemp = tempCb.readInt();
    iPlspId = (iTemp & PLSPID_TEMP_SHIFT_VALUE) >> PLSPID_SHIFT_VALUE;
    Integer iX = (iTemp & CFLAG_TEMP_SHIFT_VALUE) >> CFLAG_SHIFT_VALUE;
    bCFlag = iX > 0;
    iX = (iTemp & OFLAG_TEMP_SHIFT_VALUE) >> OFLAG_SHIFT_VALUE;
    yOFlag = iX.byteValue();
    iX = (iTemp & AFLAG_TEMP_SHIFT_VALUE) >> AFLAG_SHIFT_VALUE;
    bAFlag = iX > 0;
    iX = (iTemp & RFLAG_TEMP_SHIFT_VALUE) >> RFLAG_SHIFT_VALUE;
    bRFlag = iX > 0;
    iX = (iTemp & SFLAG_TEMP_SHIFT_VALUE) >> SFLAG_SHIFT_VALUE;
    bSFlag = iX > 0;
    iX = iTemp & DFLAG_TEMP_SHIFT_VALUE;
    bDFlag = iX > 0;
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepLspObjectVer1(lspObjHeader, iPlspId, yOFlag, bAFlag, bRFlag, bSFlag, bDFlag, bCFlag, llOptionalTlv);
}
#method_after
public static PcepLspObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader lspObjHeader;
    int iPlspId;
    // 3-bits
    byte yOFlag;
    boolean bAFlag;
    boolean bRFlag;
    boolean bSFlag;
    boolean bDFlag;
    boolean bCFlag;
    // Optional TLV
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<>();
    lspObjHeader = PcepObjectHeader.read(cb);
    if (lspObjHeader.getObjClass() != PcepLspObjectVer1.LSP_OBJ_CLASS) {
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_6, PcepErrorDetailInfo.ERROR_VALUE_8);
    }
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(lspObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    Integer iTemp = tempCb.readInt();
    iPlspId = (iTemp & PLSPID_TEMP_SHIFT_VALUE) >> PLSPID_SHIFT_VALUE;
    bCFlag = ((iTemp & CFLAG_TEMP_SHIFT_VALUE) >> CFLAG_SHIFT_VALUE) > 0;
    Integer iX = (iTemp & OFLAG_TEMP_SHIFT_VALUE) >> OFLAG_SHIFT_VALUE;
    yOFlag = iX.byteValue();
    iX = (iTemp & AFLAG_TEMP_SHIFT_VALUE) >> AFLAG_SHIFT_VALUE;
    bAFlag = iX > 0;
    iX = (iTemp & RFLAG_TEMP_SHIFT_VALUE) >> RFLAG_SHIFT_VALUE;
    bRFlag = iX > 0;
    iX = (iTemp & SFLAG_TEMP_SHIFT_VALUE) >> SFLAG_SHIFT_VALUE;
    bSFlag = iX > 0;
    iX = iTemp & DFLAG_TEMP_SHIFT_VALUE;
    bDFlag = iX > 0;
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepLspObjectVer1(lspObjHeader, iPlspId, yOFlag, bAFlag, bRFlag, bSFlag, bDFlag, bCFlag, llOptionalTlv);
}
#end_block

#method_before
@Override
public void emit(OutboundPacket packet) {
    TrafficTreatment treatment = packet.treatment();
    treatment.allInstructions().forEach(inst -> {
        if (inst.type() == Instruction.Type.OUTPUT) {
            Instructions.OutputInstruction outInst = (Instructions.OutputInstruction) inst;
            if (outInst.port().isLogical()) {
                if (outInst.port() == PortNumber.FLOOD) {
                    LOG.info("Flood not implemented", outInst);
                }
                LOG.info("Output on logical port not supported: {}", outInst);
            } else {
                int portNumber = (int) outInst.port().toLong();
                send(portNumber, packet);
            }
        } else {
            LOG.info("Instruction type not supported: {}", inst.type().name());
        }
    });
}
#method_after
@Override
public void emit(OutboundPacket packet) {
    TrafficTreatment treatment = packet.treatment();
    treatment.allInstructions().forEach(inst -> {
        if (inst.type().equals(OUTPUT)) {
            Instructions.OutputInstruction outInst = (Instructions.OutputInstruction) inst;
            if (outInst.port().isLogical()) {
                if (outInst.port() == FLOOD) {
                    // TODO: implement flood
                    LOG.info("Flood not implemented", outInst);
                }
                LOG.info("Output on logical port not supported: {}", outInst);
            } else {
                try {
                    long longPort = outInst.port().toLong();
                    int portNumber = toIntExact(longPort);
                    send(portNumber, packet);
                } catch (ArithmeticException e) {
                    LOG.error("Port number overflow! Cannot send packet on port {} (long), as the bmv2" + " device only accepts int port values.");
                }
            }
        } else {
            LOG.info("Instruction type not supported: {}", inst.type().name());
        }
    });
}
#end_block

#method_before
public static List<DeviceInterfaceDescription> getInterfacesFromConfig(HierarchicalConfiguration cfg) {
    List<DeviceInterfaceDescription> intfs = Lists.newArrayList();
    List<HierarchicalConfiguration> subtrees = cfg.configurationsAt("data.xml-config-data.Device-Configuration.interface");
    for (HierarchicalConfiguration intfConfig : subtrees) {
        String intfName = getInterfaceName(intfConfig);
        DeviceInterfaceDescription.Mode intfMode = getInterfaceMode(intfConfig);
        List<VlanId> intfVlans = getInterfaceVlans(intfConfig, intfMode);
        short intfLimit = getInterfaceLimit(intfConfig);
        boolean intfLimited = (intfLimit == NO_LIMIT ? false : true);
        DeviceInterfaceDescription intf = new DefaultDeviceInterfaceDescription(intfName, intfMode, intfVlans, intfLimited, intfLimit);
        intfs.add(intf);
    }
    return intfs;
}
#method_after
/**
 * Parses device configuration and returns the descriptions of the device
 * interfaces.
 *
 * @param cfg an hierarchical configuration
 * @return list of interface descriptions for the device
 */
public static List<DeviceInterfaceDescription> getInterfacesFromConfig(HierarchicalConfiguration cfg) {
    List<DeviceInterfaceDescription> intfs = Lists.newArrayList();
    List<HierarchicalConfiguration> subtrees = cfg.configurationsAt("data.xml-config-data.Device-Configuration.interface");
    for (HierarchicalConfiguration intfConfig : subtrees) {
        String intfName = getInterfaceName(intfConfig);
        DeviceInterfaceDescription.Mode intfMode = getInterfaceMode(intfConfig);
        List<VlanId> intfVlans = getInterfaceVlans(intfConfig, intfMode);
        short intfLimit = getInterfaceLimit(intfConfig);
        boolean intfLimited = (intfLimit == NO_LIMIT ? false : true);
        DeviceInterfaceDescription intf = new DefaultDeviceInterfaceDescription(intfName, intfMode, intfVlans, intfLimited, intfLimit);
        intfs.add(intf);
    }
    return intfs;
}
#end_block

#method_before
@Override
public void removeIntentsByAppId(ApplicationId appId) {
    if (!isElectedLeader) {
        // Only leader will withdraw intents
        return;
    }
    log.debug("Intent Synchronizer shutdown: withdrawing intents for app {}...", appId);
    intents.entrySet().stream().filter(intent -> intent.getValue().appId().equals(appId)).forEach(intent -> {
        intentService.withdraw(intent.getValue());
        log.debug("Intent Synchronizer withdrawing intent: {}", intent);
    });
    intents.clear();
    log.info("Tried to clean all intents");
}
#method_after
@Override
public void removeIntentsByAppId(ApplicationId appId) {
    if (!isElectedLeader) {
        // Only leader will withdraw intents
        return;
    }
    log.debug("Withdrawing intents for app {}...", appId);
    intents.entrySet().stream().filter(intent -> intent.getValue().appId().equals(appId)).forEach(intent -> {
        log.debug("Intent Synchronizer withdrawing intent: {}", intent);
        intentService.withdraw(intent.getValue());
        intents.remove(intent.getKey(), intent.getValue());
        log.info("Tried to clean intents for app: {}", appId);
    });
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(VPLS_APP);
    intentInstaller = new IntentInstaller(appId, intentService, intentSynchronizer);
    applicationService.registerDeactivateHook(appId, () -> {
        intentSynchronizerAdmin.removeIntentsByAppId(appId);
    });
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    setupConnectivity();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(VPLS_APP);
    intentInstaller = new IntentInstaller(appId, intentService, intentSynchronizer);
    applicationService.registerDeactivateHook(appId, () -> {
        intentSynchronizer.removeIntentsByAppId(appId);
    });
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    setupConnectivity();
    log.info("Started");
}
#end_block

#method_before
@Activate
protected void activate() {
    components.forEach(name -> componentService.activate(appId, name));
    appId = coreService.registerApplication(SDN_IP_APP);
    peerConnectivity = new PeerConnectivityManager(appId, intentSynchronizer, networkConfigService, coreService.registerApplication(RoutingService.ROUTER_APP_ID), interfaceService);
    peerConnectivity.start();
    applicationService.registerDeactivateHook(appId, () -> {
        intentSynchronizerAdmin.removeIntentsByAppId(appId);
    });
    log.info("SDN-IP started");
}
#method_after
@Activate
protected void activate() {
    components.forEach(name -> componentService.activate(appId, name));
    appId = coreService.registerApplication(SDN_IP_APP);
    peerConnectivity = new PeerConnectivityManager(appId, intentSynchronizer, networkConfigService, coreService.registerApplication(RoutingService.ROUTER_APP_ID), interfaceService);
    peerConnectivity.start();
    applicationService.registerDeactivateHook(appId, () -> {
        intentSynchronizer.removeIntentsByAppId(appId);
    });
    log.info("SDN-IP started");
}
#end_block

#method_before
// ===============-=-=-=-=-=-======================-=-=-=-=-=-=-================================
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
    pathService = directory.get(PathService.class);
    topologyService = directory.get(TopologyService.class);
    deviceService = directory.get(DeviceService.class);
    linkData = new GeoDistanceLinkWeight(directory.get(DeviceService.class));
    addListeners();
}
#method_after
@Override
public void init(UiConnection connection, ServiceDirectory directory) {
    super.init(connection, directory);
// TODO: Need add listeners.
// topologyService = directory.get(TopologyService.class);
// addListeners();
}
#end_block

#method_before
@Override
protected Collection<RequestHandler> createRequestHandlers() {
    return ImmutableSet.of(new ClearHandler(), new SetSrcHandler(), new SetDstHandler(), new SetModeHandler());
}
#method_after
@Override
protected Collection<RequestHandler> createRequestHandlers() {
    return ImmutableSet.of(new ClearHandler(), new SetSrcHandler(), new SetDstHandler(), new SetPathHandler());
}
#end_block

#method_before
private void findAndSendPaths() {
    log.info("src={}; dst={}; mode={}", src, dst);
    if (src != null && dst != null) {
        // TBD: Need to call pathcalulation API here
        hilightAndSendPaths();
    }
}
#method_after
private void findAndSendPaths() {
    log.info("src={}; dst={};", src, dst);
    if (src != null && dst != null) {
        // TBD: Need to call pathcalulation API here
        hilightAndSendPaths();
    }
}
#end_block

#method_before
private ImmutableSet.Builder<Link> buildPaths(ImmutableSet.Builder<Link> pathBuilder) {
    paths.forEach(path -> path.links().forEach(pathBuilder::add));
    return pathBuilder;
}
#method_after
// TODO: The below code is not used. Once get path from PCE app then below code will be use.
// the below code will get path and it will highlight the selected path.
// Currently primary path in use, there is no use of secondary path.
private ImmutableSet.Builder<Link> buildPaths(ImmutableSet.Builder<Link> pathBuilder) {
    paths.forEach(path -> path.links().forEach(pathBuilder::add));
    return pathBuilder;
}
#end_block

#method_before
private void hilightAndSendPaths() {
    PceWebLinkMap linkMap = new PceWebLinkMap();
    allPathLinks.forEach(linkMap::add);
    Set<Link> selectedPathLinks;
    selectedPathLinks = paths.isEmpty() ? ImmutableSet.of() : ImmutableSet.copyOf(paths.get(pathIndex).links());
    // import org.onosproject.net.AnnotationKeys;
    // import org.onosproject.net.Annotations;
    // import org.onosproject.net.Device;
    Highlights highlights = new Highlights();
    if (highlightDelay > 0) {
        highlights.delay(highlightDelay);
    }
    for (PceWebLink plink : linkMap.biLinks()) {
        plink.computeHilight(selectedPathLinks, allPathLinks);
        highlights.add(plink.highlight(null));
    }
    if (src != null) {
        highlights = addBadge(highlights, srcType, src.toString(), SRC);
    }
    if (dst != null) {
        highlights = addBadge(highlights, dstType, dst.toString(), DST);
    }
    sendMessage(TopoJson.highlightsMessage(highlights));
}
#method_after
private void hilightAndSendPaths() {
    PceWebLinkMap linkMap = new PceWebLinkMap();
    allPathLinks.forEach(linkMap::add);
    Set<Link> selectedPathLinks;
    selectedPathLinks = paths.isEmpty() ? ImmutableSet.of() : ImmutableSet.copyOf(paths.get(pathIndex).links());
    Highlights highlights = new Highlights();
    if (highlightDelay > 0) {
        highlights.delay(highlightDelay);
    }
    for (PceWebLink plink : linkMap.biLinks()) {
        plink.computeHilight(selectedPathLinks, allPathLinks);
        highlights.add(plink.highlight(null));
    }
    if (src != null) {
        highlights = addBadge(highlights, srcType, src.toString(), SRC);
    }
    if (dst != null) {
        highlights = addBadge(highlights, dstType, dst.toString(), DST);
    }
    sendMessage(TopoJson.highlightsMessage(highlights));
}
#end_block

#method_before
@Override
public void deactivate() {
    super.deactivate();
    log.debug("PCE WEB Deactivated");
}
#method_after
@Override
public void deactivate() {
    super.deactivate();
    log.debug("Deactivated");
}
#end_block

#method_before
@Override
public void modifyDeviceDetails(PropertyPanel pp, DeviceId deviceId) {
    pp.title(MY_TITLE);
    log.info("Modify device details called.");
    DeviceService deviceService = AbstractShellCommand.get(DeviceService.class);
    pp.removeProps(LATITUDE, LONGITUDE, VENDOR, HW_VERSION, SW_VERSION, SERIAL_NUMBER, PROTOCOL, FLOWS, TUNNELS, PORTS);
    pp.addButton(SRC_BUTTON).addButton(DST_BUTTON);
    pp.removeButtons(CoreButtons.SHOW_PORT_VIEW).removeButtons(CoreButtons.SHOW_GROUP_VIEW).removeButtons(CoreButtons.SHOW_METER_VIEW);
    if (deviceService != null) {
        Device device = deviceService.getDevice(deviceId);
        Annotations annot = device.annotations();
        String routerId = annot.value(AnnotationKeys.ROUTER_ID);
        String type = annot.value(AnnotationKeys.TYPE);
        String asNumber = annot.value(AS_NUMBER);
        String domain = annot.value(DOMAIN_IDENTIFIER);
        String routingUnverse = annot.value(ROUTING_UNIVERSE);
        if (type != null) {
            pp.addProp("Type", type);
        }
        /* TBD: Router ID need to print
            if (routerId != null) {
                pp.addProp("Router-ID", routerId);
            } */
        if (routingUnverse != null) {
            pp.addProp("Routing Universe", routingUnverse);
        }
        if (asNumber != null) {
            pp.addProp("AS Number", asNumber);
        }
        if (domain != null) {
            pp.addProp("Domain ID", domain);
        }
    }
}
#method_after
@Override
public void modifyDeviceDetails(PropertyPanel pp, DeviceId deviceId) {
    pp.title(MY_TITLE);
    log.info("Modify device details called.");
    DeviceService deviceService = AbstractShellCommand.get(DeviceService.class);
    pp.removeAllProps();
    pp.addButton(SRC_BUTTON).addButton(DST_BUTTON);
    pp.removeButtons(CoreButtons.SHOW_PORT_VIEW).removeButtons(CoreButtons.SHOW_GROUP_VIEW).removeButtons(CoreButtons.SHOW_METER_VIEW);
    if (deviceService != null) {
        Device device = deviceService.getDevice(deviceId);
        Annotations annot = device.annotations();
        String routerId = annot.value(AnnotationKeys.ROUTER_ID);
        String type = annot.value(AnnotationKeys.TYPE);
        String asNumber = annot.value(AS_NUMBER);
        String domain = annot.value(DOMAIN_IDENTIFIER);
        String routingUnverse = annot.value(ROUTING_UNIVERSE);
        if (type != null) {
            pp.addProp("Type", type);
        }
        /* TBD: Router ID need to print
            if (routerId != null) {
                pp.addProp("Router-ID", routerId);
            } */
        if (routingUnverse != null) {
            pp.addProp("Routing Universe", routingUnverse);
        }
        if (asNumber != null) {
            pp.addProp("AS Number", asNumber);
        }
        if (domain != null) {
            pp.addProp("Domain ID", domain);
        }
    }
}
#end_block

#method_before
// Global node SID
/*    private void pushGlobalNodeLabel(PcepClient pc, DeviceId deviceId, LabelResourceId labelId) {
        LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();

        //for node sid itz IPv4 FEC to take lsr_id??
        PcepFecObjectIPv4 fecObject = pc.factory().buildFecObjectIpv4()
                //IPv4 node ID
        .setNodeID()
        .build();

        //TODO:use SRPID generators to generate SRPID
        PcepSrpObject srpObj = pc.factory().buildSrpObject()
                .setRFlag(false)
        .setSrpID(SrpIdGenerators.create())
        .build();

        //List of label object [In SR case nexthop address not required because FEC carries dat info]
        PcepLabelObject labelObject = pc.factory().buildLabelObject()
        .setLabel((int) labelId.labelId())
        .build();

        PcepLabelMap labelMap = new PcepLabelMap();
        labelMap.setFecObject(fecObject);
        labelMap.setLabelObject(labelObject);
        labelMap.setSrpObject(srpObj);

        labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject()
                .setLabelMap(labelMap)
                .build());

        PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg()
                .setPcLabelUpdateList(labelUpdateList)
                .build();
        pc.sendMessage(labelMsg);
    }*/
private PcepClient getPcepClient(DeviceId deviceId) {
    PcepClient pcc;
    /*   Set<TeRouterId> lrsIds = resourceService.getAvailableResourceValues(Resources
                .discrete(deviceId()).id(), TeRouterId.class);

        lrsIds.forEach(lsrId ->
        {
            if (pcepController.getClient(PccId.pccId(lsrId)) != null) {
                pcc = pcepController.getClient(PccId.pccId(lsrId));
                return pcc
            }
        });*/
    return null;
}
#method_after
private PcepClient getPcepClient(DeviceId deviceId) {
    PcepClient pcc;
    /*   Set<TeRouterId> lrsIds = resourceService.getAvailableResourceValues(Resources
                .discrete(deviceId()).id(), TeRouterId.class);

        lrsIds.forEach(lsrId ->
        {
            if (pcepController.getClient(PccId.pccId(lsrId)) != null) {
                pcc = pcepController.getClient(PccId.pccId(lsrId));
                return pcc
            }
        });*/
    return null;
}
#end_block

#method_before
private void pushGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId, IpPrefix ipPrefix, Objective.Operation type) throws PcepParseException {
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client no found");
        return;
    }
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    PcepFecObjectIPv4 fecObject = pc.factory().buildFecObjectIpv4().setNodeID(ipPrefix.address().getIp4Address().toInt()).build();
    PcepSrpObject srpObj = getSrpObject(pc, type);
    // Global NODE-SID as label object
    PcepLabelObject labelObject = pc.factory().buildLabelObject().setLabel((int) labelId.labelId()).build();
    PcepLabelMap labelMap = new PcepLabelMap();
    labelMap.setFecObject(fecObject);
    labelMap.setLabelObject(labelObject);
    labelMap.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelMap(labelMap).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
}
#method_after
private void pushGlobalNodeLabel(DeviceId deviceId, LabelResourceId labelId, IpPrefix ipPrefix, Objective.Operation type) throws PcepParseException {
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client not found");
        return;
    }
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    PcepFecObjectIPv4 fecObject = pc.factory().buildFecObjectIpv4().setNodeID(ipPrefix.address().getIp4Address().toInt()).build();
    PcepSrpObject srpObj = getSrpObject(pc, type);
    // Global NODE-SID as label object
    PcepLabelObject labelObject = pc.factory().buildLabelObject().setLabel((int) labelId.labelId()).build();
    PcepLabelMap labelMap = new PcepLabelMap();
    labelMap.setFecObject(fecObject);
    labelMap.setLabelObject(labelObject);
    labelMap.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelMap(labelMap).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
}
#end_block

#method_before
private void pushAdjacencyLabel(DeviceId deviceId, LabelResourceId labelId, PortNumber srcPortNum, PortNumber dstPortNum, Objective.Operation type) throws PcepParseException {
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client no found");
        return;
    }
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    // TODO: convert portNum i,e 32nd bit shld be masked
    PcepFecObjectIPv4Adjacency fecAdjObject = pc.factory().buildFecIpv4Adjacency().seRemoteIPv4Address((int) dstPortNum.toLong()).seLocalIPv4Address((int) srcPortNum.toLong()).build();
    PcepSrpObject srpObj = getSrpObject(pc, type);
    // Adjacency label object
    PcepLabelObject labelObject = pc.factory().buildLabelObject().setLabel((int) labelId.labelId()).build();
    PcepLabelMap labelMap = new PcepLabelMap();
    labelMap.setFecObject(fecAdjObject);
    labelMap.setLabelObject(labelObject);
    labelMap.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelMap(labelMap).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
}
#method_after
private void pushAdjacencyLabel(DeviceId deviceId, LabelResourceId labelId, PortNumber srcPortNum, PortNumber dstPortNum, Objective.Operation type) throws PcepParseException {
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client not found");
        return;
    }
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    long srcPortNo = srcPortNum.toLong();
    long dstPortNo = dstPortNum.toLong();
    srcPortNo = ((srcPortNo & IDENTIFIER_SET) == IDENTIFIER_SET) ? srcPortNo & SET : srcPortNo;
    dstPortNo = ((dstPortNo & IDENTIFIER_SET) == IDENTIFIER_SET) ? dstPortNo & SET : dstPortNo;
    PcepFecObjectIPv4Adjacency fecAdjObject = pc.factory().buildFecIpv4Adjacency().seRemoteIPv4Address((int) dstPortNo).seLocalIPv4Address((int) srcPortNo).build();
    PcepSrpObject srpObj = getSrpObject(pc, type);
    // Adjacency label object
    PcepLabelObject labelObject = pc.factory().buildLabelObject().setLabel((int) labelId.labelId()).build();
    PcepLabelMap labelMap = new PcepLabelMap();
    labelMap.setFecObject(fecAdjObject);
    labelMap.setLabelObject(labelObject);
    labelMap.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelMap(labelMap).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
}
#end_block

#method_before
private void pushLocalLabels(DeviceId deviceId, LabelResourceId labelId, PortNumber portNum, TunnelId tunnelId, Boolean isBos, Long labelType, Objective.Operation type) throws PcepParseException {
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client no found");
        return;
    }
    PcepLspObject lspObj;
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    LinkedList<PcepLabelObject> labelObjects = new LinkedList<>();
    PcepSrpObject srpObj;
    PcepLabelDownload labelDownload = new PcepLabelDownload();
    LinkedList<PcepValueType> optionalTlv = new LinkedList<>();
    // TODO: convert portNum i,e 32nd bit shld be masked
    optionalTlv.add(NexthopIPv4addressTlv.of((int) portNum.toLong()));
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    PcepLabelObject labelObj = pc.factory().buildLabelObject().setOFlag(labelType == OUT_LABEL_TYPE ? true : false).setOptionalTlv(optionalTlv).setLabel((int) labelId.labelId()).build();
    // Check whether transit node or not
    if (!deviceId.equals(tunnel.path().src().deviceId()) && !deviceId.equals(tunnel.path().dst().deviceId())) {
        // Device is transit node
        if (labelType == IN_LABEL_TYPE) {
            // Store label object having IN label value
            this.labelObj = labelObj;
            return;
        }
        // Add IN label object
        labelObjects.add(this.labelObj);
    }
    // Add OUT label object in case of transit node
    labelObjects.add(labelObj);
    srpObj = getSrpObject(pc, type);
    String lspId = tunnel.annotations().value(PcepAnnotationKeys.PLSP_ID);
    String plspId = tunnel.annotations().value(PcepAnnotationKeys.LOCAL_LSP_ID);
    LinkedList<PcepValueType> tlvs = new LinkedList<>();
    StatefulIPv4LspIdentifiersTlv lspIdTlv = new StatefulIPv4LspIdentifiersTlv(((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt(), Short.valueOf(lspId), Short.valueOf(tunnelId.id()), 0, ((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt());
    tlvs.add(lspIdTlv);
    lspObj = pc.factory().buildLspObject().setRFlag(false).setAFlag(true).setDFlag(true).setPlspId(Integer.valueOf(plspId)).setOptionalTlv(tlvs).build();
    labelDownload.setLabelList(labelObjects);
    labelDownload.setLspObject(lspObj);
    labelDownload.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelDownload(labelDownload).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
    // If isBos is true, label download is done along the LSP, send PCEP update message.
    if (isBos) {
        sendPcepUpdateMsg(pc, lspObj, tunnel);
    }
}
#method_after
private void pushLocalLabels(DeviceId deviceId, LabelResourceId labelId, PortNumber portNum, TunnelId tunnelId, Boolean isBos, Long labelType, Objective.Operation type) throws PcepParseException {
    PcepClient pc = getPcepClient(deviceId);
    if (pc == null) {
        log.error("PCEP client not found");
        return;
    }
    PcepLspObject lspObj;
    LinkedList<PcepLabelUpdate> labelUpdateList = new LinkedList<>();
    LinkedList<PcepLabelObject> labelObjects = new LinkedList<>();
    PcepSrpObject srpObj;
    PcepLabelDownload labelDownload = new PcepLabelDownload();
    LinkedList<PcepValueType> optionalTlv = new LinkedList<>();
    long portNo = portNum.toLong();
    portNo = ((portNo & IDENTIFIER_SET) == IDENTIFIER_SET) ? portNo & SET : portNo;
    optionalTlv.add(NexthopIPv4addressTlv.of((int) portNo));
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    PcepLabelObject labelObj = pc.factory().buildLabelObject().setOFlag(labelType == OUT_LABEL_TYPE ? true : false).setOptionalTlv(optionalTlv).setLabel((int) labelId.labelId()).build();
    /**
     * Check whether transit node or not. For transit node, label update message should include IN and OUT labels.
     * Hence store IN label object and next when out label comes add IN and OUT label objects and encode label
     * update message and send to specified client.
     */
    if (!deviceId.equals(tunnel.path().src().deviceId()) && !deviceId.equals(tunnel.path().dst().deviceId())) {
        // Device is transit node
        if (labelType == IN_LABEL_TYPE) {
            // Store label object having IN label value
            this.labelObj = labelObj;
            return;
        }
        // Add IN label object
        labelObjects.add(this.labelObj);
    }
    // Add OUT label object in case of transit node
    labelObjects.add(labelObj);
    srpObj = getSrpObject(pc, type);
    String lspId = tunnel.annotations().value(PcepAnnotationKeys.PLSP_ID);
    String plspId = tunnel.annotations().value(PcepAnnotationKeys.LOCAL_LSP_ID);
    String tunnelIdentifier = tunnel.annotations().value(PcepAnnotationKeys.PCC_TUNNEL_ID);
    LinkedList<PcepValueType> tlvs = new LinkedList<>();
    StatefulIPv4LspIdentifiersTlv lspIdTlv = new StatefulIPv4LspIdentifiersTlv(((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt(), Short.valueOf(lspId), Short.valueOf(tunnelIdentifier), 0, ((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt());
    tlvs.add(lspIdTlv);
    lspObj = pc.factory().buildLspObject().setRFlag(false).setAFlag(true).setDFlag(true).setPlspId(Integer.valueOf(plspId)).setOptionalTlv(tlvs).build();
    labelDownload.setLabelList(labelObjects);
    labelDownload.setLspObject(lspObj);
    labelDownload.setSrpObject(srpObj);
    labelUpdateList.add(pc.factory().buildPcepLabelUpdateObject().setLabelDownload(labelDownload).build());
    PcepLabelUpdateMsg labelMsg = pc.factory().buildPcepLabelUpdateMsg().setPcLabelUpdateList(labelUpdateList).build();
    pc.sendMessage(labelMsg);
    // If isBos is true, label download is done along the LSP, send PCEP update message.
    if (isBos) {
        sendPcepUpdateMsg(pc, lspObj, tunnel);
    }
}
#end_block

#method_before
private void sendPcepUpdateMsg(PcepClient pc, PcepLspObject lspObj, Tunnel tunnel) throws PcepParseException {
    LinkedList<PcepUpdateRequest> updateRequestList = new LinkedList<>();
    LinkedList<PcepValueType> subObjects = createEroSubObj(tunnel.path());
    PcepSrpObject srpObj = pc.factory().buildSrpObject().setRFlag(false).setSrpID(SrpIdGenerators.create()).build();
    PcepEroObject eroObj = pc.factory().buildEroObject().setSubObjects(subObjects).build();
    // TODO: Set Bandwidth object in PCEP attribute??
    PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroObj).build();
    PcepUpdateRequest updateReq = pc.factory().buildPcepUpdateRequest().setSrpObject(srpObj).setMsgPath(msgPath).setLspObject(lspObj).build();
    updateRequestList.add(updateReq);
    // TODO: P = 1 is it P flag in PCEP obj header
    PcepUpdateMsg updateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(updateRequestList).build();
    pc.sendMessage(updateMsg);
}
#method_after
private void sendPcepUpdateMsg(PcepClient pc, PcepLspObject lspObj, Tunnel tunnel) throws PcepParseException {
    LinkedList<PcepUpdateRequest> updateRequestList = new LinkedList<>();
    LinkedList<PcepValueType> subObjects = createEroSubObj(tunnel.path());
    if (subObjects == null) {
        log.error("ERO subjects not present");
        return;
    }
    PcepSrpObject srpObj = pc.factory().buildSrpObject().setRFlag(false).setSrpID(SrpIdGenerators.create()).build();
    PcepEroObject eroObj = pc.factory().buildEroObject().setSubObjects(subObjects).build();
    PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroObj).build();
    PcepUpdateRequest updateReq = pc.factory().buildPcepUpdateRequest().setSrpObject(srpObj).setMsgPath(msgPath).setLspObject(lspObj).build();
    updateRequestList.add(updateReq);
    // TODO: P = 1 is it P flag in PCEP obj header
    PcepUpdateMsg updateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(updateRequestList).build();
    pc.sendMessage(updateMsg);
}
#end_block

#method_before
private LinkedList<PcepValueType> createEroSubObj(Path path) {
    LinkedList<PcepValueType> subObjects = new LinkedList<>();
    List<Link> links = path.links();
    ConnectPoint source = null;
    ConnectPoint destination = null;
    IpAddress ipDstAddress = null;
    IpAddress ipSrcAddress = null;
    PcepValueType subObj = null;
    for (Link link : links) {
        source = link.src();
        if (!(source.equals(destination))) {
            // set IPv4SubObject for ERO object
            ipSrcAddress = source.ipElementId().ipAddress();
            subObj = new IPv4SubObject(ipSrcAddress.getIp4Address().toInt());
            subObjects.add(subObj);
        }
        destination = link.dst();
        ipDstAddress = destination.ipElementId().ipAddress();
        subObj = new IPv4SubObject(ipDstAddress.getIp4Address().toInt());
        subObjects.add(subObj);
    }
    return subObjects;
}
#method_after
private LinkedList<PcepValueType> createEroSubObj(Path path) {
    LinkedList<PcepValueType> subObjects = new LinkedList<>();
    List<Link> links = path.links();
    ConnectPoint source = null;
    ConnectPoint destination = null;
    IpAddress ipDstAddress = null;
    IpAddress ipSrcAddress = null;
    PcepValueType subObj = null;
    long portNo;
    for (Link link : links) {
        source = link.src();
        if (!(source.equals(destination))) {
            // set IPv4SubObject for ERO object
            portNo = source.port().toLong();
            portNo = ((portNo & IDENTIFIER_SET) == IDENTIFIER_SET) ? portNo & SET : portNo;
            ipSrcAddress = Ip4Address.valueOf((int) portNo);
            subObj = new IPv4SubObject(ipSrcAddress.getIp4Address().toInt());
            subObjects.add(subObj);
        }
        destination = link.dst();
        portNo = destination.port().toLong();
        portNo = ((portNo & IDENTIFIER_SET) == IDENTIFIER_SET) ? portNo & SET : portNo;
        ipDstAddress = Ip4Address.valueOf((int) portNo);
        subObj = new IPv4SubObject(ipDstAddress.getIp4Address().toInt());
        subObjects.add(subObj);
    }
    return subObjects;
}
#end_block

#method_before
private void populateMetric(ChartModel.DataPoint dataPoint, Map<String, Object> data) {
    data.forEach((k, v) -> dataPoint.data(k, v));
}
#method_after
private void populateMetric(ChartModel.DataPoint dataPoint, Map<String, Object> data) {
    data.forEach(dataPoint::data);
}
#end_block

#method_before
private void attachDeviceList(ChartModel cm, Set<DeviceId> deviceIds) {
    ObjectNode root = new ObjectMapper().createObjectNode();
    ArrayNode array = root.putArray(DEVICE_IDS);
    deviceIds.forEach(id -> array.add(id.toString()));
    cm.addAnnotation(DEVICE_IDS, array);
}
#method_after
private void attachDeviceList(ChartModel cm, Set<DeviceId> deviceIds) {
    ArrayNode array = arrayNode();
    deviceIds.forEach(id -> array.add(id.toString()));
    cm.addAnnotation(DEVICE_IDS, array);
}
#end_block

#method_before
@Activate
public void activate() {
    coreService.registerApplication(APP_ID, this::preDeactivate);
    try {
        TServerTransport transport = new TServerSocket(DEFAULT_PORT);
        this.thriftServer = new TThreadPoolServer(new TThreadPoolServer.Args(transport).processor(trackingProcessor).maxWorkerThreads(10).executorService(executorService));
    } catch (TTransportException e) {
        LOG.error("Unable to start server", e);
    }
    LOG.info("Starting server...");
    executorService.execute(thriftServer::serve);
    LOG.info("Started");
}
#method_after
@Activate
public void activate() {
    coreService.registerApplication(APP_ID);
    try {
        TServerTransport transport = new TServerSocket(serverPort);
        LOG.info("Starting server on port {}...", serverPort);
        this.thriftServer = new TThreadPoolServer(new TThreadPoolServer.Args(transport).processor(trackingProcessor).executorService(executorService));
        executorService.execute(thriftServer::serve);
    } catch (TTransportException e) {
        LOG.error("Unable to start server", e);
    }
    LOG.info("Activated");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    preDeactivate();
    LOG.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    // Stop the server if running...
    if (thriftServer != null && !thriftServer.isServing()) {
        thriftServer.stop();
    }
    try {
        executorService.awaitTermination(1, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        LOG.error("Server threads did not terminate");
    }
    executorService.shutdownNow();
    LOG.info("Deactivated");
}
#end_block

#method_before
@Override
protected void execute() {
    CarrierEthernetVirtualConnectionManager evcManager = get(CarrierEthernetVirtualConnectionManager.class);
    evcManager.removeAllEvcs();
}
#method_after
@Override
protected void execute() {
    CarrierEthernetManager evcManager = get(CarrierEthernetManager.class);
    evcManager.removeAllEvcs();
}
#end_block

#method_before
@Override
protected void execute() {
    CarrierEthernetVirtualConnectionManager cem = get(CarrierEthernetVirtualConnectionManager.class);
    // Populate global UNI map
    cem.addGlobalUnis();
    printUnis(cem.getUniMap().values());
}
#method_after
@Override
protected void execute() {
    CarrierEthernetManager evcManager = get(CarrierEthernetManager.class);
    // Populate global UNI map
    evcManager.addGlobalUnis(evcManager.getGlobalUnis());
    printUnis(evcManager.getUniMap().values());
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("id", uniId).add("cfgId", uniCfgId).add("type", type).add("ceVlanIds", ceVlanIdSet).add("capacity", capacity).add("usedCapacity", usedCapacity).add("bandwidthProfiles", this.bwps()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("id", this.id).add("cfgId", this.cfgId).add("role", role).add("ceVlanIds", ceVlanIdSet).add("capacity", this.capacity).add("usedCapacity", this.usedCapacity).add("bandwidthProfiles", this.bwps()).toString();
}
#end_block

#method_before
@Override
public void setNodeForwarding(CarrierEthernetVirtualConnection service, CarrierEthernetUni srcUni, CarrierEthernetUni dstUni, ConnectPoint ingress, ConnectPoint egress, boolean first, boolean last) {
    // TODO: Produce error if ingress and egress do not belong to same device
    Set<ConnectPoint> egressCpSet = egressCpMap.get(service.id());
    if (egressCpSet == null) {
        egressCpSet = new HashSet<>();
    }
    Set<FlowRule> flowRuleSet = flowRuleMap.get(service.id());
    if (flowRuleSet == null) {
        flowRuleSet = new HashSet<>();
    }
    flowRuleSet.addAll(createFlowRules(service.id(), srcUni.ceVlanId(), service.vlanId(), ingress, egress, first, last));
    egressCpSet.add(egress);
    egressCpMap.put(service.id(), egressCpSet);
    flowRuleMap.put(service.id(), flowRuleSet);
}
#method_after
@Override
public void setNodeForwarding(CarrierEthernetVirtualConnection service, CarrierEthernetNetworkInterface srcNi, CarrierEthernetNetworkInterface dstNi, ConnectPoint ingress, ConnectPoint egress, boolean first, boolean last) {
    // TODO: Produce error if ingress and egress do not belong to same device
    Set<ConnectPoint> egressCpSet = egressCpMap.get(service.id());
    if (egressCpSet == null) {
        egressCpSet = new HashSet<>();
    }
    Set<FlowRule> flowRuleSet = flowRuleMap.get(service.id());
    if (flowRuleSet == null) {
        flowRuleSet = new HashSet<>();
    }
    // FIXME: Uncomment this after Hackathon
    flowRuleSet.addAll(createNrpFlowRule(service.id(), srcNi, dstNi, service.vlanId(), ingress, egress, first, last));
    /*flowRuleSet.addAll(createFlowRules(service.id(), ((CarrierEthernetUni) srcNi).ceVlanId(), service.vlanId(),
                ingress, egress, first, last));*/
    egressCpSet.add(egress);
    egressCpMap.put(service.id(), egressCpSet);
    flowRuleMap.put(service.id(), flowRuleSet);
}
#end_block

#method_before
@Override
void applyBandwidthProfileResources(String serviceId, CarrierEthernetUni uni) {
    Dpid dpid = Dpid.dpid(uni.cp().deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    // FIXME: Temporary hack: Do not apply meters to OFDPA2.0 switches
    if (sw.softwareDescription().equals("OF-DPA 2.0")) {
        return;
    }
    // Create meters and add them to global MeterId map
    Set<DeviceMeterId> deviceMeterIdSet = deviceMeterIdMap.get(serviceId);
    if (deviceMeterIdSet == null) {
        deviceMeterIdSet = new HashSet<>();
    }
    deviceMeterIdSet.addAll(createMeters(uni));
    deviceMeterIdMap.put(serviceId, deviceMeterIdSet);
    // Apply meters to already installed flows
    Set<FlowRule> newFlowRuleSet = new HashSet<>();
    // Get flow rules belonging to service and having as in_port the UNI connect point
    flowRuleMap.get(serviceId).forEach(flowRule -> {
        PortNumber inPort = ((PortCriterion) flowRule.selector().getCriterion(Criterion.Type.IN_PORT)).port();
        ConnectPoint flowInCp = new ConnectPoint(flowRule.deviceId(), inPort);
        // FIXME: Maybe check only in_port, vlanid, and if there is output port or group action?
        if (uni.cp().equals(flowInCp)) {
            // if (uni.cp().equals(flowInCp) && (uni.ceVlanId() == null || uni.ceVlanId().equals(flowInVlanId))) {
            // Need to add to the flow the meters associated with the same device
            Set<DeviceMeterId> tmpDeviceMeterIdSet = new HashSet<>();
            deviceMeterIdMap.get(serviceId).forEach(deviceMeterId -> {
                if (deviceMeterId.deviceId().equals(flowRule.deviceId())) {
                    tmpDeviceMeterIdSet.add(deviceMeterId);
                }
            });
            // Modify and submit flow rule only if there are meters to add
            if (!tmpDeviceMeterIdSet.isEmpty()) {
                FlowRule newFlowRule = addMetersToFlowRule(flowRule, tmpDeviceMeterIdSet);
                flowRuleService.applyFlowRules(newFlowRule);
                newFlowRuleSet.add(newFlowRule);
            } else {
                newFlowRuleSet.add(flowRule);
            }
        } else {
            newFlowRuleSet.add(flowRule);
        }
    });
    flowRuleMap.put(serviceId, newFlowRuleSet);
}
#method_after
@Override
void applyBandwidthProfileResources(String serviceId, CarrierEthernetUni uni) {
    log.info("Trying to apply BW profile resources for service {}", serviceId);
    Dpid dpid = Dpid.dpid(uni.cp().deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    // FIXME: Temporary hack: Do not apply meters to OFDPA2.0 switches
    if (sw.softwareDescription().equals("OF-DPA 2.0")) {
        return;
    }
    // Create meters and add them to global MeterId map
    Set<DeviceMeterId> deviceMeterIdSet = deviceMeterIdMap.get(serviceId);
    if (deviceMeterIdSet == null) {
        deviceMeterIdSet = new HashSet<>();
    }
    deviceMeterIdSet.addAll(createMeters(uni));
    deviceMeterIdMap.put(serviceId, deviceMeterIdSet);
    // Apply meters to already installed flows
    Set<FlowRule> newFlowRuleSet = new HashSet<>();
    // Get flow rules belonging to service and having as in_port the UNI connect point
    flowRuleMap.get(serviceId).forEach(flowRule -> {
        PortNumber inPort = ((PortCriterion) flowRule.selector().getCriterion(Criterion.Type.IN_PORT)).port();
        ConnectPoint flowInCp = new ConnectPoint(flowRule.deviceId(), inPort);
        // FIXME: Maybe check only in_port, vlanid, and if there is output port or group action?
        if (uni.cp().equals(flowInCp)) {
            // if (uni.cp().equals(flowInCp) && (uni.ceVlanId() == null || uni.ceVlanId().equals(flowInVlanId))) {
            // Need to add to the flow the meters associated with the same device
            Set<DeviceMeterId> tmpDeviceMeterIdSet = new HashSet<>();
            deviceMeterIdMap.get(serviceId).forEach(deviceMeterId -> {
                if (deviceMeterId.deviceId().equals(flowRule.deviceId())) {
                    tmpDeviceMeterIdSet.add(deviceMeterId);
                }
            });
            // Modify and submit flow rule only if there are meters to add
            if (!tmpDeviceMeterIdSet.isEmpty()) {
                FlowRule newFlowRule = addMetersToFlowRule(flowRule, tmpDeviceMeterIdSet);
                flowRuleService.applyFlowRules(newFlowRule);
                newFlowRuleSet.add(newFlowRule);
            } else {
                newFlowRuleSet.add(flowRule);
            }
        } else {
            newFlowRuleSet.add(flowRule);
        }
    });
    flowRuleMap.put(serviceId, newFlowRuleSet);
}
#end_block

#method_before
@Override
protected void execute() {
    CarrierEthernetVirtualConnectionManager evcManager = get(CarrierEthernetVirtualConnectionManager.class);
    evcManager.removeEvc(argServiceId);
}
#method_after
@Override
protected void execute() {
    CarrierEthernetManager evcManager = get(CarrierEthernetManager.class);
    evcManager.removeEvc(argServiceId);
}
#end_block

#method_before
// TODO: Get LTPs as input
public boolean setupConnectivity(CarrierEthernetUni uni1, CarrierEthernetUni uni2, CarrierEthernetVirtualConnection service) {
    // Find the paths for both directions at the same time, so that we can skip the pair if needed
    List<Link> forwardLinks = selectLinkPath(uni1, uni2, service);
    List<Link> backwardLinks = selectLinkPath(uni2, uni1, service);
    // Skip this UNI pair if no feasible path could be found
    if (forwardLinks == null || (!service.congruentPaths() && backwardLinks == null)) {
        log.warn("There are no feasible paths between {} and {}.", uni1.cp().deviceId(), uni2.cp().deviceId());
        return false;
    }
    // TODO: Send some kind of gRPC message to BigSwitches
    for (int i = 0; i < forwardLinks.size() - 1; i++) {
        // Create flows for the forward direction
        boolean first = isFirst(i);
        boolean last = isLast(forwardLinks, i);
        ConnectPoint ingress = forwardLinks.get(i).dst();
        ConnectPoint egress = forwardLinks.get(i + 1).src();
        // Set forwarding only on packet switches
        if (deviceService.getDevice(ingress.deviceId()).type().equals(Device.Type.SWITCH)) {
            ceOfPktNodeManager.setNodeForwarding(service, uni1, uni2, ingress, egress, first, last);
        }
        if (service.congruentPaths()) {
            // Create flows for the forward direction using the reverse path
            ingress = forwardLinks.get(forwardLinks.size() - i - 1).src();
            egress = forwardLinks.get(forwardLinks.size() - i - 2).dst();
            // TODO: Select node manager depending on device protocol
            if (deviceService.getDevice(ingress.deviceId()).type().equals(Device.Type.SWITCH)) {
                ceOfPktNodeManager.setNodeForwarding(service, uni2, uni1, ingress, egress, first, last);
            }
        }
    }
    if (!service.congruentPaths()) {
        // Create flows for the backward direction using a path potentially different from the reverse one
        for (int i = 0; i < backwardLinks.size() - 1; i++) {
            boolean first = isFirst(i);
            boolean last = isLast(backwardLinks, i);
            ConnectPoint ingress = backwardLinks.get(i).dst();
            ConnectPoint egress = backwardLinks.get(i + 1).src();
            // TODO: Select node manager depending on device protocol
            if (deviceService.getDevice(ingress.deviceId()).type().equals(Device.Type.SWITCH)) {
                ceOfPktNodeManager.setNodeForwarding(service, uni2, uni1, ingress, egress, first, last);
            }
        }
    }
    return true;
}
#method_after
// TODO: Get LTPs as input
public boolean setupConnectivity(CarrierEthernetNetworkInterface ni1, CarrierEthernetNetworkInterface ni2, CarrierEthernetVirtualConnection service) {
    // Find the paths for both directions at the same time, so that we can skip the pair if needed
    List<Link> forwardLinks = selectLinkPath(ni1, ni2, service);
    List<Link> backwardLinks = selectLinkPath(ni2, ni1, service);
    // Skip this UNI pair if no feasible path could be found
    if (forwardLinks == null || (!service.congruentPaths() && backwardLinks == null)) {
        log.warn("There are no feasible paths between {} and {}.", ni1.cp().deviceId(), ni2.cp().deviceId());
        return false;
    }
    // TODO: Send some kind of gRPC message to BigSwitches
    for (int i = 0; i < forwardLinks.size() - 1; i++) {
        // Create flows for the forward direction
        boolean first = isFirst(i);
        boolean last = isLast(forwardLinks, i);
        ConnectPoint ingress = forwardLinks.get(i).dst();
        ConnectPoint egress = forwardLinks.get(i + 1).src();
        // Set forwarding only on packet switches
        if (deviceService.getDevice(ingress.deviceId()).type().equals(Device.Type.SWITCH)) {
            ceOfPktNodeManager.setNodeForwarding(service, ni1, ni2, ingress, egress, first, last);
        }
        if (service.congruentPaths()) {
            // Create flows for the forward direction using the reverse path
            ingress = forwardLinks.get(forwardLinks.size() - i - 1).src();
            egress = forwardLinks.get(forwardLinks.size() - i - 2).dst();
            // TODO: Select node manager depending on device protocol
            if (deviceService.getDevice(ingress.deviceId()).type().equals(Device.Type.SWITCH)) {
                ceOfPktNodeManager.setNodeForwarding(service, ni2, ni1, ingress, egress, first, last);
            }
        }
    }
    if (!service.congruentPaths()) {
        // Create flows for the backward direction using a path potentially different from the reverse one
        for (int i = 0; i < backwardLinks.size() - 1; i++) {
            boolean first = isFirst(i);
            boolean last = isLast(backwardLinks, i);
            ConnectPoint ingress = backwardLinks.get(i).dst();
            ConnectPoint egress = backwardLinks.get(i + 1).src();
            // TODO: Select node manager depending on device protocol
            if (deviceService.getDevice(ingress.deviceId()).type().equals(Device.Type.SWITCH)) {
                ceOfPktNodeManager.setNodeForwarding(service, ni2, ni1, ingress, egress, first, last);
            }
        }
    }
    return true;
}
#end_block

#method_before
private List<Link> selectLinkPath(CarrierEthernetUni uni1, CarrierEthernetUni uni2, CarrierEthernetVirtualConnection service) {
    List<Constraint> constraints = ImmutableList.<Constraint>builder().add(new BandwidthConstraint(uni1.bwp().cir())).add(new LatencyConstraint(service.latency())).build();
    Set<Path> paths = pathService.getPaths(uni1.cp().deviceId(), uni2.cp().deviceId());
    Path path = null;
    for (Path p : paths) {
        // TODO: Select path in more sophisticated way and return null if any of the constraints cannot be met
        path = p;
        break;
    }
    if (path == null) {
        return null;
    } else {
        List<Link> links = new ArrayList<>();
        links.add(createEdgeLink(uni1.cp(), true));
        links.addAll(path.links());
        links.add(createEdgeLink(uni2.cp(), false));
        return links;
    }
}
#method_after
private List<Link> selectLinkPath(CarrierEthernetNetworkInterface ni1, CarrierEthernetNetworkInterface ni2, CarrierEthernetVirtualConnection service) {
    /*List<Constraint> constraints = ImmutableList.<Constraint>builder()
                .add(new BandwidthConstraint(uni1.bwp().cir()))
                .add(new LatencyConstraint(service.latency()))
                .build();*/
    Set<Path> paths = pathService.getPaths(ni1.cp().deviceId(), ni2.cp().deviceId());
    Path path = null;
    for (Path p : paths) {
        // TODO: Select path in more sophisticated way and return null if any of the constraints cannot be met
        path = p;
        break;
    }
    if (path == null) {
        return null;
    } else {
        List<Link> links = new ArrayList<>();
        links.add(createEdgeLink(ni1.cp(), true));
        links.addAll(path.links());
        links.add(createEdgeLink(ni2.cp(), false));
        return links;
    }
}
#end_block

#method_before
@Override
public int complete(String buffer, int cursor, List<String> candidates) {
    StringsCompleter delegate = new StringsCompleter();
    CarrierEthernetVirtualConnectionManager evcManager = AbstractShellCommand.get(CarrierEthernetVirtualConnectionManager.class);
    SortedSet<String> strings = delegate.getStrings();
    evcManager.evcMap().keySet().forEach(serviceId -> strings.add(serviceId));
    return delegate.complete(buffer, cursor, candidates);
}
#method_after
@Override
public int complete(String buffer, int cursor, List<String> candidates) {
    StringsCompleter delegate = new StringsCompleter();
    CarrierEthernetManager evcManager = AbstractShellCommand.get(CarrierEthernetManager.class);
    SortedSet<String> strings = delegate.getStrings();
    evcManager.evcMap().keySet().forEach(serviceId -> strings.add(serviceId));
    return delegate.complete(buffer, cursor, candidates);
}
#end_block

#method_before
// TODO: Add further arguments for VLAN tag preservation, CoS preservation etc.
@Override
protected void execute() {
    CarrierEthernetVirtualConnectionManager evcManager = get(CarrierEthernetVirtualConnectionManager.class);
    CarrierEthernetVirtualConnection evc = new CarrierEthernetVirtualConnection(argServiceId, argServiceCfgId, generateServiceType(), generateMaxNumUni(), generateUniSet());
    evcManager.establishConnectivity(evc);
}
#method_after
// TODO: Add further arguments for VLAN tag preservation, CoS preservation etc.
@Override
protected void execute() {
    CarrierEthernetManager evcManager = get(CarrierEthernetManager.class);
    CarrierEthernetVirtualConnection evc = new CarrierEthernetVirtualConnection(argServiceId, argServiceCfgId, generateServiceType(), generateMaxNumUni(), generateUniSet());
    evcManager.establishConnectivity(evc);
}
#end_block

#method_before
CarrierEthernetVirtualConnection.Type generateServiceType() {
    if (argServiceType == null) {
        return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT : CarrierEthernetVirtualConnection.Type.POINT_TO_POINT);
    } else {
        return CarrierEthernetVirtualConnection.Type.valueOf(argServiceType);
    }
}
#method_after
CarrierEthernetVirtualConnection.Type generateServiceType() {
    if (argServiceType == null) {
        return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.Type.MULTIPOINT_TO_MULTIPOINT : CarrierEthernetVirtualConnection.Type.POINT_TO_POINT);
    } else {
        // TODO: Catch exception
        return CarrierEthernetVirtualConnection.Type.fromString(argServiceType);
    }
}
#end_block

#method_before
Integer generateMaxNumUni() {
    if (argMaxNumUni == null) {
        if (argServiceType == null) {
            return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.MAX_NUM_UNI : 2);
        } else {
            return (CarrierEthernetVirtualConnection.Type.valueOf(argServiceType).equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT) ? 2 : CarrierEthernetVirtualConnection.MAX_NUM_UNI);
        }
    } else {
        return Integer.valueOf(argMaxNumUni);
    }
}
#method_after
Integer generateMaxNumUni() {
    if (argMaxNumUni == null) {
        if (argServiceType == null) {
            return ((argUniList.size() > 2) ? CarrierEthernetVirtualConnection.MAX_NUM_UNI : 2);
        } else {
            // TODO: Catch exception
            CarrierEthernetVirtualConnection.Type evcType = CarrierEthernetVirtualConnection.Type.fromString(argServiceType);
            return (evcType.equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT) ? 2 : CarrierEthernetVirtualConnection.MAX_NUM_UNI);
        }
    } else {
        return Integer.valueOf(argMaxNumUni);
    }
}
#end_block

#method_before
Set<CarrierEthernetUni> generateUniSet() {
    Set<CarrierEthernetUni> uniSet = new HashSet<>();
    CarrierEthernetVirtualConnection.Type serviceType = generateServiceType();
    // We assume that first UNI supplied is always root
    uniSet.add(new CarrierEthernetUni(ConnectPoint.deviceConnectPoint(argFirstUni), null, CarrierEthernetUni.Type.ROOT, generateCeVlanId(), new CarrierEthernetBandwidthProfile(generateBandwidthProfileId(argFirstUni), null, generateBandwidthProfileType(), Bandwidth.mbps(Double.parseDouble(argCir)), Bandwidth.mbps(Double.parseDouble(argEir)), Long.parseLong(argCbs), Long.parseLong(argEbs))));
    final CarrierEthernetUni.Type uniType;
    // For E-Line and E-LAN all UNIs are roots. For E-Tree all UNIs are leafs except from one
    uniType = ((serviceType == CarrierEthernetVirtualConnection.Type.ROOT_MULTIPOINT) ? CarrierEthernetUni.Type.LEAF : CarrierEthernetUni.Type.ROOT);
    argUniList.forEach(argUni -> uniSet.add(new CarrierEthernetUni(ConnectPoint.deviceConnectPoint(argUni), null, uniType, generateCeVlanId(), new CarrierEthernetBandwidthProfile(generateBandwidthProfileId(argUni), null, generateBandwidthProfileType(), Bandwidth.mbps(Double.parseDouble(argCir)), Bandwidth.mbps(Double.parseDouble(argEir)), Long.parseLong(argCbs), Long.parseLong(argEbs)))));
    return uniSet;
}
#method_after
Set<CarrierEthernetUni> generateUniSet() {
    Set<CarrierEthernetUni> uniSet = new HashSet<>();
    CarrierEthernetVirtualConnection.Type serviceType = generateServiceType();
    // We assume that first UNI supplied is always root
    uniSet.add(new CarrierEthernetUni(ConnectPoint.deviceConnectPoint(argFirstUni), null, CarrierEthernetUni.Role.ROOT, generateCeVlanId(), new CarrierEthernetBandwidthProfile(generateBandwidthProfileId(argFirstUni), null, generateBandwidthProfileType(), Bandwidth.mbps(Double.parseDouble(argCir)), Bandwidth.mbps(Double.parseDouble(argEir)), Long.parseLong(argCbs), Long.parseLong(argEbs))));
    final CarrierEthernetUni.Role uniType;
    // For E-Line and E-LAN all UNIs are roots. For E-Tree all UNIs are leafs except from one
    uniType = ((serviceType == CarrierEthernetVirtualConnection.Type.ROOT_MULTIPOINT) ? CarrierEthernetUni.Role.LEAF : CarrierEthernetUni.Role.ROOT);
    argUniList.forEach(argUni -> uniSet.add(new CarrierEthernetUni(ConnectPoint.deviceConnectPoint(argUni), null, uniType, generateCeVlanId(), new CarrierEthernetBandwidthProfile(generateBandwidthProfileId(argUni), null, generateBandwidthProfileType(), Bandwidth.mbps(Double.parseDouble(argCir)), Bandwidth.mbps(Double.parseDouble(argEir)), Long.parseLong(argCbs), Long.parseLong(argEbs)))));
    return uniSet;
}
#end_block

#method_before
public String toString() {
    return toStringHelper(this).add("id", ltpId).add("cfgId", ltpCfgId).add("sVlanIds", sVlanIdSet).add("uni", uni).toString();
}
#method_after
public String toString() {
    return toStringHelper(this).add("id", ltpId).add("cfgId", ltpCfgId).add("role", role).add("uni", ni).toString();
}
#end_block

#method_before
@Override
protected void execute() {
    CarrierEthernetVirtualConnectionManager evcManager = get(CarrierEthernetVirtualConnectionManager.class);
    printServices(evcManager.evcMap().values());
}
#method_after
@Override
protected void execute() {
    CarrierEthernetManager evcManager = get(CarrierEthernetManager.class);
    printServices(evcManager.evcMap().values());
}
#end_block

#method_before
@Override
public Collection<Tunnel> queryTunnel(TunnelEndPoint src, TunnelEndPoint dst) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    Tunnel tunnel = null;
    for (TunnelId tunnelId : tunnelIdAsKeyStore.keySet()) {
        tunnel = tunnelIdAsKeyStore.get(tunnelId);
        if ((null != tunnel) && (src.equals(tunnel.src())) && (dst.equals(tunnel.dst()))) {
            result.add(tunnel);
        }
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#method_after
@Override
public Collection<Tunnel> queryTunnel(TunnelEndPoint src, TunnelEndPoint dst) {
    Collection<Tunnel> result = new HashSet<>();
    Tunnel tunnel = null;
    for (TunnelId tunnelId : tunnelIdAsKeyStore.keySet()) {
        tunnel = tunnelIdAsKeyStore.get(tunnelId);
        if ((null != tunnel) && (src.equals(tunnel.src())) && (dst.equals(tunnel.dst()))) {
            result.add(tunnel);
        }
    }
    return result.isEmpty() ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#end_block

#method_before
@Override
public Collection<Tunnel> queryAllTunnels() {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    for (TunnelId tunnelId : tunnelIdAsKeyStore.keySet()) {
        result.add(tunnelIdAsKeyStore.get(tunnelId));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#method_after
@Override
public Collection<Tunnel> queryAllTunnels() {
    Collection<Tunnel> result = new HashSet<>();
    for (TunnelId tunnelId : tunnelIdAsKeyStore.keySet()) {
        result.add(tunnelIdAsKeyStore.get(tunnelId));
    }
    return result.isEmpty() ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0x01, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#method_after
@Test
public void tunnelProviderAddedTest1() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    controller.processClientMessage(PccId.pccId(IpAddress.valueOf("1.1.1.1")), message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x4e, 0x1f, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x4e, 0x1f, 0x04, 0x00, 0x4e, 0x20, 0x04, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // create an existing tunnel.
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e1f0400));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e200400));
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(1)).toString()).set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PCC_TUNNEL_ID, String.valueOf(1)).set(PLSP_ID, String.valueOf(1)).set(LOCAL_LSP_ID, String.valueOf(1)).build();
    Tunnel tunnel = new DefaultTunnel(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, INIT, null, null, TunnelName.tunnelName("T123"), null, annotations);
    tunnelService.setupTunnel(null, null, tunnel, null);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0x4e1f0400));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.getClient(pccId).setIsSyncComplete(true);
    // Process update message.
    controller.processClientMessage(pccId, message);
    assertThat(tunnelService.queryAllTunnels().size(), is(1));
}
#method_after
@Test
public void tunnelProviderAddedTest2() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x4e, 0x1f, 0x04, 0x00, 0x00, 0x01, 0x00, 0x01, 0x4e, 0x1f, 0x04, 0x00, 0x4e, 0x20, 0x04, 0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0xb6, // ERO IPv4 sub objects
    0x02, // ERO IPv4 sub objects
    0x4e, // ERO IPv4 sub objects
    0x1f, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    // create an existing tunnel.
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e1f0400));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(0x4e200400));
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(1)).toString()).set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).set(PCC_TUNNEL_ID, String.valueOf(1)).set(PLSP_ID, String.valueOf(1)).set(LOCAL_LSP_ID, String.valueOf(1)).build();
    Tunnel tunnel = new DefaultTunnel(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, INIT, null, null, TunnelName.tunnelName("T123"), null, annotations);
    tunnelService.setupTunnel(null, null, tunnel, null);
    PccId pccId = PccId.pccId(IpAddress.valueOf(0x4e1f0400));
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.getClient(pccId).setIsSyncComplete(true);
    // Process update message.
    controller.processClientMessage(pccId, message);
    assertThat(tunnelService.queryAllTunnels().size(), is(1));
}
#end_block

#method_before
@Test
public void tunnelProviderAddedTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0x01, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setIsSyncComplete(true);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.processClientMessage(pccId, message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#method_after
@Test
public void tunnelProviderAddedTest3() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x24, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x19, // symbolic path TLV
    0x00, // symbolic path TLV
    0x11, // symbolic path TLV
    0x00, // symbolic path TLV
    0x02, // symbolic path TLV
    0x54, // symbolic path TLV
    0x31, // symbolic path TLV
    0x00, // symbolic path TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x12, // IPv4-LSP-IDENTIFIER-TLV
    0x00, // IPv4-LSP-IDENTIFIER-TLV
    0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x05, 0x05, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x08, // ERO IPv4 sub objects
    (byte) 0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x01, // ERO IPv4 sub objects
    0x04, // ERO IPv4 sub objects
    0x00, 0x01, 0x08, (byte) 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x08, // RRO IPv4 sub objects
    0x11, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x01, // RRO IPv4 sub objects
    0x04, // RRO IPv4 sub objects
    0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = reader.readFrom(buffer);
    PccId pccId = PccId.pccId(IpAddress.valueOf("1.1.1.1"));
    controller.getClient(pccId).setIsSyncComplete(true);
    controller.getClient(pccId).setCapability(new ClientCapability(true, true, true));
    controller.processClientMessage(pccId, message);
    assertThat(registry.tunnelIdCounter, is((long) 1));
}
#end_block

#method_before
@Test
public void testCasePcepReleaseTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<Link>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepReleaseTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepReleaseTunnel2() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<Link>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E22);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#method_after
@Test
public void testCasePcepReleaseTunnel2() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E22);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#end_block

#method_before
@Test
public void testCasePcepReleaseSrTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<Link>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepReleaseSrTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepReleaseTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<Link>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepReleaseTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void reportMessageTest42() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xE8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO object
    0x01, // RRO object
    0x08, // RRO object
    0x11, // RRO object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(reportMsg));
}
#method_after
@Test
public void reportMessageTest42() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xE8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 subobjects
    0x01, // ERO IPv4 subobjects
    0x08, // ERO IPv4 subobjects
    (byte) 0xb6, // ERO IPv4 subobjects
    0x02, // ERO IPv4 subobjects
    0x4e, // ERO IPv4 subobjects
    0x1f, // ERO IPv4 subobjects
    0x04, // ERO IPv4 subobjects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO object
    0x01, // RRO object
    0x08, // RRO object
    0x11, // RRO object
    0x01, // RRO IPv4 subobjects
    0x01, // RRO IPv4 subobjects
    0x01, // RRO IPv4 subobjects
    0x04, // RRO IPv4 subobjects
    0x00, // RRO IPv4 subobjects
    0x01, // RRO IPv4 subobjects
    0x08, // RRO IPv4 subobjects
    0x11, // RRO IPv4 subobjects
    0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(reportMsg));
}
#end_block

#method_before
/**
 * Tests PCRpt msg with Path-Setup-Type TLV as SR.
 *
 * @throws PcepParseException
 * @throws PcepOutOfBoundMessageException
 */
@Test
public void reportMessageTest43() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x3C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(reportMsg));
}
#method_after
@Test
public void reportMessageTest43() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x3C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 subobjects
    0x01, // ERO IPv4 subobjects
    0x08, // ERO IPv4 subobjects
    (byte) 0xb6, // ERO IPv4 subobjects
    0x02, // ERO IPv4 subobjects
    0x4e, // ERO IPv4 subobjects
    0x1f, // ERO IPv4 subobjects
    0x04, // ERO IPv4 subobjects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(reportMsg));
}
#end_block

#method_before
/**
 * Tests PCRpt msg with Path-Setup-Type TLV as "without SR and without signalling".
 *
 * @throws PcepParseException
 * @throws PcepOutOfBoundMessageException
 */
@Test
public void reportMessageTest44() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x3C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(reportMsg));
}
#method_after
@Test
public void reportMessageTest44() throws PcepParseException, PcepOutOfBoundMessageException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x3C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x1c, // PATH-SETUP-TYPE TLV
    0x00, // PATH-SETUP-TYPE TLV
    0x04, 0x00, 0x00, 0x00, 0x02, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO IPv4 subobjects
    0x01, // ERO IPv4 subobjects
    0x08, // ERO IPv4 subobjects
    (byte) 0xb6, // ERO IPv4 subobjects
    0x02, // ERO IPv4 subobjects
    0x4e, // ERO IPv4 subobjects
    0x1f, // ERO IPv4 subobjects
    0x04, // ERO IPv4 subobjects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepReportMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex();
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    assertThat(testReportMsg, is(reportMsg));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepSetupTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010103);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#method_after
@Test
public void testCasePcepSetupTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010103);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#end_block

#method_before
@Test
public void testCasePcepSetupSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepSetupSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepSetupTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnel() {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
}
#method_after
@Test
public void testCasePcepSetupTunnel() {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Override
public TunnelId tunnelAdded(TunnelDescription tunnel, State tunnelState) {
    return handleTunnelAdded(tunnel, tunnelState);
}
#method_after
public TunnelId tunnelAdded(TunnelDescription tunnel, State tunnelState) {
    return handleTunnelAdded(tunnel, tunnelState);
}
#end_block

#method_before
@Override
public void tunnelUpdated(TunnelDescription tunnel, State tunnelState) {
    handleTunnelUpdate(tunnel, tunnelState);
}
#method_after
public void tunnelUpdated(TunnelDescription tunnel, State tunnelState) {
    handleTunnelUpdate(tunnel, tunnelState);
}
#end_block

#method_before
LinkedList<PcInitiatedLspRequest> createPcInitiatedLspReqList(Tunnel tunnel, Path path, PcepClient pc, int srpId) throws PcepParseException {
    PcepValueType tlv;
    LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
    if (llSubObjects == null || llSubObjects.size() == 0) {
        log.error("There is no link information to create tunnel");
        return null;
    }
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    // set PathSetupTypeTlv of SRP object
    tlv = new PathSetupTypeTlv(LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)).type());
    llOptionalTlv.add(tlv);
    // build SRP object
    PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).setOptionalTlv(llOptionalTlv).build();
    llOptionalTlv = new LinkedList<PcepValueType>();
    LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
    // set LSP identifiers TLV
    short localLspId = 0;
    if (LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)) != WITH_SIGNALLING) {
        localLspId = (short) LspIdGenerators.create();
    }
    tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), localLspId, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
    llOptionalTlv.add(tlv);
    // set SymbolicPathNameTlv of LSP object
    tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
    llOptionalTlv.add(tlv);
    // build LSP object
    PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setOFlag((byte) 0).setPlspId(0).setOptionalTlv(llOptionalTlv).build();
    // build ENDPOINTS object
    PcepEndPointsObject endpointsobj = pc.factory().buildEndPointsObject().setSourceIpAddress(((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()).setDestIpAddress(((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()).setPFlag(true).build();
    // build ERO object
    PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
    int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
    if (tunnel.annotations().value(BANDWIDTH) != null) {
        iBandwidth = Integer.parseInt(tunnel.annotations().value(BANDWIDTH));
    }
    // build bandwidth object
    PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
    // build pcep attribute
    PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
    PcInitiatedLspRequest initiateLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).setEndPointsObject(endpointsobj).setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
    llPcInitiatedLspRequestList.add(initiateLspRequest);
    return llPcInitiatedLspRequestList;
}
#method_after
LinkedList<PcInitiatedLspRequest> createPcInitiatedLspReqList(Tunnel tunnel, Path path, PcepClient pc, int srpId) throws PcepParseException {
    PcepValueType tlv;
    LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
    if (llSubObjects == null || llSubObjects.size() == 0) {
        log.error("There is no link information to create tunnel");
        return null;
    }
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    // set PathSetupTypeTlv of SRP object
    tlv = new PathSetupTypeTlv(LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)).type());
    llOptionalTlv.add(tlv);
    // build SRP object
    PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).setOptionalTlv(llOptionalTlv).build();
    llOptionalTlv = new LinkedList<PcepValueType>();
    LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
    // set LSP identifiers TLV
    short localLspId = 0;
    if (LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)) != WITH_SIGNALLING) {
        String localLspIdString = tunnel.annotations().value(LOCAL_LSP_ID);
        if (localLspIdString != null) {
            localLspId = Short.valueOf(localLspIdString);
        }
    }
    tlv = new StatefulIPv4LspIdentifiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), localLspId, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
    llOptionalTlv.add(tlv);
    // set SymbolicPathNameTlv of LSP object
    tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
    llOptionalTlv.add(tlv);
    // build LSP object
    PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setOFlag((byte) 0).setPlspId(0).setOptionalTlv(llOptionalTlv).build();
    // build ENDPOINTS object
    PcepEndPointsObject endpointsobj = pc.factory().buildEndPointsObject().setSourceIpAddress(((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()).setDestIpAddress(((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()).setPFlag(true).build();
    // build ERO object
    PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
    int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
    if (tunnel.annotations().value(BANDWIDTH) != null) {
        iBandwidth = Integer.parseInt(tunnel.annotations().value(BANDWIDTH));
    }
    // build bandwidth object
    PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
    // build pcep attribute
    PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
    PcInitiatedLspRequest initiateLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).setEndPointsObject(endpointsobj).setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
    llPcInitiatedLspRequestList.add(initiateLspRequest);
    return llPcInitiatedLspRequestList;
}
#end_block

#method_before
private void pcepUpdateTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, UPDATE);
        pcepTunnelApiMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        PcepValueType tlv;
        int plspId = 0;
        LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcepUpdateRequest> llUpdateRequestList = new LinkedList<PcepUpdateRequest>();
        // set PathSetupTypeTlv of SRP object
        tlv = new PathSetupTypeTlv(LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)).type());
        llOptionalTlv.add(tlv);
        // build SRP object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).setOptionalTlv(llOptionalTlv).build();
        llOptionalTlv = new LinkedList<PcepValueType>();
        if (!(pcepTunnelApiMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists in DB");
            return;
        } else {
            PcepTunnelData pcepTunnelDBData = pcepTunnelApiMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDBData.plspId();
        }
        /*
             * TODO: Only for non-RSVP cases: When PCUpd is being sent via
             * trigger from a special label from flow manager, new LSP id
             * should not be generated. The old one from 1st PCRpt msg
             * should be used.
             */
        short localLspId = 0;
        if (LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE)) != WITH_SIGNALLING) {
            localLspId = (short) LspIdGenerators.create();
        }
        tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), localLspId, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
        llOptionalTlv.add(tlv);
        if (tunnel.tunnelName().value() != null) {
            tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
            llOptionalTlv.add(tlv);
        }
        // build lsp object
        PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        // build ero object
        PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
        int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
        if (tunnel.annotations().value(BANDWIDTH) != null) {
            iBandwidth = Integer.parseInt(tunnel.annotations().value(BANDWIDTH));
        }
        // build bandwidth object
        PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
        // build pcep attribute
        PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
        // build pcep msg path
        PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
        PcepUpdateRequest updateRequest = pc.factory().buildPcepUpdateRequest().setSrpObject(srpobj).setLspObject(lspobj).setMsgPath(msgPath).build();
        llUpdateRequestList.add(updateRequest);
        PcepUpdateMsg pcUpdateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(llUpdateRequestList).build();
        pc.sendMessage(Collections.singletonList(pcUpdateMsg));
        pcepTunnelApiMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#method_after
private void pcepUpdateTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, UPDATE);
        pcepTunnelApiMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        PcepValueType tlv;
        int plspId = 0;
        LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcepUpdateRequest> llUpdateRequestList = new LinkedList<PcepUpdateRequest>();
        // set PathSetupTypeTlv of SRP object
        LspType lspSigType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
        tlv = new PathSetupTypeTlv(lspSigType.type());
        llOptionalTlv.add(tlv);
        // build SRP object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).setOptionalTlv(llOptionalTlv).build();
        llOptionalTlv = new LinkedList<PcepValueType>();
        if (!(pcepTunnelApiMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists in DB");
            return;
        } else {
            PcepTunnelData pcepTunnelDBData = pcepTunnelApiMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDBData.plspId();
        }
        if (lspSigType != WITH_SIGNALLING) {
            String localLspIdString = tunnel.annotations().value(LOCAL_LSP_ID);
            String pccTunnelIdString = tunnel.annotations().value(PCC_TUNNEL_ID);
            short localLspId = 0;
            short pccTunnelId = 0;
            if (localLspIdString != null) {
                localLspId = Short.valueOf(localLspIdString);
            }
            if (pccTunnelIdString != null) {
                pccTunnelId = Short.valueOf(pccTunnelIdString);
            }
            tlv = new StatefulIPv4LspIdentifiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), localLspId, pccTunnelId, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
            llOptionalTlv.add(tlv);
        }
        if (tunnel.tunnelName().value() != null) {
            tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
            llOptionalTlv.add(tlv);
        }
        // build lsp object
        PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        // build ero object
        PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
        int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
        if (tunnel.annotations().value(BANDWIDTH) != null) {
            iBandwidth = Integer.parseInt(tunnel.annotations().value(BANDWIDTH));
        }
        // build bandwidth object
        PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
        // build pcep attribute
        PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
        // build pcep msg path
        PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
        PcepUpdateRequest updateRequest = pc.factory().buildPcepUpdateRequest().setSrpObject(srpobj).setLspObject(lspobj).setMsgPath(msgPath).build();
        llUpdateRequestList.add(updateRequest);
        PcepUpdateMsg pcUpdateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(llUpdateRequestList).build();
        pc.sendMessage(Collections.singletonList(pcUpdateMsg));
        pcepTunnelApiMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
private void handleReportMessage(int srpId, PcepLspObject lspObj, PcepStateReport stateRpt) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepTunnelData pcepTunnelData = pcepTunnelApiMapper.getDataFromTunnelRequestQueue(srpId);
    if (pcepTunnelData == null) {
        handleRptWithoutSrpId(stateRpt);
        return;
    }
    // store the values required from report message
    pcepTunnelData.setPlspId(lspObj.getPlspId());
    pcepTunnelData.setLspAFlag(lspObj.getAFlag());
    pcepTunnelData.setLspOFlag(lspObj.getOFlag());
    pcepTunnelData.setLspDFlag(lspObj.getDFlag());
    StatefulIPv4LspIdentidiersTlv ipv4LspTlv = null;
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentidiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentidiersTlv) tlv;
            break;
        }
    }
    if (ipv4LspTlv != null) {
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspTlv);
    }
    Path path = pcepTunnelData.path();
    Tunnel tunnel = pcepTunnelData.tunnel();
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.putAll(pcepTunnelData.tunnel().annotations());
    // PCRpt in response to PCInitate msg will carry PLSP id allocated by PCC.
    if (tunnel.annotations().value(PLSP_ID) == null) {
        annotationBuilder.set(PLSP_ID, String.valueOf(lspObj.getPlspId()));
    }
    // Signalled LSPs will carry local LSP id allocated by signalling protocol(PCC).
    if (tunnel.annotations().value(LOCAL_LSP_ID) == null) {
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(ipv4LspTlv.getLspId()));
    }
    SparseAnnotations annotations = annotationBuilder.build();
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, annotations);
    if (CREATE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.handleCreateTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (DELETE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.handleRemoveFromTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (UPDATE == pcepTunnelData.requestType()) {
        pcepTunnelData.setRptFlag(true);
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelApiMapper.handleUpdateTunnelRequestQueue(srpId, pcepTunnelData);
    }
    if (lspObj.getRFlag()) {
        tunnelRemoved(td);
    } else {
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
        tunnelUpdated(td, tunnelState);
    }
}
#method_after
private void handleReportMessage(int srpId, PcepLspObject lspObj, PcepStateReport stateRpt) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepTunnelData pcepTunnelData = pcepTunnelApiMapper.getDataFromTunnelRequestQueue(srpId);
    if (pcepTunnelData == null) {
        handleRptWithoutSrpId(stateRpt);
        return;
    }
    // store the values required from report message
    pcepTunnelData.setPlspId(lspObj.getPlspId());
    pcepTunnelData.setLspAFlag(lspObj.getAFlag());
    pcepTunnelData.setLspOFlag(lspObj.getOFlag());
    pcepTunnelData.setLspDFlag(lspObj.getDFlag());
    StatefulIPv4LspIdentifiersTlv ipv4LspTlv = null;
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentifiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
            break;
        }
    }
    if (ipv4LspTlv != null) {
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspTlv);
    }
    Path path = pcepTunnelData.path();
    Tunnel tunnel = pcepTunnelData.tunnel();
    Builder annotationBuilder = DefaultAnnotations.builder();
    annotationBuilder.putAll(pcepTunnelData.tunnel().annotations());
    // PCRpt in response to PCInitate msg will carry PLSP id allocated by PCC.
    if (tunnel.annotations().value(PLSP_ID) == null) {
        annotationBuilder.set(PLSP_ID, String.valueOf(lspObj.getPlspId()));
    }
    // Signalled LSPs will carry local LSP id allocated by signalling protocol(PCC).
    if (tunnel.annotations().value(LOCAL_LSP_ID) == null) {
        annotationBuilder.set(LOCAL_LSP_ID, String.valueOf(ipv4LspTlv.getLspId()));
    }
    SparseAnnotations annotations = annotationBuilder.build();
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, annotations);
    if (CREATE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.handleCreateTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (DELETE == pcepTunnelData.requestType()) {
        pcepTunnelApiMapper.handleRemoveFromTunnelRequestQueue(srpId, pcepTunnelData);
    } else if (UPDATE == pcepTunnelData.requestType()) {
        pcepTunnelData.setRptFlag(true);
        pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelApiMapper.handleUpdateTunnelRequestQueue(srpId, pcepTunnelData);
    }
    if (lspObj.getRFlag()) {
        tunnelRemoved(td);
    } else {
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
        tunnelUpdated(td, tunnelState);
    }
}
#end_block

#method_before
private void handleRptWithoutSrpId(PcepStateReport stateRpt) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    StatefulIPv4LspIdentidiersTlv ipv4LspTlv = null;
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentidiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentidiersTlv) tlv;
            break;
        }
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if ((tunnelObj.annotations().value(PLSP_ID) == null) || (tunnelObj.annotations().value(LOCAL_LSP_ID) == null)) {
            /*
                     *  Can skip this tunnel as this is one for which PCE has
                     *  sent PCInit/PCUpd msg and waiting for a PCRpt.
                     */
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    // No need to add the tunnel if msg is for remove but store doesn't have an entry.
    if ((tunnel == null) && (!lspObj.getRFlag())) {
        handleSyncReport(stateRpt);
        return;
    }
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), tunnel.path(), (SparseAnnotations) tunnel.annotations());
    if (lspObj.getRFlag()) {
        // This will happen only for PCC initiated tunnels.
        tunnelRemoved(td);
    } else {
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
        tunnelUpdated(td, tunnelState);
    }
}
#method_after
private void handleRptWithoutSrpId(PcepStateReport stateRpt) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    StatefulIPv4LspIdentifiersTlv ipv4LspTlv = null;
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentifiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
            break;
        }
    }
    checkNotNull(ipv4LspTlv);
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if ((tunnelObj.annotations().value(PLSP_ID) == null) || (tunnelObj.annotations().value(LOCAL_LSP_ID) == null)) {
            /*
                     *  Can skip this tunnel as this is one for which PCE has
                     *  sent PCInit/PCUpd msg and waiting for a PCRpt.
                     */
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    // No need to add the tunnel if msg is for remove but store doesn't have an entry.
    if (tunnel == null) {
        if (!lspObj.getRFlag()) {
            handleSyncReport(stateRpt);
        }
        return;
    }
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), tunnel.path(), (SparseAnnotations) tunnel.annotations());
    if (lspObj.getRFlag()) {
        // This will happen only for PCC initiated tunnels.
        tunnelRemoved(td);
    } else {
        State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
        tunnelUpdated(td, tunnelState);
    }
}
#end_block

#method_before
private void buildAndStorePcepTunnelData(PcepLspObject lspObj, PcepEroObject eroObj, int bandwidth, LspType lspType) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    // StatefulIPv4LspIdentidiersTlv in LSP object will have the source and destination address.
    StatefulIPv4LspIdentidiersTlv lspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    LinkedList<PcepValueType> llOptionalTlv = lspObj.getOptionalTlv();
    ListIterator<PcepValueType> listIterator = llOptionalTlv.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentidiersTlv.TYPE:
                lspIdenTlv = (StatefulIPv4LspIdentidiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
        }
    }
    IpTunnelEndPoint tunnelEndPointSrc;
    tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(lspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst;
    tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(lspIdenTlv.getIpv4EgressAddress()));
    Path path = buildPathFromEroObj(eroObj, providerId);
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(lspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(lspIdenTlv.getLspId())).build();
    DefaultTunnelDescription td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(pathNameTlv.toString()), path, annotations);
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    TunnelId tId = tunnelAdded(td, tunnelState);
    Tunnel tunnel = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), tId, TunnelName.tunnelName(pathNameTlv.toString()), path, annotations);
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, LSP_STATE_RPT);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(lspIdenTlv);
    pcepTunnelApiMapper.addPccTunnelDB(pcepTunnelData);
    pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
}
#method_after
private void buildAndStorePcepTunnelData(PcepLspObject lspObj, PcepEroObject eroObj, int bandwidth, LspType lspType) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    // StatefulIPv4LspIdentidiersTlv in LSP object will have the source and destination address.
    StatefulIPv4LspIdentifiersTlv lspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    LinkedList<PcepValueType> llOptionalTlv = lspObj.getOptionalTlv();
    ListIterator<PcepValueType> listIterator = llOptionalTlv.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                lspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
        }
    }
    IpTunnelEndPoint tunnelEndPointSrc;
    tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(lspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst;
    tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(lspIdenTlv.getIpv4EgressAddress()));
    Path path = buildPathFromEroObj(eroObj, providerId);
    SparseAnnotations annotations = DefaultAnnotations.builder().set(BANDWIDTH, (new Integer(bandwidth)).toString()).set(LSP_SIG_TYPE, lspType.name()).set(PCC_TUNNEL_ID, String.valueOf(lspIdenTlv.getTunnelId())).set(PLSP_ID, String.valueOf(lspObj.getPlspId())).set(LOCAL_LSP_ID, String.valueOf(lspIdenTlv.getLspId())).build();
    DefaultTunnelDescription td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(pathNameTlv.toString()), path, annotations);
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    TunnelId tId = tunnelAdded(td, tunnelState);
    Tunnel tunnel = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), tId, TunnelName.tunnelName(pathNameTlv.toString()), path, annotations);
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, LSP_STATE_RPT);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(lspIdenTlv);
    pcepTunnelApiMapper.addPccTunnelDB(pcepTunnelData);
    pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
}
#end_block

#method_before
@Test
public void testCasePcepUpdateTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepUpdateTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepUpdateTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010103);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#method_after
@Test
public void testCasePcepUpdateTunnel2() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xC010103);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITH_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper.checkFromTunnelRequestQueue(1), is(false));
}
#end_block

#method_before
@Test
public void testCasePcepUpdateSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepUpdateSrTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, SR_WITHOUT_SIGNALLING.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepUpdateTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#method_after
@Test
public void testCasePcepUpdateTunnelWithoutSigSr() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    Annotations annotations = DefaultAnnotations.builder().set(LSP_SIG_TYPE, WITHOUT_SIGNALLING_AND_WITHOUT_SR.name()).build();
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, annotations);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentifiersTlv tlv = new StatefulIPv4LspIdentifiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
public static DiscreteResourceSet of(Set<DiscreteResource> values, DiscreteResourceCodec codec) {
    checkArgument(!values.isEmpty());
    return new DiscreteResourceSet(values, codec);
}
#method_after
public static DiscreteResourceSet of(Set<DiscreteResource> values, DiscreteResourceCodec codec) {
    checkNotNull(values);
    checkNotNull(codec);
    checkArgument(!values.isEmpty());
    return new DiscreteResourceSet(ImmutableSet.copyOf(values), codec);
}
#end_block

#method_before
public DiscreteResourceId parent() {
    Optional<DiscreteResourceId> parent = values.iterator().next().id().parent();
    checkState(parent.isPresent());
    return parent.get();
}
#method_after
public DiscreteResourceId parent() {
    if (values.isEmpty()) {
        // Dummy value avoiding null
        return ResourceId.ROOT;
    }
    Optional<DiscreteResourceId> parent = values.iterator().next().id().parent();
    checkState(parent.isPresent());
    return parent.get();
}
#end_block

#method_before
@Override
public DiscreteResourceSet read(Kryo kryo, Input input, Class<DiscreteResourceSet> type) {
    @SuppressWarnings("unchecked")
    List<ClosedOpenRange> ranges = kryo.readObject(input, ArrayList.class);
    DiscreteResourceCodec codec = (DiscreteResourceCodec) kryo.readClassAndObject(input);
    DiscreteResourceId parent = kryo.readObject(input, DiscreteResourceId.class);
    Set<DiscreteResource> resources = ranges.stream().flatMap(x -> IntStream.range(x.lowerBound(), x.upperBound()).mapToObj(primitive -> primitive)).map(x -> codec.decode(parent, x)).collect(Collectors.toSet());
    return DiscreteResourceSet.of(resources, codec);
}
#method_after
@Override
public DiscreteResourceSet read(Kryo kryo, Input input, Class<DiscreteResourceSet> type) {
    @SuppressWarnings("unchecked")
    List<ClosedOpenRange> ranges = kryo.readObject(input, ArrayList.class);
    DiscreteResourceCodec codec = (DiscreteResourceCodec) kryo.readClassAndObject(input);
    DiscreteResourceId parent = kryo.readObject(input, DiscreteResourceId.class);
    if (ranges.isEmpty()) {
        return DiscreteResourceSet.empty();
    }
    Set<DiscreteResource> resources = ranges.stream().flatMapToInt(x -> IntStream.range(x.lowerBound(), x.upperBound())).mapToObj(x -> codec.decode(parent, x)).collect(Collectors.toSet());
    return DiscreteResourceSet.of(resources, codec);
}
#end_block

#method_before
public static Options defaults() {
    return new Options(5, 10000L);
}
#method_after
private static Options defaults() {
    return new Options(5, 10000L);
}
#end_block

#method_before
private static void reconnectOrThrowException(TTransport transport, int maxRetries, long timeBetweenRetries) throws TTransportException {
    int errors = 0;
    transport.close();
    while (errors < maxRetries) {
        try {
            LOG.debug("Attempting to reconnect...");
            transport.open();
            LOG.debug("Reconnection successful");
            break;
        } catch (TTransportException e) {
            LOG.error("Error while reconnecting:", e);
            errors++;
            if (errors < maxRetries) {
                try {
                    LOG.debug("Sleeping for {} milliseconds before retrying", timeBetweenRetries);
                    Thread.sleep(timeBetweenRetries);
                } catch (InterruptedException e2) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
    if (errors >= maxRetries) {
        throw new TTransportException("Failed to reconnect");
    }
}
#method_after
private static void reconnectOrThrowException(TTransport transport, int maxRetries, long timeBetweenRetries) throws TTransportException {
    int errors = 0;
    transport.close();
    while (errors < maxRetries) {
        try {
            LOG.debug("Attempting to reconnect...");
            transport.open();
            LOG.debug("Reconnection successful");
            break;
        } catch (TTransportException e) {
            LOG.error("Error while reconnecting:", e);
            errors++;
            if (errors < maxRetries) {
                try {
                    LOG.debug("Sleeping for {} milliseconds before retrying", timeBetweenRetries);
                    Thread.sleep(timeBetweenRetries);
                } catch (InterruptedException e2) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException(e);
                }
            }
        }
    }
    if (errors >= maxRetries) {
        throw new TTransportException("Failed to reconnect");
    }
}
#end_block

#method_before
@Override
public synchronized Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // method is synchronized
    LOG.debug("Invoking client method... > method={}, fromThread={}", method.getName(), Thread.currentThread().getId());
    Object result = null;
    try {
        result = method.invoke(baseClient, args);
    } catch (InvocationTargetException e) {
        if (e.getTargetException() instanceof TTransportException) {
            TTransportException cause = (TTransportException) e.getTargetException();
            if (RESTARTABLE_CAUSES.contains(cause.getType())) {
                reconnectOrThrowException(baseClient.getInputProtocol().getTransport(), maxRetries, timeBetweenRetries);
                result = method.invoke(baseClient, args);
            }
        }
        if (result == null) {
            LOG.debug("Exception while invoking client method: {} > method={}, fromThread={}", e, method.getName(), Thread.currentThread().getId());
            throw e;
        }
    }
    LOG.debug("Method invoke complete! > method={}, fromThread={}", method.getName(), Thread.currentThread().getId());
    return result;
}
#method_after
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    synchronized (baseClient) {
        LOG.debug("Invoking client method... > method={}, fromThread={}", method.getName(), Thread.currentThread().getId());
        Object result = null;
        try {
            result = method.invoke(baseClient, args);
        } catch (InvocationTargetException e) {
            if (e.getTargetException() instanceof TTransportException) {
                TTransportException cause = (TTransportException) e.getTargetException();
                if (RESTARTABLE_CAUSES.contains(cause.getType())) {
                    reconnectOrThrowException(baseClient.getInputProtocol().getTransport(), maxRetries, timeBetweenRetries);
                    result = method.invoke(baseClient, args);
                }
            }
            if (result == null) {
                LOG.debug("Exception while invoking client method: {} > method={}, fromThread={}", e, method.getName(), Thread.currentThread().getId());
                throw e.getTargetException();
            }
        }
        LOG.debug("Method invoke complete! > method={}, fromThread={}", method.getName(), Thread.currentThread().getId());
        return result;
    }
}
#end_block

#method_before
public static YangRangeRestriction processRangeRestriction(YangRangeRestriction refRangeRestriction, int lineNumber, int charPositionInLine, boolean hasReferredRestriction, String curRangeString, YangDataTypes effectiveType) {
    YangBuiltInDataTypeInfo<?> startValue;
    YangBuiltInDataTypeInfo<?> endValue;
    YangRangeRestriction rangeRestriction = new YangRangeRestriction();
    String rangeArgument = removeQuotesAndHandleConcat(curRangeString);
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String startInterval;
        String endInterval;
        YangRangeInterval rangeInterval = new YangRangeInterval();
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(INTERVAL));
        if (rangeBoundary.length > MAX_RANGE_BOUNDARY) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(RANGE_DATA) + " " + rangeArgument + " is not valid.");
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        if (rangeBoundary.length == MIN_RANGE_BOUNDARY) {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[0];
        } else {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[1];
        }
        try {
            if (hasReferredRestriction && startInterval.equals("MIN")) {
                startValue = refRangeRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && startInterval.equals("MAX")) {
                startValue = refRangeRestriction.getMaxRestrictedvalue();
            } else {
                startValue = getDataObjectFromString(startInterval, effectiveType);
            }
            if (hasReferredRestriction && endInterval.equals("MIN")) {
                endValue = refRangeRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && endInterval.equals("MAX")) {
                endValue = refRangeRestriction.getMaxRestrictedvalue();
            } else {
                endValue = getDataObjectFromString(endInterval, effectiveType);
            }
        } catch (DataModelException e) {
            ParserException parserException = new ParserException(e.getMessage());
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        rangeInterval.setStartValue(startValue);
        rangeInterval.setEndValue(endValue);
        try {
            rangeRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException e) {
            ParserException parserException = new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, RANGE_DATA, rangeArgument, ENTRY, e.getMessage()));
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
    }
    return rangeRestriction;
}
#method_after
public static YangRangeRestriction processRangeRestriction(YangRangeRestriction refRangeRestriction, int lineNumber, int charPositionInLine, boolean hasReferredRestriction, String curRangeString, YangDataTypes effectiveType) {
    YangBuiltInDataTypeInfo<?> startValue;
    YangBuiltInDataTypeInfo<?> endValue;
    YangRangeRestriction rangeRestriction = new YangRangeRestriction();
    String rangeArgument = removeQuotesAndHandleConcat(curRangeString);
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String startInterval;
        String endInterval;
        YangRangeInterval rangeInterval = new YangRangeInterval();
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(INTERVAL));
        if (rangeBoundary.length > MAX_RANGE_BOUNDARY) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(RANGE_DATA) + " " + rangeArgument + " is not valid.");
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        if (rangeBoundary.length == MIN_RANGE_BOUNDARY) {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[0];
        } else {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[1];
        }
        try {
            if (hasReferredRestriction && startInterval.equals(MIN_KEYWORD) && refRangeRestriction.getMinRestrictedvalue() != null) {
                startValue = refRangeRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && startInterval.equals(MAX_KEYWORD) && refRangeRestriction.getMaxRestrictedvalue() != null) {
                startValue = refRangeRestriction.getMaxRestrictedvalue();
            } else {
                startValue = getDataObjectFromString(startInterval, effectiveType);
            }
            if (hasReferredRestriction && endInterval.equals(MIN_KEYWORD) && refRangeRestriction.getMinRestrictedvalue() != null) {
                endValue = refRangeRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && endInterval.equals(MAX_KEYWORD) && refRangeRestriction.getMaxRestrictedvalue() != null) {
                endValue = refRangeRestriction.getMaxRestrictedvalue();
            } else {
                endValue = getDataObjectFromString(endInterval, effectiveType);
            }
        } catch (DataTypeException | DataModelException e) {
            ParserException parserException = new ParserException(e.getMessage());
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        rangeInterval.setStartValue(startValue);
        rangeInterval.setEndValue(endValue);
        try {
            rangeRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException e) {
            ParserException parserException = new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, RANGE_DATA, rangeArgument, ENTRY, e.getMessage()));
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
    }
    return rangeRestriction;
}
#end_block

#method_before
public static YangRangeRestriction processLengthRestriction(YangRangeRestriction refLengthRestriction, int lineNumber, int charPositionInLine, boolean hasReferredRestriction, String curLengthString) {
    YangBuiltInDataTypeInfo<?> startValue;
    YangBuiltInDataTypeInfo<?> endValue;
    YangRangeRestriction lengthRestriction = new YangRangeRestriction<>();
    String rangeArgument = removeQuotesAndHandleConcat(curLengthString);
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String startInterval;
        String endInterval;
        YangRangeInterval rangeInterval = new YangRangeInterval<>();
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(INTERVAL));
        if (rangeBoundary.length > MAX_RANGE_BOUNDARY) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(LENGTH_DATA) + " " + rangeArgument + " is not valid.");
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        if (rangeBoundary.length == MIN_RANGE_BOUNDARY) {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[0];
        } else {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[1];
        }
        try {
            if (hasReferredRestriction && startInterval.equals("MIN")) {
                startValue = refLengthRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && startInterval.equals("MAX")) {
                startValue = refLengthRestriction.getMaxRestrictedvalue();
            } else {
                startValue = getDataObjectFromString(startInterval, YangDataTypes.UINT64);
            }
            if (hasReferredRestriction && endInterval.equals("MIN")) {
                endValue = refLengthRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && endInterval.equals("MAX")) {
                endValue = refLengthRestriction.getMaxRestrictedvalue();
            } else {
                endValue = getDataObjectFromString(endInterval, YangDataTypes.UINT64);
            }
        } catch (DataModelException e) {
            e.printStackTrace();
            ParserException parserException = new ParserException(e.getMessage());
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        rangeInterval.setStartValue(startValue);
        rangeInterval.setEndValue(endValue);
        try {
            lengthRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException e) {
            ParserException parserException = new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LENGTH_DATA, rangeArgument, ENTRY, e.getMessage()));
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
    }
    return lengthRestriction;
}
#method_after
public static YangRangeRestriction processLengthRestriction(YangRangeRestriction refLengthRestriction, int lineNumber, int charPositionInLine, boolean hasReferredRestriction, String curLengthString) {
    YangBuiltInDataTypeInfo<?> startValue;
    YangBuiltInDataTypeInfo<?> endValue;
    YangRangeRestriction lengthRestriction = new YangRangeRestriction<>();
    String rangeArgument = removeQuotesAndHandleConcat(curLengthString);
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String startInterval;
        String endInterval;
        YangRangeInterval rangeInterval = new YangRangeInterval<>();
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(INTERVAL));
        if (rangeBoundary.length > MAX_RANGE_BOUNDARY) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(LENGTH_DATA) + " " + rangeArgument + " is not valid.");
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        if (rangeBoundary.length == MIN_RANGE_BOUNDARY) {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[0];
        } else {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[1];
        }
        try {
            if (hasReferredRestriction && startInterval.equals(MIN_KEYWORD) && refLengthRestriction.getMinRestrictedvalue() != null) {
                startValue = refLengthRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && startInterval.equals(MAX_KEYWORD) && refLengthRestriction.getMaxRestrictedvalue() != null) {
                startValue = refLengthRestriction.getMaxRestrictedvalue();
            } else {
                startValue = getDataObjectFromString(startInterval, YangDataTypes.UINT64);
            }
            if (hasReferredRestriction && endInterval.equals(MIN_KEYWORD) && refLengthRestriction.getMinRestrictedvalue() != null) {
                endValue = refLengthRestriction.getMinRestrictedvalue();
            } else if (hasReferredRestriction && endInterval.equals(MAX_KEYWORD) && refLengthRestriction.getMaxRestrictedvalue() != null) {
                endValue = refLengthRestriction.getMaxRestrictedvalue();
            } else {
                endValue = getDataObjectFromString(endInterval, YangDataTypes.UINT64);
            }
        } catch (DataTypeException | DataModelException e) {
            ParserException parserException = new ParserException(e.getMessage());
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
        rangeInterval.setStartValue(startValue);
        rangeInterval.setEndValue(endValue);
        try {
            lengthRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException e) {
            ParserException parserException = new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LENGTH_DATA, rangeArgument, ENTRY, e.getMessage()));
            parserException.setLine(lineNumber);
            parserException.setCharPosition(charPositionInLine);
            throw parserException;
        }
    }
    return lengthRestriction;
}
#end_block

#method_before
@Test
public void processValidLengthStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidLengthStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(0)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(100)));
}
#method_after
@Test
public void processValidLengthStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidLengthStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(0)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(100)));
}
#end_block

#method_before
@Test
public void processLengthStatementInsideLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthStatementInsideLeafList.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(1)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(100)));
}
#method_after
@Test
public void processLengthStatementInsideLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthStatementInsideLeafList.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(1)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(100)));
}
#end_block

#method_before
@Test
public void processLengthWithOneInterval() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthWithOneInterval.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(1)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(1)));
}
#method_after
@Test
public void processLengthWithOneInterval() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthWithOneInterval.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(1)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(1)));
}
#end_block

#method_before
@Test
public void processLengthWithMinMax() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthWithMinMax.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(0)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(new BigInteger("18446744073709551615")));
}
#method_after
@Test
public void processLengthWithMinMax() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthWithMinMax.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(0)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(new BigInteger("18446744073709551615")));
}
#end_block

#method_before
@Test
public void processLengthWithInvalidIntegerPattern() throws IOException, ParserException {
    thrown.expect(DataTypeException.class);
    thrown.expectMessage("YANG file error : a is not valid.");
    YangNode node = manager.getDataModel("src/test/resources/LengthWithInvalidIntegerPattern.yang");
}
#method_after
@Test
public void processLengthWithInvalidIntegerPattern() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : Input value \"a\" is not a valid uint64.");
    YangNode node = manager.getDataModel("src/test/resources/LengthWithInvalidIntegerPattern.yang");
}
#end_block

#method_before
@Test
public void processLengthWithInvalidInterval() throws IOException, DataTypeException {
    thrown.expect(DataTypeException.class);
    thrown.expectMessage("YANG file error : 18446744073709551617 is greater than maximum value" + " 18446744073709551615.");
    YangNode node = manager.getDataModel("src/test/resources/LengthWithInvalidInterval.yang");
}
#method_after
@Test
public void processLengthWithInvalidInterval() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : 18446744073709551617 is greater than maximum value" + " 18446744073709551615.");
    YangNode node = manager.getDataModel("src/test/resources/LengthWithInvalidInterval.yang");
}
#end_block

#method_before
public ResolvableStatus resolve() throws DataModelException {
    YangType<?> baseType = getReferredTypeDef().getTypeDefBaseType();
    /*
         * Checks the data type of the referred typedef, if it's derived,
         * obtain effective built-in type and restrictions from it's derived
         * info, otherwise take from the base type of type itself.
         */
    if (baseType.getDataType() == DERIVED) {
        /*
             * Check whether the referred typedef is resolved.
             */
        if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
            throw new DataModelException("Linker Error: Referred typedef is not resolved.");
        }
        /*
             * Check if the referred typedef is intra file resolved, if yes sets
             * current status also to intra file resolved .
             */
        if (getReferredTypeDef().getTypeDefBaseType().getResolvableStatus() == INTRA_FILE_RESOLVED) {
            return INTRA_FILE_RESOLVED;
        }
        setEffectiveBuiltInType(((YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo()).getEffectiveBuiltInType());
        YangDerivedInfo refDerivedInfo = ((YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo());
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(getEffectiveBuiltInType())) {
            if (refDerivedInfo.getResolvedExtendedInfo() == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(refDerivedInfo.getResolvedExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveRangeRestriction((YangRangeRestriction) refDerivedInfo.getResolvedExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls
                 * for string resolution.
                 */
        } else if (getEffectiveBuiltInType() == STRING) {
            if (refDerivedInfo.getResolvedExtendedInfo() == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(refDerivedInfo.getResolvedExtendedInfo() instanceof YangStringRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveStringRestriction((YangStringRestriction) refDerivedInfo.getResolvedExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        }
    } else {
        setEffectiveBuiltInType((baseType.getDataType()));
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(getEffectiveBuiltInType())) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveRangeRestriction((YangRangeRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls
                 * for string resolution.
                 */
        } else if (getEffectiveBuiltInType() == STRING) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangStringRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveStringRestriction((YangStringRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        }
    }
    /*
         * Check if the data type is the one which can't be restricted, in
         * this case check whether no self restrictions should be present.
         */
    if (isOfValidNonRestrictedType(getEffectiveBuiltInType())) {
        if (getLengthRestrictionString() == null && getRangeRestrictionString() == null && getPatternRestriction() == null) {
            return RESOLVED;
        } else {
            throw new DataModelException("YANG file error: Restrictions can't be applied to a given type");
        }
    }
    // Throw exception for unsupported types
    throw new DataModelException("Linker error: Unable to process the derived type.");
}
#method_after
public ResolvableStatus resolve() throws DataModelException {
    YangType<?> baseType = getReferredTypeDef().getTypeDefBaseType();
    /*
         * Checks the data type of the referred typedef, if it's derived,
         * obtain effective built-in type and restrictions from it's derived
         * info, otherwise take from the base type of type itself.
         */
    if (baseType.getDataType() == DERIVED) {
        /*
             * Check whether the referred typedef is resolved.
             */
        if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
            throw new DataModelException("Linker Error: Referred typedef is not resolved.");
        }
        /*
             * Check if the referred typedef is intra file resolved, if yes sets
             * current status also to intra file resolved .
             */
        if (getReferredTypeDef().getTypeDefBaseType().getResolvableStatus() == INTRA_FILE_RESOLVED) {
            return INTRA_FILE_RESOLVED;
        }
        setEffectiveBuiltInType(((YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo()).getEffectiveBuiltInType());
        YangDerivedInfo refDerivedInfo = ((YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo());
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(getEffectiveBuiltInType())) {
            if (refDerivedInfo.getResolvedExtendedInfo() == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(refDerivedInfo.getResolvedExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveRangeRestriction((YangRangeRestriction) refDerivedInfo.getResolvedExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls
                 * for string resolution.
                 */
        } else if (getEffectiveBuiltInType() == STRING) {
            if (refDerivedInfo.getResolvedExtendedInfo() == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(refDerivedInfo.getResolvedExtendedInfo() instanceof YangStringRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveStringRestriction((YangStringRestriction) refDerivedInfo.getResolvedExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        }
    } else {
        setEffectiveBuiltInType((baseType.getDataType()));
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(getEffectiveBuiltInType())) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveRangeRestriction((YangRangeRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls
                 * for string resolution.
                 */
        } else if (getEffectiveBuiltInType() == STRING) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangStringRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveStringRestriction((YangStringRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception
                     * in previous function.
                     */
                return RESOLVED;
            }
        }
    }
    /*
         * Check if the data type is the one which can't be restricted, in
         * this case check whether no self restrictions should be present.
         */
    if (isOfValidNonRestrictedType(getEffectiveBuiltInType())) {
        if (Strings.isNullOrEmpty(getLengthRestrictionString()) && Strings.isNullOrEmpty(getRangeRestrictionString()) && getPatternRestriction() == null) {
            return RESOLVED;
        } else {
            throw new DataModelException("YANG file error: Restrictions can't be applied to a given type");
        }
    }
    // Throw exception for unsupported types
    throw new DataModelException("Linker error: Unable to process the derived type.");
}
#end_block

#method_before
private void resolveStringRestriction(YangStringRestriction refStringRestriction) throws DataModelException {
    YangStringRestriction curStringRestriction = null;
    YangRangeRestriction refRangeRestriction = null;
    YangPatternRestriction refPatternRestriction = null;
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refStringRestriction == null && getLengthRestrictionString() == null && getPatternRestriction() == null) {
        return;
    }
    /*
         * If referred string restriction is not null, take value of length
         * and pattern restriction and assign.
         */
    if (refStringRestriction != null) {
        refRangeRestriction = refStringRestriction.getLengthRestriction();
        refPatternRestriction = refStringRestriction.getPatternRestriction();
    }
    YangRangeRestriction lengthRestriction = resolveLengthRestriction(refRangeRestriction);
    YangPatternRestriction patternRestriction = resolvePatternRestriction(refPatternRestriction);
    if (lengthRestriction != null || patternRestriction != null) {
        curStringRestriction = new YangStringRestriction();
        curStringRestriction.setLengthRestriction(lengthRestriction);
        curStringRestriction.setPatternRestriction(patternRestriction);
    }
    setResolvedExtendedInfo((T) curStringRestriction);
}
#method_after
private void resolveStringRestriction(YangStringRestriction refStringRestriction) throws DataModelException {
    YangStringRestriction curStringRestriction = null;
    YangRangeRestriction refRangeRestriction = null;
    YangPatternRestriction refPatternRestriction = null;
    /*
         * Check that range restriction should be null when built-in type is
         * string.
         */
    if (!(Strings.isNullOrEmpty(getRangeRestrictionString()))) {
        DataModelException dataModelException = new DataModelException("YANG file error: Range restriction " + "should't be present for string data type.");
        dataModelException.setLine(lineNumber);
        dataModelException.setCharPosition(charPositionInLine);
        throw dataModelException;
    }
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refStringRestriction == null && Strings.isNullOrEmpty(getLengthRestrictionString()) && getPatternRestriction() == null) {
        return;
    }
    /*
         * If referred string restriction is not null, take value of length
         * and pattern restriction and assign.
         */
    if (refStringRestriction != null) {
        refRangeRestriction = refStringRestriction.getLengthRestriction();
        refPatternRestriction = refStringRestriction.getPatternRestriction();
    }
    YangRangeRestriction lengthRestriction = resolveLengthRestriction(refRangeRestriction);
    YangPatternRestriction patternRestriction = resolvePatternRestriction(refPatternRestriction);
    /*
         * Check if either of length or pattern restriction is present, if yes
         * create string restriction and assign value.
         */
    if (lengthRestriction != null || patternRestriction != null) {
        curStringRestriction = new YangStringRestriction();
        curStringRestriction.setLengthRestriction(lengthRestriction);
        curStringRestriction.setPatternRestriction(patternRestriction);
    }
    setResolvedExtendedInfo((T) curStringRestriction);
}
#end_block

#method_before
private YangPatternRestriction resolvePatternRestriction(YangPatternRestriction refPatternRestriction) {
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refPatternRestriction == null && getPatternRestriction() == null) {
        return null;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (getPatternRestriction() == null) {
        return refPatternRestriction;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refPatternRestriction == null) {
        return getPatternRestriction();
    }
    for (String pattern : refPatternRestriction.getPatternList()) {
        getPatternRestriction().addPattern(pattern);
    }
    return getPatternRestriction();
}
#method_after
private YangPatternRestriction resolvePatternRestriction(YangPatternRestriction refPatternRestriction) {
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refPatternRestriction == null && getPatternRestriction() == null) {
        return null;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (getPatternRestriction() == null) {
        return refPatternRestriction;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refPatternRestriction == null) {
        return getPatternRestriction();
    }
    /*
         * Get patterns of referred type and add it to current pattern
         * restrictions.
         */
    for (String pattern : refPatternRestriction.getPatternList()) {
        getPatternRestriction().addPattern(pattern);
    }
    return getPatternRestriction();
}
#end_block

#method_before
private YangRangeRestriction resolveLengthRestriction(YangRangeRestriction refLengthRestriction) throws DataModelException {
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refLengthRestriction == null && getRangeRestrictionString() == null) {
        return null;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (getRangeRestrictionString() == null) {
        return refLengthRestriction;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refLengthRestriction == null) {
        YangRangeRestriction curLengthRestriction = processLengthRestriction(null, lineNumber, charPositionInLine, false, getRangeRestrictionString());
        return curLengthRestriction;
    }
    /*
         * Carry out self resolution based with obtained effective built-in
         * type and MIN/MAX values as per the referred typedef's values.
         */
    YangRangeRestriction curLengthRestriction = processLengthRestriction(refLengthRestriction, lineNumber, charPositionInLine, false, getRangeRestrictionString());
    // Resolve the range with referred typedef's restriction.
    resolveLengthAndRangeRestriction(refLengthRestriction, curLengthRestriction);
    return curLengthRestriction;
}
#method_after
private YangRangeRestriction resolveLengthRestriction(YangRangeRestriction refLengthRestriction) throws DataModelException {
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refLengthRestriction == null && Strings.isNullOrEmpty(getLengthRestrictionString())) {
        return null;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (Strings.isNullOrEmpty(getLengthRestrictionString())) {
        return refLengthRestriction;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refLengthRestriction == null) {
        YangRangeRestriction curLengthRestriction = processLengthRestriction(null, lineNumber, charPositionInLine, false, getLengthRestrictionString());
        return curLengthRestriction;
    }
    /*
         * Carry out self resolution based with obtained effective built-in
         * type and MIN/MAX values as per the referred typedef's values.
         */
    YangRangeRestriction curLengthRestriction = processLengthRestriction(refLengthRestriction, lineNumber, charPositionInLine, true, getLengthRestrictionString());
    // Resolve the range with referred typedef's restriction.
    resolveLengthAndRangeRestriction(refLengthRestriction, curLengthRestriction);
    return curLengthRestriction;
}
#end_block

#method_before
private void resolveRangeRestriction(YangRangeRestriction refRangeRestriction) throws DataModelException {
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refRangeRestriction == null && getRangeRestrictionString() == null) {
        return;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (getRangeRestrictionString() == null) {
        setResolvedExtendedInfo((T) refRangeRestriction);
        return;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refRangeRestriction == null) {
        YangRangeRestriction curRangeRestriction = processRangeRestriction(null, lineNumber, charPositionInLine, false, getRangeRestrictionString(), getEffectiveBuiltInType());
        setResolvedExtendedInfo((T) curRangeRestriction);
        return;
    }
    /*
         * Carry out self resolution based with obtained effective built-in
         * type and MIN/MAX values as per the referred typedef's values.
         */
    YangRangeRestriction curRangeRestriction = processRangeRestriction(refRangeRestriction, lineNumber, charPositionInLine, false, getRangeRestrictionString(), getEffectiveBuiltInType());
    // Resolve the range with referred typedef's restriction.
    resolveLengthAndRangeRestriction(refRangeRestriction, curRangeRestriction);
    setResolvedExtendedInfo((T) curRangeRestriction);
}
#method_after
private void resolveRangeRestriction(YangRangeRestriction refRangeRestriction) throws DataModelException {
    /*
         * Check that string restriction should be null when built-in type is
         * of range type.
         */
    if (!(Strings.isNullOrEmpty(getLengthRestrictionString())) || getPatternRestriction() != null) {
        DataModelException dataModelException = new DataModelException("YANG file error: Length/Pattern " + "restriction should't be present for int/uint/decimal data type.");
        dataModelException.setLine(lineNumber);
        dataModelException.setCharPosition(charPositionInLine);
        throw dataModelException;
    }
    /*
         * If referred restriction and self restriction both are null, no
         * resolution is required.
         */
    if (refRangeRestriction == null && Strings.isNullOrEmpty(getRangeRestrictionString())) {
        return;
    }
    /*
         * If self restriction is null, and referred restriction is present
         * shallow copy the referred to self.
         */
    if (Strings.isNullOrEmpty(getRangeRestrictionString())) {
        setResolvedExtendedInfo((T) refRangeRestriction);
        return;
    }
    /*
         * If referred restriction is null, and self restriction is present
         * carry out self resolution.
         */
    if (refRangeRestriction == null) {
        YangRangeRestriction curRangeRestriction = processRangeRestriction(null, lineNumber, charPositionInLine, false, getRangeRestrictionString(), getEffectiveBuiltInType());
        setResolvedExtendedInfo((T) curRangeRestriction);
        return;
    }
    /*
         * Carry out self resolution based with obtained effective built-in
         * type and MIN/MAX values as per the referred typedef's values.
         */
    YangRangeRestriction curRangeRestriction = processRangeRestriction(refRangeRestriction, lineNumber, charPositionInLine, true, getRangeRestrictionString(), getEffectiveBuiltInType());
    // Resolve the range with referred typedef's restriction.
    resolveLengthAndRangeRestriction(refRangeRestriction, curRangeRestriction);
    setResolvedExtendedInfo((T) curRangeRestriction);
}
#end_block

#method_before
@Test
public void processValidRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidRangeStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(1));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(4));
}
#method_after
@Test
public void processValidRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidRangeStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(1));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(4));
}
#end_block

#method_before
@Test
public void processRangeStatementInsideLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/RangeStatementInsideLeafList.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(1));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(4));
}
#method_after
@Test
public void processRangeStatementInsideLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/RangeStatementInsideLeafList.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(1));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(4));
}
#end_block

#method_before
@Test
public void processRangeWithOneInterval() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/RangeWithOneInterval.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(1));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(1));
}
#method_after
@Test
public void processRangeWithOneInterval() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/RangeWithOneInterval.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(1));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(1));
}
#end_block

#method_before
@Test
public void processRangeWithMinMax() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/RangeWithMinMax.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(-2147483648));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(2147483647));
}
#method_after
@Test
public void processRangeWithMinMax() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/RangeWithMinMax.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangInt32) rangeInterval.getStartValue()).getValue(), is(-2147483648));
    assertThat(((YangInt32) rangeInterval.getEndValue()).getValue(), is(2147483647));
}
#end_block

#method_before
@Test
public void processRangeWithInvalidIntegerPattern() throws IOException, DataTypeException {
    thrown.expect(DataTypeException.class);
    thrown.expectMessage("YANG file error : a is not valid.");
    YangNode node = manager.getDataModel("src/test/resources/RangeWithInvalidIntegerPattern.yang");
}
#method_after
@Test
public void processRangeWithInvalidIntegerPattern() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : Input value \"a\" is not a valid int32.");
    YangNode node = manager.getDataModel("src/test/resources/RangeWithInvalidIntegerPattern.yang");
}
#end_block

#method_before
private static void setPatternRestriction(YangType type, GeneratedYangParser.PatternStatementContext ctx) {
    YangStringRestriction stringRestriction;
    if (type.getDataType() != YangDataTypes.STRING && type.getDataType() != YangDataTypes.DERIVED) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(PATTERN_DATA) + " name " + ctx.string().getText() + " can be used to restrict the built-in type string or types derived from string.");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    String patternArgument = ctx.string().getText().replace("\"", EMPTY_STRING);
    if (type.getDataType() == YangDataTypes.STRING) {
        stringRestriction = (YangStringRestriction) type.getDataTypeExtendedInfo();
        if (stringRestriction == null) {
            stringRestriction = new YangStringRestriction();
            type.setDataTypeExtendedInfo(stringRestriction);
            stringRestriction.addPattern(patternArgument);
        }
    } else {
        YangPatternRestriction patternRestriction = new YangPatternRestriction();
        ((YangDerivedInfo<?>) type.getDataTypeExtendedInfo()).setPatternRestriction(patternRestriction);
        patternRestriction.addPattern(patternArgument);
    }
}
#method_after
private static void setPatternRestriction(YangType type, GeneratedYangParser.PatternStatementContext ctx) {
    if (type.getDataType() != YangDataTypes.STRING && type.getDataType() != YangDataTypes.DERIVED) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(PATTERN_DATA) + " name " + ctx.string().getText() + " can be used to restrict the built-in type string or types derived from string.");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    String patternArgument = ctx.string().getText().replace("\"", EMPTY_STRING);
    if (type.getDataType() == YangDataTypes.STRING) {
        YangStringRestriction stringRestriction = (YangStringRestriction) type.getDataTypeExtendedInfo();
        if (stringRestriction == null) {
            stringRestriction = new YangStringRestriction();
            type.setDataTypeExtendedInfo(stringRestriction);
            stringRestriction.addPattern(patternArgument);
        } else {
            stringRestriction.addPattern(patternArgument);
        }
    } else {
        YangPatternRestriction patternRestriction = (YangPatternRestriction) ((YangDerivedInfo<?>) type.getDataTypeExtendedInfo()).getPatternRestriction();
        if (patternRestriction == null) {
            patternRestriction = new YangPatternRestriction();
            ((YangDerivedInfo<?>) type.getDataTypeExtendedInfo()).setPatternRestriction(patternRestriction);
            patternRestriction.addPattern(patternArgument);
        } else {
            ((YangDerivedInfo<?>) type.getDataTypeExtendedInfo()).setPatternRestriction(patternRestriction);
            patternRestriction.addPattern(patternArgument);
        }
    }
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenUsesAndGroupingAtRootLevel() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenUsesAndGroupingAtRootLevel.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the sibling of module's child.
    assertThat((yangNode.getChild().getNextSibling() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = grouping.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getLeafName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is module's child.
    assertThat((yangNode.getChild() instanceof YangUses), is(true));
    YangUses uses = (YangUses) yangNode.getChild();
    // Check whether uses get resolved.
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under module.
    assertThat(leafInfo.getLeafName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#method_after
@Test
public void processSelfResolutionWhenUsesAndGroupingAtRootLevel() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenUsesAndGroupingAtRootLevel.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the sibling of module's child.
    assertThat((yangNode.getChild().getNextSibling() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = grouping.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is module's child.
    assertThat((yangNode.getChild() instanceof YangUses), is(true));
    YangUses uses = (YangUses) yangNode.getChild();
    // Check whether uses get resolved.
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under module.
    assertThat(leafInfo.getName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenUsesAndGroupingAtRootLevelGroupingWithChild() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenUsesAndGroupingAtRootLevelGroupingWithChild.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the sibling of module's child.
    assertThat((yangNode.getChild().getNextSibling() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = grouping.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getLeafName(), is("treat"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether container is the child of grouping.
    assertThat((grouping.getChild() instanceof YangContainer), is(true));
    YangContainer container = (YangContainer) grouping.getChild();
    // Check whether the container name is set correctly which is under grouping.
    assertThat(container.getName(), is("test"));
    leafIterator = container.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under container which is under grouping.
    assertThat(leafInfo.getLeafName(), is("leaf2"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is module's child.
    assertThat((yangNode.getChild() instanceof YangUses), is(true));
    YangUses uses = (YangUses) yangNode.getChild();
    // Check whether uses get resolved.
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under module.
    assertThat(leafInfo.getLeafName(), is("treat"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether container is the child of module.
    assertThat((grouping.getNextSibling() instanceof YangContainer), is(true));
    container = (YangContainer) grouping.getNextSibling();
    // Check whether the container name is set correctly which is under module.
    assertThat(container.getName(), is("test"));
    leafIterator = container.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under container which is under module.
    assertThat(leafInfo.getLeafName(), is("leaf2"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#method_after
@Test
public void processSelfResolutionWhenUsesAndGroupingAtRootLevelGroupingWithChild() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenUsesAndGroupingAtRootLevelGroupingWithChild.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the sibling of module's child.
    assertThat((yangNode.getChild().getNextSibling() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = grouping.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("treat"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether container is the child of grouping.
    assertThat((grouping.getChild() instanceof YangContainer), is(true));
    YangContainer container = (YangContainer) grouping.getChild();
    // Check whether the container name is set correctly which is under grouping.
    assertThat(container.getName(), is("test"));
    leafIterator = container.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under container which is under grouping.
    assertThat(leafInfo.getName(), is("leaf2"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is module's child.
    assertThat((yangNode.getChild() instanceof YangUses), is(true));
    YangUses uses = (YangUses) yangNode.getChild();
    // Check whether uses get resolved.
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under module.
    assertThat(leafInfo.getName(), is("treat"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether container is the child of module.
    assertThat((grouping.getNextSibling() instanceof YangContainer), is(true));
    container = (YangContainer) grouping.getNextSibling();
    // Check whether the container name is set correctly which is under module.
    assertThat(container.getName(), is("test"));
    leafIterator = container.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under container which is under module.
    assertThat(leafInfo.getName(), is("leaf2"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#end_block

#method_before
@Test
public void processSelfResolutionGroupingInRpcAndUsesInOutput() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionGroupingInRpcAndUsesInOutput.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the child of rpc.
    assertThat((yangNode.getChild().getChild() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getChild();
    // Check whether the grouping name is set correctly.
    assertThat(grouping.getName(), is("hello"));
    // Check whether list is the child of grouping.
    assertThat((grouping.getChild() instanceof YangList), is(true));
    YangList yangListNode = (YangList) grouping.getChild();
    // Check whether the list name is set correctly.
    assertThat(yangListNode.getName(), is("valid"));
    leafIterator = yangListNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which is under grouping.
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
    // Check whether uses is input's child.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild() instanceof YangUses), is(true));
    YangUses uses = (YangUses) yangNode.getChild().getChild().getNextSibling().getChild();
    // Check whether uses get resolved.
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses which has been deep copied from grouping.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild().getNextSibling() instanceof YangList), is(true));
    YangList yangList = (YangList) yangNode.getChild().getChild().getNextSibling().getChild().getNextSibling();
    // Check whether the list name is set correctly.
    assertThat(yangList.getName(), is("valid"));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which is deep copied.
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
    // Check whether uses is output's child.
    assertThat((yangNode.getChild().getChild().getNextSibling().getNextSibling().getChild() instanceof YangUses), is(true));
    YangUses usesInOuput = (YangUses) yangNode.getChild().getChild().getNextSibling().getNextSibling().getChild();
    // Check whether uses get resolved.
    assertThat(usesInOuput.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses which has been deep copied from grouping.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild().getNextSibling() instanceof YangList), is(true));
    YangList yangListInOutput = (YangList) yangNode.getChild().getChild().getNextSibling().getNextSibling().getChild().getNextSibling();
    // Check whether the list name is set correctly.
    assertThat(yangListInOutput.getName(), is("valid"));
    leafIterator = yangListInOutput.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which is deep copied.
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
}
#method_after
@Test
public void processSelfResolutionGroupingInRpcAndUsesInOutput() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionGroupingInRpcAndUsesInOutput.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the child of rpc.
    assertThat((yangNode.getChild().getChild() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getChild();
    // Check whether the grouping name is set correctly.
    assertThat(grouping.getName(), is("hello"));
    // Check whether list is the child of grouping.
    assertThat((grouping.getChild() instanceof YangList), is(true));
    YangList yangListNode = (YangList) grouping.getChild();
    // Check whether the list name is set correctly.
    assertThat(yangListNode.getName(), is("valid"));
    leafIterator = yangListNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which is under grouping.
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
    // Check whether uses is input's child.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild() instanceof YangUses), is(true));
    YangUses uses = (YangUses) yangNode.getChild().getChild().getNextSibling().getChild();
    // Check whether uses get resolved.
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses which has been deep copied from grouping.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild().getNextSibling() instanceof YangList), is(true));
    YangList yangList = (YangList) yangNode.getChild().getChild().getNextSibling().getChild().getNextSibling();
    // Check whether the list name is set correctly.
    assertThat(yangList.getName(), is("valid"));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which is deep copied.
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
    // Check whether uses is output's child.
    assertThat((yangNode.getChild().getChild().getNextSibling().getNextSibling().getChild() instanceof YangUses), is(true));
    YangUses usesInOuput = (YangUses) yangNode.getChild().getChild().getNextSibling().getNextSibling().getChild();
    // Check whether uses get resolved.
    assertThat(usesInOuput.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses which has been deep copied from grouping.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild().getNextSibling() instanceof YangList), is(true));
    YangList yangListInOutput = (YangList) yangNode.getChild().getChild().getNextSibling().getNextSibling().getChild().getNextSibling();
    // Check whether the list name is set correctly.
    assertThat(yangListInOutput.getName(), is("valid"));
    leafIterator = yangListInOutput.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which is deep copied.
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
}
#end_block

#method_before
@Test
public void processSelfResolutionGroupingWithMultipleUses() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionGroupingWithMultipleUses.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the child of container.
    assertThat((yangNode.getChild().getChild() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getChild();
    // Check whether the grouping name is set correctly.
    assertThat(grouping.getName(), is("endpoint"));
    // Check whether uses is endpoint-grouping's child.
    assertThat((grouping.getChild() instanceof YangUses), is(true));
    YangUses firstUses = (YangUses) grouping.getChild();
    // Check whether uses get resolved.
    assertThat(firstUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether container is the sibling of uses.
    assertThat((firstUses.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainer = (YangContainer) firstUses.getNextSibling();
    // Check whether the container name is set correctly.
    assertThat(yangContainer.getName(), is("design"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under design-container.
    assertThat(leafInfo.getLeafName(), is("ink"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    // Check whether uses is design-container's child.
    assertThat((yangContainer.getChild() instanceof YangUses), is(true));
    YangUses secondUses = (YangUses) yangContainer.getChild();
    // Check whether uses get resolved.
    assertThat(secondUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether container is the sibling of uses.
    assertThat((secondUses.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainer2 = (YangContainer) secondUses.getNextSibling();
    assertThat(yangContainer2.getName(), is("correct"));
    leafIterator = yangContainer2.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under correct-container.
    assertThat(leafInfo.getLeafName(), is("newone"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is correct container's child.
    assertThat((yangContainer2.getChild() instanceof YangUses), is(true));
    YangUses thirdUses = (YangUses) yangContainer2.getChild();
    // Check whether uses get resolved.
    assertThat(thirdUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether container is the sibling of uses.
    assertThat((thirdUses.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainer3 = (YangContainer) thirdUses.getNextSibling();
    assertThat(yangContainer3.getName(), is("value"));
    leafIterator = yangContainer3.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under container
    // which has been deep copied from grouping.
    assertThat(leafInfo.getLeafName(), is("zip-code"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is the sibling of container-design.
    assertThat((yangContainer.getNextSibling() instanceof YangUses), is(true));
    YangUses fourthUses = (YangUses) yangContainer.getNextSibling();
    // Check whether uses get resolved.
    assertThat(fourthUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether uses is the sibling of previous uses.
    assertThat((fourthUses.getNextSibling() instanceof YangUses), is(true));
    YangUses fifthUses = (YangUses) fourthUses.getNextSibling();
    // Check whether uses get resolved.
    assertThat(fifthUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses.
    assertThat((fifthUses.getNextSibling() instanceof YangList), is(true));
    YangList yangList = (YangList) fifthUses.getNextSibling();
    assertThat(yangList.getName(), is("valid"));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which has been deep copied from grouping.
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
    // Check whether typedef is the sibling of list.
    assertThat((yangList.getNextSibling() instanceof YangTypeDef), is(true));
    YangTypeDef yangTypeDef = (YangTypeDef) yangList.getNextSibling();
    assertThat(yangTypeDef.getName(), is("my-type"));
    leafIterator = grouping.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getLeafName(), is("zip-code"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is endpoint-grouping's sibling.
    assertThat((grouping.getNextSibling() instanceof YangUses), is(true));
    YangUses endpointUses = (YangUses) grouping.getNextSibling();
    // Check whether uses get resolved.
    assertThat(endpointUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat((endpointUses.getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling() instanceof YangUses), is(true));
    YangUses yangUsesInEndpoint = (YangUses) endpointUses.getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling();
    assertThat(yangUsesInEndpoint.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat((yangUsesInEndpoint.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainerInEndPoint = (YangContainer) yangUsesInEndpoint.getNextSibling();
    assertThat(yangContainerInEndPoint.getName(), is("design"));
}
#method_after
@Test
public void processSelfResolutionGroupingWithMultipleUses() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionGroupingWithMultipleUses.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the child of container.
    assertThat((yangNode.getChild().getChild() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getChild();
    // Check whether the grouping name is set correctly.
    assertThat(grouping.getName(), is("endpoint"));
    // Check whether uses is endpoint-grouping's child.
    assertThat((grouping.getChild() instanceof YangUses), is(true));
    YangUses firstUses = (YangUses) grouping.getChild();
    // Check whether uses get resolved.
    assertThat(firstUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether container is the sibling of uses.
    assertThat((firstUses.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainer = (YangContainer) firstUses.getNextSibling();
    // Check whether the container name is set correctly.
    assertThat(yangContainer.getName(), is("design"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under design-container.
    assertThat(leafInfo.getName(), is("ink"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("int32"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.INT32));
    // Check whether uses is design-container's child.
    assertThat((yangContainer.getChild() instanceof YangUses), is(true));
    YangUses secondUses = (YangUses) yangContainer.getChild();
    // Check whether uses get resolved.
    assertThat(secondUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether container is the sibling of uses.
    assertThat((secondUses.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainer2 = (YangContainer) secondUses.getNextSibling();
    assertThat(yangContainer2.getName(), is("correct"));
    leafIterator = yangContainer2.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under correct-container.
    assertThat(leafInfo.getName(), is("newone"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is correct container's child.
    assertThat((yangContainer2.getChild() instanceof YangUses), is(true));
    YangUses thirdUses = (YangUses) yangContainer2.getChild();
    // Check whether uses get resolved.
    assertThat(thirdUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether container is the sibling of uses.
    assertThat((thirdUses.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainer3 = (YangContainer) thirdUses.getNextSibling();
    assertThat(yangContainer3.getName(), is("value"));
    leafIterator = yangContainer3.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under container
    // which has been deep copied from grouping.
    assertThat(leafInfo.getName(), is("zip-code"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is the sibling of container-design.
    assertThat((yangContainer.getNextSibling() instanceof YangUses), is(true));
    YangUses fourthUses = (YangUses) yangContainer.getNextSibling();
    // Check whether uses get resolved.
    assertThat(fourthUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether uses is the sibling of previous uses.
    assertThat((fourthUses.getNextSibling() instanceof YangUses), is(true));
    YangUses fifthUses = (YangUses) fourthUses.getNextSibling();
    // Check whether uses get resolved.
    assertThat(fifthUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses.
    assertThat((fifthUses.getNextSibling() instanceof YangList), is(true));
    YangList yangList = (YangList) fifthUses.getNextSibling();
    assertThat(yangList.getName(), is("valid"));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list which has been deep copied from grouping.
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
    assertThat(leafInfo.getUnits(), is("\"seconds\""));
    assertThat(leafInfo.getReference(), is("\"RFC 6020\""));
    // Check whether typedef is the sibling of list.
    assertThat((yangList.getNextSibling() instanceof YangTypeDef), is(true));
    YangTypeDef yangTypeDef = (YangTypeDef) yangList.getNextSibling();
    assertThat(yangTypeDef.getName(), is("my-type"));
    leafIterator = grouping.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("zip-code"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether uses is endpoint-grouping's sibling.
    assertThat((grouping.getNextSibling() instanceof YangUses), is(true));
    YangUses endpointUses = (YangUses) grouping.getNextSibling();
    // Check whether uses get resolved.
    assertThat(endpointUses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat((endpointUses.getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling() instanceof YangUses), is(true));
    YangUses yangUsesInEndpoint = (YangUses) endpointUses.getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling().getNextSibling();
    assertThat(yangUsesInEndpoint.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat((yangUsesInEndpoint.getNextSibling() instanceof YangContainer), is(true));
    YangContainer yangContainerInEndPoint = (YangContainer) yangUsesInEndpoint.getNextSibling();
    assertThat(yangContainerInEndPoint.getName(), is("design"));
}
#end_block

#method_before
@Test
public void processSelfResolutionRpcWithOneTypedefAndTwoGroupingUnderDifferentNode() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionRpcWithOneTypedefAndTwoGroupingUnderDifferentNode.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the child of input.
    assertThat((yangNode.getChild().getChild().getChild() instanceof YangGrouping), is(true));
    YangGrouping groupingUnderInput = (YangGrouping) yangNode.getChild().getChild().getChild();
    // Check whether the grouping name is set correctly.
    assertThat(groupingUnderInput.getName(), is("creative"));
    leafIterator = groupingUnderInput.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getLeafName(), is("carry"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether grouping is the child of output.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getChild().getNextSibling().getChild();
    assertThat(grouping.getName(), is("creative"));
    // Check whether typedef is the sibling of grouping.
    assertThat((grouping.getNextSibling() instanceof YangTypeDef), is(true));
    YangTypeDef typedef = (YangTypeDef) grouping.getNextSibling();
    assertThat(typedef.getName(), is("my-type"));
    // Check whether uses is the sibling of typedef.
    assertThat((typedef.getNextSibling() instanceof YangUses), is(true));
    // Check whether uses get resolved.
    YangUses uses = (YangUses) typedef.getNextSibling();
    assertThat(uses.getName(), is("creative"));
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses.
    assertThat((uses.getNextSibling() instanceof YangList), is(true));
    YangList list = (YangList) uses.getNextSibling();
    assertThat(list.getName(), is("valid"));
    leafIterator = list.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list.
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
}
#method_after
@Test
public void processSelfResolutionRpcWithOneTypedefAndTwoGroupingUnderDifferentNode() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionRpcWithOneTypedefAndTwoGroupingUnderDifferentNode.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // Check whether grouping is the child of input.
    assertThat((yangNode.getChild().getChild().getChild() instanceof YangGrouping), is(true));
    YangGrouping groupingUnderInput = (YangGrouping) yangNode.getChild().getChild().getChild();
    // Check whether the grouping name is set correctly.
    assertThat(groupingUnderInput.getName(), is("creative"));
    leafIterator = groupingUnderInput.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("carry"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    // Check whether grouping is the child of output.
    assertThat((yangNode.getChild().getChild().getNextSibling().getChild() instanceof YangGrouping), is(true));
    YangGrouping grouping = (YangGrouping) yangNode.getChild().getChild().getNextSibling().getChild();
    assertThat(grouping.getName(), is("creative"));
    // Check whether typedef is the sibling of grouping.
    assertThat((grouping.getNextSibling() instanceof YangTypeDef), is(true));
    YangTypeDef typedef = (YangTypeDef) grouping.getNextSibling();
    assertThat(typedef.getName(), is("my-type"));
    // Check whether uses is the sibling of typedef.
    assertThat((typedef.getNextSibling() instanceof YangUses), is(true));
    // Check whether uses get resolved.
    YangUses uses = (YangUses) typedef.getNextSibling();
    assertThat(uses.getName(), is("creative"));
    assertThat(uses.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether list is the sibling of uses.
    assertThat((uses.getNextSibling() instanceof YangList), is(true));
    YangList list = (YangList) uses.getNextSibling();
    assertThat(list.getName(), is("valid"));
    leafIterator = list.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under list.
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.UINT16));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithGroupingWithSelfModulePrefix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithGroupingWithSelfModulePrefix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    // Check whether container is the sibling of grouping.
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    // Check whether list is the child of container.
    YangList yangList = (YangList) yangContainer.getChild();
    // Check whether uses is the child of list.
    assertThat((yangList.getChild() instanceof YangUses), is(true));
    YangUses yangUses1 = (YangUses) yangList.getChild();
    assertThat(yangUses1.getName(), is("FirstClass"));
    // Check whether uses is getting resolved.
    assertThat(yangUses1.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether grouping is the sibling of uses.
    YangGrouping yangGrouping1 = (YangGrouping) yangUses1.getNextSibling();
    assertThat(yangGrouping1.getName(), is("FirstClass"));
    // Check whether uses is the child of grouping.
    YangUses yangUses2 = (YangUses) yangGrouping1.getChild();
    assertThat(yangUses2.getName(), is("PassingClass"));
    // Check the uses gets resolved.
    assertThat(yangUses2.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether grouping is the sibling of list.
    YangGrouping yangGrouping2 = (YangGrouping) yangList.getNextSibling();
    assertThat(yangGrouping2.getName(), is("PassingClass"));
    // Check uses is the child of that grouping which has prefix of the same module.
    YangUses yangUses3 = (YangUses) yangGrouping2.getChild();
    assertThat(yangUses3.getName(), is("Percentage"));
    // Check uses is getting resolved.
    assertThat(yangUses3.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check grouping is the child of module.
    YangGrouping yangGrouping3 = (YangGrouping) node.getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangGrouping3.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getLeafName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#method_after
@Test
public void processSelfFileLinkingWithGroupingWithSelfModulePrefix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithGroupingWithSelfModulePrefix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    // Check whether container is the sibling of grouping.
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    // Check whether list is the child of container.
    YangList yangList = (YangList) yangContainer.getChild();
    // Check whether uses is the child of list.
    assertThat((yangList.getChild() instanceof YangUses), is(true));
    YangUses yangUses1 = (YangUses) yangList.getChild();
    assertThat(yangUses1.getName(), is("FirstClass"));
    // Check whether uses is getting resolved.
    assertThat(yangUses1.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether grouping is the sibling of uses.
    YangGrouping yangGrouping1 = (YangGrouping) yangUses1.getNextSibling();
    assertThat(yangGrouping1.getName(), is("FirstClass"));
    // Check whether uses is the child of grouping.
    YangUses yangUses2 = (YangUses) yangGrouping1.getChild();
    assertThat(yangUses2.getName(), is("PassingClass"));
    // Check the uses gets resolved.
    assertThat(yangUses2.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether grouping is the sibling of list.
    YangGrouping yangGrouping2 = (YangGrouping) yangList.getNextSibling();
    assertThat(yangGrouping2.getName(), is("PassingClass"));
    // Check uses is the child of that grouping which has prefix of the same module.
    YangUses yangUses3 = (YangUses) yangGrouping2.getChild();
    assertThat(yangUses3.getName(), is("Percentage"));
    // Check uses is getting resolved.
    assertThat(yangUses3.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check grouping is the child of module.
    YangGrouping yangGrouping3 = (YangGrouping) node.getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangGrouping3.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithGroupingWithSelfAndExternalPrefixMix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithGroupingWithSelfAndExternalPrefixMix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    // Check whether container is the sibling of grouping.
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    // Check whether list is the child of container.
    YangList yangList = (YangList) yangContainer.getChild();
    // Check whether uses is the child of list.
    assertThat((yangList.getChild() instanceof YangUses), is(true));
    YangUses yangUses1 = (YangUses) yangList.getChild();
    assertThat(yangUses1.getName(), is("FirstClass"));
    // Check whether uses is getting resolved.
    assertThat(yangUses1.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether grouping is the sibling of uses.
    YangGrouping yangGrouping1 = (YangGrouping) yangUses1.getNextSibling();
    assertThat(yangGrouping1.getName(), is("FirstClass"));
    // Check whether uses is the child of grouping which has prefix from other module.
    YangUses yangUses2 = (YangUses) yangGrouping1.getChild();
    assertThat(yangUses2.getName(), is("PassingClass"));
    // Check whether uses gets intra-file-resolved.
    assertThat(yangUses2.getResolvableStatus(), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    // Check whether grouping is the sibling of list.
    YangGrouping yangGrouping2 = (YangGrouping) yangList.getNextSibling();
    assertThat(yangGrouping2.getName(), is("PassingClass"));
    // Check uses is the child of that grouping which has prefix of the same module.
    YangUses yangUses3 = (YangUses) yangGrouping2.getChild();
    assertThat(yangUses3.getName(), is("Percentage"));
    // Check uses is getting resolved.
    assertThat(yangUses3.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check grouping is the child of module.
    YangGrouping yangGrouping3 = (YangGrouping) node.getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangGrouping3.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getLeafName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#method_after
@Test
public void processSelfFileLinkingWithGroupingWithSelfAndExternalPrefixMix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithGroupingWithSelfAndExternalPrefixMix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    // Check whether container is the sibling of grouping.
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    // Check whether list is the child of container.
    YangList yangList = (YangList) yangContainer.getChild();
    // Check whether uses is the child of list.
    assertThat((yangList.getChild() instanceof YangUses), is(true));
    YangUses yangUses1 = (YangUses) yangList.getChild();
    assertThat(yangUses1.getName(), is("FirstClass"));
    // Check whether uses is getting resolved.
    assertThat(yangUses1.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check whether grouping is the sibling of uses.
    YangGrouping yangGrouping1 = (YangGrouping) yangUses1.getNextSibling();
    assertThat(yangGrouping1.getName(), is("FirstClass"));
    // Check whether uses is the child of grouping which has prefix from other module.
    YangUses yangUses2 = (YangUses) yangGrouping1.getChild();
    assertThat(yangUses2.getName(), is("PassingClass"));
    // Check whether uses gets intra-file-resolved.
    assertThat(yangUses2.getResolvableStatus(), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    // Check whether grouping is the sibling of list.
    YangGrouping yangGrouping2 = (YangGrouping) yangList.getNextSibling();
    assertThat(yangGrouping2.getName(), is("PassingClass"));
    // Check uses is the child of that grouping which has prefix of the same module.
    YangUses yangUses3 = (YangUses) yangGrouping2.getChild();
    assertThat(yangUses3.getName(), is("Percentage"));
    // Check uses is getting resolved.
    assertThat(yangUses3.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check grouping is the child of module.
    YangGrouping yangGrouping3 = (YangGrouping) node.getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangGrouping3.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenTypeAndTypedefAtRootLevel() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenTypeAndTypedefAtRootLevel.yang");
    // Check whether the data model tree returned is of type module.
    assertThat(node instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
}
#method_after
@Test
public void processSelfResolutionWhenTypeAndTypedefAtRootLevel() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenTypeAndTypedefAtRootLevel.yang");
    // Check whether the data model tree returned is of type module.
    assertThat(node instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(STRING));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(STRING));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingTypedefAtRootIsAfterContainerHavingType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootIsAfterContainerHavingType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild().getNextSibling()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingTypedefAtRootIsAfterContainerHavingType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootIsAfterContainerHavingType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild().getNextSibling()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(STRING));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingTypedefAtMiddleLevelAfterParentHolder() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtMiddleLevelAfterParentHolder.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingTypedefAtMiddleLevelAfterParentHolder() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtMiddleLevelAfterParentHolder.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(STRING));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypdefHierarchicalReference() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalReference.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypdefHierarchicalReference() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalReference.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(INT32));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypdefHierarchicalRefUnresolved() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalRefUnresolved.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypdefHierarchicalRefUnresolved() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalRefUnresolved.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(nullValue()));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypeWithSelfModulePrefix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfModulePrefix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypeWithSelfModulePrefix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfModulePrefix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(INT32));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypeWithSelfAndExternalPrefixMix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfAndExternalPrefixMix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypeWithSelfAndExternalPrefixMix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfAndExternalPrefixMix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(nullValue()));
    // Check for the restriction.
    assertThat(derivedInfo.getLengthRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getRangeRestrictionString(), is(nullValue()));
    assertThat(derivedInfo.getPatternRestriction(), is(nullValue()));
    assertThat(derivedInfo.getResolvedExtendedInfo(), is(nullValue()));
}
#end_block

#method_before
public boolean establishConnectivity(CarrierEthernetService originalService) {
    // If service already exists, remove it and reestablish with new parameters
    if (originalService.id() != null && serviceMap.containsKey(originalService.id())) {
        return updateService(originalService);
    } else {
        originalService.setId(null);
    }
    CarrierEthernetService service = validateService(originalService);
    boolean outcome = false;
    if (service == null) {
        log.error("Service could not be installed, please check log for details.");
        return outcome;
    }
    // Temporary set for iterating through service UNI pairs
    Set<CarrierEthernetUni> uniSet = service.uniSet();
    // Temporary set for indicating which UNIs were finally included in the service
    Set<CarrierEthernetUni> usedUniSet = new HashSet<>();
    Iterator<CarrierEthernetUni> it1 = uniSet.iterator();
    while (it1.hasNext()) {
        CarrierEthernetUni uni1 = it1.next();
        // Iterate through all the remaining UNIs
        Iterator<CarrierEthernetUni> it2 = uniSet.iterator();
        while (it2.hasNext()) {
            CarrierEthernetUni uni2 = it2.next();
            // Skip equals
            if (uni1.equals(uni2)) {
                continue;
            }
            // Do not establish connectivity between leaf UNIs (applies to Rooted_Multipoint)
            if (uni1.type() == CarrierEthernetUni.Type.LEAF && uni2.type() == CarrierEthernetUni.Type.LEAF) {
                continue;
            }
            MetroConnectivityId metroConnectId = null;
            if (PACKET_OPTICAL_TOPO) {
                metroConnectId = setupMetroConnectivity(uni1.cp(), uni2.cp(), uni1.bwp().cir(), service.latency());
                if (metroConnectId == null || metroConnectStatusMap.get(metroConnectId) != MetroPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish metro connectivity between {} and {}" + " (metro id and status: {}, {})", uni1.cp(), uni2.cp(), metroConnectId, (metroConnectId == null ? "null" : metroConnectStatusMap.get(metroConnectId)));
                // continue;
                }
                if (metroConnectId != null) {
                    service.setMetroConnectivityId(metroConnectId);
                    service.setMetroConnectivityStatus(metroConnectStatusMap.get(metroConnectId));
                }
                log.info("Metro connectivity id and status for CE service {}: {}, {}", service.id(), service.metroConnectivity().id(), service.metroConnectivity().status());
                // FIXME: Temporary hack for ONS: Get vlanId from metro app
                if (metroConnectId != null) {
                    Optional<VlanId> vlanId = getVlanTag(metroPathService.getPath(metroConnectId));
                    if (vlanId.isPresent()) {
                        service.setVlanId(vlanId.get());
                    }
                }
            }
            if (!cePktProvisioner.setupConnectivity(uni1, uni2, service)) {
                log.warn("Could not set up packet connectivity between {} and {}", uni1, uni2);
                removeMetroConnectivity(metroConnectId);
                continue;
            }
            // Indicate that connection for at least one UNI pair has been established
            outcome = true;
            // Add UNIs to the set of UNIs used by the service
            usedUniSet.add(uni1);
            usedUniSet.add(uni2);
        }
        // Remove UNI from temporary set so that each pair is visited only once
        it1.remove();
    }
    // Update the service UNI set, based on the UNIs actually used
    service.setUniSet(usedUniSet);
    // If no pair was connected, do not register the service
    if (outcome) {
        serviceMap.put(service.id(), service);
        cePktProvisioner.applyBandwidthProfiles(service);
        // Apply the BWPs of the service UNI to the global UNIs, creating them if needed
        applyBandwidthProfiles(service.uniSet());
    }
    return outcome;
}
#method_after
public boolean establishConnectivity(CarrierEthernetService originalService) {
    // If service already exists, remove it and reestablish with new parameters
    if (originalService.id() != null && serviceMap.containsKey(originalService.id())) {
        return updateService(originalService);
    } else {
        originalService.setId(null);
    }
    CarrierEthernetService service = validateService(originalService);
    boolean outcome = false;
    if (service == null) {
        log.error("Service could not be installed, please check log for details.");
        return outcome;
    }
    // Temporary set for iterating through service UNI pairs
    Set<CarrierEthernetUni> uniSet = service.uniSet();
    // Temporary set for indicating which UNIs were finally included in the service
    Set<CarrierEthernetUni> usedUniSet = new HashSet<>();
    Iterator<CarrierEthernetUni> it1 = uniSet.iterator();
    while (it1.hasNext()) {
        CarrierEthernetUni uni1 = it1.next();
        // Iterate through all the remaining UNIs
        Iterator<CarrierEthernetUni> it2 = uniSet.iterator();
        while (it2.hasNext()) {
            CarrierEthernetUni uni2 = it2.next();
            // Skip equals
            if (uni1.equals(uni2)) {
                continue;
            }
            // Do not establish connectivity between leaf UNIs (applies to Rooted_Multipoint)
            if (uni1.type() == CarrierEthernetUni.Type.LEAF && uni2.type() == CarrierEthernetUni.Type.LEAF) {
                continue;
            }
            MetroConnectivityId metroConnectId = null;
            if (PACKET_OPTICAL_TOPO) {
                metroConnectId = setupMetroConnectivity(uni1.cp(), uni2.cp(), uni1.bwp().cir(), service.latency());
                if (metroConnectId == null || metroConnectStatusMap.get(metroConnectId) != MetroPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish metro connectivity between {} and {}" + " (metro id and status: {}, {})", uni1.cp(), uni2.cp(), metroConnectId, (metroConnectId == null ? "null" : metroConnectStatusMap.get(metroConnectId)));
                // continue;
                }
                if (metroConnectId != null) {
                    service.setMetroConnectivityId(metroConnectId);
                    service.setMetroConnectivityStatus(metroConnectStatusMap.get(metroConnectId));
                }
                log.info("Metro connectivity id and status for CE service {}: {}, {}", service.id(), service.metroConnectivity().id(), service.metroConnectivity().status());
                if (metroConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    Optional<VlanId> vlanId = getVlanTag(metroPathService.getPath(metroConnectId));
                    if (vlanId.isPresent()) {
                        log.info("VLAN ID {} is assigned to CE service {}", vlanId.get(), service.id());
                        service.setVlanId(vlanId.get());
                    }
                }
            }
            if (!cePktProvisioner.setupConnectivity(uni1, uni2, service)) {
                log.warn("Could not set up packet connectivity between {} and {}", uni1, uni2);
                removeMetroConnectivity(metroConnectId);
                continue;
            }
            // Indicate that connection for at least one UNI pair has been established
            outcome = true;
            // Add UNIs to the set of UNIs used by the service
            usedUniSet.add(uni1);
            usedUniSet.add(uni2);
        }
        // Remove UNI from temporary set so that each pair is visited only once
        it1.remove();
    }
    // Update the service UNI set, based on the UNIs actually used
    service.setUniSet(usedUniSet);
    // If no pair was connected, do not register the service
    if (outcome) {
        serviceMap.put(service.id(), service);
        cePktProvisioner.applyBandwidthProfiles(service);
        // Apply the BWPs of the service UNI to the global UNIs, creating them if needed
        applyBandwidthProfiles(service.uniSet());
    }
    return outcome;
}
#end_block

#method_before
public GatewayNode build() {
    return new GatewayNode(checkNotNull(externalInterfaceMacs), checkNotNull(gatewayDeviceId), checkNotNull(gatewayExternalInterfaceNames), checkNotNull(dataIpAddress));
}
#method_after
public GatewayNode build() {
    return new GatewayNode(checkNotNull(gatewayDeviceId), checkNotNull(gatewayExternalInterfaceNames), checkNotNull(dataIpAddress));
}
#end_block

#method_before
@Override
public GroupId getGroupIdForGatewayLoadBalance(Algorithm algorithm) {
    return null;
}
#method_after
@Override
public GroupId getGroupIdForGatewayLoadBalance(DeviceId srcDeviceId) {
    return null;
}
#end_block

#method_before
@Test
public void testPostVirtualNetworkNullTenantId() {
    replay(mockVnetAdminService);
    WebTarget wt = target();
    try {
        String response = wt.path("vnets").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(null), String.class);
        fail("POST of null virtual network did not throw an exception");
    } catch (BadRequestException ex) {
        assertThat(ex.getMessage(), containsString("HTTP 400 Bad Request"));
    }
    verify(mockVnetAdminService);
}
#method_after
@Test
public void testPostVirtualNetworkNullTenantId() {
    replay(mockVnetAdminService);
    WebTarget wt = target();
    try {
        wt.path("vnets").request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(null), String.class);
        fail("POST of null virtual network did not throw an exception");
    } catch (BadRequestException ex) {
        assertThat(ex.getMessage(), containsString("HTTP 400 Bad Request"));
    }
    verify(mockVnetAdminService);
}
#end_block

#method_before
@Test
public void testPostVirtualDeviceNullJsonStream() {
    NetworkId networkId = networkId3;
    replay(mockVnetAdminService);
    WebTarget wt = target();
    try {
        String reqLocation = "vnets/" + networkId.toString() + "/devices";
        String response = wt.path(reqLocation).request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(null), String.class);
        fail("POST of null virtual device did not throw an exception");
    } catch (BadRequestException ex) {
        assertThat(ex.getMessage(), containsString("HTTP 400 Bad Request"));
    }
    verify(mockVnetAdminService);
}
#method_after
@Test
public void testPostVirtualDeviceNullJsonStream() {
    NetworkId networkId = networkId3;
    replay(mockVnetAdminService);
    WebTarget wt = target();
    try {
        String reqLocation = "vnets/" + networkId.toString() + "/devices";
        wt.path(reqLocation).request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(null), String.class);
        fail("POST of null virtual device did not throw an exception");
    } catch (BadRequestException ex) {
        assertThat(ex.getMessage(), containsString("HTTP 400 Bad Request"));
    }
    verify(mockVnetAdminService);
}
#end_block

#method_before
@Test
public void testPostVirtualPortNullJsonStream() {
    NetworkId networkId = networkId3;
    DeviceId deviceId = devId2;
    replay(mockVnetAdminService);
    WebTarget wt = target();
    try {
        String reqLocation = "vnets/" + networkId.toString() + "/devices/" + deviceId.toString() + "/ports";
        String response = wt.path(reqLocation).request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(null), String.class);
        fail("POST of null virtual port did not throw an exception");
    } catch (BadRequestException ex) {
        assertThat(ex.getMessage(), containsString("HTTP 400 Bad Request"));
    }
    verify(mockVnetAdminService);
}
#method_after
@Test
public void testPostVirtualPortNullJsonStream() {
    NetworkId networkId = networkId3;
    DeviceId deviceId = devId2;
    replay(mockVnetAdminService);
    WebTarget wt = target();
    try {
        String reqLocation = "vnets/" + networkId.toString() + "/devices/" + deviceId.toString() + "/ports";
        wt.path(reqLocation).request(MediaType.APPLICATION_JSON_TYPE).post(Entity.json(null), String.class);
        fail("POST of null virtual port did not throw an exception");
    } catch (BadRequestException ex) {
        assertThat(ex.getMessage(), containsString("HTTP 400 Bad Request"));
    }
    verify(mockVnetAdminService);
}
#end_block

#method_before
@Test
public void testDeleteVirtualLink() {
    NetworkId networkId = networkId3;
    mockVnetAdminService.removeVirtualLink(networkId, cp22, cp11);
    expectLastCall();
    replay(mockVnetAdminService);
    WebTarget wt = target().property(ClientProperties.SUPPRESS_HTTP_COMPLIANCE_VALIDATION, true);
    InputStream jsonStream = VirtualNetworkWebResourceTest.class.getResourceAsStream("post-virtual-link.json");
    String reqLocation = "vnets/" + networkId.toString() + "/links";
    Response response = wt.path(reqLocation).request().accept(MediaType.APPLICATION_JSON_TYPE).method("DELETE", Entity.json(jsonStream));
// Response response = wt.path(reqLocation).request().method("DELETE", Entity.json(jsonStream));
// assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
// verify(mockVnetAdminService);
}
#method_after
@Test
public void testDeleteVirtualLink() {
    NetworkId networkId = networkId3;
    mockVnetAdminService.removeVirtualLink(networkId, cp22, cp11);
    expectLastCall();
    replay(mockVnetAdminService);
    WebTarget wt = target().property(ClientProperties.SUPPRESS_HTTP_COMPLIANCE_VALIDATION, true);
    InputStream jsonStream = VirtualNetworkWebResourceTest.class.getResourceAsStream("post-virtual-link.json");
    String reqLocation = "vnets/" + networkId.toString() + "/links";
    Response response = wt.path(reqLocation).request().method("DELETE", Entity.json(jsonStream));
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_OK));
    verify(mockVnetAdminService);
}
#end_block

#method_before
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // Get the pcc client
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    pcepSetupTunnel(tunnel, path, pc);
}
#method_after
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // Get the pcc client
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // If stateful and PC Initiation capability is not supported by client not sending Initiate msg
    if (pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    pcepSetupTunnel(tunnel, path, pc);
}
#method_after
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void releaseTunnel(Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    pcepReleaseTunnel(tunnel, pc);
}
#method_after
@Override
public void releaseTunnel(Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#end_block

#method_before
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    pcepReleaseTunnel(tunnel, pc);
}
#method_after
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#end_block

#method_before
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    pcepUpdateTunnel(tunnel, path, pc);
}
#method_after
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    if (pc.capability().statefulPceCapability()) {
        pcepUpdateTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    pcepUpdateTunnel(tunnel, path, pc);
}
#method_after
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().statefulPceCapability()) {
        pcepUpdateTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Test
public void testCasePcepReleaseTunnel() {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.pcepTunnelApiMapper = pcepTunnelAPIMapper;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.activate();
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<Link>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, EMPTY);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
}
#method_after
@Test
public void testCasePcepReleaseTunnel() {
    Tunnel tunnel;
    Path path;
    List<Link> links = new ArrayList<Link>();
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    IpAddress srcIp = IpAddress.valueOf(0xB6024E20);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xB6024E21);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, EMPTY);
    // for releasing tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.DELETE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.releaseTunnel(tunnel);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepSetupTunnel() {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, EMPTY);
    tunnelProvider.setupTunnel(tunnel, path);
}
#method_after
@Test
public void testCasePcepSetupTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xC010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xC010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 10, EMPTY);
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, EMPTY);
    tunnelProvider.setupTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@Test
public void testCasePcepUpdateTunnel() {
    tunnelProvider.tunnelProviderRegistry = registry;
    tunnelProvider.pcepClientController = controller;
    tunnelProvider.controller = ctl;
    tunnelProvider.pcepTunnelApiMapper = pcepTunnelAPIMapper;
    tunnelProvider.cfgService = new ComponentConfigAdapter();
    tunnelProvider.tunnelService = tunnelService;
    tunnelProvider.activate();
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, EMPTY);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
}
#method_after
@Test
public void testCasePcepUpdateTunnel() {
    Tunnel tunnel;
    Path path;
    ProviderId pid = new ProviderId("pcep", PROVIDER_ID);
    List<Link> links = new ArrayList<Link>();
    IpAddress srcIp = IpAddress.valueOf(0xD010101);
    IpElementId srcElementId = IpElementId.ipElement(srcIp);
    IpAddress dstIp = IpAddress.valueOf(0xD010102);
    IpElementId dstElementId = IpElementId.ipElement(dstIp);
    IpTunnelEndPoint ipTunnelEndPointSrc;
    ipTunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(srcIp);
    IpTunnelEndPoint ipTunnelEndPointDst;
    ipTunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(dstIp);
    ConnectPoint src = new ConnectPoint(srcElementId, PortNumber.portNumber(10023));
    ConnectPoint dst = new ConnectPoint(dstElementId, PortNumber.portNumber(10023));
    Link link = DefaultLink.builder().providerId(pid).src(src).dst(dst).type(Link.Type.DIRECT).build();
    links.add(link);
    path = new DefaultPath(pid, links, 20, EMPTY);
    tunnel = new DefaultTunnel(pid, ipTunnelEndPointSrc, ipTunnelEndPointDst, Tunnel.Type.MPLS, new DefaultGroupId(0), TunnelId.valueOf("1"), TunnelName.tunnelName("T123"), path, EMPTY);
    // for updating tunnel tunnel should exist in db
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelData.setPlspId(1);
    StatefulIPv4LspIdentidiersTlv tlv = new StatefulIPv4LspIdentidiersTlv(0, (short) 1, (short) 2, 3, 4);
    pcepTunnelData.setStatefulIpv4IndentifierTlv(tlv);
    tunnelProvider.pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
    tunnelProvider.pcepTunnelApiMapper.handleCreateTunnelRequestQueue(1, pcepTunnelData);
    tunnelProvider.updateTunnel(tunnel, path);
    assertThat(tunnelProvider.pcepTunnelApiMapper, not(nullValue()));
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/master")
public Response getMasterFor(@PathParam("deviceId") String deviceId) {
    NodeId id = mastershipService.getMasterFor(DeviceId.deviceId(deviceId));
    ObjectNode root = mapper().createObjectNode();
    root.put(NODE, id.id());
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/master")
public Response getMasterFor(@PathParam("deviceId") String deviceId) {
    NodeId id = nullIsNotFound(mastershipService.getMasterFor(DeviceId.deviceId(deviceId)), NODE_ID_NOT_FOUND);
    ObjectNode root = mapper().createObjectNode();
    root.put(NODE, id.id());
    return ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/role")
public Response getNodesFor(@PathParam("deviceId") String deviceId) {
    RoleInfo info = mastershipService.getNodesFor(DeviceId.deviceId(deviceId));
    ObjectNode root = codec(RoleInfo.class).encode(info, this);
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/role")
public Response getNodesFor(@PathParam("deviceId") String deviceId) {
    RoleInfo info = nullIsNotFound(mastershipService.getNodesFor(DeviceId.deviceId(deviceId)), ROLE_INFO_NOT_FOUND);
    ObjectNode root = codec(RoleInfo.class).encode(info, this);
    return ok(root).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/request")
public Response requestRoleFor(@PathParam("deviceId") String deviceId) {
    // TODO: will not use CompletableFuture when MastershipService
    // provides a non CompletableFuture object as an output
    CompletableFuture<MastershipRole> result = mastershipService.requestRoleFor(DeviceId.deviceId(deviceId));
    try {
        MastershipRole role = result.get();
        ObjectNode root = codec(MastershipRole.class).encode(role, this);
        return ok(root).build();
    } catch (InterruptedException | ExecutionException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/request")
public Response requestRoleFor(@PathParam("deviceId") String deviceId) {
    // TODO: will not use CompletableFuture when MastershipService
    // provides a non CompletableFuture object as an output
    CompletableFuture<MastershipRole> result = nullIsNotFound(mastershipService.requestRoleFor(DeviceId.deviceId(deviceId)), MASTERSHIP_ROLE_NOT_FOUND);
    try {
        MastershipRole role = result.get();
        ObjectNode root = codec(MastershipRole.class).encode(role, this);
        return ok(root).build();
    } catch (InterruptedException | ExecutionException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/relinquish")
public Response relinquishMastership(@PathParam("deviceId") String deviceId) {
    DeviceId id = DeviceId.deviceId(deviceId);
    // TODO: will not use CompletableFuture when MastershipService
    // provides a non CompletableFuture object as an output
    CompletableFuture<Void> result = mastershipService.relinquishMastership(id);
    try {
        result.get();
        return Response.created(id.uri()).build();
    } catch (InterruptedException | ExecutionException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{deviceId}/relinquish")
public Response relinquishMastership(@PathParam("deviceId") String deviceId) {
    DeviceId id = DeviceId.deviceId(deviceId);
    // TODO: will not use CompletableFuture when MastershipService
    // provides a non CompletableFuture object as an output
    CompletableFuture<Void> result = nullIsNotFound(mastershipService.relinquishMastership(id), RESULT_NOT_FOUND);
    try {
        result.get();
        return Response.created(id.uri()).build();
    } catch (InterruptedException | ExecutionException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@PUT
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response setRole(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode deviceIdJson = jsonTree.get(DEVICE_ID);
        JsonNode nodeIdJson = jsonTree.get(NODE_ID);
        MastershipRole role = codec(MastershipRole.class).decode(jsonTree, this);
        if (deviceIdJson == null) {
            throw new IllegalArgumentException(DEVICE_ID_INVALID);
        }
        if (nodeIdJson == null) {
            throw new IllegalArgumentException(NODE_ID_INVALID);
        }
        // TODO: will not use CompletableFuture when MastershipAdminService
        // provides a non CompletableFuture object as an output
        mastershipAdminService.setRole(NodeId.nodeId(nodeIdJson.asText()), DeviceId.deviceId(deviceIdJson.asText()), role).get();
        return Response.ok().build();
    } catch (InterruptedException | ExecutionException | IOException e) {
        throw new IllegalArgumentException(e);
    }
}
#method_after
@PUT
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response setRole(InputStream stream) {
    try {
        ObjectNode jsonTree = (ObjectNode) mapper().readTree(stream);
        JsonNode deviceIdJson = jsonTree.get(DEVICE_ID);
        JsonNode nodeIdJson = jsonTree.get(NODE_ID);
        MastershipRole role = codec(MastershipRole.class).decode(jsonTree, this);
        if (deviceIdJson == null) {
            throw new IllegalArgumentException(DEVICE_ID_INVALID);
        }
        if (nodeIdJson == null) {
            throw new IllegalArgumentException(NODE_ID_INVALID);
        }
        // TODO: will not use CompletableFuture when MastershipAdminService
        // provides a non CompletableFuture object as an output
        CompletableFuture<Void> result = nullIsNotFound(mastershipAdminService.setRole(NodeId.nodeId(nodeIdJson.asText()), DeviceId.deviceId(deviceIdJson.asText()), role), RESULT_NOT_FOUND);
        result.get();
        return Response.ok().build();
    } catch (InterruptedException | ExecutionException | IOException e) {
        throw new IllegalArgumentException(e);
    }
}
#end_block

#method_before
@Override
public void handleOutgoingMessage(Dpid dpid, OFMessage msg) {
    if (msg.getType() == OFType.PACKET_OUT || msg.getType() == OFType.FLOW_MOD || msg.getType() == OFType.STATS_REQUEST) {
        aggregators.computeIfPresent(dpid, (k, v) -> {
            v.increment(msg);
            return v;
        });
    }
}
#method_after
@Override
public void handleOutgoingMessage(Dpid dpid, List<OFMessage> msgs) {
    for (OFMessage msg : msgs) {
        if (msg.getType() == OFType.PACKET_OUT || msg.getType() == OFType.FLOW_MOD || msg.getType() == OFType.STATS_REQUEST) {
            aggregators.computeIfPresent(dpid, (k, v) -> {
                v.increment(msg);
                return v;
            });
        }
    }
}
#end_block

#method_before
@Override
public final void sendMsg(List<OFMessage> msgs) {
    /*
           It is possible that in this block, we transition to SLAVE/EQUAL.
           If this is the case, the supplied messages will race with the
           RoleRequest message, and they could be rejected by the switch.
           In the interest of performance, we will not protect this block with
           a synchronization primitive, because the message would have just been
           dropped anyway.
        */
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
}
#method_after
@Override
public final void sendMsg(List<OFMessage> msgs) {
    if (role == RoleState.MASTER) {
        // fast path send when we are master
        sendMsgsOnChannel(msgs);
        return;
    }
    // check to see if mastership transition is in progress
    synchronized (messagesPendingMastership) {
        /*
               messagesPendingMastership is used as synchronization variable for
               all mastership related changes. In this block, mastership (including
               role update) will have either occurred or not.
            */
        if (role == RoleState.MASTER) {
            // transition to MASTER complete, send messages
            sendMsgsOnChannel(msgs);
            return;
        }
        List<OFMessage> messages = messagesPendingMastership.get();
        if (messages != null) {
            // we are transitioning to MASTER, so add messages to queue
            messages.addAll(msgs);
            log.debug("Enqueue message for switch {}. queue size after is {}", dpid, messages.size());
        } else {
            // not transitioning to MASTER
            log.warn("Dropping message for switch {} (role: {}, connected: {}): {}", dpid, role, channel.isConnected(), msgs);
        }
    }
}
#end_block

#method_before
private void sendMsgsOnChannel(List<OFMessage> msgs) {
    if (channel.isConnected()) {
        channel.write(msgs);
    } else {
        log.warn("Dropping messages for switch {} because channel is not connected: {}", dpid, msgs);
    }
}
#method_after
private void sendMsgsOnChannel(List<OFMessage> msgs) {
    if (channel.isConnected()) {
        channel.write(msgs);
        agent.processDownstreamMessage(dpid, msgs);
    } else {
        log.warn("Dropping messages for switch {} because channel is not connected: {}", dpid, msgs);
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    coreService.registerApplication(APP_ID, this::preDeactivate);
    cfgService.registerProperties(getClass());
    ctrl.setConfigParams(context.getProperties());
    ctrl.start(agent, driverService);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    coreService.registerApplication(APP_ID, this::cleanup);
    cfgService.registerProperties(getClass());
    ctrl.setConfigParams(context.getProperties());
    ctrl.start(agent, driverService);
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    preDeactivate();
    cfgService.unregisterProperties(getClass(), false);
    connectedSwitches.clear();
    activeMasterSwitches.clear();
    activeEqualSwitches.clear();
}
#method_after
@Deactivate
public void deactivate() {
    if (!connectedSwitches.isEmpty()) {
        cleanup();
    }
    cfgService.unregisterProperties(getClass(), false);
}
#end_block

#method_before
@Override
public void write(Dpid dpid, OFMessage msg) {
    this.getSwitch(dpid).sendMsg(msg);
    for (OpenFlowMessageListener listener : ofMessageListener) {
        listener.handleOutgoingMessage(dpid, msg);
    }
}
#method_after
@Override
public void write(Dpid dpid, OFMessage msg) {
    this.getSwitch(dpid).sendMsg(msg);
}
#end_block

#method_before
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFTableStatsEntry> tableStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case TABLE:
                    tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
                    if (tableStats != null) {
                        OFTableStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildTableStatsReply();
                        rep.setEntries(Lists.newLinkedList(tableStats));
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.execute(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
    for (OpenFlowMessageListener listener : ofMessageListener) {
        listener.handleIncomingMessage(dpid, msg);
    }
}
#method_after
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFTableStatsEntry> tableStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case TABLE:
                    tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
                    if (tableStats != null) {
                        OFTableStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildTableStatsReply();
                        rep.setEntries(Lists.newLinkedList(tableStats));
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.execute(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#end_block

#method_before
@Override
public void processMessage(Dpid dpid, OFMessage m) {
    processPacket(dpid, m);
}
#method_after
@Override
public void processMessage(Dpid dpid, OFMessage m) {
    processPacket(dpid, m);
    for (OpenFlowMessageListener listener : ofMessageListener) {
        listener.handleIncomingMessage(dpid, m);
    }
}
#end_block

#method_before
private void populateMetrics(ChartModel cm, Map<ControlMetricType, Long[]> data, LocalDateTime time, int numOfDp) {
    for (int i = 0; i < numOfDp; i++) {
        Map<String, Object> local = Maps.newHashMap();
        for (ControlMetricType cmt : CONTROL_MESSAGE_METRICS) {
            local.put(StringUtils.lowerCase(cmt.name()), data.get(cmt)[i]);
        }
        LocalDateTime calculated = time.minusMinutes(numOfDp - i);
        local.put(LABEL, calculated.toString(TIME_FORMAT));
        populateMetric(cm.addDataPoint(calculated.toString(TIME_FORMAT)), local);
    }
}
#method_after
private void populateMetrics(ChartModel cm, Map<ControlMetricType, Long[]> data, LocalDateTime time, int numOfDp) {
    for (int i = 0; i < numOfDp; i++) {
        Map<String, Object> local = Maps.newHashMap();
        for (ControlMetricType cmt : CONTROL_MESSAGE_METRICS) {
            local.put(StringUtils.lowerCase(cmt.name()), data.get(cmt)[i]);
        }
        String calculated = time.minusMinutes(numOfDp - i).toString(TIME_FORMAT);
        local.put(LABEL, calculated);
        populateMetric(cm.addDataPoint(calculated), local);
    }
}
#end_block

#method_before
String getAsString(String series) {
    return get(series).toString();
}
#method_after
public String getAsString(String series) {
    return get(series).toString();
}
#end_block

#method_before
public void addAnnotation(String key, Object value) {
    Annot annot = new Annot(key, value);
    annotations.put(key, annot);
}
#method_after
public void addAnnotation(String key, Object value) {
    annotations.put(key, new Annot(key, value));
}
#end_block

#method_before
public Collection<Annot> getAnnotations() {
    Collection<Annot> annots = new ArrayList<>(annotations.size());
    annotations.forEach((k, v) -> annots.add(v));
    return annots;
}
#method_after
public Collection<Annot> getAnnotations() {
    return new ArrayList<>(annotations.values());
}
#end_block

#method_before
@Override
public MastershipRole decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String roleJson = nullIsIllegal(json.get(ROLE), ROLE + MISSING_MEMBER_MESSAGE).asText();
    MastershipRole mastershipRole;
    switch(roleJson) {
        case "MASTER":
            mastershipRole = MastershipRole.MASTER;
            break;
        case "STANDBY":
            mastershipRole = MastershipRole.STANDBY;
            break;
        case "NONE":
            mastershipRole = MastershipRole.NONE;
            break;
        default:
            log.warn("The mastership role {} is not defined.", roleJson);
            return null;
    }
    return mastershipRole;
}
#method_after
@Override
public MastershipRole decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String roleJson = nullIsIllegal(json.get(ROLE), ROLE + MISSING_MEMBER_MESSAGE).asText();
    MastershipRole mastershipRole;
    switch(roleJson) {
        case "MASTER":
            mastershipRole = MASTER;
            break;
        case "STANDBY":
            mastershipRole = STANDBY;
            break;
        case "NONE":
            mastershipRole = NONE;
            break;
        default:
            log.warn("The mastership role {} is not defined.", roleJson);
            return null;
    }
    return mastershipRole;
}
#end_block

#method_before
@Override
public RoleInfo decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    // parse node identifier of master
    NodeId nodeId = json.get(MASTER) == null ? null : NodeId.nodeId(json.get(MASTER).asText());
    // parse node identifier of backups
    List<NodeId> backups = new ArrayList<>();
    ArrayNode backupsJson = (ArrayNode) json.get(BACKUPS);
    checkNotNull(backupsJson);
    IntStream.range(0, backupsJson.size()).forEach(i -> {
        JsonNode backupJson = backupsJson.get(i);
        checkNotNull(backupJson);
        backups.add(NodeId.nodeId(backupJson.asText()));
    });
    return new RoleInfo(nodeId, backups);
}
#method_after
@Override
public RoleInfo decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    // parse node identifier of master
    NodeId nodeId = json.get(MASTER) == null ? null : NodeId.nodeId(json.get(MASTER).asText());
    // parse node identifier of backups
    List<NodeId> backups = new ArrayList<>();
    ArrayNode backupsJson = (ArrayNode) nullIsIllegal(json.get(BACKUPS), BACKUPS + MISSING_MEMBER_MESSAGE);
    IntStream.range(0, backupsJson.size()).forEach(i -> {
        JsonNode backupJson = nullIsIllegal(backupsJson.get(i), "Backup node id cannot be null");
        backups.add(NodeId.nodeId(backupJson.asText()));
    });
    return new RoleInfo(nodeId, backups);
}
#end_block

#method_before
@Test
public void testMastershipRoleEncode() {
    MastershipRole mastershipRole = MastershipRole.MASTER;
    ObjectNode mastershipRoleJson = mastershipRoleCodec.encode(mastershipRole, context);
    assertThat(mastershipRoleJson, MastershipRoleJsonMatcher.matchesMastershipRole(mastershipRole));
}
#method_after
@Test
public void testMastershipRoleEncode() {
    MastershipRole mastershipRole = MASTER;
    ObjectNode mastershipRoleJson = mastershipRoleCodec.encode(mastershipRole, context);
    assertThat(mastershipRoleJson, MastershipRoleJsonMatcher.matchesMastershipRole(mastershipRole));
}
#end_block

#method_before
@Test
public void testMastershipRoleDecode() throws IOException {
    MastershipRole mastershipRole = getMastershipRole("MastershipRole.json");
    assertThat(mastershipRole, is(MastershipRole.MASTER));
}
#method_after
@Test
public void testMastershipRoleDecode() throws IOException {
    MastershipRole mastershipRole = getMastershipRole("MastershipRole.json");
    assertThat(mastershipRole, is(MASTER));
}
#end_block

#method_before
public void populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return;
    }
    for (Port port : srManager.deviceService.getPorts(deviceId)) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!srManager.deviceConfiguration.suppressSubnet().contains(connectPoint) && port.isEnabled()) {
            Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
            VlanId assignedVlan = (portSubnet == null) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
            FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
            fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
            // vlan assignment is valid only if this instance is master
            if (srManager.mastershipService.isLocalMaster(deviceId)) {
                TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
                fob.withMeta(tt);
            }
            fob.permit().fromApp(srManager.appId);
            ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
            srManager.flowObjectiveService.filter(deviceId, fob.add(context));
        }
    }
}
#method_after
public boolean populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return false;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts != null && devPorts.size() == 0) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return false;
    }
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        if (!srManager.deviceConfiguration.suppressSubnet().contains(connectPoint) && port.isEnabled()) {
            Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
            VlanId assignedVlan = (portSubnet == null) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
            FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
            fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
            // vlan assignment is valid only if this instance is master
            if (srManager.mastershipService.isLocalMaster(deviceId)) {
                TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
                fob.withMeta(tt);
            }
            fob.permit().fromApp(srManager.appId);
            log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
            ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
            srManager.flowObjectiveService.filter(deviceId, fob.add(context));
        }
    }
    return true;
}
#end_block

#method_before
private void printPortStats(DeviceId deviceId, Iterable<PortStatistics> portStats) {
    print("deviceId=%s", deviceId);
    for (PortStatistics stat : sortByPort(portStats)) {
        if (portNumber != null && stat.port() != portNumber) {
            continue;
        }
        if (nonzero && statsZero(stat)) {
            continue;
        }
        print(FORMAT, stat.port(), stat.packetsReceived(), stat.packetsSent(), stat.bytesReceived(), stat.bytesSent(), stat.packetsRxDropped(), stat.packetsTxDropped(), stat.durationSec());
    }
}
#method_after
private void printPortStats(DeviceId deviceId, Iterable<PortStatistics> portStats) {
    print("deviceId=%s", deviceId);
    for (PortStatistics stat : sortByPort(portStats)) {
        if (portNumber != null && stat.port() != portNumber) {
            continue;
        }
        if (nonzero && stat.isZero()) {
            continue;
        }
        print(FORMAT, stat.port(), stat.packetsReceived(), stat.packetsSent(), stat.bytesReceived(), stat.bytesSent(), stat.packetsRxDropped(), stat.packetsTxDropped(), stat.durationSec());
    }
}
#end_block

#method_before
private void printPortStatsDelta(DeviceId deviceId, Iterable<PortStatistics> portStats) {
    final String formatDelta = "   port=%s, pktRx=%s, pktTx=%s, bytesRx=%s, bytesTx=%s," + " rateRx=%s, rateTx=%s, pktRxDrp=%s, pktTxDrp=%s, interval=%s";
    print("deviceId=%s", deviceId);
    for (PortStatistics stat : sortByPort(portStats)) {
        if (portNumber != null && stat.port() != portNumber) {
            continue;
        }
        if (nonzero && statsZero(stat)) {
            continue;
        }
        float duration = ((float) stat.durationSec()) + (((float) stat.durationNano()) / TimeUnit.SECONDS.toNanos(1));
        float rateRx = stat.bytesReceived() * 8 / duration;
        float rateTx = stat.bytesSent() * 8 / duration;
        print(formatDelta, stat.port(), stat.packetsReceived(), stat.packetsSent(), stat.bytesReceived(), stat.bytesSent(), String.format("%.1f", rateRx), String.format("%.1f", rateTx), stat.packetsRxDropped(), stat.packetsTxDropped(), String.format("%.3f", duration));
    }
}
#method_after
private void printPortStatsDelta(DeviceId deviceId, Iterable<PortStatistics> portStats) {
    final String formatDelta = "   port=%s, pktRx=%s, pktTx=%s, bytesRx=%s, bytesTx=%s," + " rateRx=%s, rateTx=%s, pktRxDrp=%s, pktTxDrp=%s, interval=%s";
    print("deviceId=%s", deviceId);
    for (PortStatistics stat : sortByPort(portStats)) {
        if (portNumber != null && stat.port() != portNumber) {
            continue;
        }
        if (nonzero && stat.isZero()) {
            continue;
        }
        float duration = ((float) stat.durationSec()) + (((float) stat.durationNano()) / TimeUnit.SECONDS.toNanos(1));
        float rateRx = stat.bytesReceived() * 8 / duration;
        float rateTx = stat.bytesSent() * 8 / duration;
        print(formatDelta, stat.port(), stat.packetsReceived(), stat.packetsSent(), stat.bytesReceived(), stat.bytesSent(), String.format("%.1f", rateRx), String.format("%.1f", rateTx), stat.packetsRxDropped(), stat.packetsTxDropped(), String.format("%.3f", duration));
    }
}
#end_block

#method_before
private void printPortStatsDeltaTable(DeviceId deviceId, Iterable<PortStatistics> portStats) {
    final String formatDeltaTable = "|%5s | %7s | %7s |  %7s | %7s | %7s | %7s |  %7s | %7s |%9s |";
    print("+---------------------------------------------------------------------------------------------------+");
    print("| DeviceId = %s                                                                    |", deviceId);
    print("|---------------------------------------------------------------------------------------------------|");
    print("|      | Receive                                | Transmit                               | Time [s] |");
    print("| Port | Packets |  Bytes  | Rate bps |   Drop  | Packets |  Bytes  | Rate bps |   Drop  | Interval |");
    print("|---------------------------------------------------------------------------------------------------|");
    for (PortStatistics stat : sortByPort(portStats)) {
        if (portNumber != null && stat.port() != portNumber) {
            continue;
        }
        if (nonzero && statsZero(stat)) {
            continue;
        }
        float duration = ((float) stat.durationSec()) + (((float) stat.durationNano()) / TimeUnit.SECONDS.toNanos(1));
        float rateRx = stat.bytesReceived() * 8 / duration;
        float rateTx = stat.bytesSent() * 8 / duration;
        print(formatDeltaTable, stat.port(), humanReadable(stat.packetsReceived()), humanReadable(stat.bytesReceived()), humanReadableBps(rateRx), humanReadable(stat.packetsRxDropped()), humanReadable(stat.packetsSent()), humanReadable(stat.bytesSent()), humanReadableBps(rateTx), humanReadable(stat.packetsTxDropped()), String.format("%.3f", duration));
    }
    print("+---------------------------------------------------------------------------------------------------+");
}
#method_after
private void printPortStatsDeltaTable(DeviceId deviceId, Iterable<PortStatistics> portStats) {
    final String formatDeltaTable = "|%5s | %7s | %7s |  %7s | %7s | %7s | %7s |  %7s | %7s |%9s |";
    print("+---------------------------------------------------------------------------------------------------+");
    print("| DeviceId = %s                                                                    |", deviceId);
    print("|---------------------------------------------------------------------------------------------------|");
    print("|      | Receive                                | Transmit                               | Time [s] |");
    print("| Port | Packets |  Bytes  | Rate bps |   Drop  | Packets |  Bytes  | Rate bps |   Drop  | Interval |");
    print("|---------------------------------------------------------------------------------------------------|");
    for (PortStatistics stat : sortByPort(portStats)) {
        if (portNumber != null && stat.port() != portNumber) {
            continue;
        }
        if (nonzero && stat.isZero()) {
            continue;
        }
        float duration = ((float) stat.durationSec()) + (((float) stat.durationNano()) / TimeUnit.SECONDS.toNanos(1));
        float rateRx = stat.bytesReceived() * 8 / duration;
        float rateTx = stat.bytesSent() * 8 / duration;
        print(formatDeltaTable, stat.port(), humanReadable(stat.packetsReceived()), humanReadable(stat.bytesReceived()), humanReadableBps(rateRx), humanReadable(stat.packetsRxDropped()), humanReadable(stat.packetsSent()), humanReadable(stat.bytesSent()), humanReadableBps(rateTx), humanReadable(stat.packetsTxDropped()), String.format("%.3f", duration));
    }
    print("+---------------------------------------------------------------------------------------------------+");
}
#end_block

#method_before
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(appId, segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // per switch.
        if (groupHandlerMap.get(device.id()) == null) {
            DefaultGroupHandler groupHandler;
            try {
                groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, segmentRoutingManager);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting configureNetwork.");
                return;
            }
            groupHandlerMap.put(device.id(), groupHandler);
            // Also, in some cases, drivers may need extra
            // information to process rules (eg. Router IP/MAC); and so, we send
            // port addressing rules to the driver as well, irrespective of whether
            // this instance is the master or not.
            defaultRoutingHandler.populatePortAddressingRules(device.id());
        }
        if (mastershipService.isLocalMaster(device.id())) {
            hostHandler.readInitialHosts(device.id());
            DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
            groupHandler.createGroupsFromSubnetConfig();
            routingRulePopulator.populateSubnetBroadcastRule(device.id());
            groupHandler.createGroupsForXConnect(device.id());
            routingRulePopulator.populateXConnectBroadcastRule(device.id());
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#method_after
public void configureNetwork() {
    deviceConfiguration = new DeviceConfiguration(appId, segmentRoutingManager.cfgService);
    arpHandler = new ArpHandler(segmentRoutingManager);
    icmpHandler = new IcmpHandler(segmentRoutingManager);
    ipHandler = new IpHandler(segmentRoutingManager);
    routingRulePopulator = new RoutingRulePopulator(segmentRoutingManager);
    defaultRoutingHandler = new DefaultRoutingHandler(segmentRoutingManager);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    for (Device device : deviceService.getDevices()) {
        // Irrespective of whether the local is a MASTER or not for this device,
        // we need to create a SR-group-handler instance. This is because in a
        // multi-instance setup, any instance can initiate forwarding/next-objectives
        // for any switch (even if this instance is a SLAVE or not even connected
        // to the switch). To handle this, a default-group-handler instance is necessary
        // per switch.
        log.debug("Current groupHandlerMap devs: {}", groupHandlerMap.keySet());
        if (groupHandlerMap.get(device.id()) == null) {
            DefaultGroupHandler groupHandler;
            try {
                groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, segmentRoutingManager);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting configureNetwork.");
                return;
            }
            log.debug("updating groupHandlerMap with new config for " + "device: {}", device.id());
            groupHandlerMap.put(device.id(), groupHandler);
            // Also, in some cases, drivers may need extra
            // information to process rules (eg. Router IP/MAC); and so, we send
            // port addressing rules to the driver as well, irrespective of whether
            // this instance is the master or not.
            defaultRoutingHandler.populatePortAddressingRules(device.id());
        }
        if (mastershipService.isLocalMaster(device.id())) {
            hostHandler.readInitialHosts(device.id());
            DefaultGroupHandler groupHandler = groupHandlerMap.get(device.id());
            groupHandler.createGroupsFromSubnetConfig();
            routingRulePopulator.populateSubnetBroadcastRule(device.id());
            groupHandler.createGroupsForXConnect(device.id());
            routingRulePopulator.populateXConnectBroadcastRule(device.id());
        }
    }
    defaultRoutingHandler.startPopulationProcess();
}
#end_block

#method_before
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST || criterion.type() == Criterion.Type.ETH_DST_MASKED) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(MacAddress.NONE)) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (ethCriterion == null || vidCriterion == null) {
        log.debug("filtering objective missing dstMac or VLAN, " + "cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
            VlanId vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.debug("adding VLAN assignment rule in VLAN table: {} for dev: {}", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    Collection<IPCriterion> ips = new ArrayList<IPCriterion>();
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST || criterion.type() == Criterion.Type.ETH_DST_MASKED) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vidCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            ips.add((IPCriterion) criterion);
        } else {
            log.error("Unsupported filter {}", criterion);
            fail(filt, ObjectiveError.UNSUPPORTED);
            return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(MacAddress.NONE)) {
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (ethCriterion == null || vidCriterion == null) {
        log.warn("filtering objective missing dstMac or VLAN, " + "cannot program VLAN Table");
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
            VlanId vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.debug("adding VLAN assignment rule in VLAN table: {} for dev: {}", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    for (IPCriterion ipaddr : ips) {
        // only a single rule to the switch.
        if (!sentIpFilters.contains(ipaddr)) {
            sentIpFilters.add(ipaddr);
            log.debug("adding IP filtering rules in ACL table {} for dev: {}", ipaddr, deviceId);
            TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
            TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
            selector.matchEthType(Ethernet.TYPE_IPV4);
            selector.matchIPDst(ipaddr.ip());
            treatment.setOutput(PortNumber.CONTROLLER);
            FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGHEST_PRIORITY).fromApp(applicationId).makePermanent().forTable(ACL_TABLE).build();
            ops = install ? ops.add(rule) : ops.remove(rule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.info("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected static VlanId readVlanFromSelector(TrafficSelector selector) {
    Criterion criterion = selector.getCriterion(Criterion.Type.VLAN_VID);
    return (criterion == null) ? null : ((VlanIdCriterion) criterion).vlanId();
}
#method_after
protected static VlanId readVlanFromSelector(TrafficSelector selector) {
    if (selector == null) {
        return null;
    }
    Criterion criterion = selector.getCriterion(Criterion.Type.VLAN_VID);
    return (criterion == null) ? null : ((VlanIdCriterion) criterion).vlanId();
}
#end_block

#method_before
protected static IpPrefix readIpDstFromSelector(TrafficSelector selector) {
    Criterion criterion = selector.getCriterion(Criterion.Type.IPV4_DST);
    return (criterion == null) ? null : ((IPCriterion) criterion).ip();
}
#method_after
protected static IpPrefix readIpDstFromSelector(TrafficSelector selector) {
    if (selector == null) {
        return null;
    }
    Criterion criterion = selector.getCriterion(Criterion.Type.IPV4_DST);
    return (criterion == null) ? null : ((IPCriterion) criterion).ip();
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    readComponenetConfiguration(context);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    readComponentConfiguration(context);
    // Reset Cache and copy all.
    Cache<Integer, SettableFuture<CompletedBatchOperation>> prevFutures = pendingFutures;
    pendingFutures = CacheBuilder.newBuilder().expireAfterWrite(pendingFutureTimeoutMinutes, TimeUnit.MINUTES).removalListener(new TimeoutFuture()).build();
    pendingFutures.putAll(prevFutures.asMap());
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    controller.removeListener(listener);
    providerRegistry.unregister(this);
    collectors.values().forEach(PortStatsCollector::stop);
    providerService = null;
    LOG.info("Stopped");
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    listener.disable();
    controller.removeListener(listener);
    providerRegistry.unregister(this);
    collectors.values().forEach(PortStatsCollector::stop);
    providerService = null;
    LOG.info("Stopped");
}
#end_block

#method_before
private Collection<PortStatistics> buildPortStatistics(DeviceId deviceId, List<OFPortStatsEntry> entries) {
    HashSet<PortStatistics> stats = Sets.newHashSet();
    for (OFPortStatsEntry entry : entries) {
        try {
            if (entry == null || entry.getPortNo() == null || entry.getPortNo().getPortNumber() < 0) {
                continue;
            }
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            DefaultPortStatistics stat = builder.setDeviceId(deviceId).setPort(entry.getPortNo().getPortNumber()).setPacketsReceived(entry.getRxPackets().getValue()).setPacketsSent(entry.getTxPackets().getValue()).setBytesReceived(entry.getRxBytes().getValue()).setBytesSent(entry.getTxBytes().getValue()).setPacketsRxDropped(entry.getRxDropped().getValue()).setPacketsTxDropped(entry.getTxDropped().getValue()).setPacketsRxErrors(entry.getRxErrors().getValue()).setPacketsTxErrors(entry.getTxErrors().getValue()).setDurationSec(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationSec()).setDurationNano(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationNsec()).build();
            stats.add(stat);
        } catch (Exception e) {
            LOG.warn("Unable to process port stats", e);
        }
    }
    return Collections.unmodifiableSet(stats);
}
#method_after
private Collection<PortStatistics> buildPortStatistics(DeviceId deviceId, List<OFPortStatsEntry> entries) {
    HashSet<PortStatistics> stats = Sets.newHashSet();
    if (entries == null) {
        return Collections.unmodifiableSet(stats);
    }
    for (OFPortStatsEntry entry : entries) {
        try {
            if (entry == null || entry.getPortNo() == null || entry.getPortNo().getPortNumber() < 0) {
                continue;
            }
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            DefaultPortStatistics stat = builder.setDeviceId(deviceId).setPort(entry.getPortNo().getPortNumber()).setPacketsReceived(entry.getRxPackets().getValue()).setPacketsSent(entry.getTxPackets().getValue()).setBytesReceived(entry.getRxBytes().getValue()).setBytesSent(entry.getTxBytes().getValue()).setPacketsRxDropped(entry.getRxDropped().getValue()).setPacketsTxDropped(entry.getTxDropped().getValue()).setPacketsRxErrors(entry.getRxErrors().getValue()).setPacketsTxErrors(entry.getTxErrors().getValue()).setDurationSec(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationSec()).setDurationNano(entry.getVersion() == OFVersion.OF_10 ? 0 : entry.getDurationNsec()).build();
            stats.add(stat);
        } catch (Exception e) {
            LOG.warn("Unable to process port stats", e);
        }
    }
    return Collections.unmodifiableSet(stats);
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    switch(msg.getType()) {
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.PORT) {
                OFPortStatsReply portStatsReply = (OFPortStatsReply) msg;
                List<OFPortStatsEntry> portStatsReplyList = portStatsReplies.get(dpid);
                if (portStatsReplyList == null) {
                    portStatsReplyList = Lists.newArrayList();
                }
                portStatsReplyList.addAll(portStatsReply.getEntries());
                portStatsReplies.put(dpid, portStatsReplyList);
                if (!portStatsReply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
                    pushPortMetrics(dpid, portStatsReplies.get(dpid));
                    portStatsReplies.get(dpid).clear();
                }
            }
            break;
        case ERROR:
            if (((OFErrorMsg) msg).getErrType() == OFErrorType.PORT_MOD_FAILED) {
                LOG.error("port mod failed");
            }
        default:
            break;
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (isDisabled) {
        return;
    }
    try {
        switch(msg.getType()) {
            case STATS_REPLY:
                if (((OFStatsReply) msg).getStatsType() == OFStatsType.PORT) {
                    OFPortStatsReply portStatsReply = (OFPortStatsReply) msg;
                    List<OFPortStatsEntry> portStatsReplyList = portStatsReplies.get(dpid);
                    if (portStatsReplyList == null) {
                        portStatsReplyList = Lists.newArrayList();
                    }
                    portStatsReplyList.addAll(portStatsReply.getEntries());
                    portStatsReplies.put(dpid, portStatsReplyList);
                    if (!portStatsReply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
                        pushPortMetrics(dpid, portStatsReplies.get(dpid));
                        portStatsReplies.get(dpid).clear();
                    }
                }
                break;
            case ERROR:
                if (((OFErrorMsg) msg).getErrType() == OFErrorType.PORT_MOD_FAILED) {
                    LOG.error("port mod failed");
                }
            default:
                break;
        }
    } catch (IllegalStateException e) {
    // system is shutting down and the providerService is no longer
    // valid. Messages cannot be processed.
    }
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeofNode(this, yangPlugin, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfNode(this, yangPlugin);
}
#end_block

#method_before
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), ENTRY);
    // Validate node identifier.
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), YangConstructType.TYPE_DATA, ctx);
    // Obtain the YANG data type.
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    // Create YANG type object and fill the values.
    YangType<?> type = getYangType(JAVA_GENERATION);
    type.setNodeIdentifier(nodeIdentifier);
    type.setDataType(yangDataTypes);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                type.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf list to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addType((YangType<?>) type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) unionNode, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) typeDef, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    // Push the type to the stack.
    listener.getParsedDataStack().push(type);
}
#method_after
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), ENTRY);
    // Validate node identifier.
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), TYPE_DATA, ctx);
    // Obtain the YANG data type.
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    // Create YANG type object and fill the values.
    YangType<?> type = getYangType(JAVA_GENERATION);
    type.setNodeIdentifier(nodeIdentifier);
    type.setDataType(yangDataTypes);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                type.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf list to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addType(type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, unionNode, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, typeDef, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    // Push the type to the stack.
    listener.getParsedDataStack().push(type);
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeofNode(this, yangPlugin, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfNode(this, yangPlugin);
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, INTERFACE_MASK, imports, path);
    if (isAttrPresent) {
        /**
         * Add getter methods to interface file.
         */
        try {
            /**
             * Getter methods.
             */
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    return file;
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, INTERFACE_MASK, imports, path);
    if (isAttrPresent) {
        /**
         * Add getter methods to interface file.
         */
        try {
            /**
             * Getter methods.
             */
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    return file;
}
#end_block

#method_before
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, BUILDER_INTERFACE_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            /**
             * Getter methods.
             */
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
            /**
             * Setter methods.
             */
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder interface file generation");
        }
    }
    /**
     * Add build method to builder interface file.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface());
    /**
     * Add getters and setters in builder interface.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, BUILDER_INTERFACE_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            /**
             * Getter methods.
             */
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
            /**
             * Setter methods.
             */
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder interface file generation");
        }
    }
    /**
     * Add build method to builder interface file.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface());
    /**
     * Add getters and setters in builder interface.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static File generateBuilderClassFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, BUILDER_CLASS_MASK, imports, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
            /**
             * Setter methods.
             */
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()) + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    /**
     * Add default constructor and build method impl.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER));
    /**
     * Add methods in builder class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#method_after
public static File generateBuilderClassFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, BUILDER_CLASS_MASK, imports, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
            /**
             * Setter methods.
             */
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()) + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    /**
     * Add default constructor and build method impl.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER));
    /**
     * Add methods in builder class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return file;
}
#end_block

#method_before
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        /**
         * Add attribute for augmented info's list.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            insertDataIntoJavaFile(file, getAugmentedInfoAttribute());
        }
        insertDataIntoJavaFile(file, NEW_LINE);
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
            /**
             * Hash code method.
             */
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()).replace(NEW_LINE, EMPTY_STRING))));
            /**
             * Equals method.
             */
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + IMPL) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles())));
            /**
             * To string method.
             */
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        /**
         * Constructor.
         */
        methods.add(getConstructorStart(className) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    /**
     * Add method for augment info's list.
     */
    if (isHasAugmentationExtended(getExtendsList())) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getAugmentInfoListImpl());
        methods.add(getRemoveAugmentationImpl());
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + method + NEW_LINE);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        /**
         * Add attribute for augmented info's list.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            insertDataIntoJavaFile(file, getAugmentedInfoAttribute());
        }
        insertDataIntoJavaFile(file, NEW_LINE);
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()));
            /**
             * Hash code method.
             */
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()).replace(NEW_LINE, EMPTY_STRING))));
            /**
             * Equals method.
             */
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + IMPL) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles())));
            /**
             * To string method.
             */
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        /**
         * Constructor.
         */
        methods.add(getConstructorStart(className) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles()) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    /**
     * Add method for augment info's list.
     */
    if (isHasAugmentationExtended(getExtendsList())) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getAugmentInfoListImpl());
        methods.add(getRemoveAugmentationImpl());
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + method + NEW_LINE);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Of method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles())));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()) + getToStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Of method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles())));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()) + getToStringMethodClose());
        JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
        /**
         * From string method.
         */
        methods.add(getFromStringMethodSignature(className) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getTypeTempFiles()) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Of string method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles())));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()) + getToStringMethodClose());
        /**
         * From string method.
         */
        methods.add(getFromStringMethodSignature(className) + getDataFromTempFileHandle(UNION_FROM_STRING_IMPL_MASK, ((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Of string method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles())));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()) + getToStringMethodClose());
        /**
         * From string method.
         */
        methods.add(getFromStringMethodSignature(className) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles()) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeAndUpdateInParent(this, yangPlugin, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfNode(this, yangPlugin);
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeAndUpdateInParent(this, yangPlugin, false);
// TODO:getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles(this);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    YangJavaModelUtils.generateCodeAndUpdateInParent(this, yangPlugin, false);
}
#end_block

#method_before
@Override
public void generateCodeExit() {
// TODO Auto-generated method stub
}
#method_after
@Override
public void generateCodeExit() throws IOException {
    getTempJavaCodeFragmentFiles().generateJavaFile(INTERFACE_MASK, this);
}
#end_block

#method_before
@Test
public void processValidAugmentStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidAugmentStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangAugment yangAugment = (YangAugment) yangNode.getChild();
    if (yangAugment.getTargetNode().isEmpty()) {
        System.out.println("list is empty");
    }
    ListIterator<YangNodeIdentifier> nodeIdentifierIterator = yangAugment.getTargetNode().listIterator();
    YangNodeIdentifier yangNodeIdentifier = nodeIdentifierIterator.next();
    assertThat(yangNodeIdentifier.getPrefix(), is("if"));
    assertThat(yangNodeIdentifier.getName(), is("interfaces"));
    ListIterator<YangLeaf> leafIterator = yangAugment.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("ds0ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
}
#method_after
@Test
public void processValidAugmentStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidAugmentStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangAugment yangAugment = (YangAugment) yangNode.getChild();
    ListIterator<YangNodeIdentifier> nodeIdentifierIterator = yangAugment.getTargetNode().listIterator();
    YangNodeIdentifier yangNodeIdentifier = nodeIdentifierIterator.next();
    assertThat(yangNodeIdentifier.getPrefix(), is("if"));
    assertThat(yangNodeIdentifier.getName(), is("interfaces"));
    ListIterator<YangLeaf> leafIterator = yangAugment.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("ds0ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
}
#end_block

#method_before
@Test
public void processOutputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("activate-software-imageOutput"));
    ListIterator<YangLeaf> leafIterator = yangOutput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangOutput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#method_after
@Test
public void processOutputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("activate-software-image_output"));
    ListIterator<YangLeaf> leafIterator = yangOutput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangOutput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#end_block

#method_before
@Test
public void processOutputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("activate-software-imageOutput"));
    YangTypeDef typeDef = (YangTypeDef) yangOutput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#method_after
@Test
public void processOutputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/OutputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangOutput yangOutput = (YangOutput) yangRpc.getChild();
    assertThat(yangOutput.getName(), is("activate-software-image_output"));
    YangTypeDef typeDef = (YangTypeDef) yangOutput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#end_block

#method_before
@Override
public void updateJavaQualifiedInfo() {
    JavaQualifiedTypeInfo importInfo = getJavaQualifiedInfo();
    /*
         * Type is is added as an attribute in the class.
         */
    String className = AttributesJavaDataType.getJavaImportClass(this, false);
    if (className != null) {
        /*
             * Corresponding to the attribute type a class needs to be imported,
             * since it can be a derived type or a usage of wrapper classes.
             */
        importInfo.setClassInfo(className);
        String classPkg = AttributesJavaDataType.getJavaImportPackage(this, false, className);
        if (classPkg == null) {
            throw new TranslatorException("import package cannot be null when the class is used");
        }
        importInfo.setPkgInfo(classPkg);
    } else {
        /*
             * The attribute does not need a class to be imported, for example
             * built in java types.
             */
        String dataTypeName = AttributesJavaDataType.getJavaDataType(this);
        if (dataTypeName == null) {
            throw new TranslatorException("not supported data type");
        }
        importInfo.setClassInfo(dataTypeName);
    }
}
#method_after
@Override
public void updateJavaQualifiedInfo() {
    JavaQualifiedTypeInfo importInfo = getJavaQualifiedInfo();
    /*
         * Type is added as an attribute in the class.
         */
    String className = AttributesJavaDataType.getJavaImportClass(this, false);
    if (className != null) {
        /*
             * Corresponding to the attribute type a class needs to be imported,
             * since it can be a derived type or a usage of wrapper classes.
             */
        importInfo.setClassInfo(className);
        String classPkg = AttributesJavaDataType.getJavaImportPackage(this, false, className);
        if (classPkg == null) {
            throw new TranslatorException("import package cannot be null when the class is used");
        }
        importInfo.setPkgInfo(classPkg);
    } else {
        /*
             * The attribute does not need a class to be imported, for example
             * built in java types.
             */
        String dataTypeName = AttributesJavaDataType.getJavaDataType(this);
        if (dataTypeName == null) {
            throw new TranslatorException("not supported data type");
        }
        importInfo.setClassInfo(dataTypeName);
    }
}
#end_block

#method_before
public static String getDataFromTempFileHandle(int generatedTempFiles, TempJavaFragmentFiles tempJavaFragmentFiles) throws IOException {
    if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getAttributesTempFileHandle());
    } else if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getGetterInterfaceTempFileHandle());
    } else if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getSetterInterfaceTempFileHandle());
    } else if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getGetterImplTempFileHandle());
    } else if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getSetterImplTempFileHandle());
    } else if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getConstructorImplTempFileHandle());
    } else if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getHashCodeImplTempFileHandle());
    } else if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getEqualsImplTempFileHandle());
    } else if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getToStringImplTempFileHandle());
    } else if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getConstructorForTypeTempFileHandle());
    } else if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getOfStringImplTempFileHandle());
    } else if ((generatedTempFiles & UNION_FROM_STRING_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getUnionFromStringImplTempFileHandle());
    }
    return null;
}
#method_after
public static String getDataFromTempFileHandle(int generatedTempFiles, TempJavaFragmentFiles tempJavaFragmentFiles) throws IOException {
    if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getAttributesTempFileHandle());
    } else if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getGetterInterfaceTempFileHandle());
    } else if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getSetterInterfaceTempFileHandle());
    } else if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getGetterImplTempFileHandle());
    } else if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getSetterImplTempFileHandle());
    } else if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getConstructorImplTempFileHandle());
    } else if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getHashCodeImplTempFileHandle());
    } else if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getEqualsImplTempFileHandle());
    } else if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getToStringImplTempFileHandle());
    } else if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getConstructorForTypeTempFileHandle());
    } else if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getOfStringImplTempFileHandle());
    } else if ((generatedTempFiles & FROM_STRING_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getFromStringImplTempFileHandle());
    } else if ((generatedTempFiles & ENUM_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getEnumClassTempFileHandle());
    } else if ((generatedTempFiles & RPC_IMPL_MASK) != 0) {
        return tempJavaFragmentFiles.getTemporaryDataFromFileHandle(tempJavaFragmentFiles.getRpcInterfaceImplTempFileHandle());
    }
    return null;
}
#end_block

#method_before
private static void appendContents(File file, String fileName, int type, List<String> importsList, String pkg) throws IOException {
    String pkgString = parsePackageString(pkg, importsList);
    if ((type & IMPL_CLASS_MASK) != 0) {
        write(file, fileName, type, IMPL_CLASS);
    } else if ((type & BUILDER_INTERFACE_MASK) != 0) {
        write(file, fileName, type, BUILDER_INTERFACE);
    } else if ((type & GENERATE_TYPEDEF_CLASS) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, IMPL_CLASS);
    } else if ((type & INTERFACE_MASK) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, INTERFACE);
    } else if ((type & BUILDER_CLASS_MASK) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, BUILDER_CLASS);
    } else if ((type & GENERATE_UNION_CLASS) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, IMPL_CLASS);
    }
}
#method_after
private static void appendContents(File file, String fileName, int type, List<String> importsList, String pkg) throws IOException {
    String pkgString = parsePackageString(pkg, importsList);
    if ((type & IMPL_CLASS_MASK) != 0) {
        write(file, fileName, type, IMPL_CLASS);
    } else if ((type & BUILDER_INTERFACE_MASK) != 0) {
        write(file, fileName, type, BUILDER_INTERFACE);
    } else if ((type & GENERATE_TYPEDEF_CLASS) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, IMPL_CLASS);
    } else if ((type & INTERFACE_MASK) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, INTERFACE);
    } else if ((type & BUILDER_CLASS_MASK) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, BUILDER_CLASS);
    } else if ((type & GENERATE_UNION_CLASS) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, IMPL_CLASS);
    } else if ((type & GENERATE_ENUM_CLASS) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, ENUM_CLASS);
    } else if ((type & GENERATE_RPC_INTERFACE) != 0) {
        appendHeaderContents(file, pkgString, importsList);
        write(file, fileName, type, RPC_INTERFACE);
    }
}
#end_block

#method_before
public String getAbsoluteDirPath() {
    return absoluteDirPath;
}
#method_after
private String getAbsoluteDirPath() {
    return absoluteDirPath;
}
#end_block

#method_before
public void setAbsoluteDirPath(String absoluteDirPath) {
    this.absoluteDirPath = absoluteDirPath;
}
#method_after
private void setAbsoluteDirPath(String absoluteDirPath) {
    this.absoluteDirPath = absoluteDirPath;
}
#end_block

#method_before
public int getGeneratedTempFiles() {
    return generatedTempFiles;
}
#method_after
private int getGeneratedTempFiles() {
    return generatedTempFiles;
}
#end_block

#method_before
public int getGeneratedJavaFiles() {
    return getJavaFileInfo().getGeneratedFileTypes();
}
#method_after
private int getGeneratedJavaFiles() {
    return getJavaFileInfo().getGeneratedFileTypes();
}
#end_block

#method_before
public String getGeneratedJavaClassName() {
    return getJavaFileInfo().getJavaName();
}
#method_after
private String getGeneratedJavaClassName() {
    return getJavaFileInfo().getJavaName();
}
#end_block

#method_before
public void setJavaImportData(JavaImportData javaImportData) {
    this.javaImportData = javaImportData;
}
#method_after
private void setJavaImportData(JavaImportData javaImportData) {
    this.javaImportData = javaImportData;
}
#end_block

#method_before
/**
 * Sets class to be extended by generated file.
 *
 * @param extendsList list of classes to be extended
 */
private void setExtendsList(List<String> extendsList) {
    this.extendsList = extendsList;
}
#method_after
private void setExtendsList(List<String> extendsList) {
    this.extendsList = extendsList;
}
#end_block

#method_before
public String addBuildMethodForInterface() throws IOException {
    return parseBuilderInterfaceBuildMethodString(getGeneratedJavaClassName());
}
#method_after
String addBuildMethodForInterface() throws IOException {
    return parseBuilderInterfaceBuildMethodString(getGeneratedJavaClassName());
}
#end_block

#method_before
public String addBuildMethodImpl() throws IOException {
    return getBuildString(getGeneratedJavaClassName()) + NEW_LINE;
}
#method_after
String addBuildMethodImpl() throws IOException {
    return getBuildString(getGeneratedJavaClassName()) + NEW_LINE;
}
#end_block

#method_before
public String addDefaultConstructor(String modifier, String toAppend) throws IOException {
    return NEW_LINE + getDefaultConstructorString(getGeneratedJavaClassName() + toAppend, modifier);
}
#method_after
String addDefaultConstructor(String modifier, String toAppend) throws IOException {
    return NEW_LINE + getDefaultConstructorString(getGeneratedJavaClassName() + toAppend, modifier);
}
#end_block

#method_before
private File getJavaFileHandle(String fileName) throws IOException {
    createPackage(absoluteDirPath, getJavaFileInfo().getJavaName());
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, getJavaFileInfo());
}
#method_after
private File getJavaFileHandle(String fileName) throws IOException {
    createPackage(getAbsoluteDirPath(), getJavaFileInfo().getJavaName());
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, getJavaFileInfo());
}
#end_block

#method_before
private String getTempDirPath() {
    return getPackageDirPathFromJavaJPackage(absoluteDirPath) + SLASH + getGeneratedJavaClassName() + TEMP_FOLDER_NAME_SUFIX + SLASH;
}
#method_after
private String getTempDirPath() {
    return getPackageDirPathFromJavaJPackage(getAbsoluteDirPath()) + SLASH + getGeneratedJavaClassName() + TEMP_FOLDER_NAME_SUFIX + SLASH;
}
#end_block

#method_before
public static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList) throws IOException {
    YangNode parent = getParentNodeInGenCode(curNode);
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException("missing parent node to contain current node info in generated file");
    }
    JavaAttributeInfo javaAttributeInfo = getCurNodeAsAttributeInParent(curNode, parent, isList);
    if (!(parent instanceof HasTempJavaCodeFragmentFiles)) {
        throw new TranslatorException("missing parent temp file handle");
    }
    ((HasTempJavaCodeFragmentFiles) parent).getTempJavaCodeFragmentFiles().getBeanTempFiles().addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#method_after
public static void addCurNodeInfoInParentTempFile(YangNode curNode, boolean isList) throws IOException {
    YangNode parent = getParentNodeInGenCode(curNode);
    if (!(parent instanceof JavaCodeGenerator)) {
        throw new TranslatorException("missing parent node to contain current node info in generated file");
    }
    JavaAttributeInfo javaAttributeInfo = getCurNodeAsAttributeInParent(curNode, parent, isList);
    if (!(parent instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException("missing parent temp file handle");
    }
    ((TempJavaCodeFragmentFilesContainer) parent).getTempJavaCodeFragmentFiles().getBeanTempFiles().addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#end_block

#method_before
public static JavaAttributeInfo getCurNodeAsAttributeInParent(YangNode curNode, YangNode parentNode, boolean isListNode) {
    String curNodeName = ((HasJavaFileInfo) curNode).getJavaFileInfo().getJavaName();
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access
         */
    JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(parentNode, curNodeName, isListNode);
    if (!(parentNode instanceof HasTempJavaCodeFragmentFiles)) {
        throw new TranslatorException("Parent node does not have file info");
    }
    JavaImportData parentImportData = ((HasTempJavaCodeFragmentFiles) parentNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData();
    boolean isQualified = parentImportData.addImportInfo(qualifiedTypeInfo);
    return getAttributeInfoForTheData(qualifiedTypeInfo, curNodeName, null, isQualified, isListNode);
}
#method_after
public static JavaAttributeInfo getCurNodeAsAttributeInParent(YangNode curNode, YangNode parentNode, boolean isListNode) {
    String curNodeName = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName();
    /*
         * Get the import info corresponding to the attribute for import in
         * generated java files or qualified access
         */
    JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(parentNode, curNodeName);
    if (!(parentNode instanceof TempJavaCodeFragmentFilesContainer)) {
        throw new TranslatorException("Parent node does not have file info");
    }
    TempJavaFragmentFiles tempJavaFragmentFiles;
    if (parentNode instanceof YangRpc) {
        tempJavaFragmentFiles = ((TempJavaCodeFragmentFilesContainer) parentNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    } else {
        tempJavaFragmentFiles = ((TempJavaCodeFragmentFilesContainer) parentNode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    }
    JavaImportData parentImportData = tempJavaFragmentFiles.getJavaImportData();
    boolean isQualified = parentImportData.addImportInfo(qualifiedTypeInfo);
    return getAttributeInfoForTheData(qualifiedTypeInfo, curNodeName, null, isQualified, isListNode);
}
#end_block

#method_before
private void addLeavesInfoToTempFiles(List<YangLeaf> listOfLeaves, YangNode curNode) throws IOException {
    if (listOfLeaves != null) {
        for (YangLeaf leaf : listOfLeaves) {
            if (!(leaf instanceof HasJavaLeafInfo)) {
                throw new TranslatorException("Leaf does not have java information");
            }
            HasJavaLeafInfo javaLeaf = (HasJavaLeafInfo) leaf;
            javaLeaf.updateJavaQualifiedInfo();
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaLeaf.getJavaQualifiedInfo(), javaLeaf.getName(), javaLeaf.getDataType(), getIsQualifiedAccessOrAddToImportList(javaLeaf.getJavaQualifiedInfo()), false);
            addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
        }
    }
}
#method_after
private void addLeavesInfoToTempFiles(List<YangLeaf> listOfLeaves) throws IOException {
    if (listOfLeaves != null) {
        for (YangLeaf leaf : listOfLeaves) {
            if (!(leaf instanceof JavaLeafInfoContainer)) {
                throw new TranslatorException("Leaf does not have java information");
            }
            JavaLeafInfoContainer javaLeaf = (JavaLeafInfoContainer) leaf;
            javaLeaf.updateJavaQualifiedInfo();
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaLeaf.getJavaQualifiedInfo(), javaLeaf.getName(), javaLeaf.getDataType(), getIsQualifiedAccessOrAddToImportList(javaLeaf.getJavaQualifiedInfo()), false);
            addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
        }
    }
}
#end_block

#method_before
private void addLeafListInfoToTempFiles(List<YangLeafList> listOfLeafList, YangNode curNode) throws IOException {
    if (listOfLeafList != null) {
        /*
             * Check if the attribute is of type list, then the java.lang.list
             * needs to be imported.
             */
        if (listOfLeafList.size() != 0) {
            if (!(curNode instanceof HasJavaImportData)) {
                throw new TranslatorException("missing import info in current data model node");
            }
            ((HasJavaImportData) curNode).getJavaImportData().setIfListImported(true);
        }
        for (YangLeafList leafList : listOfLeafList) {
            if (!(listOfLeafList instanceof HasJavaLeafInfo)) {
                throw new TranslatorException("Leaf-list does not have java information");
            }
            HasJavaLeafInfo javaLeaf = (HasJavaLeafInfo) listOfLeafList;
            javaLeaf.updateJavaQualifiedInfo();
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaLeaf.getJavaQualifiedInfo(), javaLeaf.getName(), javaLeaf.getDataType(), getIsQualifiedAccessOrAddToImportList(javaLeaf.getJavaQualifiedInfo()), true);
            addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
        }
    }
}
#method_after
private void addLeafListInfoToTempFiles(List<YangLeafList> listOfLeafList) throws IOException {
    if (listOfLeafList != null) {
        for (YangLeafList leafList : listOfLeafList) {
            if (!(leafList instanceof JavaLeafInfoContainer)) {
                throw new TranslatorException("Leaf-list does not have java information");
            }
            JavaLeafInfoContainer javaLeaf = (JavaLeafInfoContainer) leafList;
            javaLeaf.updateJavaQualifiedInfo();
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaLeaf.getJavaQualifiedInfo(), javaLeaf.getName(), javaLeaf.getDataType(), getIsQualifiedAccessOrAddToImportList(javaLeaf.getJavaQualifiedInfo()), true);
            addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
        }
    }
}
#end_block

#method_before
public void addCurNodeLeavesInfoToTempFiles(YangNode curNode) throws IOException {
    if (!(curNode instanceof YangLeavesHolder)) {
        throw new TranslatorException("Data model node does not have any leaves");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
    addLeavesInfoToTempFiles(leavesHolder.getListOfLeaf(), curNode);
    addLeafListInfoToTempFiles(leavesHolder.getListOfLeafList(), curNode);
}
#method_after
void addCurNodeLeavesInfoToTempFiles(YangNode curNode) throws IOException {
    if (!(curNode instanceof YangLeavesHolder)) {
        throw new TranslatorException("Data model node does not have any leaves");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
    addLeavesInfoToTempFiles(leavesHolder.getListOfLeaf());
    addLeafListInfoToTempFiles(leavesHolder.getListOfLeafList());
}
#end_block

#method_before
public void addTypeInfoToTempFiles(HasType hasType) throws IOException {
    List<YangType<?>> typeList = hasType.getTypeList();
    if (typeList != null) {
        for (YangType<?> yangType : typeList) {
            if (!(yangType instanceof YangJavaType)) {
                throw new TranslatorException("Type does not have Java info");
            }
            YangJavaType javaType = (YangJavaType) yangType;
            javaType.updateJavaQualifiedInfo();
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaType.getJavaQualifiedInfo(), javaType.getDataTypeName(), javaType, getIsQualifiedAccessOrAddToImportList(javaType.getJavaQualifiedInfo()), false);
            addJavaSnippetInfoToApplicableTempFiles((YangNode) hasType, javaAttributeInfo);
        }
    }
}
#method_after
public void addTypeInfoToTempFiles(YangTypeContainer yangTypeContainer) throws IOException {
    List<YangType<?>> typeList = yangTypeContainer.getTypeList();
    if (typeList != null) {
        for (YangType<?> yangType : typeList) {
            if (!(yangType instanceof YangJavaType)) {
                throw new TranslatorException("Type does not have Java info");
            }
            YangJavaType<?> javaType = (YangJavaType<?>) yangType;
            javaType.updateJavaQualifiedInfo();
            JavaAttributeInfo javaAttributeInfo = getAttributeInfoForTheData(javaType.getJavaQualifiedInfo(), javaType.getDataTypeName(), javaType, getIsQualifiedAccessOrAddToImportList(javaType.getJavaQualifiedInfo()), false);
            addJavaSnippetInfoToApplicableTempFiles((YangNode) yangTypeContainer, javaAttributeInfo);
        }
    }
}
#end_block

#method_before
private void addJavaSnippetInfoToApplicableTempFiles(YangNode hasType, JavaAttributeInfo javaAttributeInfo) throws IOException {
    JavaQualifiedTypeInfo qualifiedInfoOfFromString = getQualifiedInfoOfFromString(javaAttributeInfo);
    /*
         * Create a new java attribute info with qualified information of
         * wrapper classes.
         */
    JavaAttributeInfo fromStringAttributeInfo = getAttributeInfoForTheData(qualifiedInfoOfFromString, javaAttributeInfo.getAttributeName(), javaAttributeInfo.getAttributeType(), getIsQualifiedAccessOrAddToImportList(qualifiedInfoOfFromString), false);
    if ((generatedTempFiles & UNION_FROM_STRING_IMPL_MASK) != 0) {
        addUnionFromStringMethod(javaAttributeInfo, fromStringAttributeInfo);
    }
    addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#method_after
private void addJavaSnippetInfoToApplicableTempFiles(YangNode hasType, JavaAttributeInfo javaAttributeInfo) throws IOException {
    JavaQualifiedTypeInfo qualifiedInfoOfFromString = getQualifiedInfoOfFromString(javaAttributeInfo);
    /*
         * Create a new java attribute info with qualified information of
         * wrapper classes.
         */
    JavaAttributeInfo fromStringAttributeInfo = getAttributeInfoForTheData(qualifiedInfoOfFromString, javaAttributeInfo.getAttributeName(), javaAttributeInfo.getAttributeType(), getIsQualifiedAccessOrAddToImportList(qualifiedInfoOfFromString), false);
    if ((getGeneratedTempFiles() & FROM_STRING_IMPL_MASK) != 0) {
        addFromStringMethod(javaAttributeInfo, fromStringAttributeInfo);
    }
    addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    isAttributePresent = true;
    if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
        addAttribute(newAttrInfo);
    }
    if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
        addGetterForInterface(newAttrInfo);
    }
    if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
        addSetterForInterface(newAttrInfo);
    }
    if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
        addGetterImpl(newAttrInfo, getGeneratedJavaFiles());
    }
    if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
        addSetterImpl(newAttrInfo);
    }
    if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
        addConstructor(newAttrInfo);
    }
    if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
        addHashCodeMethod(newAttrInfo);
    }
    if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
        addEqualsMethod(newAttrInfo);
    }
    if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
        addToStringMethod(newAttrInfo);
    }
    if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
        addOfStringMethod(newAttrInfo);
    }
    if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        addTypeConstructor(newAttrInfo);
    }
}
#method_after
public void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo javaAttributeInfoOfInput, JavaAttributeInfo javaAttributeInfoOfOutput, String rpcName) throws IOException {
    if ((getGeneratedTempFiles() & RPC_IMPL_MASK) != 0) {
        addRpcString(javaAttributeInfoOfInput, javaAttributeInfoOfOutput, rpcName);
    }
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    isAttributePresent = true;
    if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
        addAttribute(newAttrInfo);
    }
    if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
        addGetterForInterface(newAttrInfo);
    }
    if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
        addSetterForInterface(newAttrInfo);
    }
    if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
        addGetterImpl(newAttrInfo, getGeneratedJavaFiles());
    }
    if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
        addSetterImpl(newAttrInfo);
    }
    if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
        addConstructor(newAttrInfo);
    }
    if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
        addHashCodeMethod(newAttrInfo);
    }
    if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
        addEqualsMethod(newAttrInfo);
    }
    if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
        addToStringMethod(newAttrInfo);
    }
    if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
        addOfStringMethod(newAttrInfo);
    }
    if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        addTypeConstructor(newAttrInfo);
    }
}
#method_after
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    isAttributePresent = true;
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        addAttribute(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_INTERFACE_MASK) != 0) {
        addGetterForInterface(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_INTERFACE_MASK) != 0) {
        addSetterForInterface(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
        addGetterImpl(newAttrInfo, getGeneratedJavaFiles());
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_CLASS_MASK) != 0) {
        addSetterImpl(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & CONSTRUCTOR_IMPL_MASK) != 0) {
        addConstructor(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        addHashCodeMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        addEqualsMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        addToStringMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & ENUM_IMPL_MASK) != 0) {
        addAttributesForEnumClass(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & OF_STRING_IMPL_MASK) != 0) {
        addOfStringMethod(newAttrInfo);
    }
    if ((getGeneratedTempFiles() & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        addTypeConstructor(newAttrInfo);
    }
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    if (isAttributePresent) {
        imports = getJavaImportData().getImports();
    }
    /**
     * Prepares java file generator for extends list.
     */
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    /**
     * Generate java code.
     */
    if ((fileType & INTERFACE_MASK) != 0 | (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /**
         * Adds import for HasAugmentation class.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
        }
        /**
         * Create interface file.
         */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create builder interface file.
         */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append builder interface file to interface file and close it.
             */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, false);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 | (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isHasAugmentationExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        /**
         * Create builder class file.
         */
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create impl class file.
         */
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append impl class to builder class and close it.
             */
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    /**
     * Creates type def class file.
     */
    if ((fileType & GENERATE_TYPEDEF_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypedefClassJavaFileHandle(getJavaFileHandle(getJavaClassName(TYPEDEF_CLASS_FILE_NAME_SUFFIX)));
        setTypedefClassJavaFileHandle(generateTypeDefClassFile(getTypedefClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type class file.
     */
    if ((fileType & GENERATE_UNION_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypeClassJavaFileHandle(getJavaFileHandle(getJavaClassName(UNION_TYPE_CLASS_FILE_NAME_SUFFIX)));
        setTypeClassJavaFileHandle(generateUnionClassFile(getTypeClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Close all the file handles.
     */
    close(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    if (isAttributePresent) {
        imports = getJavaImportData().getImports();
    }
    /**
     * Prepares java file generator for extends list.
     */
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    if (curNode.getNodeType().equals(MODULE_NODE)) {
        createPackage(absoluteDirPath, getJavaFileInfo().getJavaName());
    } else {
        createPackage(absoluteDirPath, ((JavaFileInfoContainer) curNode.getParent()).getJavaFileInfo().getJavaName() + PACKAGE_INFO_JAVADOC_OF_CHILD);
    }
    /**
     * Generate java code.
     */
    if ((fileType & INTERFACE_MASK) != 0 | (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /**
         * Adds import for case.
         */
        if (curNode instanceof YangCase) {
            List<String> importData = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
            for (String importInfo : importData) {
                if (!imports.contains(importInfo)) {
                    imports.add(importInfo);
                }
            }
        }
        /**
         * Adds import for HasAugmentation class.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
        }
        /**
         * Create interface file.
         */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create builder interface file.
         */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append builder interface file to interface file and close it.
             */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, false);
        }
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 | (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isHasAugmentationExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        /**
         * Create builder class file.
         */
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create impl class file.
         */
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append impl class to builder class and close it.
             */
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    /**
     * Creates type def class file.
     */
    if ((fileType & GENERATE_TYPEDEF_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypedefClassJavaFileHandle(getJavaFileHandle(getJavaClassName(TYPEDEF_CLASS_FILE_NAME_SUFFIX)));
        setTypedefClassJavaFileHandle(generateTypeDefClassFile(getTypedefClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type class file.
     */
    if ((fileType & GENERATE_UNION_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypeClassJavaFileHandle(getJavaFileHandle(getJavaClassName(UNION_TYPE_CLASS_FILE_NAME_SUFFIX)));
        setTypeClassJavaFileHandle(generateUnionClassFile(getTypeClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type enum class file.
     */
    if ((fileType & GENERATE_ENUM_CLASS) != 0) {
        setEnumClassJavaFileHandle(getJavaFileHandle(getJavaClassName(ENUM_CLASS_FILE_NAME_SUFFIX)));
        setEnumClassJavaFileHandle(generateEnumClassFile(getEnumClassJavaFileHandle(), curNode));
    }
    /**
     * Creates rpc interface file.
     */
    if ((fileType & GENERATE_RPC_INTERFACE) != 0) {
        setRpcInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(RPC_INTERFACE_FILE_NAME_SUFFIX)));
        setRpcInterfaceJavaFileHandle(generateRpcInterfaceFile(getRpcInterfaceJavaFileHandle(), curNode, imports));
    }
    /**
     * Close all the file handles.
     */
    close(false);
}
#end_block

#method_before
public void close(boolean isErrorOccurred) throws IOException {
    boolean isError = isErrorOccurred;
    /**
     * Close all java file handles and when error occurs delete the files.
     */
    if ((getGeneratedJavaFiles() & INTERFACE_MASK) != 0) {
        closeFile(getInterfaceJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderClassJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & BUILDER_INTERFACE_MASK) != 0) {
        closeFile(getBuilderInterfaceJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & IMPL_CLASS_MASK) != 0) {
        closeFile(getImplClassJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & GENERATE_TYPEDEF_CLASS) != 0) {
        closeFile(getTypedefClassJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & GENERATE_UNION_CLASS) != 0) {
        closeFile(getTypeClassJavaFileHandle(), isError);
    }
    /**
     * Close all temporary file handles and delete the files.
     */
    if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getGetterInterfaceTempFileHandle(), true);
    }
    if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getGetterImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getSetterInterfaceTempFileHandle(), true);
    }
    if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getSetterImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
        closeFile(getConstructorImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
        closeFile(getAttributesTempFileHandle(), true);
    }
    if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
        closeFile(getHashCodeImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
        closeFile(getToStringImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
        closeFile(getEqualsImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        closeFile(getConstructorForTypeTempFileHandle(), true);
    }
    if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
        closeFile(getOfStringImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & UNION_FROM_STRING_IMPL_MASK) != 0) {
        closeFile(getUnionFromStringImplTempFileHandle(), true);
    }
    clean(getTempDirPath());
    generatedTempFiles = 0;
}
#method_after
public void close(boolean isErrorOccurred) throws IOException {
    boolean isError = isErrorOccurred;
    /**
     * Close all java file handles and when error occurs delete the files.
     */
    if ((getGeneratedJavaFiles() & INTERFACE_MASK) != 0) {
        closeFile(getInterfaceJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderClassJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & BUILDER_INTERFACE_MASK) != 0) {
        closeFile(getBuilderInterfaceJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & IMPL_CLASS_MASK) != 0) {
        closeFile(getImplClassJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & GENERATE_TYPEDEF_CLASS) != 0) {
        closeFile(getTypedefClassJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & GENERATE_ENUM_CLASS) != 0) {
        closeFile(getEnumClassJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & GENERATE_UNION_CLASS) != 0) {
        closeFile(getTypeClassJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & GENERATE_RPC_INTERFACE) != 0) {
        closeFile(getRpcInterfaceJavaFileHandle(), isError);
    }
    /**
     * Close all temporary file handles and delete the files.
     */
    if ((getGeneratedTempFiles() & GETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getGetterInterfaceTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getGetterImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getSetterInterfaceTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & SETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getSetterImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & CONSTRUCTOR_IMPL_MASK) != 0) {
        closeFile(getConstructorImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        closeFile(getAttributesTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        closeFile(getHashCodeImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        closeFile(getToStringImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        closeFile(getEqualsImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & ENUM_IMPL_MASK) != 0) {
        closeFile(getEnumClassTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        closeFile(getConstructorForTypeTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & OF_STRING_IMPL_MASK) != 0) {
        closeFile(getOfStringImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & FROM_STRING_IMPL_MASK) != 0) {
        closeFile(getFromStringImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & RPC_IMPL_MASK) != 0) {
        closeFile(getRpcInterfaceImplTempFileHandle(), true);
    }
    clean(getTempDirPath());
    clearGeneratedTempFiles();
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeAndUpdateInParent(this, yangPlugin, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfAugmentableNode(this, yangPlugin);
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenTypeAndTypedefAtRootLevel() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenTypeAndTypedefAtRootLevel.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processSelfResolutionWhenTypeAndTypedefAtRootLevel() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenTypeAndTypedefAtRootLevel.yang");
    // Check whether the data model tree returned is of type module.
    assertThat(node instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootTypeTwoLevelInHierarchy.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingTypedefAtRootIsAfterContainerHavingType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootIsAfterContainerHavingType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild().getNextSibling()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingTypedefAtRootIsAfterContainerHavingType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtRootIsAfterContainerHavingType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild().getNextSibling()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingTypedefAtMiddleLevelAfterParentHolder() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtMiddleLevelAfterParentHolder.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingTypedefAtMiddleLevelAfterParentHolder() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingTypedefAtMiddleLevelAfterParentHolder.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("hello"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypdefHierarchicalReference() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalReference.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat((typeDef1.getTypeDefBaseType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat((typeDef2.getTypeDefBaseType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypdefHierarchicalReference() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalReference.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypdefHierarchicalRefUnresolved() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalRefUnresolved.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat((typeDef1.getTypeDefBaseType().getResolvableStatus()), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat((typeDef2.getTypeDefBaseType().getResolvableStatus()), is(ResolvableStatus.INTRA_FILE_RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypdefHierarchicalRefUnresolved() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypdefHierarchicalRefUnresolved.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(ResolvableStatus.INTRA_FILE_RESOLVED));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypeWithSelfModulePrefix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfModulePrefix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat((typeDef1.getTypeDefBaseType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat((typeDef2.getTypeDefBaseType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypeWithSelfModulePrefix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfModulePrefix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    assertThat(((YangDerivedInfo<?>) typeDef1.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangContainer.getChild().getNextSibling()));
    assertThat(typeDef1.getTypeDefBaseType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processSelfFileLinkingWithTypeWithSelfAndExternalPrefixMix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfAndExternalPrefixMix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat((leafInfo.getDataType().getResolvableStatus()), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat((typeDef2.getTypeDefBaseType().getResolvableStatus()), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processSelfFileLinkingWithTypeWithSelfAndExternalPrefixMix() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfFileLinkingWithTypeWithSelfAndExternalPrefixMix.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) node.getChild().getNextSibling();
    YangList yangList = (YangList) yangContainer.getChild();
    ListIterator<YangLeaf> leafIterator = yangList.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("FirstClass"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    assertThat(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) yangList.getChild()));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(ResolvableStatus.INTRA_FILE_RESOLVED));
    YangTypeDef typeDef1 = (YangTypeDef) yangList.getChild();
    YangTypeDef typeDef2 = (YangTypeDef) yangContainer.getChild().getNextSibling();
    assertThat(((YangDerivedInfo<?>) typeDef2.getTypeDefBaseType().getDataTypeExtendedInfo()).getReferredTypeDef(), is((YangTypeDef) node.getChild()));
    assertThat(typeDef2.getTypeDefBaseType().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
public static void detectCollidingChildUtil(String identifierName, YangConstructType dataType, YangNode node) throws DataModelException {
    if (node instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) node;
        detectCollidingLeaf(leavesHolder.getListOfLeaf(), identifierName);
        detectCollidingLeafList(leavesHolder.getListOfLeafList(), identifierName);
    }
    node = node.getChild();
    while (node != null) {
        if (node instanceof CollisionDetector) {
            ((CollisionDetector) node).detectSelfCollision(identifierName, dataType);
        }
        node = node.getNextSibling();
    }
}
#method_after
public static void detectCollidingChildUtil(String identifierName, YangConstructType dataType, YangNode node) throws DataModelException {
    if (dataType == YangConstructType.USES_DATA || dataType == YangConstructType.GROUPING_DATA) {
        detectCollidingForUsesGrouping(identifierName, dataType, node);
    } else {
        if (node instanceof YangLeavesHolder) {
            YangLeavesHolder leavesHolder = (YangLeavesHolder) node;
            detectCollidingLeaf(leavesHolder.getListOfLeaf(), identifierName);
            detectCollidingLeafList(leavesHolder.getListOfLeafList(), identifierName);
        }
        node = node.getChild();
        while (node != null) {
            Parsable parsable = (Parsable) node;
            if (node instanceof CollisionDetector && (parsable.getYangConstructType() != YangConstructType.USES_DATA) && (parsable.getYangConstructType() != YangConstructType.GROUPING_DATA)) {
                ((CollisionDetector) node).detectSelfCollision(identifierName, dataType);
            }
            node = node.getNextSibling();
        }
    }
}
#end_block

#method_before
public static void addResolutionInfo(YangResolutionInfo resolutionInfo) throws DataModelException {
    /* get the module node to add maintain the list of nested reference */
    YangNode curNode = resolutionInfo.getEntityToResolveInfo().getHolderOfEntityToResolve();
    while (!(curNode instanceof HasResolutionInfo)) {
        curNode = curNode.getParent();
        if (curNode == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
        }
    }
    HasResolutionInfo resolutionNode = (HasResolutionInfo) curNode;
    if (!isPrefixValid(resolutionInfo.getEntityToResolveInfo().getEntityPrefix(), resolutionNode)) {
        throw new DataModelException("The prefix used is not valid");
    }
    resolutionNode.addToResolutionList(resolutionInfo);
}
#method_after
public static void addResolutionInfo(YangResolutionInfo resolutionInfo) throws DataModelException {
    /* get the module node to add maintain the list of nested reference */
    YangNode curNode = resolutionInfo.getEntityToResolveInfo().getHolderOfEntityToResolve();
    while (!(curNode instanceof YangReferenceResolver)) {
        curNode = curNode.getParent();
        if (curNode == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
        }
    }
    YangReferenceResolver resolutionNode = (YangReferenceResolver) curNode;
    if (!isPrefixValid(resolutionInfo.getEntityToResolveInfo().getEntityPrefix(), resolutionNode)) {
        throw new DataModelException("The prefix used is not valid");
    }
    resolutionNode.addToResolutionList(resolutionInfo);
}
#end_block

#method_before
private static boolean isPrefixValid(String entityPrefix, HasResolutionInfo resolutionNode) {
    if (entityPrefix == null) {
        return true;
    }
    if (resolutionNode.getPrefix().contentEquals(entityPrefix)) {
        return true;
    }
    if (resolutionNode.getImportList() != null) {
        for (YangImport importedInfo : resolutionNode.getImportList()) {
            if (importedInfo.getPrefixId().contentEquals(entityPrefix)) {
                return true;
            }
        }
    }
    if (resolutionNode.getIncludeList() != null) {
    /**
     * TODO: check if the prefix matches with the imported data
     *
     *             for (YangInclude includedInfo : resolutionNode.getIncludeList()) {
     *             if (includedInfo.contentEquals(prefix)) {
     *             return true;
     *             }
     *             }
     */
    }
    return false;
}
#method_after
private static boolean isPrefixValid(String entityPrefix, YangReferenceResolver resolutionNode) {
    if (entityPrefix == null) {
        return true;
    }
    if (resolutionNode.getPrefix().contentEquals(entityPrefix)) {
        return true;
    }
    if (resolutionNode.getImportList() != null) {
        for (YangImport importedInfo : resolutionNode.getImportList()) {
            if (importedInfo.getPrefixId().contentEquals(entityPrefix)) {
                return true;
            }
        }
    }
    if (resolutionNode.getIncludeList() != null) {
    /**
     * TODO: check if the prefix matches with the imported data
     *
     *             for (YangInclude includedInfo : resolutionNode.getIncludeList()) {
     *             if (includedInfo.contentEquals(prefix)) {
     *             return true;
     *             }
     *             }
     */
    }
    return false;
}
#end_block

#method_before
public static void resolveLinkingForResolutionList(List<YangResolutionInfo> resolutionList, HasResolutionInfo dataModelRootNode) throws DataModelException {
    for (YangResolutionInfo resolutionInfo : resolutionList) {
        resolutionInfo.resolveLinkingForResolutionInfo(dataModelRootNode.getPrefix());
    }
}
#method_after
public static void resolveLinkingForResolutionList(List<YangResolutionInfo> resolutionList, YangReferenceResolver dataModelRootNode) throws DataModelException {
    for (YangResolutionInfo resolutionInfo : resolutionList) {
        resolutionInfo.resolveLinkingForResolutionInfo(dataModelRootNode.getPrefix());
    }
}
#end_block

#method_before
public static void updateLeavesJavaQualifiedInfo(HasJavaLeafInfo leaf) {
    JavaQualifiedTypeInfo importInfo = leaf.getJavaQualifiedInfo();
    if (leaf.getDataType() == null) {
        throw new TranslatorException("missing data type of leaf " + leaf.getName());
    }
    /*
         * Current leaves holder is adding a leaf info as a attribute to the
         * current class.
         */
    String className = AttributesJavaDataType.getJavaImportClass(leaf.getDataType(), leaf.isLeafList());
    if (className != null) {
        /*
             * Corresponding to the attribute type a class needs to be imported,
             * since it can be a derived type or a usage of wrapper classes.
             */
        importInfo.setClassInfo(className);
        String classPkg = AttributesJavaDataType.getJavaImportPackage(leaf.getDataType(), leaf.isLeafList(), className);
        if (classPkg == null) {
            throw new TranslatorException("import package cannot be null when the class is used");
        }
        importInfo.setPkgInfo(classPkg);
    } else {
        /*
             * The attribute does not need a class to be imported, for example
             * built in java types.
             */
        String dataTypeName = AttributesJavaDataType.getJavaDataType(leaf.getDataType());
        if (dataTypeName == null) {
            throw new TranslatorException("not supported data type");
        }
        importInfo.setClassInfo(dataTypeName);
    }
}
#method_after
public static void updateLeavesJavaQualifiedInfo(JavaLeafInfoContainer leaf) {
    JavaQualifiedTypeInfo importInfo = leaf.getJavaQualifiedInfo();
    if (leaf.getDataType() == null) {
        throw new TranslatorException("missing data type of leaf " + leaf.getName());
    }
    /*
         * Current leaves holder is adding a leaf info as a attribute to the
         * current class.
         */
    String className = AttributesJavaDataType.getJavaImportClass(leaf.getDataType(), leaf.isLeafList());
    if (className != null) {
        /*
             * Corresponding to the attribute type a class needs to be imported,
             * since it can be a derived type or a usage of wrapper classes.
             */
        importInfo.setClassInfo(className);
        String classPkg = AttributesJavaDataType.getJavaImportPackage(leaf.getDataType(), leaf.isLeafList(), className);
        if (classPkg == null) {
            throw new TranslatorException("import package cannot be null when the class is used");
        }
        importInfo.setPkgInfo(classPkg);
    } else {
        /*
             * The attribute does not need a class to be imported, for example
             * built in java types.
             */
        String dataTypeName = AttributesJavaDataType.getJavaDataType(leaf.getDataType());
        if (dataTypeName == null) {
            throw new TranslatorException("not supported data type");
        }
        importInfo.setClassInfo(dataTypeName);
    }
}
#end_block

#method_before
public static JavaQualifiedTypeInfo getQualifiedTypeInfoOfCurNode(YangNode curNode, String attributeName, boolean isListAttr) {
    JavaQualifiedTypeInfo importInfo = new JavaQualifiedTypeInfo();
    if (!(curNode instanceof HasJavaFileInfo)) {
        throw new TranslatorException("missing java file information to get the package details " + "of attribute corresponding to child node");
    }
    /*
         * The scenario when we need to add the child class as an attribute in
         * the current class. The child class is in the package of the current
         * classes package with current classes name.
         */
    importInfo.setClassInfo(attributeName);
    importInfo.setPkgInfo((((HasJavaFileInfo) curNode).getJavaFileInfo().getPackage() + "." + ((HasJavaFileInfo) curNode).getJavaFileInfo().getJavaName()).toLowerCase());
    return importInfo;
}
#method_after
public static JavaQualifiedTypeInfo getQualifiedTypeInfoOfCurNode(YangNode curNode, String attributeName) {
    JavaQualifiedTypeInfo importInfo = new JavaQualifiedTypeInfo();
    if (!(curNode instanceof JavaFileInfoContainer)) {
        throw new TranslatorException("missing java file information to get the package details " + "of attribute corresponding to child node");
    }
    /*
         * The scenario when we need to add the child class as an attribute in
         * the current class. The child class is in the package of the current
         * classes package with current classes name.
         */
    importInfo.setClassInfo(attributeName);
    importInfo.setPkgInfo((((JavaFileInfoContainer) curNode).getJavaFileInfo().getPackage() + "." + ((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName()).toLowerCase());
    return importInfo;
}
#end_block

#method_before
public static void processEnumerationEntry(TreeWalkListener listener, GeneratedYangParser.EnumSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangEnumeration enumerationNode = new YangEnumeration();
        Parsable typeData = listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                // Set the name of enumeration same as leaf.
                enumerationNode.setName(((YangLeaf) tmpData).getName() + ENUMERATION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leaf = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leaf);
                break;
            case LEAF_LIST_DATA:
                // Set the name of enumeration same as leaf list.
                enumerationNode.setName(((YangLeafList) tmpData).getName() + ENUMERATION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leafList = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leafList);
                break;
            case UNION_DATA:
                YangUnion yangUnion = (YangUnion) tmpData;
                /*
                     * In case parent of enumeration is a union, name of the
                     * enumeration is parent union name suffixed with running
                     * integer number, this is done because under union there
                     * could be multiple child union types.
                     */
                enumerationNode.setName(yangUnion.getName() + yangUnion.getChildUnionNumber() + ENUMERATION_CLASS_SUFFIX);
                // Increment the running number.
                yangUnion.setChildUnionNumber(yangUnion.getChildUnionNumber() + 1);
                // Add union as a child to parent union.
                addChildToParentNode(listener, enumerationNode);
                break;
            case TYPEDEF_DATA:
                YangTypeDef typeDef = (YangTypeDef) tmpData;
                // Set the name of enumeration same as typedef name.
                enumerationNode.setName(typeDef.getName() + ENUMERATION_CLASS_SUFFIX);
                // Add enumeration as a child to parent type def.
                addChildToParentNode(listener, enumerationNode);
                break;
            // TODO deviate.
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ((YangType<?>) typeData).getDataTypeName(), ENTRY));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(enumerationNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ENUMERATION_DATA, "", ENTRY));
    }
}
#method_after
public static void processEnumerationEntry(TreeWalkListener listener, GeneratedYangParser.EnumSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangEnumeration enumerationNode = getYangEnumerationNode(JAVA_GENERATION);
        Parsable typeData = listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                // Set the name of enumeration same as leaf.
                enumerationNode.setName(((YangLeaf) tmpData).getName() + ENUMERATION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leaf = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leaf);
                break;
            case LEAF_LIST_DATA:
                // Set the name of enumeration same as leaf list.
                enumerationNode.setName(((YangLeafList) tmpData).getName() + ENUMERATION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leafList = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leafList);
                break;
            case UNION_DATA:
                YangUnion yangUnion = (YangUnion) tmpData;
                /*
                     * In case parent of enumeration is a union, name of the
                     * enumeration is parent union name suffixed with running
                     * integer number, this is done because under union there
                     * could be multiple child union types.
                     */
                enumerationNode.setName(yangUnion.getName() + yangUnion.getChildUnionNumber() + ENUMERATION_CLASS_SUFFIX);
                // Increment the running number.
                yangUnion.setChildUnionNumber(yangUnion.getChildUnionNumber() + 1);
                // Add union as a child to parent union.
                addChildToParentNode(listener, enumerationNode);
                break;
            case TYPEDEF_DATA:
                YangTypeDef typeDef = (YangTypeDef) tmpData;
                // Set the name of enumeration same as typedef name.
                enumerationNode.setName(typeDef.getName() + ENUMERATION_CLASS_SUFFIX);
                // Add enumeration as a child to parent type def.
                addChildToParentNode(listener, enumerationNode);
                break;
            // TODO deviate.
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ((YangType<?>) typeData).getDataTypeName(), ENTRY));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(enumerationNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ENUMERATION_DATA, "", ENTRY));
    }
}
#end_block

#method_before
private static void addChildToParentNode(TreeWalkListener listener, YangUnion unionNode) {
    if (!(listener.getParsedDataStack().peek() instanceof YangNode)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, UNION_DATA, "", ENTRY));
    } else {
        YangNode curNode = (YangNode) listener.getParsedDataStack().peek();
        try {
            curNode.addChild(unionNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, YangConstructType.UNION_DATA, "", ENTRY, e.getMessage()));
        }
    }
}
#method_after
private static void addChildToParentNode(TreeWalkListener listener, YangUnion unionNode) {
    if (!(listener.getParsedDataStack().peek() instanceof YangNode)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, UNION_DATA, "", ENTRY));
    } else {
        YangNode curNode = (YangNode) listener.getParsedDataStack().peek();
        try {
            curNode.addChild(unionNode);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, UNION_DATA, "", ENTRY, e.getMessage()));
        }
    }
}
#end_block

#method_before
public YangNode clone() throws CloneNotSupportedException {
    YangNode clonedNode = (YangNode) super.clone();
    clonedNode.setParent(null);
    clonedNode.setChild(null);
    clonedNode.setNextSibling(null);
    clonedNode.setPreviousSibling(null);
    return clonedNode;
}
#method_after
@Override
public YangNode clone() throws CloneNotSupportedException {
    YangNode clonedNode = (YangNode) super.clone();
    clonedNode.setParent(null);
    clonedNode.setChild(null);
    clonedNode.setNextSibling(null);
    clonedNode.setPreviousSibling(null);
    return clonedNode;
}
#end_block

#method_before
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode) throws DataModelException {
    YangNode nextNodeToClone = srcRootNode;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    nextNodeToClone = nextNodeToClone.getChild();
    if (nextNodeToClone == null) {
        return;
    } else {
        /**
         * Root level cloning is taken care in the caller.
         */
        curTraversal = CHILD;
    }
    /**
     * Caller ensures the cloning of the root nodes
     */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning failed, source tree null pointer reached");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone();
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /**
                 * add the new node to the cloned tree.
                 */
                clonedTreeCurNode.addChild(newNode);
                /**
                 * update the cloned tree's travesal current node as the new node.
                 */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBILING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else if (curTraversal == PARENT) {
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /**
                 * update the traversal's current node.
                 */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                curTraversal = SIBILING;
                nextNodeToClone = nextNodeToClone.getNextSibling();
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree");
    }
}
#method_after
public static void cloneSubTree(YangNode srcRootNode, YangNode dstRootNode) throws DataModelException {
    YangNode nextNodeToClone = srcRootNode;
    TraversalType curTraversal;
    YangNode clonedTreeCurNode = dstRootNode;
    YangNode newNode = null;
    nextNodeToClone = nextNodeToClone.getChild();
    if (nextNodeToClone == null) {
        return;
    } else {
        /**
         * Root level cloning is taken care in the caller.
         */
        curTraversal = CHILD;
    }
    /**
     * Caller ensures the cloning of the root nodes
     */
    try {
        while (nextNodeToClone != srcRootNode) {
            if (nextNodeToClone == null) {
                throw new DataModelException("Internal error: Cloning failed, source tree null pointer reached");
            }
            if (curTraversal != PARENT) {
                newNode = nextNodeToClone.clone();
                detectCollisionWhileCloning(clonedTreeCurNode, newNode, curTraversal);
            }
            if (curTraversal == CHILD) {
                /**
                 * add the new node to the cloned tree.
                 */
                clonedTreeCurNode.addChild(newNode);
                /**
                 * update the cloned tree's traversal current node as the
                 * new node.
                 */
                clonedTreeCurNode = newNode;
            } else if (curTraversal == SIBILING) {
                clonedTreeCurNode.addNextSibling(newNode);
                clonedTreeCurNode = newNode;
            } else if (curTraversal == PARENT) {
                clonedTreeCurNode = clonedTreeCurNode.getParent();
            }
            if (curTraversal != PARENT && nextNodeToClone.getChild() != null) {
                curTraversal = CHILD;
                /**
                 * update the traversal's current node.
                 */
                nextNodeToClone = nextNodeToClone.getChild();
            } else if (nextNodeToClone.getNextSibling() != null) {
                curTraversal = SIBILING;
                nextNodeToClone = nextNodeToClone.getNextSibling();
            } else {
                curTraversal = PARENT;
                nextNodeToClone = nextNodeToClone.getParent();
            }
        }
    } catch (CloneNotSupportedException e) {
        throw new DataModelException("Failed to clone the tree");
    }
}
#end_block

#method_before
private static void detectCollisionWhileCloning(YangNode currentNode, YangNode newNode, TraversalType addAs) throws DataModelException {
    if ((!(currentNode instanceof CollisionDetector)) || (!(newNode instanceof Parsable))) {
        throw new DataModelException("Node in data model tree does not support collision detection");
    }
    CollisionDetector collisionDetector = (CollisionDetector) currentNode;
    Parsable parsable = (Parsable) newNode;
    if (addAs == TraversalType.CHILD) {
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else if (addAs == TraversalType.SIBILING) {
        currentNode = currentNode.getParent();
        if (!(currentNode instanceof CollisionDetector)) {
            throw new DataModelException("Node in data model tree does not support collision detection");
        }
        collisionDetector = (CollisionDetector) currentNode;
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else {
        throw new DataModelException("Errored tree cloning");
    }
}
#method_after
private static void detectCollisionWhileCloning(YangNode currentNode, YangNode newNode, TraversalType addAs) throws DataModelException {
    if (!(currentNode instanceof CollisionDetector) || !(newNode instanceof Parsable)) {
        throw new DataModelException("Node in data model tree does not support collision detection");
    }
    CollisionDetector collisionDetector = (CollisionDetector) currentNode;
    Parsable parsable = (Parsable) newNode;
    if (addAs == TraversalType.CHILD) {
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else if (addAs == TraversalType.SIBILING) {
        currentNode = currentNode.getParent();
        if (!(currentNode instanceof CollisionDetector)) {
            throw new DataModelException("Node in data model tree does not support collision detection");
        }
        collisionDetector = (CollisionDetector) currentNode;
        collisionDetector.detectCollidingChild(newNode.getName(), parsable.getYangConstructType());
    } else {
        throw new DataModelException("Errored tree cloning");
    }
}
#end_block

#method_before
private void addNextSibling(YangNode newSibling) throws DataModelException {
    if (newSibling.getNodeType() == null) {
        throw new DataModelException("Cloned abstract node cannot be inserted into a tree");
    }
    if (newSibling.getParent() == null) {
        /**
         * Since the siblings needs to have a common parent, set the parent as the current node's parent
         */
        newSibling.setParent(this.getParent());
    } else {
        throw new DataModelException("Node is already part of a tree, and cannot be added as a sibling");
    }
    if (newSibling.getPreviousSibling() == null) {
        newSibling.setPreviousSibling(this);
        setNextSibling(newSibling);
    } else {
        throw new DataModelException("New sibling to be added is not atomic, it already has a previous sibling");
    }
    if (newSibling.getChild() != null) {
        throw new DataModelException("Sibling to be added is not atomic, it already has a child");
    }
    if (newSibling.getNextSibling() != null) {
        throw new DataModelException("Sibling to be added is not atomic, it already has a next sibling");
    }
}
#method_after
private void addNextSibling(YangNode newSibling) throws DataModelException {
    if (newSibling.getNodeType() == null) {
        throw new DataModelException("Cloned abstract node cannot be inserted into a tree");
    }
    if (newSibling.getParent() == null) {
        /**
         * Since the siblings needs to have a common parent, set the parent
         * as the current node's parent
         */
        newSibling.setParent(getParent());
    } else {
        throw new DataModelException("Node is already part of a tree, and cannot be added as a sibling");
    }
    if (newSibling.getPreviousSibling() == null) {
        newSibling.setPreviousSibling(this);
        setNextSibling(newSibling);
    } else {
        throw new DataModelException("New sibling to be added is not atomic, it already has a previous sibling");
    }
    if (newSibling.getChild() != null) {
        throw new DataModelException("Sibling to be added is not atomic, it already has a child");
    }
    if (newSibling.getNextSibling() != null) {
        throw new DataModelException("Sibling to be added is not atomic, it already has a next sibling");
    }
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeAndUpdateInParent(this, yangPlugin, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfAugmentableNode(this, yangPlugin);
}
#end_block

#method_before
@Override
public void generateCodeExit() {
// TODO Auto-generated method stub
}
#method_after
@Override
public void generateCodeExit() throws IOException {
    getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeAndUpdateInParent(this, yangPlugin, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfNode(this, yangPlugin);
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                // TODO: DECIMAL64.
                break;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                // TODO: ENUMERATION.
                break;
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                return null;
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                // TODO: DECIMAL64.
                break;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                // TODO: ENUMERATION.
                break;
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                // TODO:EMPTY
                break;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                return null;
        }
    }
    return null;
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                // TODO: DECIMAL64.
                break;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCaptialCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), null));
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                // TODO: DECIMAL64.
                break;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCaptialCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), null));
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                // TODO:EMPTY
                break;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                return null;
        }
    }
    return null;
}
#end_block

#method_before
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, String classInfo) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
            case INT16:
            case INT32:
            case INT64:
            case UINT8:
            case UINT16:
            case UINT32:
            case STRING:
            case BOOLEAN:
                return JAVA_LANG;
            case UINT64:
                return JAVA_MATH;
            case DECIMAL64:
                // TODO: DECIMAL64.
                break;
            case ENUMERATION:
                // TODO: ENUMERATION.
                break;
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                // TODO:EMPTY
                break;
            case UNION:
                return getUnionPackage(yangType);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType);
            default:
                return null;
        }
    } else {
        switch(type) {
            case UINT64:
                // TODO: BIGINTEGER.
                break;
            case DECIMAL64:
                // TODO: DECIMAL64
                break;
            case STRING:
                return JAVA_LANG;
            case ENUMERATION:
                // TODO: ENUMERATION.
                break;
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                // TODO:EMPTY
                break;
            case UNION:
                return getUnionPackage(yangType);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType);
            default:
                return null;
        }
    }
    return null;
}
#method_after
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, String classInfo) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
            case INT16:
            case INT32:
            case INT64:
            case UINT8:
            case UINT16:
            case UINT32:
            case STRING:
            case BOOLEAN:
                return JAVA_LANG;
            case UINT64:
                return JAVA_MATH;
            case DECIMAL64:
                // TODO: DECIMAL64.
                break;
            case ENUMERATION:
                return getEnumsPackage(yangType);
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                // TODO:EMPTY
                break;
            case UNION:
                return getUnionPackage(yangType);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType);
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                // TODO: BIGINTEGER.
                break;
            case DECIMAL64:
                // TODO: DECIMAL64
                break;
            case STRING:
                return JAVA_LANG;
            case ENUMERATION:
                return getEnumsPackage(yangType);
            case BITS:
                // TODO:BITS
                break;
            case BINARY:
                // TODO:BINARY
                break;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                // TODO:EMPTY
                break;
            case UNION:
                return getUnionPackage(yangType);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType);
            default:
                return null;
        }
    }
    return null;
}
#end_block

#method_before
private static String getPackageFromParent(YangNode parent) {
    if (!(parent instanceof HasJavaFileInfo)) {
        throw new TranslatorException("invalid child node is being processed.");
    }
    JavaFileInfo parentInfo = ((HasJavaFileInfo) parent).getJavaFileInfo();
    return parentInfo.getPackage() + PERIOD + parentInfo.getJavaName().toLowerCase();
}
#method_after
private static String getPackageFromParent(YangNode parent) {
    if (!(parent instanceof JavaFileInfoContainer)) {
        throw new TranslatorException("invalid child node is being processed.");
    }
    JavaFileInfo parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    return parentInfo.getPackage() + PERIOD + parentInfo.getJavaName().toLowerCase();
}
#end_block

#method_before
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPlugin.getConflictResolver())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) javaCodeGeneratorInfo));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
}
#method_after
public static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPlugin.getConflictResolver())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) javaCodeGeneratorInfo));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
}
#end_block

#method_before
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo);
    } else if (javaCodeGeneratorInfo instanceof HasType) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((HasType) javaCodeGeneratorInfo);
    } else {
    // TODO throw exception
    }
}
#method_after
private static void updateTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo);
    } else if (javaCodeGeneratorInfo instanceof YangTypeContainer) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((YangTypeContainer) javaCodeGeneratorInfo);
    } else if (javaCodeGeneratorInfo instanceof YangJavaEnumeration) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addEnumAttributeToTempFiles((YangNode) javaCodeGeneratorInfo);
    } else if (javaCodeGeneratorInfo instanceof YangChoice) {
    /*Do nothing, only the interface needs to be generated*/
    } else {
        throw new TranslatorException("Unsupported Node Translation");
    }
}
#end_block

#method_before
private static void generateTempFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    createTempFragmentFile(javaCodeGeneratorInfo);
    updateTempFragmentFiles(javaCodeGeneratorInfo);
}
#method_after
private static void generateTempFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("translation is not supported for the node");
    }
    createTempFragmentFile(javaCodeGeneratorInfo);
    updateTempFragmentFiles(javaCodeGeneratorInfo);
}
#end_block

#method_before
public static void generateCodeAndUpdateInParent(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    /**
     * Generate the Java files corresponding to the current node.
     */
    generateCodeofNode(javaCodeGeneratorInfo, yangPlugin, isMultiInstance);
    /**
     * Update the current nodes info in its parent nodes generated files.
     */
    addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
}
#method_after
public static void generateCodeAndUpdateInParent(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
        throw new TranslatorException("Invalid node for translation");
    }
    /**
     * Generate the Java files corresponding to the current node.
     */
    generateCodeOfAugmentableNode(javaCodeGeneratorInfo, yangPlugin);
    /**
     * Update the current nodes info in its parent nodes generated files.
     */
    addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    if (getBeanTempFiles() != null) {
        getBeanTempFiles().addJavaSnippetInfoToApplicableTempFiles(newAttrInfo);
    }
    /**
     * Creates user defined data type class file.
     */
    if (getTypeTempFiles() != null) {
        getTypeTempFiles().addJavaSnippetInfoToApplicableTempFiles(newAttrInfo);
    }
}
#method_after
public void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    if (getBeanTempFiles() != null) {
        getBeanTempFiles().addJavaSnippetInfoToApplicableTempFiles(newAttrInfo);
    }
    /**
     * Creates user defined data type class file.
     */
    if (getTypeTempFiles() != null) {
        getTypeTempFiles().addJavaSnippetInfoToApplicableTempFiles(newAttrInfo);
    }
}
#end_block

#method_before
public void addTypeInfoToTempFiles(HasType hasType) throws IOException {
    if (getTypeTempFiles() != null) {
        getTypeTempFiles().addTypeInfoToTempFiles(hasType);
    }
}
#method_after
public void addTypeInfoToTempFiles(YangTypeContainer yangTypeContainer) throws IOException {
    if (getTypeTempFiles() != null) {
        getTypeTempFiles().addTypeInfoToTempFiles(yangTypeContainer);
    }
}
#end_block

#method_before
public String addBuildMethodForInterface() throws IOException {
    if (getBeanTempFiles() != null) {
        return getBeanTempFiles().addBuildMethodForInterface();
    }
    throw new RuntimeException("build method only supported for bean class");
}
#method_after
public String addBuildMethodForInterface() throws IOException {
    if (getBeanTempFiles() != null) {
        return getBeanTempFiles().addBuildMethodForInterface();
    }
    throw new TranslatorException("build method only supported for bean class");
}
#end_block

#method_before
public String addDefaultConstructor(String modifier, String toAppend) throws IOException {
    if (getTypeTempFiles() != null) {
        return getTypeTempFiles().addDefaultConstructor(modifier, toAppend);
    }
    if (getBeanTempFiles() != null) {
        return getBeanTempFiles().addDefaultConstructor(modifier, toAppend);
    }
    throw new RuntimeException("default constructor should not be added");
}
#method_after
public String addDefaultConstructor(String modifier, String toAppend) throws IOException {
    if (getTypeTempFiles() != null) {
        return getTypeTempFiles().addDefaultConstructor(modifier, toAppend);
    }
    if (getBeanTempFiles() != null) {
        return getBeanTempFiles().addDefaultConstructor(modifier, toAppend);
    }
    throw new TranslatorException("default constructor should not be added");
}
#end_block

#method_before
public String addBuildMethodImpl() throws IOException {
    if (getBeanTempFiles() != null) {
        return getBeanTempFiles().addBuildMethodImpl();
    }
    throw new RuntimeException("build should not be added");
}
#method_after
public String addBuildMethodImpl() throws IOException {
    if (getBeanTempFiles() != null) {
        return getBeanTempFiles().addBuildMethodImpl();
    }
    throw new TranslatorException("build should not be added");
}
#end_block

#method_before
public void close(boolean isErrorOccurred) throws IOException {
    if (getBeanTempFiles() != null) {
        getBeanTempFiles().close(isErrorOccurred);
    }
    if (getTypeTempFiles() != null) {
        getTypeTempFiles().close(isErrorOccurred);
    }
}
#method_after
public void close(boolean isErrorOccurred) throws IOException {
    if (getBeanTempFiles() != null) {
        getBeanTempFiles().close(isErrorOccurred);
    }
    if (getTypeTempFiles() != null) {
        getTypeTempFiles().close(isErrorOccurred);
    }
    if (getEnumerationTempFiles() != null) {
        getEnumerationTempFiles().close(isErrorOccurred);
    }
}
#end_block

#method_before
@Test
public void processInputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("activate-software-imageInput"));
    ListIterator<YangLeaf> leafIterator = yangInput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangInput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#method_after
@Test
public void processInputStatementWithDataDefinition() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithDataDefinition.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("activate-software-image_input"));
    ListIterator<YangLeaf> leafIterator = yangInput.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("image-name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    YangList yangList = (YangList) yangInput.getChild();
    assertThat(yangList.getName(), is("ospf"));
    assertThat(yangList.getKeyList().contains("invalid-interval"), is(true));
    assertThat(yangList.isConfig(), is(true));
    assertThat(yangList.getMaxElements(), is(10));
    assertThat(yangList.getMinElements(), is(3));
    leafIterator = yangList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
    YangContainer yangContainer = (YangContainer) yangList.getNextSibling();
    assertThat(yangContainer.getName(), is("isis"));
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("uint16"));
}
#end_block

#method_before
@Test
public void processInputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("activate-software-imageInput"));
    YangTypeDef typeDef = (YangTypeDef) yangInput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#method_after
@Test
public void processInputStatementWithTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InputStatementWithTypedef.yang");
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("rock"));
    YangRpc yangRpc = (YangRpc) yangNode.getChild();
    assertThat(yangRpc.getName(), is("activate-software-image"));
    YangInput yangInput = (YangInput) yangRpc.getChild();
    assertThat(yangInput.getName(), is("activate-software-image_input"));
    YangTypeDef typeDef = (YangTypeDef) yangInput.getChild();
    assertThat(typeDef.getName(), is("my-type"));
    assertThat(typeDef.getStatus(), is(YangStatusType.DEPRECATED));
    assertThat(typeDef.getTypeDefBaseType().getDataType(), is(YangDataTypes.INT32));
}
#end_block

#method_before
private static String getGetter(String type, String name) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + type + SPACE + GET_METHOD_PREFIX + getCaptialCase(name) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + name + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
public static String getGetter(String type, String name) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + type + SPACE + GET_METHOD_PREFIX + getCaptialCase(name) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + name + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
private static String getReturnType(JavaAttributeInfo attr) {
    String returnType = EMPTY_STRING;
    if (attr.isQualifiedName() && (attr.getImportInfo().getPkgInfo() != null)) {
        returnType = attr.getImportInfo().getPkgInfo() + PERIOD;
    }
    returnType = returnType + attr.getImportInfo().getClassInfo();
    return returnType;
}
#method_after
private static String getReturnType(JavaAttributeInfo attr) {
    String returnType = EMPTY_STRING;
    if (attr.isQualifiedName() && attr.getImportInfo().getPkgInfo() != null) {
        returnType = attr.getImportInfo().getPkgInfo() + PERIOD;
    }
    returnType = returnType + attr.getImportInfo().getClassInfo();
    return returnType;
}
#end_block

#method_before
public static String getFromStringMethodSignature(String className) {
    return getJavaDoc(UNION_FROM_METHOD, className, false) + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + SPACE + FROM_STRING_METHOD_NAME + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#method_after
public static String getFromStringMethodSignature(String className) {
    return getJavaDoc(FROM_METHOD, className, false) + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + SPACE + FROM_STRING_METHOD_NAME + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    tunnelNameAsKeyStore = storageService.<TunnelName, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("tunnel_name_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    srcAndDstKeyStore = storageService.<TunnelKey, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("src_dst_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    typeKeyStore = storageService.<Tunnel.Type, Set<TunnelId>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    orderRelationship = storageService.<ApplicationId, Set<TunnelSubscription>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    idGenerator = coreService.getIdGenerator(tunnelOpTopic);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    tunnelIdAsKeyStore = storageService.<TunnelId, Tunnel>eventuallyConsistentMapBuilder().withName("all_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    orderRelationship = storageService.<ApplicationId, Set<TunnelSubscription>>eventuallyConsistentMapBuilder().withName("type_tunnel").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    idGenerator = coreService.getIdGenerator(tunnelOpTopic);
    tunnelIdAsKeyStore.addListener(tunnelUpdateListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    orderRelationship.destroy();
    tunnelIdAsKeyStore.destroy();
    srcAndDstKeyStore.destroy();
    typeKeyStore.destroy();
    tunnelNameAsKeyStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    tunnelIdAsKeyStore.removeListener(tunnelUpdateListener);
    orderRelationship.destroy();
    tunnelIdAsKeyStore.destroy();
    srcAndDstKeyMap.clear();
    typeKeyMap.clear();
    tunnelNameAsKeyMap.clear();
    log.info("Stopped");
}
#end_block

#method_before
private TunnelId handleCreateOrUpdateTunnel(Tunnel tunnel, State state) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null && !"".equals(tunnel.tunnelId().toString())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        if (old == null) {
            log.info("This tunnel[" + tunnel.tunnelId() + "] is not available.");
            return tunnel.tunnelId();
        }
        DefaultAnnotations oldAnno = (DefaultAnnotations) old.annotations();
        SparseAnnotations newAnno = (SparseAnnotations) tunnel.annotations();
        State newTunnelState = (state != null) ? state : old.state();
        Tunnel newT = new DefaultTunnel(old.providerId(), old.src(), old.dst(), old.type(), newTunnelState, old.groupId(), old.tunnelId(), old.tunnelName(), old.path(), DefaultAnnotations.merge(oldAnno, newAnno));
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
        return tunnel.tunnelId();
    } else {
        TunnelId tunnelId = TunnelId.valueOf(String.valueOf(idGenerator.getNewId()));
        State tunnelState = (state != null) ? state : tunnel.state();
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnelState, tunnel.groupId(), tunnelId, tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
        TunnelKey key = TunnelKey.tunnelKey(tunnel.src(), tunnel.dst());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        Set<TunnelId> tunnelnameSet = tunnelNameAsKeyStore.get(tunnel.tunnelName());
        if (tunnelnameSet == null) {
            tunnelnameSet = new HashSet<TunnelId>();
        }
        tunnelnameSet.add(tunnelId);
        tunnelNameAsKeyStore.put(tunnel.tunnelName(), tunnelnameSet);
        Set<TunnelId> srcAndDstKeySet = srcAndDstKeyStore.get(key);
        if (srcAndDstKeySet == null) {
            srcAndDstKeySet = new HashSet<TunnelId>();
        }
        srcAndDstKeySet.add(tunnelId);
        srcAndDstKeyStore.put(key, srcAndDstKeySet);
        Set<TunnelId> typeKeySet = typeKeyStore.get(tunnel.type());
        if (typeKeySet == null) {
            typeKeySet = new HashSet<TunnelId>();
        }
        typeKeySet.add(tunnelId);
        typeKeyStore.put(tunnel.type(), typeKeySet);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
        return tunnelId;
    }
}
#method_after
private TunnelId handleCreateOrUpdateTunnel(Tunnel tunnel, State state) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null && !"".equals(tunnel.tunnelId().toString())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        if (old == null) {
            log.info("This tunnel[" + tunnel.tunnelId() + "] is not available.");
            return tunnel.tunnelId();
        }
        DefaultAnnotations oldAnno = (DefaultAnnotations) old.annotations();
        SparseAnnotations newAnno = (SparseAnnotations) tunnel.annotations();
        State newTunnelState = (state != null) ? state : old.state();
        Tunnel newT = new DefaultTunnel(old.providerId(), old.src(), old.dst(), old.type(), newTunnelState, old.groupId(), old.tunnelId(), old.tunnelName(), old.path(), DefaultAnnotations.merge(oldAnno, newAnno));
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
        return tunnel.tunnelId();
    } else {
        TunnelId tunnelId = TunnelId.valueOf(String.valueOf(idGenerator.getNewId()));
        State tunnelState = (state != null) ? state : tunnel.state();
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnelState, tunnel.groupId(), tunnelId, tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
        return tunnelId;
    }
}
#end_block

#method_before
@Override
public void deleteTunnel(TunnelId tunnelId) {
    Tunnel deletedTunnel = tunnelIdAsKeyStore.get(tunnelId);
    if (deletedTunnel == null) {
        return;
    }
    tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).remove(tunnelId);
    if (tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).isEmpty()) {
        tunnelNameAsKeyStore.remove(deletedTunnel.tunnelName());
    }
    tunnelIdAsKeyStore.remove(tunnelId);
    TunnelKey key = new TunnelKey(deletedTunnel.src(), deletedTunnel.dst());
    srcAndDstKeyStore.get(key).remove(tunnelId);
    if (srcAndDstKeyStore.get(key).isEmpty()) {
        srcAndDstKeyStore.remove(key);
    }
    typeKeyStore.get(deletedTunnel.type()).remove(tunnelId);
    if (typeKeyStore.get(deletedTunnel.type()).isEmpty()) {
        typeKeyStore.remove(deletedTunnel.type());
    }
    TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
    notifyDelegate(event);
}
#method_after
@Override
public void deleteTunnel(TunnelId tunnelId) {
    Tunnel deletedTunnel = tunnelIdAsKeyStore.get(tunnelId);
    if (deletedTunnel == null) {
        return;
    }
    tunnelIdAsKeyStore.remove(tunnelId);
    TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
    notifyDelegate(event);
}
#end_block

#method_before
@Override
public void deleteTunnel(TunnelEndPoint src, TunnelEndPoint dst, ProviderId producerName) {
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyStore.get(key);
    if (idSet == null) {
        return;
    }
    Tunnel deletedTunnel = null;
    TunnelEvent event = null;
    List<TunnelEvent> ls = new ArrayList<TunnelEvent>();
    for (TunnelId id : idSet) {
        deletedTunnel = tunnelIdAsKeyStore.get(id);
        if (producerName == null || (producerName != null && producerName.equals(deletedTunnel.providerId()))) {
            tunnelIdAsKeyStore.remove(deletedTunnel.tunnelId());
            tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).remove(deletedTunnel.tunnelId());
            if (tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).isEmpty()) {
                tunnelNameAsKeyStore.remove(deletedTunnel.tunnelName());
            }
            srcAndDstKeyStore.get(key).remove(deletedTunnel.tunnelId());
            if (srcAndDstKeyStore.get(key).isEmpty()) {
                srcAndDstKeyStore.remove(key);
            }
            typeKeyStore.get(deletedTunnel.type()).remove(deletedTunnel.tunnelId());
            if (typeKeyStore.get(deletedTunnel.type()).isEmpty()) {
                typeKeyStore.remove(deletedTunnel.type());
            }
            event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
            ls.add(event);
        }
    }
    if (!ls.isEmpty()) {
        notifyDelegate(ls);
    }
}
#method_after
@Override
public void deleteTunnel(TunnelEndPoint src, TunnelEndPoint dst, ProviderId producerName) {
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyMap.get(key);
    if (idSet == null) {
        return;
    }
    Tunnel deletedTunnel = null;
    TunnelEvent event = null;
    List<TunnelEvent> ls = new ArrayList<TunnelEvent>();
    for (TunnelId id : idSet) {
        deletedTunnel = tunnelIdAsKeyStore.get(id);
        if (producerName == null || (producerName != null && producerName.equals(deletedTunnel.providerId()))) {
            tunnelIdAsKeyStore.remove(deletedTunnel.tunnelId());
            event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
            ls.add(event);
        }
    }
    if (!ls.isEmpty()) {
        notifyDelegate(ls);
    }
}
#end_block

#method_before
@Override
public void deleteTunnel(TunnelEndPoint src, TunnelEndPoint dst, Type type, ProviderId producerName) {
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyStore.get(key);
    if (idSet == null) {
        return;
    }
    Tunnel deletedTunnel = null;
    TunnelEvent event = null;
    List<TunnelEvent> ls = new ArrayList<TunnelEvent>();
    for (TunnelId id : idSet) {
        deletedTunnel = tunnelIdAsKeyStore.get(id);
        if (type.equals(deletedTunnel.type()) && (producerName == null || (producerName != null && producerName.equals(deletedTunnel.providerId())))) {
            tunnelIdAsKeyStore.remove(deletedTunnel.tunnelId());
            tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).remove(deletedTunnel.tunnelId());
            if (tunnelNameAsKeyStore.get(deletedTunnel.tunnelName()).isEmpty()) {
                tunnelNameAsKeyStore.remove(deletedTunnel.tunnelName());
            }
            srcAndDstKeyStore.get(key).remove(deletedTunnel.tunnelId());
            if (srcAndDstKeyStore.get(key).isEmpty()) {
                srcAndDstKeyStore.remove(key);
            }
            typeKeyStore.get(deletedTunnel.type()).remove(deletedTunnel.tunnelId());
            if (typeKeyStore.get(deletedTunnel.type()).isEmpty()) {
                typeKeyStore.remove(deletedTunnel.type());
            }
            event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
            ls.add(event);
        }
    }
    if (!ls.isEmpty()) {
        notifyDelegate(ls);
    }
}
#method_after
@Override
public void deleteTunnel(TunnelEndPoint src, TunnelEndPoint dst, Type type, ProviderId producerName) {
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyMap.get(key);
    if (idSet == null) {
        return;
    }
    Tunnel deletedTunnel = null;
    TunnelEvent event = null;
    List<TunnelEvent> ls = new ArrayList<TunnelEvent>();
    for (TunnelId id : idSet) {
        deletedTunnel = tunnelIdAsKeyStore.get(id);
        if (type.equals(deletedTunnel.type()) && (producerName == null || (producerName != null && producerName.equals(deletedTunnel.providerId())))) {
            tunnelIdAsKeyStore.remove(deletedTunnel.tunnelId());
            event = new TunnelEvent(TunnelEvent.Type.TUNNEL_REMOVED, deletedTunnel);
            ls.add(event);
        }
    }
    if (!ls.isEmpty()) {
        notifyDelegate(ls);
    }
}
#end_block

#method_before
@Override
public Collection<Tunnel> borrowTunnel(ApplicationId appId, TunnelEndPoint src, TunnelEndPoint dst, Annotations... annotations) {
    Set<TunnelSubscription> orderSet = orderRelationship.get(appId);
    if (orderSet == null) {
        orderSet = new HashSet<TunnelSubscription>();
    }
    TunnelSubscription order = new TunnelSubscription(appId, src, dst, null, null, null, annotations);
    boolean isExist = orderSet.contains(order);
    if (!isExist) {
        orderSet.add(order);
    }
    orderRelationship.put(appId, orderSet);
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyStore.get(key);
    if (idSet == null || idSet.size() == 0) {
        return Collections.emptySet();
    }
    Collection<Tunnel> tunnelSet = new HashSet<Tunnel>();
    for (TunnelId tunnelId : idSet) {
        Tunnel result = tunnelIdAsKeyStore.get(tunnelId);
        if (Tunnel.State.ACTIVE.equals(result.state())) {
            tunnelSet.add(result);
        }
    }
    return tunnelSet;
}
#method_after
@Override
public Collection<Tunnel> borrowTunnel(ApplicationId appId, TunnelEndPoint src, TunnelEndPoint dst, Annotations... annotations) {
    Set<TunnelSubscription> orderSet = orderRelationship.get(appId);
    if (orderSet == null) {
        orderSet = new HashSet<TunnelSubscription>();
    }
    TunnelSubscription order = new TunnelSubscription(appId, src, dst, null, null, null, annotations);
    boolean isExist = orderSet.contains(order);
    if (!isExist) {
        orderSet.add(order);
    }
    orderRelationship.put(appId, orderSet);
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyMap.get(key);
    if (idSet == null || idSet.size() == 0) {
        return Collections.emptySet();
    }
    Collection<Tunnel> tunnelSet = new HashSet<Tunnel>();
    for (TunnelId tunnelId : idSet) {
        Tunnel result = tunnelIdAsKeyStore.get(tunnelId);
        if (Tunnel.State.ACTIVE.equals(result.state())) {
            tunnelSet.add(result);
        }
    }
    return tunnelSet;
}
#end_block

#method_before
@Override
public Collection<Tunnel> borrowTunnel(ApplicationId appId, TunnelEndPoint src, TunnelEndPoint dst, Type type, Annotations... annotations) {
    Set<TunnelSubscription> orderSet = orderRelationship.get(appId);
    if (orderSet == null) {
        orderSet = new HashSet<TunnelSubscription>();
    }
    TunnelSubscription order = new TunnelSubscription(appId, src, dst, null, type, null, annotations);
    boolean isExist = orderSet.contains(order);
    if (!isExist) {
        orderSet.add(order);
    }
    orderRelationship.put(appId, orderSet);
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyStore.get(key);
    if (idSet == null || idSet.size() == 0) {
        return Collections.emptySet();
    }
    Collection<Tunnel> tunnelSet = new HashSet<Tunnel>();
    for (TunnelId tunnelId : idSet) {
        Tunnel result = tunnelIdAsKeyStore.get(tunnelId);
        if (type.equals(result.type()) && Tunnel.State.ACTIVE.equals(result.state())) {
            tunnelSet.add(result);
        }
    }
    return tunnelSet;
}
#method_after
@Override
public Collection<Tunnel> borrowTunnel(ApplicationId appId, TunnelEndPoint src, TunnelEndPoint dst, Type type, Annotations... annotations) {
    Set<TunnelSubscription> orderSet = orderRelationship.get(appId);
    if (orderSet == null) {
        orderSet = new HashSet<TunnelSubscription>();
    }
    TunnelSubscription order = new TunnelSubscription(appId, src, dst, null, type, null, annotations);
    boolean isExist = orderSet.contains(order);
    if (!isExist) {
        orderSet.add(order);
    }
    orderRelationship.put(appId, orderSet);
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> idSet = srcAndDstKeyMap.get(key);
    if (idSet == null || idSet.size() == 0) {
        return Collections.emptySet();
    }
    Collection<Tunnel> tunnelSet = new HashSet<Tunnel>();
    for (TunnelId tunnelId : idSet) {
        Tunnel result = tunnelIdAsKeyStore.get(tunnelId);
        if (type.equals(result.type()) && Tunnel.State.ACTIVE.equals(result.state())) {
            tunnelSet.add(result);
        }
    }
    return tunnelSet;
}
#end_block

#method_before
@Override
public Collection<Tunnel> borrowTunnel(ApplicationId appId, TunnelName tunnelName, Annotations... annotations) {
    Set<TunnelSubscription> orderSet = orderRelationship.get(appId);
    if (orderSet == null) {
        orderSet = new HashSet<TunnelSubscription>();
    }
    TunnelSubscription order = new TunnelSubscription(appId, null, null, null, null, tunnelName, annotations);
    boolean isExist = orderSet.contains(order);
    Set<TunnelId> idSet = tunnelNameAsKeyStore.get(tunnelName);
    if (idSet == null || idSet.size() == 0) {
        return Collections.emptySet();
    }
    Collection<Tunnel> tunnelSet = new HashSet<Tunnel>();
    for (TunnelId tunnelId : idSet) {
        Tunnel result = tunnelIdAsKeyStore.get(tunnelId);
        if (Tunnel.State.ACTIVE.equals(result.state())) {
            tunnelSet.add(result);
        }
    }
    if (!tunnelSet.isEmpty() && !isExist) {
        orderSet.add(order);
        orderRelationship.put(appId, orderSet);
    }
    return tunnelSet;
}
#method_after
@Override
public Collection<Tunnel> borrowTunnel(ApplicationId appId, TunnelName tunnelName, Annotations... annotations) {
    Set<TunnelSubscription> orderSet = orderRelationship.get(appId);
    if (orderSet == null) {
        orderSet = new HashSet<TunnelSubscription>();
    }
    TunnelSubscription order = new TunnelSubscription(appId, null, null, null, null, tunnelName, annotations);
    boolean isExist = orderSet.contains(order);
    Set<TunnelId> idSet = tunnelNameAsKeyMap.get(tunnelName);
    if (idSet == null || idSet.size() == 0) {
        return Collections.emptySet();
    }
    Collection<Tunnel> tunnelSet = new HashSet<Tunnel>();
    for (TunnelId tunnelId : idSet) {
        Tunnel result = tunnelIdAsKeyStore.get(tunnelId);
        if (Tunnel.State.ACTIVE.equals(result.state())) {
            tunnelSet.add(result);
        }
    }
    if (!tunnelSet.isEmpty() && !isExist) {
        orderSet.add(order);
        orderRelationship.put(appId, orderSet);
    }
    return tunnelSet;
}
#end_block

#method_before
@Override
public Collection<Tunnel> queryTunnel(Type type) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    Set<TunnelId> tunnelIds = typeKeyStore.get(type);
    if (tunnelIds == null) {
        return Collections.emptySet();
    }
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#method_after
@Override
public Collection<Tunnel> queryTunnel(Type type) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    Set<TunnelId> tunnelIds = typeKeyMap.get(type);
    if (tunnelIds == null) {
        return Collections.emptySet();
    }
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#end_block

#method_before
@Override
public Collection<Tunnel> queryTunnel(TunnelEndPoint src, TunnelEndPoint dst) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> tunnelIds = srcAndDstKeyStore.get(key);
    if (tunnelIds == null) {
        return Collections.emptySet();
    }
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#method_after
@Override
public Collection<Tunnel> queryTunnel(TunnelEndPoint src, TunnelEndPoint dst) {
    Collection<Tunnel> result = new HashSet<Tunnel>();
    TunnelKey key = TunnelKey.tunnelKey(src, dst);
    Set<TunnelId> tunnelIds = srcAndDstKeyMap.get(key);
    if (tunnelIds == null) {
        return Collections.emptySet();
    }
    for (TunnelId id : tunnelIds) {
        result.add(tunnelIdAsKeyStore.get(id));
    }
    return result.size() == 0 ? Collections.emptySet() : ImmutableSet.copyOf(result);
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    if (connectedSwitches.size() != 0) {
        cleanup();
    }
    cfgService.unregisterProperties(getClass(), false);
}
#method_after
@Deactivate
public void deactivate() {
    if (!connectedSwitches.isEmpty()) {
        cleanup();
    }
    cfgService.unregisterProperties(getClass(), false);
}
#end_block

#method_before
@Override
public ObjectNode encode(EventSubscriber data, CodecContext context) {
    checkNotNull(data, "Subscriber cannot be null");
    final ObjectNode result = context.mapper().createObjectNode().put(NAME, data.appName()).put(GROUP_ID, data.groupId()).put(EVENT_TYPE, data.eventType().toString());
    return result;
}
#method_after
@Override
public ObjectNode encode(EventSubscriber data, CodecContext context) {
    checkNotNull(data, "Subscriber cannot be null");
    return context.mapper().createObjectNode().put(NAME, data.appName()).put(GROUP_ID, data.subscriberGroupId().getId().toString()).put(EVENT_TYPE, data.eventType().toString());
}
#end_block

#method_before
@Override
public EventSubscriber decode(ObjectNode json, CodecContext context) {
    String name = json.path(NAME).asText();
    String topic = json.path(GROUP_ID).asText();
    String eventType = json.path(EVENT_TYPE).asText();
    return new EventSubscriber(name, topic, KafkaEvent.Type.valueOf(eventType));
}
#method_after
@Override
public EventSubscriber decode(ObjectNode json, CodecContext context) {
    String name = json.path(NAME).asText();
    String groupId = json.path(GROUP_ID).asText();
    EventSubscriberGroupId subscriberGroupId = new EventSubscriberGroupId(UUID.fromString(groupId));
    String eventType = json.path(EVENT_TYPE).asText();
    return new EventSubscriber(name, subscriberGroupId, Type.valueOf(eventType));
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    providerRegistry.unregister(this);
    providerService = null;
}
#method_after
@Deactivate
public void deactivate(ComponentContext context) {
    cfgService.unregisterProperties(getClass(), false);
    providerRegistry.unregister(this);
    providerService = null;
    log.info("Stopped");
}
#end_block

#method_before
private void applyRule(FlowRule flowRule) {
    flowRule.selector().criteria().forEach(c -> {
        // If Criterion type is MPLS_LABEL, push labels through PCEP client
        if (c.type() == Criterion.Type.MPLS_LABEL) {
            PcepClient pcc;
            Set<Resource> resources = resourceService.getRegisteredResources(Resources.discrete(flowRule.deviceId()).resource().id());
        /**
         * PCC client session is based on LSR ID, get the LSR ID for a specific device to
         *                             push the flows
         */
        // TODO: commented code has dependency with other patch
        /*  resources.forEach(res ->
                            if (res.isTypeOf(TeRouterId.class)) {
                                List<Ip4Address> lsrIds = res.valueAs(TeRouterId.class).get().teIds();
                                if (!lsrIds.isEmpty()) {
                                    lsrIds.forEach(id ->
                                    if (pcepController.getClient(PccId.pccId(id)) != null) {
                                        pcc = pcepController.getClient(PccId.pccId(lsrIds.iterator().next()))
                                    });
                                }
                            });*/
        // TODO: Build message and send the PCEP label message via PCEP client
        } else {
        // TODO: Get the BGP peer based on deviceId and send the message
        }
    });
}
#method_after
private void applyRule(FlowRule flowRule) {
    flowRule.selector().criteria().forEach(c -> {
        // If Criterion type is MPLS_LABEL, push labels through PCEP client
        if (c.type() == Criterion.Type.MPLS_LABEL) {
            PcepClient pcc;
        /**
         * PCC client session is based on LSR ID, get the LSR ID for a specific device to
         *                            push the flows
         */
        // TODO: commented code has dependency with other patch
        /*     Set<TeRouterId> lrsIds = resourceService.getAvailableResourceValues(Resources
                                    .discrete(flowRule.deviceId()).id(), TeRouterId.class);

                            lrsIds.forEach(lsrId ->
                            {
                                if (pcepController.getClient(PccId.pccId(lsrId)) != null) {
                                    pcc = pcepController.getClient(PccId.pccId(lsrId));
                                }
                            });*/
        // TODO: Build message and send the PCEP label message via PCEP client
        } else {
        // TODO: Get the BGP peer based on deviceId and send the message
        }
    });
}
#end_block

#method_before
private void removeRule(FlowRule flowRule) {
    flowRule.selector().criteria().forEach(c -> {
        // If Criterion type is MPLS_LABEL, remove the specified flow rules
        if (c.type() == Criterion.Type.MPLS_LABEL) {
            PcepClient pcc;
            Set<Resource> resources = resourceService.getRegisteredResources(Resources.discrete(flowRule.deviceId()).resource().id());
        /**
         * PCC client session is based on LSR ID, get the LSR ID for a specific device to
         *                     push the flows
         */
        // TODO: commented code has dependency with other patch
        /*  resources.forEach(res ->
                    if (res.isTypeOf(TeRouterId.class)) {
                        List<Ip4Address> lsrIds = res.valueAs(TeRouterId.class).get().teIds();
                        if (!lsrIds.isEmpty()) {
                            lsrIds.forEach(id ->
                            if (pcepController.getClient(PccId.pccId(id)) != null) {
                                pcc = pcepController.getClient(PccId.pccId(lsrIds.iterator().next()))
                            });
                        }
                    });*/
        // TODO: Build message and send the PCEP label message via PCEP client
        } else {
        // TODO: Get the BGP peer based on deviceId and send the message
        }
    });
}
#method_after
private void removeRule(FlowRule flowRule) {
    flowRule.selector().criteria().forEach(c -> {
        // If Criterion type is MPLS_LABEL, remove the specified flow rules
        if (c.type() == Criterion.Type.MPLS_LABEL) {
            PcepClient pcc;
        /**
         * PCC client session is based on LSR ID, get the LSR ID for a specific device to
         *                    push the flows
         */
        // TODO: commented code has dependency with other patch
        /*     Set<TeRouterId> lrsIds = resourceService.getAvailableResourceValues(Resources
                            .discrete(flowRule.deviceId()).id(), TeRouterId.class);

                    lrsIds.forEach(lsrId ->
                    {
                        if (pcepController.getClient(PccId.pccId(lsrId)) != null) {
                            pcc = pcepController.getClient(PccId.pccId(lsrId));
                        }
                    });*/
        // TODO: Build message and send the PCEP label message via PCEP client
        } else {
        // TODO: Get the BGP peer based on deviceId and send the message
        }
    });
}
#end_block

#method_before
public void readFrom(ChannelBuffer channelBuffer) {
    byte[] tempByteArray = new byte[IsisUtil.ID_PLUS_ONE_BYTE];
    channelBuffer.readBytes(tempByteArray, 0, IsisUtil.ID_PLUS_ONE_BYTE);
    this.setNeighborId(IsisUtil.systemIdPlus(tempByteArray));
    this.setMetric(channelBuffer.readUnsignedMedium());
    int nTlvPresent = channelBuffer.readByte();
    if (nTlvPresent > 0) {
        while (channelBuffer.readableBytes() > IsisUtil.TWO_BYTES) {
            TlvHeader tlvHeader = new TlvHeader();
            tlvHeader.setTlvType(channelBuffer.readByte());
            tlvHeader.setTlvLength(channelBuffer.readByte());
            SubTlvType tlvValue = SubTlvType.get(tlvHeader.tlvType());
            if (tlvValue != null) {
                this.addSubTlv(SubTlvFinder.findSubTlv(tlvHeader, channelBuffer.readBytes(tlvHeader.tlvLength())));
            } else {
                channelBuffer.readBytes(tlvHeader.tlvLength());
            }
        }
    }
}
#method_after
public void readFrom(ChannelBuffer channelBuffer) {
    byte[] tempByteArray = new byte[IsisUtil.ID_PLUS_ONE_BYTE];
    channelBuffer.readBytes(tempByteArray, 0, IsisUtil.ID_PLUS_ONE_BYTE);
    this.setNeighborId(IsisUtil.systemIdPlus(tempByteArray));
    this.setMetric(channelBuffer.readUnsignedMedium());
    int nTlvPresent = channelBuffer.readByte();
    if (nTlvPresent > 0) {
        while (channelBuffer.readableBytes() > IsisUtil.TWO_BYTES) {
            TlvHeader tlvHeader = new TlvHeader();
            tlvHeader.setTlvType(channelBuffer.readByte());
            tlvHeader.setTlvLength(channelBuffer.readByte());
            SubTlvType tlvValue = SubTlvType.get(tlvHeader.tlvType());
            int tlvLength = tlvHeader.tlvLength();
            if (tlvValue != null) {
                if (channelBuffer.readableBytes() >= tlvLength) {
                    this.addSubTlv(SubTlvFinder.findSubTlv(tlvHeader, channelBuffer.readBytes(tlvHeader.tlvLength())));
                }
            } else {
                if (channelBuffer.readableBytes() >= tlvLength) {
                    channelBuffer.readBytes(tlvLength);
                }
            }
        }
    }
}
#end_block

#method_before
@Activate
public void activate() {
    log.debug("IsisCfgProvider:activate");
    appId = coreService.registerApplication(PROVIDER_ID);
    configService.addListener(configListener);
    configRegistry.registerConfigFactory(configFactory);
    log.debug("Isis cfg service got started");
}
#method_after
@Activate
public void activate() {
    log.debug("Activate...!!!");
    appId = coreService.registerApplication(PROVIDER_ID);
    configService.addListener(configListener);
    configRegistry.registerConfigFactory(configFactory);
    log.debug("ISIS cfg service got started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    log.debug("IsisCfgProvider::deactivate...!!!");
    configRegistry.unregisterConfigFactory(configFactory);
    configService.removeListener(configListener);
}
#method_after
@Deactivate
public void deactivate() {
    log.debug("Deactivate...!!!");
    configRegistry.unregisterConfigFactory(configFactory);
    configService.removeListener(configListener);
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    log.debug("InternalConfigListener:: event is getting called");
    if (!event.configClass().equals(IsisAppConfig.class)) {
        return;
    }
    switch(event.type()) {
        case CONFIG_ADDED:
            updateConfig();
            break;
        case CONFIG_UPDATED:
            updateConfig();
            break;
        case CONFIG_REMOVED:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    log.debug("config event is getting called...!!!");
    if (!event.configClass().equals(IsisAppConfig.class)) {
        return;
    }
    switch(event.type()) {
        case CONFIG_ADDED:
            updateConfig();
            break;
        case CONFIG_UPDATED:
            updateConfig();
            break;
        case CONFIG_REMOVED:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Activate
public void activate() {
    log.debug("IsisTopologyProvider activated!!!");
}
#method_after
@Activate
public void activate() {
    log.debug("Activate...!!!");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    log.debug("IsisTopologyProvider deActivated!!!");
}
#method_after
@Deactivate
public void deactivate() {
    log.debug("Deactivate...!!!");
}
#end_block

#method_before
public void addLocalDevice(OspfLsa ospfLsa, OspfInterface ospfInterface, OspfArea ospfArea) {
    if (ospfLsa.getOspfLsaType().equals(OspfLsaType.ROUTER)) {
        // updateLinkInformation(ospfLsa);
        RouterLsa routerLsa = (RouterLsa) ospfLsa;
        List<OspfLsaLink> ospfLsaLinkList = routerLsa.routerLink();
        Iterator iterator = ospfLsaLinkList.iterator();
        Ip4Address advertisingRouterId = routerLsa.advertisingRouter();
        adRouterId = advertisingRouterId;
        DeviceInformation deviceInformation = new DeviceInformationImpl();
        DeviceInformation deviceInformationDr = new DeviceInformationImpl();
        while (iterator.hasNext()) {
            OspfLsaLink ospfLsaLink = (OspfLsaLink) iterator.next();
            Ip4Address linkId = Ip4Address.valueOf(ospfLsaLink.linkId());
            Ip4Address linkData = Ip4Address.valueOf(ospfLsaLink.linkData());
            if (ospfLsaLink.linkType() == 1) {
                if ((advertisingRouterId.equals(ospfArea.routerId())) || (linkId.equals(ospfArea.routerId()))) {
                    log.debug("OspfInterface information will not display in web ");
                } else {
                    deviceInformation.setAlreadyCreated(false);
                    deviceInformation.setDeviceId(linkId);
                    deviceInformation.setNeighborId(linkId);
                    deviceInformation.setRouterId(advertisingRouterId);
                    deviceInformation.addInterfaceId(linkData);
                    deviceInformation.setAreaId(ospfArea.areaId());
                    deviceInformation.setDr(false);
                    String key = "device:" + advertisingRouterId;
                    setDeviceInformationMap(key, deviceInformation);
                    String linkIdKey = "linkId:" + advertisingRouterId + "-" + linkId;
                    addLocalLink(linkIdKey, linkData, advertisingRouterId, linkId, true, false);
                }
            } else if (ospfLsaLink.linkType() == 2) {
                log.debug(" RouterId , NeighbourId, InterfaceId " + advertisingRouterId + " , " + linkId + " , " + linkData);
                if ((advertisingRouterId.equals(ospfArea.routerId())) || (linkId.equals(ospfArea.routerId()))) {
                    log.debug("OspfInterface information will not display in web ");
                } else {
                    if (linkId.equals(linkData)) {
                        if (drRouter.equals(Ip4Address.valueOf("0.0.0.0"))) {
                            log.debug("TopologyForDeviceAndLinkImpl::addLocalDevice" + "previous dr is empty");
                        } else {
                            if (drRouterOld.equals(linkId)) {
                                log.debug("TopologyForDeviceAndLinkImpl::addLocalDevice" + "previous dr is empty");
                            } else {
                                String key = "device:" + drRouterOld;
                                DeviceInformation deviceInformation1 = deviceInformation(key);
                                if (deviceInformation1 != null) {
                                    deviceInformation1.setAlreadyCreated(true);
                                    String linkIdKey = "linkId:" + linkId + "-" + deviceInformation1.neighborId();
                                    addLocalLink(linkIdKey, linkData, linkId, deviceInformation1.neighborId(), true, false);
                                } else {
                                    DeviceInformation deviceInformation2 = new DeviceInformationImpl();
                                    deviceInformation2.setAlreadyCreated(true);
                                    deviceInformation2.setDr(true);
                                    deviceInformation2.setRouterId(drRouterOld);
                                    deviceInformation2.setDeviceId(drRouterOld);
                                    deviceInformation2.setNeighborId(drRouterOld);
                                    setDeviceInformationMap(key, deviceInformation2);
                                }
                                String linkIdKey1 = "linkId:" + linkId + "-" + advertisingRouterId;
                                addLocalLink(linkIdKey1, linkData, linkId, advertisingRouterId, true, false);
                            }
                        }
                        drRouter = linkId;
                        drRouterOld = linkId;
                        deviceInformationDr.setAlreadyCreated(false);
                        deviceInformationDr.setDeviceId(linkId);
                        deviceInformationDr.setNeighborId(advertisingRouterId);
                        deviceInformationDr.setRouterId(linkId);
                        deviceInformationDr.addInterfaceId(linkData);
                        deviceInformationDr.setAreaId(ospfArea.areaId());
                        deviceInformationDr.setDr(true);
                        String key = "device:" + linkId;
                        setDeviceInformationMap(key, deviceInformationDr);
                        String key1 = "device:" + advertisingRouterId;
                        deviceInformation.setAlreadyCreated(false);
                        deviceInformation.setDeviceId(linkId);
                        deviceInformation.setNeighborId(advertisingRouterId);
                        deviceInformation.setRouterId(advertisingRouterId);
                        deviceInformation.addInterfaceId(linkData);
                        deviceInformation.setAreaId(ospfArea.areaId());
                        deviceInformation.setDr(false);
                        setDeviceInformationMap(key1, deviceInformation);
                        if (drRouter.equals(Ip4Address.valueOf("0.0.0.0"))) {
                            log.debug("Link will not get create since dr is not valid");
                            // Need to analysis since this place will not get Dr information
                            String linkIdKey = "linkId:" + linkId + "-" + advertisingRouterId;
                            addLocalLink(linkIdKey, linkData, linkId, advertisingRouterId, true, false);
                        } else {
                            String linkIdKey = "linkId:" + drRouter + "-" + advertisingRouterId;
                            addLocalLink(linkIdKey, linkData, drRouter, advertisingRouterId, true, false);
                        }
                    } else {
                        deviceInformation.setAlreadyCreated(false);
                        deviceInformation.setDeviceId(linkId);
                        deviceInformation.setNeighborId(linkId);
                        deviceInformation.setRouterId(advertisingRouterId);
                        deviceInformation.addInterfaceId(linkData);
                        deviceInformation.setAreaId(ospfArea.areaId());
                        deviceInformation.setDr(false);
                        String key = "device:" + advertisingRouterId;
                        setDeviceInformationMap(key, deviceInformation);
                        if (drRouter.equals(Ip4Address.valueOf("0.0.0.0"))) {
                            log.debug("Link will not get create since dr is not valid");
                            String linkIdKey = "linkId:" + linkId + "-" + advertisingRouterId;
                            addLocalLink(linkIdKey, linkData, linkId, advertisingRouterId, true, false);
                        } else {
                            String linkIdKey = "linkId:" + drRouter + "-" + advertisingRouterId;
                            addLocalLink(linkIdKey, linkData, drRouter, advertisingRouterId, true, false);
                        }
                    }
                }
            }
        }
    } else if (ospfLsa.getOspfLsaType().equals(OspfLsaType.NETWORK)) {
        NetworkLsa networkLsa = (NetworkLsa) ospfLsa;
        log.debug("It is Netowork Lsa: RouterId, LinkStateId" + networkLsa.advertisingRouter() + " , " + networkLsa.linkStateId());
    } else if (ospfLsa.getOspfLsaType().equals(OspfLsaType.AREA_LOCAL_OPAQUE_LSA)) {
        OspfLinkTed ospfLinkTed = new OspfLinkTedImpl();
        OpaqueLsa10 opaqueLsa10 = (OpaqueLsa10) ospfLsa;
        List<TopLevelTlv> topLevelTlvList = opaqueLsa10.topLevelValues();
        for (TopLevelTlv topLevelTlv : topLevelTlvList) {
            if (topLevelTlv instanceof LinkTlv) {
                LinkTlv linkTlv = (LinkTlv) topLevelTlv;
                List<LinkSubType> subTypes = linkTlv.subTlvList();
                for (LinkSubType type : subTypes) {
                    if (type instanceof UnreservedBandwidth) {
                        UnreservedBandwidth unreservedBandwidth = (UnreservedBandwidth) type;
                        List<Float> bandwidthFloatValues = unreservedBandwidth.getUnReservedBandwidthValue();
                        List<Bandwidth> bandwidthList = new ArrayList<>();
                        for (Float value : bandwidthFloatValues) {
                            Bandwidth bandwidth = Bandwidth.bps((double) value);
                            ospfLinkTed.setMaxUnResBandwidth(bandwidth);
                            bandwidthList.add(bandwidth);
                        }
                    }
                    if (type instanceof MaximumBandwidth) {
                        MaximumBandwidth maximumBandwidth = (MaximumBandwidth) type;
                        float maxBandValue = maximumBandwidth.getMaximumBandwidthValue();
                        Bandwidth bandwidth = Bandwidth.bps((double) maxBandValue);
                        ospfLinkTed.setMaximumLink(bandwidth);
                    }
                    if (type instanceof MaximumReservableBandwidth) {
                        MaximumReservableBandwidth maximumReservableBandwidth = (MaximumReservableBandwidth) type;
                        float maxResBandValue = maximumReservableBandwidth.getMaximumBandwidthValue();
                        Bandwidth bandwidth = Bandwidth.bps((double) maxResBandValue);
                        ospfLinkTed.setMaxReserved(bandwidth);
                    }
                    if (type instanceof TrafficEngineeringMetric) {
                        TrafficEngineeringMetric trafficEngineeringMetric = (TrafficEngineeringMetric) type;
                        long teMetric = trafficEngineeringMetric.getTrafficEngineeringMetricValue();
                        ospfLinkTed.setTeMetric((Integer) (int) teMetric);
                    }
                    if (type instanceof LocalInterfaceIpAddress) {
                        LocalInterfaceIpAddress localInterfaceIpAddress = (LocalInterfaceIpAddress) type;
                        List<String> stringValue = localInterfaceIpAddress.getLocalInterfaceIPAddress();
                        List<Ip4Address> localIp4Address = new ArrayList<>();
                        for (String value : stringValue) {
                            Ip4Address ip4Address = Ip4Address.valueOf(value);
                            localIp4Address.add(ip4Address);
                        }
                        ospfLinkTed.setIpv4LocRouterId(localIp4Address);
                    }
                    if (type instanceof RemoteInterfaceIpAddress) {
                        RemoteInterfaceIpAddress remoteInterfaceIpAddress = (RemoteInterfaceIpAddress) type;
                        List<String> stringValue = remoteInterfaceIpAddress.getRemoteInterfaceAddress();
                        List<Ip4Address> remoteIp4Address = new ArrayList<>();
                        for (String value : stringValue) {
                            Ip4Address ip4Address = Ip4Address.valueOf(value);
                            remoteIp4Address.add(ip4Address);
                        }
                        ospfLinkTed.setIpv4RemRouterId(remoteIp4Address);
                    }
                }
            }
        }
        ospfLinkTedHashMap.put(adRouterId.toString(), ospfLinkTed);
    }
}
#method_after
public void addLocalDevice(OspfLsa ospfLsa, OspfInterface ospfInterface, OspfArea ospfArea) {
    if (ospfLsa.getOspfLsaType().equals(OspfLsaType.ROUTER)) {
        createDeviceAndLinkFromRouterLsa(ospfLsa, ospfArea);
    } else if (ospfLsa.getOspfLsaType().equals(OspfLsaType.NETWORK)) {
        createDeviceAndLinkFromNetworkLsa(ospfLsa, ospfArea);
    } else if (ospfLsa.getOspfLsaType().equals(OspfLsaType.AREA_LOCAL_OPAQUE_LSA)) {
        createDeviceAndLinkFromOpaqueLsa(ospfLsa, ospfArea);
    }
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    checkAndRestablishSession();
    request = formatRequestMessageId(request);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request);
    messageIdInteger.incrementAndGet();
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request) throws NetconfException {
    checkAndRestablishSession();
    request = formatRequestMessageId(request);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request);
    messageIdInteger.incrementAndGet();
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context != null ? context.getProperties() : new Properties();
    int newNetconfReplyTimeout;
    try {
        String s = get(properties, PROP_NETCONF_REPLY_TIMEOUT);
        newNetconfReplyTimeout = isNullOrEmpty(s) ? netconfReplyTimeout : Integer.parseInt(s.trim());
    } catch (NumberFormatException e) {
        log.warn("Component configuration had invalid value", e);
        newNetconfReplyTimeout = netconfReplyTimeout;
    }
    netconfReplyTimeout = newNetconfReplyTimeout;
    log.info("Settings: {} = {}", PROP_NETCONF_REPLY_TIMEOUT, newNetconfReplyTimeout);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        netconfReplyTimeout = DEFAULT_REPLY_TIMEOUT_SECONDS;
        log.info("No component configuration");
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    int newNetconfReplyTimeout;
    try {
        String s = get(properties, PROP_NETCONF_REPLY_TIMEOUT);
        newNetconfReplyTimeout = isNullOrEmpty(s) ? netconfReplyTimeout : Integer.parseInt(s.trim());
    } catch (NumberFormatException e) {
        log.warn("Component configuration had invalid value", e);
        return;
    }
    netconfReplyTimeout = newNetconfReplyTimeout;
    log.info("Settings: {} = {}", PROP_NETCONF_REPLY_TIMEOUT, netconfReplyTimeout);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(opaqueInfo);
}
#method_after
@Override
public int hashCode() {
    return Arrays.hashCode(opaqueInfo);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(opaqueInfo);
}
#method_after
@Override
public int hashCode() {
    return Arrays.hashCode(opaqueInfo);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(opaqueInfo, topLevelValues);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(Arrays.hashCode(opaqueInfo), topLevelValues);
}
#end_block

#method_before
public void initializeInterfaceIpList() {
    for (IsisProcess process : processes) {
        for (IsisInterface isisInterface : process.isisInterfaceList()) {
            ((IsisInterfaceImpl) isisInterface).setAllConfiguredInterfaceIps(interfaceIps);
        }
    }
}
#method_after
public void initializeInterfaceIpList() {
    for (IsisProcess process : processes) {
        for (IsisInterface isisInterface : process.isisInterfaceList()) {
            ((DefaultIsisInterface) isisInterface).setAllConfiguredInterfaceIps(interfaceIps);
        }
    }
}
#end_block

#method_before
public void updateConfig(JsonNode jsonNode) throws Exception {
    log.debug("Controller::UpdateConfig called");
    byte[] configPacket = new byte[IsisConstants.CONFIG_LENGTH];
    // number of interfaces to configure
    byte numberOfInterface = 0;
    // its a conf packet - identifier
    configPacket[0] = (byte) 0xFF;
    List<IsisProcess> isisProcesses = getConfig(jsonNode);
    for (IsisProcess isisProcess : isisProcesses) {
        log.debug("IsisProcessDetails : " + isisProcess);
        for (IsisInterface isisInterface : isisProcess.isisInterfaceList()) {
            IsisInterfaceImpl isisInterfaceImpl = (IsisInterfaceImpl) isisInterface;
            log.debug("IsisInterfaceDetails : " + isisInterface);
            numberOfInterface++;
            configPacket[2 * numberOfInterface] = (byte) isisInterfaceImpl.interfaceIndex();
            if (isisInterface.networkType() == IsisNetworkType.BROADCAST && isisInterfaceImpl.reservedPacketCircuitType() == IsisRouterType.L1.value()) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 0;
            } else if (isisInterface.networkType() == IsisNetworkType.BROADCAST && isisInterfaceImpl.reservedPacketCircuitType() == IsisRouterType.L2.value()) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 1;
            } else if (isisInterface.networkType() == IsisNetworkType.P2P) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 2;
            } else if (isisInterface.networkType() == IsisNetworkType.BROADCAST && isisInterfaceImpl.reservedPacketCircuitType() == IsisRouterType.L1L2.value()) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 3;
            }
        }
    }
    configPacket[1] = numberOfInterface;
    // First time configuration
    if (processes == null) {
        processes = isisProcesses;
        // Initialize connection by creating a channel handler instance and sent the config packet);
        initConnection();
        // Initializing the interface map in channel handler
        isisChannelHandler.initializeInterfaceMap();
    } else {
        isisChannelHandler.updateInterfaceMap(isisProcesses);
    }
    // Send the config packet
    isisChannelHandler.sentConfigPacket(configPacket);
}
#method_after
public void updateConfig(JsonNode jsonNode) throws Exception {
    log.debug("Controller::UpdateConfig called");
    byte[] configPacket = new byte[IsisConstants.CONFIG_LENGTH];
    // number of interfaces to configure
    byte numberOfInterface = 0;
    // its a conf packet - identifier
    configPacket[0] = (byte) 0xFF;
    List<IsisProcess> isisProcesses = getConfig(jsonNode);
    for (IsisProcess isisProcess : isisProcesses) {
        log.debug("IsisProcessDetails : " + isisProcess);
        for (IsisInterface isisInterface : isisProcess.isisInterfaceList()) {
            DefaultIsisInterface isisInterfaceImpl = (DefaultIsisInterface) isisInterface;
            log.debug("IsisInterfaceDetails : " + isisInterface);
            numberOfInterface++;
            configPacket[2 * numberOfInterface] = (byte) isisInterfaceImpl.interfaceIndex();
            if (isisInterface.networkType() == IsisNetworkType.BROADCAST && isisInterfaceImpl.reservedPacketCircuitType() == IsisRouterType.L1.value()) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 0;
            } else if (isisInterface.networkType() == IsisNetworkType.BROADCAST && isisInterfaceImpl.reservedPacketCircuitType() == IsisRouterType.L2.value()) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 1;
            } else if (isisInterface.networkType() == IsisNetworkType.P2P) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 2;
            } else if (isisInterface.networkType() == IsisNetworkType.BROADCAST && isisInterfaceImpl.reservedPacketCircuitType() == IsisRouterType.L1L2.value()) {
                configPacket[(2 * numberOfInterface) + 1] = (byte) 3;
            }
        }
    }
    configPacket[1] = numberOfInterface;
    // First time configuration
    if (processes == null) {
        processes = isisProcesses;
        // Initialize connection by creating a channel handler instance and sent the config packet);
        initConnection();
        // Initializing the interface map in channel handler
        isisChannelHandler.initializeInterfaceMap();
    } else {
        isisChannelHandler.updateInterfaceMap(isisProcesses);
    }
    // Send the config packet
    isisChannelHandler.sentConfigPacket(configPacket);
}
#end_block

#method_before
private List<IsisProcess> getConfig(JsonNode json) throws Exception {
    List<IsisProcess> isisProcessesList = new ArrayList<>();
    JsonNode jsonNodes = json;
    if (jsonNodes == null) {
        return isisProcessesList;
    }
    jsonNodes.forEach(jsonNode -> {
        List<IsisInterface> interfaceList = new ArrayList<>();
        for (JsonNode jsonNode1 : jsonNode.path(IsisConstants.INTERFACE)) {
            IsisInterface isisInterface = new IsisInterfaceImpl();
            isisInterface.setInterfaceIndex(jsonNode1.path(IsisConstants.INTERFACEINDEX).asInt());
            isisInterface.setInterfaceIpAddress(Ip4Address.valueOf(jsonNode1.path(IsisConstants.INTERFACEIP).asText()));
            try {
                isisInterface.setNetworkMask(InetAddress.getByName((jsonNode1.path(IsisConstants.NETWORKMASK).asText())).getAddress());
            } catch (UnknownHostException e) {
                log.debug("Error:: Parsing network mask");
            }
            isisInterface.setInterfaceMacAddress(MacAddress.valueOf(jsonNode1.path(IsisConstants.MACADDRESS).asText()));
            isisInterface.setIntermediateSystemName(jsonNode1.path(IsisConstants.INTERMEDIATESYSTEMNAME).asText());
            isisInterface.setSystemId(jsonNode1.path(IsisConstants.SYSTEMID).asText());
            isisInterface.setReservedPacketCircuitType(jsonNode1.path(IsisConstants.RESERVEDPACKETCIRCUITTYPE).asInt());
            if (isisInterface.reservedPacketCircuitType() == IsisRouterType.L1.value()) {
                isisInterface.setL1LanId(jsonNode1.path(IsisConstants.LANID).asText());
            }
            isisInterface.setIdLength(jsonNode1.path(IsisConstants.IDLENGTH).asInt());
            isisInterface.setMaxAreaAddresses(jsonNode1.path(IsisConstants.MAXAREAADDRESSES).asInt());
            isisInterface.setNetworkType(IsisNetworkType.get(jsonNode1.path(IsisConstants.NETWORKTYPE).asInt()));
            isisInterface.setAreaAddress(jsonNode1.path(IsisConstants.AREAADDRESS).asText());
            isisInterface.setAreaLength(jsonNode1.path(IsisConstants.AREALENGTH).asInt());
            isisInterface.setLspId(jsonNode1.path(IsisConstants.LSPID).asText());
            isisInterface.setCircuitId(jsonNode1.path(IsisConstants.CIRCUITID).asText());
            isisInterface.setHoldingTime(jsonNode1.path(IsisConstants.HOLDINGTIME).asInt());
            isisInterface.setPriority(jsonNode1.path(IsisConstants.PRIORITY).asInt());
            isisInterface.setHelloInterval(jsonNode1.path(IsisConstants.HELLOINTERVAL).asInt());
            interfaceList.add(isisInterface);
        }
        IsisProcess process = new IsisProcessImpl();
        process.setProcessId(jsonNode.path(IsisConstants.PROCESSESID).asText());
        process.setIsisInterfaceList(interfaceList);
        isisProcessesList.add(process);
    });
    return isisProcessesList;
}
#method_after
private List<IsisProcess> getConfig(JsonNode json) throws Exception {
    List<IsisProcess> isisProcessesList = new ArrayList<>();
    JsonNode jsonNodes = json;
    if (jsonNodes == null) {
        return isisProcessesList;
    }
    jsonNodes.forEach(jsonNode -> {
        List<IsisInterface> interfaceList = new ArrayList<>();
        for (JsonNode jsonNode1 : jsonNode.path(IsisConstants.INTERFACE)) {
            IsisInterface isisInterface = new DefaultIsisInterface();
            isisInterface.setInterfaceIndex(jsonNode1.path(IsisConstants.INTERFACEINDEX).asInt());
            isisInterface.setInterfaceIpAddress(Ip4Address.valueOf(jsonNode1.path(IsisConstants.INTERFACEIP).asText()));
            try {
                isisInterface.setNetworkMask(InetAddress.getByName((jsonNode1.path(IsisConstants.NETWORKMASK).asText())).getAddress());
            } catch (UnknownHostException e) {
                log.debug("Error:: Parsing network mask");
            }
            isisInterface.setInterfaceMacAddress(MacAddress.valueOf(jsonNode1.path(IsisConstants.MACADDRESS).asText()));
            isisInterface.setIntermediateSystemName(jsonNode1.path(IsisConstants.INTERMEDIATESYSTEMNAME).asText());
            isisInterface.setSystemId(jsonNode1.path(IsisConstants.SYSTEMID).asText());
            isisInterface.setReservedPacketCircuitType(jsonNode1.path(IsisConstants.RESERVEDPACKETCIRCUITTYPE).asInt());
            if (isisInterface.reservedPacketCircuitType() == IsisRouterType.L1.value()) {
                isisInterface.setL1LanId(jsonNode1.path(IsisConstants.LANID).asText());
            }
            isisInterface.setIdLength(jsonNode1.path(IsisConstants.IDLENGTH).asInt());
            isisInterface.setMaxAreaAddresses(jsonNode1.path(IsisConstants.MAXAREAADDRESSES).asInt());
            isisInterface.setNetworkType(IsisNetworkType.get(jsonNode1.path(IsisConstants.NETWORKTYPE).asInt()));
            isisInterface.setAreaAddress(jsonNode1.path(IsisConstants.AREAADDRESS).asText());
            isisInterface.setAreaLength(jsonNode1.path(IsisConstants.AREALENGTH).asInt());
            isisInterface.setLspId(jsonNode1.path(IsisConstants.LSPID).asText());
            isisInterface.setCircuitId(jsonNode1.path(IsisConstants.CIRCUITID).asText());
            isisInterface.setHoldingTime(jsonNode1.path(IsisConstants.HOLDINGTIME).asInt());
            isisInterface.setPriority(jsonNode1.path(IsisConstants.PRIORITY).asInt());
            isisInterface.setHelloInterval(jsonNode1.path(IsisConstants.HELLOINTERVAL).asInt());
            interfaceList.add(isisInterface);
        }
        IsisProcess process = new DefaultIsisProcess();
        process.setProcessId(jsonNode.path(IsisConstants.PROCESSESID).asText());
        process.setIsisInterfaceList(interfaceList);
        isisProcessesList.add(process);
    });
    return isisProcessesList;
}
#end_block

#method_before
private void processRefreshLsp(LspWrapper wrapper) throws Exception {
    if (wrapper.isSelfOriginated()) {
        // self originated
        IsisInterfaceImpl isisInterface = (IsisInterfaceImpl) wrapper.isisInterface();
        Channel channel = isisInterface.channel();
        if (channel != null && channel.isConnected()) {
            LsPdu lsPdu = (LsPdu) wrapper.lsPdu();
            lsPdu.setSequenceNumber(isisInterface.isisLsdb().lsSequenceNumber(IsisPduType.get(lsPdu.pduType())));
            lsPdu.setRemainingLifeTime(IsisConstants.LSPMAXAGE);
            byte[] lspBytes = lsPdu.asBytes();
            lspBytes = IsisUtil.addLengthAndMarkItInReserved(lspBytes, IsisConstants.LENGTHPOSITION, IsisConstants.LENGTHPOSITION + 1, IsisConstants.RESERVEDPOSITION);
            lspBytes = IsisUtil.addChecksum(lspBytes, IsisConstants.CHECKSUMPOSITION, IsisConstants.CHECKSUMPOSITION + 1);
            // write to the channel
            channel.write(IsisUtil.framePacket(lspBytes, isisInterface.interfaceIndex()));
            log.debug("LSPQueueConsumer: processRefreshLsp - Flooded SelfOriginated LSP {}", wrapper.lsPdu());
        }
    }
}
#method_after
private void processRefreshLsp(LspWrapper wrapper) throws Exception {
    if (wrapper.isSelfOriginated()) {
        // self originated
        DefaultIsisInterface isisInterface = (DefaultIsisInterface) wrapper.isisInterface();
        Channel channel = isisInterface.channel();
        if (channel != null && channel.isConnected()) {
            LsPdu lsPdu = (LsPdu) wrapper.lsPdu();
            lsPdu.setSequenceNumber(isisInterface.isisLsdb().lsSequenceNumber(IsisPduType.get(lsPdu.pduType())));
            lsPdu.setRemainingLifeTime(IsisConstants.LSPMAXAGE);
            byte[] lspBytes = lsPdu.asBytes();
            lspBytes = IsisUtil.addLengthAndMarkItInReserved(lspBytes, IsisConstants.LENGTHPOSITION, IsisConstants.LENGTHPOSITION + 1, IsisConstants.RESERVEDPOSITION);
            lspBytes = IsisUtil.addChecksum(lspBytes, IsisConstants.CHECKSUMPOSITION, IsisConstants.CHECKSUMPOSITION + 1);
            // write to the channel
            channel.write(IsisUtil.framePacket(lspBytes, isisInterface.interfaceIndex()));
            log.debug("LSPQueueConsumer: processRefreshLsp - Flooded SelfOriginated LSP {}", wrapper.lsPdu());
        }
    }
}
#end_block

#method_before
private void processMaxAgeLsa(LspWrapper wrapper) {
    // set the destination
    IsisInterfaceImpl isisInterface = (IsisInterfaceImpl) wrapper.isisInterface();
    if (isisInterface != null) {
        // delete from db
        LsPdu lsPdu = (LsPdu) wrapper.lsPdu();
        IsisLsdb isisDb = isisInterface.isisLsdb();
        isisDb.deleteLsp(lsPdu);
        log.debug("LSPQueueConsumer: processMaxAgeLsp - Removed-Max Age LSP {}", wrapper.lsPdu());
    }
}
#method_after
private void processMaxAgeLsa(LspWrapper wrapper) {
    // set the destination
    DefaultIsisInterface isisInterface = (DefaultIsisInterface) wrapper.isisInterface();
    if (isisInterface != null) {
        // delete from db
        LsPdu lsPdu = (LsPdu) wrapper.lsPdu();
        IsisLsdb isisDb = isisInterface.isisLsdb();
        isisDb.deleteLsp(lsPdu);
        log.debug("LSPQueueConsumer: processMaxAgeLsp - Removed-Max Age LSP {}", wrapper.lsPdu());
    }
}
#end_block

#method_before
public static String generateClassDefinition(int genFileTypes, String yangName) {
    /**
     * based on the file type and the YANG name of the file, generate the
     * class / interface definition start.
     */
    if ((genFileTypes & INTERFACE_MASK) != 0) {
        return getInterfaceDefinition(yangName);
    } else if ((genFileTypes & BUILDER_CLASS_MASK) != 0) {
        return getBuilderClassDefinition(yangName);
    } else if ((genFileTypes & IMPL_CLASS_MASK) != 0) {
        return getImplClassDefinition(yangName);
    } else if ((genFileTypes & BUILDER_INTERFACE_MASK) != 0) {
        return getBuilderInterfaceDefinition(yangName);
    } else if ((genFileTypes & GENERATE_TYPEDEF_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_UNION_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    }
    return null;
}
#method_after
public static String generateClassDefinition(int genFileTypes, String yangName) {
    /**
     * Based on the file type and the YANG name of the file, generate the
     * class / interface definition start.
     */
    if ((genFileTypes & INTERFACE_MASK) != 0) {
        return getInterfaceDefinition(yangName);
    } else if ((genFileTypes & BUILDER_CLASS_MASK) != 0) {
        return getBuilderClassDefinition(yangName);
    } else if ((genFileTypes & IMPL_CLASS_MASK) != 0) {
        return getImplClassDefinition(yangName);
    } else if ((genFileTypes & BUILDER_INTERFACE_MASK) != 0) {
        return getBuilderInterfaceDefinition(yangName);
    } else if ((genFileTypes & GENERATE_TYPEDEF_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_UNION_CLASS) != 0) {
        return getTypeClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_ENUM_CLASS) != 0) {
        return getEnumClassDefinition(yangName);
    } else if ((genFileTypes & GENERATE_RPC_INTERFACE) != 0) {
        return getRpcInterfaceDefinition(yangName);
    }
    return null;
}
#end_block

#method_before
@Test
public void testGetCopyrightHeader() throws IOException {
    String baseDir = System.getProperty("basedir");
    String path = "/src/test/resources/CopyrightHeader.txt";
    String licenseHeader = getCopyrightHeader();
    File test = new File("target/TestCopyrightHeader.txt");
    FileWriter out = new FileWriter(test);
    out.write(licenseHeader);
    out.close();
    assertThat(true, is(contentEquals(test, new File(baseDir + path))));
}
#method_after
@Test
public void testGetCopyrightHeader() throws IOException {
    String path = "src/test/resources/CopyrightHeader.txt";
    File testRsc = new File(path);
    FileInputStream in = new FileInputStream(testRsc);
    File testFile = new File("target/TestHeader.txt");
    FileOutputStream out = new FileOutputStream(testFile);
    out.write(COPYRIGHTS_FIRST_LINE.getBytes());
    int c = 0;
    while ((c = in.read()) != -1) {
        out.write(c);
    }
    String licenseHeader = getCopyrightHeader();
    File test = new File("target/TestCopyrightHeader.txt");
    FileWriter writer = new FileWriter(test);
    writer.write(licenseHeader);
    writer.close();
    out.close();
    out.flush();
    in.close();
    assertThat(true, is(contentEquals(test, testFile)));
}
#end_block

#method_before
private static List<String> performOperationOnImports(List<String> imports, String curImport, boolean operation) {
    if (operation) {
        imports.add(curImport);
    } else {
        imports.remove(curImport);
    }
    java.util.Collections.sort(imports);
    return imports;
}
#method_after
private static List<String> performOperationOnImports(List<String> imports, String curImport, boolean operation) {
    if (operation) {
        imports.add(curImport);
    } else {
        imports.remove(curImport);
    }
    sort(imports);
    return imports;
}
#end_block

#method_before
@Override
public void resolve() {
    /*
       Inherit the Restriction from the referred typedef definition.
        */
    if (getDataType() != YangDataTypes.DERIVED) {
        throw new RuntimeException("Resolve should only be called for derrived data types");
    }
    YangDerivedInfo<?> derrivedInfo = (YangDerivedInfo<?>) getDataTypeExtendedInfo();
    YangType<?> baseType = derrivedInfo.getReferredTypeDef().getTypeDefBaseType();
    if (YangDataTypes.DERIVED == baseType.getDataType() && baseType.getResolvableStatus() == INTRA_FILE_RESOLVED) {
        setResolvableStatus(INTRA_FILE_RESOLVED);
    }
// TODO:
}
#method_after
@Override
public void resolve() throws DataModelException {
    /*
       Inherit the Restriction from the referred typedef definition.
        */
    if (getDataType() != DERIVED) {
        throw new DataModelException("Resolve should only be called for derived data types");
    }
    YangDerivedInfo<?> derrivedInfo = (YangDerivedInfo<?>) getDataTypeExtendedInfo();
    YangType<?> baseType = derrivedInfo.getReferredTypeDef().getTypeDefBaseType();
    if (DERIVED == baseType.getDataType() && baseType.getResolvableStatus() == INTRA_FILE_RESOLVED) {
        setResolvableStatus(INTRA_FILE_RESOLVED);
    }
// TODO:
}
#end_block

#method_before
private static String getGetter(String type, String name) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + type + SPACE + GET_METHOD_PREFIX + getCaptialCase(name) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + name + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#method_after
public static String getGetter(String type, String name) {
    return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + type + SPACE + GET_METHOD_PREFIX + getCaptialCase(name) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + name + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
}
#end_block

#method_before
public static String getFromStringMethodSignature(String className) {
    return getJavaDoc(UNION_FROM_METHOD, className, false) + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + SPACE + FROM_STRING_METHOD_NAME + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#method_after
public static String getFromStringMethodSignature(String className) {
    return getJavaDoc(FROM_METHOD, className, false) + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + SPACE + FROM_STRING_METHOD_NAME + OPEN_PARENTHESIS + STRING_DATA_TYPE + SPACE + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
public static void addPackageInfo(File path, String classInfo, String pack) throws IOException {
    if (pack.contains(ORG)) {
        String[] strArray = pack.split(ORG);
        pack = ORG + strArray[1];
    }
    try {
        File packageInfo = new File(path + SLASH + "package-info.java");
        packageInfo.createNewFile();
        FileWriter fileWriter = new FileWriter(packageInfo);
        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
        bufferedWriter.write(CopyrightHeader.getCopyrightHeader());
        bufferedWriter.write(JavaDocGen.getJavaDoc(PACKAGE_INFO, classInfo, false));
        bufferedWriter.write(PACKAGE + SPACE + pack + SEMI_COLAN);
        bufferedWriter.close();
        fileWriter.close();
    } catch (IOException e) {
        throw new IOException("Exception occured while creating package info file.");
    }
}
#method_after
public static void addPackageInfo(File path, String classInfo, String pack) throws IOException {
    if (pack.contains(ORG)) {
        String[] strArray = pack.split(ORG);
        pack = ORG + strArray[1];
    }
    try {
        File packageInfo = new File(path + SLASH + "package-info.java");
        packageInfo.createNewFile();
        FileWriter fileWriter = new FileWriter(packageInfo);
        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
        bufferedWriter.write(CopyrightHeader.getCopyrightHeader());
        bufferedWriter.write(getJavaDoc(PACKAGE_INFO, classInfo, false));
        bufferedWriter.write(PACKAGE + SPACE + pack + SEMI_COLAN);
        bufferedWriter.close();
        fileWriter.close();
    } catch (IOException e) {
        throw new IOException("Exception occured while creating package info file.");
    }
}
#end_block

#method_before
private void resolveTopOfStack() {
    ((Resolvable) getCurrentEntityToResolveFromStack()).resolve();
    if (((Resolvable) getCurrentEntityToResolveFromStack()).getResolvableStatus() != INTRA_FILE_RESOLVED) {
        // Sets the resolution status in inside the type/uses.
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(RESOLVED);
    }
}
#method_after
private void resolveTopOfStack() throws DataModelException {
    ((Resolvable) getCurrentEntityToResolveFromStack()).resolve();
    if (((Resolvable) getCurrentEntityToResolveFromStack()).getResolvableStatus() != INTRA_FILE_RESOLVED) {
        // Sets the resolution status in inside the type/uses.
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(RESOLVED);
    }
}
#end_block

#method_before
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), ENTRY);
    // Validate node identifier.
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), TYPE_DATA, ctx);
    // Obtain the YANG data type.
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    // Create YANG type object and fill the values.
    YangType<?> type = new YangType();
    type.setNodeIdentifier(nodeIdentifier);
    type.setDataType(yangDataTypes);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                type.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf list to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = type.getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addType(type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = type.getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, unionNode, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = type.getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, typeDef, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    // Push the type to the stack.
    listener.getParsedDataStack().push(type);
}
#method_after
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), ENTRY);
    // Validate node identifier.
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), TYPE_DATA, ctx);
    // Obtain the YANG data type.
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    // Create YANG type object and fill the values.
    YangType<?> type = new YangType();
    type.setNodeIdentifier(nodeIdentifier);
    type.setDataType(yangDataTypes);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                type.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf list to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addType(type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, unionNode, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, typeDef, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    // Push the type to the stack.
    listener.getParsedDataStack().push(type);
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(JavaIdentifierSyntax.getCamelCase(name, null));
    String javaDoc;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else if (type.equals(JavaDocType.TYPE_CONSTRUCTOR)) {
        javaDoc = generateForTypeConstructor(name);
    } else if (type.equals(JavaDocType.UNION_FROM_METHOD)) {
        javaDoc = generateForUnionFrom(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(getCamelCase(name, null));
    switch(type) {
        case IMPL_CLASS:
            {
                return generateForImplClass(name);
            }
        case BUILDER_CLASS:
            {
                return generateForBuilderClass(name);
            }
        case INTERFACE:
            {
                return generateForInterface(name);
            }
        case BUILDER_INTERFACE:
            {
                return generateForBuilderInterface(name);
            }
        case PACKAGE_INFO:
            {
                return generateForPackage(name);
            }
        case GETTER_METHOD:
            {
                return generateForGetters(name, isList);
            }
        case TYPE_DEF_SETTER_METHOD:
            {
                return generateForTypeDefSetter(name);
            }
        case SETTER_METHOD:
            {
                return generateForSetters(name, isList);
            }
        case OF_METHOD:
            {
                return generateForOf(name);
            }
        case DEFAULT_CONSTRUCTOR:
            {
                return generateForDefaultConstructors(name);
            }
        case BUILD_METHOD:
            {
                return generateForBuild(name);
            }
        case TYPE_CONSTRUCTOR:
            {
                return generateForTypeConstructor(name);
            }
        case FROM_METHOD:
            {
                return generateForFromString(name);
            }
        case ENUM_CLASS:
            {
                return generateForEnum(name);
            }
        case ENUM_ATTRIBUTE:
            {
                return generateForEnumAttr(name);
            }
        case RPC_INTERFACE:
            {
                return generateForRpcInterface(name);
            }
        default:
            {
                return generateForConstructors(name);
            }
    }
}
#end_block

#method_before
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, String pkg) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPlugin.getConflictResolver())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(pkg);
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
}
#method_after
public static void updatePackageInfo(HasJavaFileInfo hasJavaFileInfo, YangPluginConfig yangPlugin) throws IOException {
    hasJavaFileInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) hasJavaFileInfo).getName(), yangPlugin.getConflictResolver())));
    hasJavaFileInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) hasJavaFileInfo));
    hasJavaFileInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(hasJavaFileInfo.getJavaFileInfo().getPackage()));
    hasJavaFileInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
}
#end_block

#method_before
private static void updateLeafInfoInTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo);
    } else if (javaCodeGeneratorInfo instanceof HasType) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((HasType) javaCodeGeneratorInfo);
    } else {
    // TODO throw exception
    }
}
#method_after
private static void updateLeafInfoInTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo);
    } else if (javaCodeGeneratorInfo instanceof HasType) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addTypeInfoToTempFiles((HasType) javaCodeGeneratorInfo);
    } else if (javaCodeGeneratorInfo instanceof YangJavaEnumeration) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addEnumAttributeToTempFiles((YangNode) javaCodeGeneratorInfo);
    } else {
    // TODO throw exception
    }
}
#end_block

#method_before
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
    if (!(javaCodeGeneratorInfo instanceof YangCase)) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
    }
    /**
     * For augmentation of nodes.
     */
    if (javaCodeGeneratorInfo instanceof YangContainer || javaCodeGeneratorInfo instanceof YangCase || javaCodeGeneratorInfo instanceof YangChoice || javaCodeGeneratorInfo instanceof YangInput || javaCodeGeneratorInfo instanceof YangList || javaCodeGeneratorInfo instanceof YangNotification || javaCodeGeneratorInfo instanceof YangOutput) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(HAS_AUGMENTATION);
    } else if (javaCodeGeneratorInfo instanceof YangAugment) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(AUGMENTED_INFO);
    }
    if (javaCodeGeneratorInfo instanceof YangCase) {
        YangNode parent = ((YangCase) javaCodeGeneratorInfo).getParent();
        String curNodeName = ((YangCase) javaCodeGeneratorInfo).getName();
        if (!parent.getName().equals(curNodeName)) {
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(getCaptialCase(getCamelCase(parent.getName(), null)));
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addParentInfoInCurNodeTempFile((YangNode) javaCodeGeneratorInfo);
        } else {
            String parentPackage = ((HasJavaFileInfo) parent).getJavaFileInfo().getPackage();
            String caseExtendInfo = parentPackage + PERIOD + parent.getName();
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(caseExtendInfo);
        }
    }
}
#method_after
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo((HasJavaFileInfo) javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
    if (!(javaCodeGeneratorInfo instanceof YangCase)) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
    }
    /**
     * For augmentation of nodes.
     */
    if (javaCodeGeneratorInfo instanceof YangContainer || javaCodeGeneratorInfo instanceof YangCase || javaCodeGeneratorInfo instanceof YangChoice || javaCodeGeneratorInfo instanceof YangInput || javaCodeGeneratorInfo instanceof YangList || javaCodeGeneratorInfo instanceof YangNotification || javaCodeGeneratorInfo instanceof YangOutput) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(HAS_AUGMENTATION);
    } else if (javaCodeGeneratorInfo instanceof YangAugment) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(AUGMENTED_INFO);
    }
    if (javaCodeGeneratorInfo instanceof YangCase) {
        YangNode parent = ((YangCase) javaCodeGeneratorInfo).getParent();
        String curNodeName = ((YangCase) javaCodeGeneratorInfo).getName();
        if (!parent.getName().equals(curNodeName)) {
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(getCaptialCase(getCamelCase(parent.getName(), null)));
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addParentInfoInCurNodeTempFile((YangNode) javaCodeGeneratorInfo);
        } else {
            String parentPackage = ((HasJavaFileInfo) parent).getJavaFileInfo().getPackage();
            String caseExtendInfo = parentPackage + PERIOD + parent.getName();
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(caseExtendInfo);
        }
    }
}
#end_block

#method_before
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
    if (!(javaCodeGeneratorInfo instanceof YangCase)) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
    }
    /**
     * For augmentation of nodes.
     */
    if (javaCodeGeneratorInfo instanceof YangContainer || javaCodeGeneratorInfo instanceof YangCase || javaCodeGeneratorInfo instanceof YangChoice || javaCodeGeneratorInfo instanceof YangInput || javaCodeGeneratorInfo instanceof YangList || javaCodeGeneratorInfo instanceof YangNotification || javaCodeGeneratorInfo instanceof YangOutput) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(HAS_AUGMENTATION);
    } else if (javaCodeGeneratorInfo instanceof YangAugment) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(AUGMENTED_INFO);
    }
    if (javaCodeGeneratorInfo instanceof YangCase) {
        YangNode parent = ((YangCase) javaCodeGeneratorInfo).getParent();
        String curNodeName = ((YangCase) javaCodeGeneratorInfo).getName();
        if (!parent.getName().equals(curNodeName)) {
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(getCaptialCase(getCamelCase(parent.getName(), null)));
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addParentInfoInCurNodeTempFile((YangNode) javaCodeGeneratorInfo);
        } else {
            String parentPackage = ((HasJavaFileInfo) parent).getJavaFileInfo().getPackage();
            String caseExtendInfo = parentPackage + PERIOD + parent.getName();
            javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(caseExtendInfo);
        }
    }
}
#method_after
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo((HasJavaFileInfo) javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
}
#end_block

#method_before
private File getJavaFileHandle(String fileName) throws IOException {
    createPackage(absoluteDirPath, getJavaFileInfo().getJavaName());
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, getJavaFileInfo());
}
#method_after
private File getJavaFileHandle(String fileName) throws IOException {
    return getFileObject(getDirPath(), fileName, JAVA_FILE_EXTENSION, getJavaFileInfo());
}
#end_block

#method_before
private void addJavaSnippetInfoToApplicableTempFiles(YangNode hasType, JavaAttributeInfo javaAttributeInfo) throws IOException {
    JavaAttributeInfo fromStringAttributeInfo = getFromStringAttributeInfo(hasType, javaAttributeInfo);
    if ((generatedTempFiles & UNION_FROM_STRING_IMPL_MASK) != 0) {
        addUnionFromStringMethod(javaAttributeInfo, fromStringAttributeInfo);
    }
    addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#method_after
private void addJavaSnippetInfoToApplicableTempFiles(YangNode hasType, JavaAttributeInfo javaAttributeInfo) throws IOException {
    JavaAttributeInfo fromStringAttributeInfo = getFromStringAttributeInfo(hasType, javaAttributeInfo);
    if ((generatedTempFiles & FROM_STRING_IMPL_MASK) != 0) {
        addFromStringMethod(javaAttributeInfo, fromStringAttributeInfo);
    }
    addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#end_block

#method_before
private void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setNewAttrInfo(newAttrInfo);
    if (isAttributePresent) {
        if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
            addAttribute(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
            addGetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
            addSetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, generatedJavaFiles);
        }
        if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
            addSetterImpl(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
            addConstructor(newAttrInfo);
        }
        if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
            addHashCodeMethod(newAttrInfo);
        }
        if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
            addEqualsMethod(newAttrInfo);
        }
        if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
            addToStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(newAttrInfo);
        }
    }
}
#method_after
public void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo javaAttributeInfoOfInput, JavaAttributeInfo javaAttributeInfoOfOutput, String rpcName) throws IOException {
    if ((generatedTempFiles & RPC_IMPL_MASK) != 0) {
        addRpcString(javaAttributeInfoOfInput, javaAttributeInfoOfOutput, rpcName);
    }
}
#end_block

#method_before
private void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setNewAttrInfo(newAttrInfo);
    if (isAttributePresent) {
        if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
            addAttribute(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
            addGetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
            addSetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, generatedJavaFiles);
        }
        if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
            addSetterImpl(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
            addConstructor(newAttrInfo);
        }
        if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
            addHashCodeMethod(newAttrInfo);
        }
        if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
            addEqualsMethod(newAttrInfo);
        }
        if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
            addToStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(newAttrInfo);
        }
    }
}
#method_after
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setNewAttrInfo(newAttrInfo);
    if (isAttributePresent) {
        if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
            addAttribute(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
            addGetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
            addSetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, generatedJavaFiles);
        }
        if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
            addSetterImpl(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
            addConstructor(newAttrInfo);
        }
        if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
            addHashCodeMethod(newAttrInfo);
        }
        if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
            addEqualsMethod(newAttrInfo);
        }
        if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
            addToStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & ENUM_IMPL_MASK) != 0) {
            addAttributesForEnumClass(newAttrInfo);
        }
        if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(newAttrInfo);
        }
    }
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    setCurYangNode(curNode);
    List<String> imports = new ArrayList<>();
    if (curNode instanceof HasJavaImportData && isAttributePresent) {
        imports = ((HasJavaImportData) curNode).getJavaImportData().getImports(getNewAttrInfo());
    }
    /**
     * Prepares java file generator for extends list.
     */
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    /**
     * Generate java code.
     */
    if ((fileType & INTERFACE_MASK) != 0 | (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /**
         * Adds import for case.
         */
        if (curNode instanceof YangCase) {
            List<String> importData = ((HasJavaImportData) curNode).getJavaImportData().getImports();
            for (String importInfo : importData) {
                if (!imports.contains(importInfo)) {
                    imports.add(importInfo);
                }
            }
        }
        /**
         * Adds import for HasAugmentation class.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
        }
        /**
         * Create interface file.
         */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create builder interface file.
         */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append builder interface file to interface file and close it.
             */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, false);
        }
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 | (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isHasAugmentationExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        /**
         * Create builder class file.
         */
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create impl class file.
         */
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append impl class to builder class and close it.
             */
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    /**
     * Creates type def class file.
     */
    if ((fileType & GENERATE_TYPEDEF_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypedefClassJavaFileHandle(getJavaFileHandle(getJavaClassName(TYPEDEF_CLASS_FILE_NAME_SUFFIX)));
        setTypedefClassJavaFileHandle(generateTypeDefClassFile(getTypedefClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type class file.
     */
    if ((fileType & GENERATE_UNION_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypeClassJavaFileHandle(getJavaFileHandle(getJavaClassName(UNION_TYPE_CLASS_FILE_NAME_SUFFIX)));
        setTypeClassJavaFileHandle(generateUnionClassFile(getTypeClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Close all the file handles.
     */
    close(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    setCurYangNode(curNode);
    List<String> imports = new ArrayList<>();
    if (curNode instanceof HasJavaImportData && isAttributePresent) {
        imports = ((HasJavaImportData) curNode).getJavaImportData().getImports(getNewAttrInfo());
    }
    /**
     * Prepares java file generator for extends list.
     */
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    if (curNode.getNodeType().equals(MODULE_NODE)) {
        createPackage(absoluteDirPath, getJavaFileInfo().getJavaName());
    } else {
        createPackage(absoluteDirPath, ((HasJavaFileInfo) curNode.getParent()).getJavaFileInfo().getJavaName() + PACKAGE_INFO_JAVADOC_OF_CHILD);
    }
    /**
     * Generate java code.
     */
    if ((fileType & INTERFACE_MASK) != 0 | (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /**
         * Adds import for case.
         */
        if (curNode instanceof YangCase) {
            List<String> importData = ((HasJavaImportData) curNode).getJavaImportData().getImports();
            for (String importInfo : importData) {
                if (!imports.contains(importInfo)) {
                    imports.add(importInfo);
                }
            }
        }
        /**
         * Adds import for HasAugmentation class.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
        }
        /**
         * Create interface file.
         */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create builder interface file.
         */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append builder interface file to interface file and close it.
             */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, false);
        }
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 | (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isHasAugmentationExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        /**
         * Create builder class file.
         */
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create impl class file.
         */
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append impl class to builder class and close it.
             */
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    /**
     * Creates type def class file.
     */
    if ((fileType & GENERATE_TYPEDEF_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypedefClassJavaFileHandle(getJavaFileHandle(getJavaClassName(TYPEDEF_CLASS_FILE_NAME_SUFFIX)));
        setTypedefClassJavaFileHandle(generateTypeDefClassFile(getTypedefClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type class file.
     */
    if ((fileType & GENERATE_UNION_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypeClassJavaFileHandle(getJavaFileHandle(getJavaClassName(UNION_TYPE_CLASS_FILE_NAME_SUFFIX)));
        setTypeClassJavaFileHandle(generateUnionClassFile(getTypeClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type enum class file.
     */
    if ((fileType & GENERATE_ENUM_CLASS) != 0) {
        setEnumClassJavaFileHandle(getJavaFileHandle(getJavaClassName(ENUM_CLASS_FILE_NAME_SUFFIX)));
        setEnumClassJavaFileHandle(generateEnumClassFile(getEnumClassJavaFileHandle(), curNode));
    }
    /**
     * Creates rpc interface file.
     */
    if ((fileType & GENERATE_RPC_INTERFACE) != 0) {
        setRpcInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(RPC_INTERFACE_FILE_NAME_SUFFIX)));
        setRpcInterfaceJavaFileHandle(generateRpcInterfaceFile(getRpcInterfaceJavaFileHandle(), curNode, imports));
    }
    /**
     * Close all the file handles.
     */
    close(false);
}
#end_block

#method_before
public void close(boolean isErrorOccurred) throws IOException {
    boolean isError = isErrorOccurred;
    /**
     * Close all java file handles and when error occurs delete the files.
     */
    if ((generatedJavaFiles & INTERFACE_MASK) != 0) {
        closeFile(getInterfaceJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderClassJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & BUILDER_INTERFACE_MASK) != 0) {
        closeFile(getBuilderInterfaceJavaFileHandle(), true);
    }
    if ((generatedJavaFiles & IMPL_CLASS_MASK) != 0) {
        closeFile(getImplClassJavaFileHandle(), true);
    }
    if ((generatedJavaFiles & GENERATE_TYPEDEF_CLASS) != 0) {
        closeFile(getTypedefClassJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & GENERATE_UNION_CLASS) != 0) {
        closeFile(getTypeClassJavaFileHandle(), isError);
    }
    /**
     * Close all temporary file handles and delete the files.
     */
    if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getGetterInterfaceTempFileHandle(), true);
    }
    if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getGetterImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getSetterInterfaceTempFileHandle(), true);
    }
    if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getSetterImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
        closeFile(getConstructorImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
        closeFile(getAttributesTempFileHandle(), true);
    }
    if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
        closeFile(getHashCodeImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
        closeFile(getToStringImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
        closeFile(getEqualsImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        closeFile(getConstructorForTypeTempFileHandle(), true);
    }
    if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
        closeFile(getOfStringImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & UNION_FROM_STRING_IMPL_MASK) != 0) {
        closeFile(getUnionFromStringImplTempFileHandle(), true);
    }
    clean(getTempDirPath());
    generatedTempFiles = 0;
}
#method_after
public void close(boolean isErrorOccurred) throws IOException {
    boolean isError = isErrorOccurred;
    /**
     * Close all java file handles and when error occurs delete the files.
     */
    if ((generatedJavaFiles & INTERFACE_MASK) != 0) {
        closeFile(getInterfaceJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderClassJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & BUILDER_INTERFACE_MASK) != 0) {
        closeFile(getBuilderInterfaceJavaFileHandle(), true);
    }
    if ((generatedJavaFiles & IMPL_CLASS_MASK) != 0) {
        closeFile(getImplClassJavaFileHandle(), true);
    }
    if ((generatedJavaFiles & GENERATE_TYPEDEF_CLASS) != 0) {
        closeFile(getTypedefClassJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & GENERATE_ENUM_CLASS) != 0) {
        closeFile(getEnumClassJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & GENERATE_UNION_CLASS) != 0) {
        closeFile(getTypeClassJavaFileHandle(), isError);
    }
    if ((generatedJavaFiles & GENERATE_RPC_INTERFACE) != 0) {
        closeFile(getRpcInterfaceJavaFileHandle(), isError);
    }
    /**
     * Close all temporary file handles and delete the files.
     */
    if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getGetterInterfaceTempFileHandle(), true);
    }
    if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getGetterImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
        closeFile(getSetterInterfaceTempFileHandle(), true);
    }
    if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getSetterImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
        closeFile(getConstructorImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
        closeFile(getAttributesTempFileHandle(), true);
    }
    if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
        closeFile(getHashCodeImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
        closeFile(getToStringImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
        closeFile(getEqualsImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & ENUM_IMPL_MASK) != 0) {
        closeFile(getEnumClassTempFileHandle(), true);
    }
    if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
        closeFile(getConstructorForTypeTempFileHandle(), true);
    }
    if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
        closeFile(getOfStringImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & FROM_STRING_IMPL_MASK) != 0) {
        closeFile(getFromStringImplTempFileHandle(), true);
    }
    if ((generatedTempFiles & RPC_IMPL_MASK) != 0) {
        closeFile(getRpcInterfaceImplTempFileHandle(), true);
    }
    clean(getTempDirPath());
    generatedTempFiles = 0;
}
#end_block

#method_before
@Override
public void generateCodeExit() throws IOException {
    getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_MANAGER_WITH_RPC, this);
    return;
}
#method_after
@Override
public void generateCodeExit() throws IOException {
    getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_MANAGER_WITH_RPC, this);
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(getCamelCase(name, null));
    String javaDoc;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else if (type.equals(JavaDocType.TYPE_CONSTRUCTOR)) {
        javaDoc = generateForTypeConstructor(name);
    } else if (type.equals(JavaDocType.FROM_METHOD)) {
        javaDoc = generateForFromString(name);
    } else if (type.equals(JavaDocType.ENUM_CLASS)) {
        javaDoc = generateForEnum(name);
    } else if (type.equals(JavaDocType.ENUM_ATTRIBUTE)) {
        javaDoc = generateForEnumAttr(name);
    } else if (type.equals(JavaDocType.RPC_INTERFACE)) {
        javaDoc = generateForRpcInterface(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(getCamelCase(name, null));
    switch(type) {
        case IMPL_CLASS:
            {
                return generateForImplClass(name);
            }
        case BUILDER_CLASS:
            {
                return generateForBuilderClass(name);
            }
        case INTERFACE:
            {
                return generateForInterface(name);
            }
        case BUILDER_INTERFACE:
            {
                return generateForBuilderInterface(name);
            }
        case PACKAGE_INFO:
            {
                return generateForPackage(name);
            }
        case GETTER_METHOD:
            {
                return generateForGetters(name, isList);
            }
        case TYPE_DEF_SETTER_METHOD:
            {
                return generateForTypeDefSetter(name);
            }
        case SETTER_METHOD:
            {
                return generateForSetters(name, isList);
            }
        case OF_METHOD:
            {
                return generateForOf(name);
            }
        case DEFAULT_CONSTRUCTOR:
            {
                return generateForDefaultConstructors(name);
            }
        case BUILD_METHOD:
            {
                return generateForBuild(name);
            }
        case TYPE_CONSTRUCTOR:
            {
                return generateForTypeConstructor(name);
            }
        case FROM_METHOD:
            {
                return generateForFromString(name);
            }
        case ENUM_CLASS:
            {
                return generateForEnum(name);
            }
        case ENUM_ATTRIBUTE:
            {
                return generateForEnumAttr(name);
            }
        case RPC_INTERFACE:
            {
                return generateForRpcInterface(name);
            }
        default:
            {
                return generateForConstructors(name);
            }
    }
}
#end_block

#method_before
private static void validateSubStatementsCardinality(GeneratedYangParser.ContainerStatementContext ctx) {
    validateCardinalityMaxOne(ctx.presenceStatement(), PRESENCE_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.configStatement(), CONFIG_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.descriptionStatement(), DESCRIPTION_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.referenceStatement(), REFERENCE_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.statusStatement(), STATUS_DATA, CONTAINER_DATA, ctx.identifier().getText());
// TODO when, grouping, typedef.
}
#method_after
private static void validateSubStatementsCardinality(GeneratedYangParser.ContainerStatementContext ctx) {
    validateCardinalityMaxOne(ctx.presenceStatement(), PRESENCE_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.configStatement(), CONFIG_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.descriptionStatement(), DESCRIPTION_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.referenceStatement(), REFERENCE_DATA, CONTAINER_DATA, ctx.identifier().getText());
    validateCardinalityMaxOne(ctx.statusStatement(), STATUS_DATA, CONTAINER_DATA, ctx.identifier().getText());
// TODO validate 'when' cardinality
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(JavaIdentifierSyntax.getCamelCase(name));
    String javaDoc = UtilConstants.EMPTY_STRING;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else if (type.equals(JavaDocType.TYPE_CONSTRUCTOR)) {
        javaDoc = generateForTypeConstructor(name);
    } else if (type.equals(JavaDocType.UNION_FROM_METHOD)) {
        javaDoc = generateForUnionFrom(name);
    } else if (type.equals(JavaDocType.ENUM_CLASS)) {
        javaDoc = generateForEnum(name);
    } else if (type.equals(JavaDocType.ENUM_ATTRIBUTE)) {
        javaDoc = generateForEnumAttr(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(JavaIdentifierSyntax.getCamelCase(name, null));
    String javaDoc;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else if (type.equals(JavaDocType.TYPE_CONSTRUCTOR)) {
        javaDoc = generateForTypeConstructor(name);
    } else if (type.equals(JavaDocType.UNION_FROM_METHOD)) {
        javaDoc = generateForUnionFrom(name);
    } else if (type.equals(JavaDocType.ENUM_CLASS)) {
        javaDoc = generateForEnum(name);
    } else if (type.equals(JavaDocType.ENUM_ATTRIBUTE)) {
        javaDoc = generateForEnumAttr(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#end_block

#method_before
private String parseAttribute(JavaAttributeInfo attr) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(getSmallCase(attr.getAttributeName()));
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    }
}
#method_after
private String parseAttribute(JavaAttributeInfo attr) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(getSmallCase(attr.getAttributeName()), null);
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    }
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setNewAttrInfo(newAttrInfo);
    if (isAttributePresent) {
        if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
            addAttribute(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
            addGetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
            addSetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, generatedJavaFiles);
        }
        if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
            addSetterImpl(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
            addConstructor(newAttrInfo);
        }
        if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
            addHashCodeMethod(newAttrInfo);
        }
        if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
            addEqualsMethod(newAttrInfo);
        }
        if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
            addToStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & ENUM_IMPL_MASK) != 0) {
            addAttributesForEnumClass(newAttrInfo);
        }
        if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(newAttrInfo);
        }
    }
    return;
}
#method_after
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setNewAttrInfo(newAttrInfo);
    if (isAttributePresent) {
        if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
            addAttribute(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
            addGetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
            addSetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, generatedJavaFiles);
        }
        if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
            addSetterImpl(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
            addConstructor(newAttrInfo);
        }
        if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
            addHashCodeMethod(newAttrInfo);
        }
        if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
            addEqualsMethod(newAttrInfo);
        }
        if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
            addToStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & ENUM_IMPL_MASK) != 0) {
            addAttributesForEnumClass(newAttrInfo);
        }
        if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(newAttrInfo);
        }
    }
}
#end_block

#method_before
public static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + PARSE_BYTE;
        case INT16:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case INT64:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT8:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case UINT16:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case UINT32:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT64:
            return NEW + SPACE + BIG_INTEGER;
        case DECIMAL64:
        // TODO: DECIMAL64.
        case STRING:
            return EMPTY_STRING;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        case ENUMERATION:
        // TODO:ENUMERATION.
        case BITS:
        // TODO:BITS
        case BINARY:
        // TODO:BINARY
        case DERIVED:
            return targetDataType + PERIOD + OF;
        default:
            throw new TranslatorException("Given data type is not supported.");
    }
}
#method_after
public static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + PARSE_BYTE;
        case INT16:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case INT64:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT8:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case UINT16:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case UINT32:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT64:
            return NEW + SPACE + BIG_INTEGER;
        case DECIMAL64:
        // TODO: DECIMAL64.
        case STRING:
            return EMPTY_STRING;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        case ENUMERATION:
        // TODO:ENUMERATION.
        case BITS:
        // TODO:BITS
        case BINARY:
        // TODO:BINARY
        case DERIVED:
            return targetDataType + PERIOD + OF;
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCaptialCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName()));
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName()));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCaptialCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName()));
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
            // TODO:EMPTY
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName()));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
            default:
                return null;
        }
    }
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCaptialCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), null));
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCaptialCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), null));
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
            // TODO:EMPTY
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                return null;
        }
    }
}
#end_block

#method_before
private static String getPackageFromParent(YangNode parent) {
    if (!(parent instanceof HasJavaFileInfo)) {
        throw new TranslatorException("Invalid child node is being processed.");
    }
    JavaFileInfo parentInfo = ((HasJavaFileInfo) parent).getJavaFileInfo();
    return parentInfo.getPackage() + PERIOD + parentInfo.getJavaName().toLowerCase();
}
#method_after
private static String getPackageFromParent(YangNode parent) {
    if (!(parent instanceof HasJavaFileInfo)) {
        throw new TranslatorException("invalid child node is being processed.");
    }
    JavaFileInfo parentInfo = ((HasJavaFileInfo) parent).getJavaFileInfo();
    return parentInfo.getPackage() + PERIOD + parentInfo.getJavaName().toLowerCase();
}
#end_block

#method_before
private static String getPkgFromNameSpace(String nameSpace) {
    ArrayList<String> pkgArr = new ArrayList<String>();
    nameSpace = nameSpace.replace(QUOTES, EMPTY_STRING);
    String properNameSpace = nameSpace.replaceAll(REGEX_WITH_SPECIAL_CHAR, COLAN);
    String[] nameSpaceArr = properNameSpace.split(COLAN);
    for (String nameSpaceString : nameSpaceArr) {
        pkgArr.add(nameSpaceString);
    }
    return getPkgFrmArr(pkgArr);
}
#method_after
private static String getPkgFromNameSpace(String nameSpace) {
    ArrayList<String> pkgArr = new ArrayList<String>();
    nameSpace = nameSpace.replace(QUOTES, EMPTY_STRING);
    String properNameSpace = nameSpace.replaceAll(REGEX_WITH_ALL_SPECIAL_CHAR, COLAN);
    String[] nameSpaceArr = properNameSpace.split(COLAN);
    for (String nameSpaceString : nameSpaceArr) {
        pkgArr.add(nameSpaceString);
    }
    return getPkgFrmArr(pkgArr);
}
#end_block

#method_before
private static String getPkgFrmArr(ArrayList<String> pkgArr) {
    String pkg = EMPTY_STRING;
    int size = pkgArr.size();
    int i = 0;
    for (String member : pkgArr) {
        boolean presenceOfKeyword = JAVA_KEY_WORDS.contains(member);
        if (presenceOfKeyword || member.matches(REGEX_FOR_FIRST_DIGIT)) {
            member = UNDER_SCORE + member;
        }
        pkg = pkg + member;
        if (i != size - 1) {
            pkg = pkg + PERIOD;
        }
        i++;
    }
    return pkg;
}
#method_after
private static String getPkgFrmArr(ArrayList<String> pkgArr) {
    String pkg = EMPTY_STRING;
    int size = pkgArr.size();
    int i = 0;
    for (String member : pkgArr) {
        boolean presenceOfKeyword = JAVA_KEY_WORDS.contains(member);
        if (presenceOfKeyword || member.matches(REGEX_FOR_FIRST_DIGIT)) {
            member = YANG_AUTO_PREFIX + member;
        }
        pkg = pkg + member;
        if (i != size - 1) {
            pkg = pkg + PERIOD;
        }
        i++;
    }
    return pkg;
}
#end_block

#method_before
public static String getCamelCase(String yangIdentifier) {
    String[] strArray = yangIdentifier.split(HYPHEN);
    String camelCase = strArray[0];
    for (int i = 1; i < strArray.length; i++) {
        camelCase = camelCase + strArray[i].substring(0, 1).toUpperCase() + strArray[i].substring(1);
    }
    return camelCase;
}
#method_after
public static String getCamelCase(String yangIdentifier, YangToJavaNamingConflictUtil conflictResolver) {
    if (conflictResolver != null) {
        String replacementForHyphen = conflictResolver.getReplacementForHyphen();
        String replacementForPeriod = conflictResolver.getReplacementForPeriod();
        String replacementForUnderscore = conflictResolver.getReplacementForUnderscore();
        if (replacementForPeriod != null) {
            yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_PERIOD, PERIOD + replacementForPeriod.toLowerCase() + PERIOD);
        }
        if (replacementForUnderscore != null) {
            yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_UNDERSCORE, UNDER_SCORE + replacementForUnderscore.toLowerCase() + UNDER_SCORE);
        }
        if (replacementForHyphen != null) {
            yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_HYPHEN, HYPHEN + replacementForHyphen.toLowerCase() + HYPHEN);
        }
    }
    yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_IDENTIFIER_SPECIAL_CHAR, COLAN);
    String[] strArray = yangIdentifier.split(COLAN);
    if (strArray[0].isEmpty()) {
        List<String> stringArrangement = new ArrayList<String>();
        for (int i = 1; i < strArray.length; i++) {
            stringArrangement.add(strArray[i]);
        }
        strArray = stringArrangement.toArray(new String[stringArrangement.size()]);
    }
    return applyCamelCaseRule(strArray);
}
#end_block

#method_before
public static String getEnumJavaAttribute(String name) {
    String[] strArray = name.split(HYPHEN);
    String output = "";
    for (int i = 0; i < strArray.length; i++) {
        output = output + strArray[i];
        if (i > 0 && i < strArray.length - 1) {
            output = output + UNDER_SCORE;
        }
    }
    return output;
}
#method_after
public static String getEnumJavaAttribute(String name) {
    String[] strArray = name.split(HYPHEN);
    String output = EMPTY_STRING;
    for (int i = 0; i < strArray.length; i++) {
        output = output + strArray[i];
        if (i > 0 && i < strArray.length - 1) {
            output = output + UNDER_SCORE;
        }
    }
    return output;
}
#end_block

#method_before
private static JavaAttributeInfo getAttributeInfoForTheData(JavaQualifiedTypeInfo importInfo, String attributeName, YangType<?> attributeType, YangNode curNode, boolean isListAttribute) {
    JavaAttributeInfo newAttr = new JavaAttributeInfo();
    newAttr.setImportInfo(importInfo);
    newAttr.setIsQualifiedAccess(getIsQualifiedAccessOrAddToImportList(curNode, importInfo));
    newAttr.setAttributeName(getCamelCase(attributeName));
    newAttr.setListAttr(isListAttribute);
    newAttr.setImportInfo(importInfo);
    newAttr.setAttributeType(attributeType);
    return newAttr;
}
#method_after
private static JavaAttributeInfo getAttributeInfoForTheData(JavaQualifiedTypeInfo importInfo, String attributeName, YangType<?> attributeType, YangNode curNode, boolean isListAttribute) {
    JavaAttributeInfo newAttr = new JavaAttributeInfo();
    newAttr.setImportInfo(importInfo);
    newAttr.setIsQualifiedAccess(getIsQualifiedAccessOrAddToImportList(curNode, importInfo));
    newAttr.setAttributeName(getCamelCase(attributeName, null));
    newAttr.setListAttr(isListAttribute);
    newAttr.setImportInfo(importInfo);
    newAttr.setAttributeType(attributeType);
    return newAttr;
}
#end_block

#method_before
public static String getJavaClassDefStart(int genFileTypes, String yangName) {
    /*
         * get the camel case name for java class / interface.
         */
    yangName = getCamelCase(yangName);
    return generateClassDefinition(genFileTypes, yangName);
}
#method_after
public static String getJavaClassDefStart(int genFileTypes, String yangName) {
    /*
         * get the camel case name for java class / interface.
         */
    yangName = getCamelCase(yangName, null);
    return generateClassDefinition(genFileTypes, yangName);
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfType(this, codeGenDir, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfType(this, yangPlugin, false);
}
#end_block

#method_before
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, String pkg) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(pkg);
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(codeGenDir);
}
#method_after
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPlugin.getConflictResolver())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) javaCodeGeneratorInfo));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
}
#end_block

#method_before
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, codeGenDir);
    generateTempFiles(javaCodeGeneratorInfo, codeGenDir);
    javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
    /**
     * For augmentation of nodes.
     */
    if (javaCodeGeneratorInfo instanceof YangContainer || javaCodeGeneratorInfo instanceof YangCase || javaCodeGeneratorInfo instanceof YangChoice || javaCodeGeneratorInfo instanceof YangInput || javaCodeGeneratorInfo instanceof YangList || javaCodeGeneratorInfo instanceof YangNotification || javaCodeGeneratorInfo instanceof YangOutput) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(HAS_AUGMENTATION);
    } else if (javaCodeGeneratorInfo instanceof YangAugment) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(AUGMENTED_INFO);
    }
}
#method_after
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
    javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
    /**
     * For augmentation of nodes.
     */
    if (javaCodeGeneratorInfo instanceof YangContainer || javaCodeGeneratorInfo instanceof YangCase || javaCodeGeneratorInfo instanceof YangChoice || javaCodeGeneratorInfo instanceof YangInput || javaCodeGeneratorInfo instanceof YangList || javaCodeGeneratorInfo instanceof YangNotification || javaCodeGeneratorInfo instanceof YangOutput) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(HAS_AUGMENTATION);
    } else if (javaCodeGeneratorInfo instanceof YangAugment) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(AUGMENTED_INFO);
    }
}
#end_block

#method_before
public static void generateCodeOfType(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, codeGenDir);
    generateTempFiles(javaCodeGeneratorInfo, codeGenDir);
}
#method_after
public static void generateCodeOfType(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
}
#end_block

#method_before
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, String rootPkg) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, codeGenDir, rootPkg);
    generateTempFiles(javaCodeGeneratorInfo, codeGenDir);
}
#method_after
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, String rootPkg) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin, rootPkg);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
}
#end_block

#method_before
public static String getConstructor(String yangName, JavaAttributeInfo attr) {
    String attributeName = getSmallCase(attr.getAttributeName());
    String constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCaptialCase(getCamelCase(attributeName)) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    return constructor;
}
#method_after
public static String getConstructor(String yangName, JavaAttributeInfo attr) {
    String attributeName = getSmallCase(attr.getAttributeName());
    String constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, null) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCaptialCase(getCamelCase(attributeName, null)) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    return constructor;
}
#end_block

#method_before
public static String getRemoveAugmentationImpl() {
    String method = FOUR_SPACE_INDENTATION;
    method = method + getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + "remove" + AUGMENTATION + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_METHOD_PREFIX + AUGMENTED_INFO + LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + "clear" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return method;
}
#method_after
public static String getRemoveAugmentationImpl() {
    String method = FOUR_SPACE_INDENTATION;
    method = method + getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + "remove" + AUGMENTATION + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_METHOD_PREFIX + AUGMENTED_INFO + LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + CLEAR + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return method;
}
#end_block

#method_before
@Test
public void testCompiler() throws Exception {
    DeviceId deviceId = DeviceId.NONE;
    ApplicationId appId = new DefaultApplicationId(1, "test");
    int tableId = 0;
    MacAddress ethDstMac = MacAddress.valueOf(random.nextLong());
    MacAddress ethSrcMac = MacAddress.valueOf(random.nextLong());
    short ethType = (short) (0x0000FFFF & random.nextInt());
    short outPort = (short) random.nextInt(65);
    short inPort = (short) random.nextInt(65);
    int timeout = random.nextInt(100);
    int priority = random.nextInt(100);
    TrafficSelector matchInPort1 = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(inPort)).matchEthDst(ethDstMac).matchEthSrc(ethSrcMac).matchEthType(ethType).build();
    TrafficTreatment outPort2 = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(outPort)).build();
    FlowRule rule1 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    FlowRule rule2 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    Bmv2TableEntry entry1 = translator.translate(rule1);
    Bmv2TableEntry entry2 = translator.translate(rule1);
    // check equality, i.e. same rules must produce same entries
    new EqualsTester().addEqualityGroup(rule1, rule2).addEqualityGroup(entry1, entry2).testEquals();
    int numMatchParams = model.table(0).keys().size();
    // parse values stored in entry1
    Bmv2TernaryMatchParam inPortParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(0);
    Bmv2TernaryMatchParam ethDstParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(1);
    Bmv2TernaryMatchParam ethSrcParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(2);
    Bmv2TernaryMatchParam ethTypeParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(3);
    // check that the number of parameters in the entry is the same as the number of table keys
    assertThat("Incorrect number of match parameters", entry1.matchKey().matchParams().size(), is(equalTo(numMatchParams)));
    // check that values stored in entry are the same used for the flow rule
    assertThat("Incorrect inPort match param value", inPortParam.value().asReadOnlyBuffer().getShort(), is(equalTo(inPort)));
    assertThat("Incorrect ethDestMac match param value", ethDstParam.value().asArray(), is(equalTo(ethDstMac.toBytes())));
    assertThat("Incorrect ethSrcMac match param value", ethSrcParam.value().asArray(), is(equalTo(ethSrcMac.toBytes())));
    assertThat("Incorrect ethType match param value", ethTypeParam.value().asReadOnlyBuffer().getShort(), is(equalTo(ethType)));
    assertThat("Incorrect priority value", entry1.priority(), is(equalTo(rule1.priority())));
    assertThat("Incorrect timeout value", entry1.timeout(), is(equalTo((double) rule1.timeout())));
}
#method_after
@Test
public void testCompiler() throws Exception {
    DeviceId deviceId = DeviceId.NONE;
    ApplicationId appId = new DefaultApplicationId(1, "test");
    int tableId = 0;
    MacAddress ethDstMac = MacAddress.valueOf(random.nextLong());
    MacAddress ethSrcMac = MacAddress.valueOf(random.nextLong());
    short ethType = (short) (0x0000FFFF & random.nextInt());
    short outPort = (short) random.nextInt(65);
    short inPort = (short) random.nextInt(65);
    int timeout = random.nextInt(100);
    int priority = random.nextInt(100);
    TrafficSelector matchInPort1 = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(inPort)).matchEthDst(ethDstMac).matchEthSrc(ethSrcMac).matchEthType(ethType).build();
    TrafficTreatment outPort2 = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(outPort)).build();
    FlowRule rule1 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    FlowRule rule2 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    Bmv2TableEntry entry1 = translator.translate(rule1);
    Bmv2TableEntry entry2 = translator.translate(rule1);
    // check equality, i.e. same rules must produce same entries
    new EqualsTester().addEqualityGroup(rule1, rule2).addEqualityGroup(entry1, entry2).testEquals();
    int numMatchParams = model.table(0).keys().size();
    // parse values stored in entry1
    Bmv2TernaryMatchParam inPortParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(0);
    Bmv2TernaryMatchParam ethDstParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(1);
    Bmv2TernaryMatchParam ethSrcParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(2);
    Bmv2TernaryMatchParam ethTypeParam = (Bmv2TernaryMatchParam) entry1.matchKey().matchParams().get(3);
    double expectedTimeout = (double) (model.table(0).hasTimeouts() ? rule1.timeout() : -1);
    // check that the number of parameters in the entry is the same as the number of table keys
    assertThat("Incorrect number of match parameters", entry1.matchKey().matchParams().size(), is(equalTo(numMatchParams)));
    // check that values stored in entry are the same used for the flow rule
    assertThat("Incorrect inPort match param value", inPortParam.value().asReadOnlyBuffer().getShort(), is(equalTo(inPort)));
    assertThat("Incorrect ethDestMac match param value", ethDstParam.value().asArray(), is(equalTo(ethDstMac.toBytes())));
    assertThat("Incorrect ethSrcMac match param value", ethSrcParam.value().asArray(), is(equalTo(ethSrcMac.toBytes())));
    assertThat("Incorrect ethType match param value", ethTypeParam.value().asReadOnlyBuffer().getShort(), is(equalTo(ethType)));
    assertThat("Incorrect priority value", entry1.priority(), is(equalTo(rule1.priority())));
    assertThat("Incorrect timeout value", entry1.timeout(), is(equalTo(expectedTimeout)));
}
#end_block

#method_before
@Override
public Bmv2TableEntry translate(FlowRule rule) throws Bmv2FlowRuleTranslatorException {
    int tableId = rule.tableId();
    Bmv2ModelTable table = model.table(tableId);
    if (table == null) {
        throw new Bmv2FlowRuleTranslatorException("Unknown table ID: " + tableId);
    }
    /* Translate selector */
    TrafficSelector selector = rule.selector();
    Bmv2MatchKey bmv2MatchKey = null;
    // If selector has only 1 criterion of type extension, use that
    Criterion criterion = selector.getCriterion(Criterion.Type.EXTENSION);
    if (criterion != null) {
        if (selector.criteria().size() == 1) {
            bmv2MatchKey = getMatchKeyFromExtension((ExtensionCriterion) criterion);
        } else {
            throw new Bmv2FlowRuleTranslatorException("Unable to translate traffic selector, found multiple criteria " + "of which one is an extension: " + selector.toString());
        }
    }
    if (bmv2MatchKey == null) {
        // not an extension
        bmv2MatchKey = buildMatchKey(config, selector, table);
    }
    /* Translate treatment */
    TrafficTreatment treatment = rule.treatment();
    Bmv2Action bmv2Action = null;
    // If treatment has only 1 instruction of type extension, use that
    for (Instruction inst : treatment.allInstructions()) {
        if (inst.type() == Instruction.Type.EXTENSION) {
            if (treatment.allInstructions().size() == 1) {
                bmv2Action = getActionFromExtension((ExtensionInstructionWrapper) inst);
            } else {
                throw new Bmv2FlowRuleTranslatorException("Unable to translate traffic treatment, found multiple instructions " + "of which one is an extension: " + selector.toString());
            }
        }
    }
    if (bmv2Action == null) {
        // No extension, use config to build action
        bmv2Action = config.buildAction(treatment);
    }
    if (bmv2Action == null) {
        // Config returned null
        throw new Bmv2FlowRuleTranslatorException("Unable to translate treatment: " + treatment);
    }
    Bmv2TableEntry.Builder tableEntryBuilder = Bmv2TableEntry.builder();
    tableEntryBuilder.withTableName(table.name()).withPriority(rule.priority()).withMatchKey(bmv2MatchKey).withAction(bmv2Action);
    if (!rule.isPermanent()) {
        tableEntryBuilder.withTimeout((double) rule.timeout());
    }
    return tableEntryBuilder.build();
}
#method_after
@Override
public Bmv2TableEntry translate(FlowRule rule) throws Bmv2FlowRuleTranslatorException {
    int tableId = rule.tableId();
    Bmv2ModelTable table = model.table(tableId);
    if (table == null) {
        throw new Bmv2FlowRuleTranslatorException("Unknown table ID: " + tableId);
    }
    /* Translate selector */
    TrafficSelector selector = rule.selector();
    Bmv2MatchKey bmv2MatchKey = null;
    // If selector has only 1 criterion of type extension, use that
    Criterion criterion = selector.getCriterion(Criterion.Type.EXTENSION);
    if (criterion != null) {
        if (selector.criteria().size() == 1) {
            bmv2MatchKey = getMatchKeyFromExtension((ExtensionCriterion) criterion);
        } else {
            throw new Bmv2FlowRuleTranslatorException("Unable to translate traffic selector, found multiple " + "criteria of which one is an extension: " + selector.toString());
        }
    }
    if (bmv2MatchKey == null) {
        // not an extension
        bmv2MatchKey = buildMatchKey(config, selector, table);
    }
    /* Translate treatment */
    TrafficTreatment treatment = rule.treatment();
    Bmv2Action bmv2Action = null;
    // If treatment has only 1 instruction of type extension, use that
    for (Instruction inst : treatment.allInstructions()) {
        if (inst.type() == Instruction.Type.EXTENSION) {
            if (treatment.allInstructions().size() == 1) {
                bmv2Action = getActionFromExtension((ExtensionInstructionWrapper) inst);
            } else {
                throw new Bmv2FlowRuleTranslatorException("Unable to translate traffic treatment, found multiple " + "instructions of which one is an extension: " + selector.toString());
            }
        }
    }
    if (bmv2Action == null) {
        // No extension, use config to build action
        bmv2Action = config.buildAction(treatment);
    }
    if (bmv2Action == null) {
        // Config returned null
        throw new Bmv2FlowRuleTranslatorException("Unable to translate treatment: " + treatment);
    }
    Bmv2TableEntry.Builder tableEntryBuilder = Bmv2TableEntry.builder();
    tableEntryBuilder.withTableName(table.name()).withPriority(rule.priority()).withMatchKey(bmv2MatchKey).withAction(bmv2Action);
    if (!rule.isPermanent()) {
        if (table.hasTimeouts()) {
            tableEntryBuilder.withTimeout((double) rule.timeout());
        }
    // FIXME: add warn log or exception?
    }
    return tableEntryBuilder.build();
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    return Collections.unmodifiableCollection(deviceFlowEntriesMap.values());
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    return Collections.unmodifiableCollection(deviceEntriesMap.values());
}
#end_block

#method_before
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    Bmv2ThriftClient device;
    try {
        device = new Bmv2ThriftClient(handler().data().deviceId());
    } catch (Bmv2Exception e) {
        log.error("Failed to connect to Bmv2 device", e);
        return Collections.emptyList();
    }
    List<FlowRule> appliedFlowRules = Lists.newArrayList();
    for (FlowRule rule : rules) {
        Bmv2TableEntry entry;
        try {
            entry = parseFlowRule(rule);
        } catch (IllegalStateException e) {
            log.error("Unable to parse flow rule", e);
            continue;
        }
        // Instantiate flowrule set for table if it does not exists
        if (!tableFlowRulesMap.containsKey(rule.tableId())) {
            tableFlowRulesMap.put(rule.tableId(), Sets.newHashSet());
        }
        if (tableFlowRulesMap.get(rule.tableId()).contains(rule)) {
            /* Rule is already installed in the table */
            long entryId = tableEntryIdsMap.get(rule);
            try {
                device.modifyTableEntry(0, entry.tableName(), entryId, entry.action());
                // replace already stored rule, as treatment, priority, etc. might have changed
                // Java Set doesn't replace on add
                tableFlowRulesMap.get(rule.tableId()).remove(rule);
                tableFlowRulesMap.get(rule.tableId()).add(rule);
                tableEntryIdsMap.put(rule, entryId);
                deviceFlowEntriesMap.put(rule, new DefaultFlowEntry(rule, FlowEntry.FlowEntryState.ADDED, 0, 0, 0));
            } catch (Bmv2Exception e) {
                log.error("Unable to update flow rule", e);
                continue;
            }
        } else {
            /* Rule is new */
            try {
                long entryId = device.addTableEntry(0, entry);
                tableFlowRulesMap.get(rule.tableId()).add(rule);
                tableEntryIdsMap.put(rule, entryId);
                deviceFlowEntriesMap.put(rule, new DefaultFlowEntry(rule, FlowEntry.FlowEntryState.ADDED, 0, 0, 0));
            } catch (Bmv2Exception e) {
                log.error("Unable to add flow rule", e);
                continue;
            }
        }
        appliedFlowRules.add(rule);
    }
    return Collections.unmodifiableCollection(appliedFlowRules);
}
#method_after
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    Bmv2ThriftClient deviceClient;
    try {
        deviceClient = getDeviceClient();
    } catch (Bmv2Exception e) {
        return Collections.emptyList();
    }
    List<FlowRule> appliedFlowRules = Lists.newArrayList();
    for (FlowRule rule : rules) {
        Bmv2TableEntry entry;
        try {
            entry = parseFlowRule(rule);
        } catch (IllegalStateException e) {
            log.error("Unable to parse flow rule", e);
            continue;
        }
        // Instantiate flowrule set for table if it does not exist
        if (!tableRulesMap.containsKey(rule.tableId())) {
            tableRulesMap.put(rule.tableId(), Sets.newHashSet());
        }
        if (tableRulesMap.get(rule.tableId()).contains(rule)) {
            /* Rule is already installed in the table */
            long entryId = tableEntryIdsMap.get(rule);
            try {
                deviceClient.modifyTableEntry(entry.tableName(), entryId, entry.action());
                // Replace stored rule as treatment, etc. might have changed
                // Java Set doesn't replace on add, remove first
                tableRulesMap.get(rule.tableId()).remove(rule);
                tableRulesMap.get(rule.tableId()).add(rule);
                tableEntryIdsMap.put(rule, entryId);
                deviceEntriesMap.put(rule, new DefaultFlowEntry(rule, FlowEntry.FlowEntryState.ADDED, 0, 0, 0));
            } catch (Bmv2Exception e) {
                log.error("Unable to update flow rule", e);
                continue;
            }
        } else {
            /* Rule is new */
            try {
                long entryId = deviceClient.addTableEntry(entry);
                tableRulesMap.get(rule.tableId()).add(rule);
                tableEntryIdsMap.put(rule, entryId);
                deviceEntriesMap.put(rule, new DefaultFlowEntry(rule, FlowEntry.FlowEntryState.ADDED, 0, 0, 0));
            } catch (Bmv2Exception e) {
                log.error("Unable to add flow rule", e);
                continue;
            }
        }
        appliedFlowRules.add(rule);
    }
    return Collections.unmodifiableCollection(appliedFlowRules);
}
#end_block

#method_before
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    Bmv2ThriftClient device;
    try {
        device = new Bmv2ThriftClient(handler().data().deviceId());
    } catch (Bmv2Exception e) {
        log.error("Failed to connect to Bmv2 device", e);
        return Collections.emptyList();
    }
    List<FlowRule> removedFlowRules = Lists.newArrayList();
    for (FlowRule rule : rules) {
        if (tableEntryIdsMap.containsKey(rule)) {
            long entryId = tableEntryIdsMap.get(rule);
            String tableName = parseTableName(rule.tableId());
            try {
                device.deleteTableEntry(0, tableName, entryId);
            } catch (Bmv2Exception e) {
                log.error("Unable to delete flow rule", e);
                continue;
            }
            /* remove from local store */
            tableEntryIdsMap.remove(rule);
            tableFlowRulesMap.get(rule.tableId()).remove(rule);
            deviceFlowEntriesMap.remove(rule);
            removedFlowRules.add(rule);
        }
    }
    return Collections.unmodifiableCollection(removedFlowRules);
}
#method_after
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rules) {
    Bmv2ThriftClient deviceClient;
    try {
        deviceClient = getDeviceClient();
    } catch (Bmv2Exception e) {
        return Collections.emptyList();
    }
    List<FlowRule> removedFlowRules = Lists.newArrayList();
    for (FlowRule rule : rules) {
        if (tableEntryIdsMap.containsKey(rule)) {
            long entryId = tableEntryIdsMap.get(rule);
            String tableName = parseTableName(rule.tableId());
            try {
                deviceClient.deleteTableEntry(tableName, entryId);
            } catch (Bmv2Exception e) {
                log.error("Unable to delete flow rule", e);
                continue;
            }
            /* remove from local store */
            tableEntryIdsMap.remove(rule);
            tableRulesMap.get(rule.tableId()).remove(rule);
            deviceEntriesMap.remove(rule);
            removedFlowRules.add(rule);
        }
    }
    return Collections.unmodifiableCollection(removedFlowRules);
}
#end_block

#method_before
public List<BmMatchParam> bmMatchParams() {
    return Collections.unmodifiableList(matchParams);
}
#method_after
public final List<BmMatchParam> bmMatchParams() {
    return Collections.unmodifiableList(matchParams);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hashCode(matchParams);
}
#method_after
@Override
public final int hashCode() {
    return Objects.hashCode(matchParams);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final Bmv2MatchKey other = (Bmv2MatchKey) obj;
    return Objects.equals(this.matchParams, other.matchParams);
}
#method_after
@Override
public final boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final Bmv2MatchKey other = (Bmv2MatchKey) obj;
    return Objects.equals(this.matchParams, other.matchParams);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).addValue(matchParams).toString();
}
#method_after
@Override
public final String toString() {
    return MoreObjects.toStringHelper(this).addValue(matchParams).toString();
}
#end_block

#method_before
public long addTableEntry(int contextId, Bmv2TableEntry entry) throws Bmv2Exception {
    try {
        BmAddEntryOptions options = new BmAddEntryOptions();
        if (entry.hasPriority()) {
            options.setPriority(entry.priority());
        }
        long entryId = stdClient.bm_mt_add_entry(contextId, entry.tableName(), entry.matchKey().bmMatchParams(), entry.action().name(), entry.action().parameters(), options);
        // FIXME: what if bm_mt_set_entry_ttl is not successful (i.e. no timeouts support)? Should we keep the entry or remove it?
        if (entry.hasTimeout()) {
            /* bmv2 accepts timeouts in milliseconds */
            int msTimeout = (int) Math.round(entry.timeout() * 1_000);
            stdClient.bm_mt_set_entry_ttl(contextId, entry.tableName(), entryId, msTimeout);
        }
        return entryId;
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#method_after
public final long addTableEntry(Bmv2TableEntry entry) throws Bmv2Exception {
    long entryId = -1;
    try {
        BmAddEntryOptions options = new BmAddEntryOptions();
        if (entry.hasPriority()) {
            options.setPriority(entry.priority());
        }
        entryId = stdClient.bm_mt_add_entry(CONTEXT_ID, entry.tableName(), entry.matchKey().bmMatchParams(), entry.action().name(), entry.action().parameters(), options);
        if (entry.hasTimeout()) {
            /* bmv2 accepts timeouts in milliseconds */
            int msTimeout = (int) Math.round(entry.timeout() * 1_000);
            stdClient.bm_mt_set_entry_ttl(CONTEXT_ID, entry.tableName(), entryId, msTimeout);
        }
        return entryId;
    } catch (TException e) {
        if (entryId != -1) {
            try {
                stdClient.bm_mt_delete_entry(CONTEXT_ID, entry.tableName(), entryId);
            } catch (TException e1) {
                // this should never happen as we know the entry is there
                throw new Bmv2Exception(e1.getMessage(), e1);
            }
        }
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#end_block

#method_before
public void modifyTableEntry(int contextId, String tableName, long entryId, Bmv2Action action) throws Bmv2Exception {
    try {
        stdClient.bm_mt_modify_entry(contextId, tableName, entryId, action.name(), action.parameters());
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#method_after
public final void modifyTableEntry(String tableName, long entryId, Bmv2Action action) throws Bmv2Exception {
    try {
        stdClient.bm_mt_modify_entry(CONTEXT_ID, tableName, entryId, action.name(), action.parameters());
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#end_block

#method_before
public void deleteTableEntry(int contextId, String tableName, long entryId) throws Bmv2Exception {
    try {
        stdClient.bm_mt_delete_entry(contextId, tableName, entryId);
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#method_after
public final void deleteTableEntry(String tableName, long entryId) throws Bmv2Exception {
    try {
        stdClient.bm_mt_delete_entry(CONTEXT_ID, tableName, entryId);
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#end_block

#method_before
public void setTableDefaultAction(int contextId, String tableName, Bmv2Action action) throws Bmv2Exception {
    try {
        stdClient.bm_mt_set_default_action(contextId, tableName, action.name(), action.parameters());
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#method_after
public final void setTableDefaultAction(String tableName, Bmv2Action action) throws Bmv2Exception {
    try {
        stdClient.bm_mt_set_default_action(CONTEXT_ID, tableName, action.name(), action.parameters());
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#end_block

#method_before
public Collection<Bmv2PortInfo> getPortsInfo() throws Bmv2Exception {
    try {
        List<DevMgrPortInfo> portInfos = stdClient.bm_dev_mgr_show_ports();
        Collection<Bmv2PortInfo> bmv2PortInfos = Lists.newArrayList();
        bmv2PortInfos.addAll(portInfos.stream().map(Bmv2PortInfo::new).collect(Collectors.toList()));
        return Collections.unmodifiableCollection(bmv2PortInfos);
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#method_after
public Collection<Bmv2PortInfo> getPortsInfo() throws Bmv2Exception {
    try {
        List<DevMgrPortInfo> portInfos = stdClient.bm_dev_mgr_show_ports();
        Collection<Bmv2PortInfo> bmv2PortInfos = Lists.newArrayList();
        bmv2PortInfos.addAll(portInfos.stream().map(Bmv2PortInfo::new).collect(Collectors.toList()));
        return bmv2PortInfos;
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#end_block

#method_before
public String dumpTable(int contextId, String tableName) throws Bmv2Exception {
    try {
        return stdClient.bm_dump_table(contextId, tableName);
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#method_after
public String dumpTable(String tableName) throws Bmv2Exception {
    try {
        return stdClient.bm_dump_table(CONTEXT_ID, tableName);
    } catch (TException e) {
        throw new Bmv2Exception(e.getMessage(), e);
    }
}
#end_block

#method_before
final public String name() {
    return name;
}
#method_after
public final String name() {
    return name;
}
#end_block

#method_before
final public List<ByteBuffer> parameters() {
    return Collections.unmodifiableList(parameters);
}
#method_after
public final List<ByteBuffer> parameters() {
    return Collections.unmodifiableList(parameters);
}
#end_block

#method_before
@Override
final public int hashCode() {
    return Objects.hash(name, parameters);
}
#method_after
@Override
public final int hashCode() {
    return Objects.hash(name, parameters);
}
#end_block

#method_before
@Override
final public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final Bmv2Action other = (Bmv2Action) obj;
    return Objects.equals(this.name, other.name) && Objects.equals(this.parameters, other.parameters);
}
#method_after
@Override
public final boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final Bmv2Action other = (Bmv2Action) obj;
    return Objects.equals(this.name, other.name) && Objects.equals(this.parameters, other.parameters);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("name", name).add("parameters", parameters).toString();
}
#method_after
@Override
public final String toString() {
    return MoreObjects.toStringHelper(this).add("name", name).add("parameters", parameters).toString();
}
#end_block

#method_before
public Builder withName(String name) {
    this.name = name;
    return this;
}
#method_after
public Builder withName(String actionName) {
    this.name = actionName;
    return this;
}
#end_block

#method_before
final public String tableName() {
    return this.tableName;
}
#method_after
public final String tableName() {
    return this.tableName;
}
#end_block

#method_before
final public Bmv2MatchKey matchKey() {
    return matchKey;
}
#method_after
public final Bmv2MatchKey matchKey() {
    return matchKey;
}
#end_block

#method_before
final public Bmv2Action action() {
    return action;
}
#method_after
public final Bmv2Action action() {
    return action;
}
#end_block

#method_before
final public boolean hasPriority() {
    return this.priority != NO_PRIORITY_VALUE;
}
#method_after
public final boolean hasPriority() {
    return this.priority != NO_PRIORITY_VALUE;
}
#end_block

#method_before
final public int priority() {
    return priority;
}
#method_after
public final int priority() {
    return priority;
}
#end_block

#method_before
final public boolean hasTimeout() {
    return this.timeout != NO_PRIORITY_VALUE;
}
#method_after
public final boolean hasTimeout() {
    return this.timeout != NO_PRIORITY_VALUE;
}
#end_block

#method_before
final public double timeout() {
    return timeout;
}
#method_after
public final double timeout() {
    return timeout;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(matchKey, action, priority, timeout);
}
#method_after
@Override
public final int hashCode() {
    return Objects.hash(matchKey, action, priority, timeout);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final Bmv2TableEntry other = (Bmv2TableEntry) obj;
    return Objects.equals(this.matchKey, other.matchKey) && Objects.equals(this.action, other.action) && Objects.equals(this.priority, other.priority) && Objects.equals(this.timeout, other.timeout);
}
#method_after
@Override
public final boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    final Bmv2TableEntry other = (Bmv2TableEntry) obj;
    return Objects.equals(this.matchKey, other.matchKey) && Objects.equals(this.action, other.action) && Objects.equals(this.priority, other.priority) && Objects.equals(this.timeout, other.timeout);
}
#end_block

#method_before
@Override
public String toString() {
    return com.google.common.base.MoreObjects.toStringHelper(this).addValue(matchKey).addValue(action).add("priority", priority).add("timeout", timeout).toString();
}
#method_after
@Override
public final String toString() {
    return com.google.common.base.MoreObjects.toStringHelper(this).addValue(matchKey).addValue(action).add("priority", priority).add("timeout", timeout).toString();
}
#end_block

#method_before
@Override
public <T> void setPropertyValue(String key, T value) throws ExtensionPropertyException {
    throw new ExtensionPropertyException("Method not supported");
}
#method_after
@Override
public <T> void setPropertyValue(String key, T value) throws ExtensionPropertyException {
    // We don't support any property retrieval
    throw new ExtensionPropertyException("Method not supported");
}
#end_block

#method_before
@Override
public <T> T getPropertyValue(String key) throws ExtensionPropertyException {
    throw new ExtensionPropertyException("Method not supported");
}
#method_after
@Override
public <T> T getPropertyValue(String key) throws ExtensionPropertyException {
    // As above
    throw new ExtensionPropertyException("Method not supported");
}
#end_block

#method_before
@Override
public void deserialize(byte[] data) {
    matchKey = appKryo.deserialize(data);
// FIXME: should recompute the type?
}
#method_after
@Override
public void deserialize(byte[] data) {
    matchKey = appKryo.deserialize(data);
}
#end_block

#method_before
@Override
public List<PortDescription> getPorts() {
    Bmv2ThriftClient device;
    try {
        device = new Bmv2ThriftClient(handler().data().deviceId());
    } catch (Bmv2Exception e) {
        log.error("Failed to connect to Bmv2 device", e);
        return Collections.emptyList();
    }
    List<PortDescription> portDescriptions = Lists.newArrayList();
    try {
        device.getPortsInfo().forEach(p -> {
            DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
            p.getExtraProperties().forEach(builder::set);
            SparseAnnotations annotations = builder.build();
            portDescriptions.add(new DefaultPortDescription(PortNumber.portNumber((long) p.portNumber(), p.ifaceName()), p.isUp(), annotations));
        });
    } catch (Bmv2Exception e) {
        log.error("Unable to get port description from Bmv2", e);
        return Collections.emptyList();
    }
    return portDescriptions;
}
#method_after
@Override
public List<PortDescription> getPorts() {
    Bmv2ThriftClient deviceClient;
    try {
        deviceClient = Bmv2ThriftClient.of(handler().data().deviceId());
    } catch (Bmv2Exception e) {
        log.error("Failed to connect to Bmv2 device", e);
        return Collections.emptyList();
    }
    List<PortDescription> portDescriptions = Lists.newArrayList();
    try {
        deviceClient.getPortsInfo().forEach(p -> {
            DefaultAnnotations.Builder builder = DefaultAnnotations.builder();
            p.getExtraProperties().forEach(builder::set);
            SparseAnnotations annotations = builder.build();
            portDescriptions.add(new DefaultPortDescription(PortNumber.portNumber((long) p.portNumber(), p.ifaceName()), p.isUp(), annotations));
        });
    } catch (Bmv2Exception e) {
        log.error("Unable to get port description from Bmv2 device", e);
    }
    return ImmutableList.copyOf(portDescriptions);
}
#end_block

#method_before
public String ifaceName() {
    return portInfo.getIface_name();
}
#method_after
public final String ifaceName() {
    return portInfo.getIface_name();
}
#end_block

#method_before
public int portNumber() {
    return portInfo.getPort_num();
}
#method_after
public final int portNumber() {
    return portInfo.getPort_num();
}
#end_block

#method_before
public boolean isUp() {
    return portInfo.isIs_up();
}
#method_after
public final boolean isUp() {
    return portInfo.isIs_up();
}
#end_block

#method_before
public Map<String, String> getExtraProperties() {
    return Collections.unmodifiableMap(portInfo.getExtra());
}
#method_after
public final Map<String, String> getExtraProperties() {
    return Collections.unmodifiableMap(portInfo.getExtra());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).addValue(portInfo).toString();
}
#method_after
@Override
public final String toString() {
    return MoreObjects.toStringHelper(this).addValue(portInfo).toString();
}
#end_block

#method_before
public void linkUp(Link newLink, boolean isMaster) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    log.info("* LinkUP: Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    MacAddress dstMac;
    try {
        dstMac = deviceConfig.getDeviceMac(newLink.dst().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting linkUp.");
        return;
    }
    addNeighborAtPort(newLink.dst().deviceId(), newLink.src().port());
    /*if (devicePortMap.get(newLink.dst().deviceId()) == null) {
            // New Neighbor
            newNeighbor(newLink);
        } else {
            // Old Neighbor
            newPortToExistingNeighbor(newLink);
        }*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(newLink.dst().deviceId()))).collect(Collectors.toSet());
    log.trace("linkUp: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null && isMaster) {
            // Create the new bucket to be updated
            TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
            tBuilder.setOutput(newLink.src().port()).setEthDst(dstMac).setEthSrc(nodeMacAddr);
            if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
            }
            // setup metadata to pass to nextObjective - indicate the vlan on egress
            // if needed by the switch pipeline. Since hashed next-hops are always to
            // other neighboring routers, there is no subnet assigned on those ports.
            TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
            metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).addTreatment(tBuilder.build()).withMeta(metabuilder.build()).fromApp(appId);
            log.info("**linkUp in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, newLink.src().port(), nextId);
            ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("NextObj {} installed on {}", nextId, deviceId), (objective, error) -> log.warn("Failed to install NextObj {} on {}: {}", nextId, deviceId, error));
            NextObjective nextObjective = nextObjBuilder.addToExisting(context);
            flowObjectiveService.next(deviceId, nextObjective);
        // the addition of a bucket may actually change the neighborset
        // update the global store
        /*
                Set<DeviceId> neighbors = new HashSet<DeviceId>(ns.getDeviceIds());
                boolean newadd = neighbors.add(newLink.dst().deviceId());
                if (newadd) {
                    NeighborSet nsnew = new NeighborSet(neighbors, ns.getEdgeLabel());
                    nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, nsnew),
                                       nextId);
                    nsNextObjStore.remove(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
                }*/
        } else if (isMaster) {
            log.warn("linkUp in device {}, but global store has no record " + "for neighbor-set {}", deviceId, ns);
        }
    }
}
#method_after
public void linkUp(Link newLink, boolean isMaster) {
    if (newLink.type() != Link.Type.DIRECT) {
        log.warn("linkUp: unknown link type");
        return;
    }
    if (!newLink.src().deviceId().equals(deviceId)) {
        log.warn("linkUp: deviceId{} doesn't match with link src{}", deviceId, newLink.src().deviceId());
        return;
    }
    log.info("* LinkUP: Device {} linkUp at local port {} to neighbor {}", deviceId, newLink.src().port(), newLink.dst().deviceId());
    MacAddress dstMac;
    try {
        dstMac = deviceConfig.getDeviceMac(newLink.dst().deviceId());
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting linkUp.");
        return;
    }
    addNeighborAtPort(newLink.dst().deviceId(), newLink.src().port());
    /*if (devicePortMap.get(newLink.dst().deviceId()) == null) {
            // New Neighbor
            newNeighbor(newLink);
        } else {
            // Old Neighbor
            newPortToExistingNeighbor(newLink);
        }*/
    Set<NeighborSet> nsSet = nsNextObjStore.keySet().stream().filter((nsStoreEntry) -> (nsStoreEntry.deviceId().equals(deviceId))).map((nsStoreEntry) -> (nsStoreEntry.neighborSet())).filter((ns) -> (ns.getDeviceIds().contains(newLink.dst().deviceId()))).collect(Collectors.toSet());
    log.trace("linkUp: nsNextObjStore contents for device {}:", deviceId, nsSet);
    for (NeighborSet ns : nsSet) {
        Integer nextId = nsNextObjStore.get(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
        if (nextId != null && isMaster) {
            // Create the new bucket to be updated
            TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
            tBuilder.setOutput(newLink.src().port()).setEthDst(dstMac).setEthSrc(nodeMacAddr);
            if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
            }
            // setup metadata to pass to nextObjective - indicate the vlan on egress
            // if needed by the switch pipeline. Since hashed next-hops are always to
            // other neighboring routers, there is no subnet assigned on those ports.
            TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
            metabuilder.matchVlanId(VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET));
            NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).addTreatment(tBuilder.build()).withMeta(metabuilder.build()).fromApp(appId);
            log.info("**linkUp in device {}: Adding Bucket " + "with Port {} to next object id {}", deviceId, newLink.src().port(), nextId);
            ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("LinkUp installed NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("LinkUp failed to install NextObj {} on {}: {}", nextId, deviceId, error));
            NextObjective nextObjective = nextObjBuilder.addToExisting(context);
            flowObjectiveService.next(deviceId, nextObjective);
        // the addition of a bucket may actually change the neighborset
        // update the global store
        /*
                Set<DeviceId> neighbors = new HashSet<DeviceId>(ns.getDeviceIds());
                boolean newadd = neighbors.add(newLink.dst().deviceId());
                if (newadd) {
                    NeighborSet nsnew = new NeighborSet(neighbors, ns.getEdgeLabel());
                    nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, nsnew),
                                       nextId);
                    nsNextObjStore.remove(new NeighborSetNextObjectiveStoreKey(deviceId, ns));
                }*/
        } else if (isMaster) {
            log.warn("linkUp in device {}, but global store has no record " + "for neighbor-set {}", deviceId, ns);
        }
    }
}
#end_block

#method_before
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet, TrafficSelector meta) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId neighborId : ns.getDeviceIds()) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromNeighborsets.");
                return;
            }
            for (PortNumber sp : devicePortMap.get(neighborId)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        if (meta != null) {
            nextObjBuilder.withMeta(meta);
        }
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("NextObj {} installed on {}", nextId, deviceId), (objective, error) -> log.warn("Failed to install NextObj {} on {}: {}", nextId, deviceId, error));
        NextObjective nextObj = nextObjBuilder.add(context);
        log.debug("**createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        flowObjectiveService.next(deviceId, nextObj);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#method_after
public void createGroupsFromNeighborsets(Set<NeighborSet> nsSet, TrafficSelector meta) {
    for (NeighborSet ns : nsSet) {
        int nextId = flowObjectiveService.allocateNextId();
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextId).withType(NextObjective.Type.HASHED).fromApp(appId);
        for (DeviceId neighborId : ns.getDeviceIds()) {
            if (devicePortMap.get(neighborId) == null) {
                log.warn("Neighbor {} is not in the port map yet for dev:{}", neighborId, deviceId);
                return;
            } else if (devicePortMap.get(neighborId).size() == 0) {
                log.warn("There are no ports for " + "the Device {} in the port map yet", neighborId);
                return;
            }
            MacAddress neighborMac;
            try {
                neighborMac = deviceConfig.getDeviceMac(neighborId);
            } catch (DeviceConfigNotFoundException e) {
                log.warn(e.getMessage() + " Aborting createGroupsFromNeighborsets.");
                return;
            }
            for (PortNumber sp : devicePortMap.get(neighborId)) {
                TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
                tBuilder.setEthDst(neighborMac).setEthSrc(nodeMacAddr);
                if (ns.getEdgeLabel() != NeighborSet.NO_EDGE_LABEL) {
                    tBuilder.pushMpls().copyTtlOut().setMpls(MplsLabel.mplsLabel(ns.getEdgeLabel()));
                }
                tBuilder.setOutput(sp);
                nextObjBuilder.addTreatment(tBuilder.build());
            }
        }
        if (meta != null) {
            nextObjBuilder.withMeta(meta);
        }
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("createGroupsFromNeighborsets installed NextObj {} on {}", nextId, deviceId), (objective, error) -> log.warn("createGroupsFromNeighborsets failed to install NextObj {} on {}: {}", nextId, deviceId, error));
        NextObjective nextObj = nextObjBuilder.add(context);
        log.debug("**createGroupsFromNeighborsets: Submited " + "next objective {} in device {}", nextId, deviceId);
        flowObjectiveService.next(deviceId, nextObj);
        nsNextObjStore.put(new NeighborSetNextObjectiveStoreKey(deviceId, ns), nextId);
    }
}
#end_block

#method_before
public boolean removeGroup(int objectiveId) {
    if (nsNextObjStore.containsValue(objectiveId)) {
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(objectiveId).withType(NextObjective.Type.HASHED).fromApp(appId);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("NextObj {} removed on {}", objectiveId, deviceId), (objective, error) -> log.warn("Failed to remove NextObj {} on {}: {}", objectiveId, deviceId, error));
        NextObjective nextObjective = nextObjBuilder.remove(context);
        log.info("**removeGroup: Submited " + "next objective {} in device {}", objectiveId, deviceId);
        flowObjectiveService.next(deviceId, nextObjective);
        for (Map.Entry<NeighborSetNextObjectiveStoreKey, Integer> entry : nsNextObjStore.entrySet()) {
            if (entry.getValue().equals(objectiveId)) {
                nsNextObjStore.remove(entry.getKey());
                break;
            }
        }
        return true;
    }
    return false;
}
#method_after
public boolean removeGroup(int objectiveId) {
    if (nsNextObjStore.containsValue(objectiveId)) {
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(objectiveId).withType(NextObjective.Type.HASHED).fromApp(appId);
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("RemoveGroup removes NextObj {} on {}", objectiveId, deviceId), (objective, error) -> log.warn("RemoveGroup failed to remove NextObj {} on {}: {}", objectiveId, deviceId, error));
        NextObjective nextObjective = nextObjBuilder.remove(context);
        log.info("**removeGroup: Submited " + "next objective {} in device {}", objectiveId, deviceId);
        flowObjectiveService.next(deviceId, nextObjective);
        for (Map.Entry<NeighborSetNextObjectiveStoreKey, Integer> entry : nsNextObjStore.entrySet()) {
            if (entry.getValue().equals(objectiveId)) {
                nsNextObjStore.remove(entry.getKey());
                break;
            }
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected void execute() {
    log.info("executing pce-update-path");
    PceService service = get(PceService.class);
    List<Constraint> constrntList = new LinkedList<Constraint>();
    // Assign cost
    if (null != cost) {
    // TODO: need to uncomment below lines once CostConstraint is ready
    // CostConstraint.Type costType = CostConstraint.Type.values()[Integer.valueOf(cost)];
    // constrntList.add(CostConstraint.of(costType));
    }
    // Assign bandwidth. Data rate unit is in BPS.
    if (null != bandwidth) {
    // TODO: need to uncomment below line once BandwidthConstraint is ready
    // constrntList.add(LocalBandwidthConstraint.of(Double.valueOf(bandwidth), DataRateUnit.valueOf("BPS")));
    }
// TODO: need to uncomment below lines once updatePath method is added to PceService
// if (null == service.updatePath(PcePathId.of(id), constrntList)) {
// error("Path updation failed.");
// return;
// }
}
#method_after
@Override
protected void execute() {
    log.info("executing pce-update-path");
    PceService service = get(PceService.class);
    List<Constraint> constrntList = new LinkedList<>();
    // Assign cost
    if (cost != 0) {
    // TODO: need to uncomment below lines once CostConstraint is ready
    // CostConstraint.Type costType = CostConstraint.Type.values()[Integer.valueOf(cost)];
    // constrntList.add(CostConstraint.of(costType));
    }
    // Assign bandwidth. Data rate unit is in Bps.
    if (bandwidth != 0.0) {
    // TODO: need to uncomment below line once BandwidthConstraint is ready
    // constrntList.add(LocalBandwidthConstraint.of(Double.valueOf(bandwidth), DataRateUnit.valueOf("BPS")));
    }
// TODO: need to uncomment below lines once updatePath method is added to PceService
// if (null == service.updatePath(PcePathId.of(id), constrntList)) {
// error("Path updation failed.");
// return;
// }
}
#end_block

#method_before
@Override
protected void execute() {
    log.info("executing pce-setup-path");
    PceService service = get(PceService.class);
    DeviceId srcDevice = DeviceId.deviceId(src);
    DeviceId dstDevice = DeviceId.deviceId(dst);
    LspType lspType = LspType.values()[Integer.valueOf(type)];
    List<Constraint> listConstrnt = new LinkedList<Constraint>();
    // bandwidth default data rate unit is in BPS
    if (null != bandwidth) {
    // TODO: need to uncomment below line once BandwidthConstraint is ready
    // listConstrnt.add(LocalBandwidthConstraint.of(Double.valueOf(bandwidth), DataRateUnit.valueOf("BPS")));
    }
// TODO: need to uncomment below lines once setupPath method is modified in PceService
// if (null == service.setupPath(srcDevice, dstDevice, name, listConstrnt, lspType)) {
// error("Path creation failed.");
// }
}
#method_after
@Override
protected void execute() {
    log.info("executing pce-setup-path");
    PceService service = get(PceService.class);
    DeviceId srcDevice = DeviceId.deviceId(src);
    DeviceId dstDevice = DeviceId.deviceId(dst);
    LspType lspType = LspType.values()[type];
    List<Constraint> listConstrnt = new LinkedList<>();
    // bandwidth default data rate unit is in BPS
    if (bandwidth != 0.0) {
    // TODO: need to uncomment below line once BandwidthConstraint is ready
    // listConstrnt.add(LocalBandwidthConstraint.of(bandwidth, DataRateUnit.valueOf("BPS")));
    }
// TODO: need to uncomment below lines once setupPath method is modified in PceService
// if (null == service.setupPath(srcDevice, dstDevice, name, listConstrnt, lspType)) {
// error("Path creation failed.");
// }
}
#end_block

#method_before
@Test
public void testEquals() {
    // create same two pce-path objects.
    final String cost1 = "1";
    final String bandwidth1 = "200";
    final String src1 = "foo";
    final String dst1 = "bee";
    final String type1 = "1";
    final String name1 = "pcc";
    PceConstraint constrnt1 = DefaultPceConstraint.builder().cost(cost1).bandwidth(bandwidth1).build();
    PcePath path1 = DefaultPcePath.builder().source(src1).destination(dst1).lspType(type1).name(name1).constraint(constrnt1).build();
    path1.id(PcePathId.of("1"));
    // create same as above object
    PcePath samePath1 = DefaultPcePath.builder().source(src1).destination(dst1).lspType(type1).name(name1).constraint(constrnt1).build();
    samePath1.id(PcePathId.of("1"));
    // Create different pce-path object.
    final String cost2 = "1";
    final String bandwidth2 = "200";
    final String src2 = "google";
    final String dst2 = "yahoo";
    final String type2 = "2";
    final String name2 = "pcc2";
    PceConstraint constrnt2 = DefaultPceConstraint.builder().cost(cost2).bandwidth(bandwidth2).build();
    PcePath path2 = DefaultPcePath.builder().source(src2).destination(dst2).lspType(type2).name(name2).constraint(constrnt2).build();
    path2.id(PcePathId.of("2"));
    new EqualsTester().addEqualityGroup(path1, samePath1).addEqualityGroup(path2).testEquals();
}
#method_after
@Test
public void testEquals() {
    // create same two pce-path objects.
    final String cost1 = "1";
    final String bandwidth1 = "200";
    final String src1 = "foo";
    final String dst1 = "bee";
    final String type1 = "1";
    final String name1 = "pcc";
    PcePath path1 = DefaultPcePath.builder().source(src1).destination(dst1).lspType(type1).name(name1).costConstraint(cost1).bandwidthConstraint(bandwidth1).build();
    path1.id(TunnelId.valueOf("1"));
    // create same as above object
    PcePath samePath1 = DefaultPcePath.builder().source(src1).destination(dst1).lspType(type1).name(name1).costConstraint(cost1).bandwidthConstraint(bandwidth1).build();
    samePath1.id(TunnelId.valueOf("1"));
    // Create different pce-path object.
    final String cost2 = "1";
    final String bandwidth2 = "200";
    final String src2 = "google";
    final String dst2 = "yahoo";
    final String type2 = "2";
    final String name2 = "pcc2";
    PcePath path2 = DefaultPcePath.builder().source(src2).destination(dst2).lspType(type2).name(name2).costConstraint(cost2).bandwidthConstraint(bandwidth2).build();
    path2.id(TunnelId.valueOf("2"));
// TODO: will be uncommented below line once CostConstraint and LocalBandwidthConstraint classes are ready
// new EqualsTester().addEqualityGroup(path1, samePath1).addEqualityGroup(path2).testEquals();
}
#end_block

#method_before
@Test
public void testConstruction() {
    final String cost = "1";
    final String bandwidth = "600";
    final String src = "indiatimes";
    final String dst = "deccan";
    final String type = "3";
    final String name = "pcc4";
    PceConstraint constrnt = DefaultPceConstraint.builder().cost(cost).bandwidth(bandwidth).build();
    PcePath path = DefaultPcePath.builder().source(src).destination(dst).lspType(type).name(name).constraint(constrnt).build();
    assertThat(src, is(path.source()));
    assertThat(dst, is(path.destination()));
    assertThat(LspType.SR_WITHOUT_SIGNALLING, is(path.lspType()));
    assertThat(name, is(path.name()));
    assertThat(constrnt, is(path.constraint()));
}
#method_after
@Test
public void testConstruction() {
    final String cost = "1";
    final String bandwidth = "600";
    final String src = "indiatimes";
    final String dst = "deccan";
    final String type = "3";
    final String name = "pcc4";
    PcePath path = DefaultPcePath.builder().source(src).destination(dst).lspType(type).name(name).costConstraint(cost).bandwidthConstraint(bandwidth).build();
    assertThat(src, is(path.source()));
    assertThat(dst, is(path.destination()));
    assertThat(LspType.WITHOUT_SIGNALLING_AND_WITHOUT_SR, is(path.lspType()));
    assertThat(name, is(path.name()));
// TODO: will be uncommented below lines once CostConstraint and LocalBandwidthConstraint classes are ready
// assertThat(cost, is(path.costConstraint().toString()));
// assertThat(bandwidth, is(path.bandwidthConstraint().toString()));
}
#end_block

#method_before
@Override
protected void execute() {
    log.info("executing pce-query-path");
    PceService service = get(PceService.class);
    if (null == id) {
        // TODO: need to uncomment below line once queryAllPath method is added to PceService
        // = service.queryAllPath();
        Iterable<Tunnel> tunnels = null;
        if (tunnels != null) {
            for (final Tunnel tunnel : tunnels) {
                display(tunnel);
            }
        } else {
            print("No path is found.");
            return;
        }
    } else {
        // TODO: need to uncomment below line once queryPath method is added to PceService
        // = service.queryPath(PcePathId.of(id));
        Tunnel tunnel = null;
        if (null == tunnel) {
            print("Path is not exists.");
            return;
        }
        display(tunnel);
    }
}
#method_after
@Override
protected void execute() {
    log.info("executing pce-query-path");
    PceService service = get(PceService.class);
    if (null == id) {
        // TODO: need to uncomment below line once queryAllPath method is added to PceService
        // = service.queryAllPath();
        Iterable<Tunnel> tunnels = null;
        if (tunnels != null) {
            for (final Tunnel tunnel : tunnels) {
                display(tunnel);
            }
        } else {
            print("No path is found.");
            return;
        }
    } else {
        // TODO: need to uncomment below line once queryPath method is added to PceService
        // = service.queryPath(PcePathId.of(id));
        Tunnel tunnel = null;
        if (tunnel == null) {
            print("Path doesnot exists.");
            return;
        }
        display(tunnel);
    }
}
#end_block

#method_before
void display(Tunnel tunnel) {
    print("\npath-id            : %d \n" + "source             : %s \n" + "destination        : %s \n" + "lsp-type           : %d \n" + "symbolic-path-name : %s \n" + "constraints:            \n" + "   cost            : %d \n" + "   bandwidth       : %.2f", tunnel.tunnelId().toString(), tunnel.src().toString(), tunnel.dst().toString(), tunnel.type(), tunnel.tunnelName(), tunnel.path().cost(), tunnel.annotations().value(AnnotationKeys.BANDWIDTH));
}
#method_after
void display(Tunnel tunnel) {
    print("\npath-id            : %d \n" + "source             : %s \n" + "destination        : %s \n" + "path-type          : %d \n" + "symbolic-path-name : %s \n" + "constraints:            \n" + "   cost            : %d \n" + "   bandwidth       : %.2f", tunnel.tunnelId().id(), tunnel.src().toString(), tunnel.dst().toString(), tunnel.type(), tunnel.tunnelName(), tunnel.path().cost(), tunnel.annotations().value(AnnotationKeys.BANDWIDTH));
}
#end_block

#method_before
@Override
public PcePathId id() {
    return id;
}
#method_after
@Override
public TunnelId id() {
    return id;
}
#end_block

#method_before
@Override
public void id(PcePathId id) {
    this.id = id;
}
#method_after
@Override
public void id(TunnelId id) {
    this.id = id;
}
#end_block

#method_before
@Override
public PcePath copy(PcePath path) {
    if (null != path.source()) {
        this.source = path.source();
    }
    if (null != path.destination()) {
        this.destination = path.destination();
    }
    this.lspType = path.lspType();
    if (null != path.name()) {
        this.name = path.name();
    }
    if (null != path.constraint()) {
        this.constraint.copy(path.constraint());
    }
    return this;
}
#method_after
@Override
public PcePath copy(PcePath path) {
    if (null != path.source()) {
        this.source = path.source();
    }
    if (null != path.destination()) {
        this.destination = path.destination();
    }
    this.lspType = path.lspType();
    if (null != path.name()) {
        this.name = path.name();
    }
    if (null != path.costConstraint()) {
        this.costConstraint = path.costConstraint();
    }
    if (null != path.bandwidthConstraint()) {
        this.bandwidthConstraint = path.bandwidthConstraint();
    }
    return this;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, source, destination, lspType, name, constraint);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, source, destination, lspType, name, costConstraint, bandwidthConstraint);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultPcePath) {
        DefaultPcePath that = (DefaultPcePath) obj;
        return Objects.equals(id, that.id) && Objects.equals(source, that.source) && Objects.equals(destination, that.destination) && Objects.equals(lspType, that.lspType) && Objects.equals(name, that.name) && Objects.equals(constraint, that.constraint);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultPcePath) {
        DefaultPcePath that = (DefaultPcePath) obj;
        return Objects.equals(id, that.id) && Objects.equals(source, that.source) && Objects.equals(destination, that.destination) && Objects.equals(lspType, that.lspType) && Objects.equals(name, that.name) && Objects.equals(costConstraint, that.costConstraint) && Objects.equals(bandwidthConstraint, that.bandwidthConstraint);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("id", id.value()).add("source", source).add("destination", destination).add("lsptype", lspType).add("name", name).add("constraint", constraint.toString()).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("id", id()).add("source", source).add("destination", destination).add("lsptype", lspType).add("name", name).add("costConstraint", costConstraint.toString()).add("bandwidthConstraint", bandwidthConstraint.toString()).toString();
}
#end_block

#method_before
@Override
public Builder id(String id) {
    this.id = PcePathId.of(id);
    return this;
}
#method_after
@Override
public Builder id(String id) {
    this.id = TunnelId.valueOf(id);
    return this;
}
#end_block

#method_before
@Override
public Builder of(Tunnel tunnel) {
    PcePathId id = PcePathId.of(Integer.valueOf(tunnel.tunnelId().toString()));
    String source = tunnel.src().toString();
    String destination = tunnel.dst().toString();
    // TODO: need to uncomment below line once LSP_SIG_TYPE is added to AnnotationKeys
    // = LspType.valueOf(tunnel.annotations().value(AnnotationKeys.LSP_SIG_TYPE));
    LspType lspType;
    String name = tunnel.tunnelName().toString();
    PceConstraint constraint = DefaultPceConstraint.builder().cost(Double.toString(tunnel.path().cost())).bandwidth(tunnel.annotations().value(AnnotationKeys.BANDWIDTH)).build();
    return this;
}
#method_after
@Override
public Builder of(Tunnel tunnel) {
    this.id = TunnelId.valueOf(tunnel.tunnelId().id());
    this.source = tunnel.src().toString();
    this.destination = tunnel.dst().toString();
    // TODO: need to uncomment below line once LSP_SIG_TYPE is added to AnnotationKeys
    // = LspType.valueOf(tunnel.annotations().value(AnnotationKeys.LSP_SIG_TYPE));
    this.lspType = null;
    this.name = tunnel.tunnelName().toString();
    // CostConstraint.of(tunnel.path().cost());
    this.costConstraint = null;
    this.bandwidthConstraint = null;
    // LocalBandwidthConstraint.of(tunnel.annotations().value(AnnotationKeys.BANDWIDTH));
    return this;
}
#end_block

#method_before
@Override
public PcePath build() {
    return new DefaultPcePath(id, source, destination, lspType, name, constraint);
}
#method_after
@Override
public PcePath build() {
    return new DefaultPcePath(id, source, destination, lspType, name, costConstraint, bandwidthConstraint);
}
#end_block

#method_before
@Override
public Set<String> services() {
    String response = RestClientUtil.restGet(access.endpoint() + BASE_URL);
    Set<String> services = Sets.newHashSet();
    ObjectMapper mapper = new ObjectMapper();
    try {
        ObjectNode node = (ObjectNode) mapper.readTree(response);
    // TODO parse the result and add to services set
    } catch (IOException e) {
        e.printStackTrace();
    }
    return services;
}
#method_after
@Override
public Set<String> services() {
    String response = restGet(EMPTY_STRING);
    log.trace("Get services {}", response);
    ObjectMapper mapper = new ObjectMapper();
    try {
        JsonNode nodes = mapper.readTree(response);
        return Sets.newHashSet(nodes.fieldNames());
    } catch (IOException e) {
        log.warn("Failed to get service list");
        return Sets.newHashSet();
    }
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.core");
    netCfgService.registerConfigFactory(factory);
    netCfgService.addListener(cfgListener);
    cfgListener.reconfigure(netCfgService.getConfig(appId, CoreConfig.class));
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MastershipBasedTimestamp.class).register(Provided.class);
    linkDescriptions = storageService.<Provided<LinkKey>, LinkDescription>eventuallyConsistentMapBuilder().withName("onos-link-descriptions").withSerializer(serializer).withTimestampProvider((k, v) -> {
        try {
            return v == null ? null : deviceClockService.getTimestamp(v.dst().deviceId());
        } catch (IllegalStateException e) {
            return null;
        }
    }).build();
    linkProviders = storageService.<LinkKey, Set<ProviderId>>eventuallyConsistentMapBuilder().withName("onos-link-providers").withSerializer(serializer).withTimestampProvider((k, v) -> {
        try {
            return v == null ? null : deviceClockService.getTimestamp(k.dst().deviceId());
        } catch (IllegalStateException e) {
            return null;
        }
    }).build();
    clusterCommunicator.addSubscriber(LINK_INJECT_MESSAGE, SERIALIZER::decode, this::injectLink, SERIALIZER::encode, SharedExecutors.getPoolThreadExecutor());
    linkDescriptions.addListener(linkTracker);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.core");
    netCfgService.registerConfigFactory(factory);
    netCfgService.addListener(cfgListener);
    cfgListener.reconfigure(netCfgService.getConfig(appId, CoreConfig.class));
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MastershipBasedTimestamp.class).register(Provided.class);
    linkDescriptions = storageService.<Provided<LinkKey>, LinkDescription>eventuallyConsistentMapBuilder().withName("onos-link-descriptions").withSerializer(serializer).withTimestampProvider((k, v) -> {
        try {
            return v == null ? null : deviceClockService.getTimestamp(v.dst().deviceId());
        } catch (IllegalStateException e) {
            return null;
        }
    }).build();
    clusterCommunicator.addSubscriber(LINK_INJECT_MESSAGE, SERIALIZER::decode, this::injectLink, SERIALIZER::encode, SharedExecutors.getPoolThreadExecutor());
    linkDescriptions.addListener(linkTracker);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    linkDescriptions.removeListener(linkTracker);
    linkDescriptions.destroy();
    linkProviders.destroy();
    links.clear();
    clusterCommunicator.removeSubscriber(LINK_INJECT_MESSAGE);
    netCfgService.removeListener(cfgListener);
    netCfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    linkDescriptions.removeListener(linkTracker);
    linkDescriptions.destroy();
    linkProviders.clear();
    links.clear();
    clusterCommunicator.removeSubscriber(LINK_INJECT_MESSAGE);
    netCfgService.removeListener(cfgListener);
    netCfgService.unregisterConfigFactory(factory);
    log.info("Stopped");
}
#end_block

#method_before
private Set<ProviderId> createOrUpdateLinkProviders(Set<ProviderId> current, ProviderId providerId) {
    if (current == null) {
        current = new HashSet<ProviderId>();
    }
    current.add(providerId);
    return current;
}
#method_after
private Set<ProviderId> createOrUpdateLinkProviders(Set<ProviderId> current, ProviderId providerId) {
    if (current == null) {
        current = Sets.newConcurrentHashSet();
    }
    current.add(providerId);
    return current;
}
#end_block

#method_before
private Set<ProviderId> getAllProviders(LinkKey linkKey) {
    Set<ProviderId> providerIds = linkProviders.get(linkKey);
    if (providerIds == null)
        providerIds = new HashSet<ProviderId>();
    return providerIds;
}
#method_after
private Set<ProviderId> getAllProviders(LinkKey linkKey) {
    return linkProviders.getOrDefault(linkKey, Sets.newConcurrentHashSet());
}
#end_block

#method_before
private Link composeLink(LinkKey linkKey) {
    ProviderId baseProviderId = checkNotNull(getBaseProviderId(linkKey));
    LinkDescription base = linkDescriptions.get(new Provided<>(linkKey, baseProviderId));
    ConnectPoint src = base.src();
    ConnectPoint dst = base.dst();
    Type type = base.type();
    AtomicReference<DefaultAnnotations> annotations = new AtomicReference<>(DefaultAnnotations.builder().build());
    annotations.set(merge(annotations.get(), base.annotations()));
    getAllProviders(linkKey).stream().map(p -> new Provided<>(linkKey, p)).forEach(key -> {
        annotations.set(merge(annotations.get(), linkDescriptions.get(key).annotations()));
    });
    Link.State initialLinkState;
    boolean isExpected;
    if (linkDiscoveryMode == LinkDiscoveryMode.PERMISSIVE) {
        initialLinkState = ACTIVE;
        isExpected = Objects.equals(annotations.get().value(AnnotationKeys.DURABLE), "true");
    } else {
        initialLinkState = base.isExpected() ? ACTIVE : INACTIVE;
        isExpected = base.isExpected();
    }
    return DefaultLink.builder().providerId(baseProviderId).src(src).dst(dst).type(type).state(initialLinkState).isExpected(isExpected).annotations(annotations.get()).build();
}
#method_after
private Link composeLink(LinkKey linkKey) {
    ProviderId baseProviderId = checkNotNull(getBaseProviderId(linkKey));
    LinkDescription base = linkDescriptions.get(new Provided<>(linkKey, baseProviderId));
    ConnectPoint src = base.src();
    ConnectPoint dst = base.dst();
    Type type = base.type();
    AtomicReference<DefaultAnnotations> annotations = new AtomicReference<>(DefaultAnnotations.builder().build());
    annotations.set(merge(annotations.get(), base.annotations()));
    getAllProviders(linkKey).stream().map(p -> new Provided<>(linkKey, p)).forEach(key -> {
        LinkDescription linkDescription = linkDescriptions.get(key);
        if (linkDescription != null) {
            annotations.set(merge(annotations.get(), linkDescription.annotations()));
        }
    });
    Link.State initialLinkState;
    boolean isExpected;
    if (linkDiscoveryMode == LinkDiscoveryMode.PERMISSIVE) {
        initialLinkState = ACTIVE;
        isExpected = Objects.equals(annotations.get().value(AnnotationKeys.DURABLE), "true");
    } else {
        initialLinkState = base.isExpected() ? ACTIVE : INACTIVE;
        isExpected = base.isExpected();
    }
    return DefaultLink.builder().providerId(baseProviderId).src(src).dst(dst).type(type).state(initialLinkState).isExpected(isExpected).annotations(annotations.get()).build();
}
#end_block

#method_before
@Override
public void event(EventuallyConsistentMapEvent<Provided<LinkKey>, LinkDescription> event) {
    if (event.type() == PUT) {
        linkProviders.compute(event.key().key(), (k, v) -> createOrUpdateLinkProviders(v, event.key().providerId()));
        notifyDelegate(refreshLinkCache(event.key().key()));
    } else if (event.type() == REMOVE) {
        notifyDelegate(purgeLinkCache(event.key().key()));
    }
}
#method_after
@Override
public void event(EventuallyConsistentMapEvent<Provided<LinkKey>, LinkDescription> event) {
    if (event.type() == PUT) {
        linkProviders.compute(event.key().key(), (k, v) -> createOrUpdateLinkProviders(v, event.key().providerId()));
        notifyDelegate(refreshLinkCache(event.key().key()));
    } else if (event.type() == REMOVE) {
        notifyDelegate(purgeLinkCache(event.key().key()));
        linkProviders.remove(event.key().key());
    }
}
#end_block

#method_before
@Override
public TunnelId setupTunnel(Tunnel tunnel, Path path) {
    return null;
}
#method_after
@Override
public TunnelId setupTunnel(ApplicationId producerId, ElementId srcElementId, Tunnel tunnel, Path path) {
    return null;
}
#end_block

#method_before
@Override
public boolean downTunnel(TunnelId tunnelId) {
    return false;
}
#method_after
@Override
public boolean downTunnel(ApplicationId producerId, TunnelId tunnelId) {
    return false;
}
#end_block

#method_before
@Override
public TunnelId setupTunnel(Tunnel tunnel, Path path) {
    // TODO: Insert into store and trigger provider API.
    return null;
}
#method_after
@Override
public TunnelId setupTunnel(ApplicationId producerId, ElementId srcElementId, Tunnel tunnel, Path path) {
    // TODO: Insert into store and trigger provider API.
    return null;
}
#end_block

#method_before
@Override
public boolean downTunnel(TunnelId tunnelId) {
    // TODO: Change the tunnel status and trigger provider API.
    return false;
}
#method_after
@Override
public boolean downTunnel(ApplicationId producerId, TunnelId tunnelId) {
    // TODO: Change the tunnel status and trigger provider API.
    return false;
}
#end_block

#method_before
@Override
public void tunnelUpdated(TunnelDescription tunnel) {
    Tunnel storedTunnel = new DefaultTunnel(provider().id(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), tunnel.id(), tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
    store.createOrUpdateTunnel(storedTunnel);
}
#method_after
@Override
public void tunnelUpdated(TunnelDescription tunnel, State state) {
    Tunnel storedTunnel = new DefaultTunnel(provider().id(), tunnel.src(), tunnel.dst(), tunnel.type(), state, tunnel.groupId(), tunnel.id(), tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
    store.createOrUpdateTunnel(storedTunnel, state);
}
#end_block

#method_before
private Ip4Address getHostIpfromOpenstackPort(OpenstackPort openstackPort) {
    Device device = getDevicefromOpenstackPort(openstackPort);
    return getIPAddressforDevice(device);
}
#method_after
private Ip4Address getHostIpfromOpenstackPort(OpenstackPort openstackPort) {
    Device device = getDevicefromOpenstackPort(openstackPort);
    return config.nodes().get(device.id());
}
#end_block

#method_before
private boolean findPortinDevice(Device d, String openstackPortName) {
    Port port = deviceService.getPorts(d.id()).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).iterator().next();
    return port != null;
}
#method_after
private boolean findPortinDevice(Device d, String openstackPortName) {
    Port port = deviceService.getPorts(d.id()).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).findAny().orElse(null);
    return port != null;
}
#end_block

#method_before
private void populateRuleToGateway(Device d, Device gatewayDevice, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.extension(buildNiciraExtenstion(d.id(), getIPAddressforDevice(gatewayDevice)), d.id()).setOutput(getTunnelPort(d.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(d.id(), fo);
}
#method_after
private void populateRuleToGateway(Device d, Device gatewayDevice, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.extension(buildNiciraExtenstion(d.id(), config.nodes().get(gatewayDevice.id())), d.id()).setOutput(getTunnelPort(d.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(d.id(), fo);
}
#end_block

#method_before
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    Device gatewayNode = getGatewayNode();
    Device portNode = deviceService.getDevice(portDeviceId);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    tBuilder.setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), getIPAddressforDevice(portNode)), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#method_after
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    Device gatewayNode = getGatewayNode();
    Device portNode = deviceService.getDevice(portDeviceId);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    tBuilder.setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), config.nodes().get(portNode.id())), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#end_block

#method_before
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP, OpenstackPortInfo portInfo) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(portInfo.vni()).matchIPSrc(IpPrefix.valueOf(portInfo.ip(), SPECIFIC_PRIFIX));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), SPECIFIC_PRIFIX));
    removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
}
#method_after
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP, OpenstackPortInfo portInfo) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(portInfo.vni()).matchIPSrc(IpPrefix.valueOf(portInfo.ip(), PREFIX_LENGTH));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
}
#end_block

#method_before
public void removeL3Rules(Ip4Address vmIp, List<OpenstackRouterInterface> routerInterfaces) {
    if (vmIp == null) {
        return;
    }
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(getGatewayNode())) {
            routerInterfaces.forEach(routerInterface -> {
                String networkId = routingService.networkIdforRouterInterface(routerInterface.portId());
                long vni = getVni(networkId);
                TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
                sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix()).matchTunnelId(vni);
                removeRule(d.id(), sBuilder, ForwardingObjective.Flag.SPECIFIC, ROUTING_RULE_PRIORITY);
            });
        }
    });
}
#method_after
public void removeL3Rules(Ip4Address vmIp, List<OpenstackRouterInterface> routerInterfaces) {
    if (vmIp == null) {
        return;
    }
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(getGatewayNode())) {
            routerInterfaces.forEach(routerInterface -> {
                String networkId = routingService.networkIdForRouterInterface(routerInterface.portId());
                long vni = getVni(networkId);
                TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
                sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix()).matchTunnelId(vni);
                removeRule(d.id(), sBuilder, ForwardingObjective.Flag.SPECIFIC, ROUTING_RULE_PRIORITY);
            });
        }
    });
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    configRegistry.registerConfigFactory(configFactory);
    configService.addListener(configListener);
    deviceService.addListener(internalDeviceListener);
    readConfiguration();
    floatingIpMap = storageService.<String, OpenstackFloatingIP>consistentMapBuilder().withSerializer(Serializer.using(FLOATING_IP_SERIALIZER.build())).withName(FLOATING_IP_MAP_NAME).withApplicationId(appId).build();
    tpPortNumMap = storageService.<Integer, String>consistentMapBuilder().withSerializer(Serializer.using(NUMBER_SERIALIZER.build())).withName(TP_PORT_MAP_NAME).withApplicationId(appId).build();
    routerInterfaceMap = storageService.<String, String>consistentMapBuilder().withSerializer(Serializer.using(ROUTER_INTERFACE_SERIALIZER.build())).withName(ROUTER_INTERFACE_MAP_NAME).withApplicationId(appId).build();
    log.info("onos-openstackrouting started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    configRegistry.registerConfigFactory(configFactory);
    configService.addListener(configListener);
    deviceService.addListener(internalDeviceListener);
    floatingIpMap = storageService.<String, OpenstackFloatingIP>consistentMapBuilder().withSerializer(Serializer.using(FLOATING_IP_SERIALIZER.build())).withName(FLOATING_IP_MAP_NAME).withApplicationId(appId).build();
    tpPortNumMap = storageService.<Integer, String>consistentMapBuilder().withSerializer(Serializer.using(NUMBER_SERIALIZER.build())).withName(TP_PORT_MAP_NAME).withApplicationId(appId).build();
    routerInterfaceMap = storageService.<String, String>consistentMapBuilder().withSerializer(Serializer.using(ROUTER_INTERFACE_SERIALIZER.build())).withName(ROUTER_INTERFACE_MAP_NAME).withApplicationId(appId).build();
    readConfiguration();
    log.info("started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    deviceService.removeListener(internalDeviceListener);
    l3EventExecutorService.shutdown();
    icmpEventExecutorService.shutdown();
    arpEventExecutorService.shutdown();
    floatingIpMap.clear();
    tpPortNumMap.clear();
    routerInterfaceMap.clear();
    log.info("onos-openstackrouting stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    deviceService.removeListener(internalDeviceListener);
    l3EventExecutorService.shutdown();
    icmpEventExecutorService.shutdown();
    arpEventExecutorService.shutdown();
    floatingIpMap.clear();
    tpPortNumMap.clear();
    routerInterfaceMap.clear();
    log.info("stopped");
}
#end_block

#method_before
@Override
public void createFloatingIP(OpenstackFloatingIP openstackFloatingIP) {
    floatingIpMap.put(openstackFloatingIP.id(), openstackFloatingIP);
}
#method_after
@Override
public void createFloatingIP(OpenstackFloatingIP openstackFloatingIp) {
    floatingIpMap.put(openstackFloatingIp.id(), openstackFloatingIp);
}
#end_block

#method_before
@Override
public void updateFloatingIP(OpenstackFloatingIP openstackFloatingIP) {
    if (!floatingIpMap.containsKey(openstackFloatingIP.id())) {
        log.warn("There`s no information about {} in FloatingIpMap", openstackFloatingIP.id());
        return;
    }
    if (openstackFloatingIP.portId() == null || openstackFloatingIP.portId().equals("null")) {
        OpenstackFloatingIP floatingIP = floatingIpMap.get(openstackFloatingIP.id()).value();
        OpenstackPortInfo portInfo = openstackSwitchingService.openstackPortInfo().get(PORTNAME_PREFIX_VM.concat(floatingIP.portId().substring(0, 11)));
        if (portInfo == null) {
            log.warn("There`s no portInfo information about portId {}", floatingIP.portId());
            return;
        }
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, floatingIP, false, portInfo));
        floatingIpMap.replace(floatingIP.id(), openstackFloatingIP);
    } else {
        floatingIpMap.put(openstackFloatingIP.id(), openstackFloatingIP);
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, openstackFloatingIP, true, null));
    }
}
#method_after
@Override
public void updateFloatingIP(OpenstackFloatingIP openstackFloatingIp) {
    if (!floatingIpMap.containsKey(openstackFloatingIp.id())) {
        log.warn("There`s no information about {} in FloatingIpMap", openstackFloatingIp.id());
        return;
    }
    if (openstackFloatingIp.portId() == null || openstackFloatingIp.portId().equals("null")) {
        OpenstackFloatingIP floatingIp = floatingIpMap.get(openstackFloatingIp.id()).value();
        OpenstackPortInfo portInfo = openstackSwitchingService.openstackPortInfo().get(PORTNAME_PREFIX_VM.concat(floatingIp.portId().substring(0, 11)));
        if (portInfo == null) {
            log.warn("There`s no portInfo information about portId {}", floatingIp.portId());
            return;
        }
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, floatingIp, false, portInfo));
        floatingIpMap.replace(floatingIp.id(), openstackFloatingIp);
    } else {
        floatingIpMap.put(openstackFloatingIp.id(), openstackFloatingIp);
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, openstackFloatingIp, true, null));
    }
}
#end_block

#method_before
@Override
public void updateRouter(OpenstackRouter openstackRouter) {
    if (openstackRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        Ip4Address externalIp = openstackRouter.gatewayExternalInfo().externalFixedIps().values().stream().iterator().next();
        Optional<OpenstackRouter> router = getRouterfromExternalIp(externalIp);
        if (router.isPresent()) {
            checkExternalConnection(router.get(), getOpenstackRouterInterface(router.get()));
        } else {
            log.debug("UpdateRouter failed because there's no router information that matched" + "externalIp {} ", externalIp.toString());
        }
    } else {
        unsetExternalConnection();
    }
}
#method_after
@Override
public void updateRouter(OpenstackRouter openstackRouter) {
    if (openstackRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        checkExternalConnection(openstackRouter, getOpenstackRouterInterface(openstackRouter));
    } else {
        unsetExternalConnection();
    }
}
#end_block

#method_before
@Override
public void removeRouterInterface(OpenstackRouterInterface routerInterface) {
    OpenstackRouter router = openstackService.router(routerInterface.id());
    Collection<OpenstackRouterInterface> interfaceList = getOpenstackRouterInterface(router);
    if (interfaceList.size() == 1) {
        List<OpenstackRouterInterface> newList = Lists.newArrayList();
        newList.add(routerInterface);
        interfaceList.forEach(i -> removeL3RulesforRouterInterface(i, router, newList));
    }
    removeL3RulesforRouterInterface(routerInterface, router, null);
    rulePopulator.removeExternalRules(routerInterface);
    routerInterfaceMap.remove(routerInterface.portId());
}
#method_after
@Override
public void removeRouterInterface(OpenstackRouterInterface routerInterface) {
    OpenstackRouter router = openstackService.router(routerInterface.id());
    Collection<OpenstackRouterInterface> interfaceList = getOpenstackRouterInterface(router);
    if (interfaceList.size() == 1) {
        List<OpenstackRouterInterface> newList = Lists.newArrayList();
        newList.add(routerInterface);
        interfaceList.forEach(i -> removeL3RulesForRouterInterface(i, router, newList));
    }
    removeL3RulesForRouterInterface(routerInterface, router, null);
    rulePopulator.removeExternalRules(routerInterface);
    routerInterfaceMap.remove(routerInterface.portId());
}
#end_block

#method_before
private void readConfiguration() {
    config = configService.getConfig(appId, OpenstackRoutingConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    checkNotNull(config.physicalRouterMac());
    checkNotNull(config.gatewayBridgeId());
    checkNotNull(config.gatewayExternalInterfaceMac());
    checkNotNull(config.gatewayExternalInterfaceName());
    log.debug("Configured info: {}, {}, {}, {}", config.physicalRouterMac(), config.gatewayBridgeId(), config.gatewayExternalInterfaceMac(), config.gatewayExternalInterfaceName());
    rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
    openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, openstackService, config, openstackSwitchingService);
    openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, config);
    openstackIcmpHandler.requestPacket(appId);
    openstackArpHandler.requestPacket(appId);
    reloadInitL3Rules();
    log.info("OpenstackRouting configured");
}
#method_after
private void readConfiguration() {
    config = configService.getConfig("openstacknetworking", OpenstackNetworkingConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    checkNotNull(config.physicalRouterMac());
    checkNotNull(config.gatewayBridgeId());
    checkNotNull(config.gatewayExternalInterfaceMac());
    checkNotNull(config.gatewayExternalInterfaceName());
    log.warn("Configured info: {}, {}, {}, {}", config.physicalRouterMac(), config.gatewayBridgeId(), config.gatewayExternalInterfaceMac(), config.gatewayExternalInterfaceName());
    rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
    openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, openstackService, config, openstackSwitchingService);
    openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, config);
    openstackIcmpHandler.requestPacket(appId);
    openstackArpHandler.requestPacket(appId);
    reloadInitL3Rules();
    log.info("OpenstackRouting configured");
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (!event.configClass().equals(OpenstackRoutingConfig.class)) {
        return;
    }
    if (event.type().equals(NetworkConfigEvent.Type.CONFIG_ADDED) || event.type().equals(NetworkConfigEvent.Type.CONFIG_UPDATED)) {
        l3EventExecutorService.execute(OpenstackRoutingManager.this::readConfiguration);
        rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config);
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    if (!event.configClass().equals(OpenstackNetworkingConfig.class)) {
        return;
    }
    if (event.type().equals(NetworkConfigEvent.Type.CONFIG_ADDED) || event.type().equals(NetworkConfigEvent.Type.CONFIG_UPDATED)) {
        l3EventExecutorService.execute(OpenstackRoutingManager.this::readConfiguration);
    }
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint9() {
    exceptionname.expect(IllegalStateException.class);
    exceptionname.expectMessage("Names cannot some characters");
    SdxL2ConnectionPoint scp9a = SdxL2ConnectionPoint.sdxl2ConnectionPoint("NA,1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp9b = SdxL2ConnectionPoint.sdxl2ConnectionPoint("{NA2}", CP2, VLANS2, CEMAC2);
    SdxL2ConnectionPoint scp9c = SdxL2ConnectionPoint.sdxl2ConnectionPoint("NA3,elementId=50", CP3, VLANS3, CEMAC3);
}
#method_after
@Test
public void testSdxL2ConnectionPoint9() {
    exceptionname.expect(IllegalStateException.class);
    exceptionname.expectMessage("Names cannot contain some special characters");
    SdxL2ConnectionPoint scp9a = SdxL2ConnectionPoint.sdxl2ConnectionPoint("NA,1", CP1, VLANS1, CEMAC1);
    SdxL2ConnectionPoint scp9b = SdxL2ConnectionPoint.sdxl2ConnectionPoint("{NA2}", CP2, VLANS2, CEMAC2);
    SdxL2ConnectionPoint scp9c = SdxL2ConnectionPoint.sdxl2ConnectionPoint("NA3,elementId=50", CP3, VLANS3, CEMAC3);
}
#end_block

#method_before
@Test
public void testSdxL2ConnectionPoint12() {
    SdxL2ConnectionPoint scp12 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("AQ1", CP1, VLANS12, CEMAC5);
}
#method_after
@Test
public void testSdxL2ConnectionPoint12() {
    SdxL2ConnectionPoint scp12 = SdxL2ConnectionPoint.sdxl2ConnectionPoint("AQ1", CP1, VLANS12, CEMAC5);
    List<VlanId> vlanIdList = new ArrayList<>();
    vlanIdList.add(VlanId.vlanId(Short.parseShort("2")));
    vlanIdList.add(VlanId.vlanId(Short.parseShort("6")));
    assertEquals(vlanIdList, scp12.vlanIds());
}
#end_block

#method_before
public static SdxL2ConnectionPoint sdxl2ConnectionPoint(String name, String connectPoint, String vlans, String mac) {
    checkNotNull(connectPoint);
    checkNotNull(vlans);
    checkState(!(name.contains(",") || name.contains("-") || name.contains("vlanid=") || name.contains("ConnectPoint{") || name.contains("elementId=") || name.contains("portNumber=") || name.contains("{") || name.contains("}") || name.contains("|")), "Names cannot some characters");
    checkNotNull(mac);
    ConnectPoint connectionPoint = ConnectPoint.deviceConnectPoint(connectPoint);
    String[] splitted = vlans.split(",");
    checkArgument(splitted.length != 0, "At least '-1' value");
    List<VlanId> vlanslist = new ArrayList<>();
    for (String vlan : splitted) {
        if (!vlanslist.contains(VlanId.vlanId(Short.parseShort(vlan))) && Short.parseShort(vlan) != -1 && Short.parseShort(vlan) != 1) {
            vlanslist.add(VlanId.vlanId(Short.parseShort(vlan)));
        }
    }
    /* MacAddress macAddress = MacAddress.ZERO;*/
    /* To do only with Mac tunnels */
    MacAddress macAddress = MacAddress.valueOf(mac);
    return new SdxL2ConnectionPoint(name, connectionPoint, vlanslist, macAddress);
}
#method_after
public static SdxL2ConnectionPoint sdxl2ConnectionPoint(String name, String connectPoint, String vlans, String mac) {
    checkNotNull(connectPoint);
    checkNotNull(vlans);
    checkState(!(name.contains(",") || name.contains("-") || name.contains("vlanid=") || name.contains("ConnectPoint{") || name.contains("elementId=") || name.contains("portNumber=") || name.contains("{") || name.contains("}") || name.contains("|")), "Names cannot contain some special characters");
    checkNotNull(mac);
    ConnectPoint connectionPoint = ConnectPoint.deviceConnectPoint(connectPoint);
    String[] splitted = vlans.split(",");
    checkArgument(splitted.length != 0, "At least '-1' or '1' as value");
    List<VlanId> vlanslist = new ArrayList<>();
    for (String vlan : splitted) {
        if (!vlanslist.contains(VlanId.vlanId(Short.parseShort(vlan))) && Short.parseShort(vlan) != -1 && Short.parseShort(vlan) != 1) {
            vlanslist.add(VlanId.vlanId(Short.parseShort(vlan)));
        }
    }
    MacAddress macAddress = MacAddress.valueOf(mac);
    return new SdxL2ConnectionPoint(name, connectionPoint, vlanslist, macAddress);
}
#end_block

#method_before
public static SdxL2ConnectionPoint sdxl2ConnectionPoint(String name, String connectPoint, String vlans) {
    checkNotNull(connectPoint);
    checkNotNull(vlans);
    checkState(!(name.contains(",") || name.contains("-") || name.contains("vlanid=") || name.contains("ConnectPoint{") || name.contains("elementId=") || name.contains("portNumber=") || name.contains("{") || name.contains("}") || name.contains("|")), "Names cannot some characters");
    ConnectPoint connectionPoint = ConnectPoint.deviceConnectPoint(connectPoint);
    String[] splitted = vlans.split(",");
    checkArgument(splitted.length != 0, "At least vlanId=1");
    List<VlanId> vlanslist = new ArrayList<>();
    for (String vlan : splitted) {
        if (!vlanslist.contains(VlanId.vlanId(Short.parseShort(vlan))) && Short.parseShort(vlan) != -1 && Short.parseShort(vlan) != 1) {
            vlanslist.add(VlanId.vlanId(Short.parseShort(vlan)));
        }
    }
    MacAddress macAddress = MacAddress.ZERO;
    return new SdxL2ConnectionPoint(name, connectionPoint, vlanslist, macAddress);
}
#method_after
public static SdxL2ConnectionPoint sdxl2ConnectionPoint(String name, String connectPoint, String vlans) {
    checkNotNull(connectPoint);
    checkNotNull(vlans);
    checkState(!(name.contains(",") || name.contains("-") || name.contains("vlanid=") || name.contains("ConnectPoint{") || name.contains("elementId=") || name.contains("portNumber=") || name.contains("{") || name.contains("}") || name.contains("|")), "Names cannot contain some special characters");
    ConnectPoint connectionPoint = ConnectPoint.deviceConnectPoint(connectPoint);
    String[] splitted = vlans.split(",");
    checkArgument(splitted.length != 0, "At least '-1' or '1' as value");
    List<VlanId> vlanslist = new ArrayList<>();
    for (String vlan : splitted) {
        if (!vlanslist.contains(VlanId.vlanId(Short.parseShort(vlan))) && Short.parseShort(vlan) != -1 && Short.parseShort(vlan) != 1) {
            vlanslist.add(VlanId.vlanId(Short.parseShort(vlan)));
        }
    }
    MacAddress macAddress = MacAddress.ZERO;
    return new SdxL2ConnectionPoint(name, connectionPoint, vlanslist, macAddress);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("FlowClassifierId", flowClassifierId).add("TenantId", tenantId).add("Name", name).add("Description", description).add("String", etherType).add("Protocol", protocol).add("MinSrcPortRange", minSrcPortRange).add("MaxSrcPortRange", maxSrcPortRange).add("MinDstPortRange", minDstPortRange).add("MaxDstPortRange", maxDstPortRange).add("SrcIpPrefix", srcIpPrefix).add("DstIpPrefix", dstIpPrefix).add("SrcPort", srcPort).add("DstPort", dstPort).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("FlowClassifierId", flowClassifierId).add("TenantId", tenantId).add("Name", name).add("Description", description).add("String", etherType).add("Protocol", protocol).add("Priority", priority).add("MinSrcPortRange", minSrcPortRange).add("MaxSrcPortRange", maxSrcPortRange).add("MinDstPortRange", minDstPortRange).add("MaxDstPortRange", maxDstPortRange).add("SrcIpPrefix", srcIpPrefix).add("DstIpPrefix", dstIpPrefix).add("SrcPort", srcPort).add("DstPort", dstPort).toString();
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(JavaIdentifierSyntax.getCamelCase(name));
    String javaDoc = UtilConstants.EMPTY_STRING;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else if (type.equals(JavaDocType.TYPE_CONSTRUCTOR)) {
        javaDoc = generateForTypeConstructor(name);
    } else if (type.equals(JavaDocType.UNION_FROM_METHOD)) {
        javaDoc = generateForUnionFrom(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(JavaIdentifierSyntax.getCamelCase(name, null));
    String javaDoc;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else if (type.equals(JavaDocType.TYPE_CONSTRUCTOR)) {
        javaDoc = generateForTypeConstructor(name);
    } else if (type.equals(JavaDocType.UNION_FROM_METHOD)) {
        javaDoc = generateForUnionFrom(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#end_block

#method_before
private static JavaAttributeInfo getAttributeInfoForTheData(JavaQualifiedTypeInfo importInfo, String attributeName, YangType<?> attributeType, YangNode curNode, boolean isListAttribute) {
    JavaAttributeInfo newAttr = new JavaAttributeInfo();
    newAttr.setImportInfo(importInfo);
    newAttr.setIsQualifiedAccess(getIsQualifiedAccessOrAddToImportList(curNode, importInfo));
    newAttr.setAttributeName(getCamelCase(attributeName));
    newAttr.setListAttr(isListAttribute);
    newAttr.setImportInfo(importInfo);
    newAttr.setAttributeType(attributeType);
    return newAttr;
}
#method_after
private static JavaAttributeInfo getAttributeInfoForTheData(JavaQualifiedTypeInfo importInfo, String attributeName, YangType<?> attributeType, YangNode curNode, boolean isListAttribute) {
    JavaAttributeInfo newAttr = new JavaAttributeInfo();
    newAttr.setImportInfo(importInfo);
    newAttr.setIsQualifiedAccess(getIsQualifiedAccessOrAddToImportList(curNode, importInfo));
    newAttr.setAttributeName(getCamelCase(attributeName, null));
    newAttr.setListAttr(isListAttribute);
    newAttr.setImportInfo(importInfo);
    newAttr.setAttributeType(attributeType);
    return newAttr;
}
#end_block

#method_before
public static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + "parseByte";
        case INT16:
            return SHORT_WRAPPER;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + "parseInt";
        case INT64:
            return LONG_WRAPPER;
        case UINT8:
            return SHORT_WRAPPER;
        case UINT16:
            return INTEGER_WRAPPER;
        case UINT32:
            return LONG_WRAPPER;
        case UINT64:
            return BIG_INTEGER;
        case DECIMAL64:
        // TODO: DECIMAL64.
        case STRING:
            return STRING_DATA_TYPE;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        case ENUMERATION:
        // TODO:ENUMERATION.
        case BITS:
        // TODO:BITS
        case BINARY:
        // TODO:BINARY
        case DERIVED:
            return targetDataType + PERIOD + "of";
        default:
            throw new TranslatorException("Given data type is not supported.");
    }
}
#method_after
public static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + PARSE_BYTE;
        case INT16:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case INT64:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT8:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case UINT16:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case UINT32:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT64:
            return NEW + SPACE + BIG_INTEGER;
        case DECIMAL64:
        // TODO: DECIMAL64.
        case STRING:
            return EMPTY_STRING;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        case ENUMERATION:
        // TODO:ENUMERATION.
        case BITS:
        // TODO:BITS
        case BINARY:
        // TODO:BINARY
        case DERIVED:
            return targetDataType + PERIOD + OF;
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName()));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
            default:
                return null;
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
            // TODO:EMPTY
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName()));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
            default:
                return null;
        }
    }
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                return null;
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
            // TODO:EMPTY
            case UNION:
                return getCaptialCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), null));
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                return null;
        }
    }
}
#end_block

#method_before
private static String getPackageFromParent(YangNode parent) {
    if (!(parent instanceof HasJavaFileInfo)) {
        throw new TranslatorException("Invalid child node is being processed.");
    }
    JavaFileInfo parentInfo = ((HasJavaFileInfo) parent).getJavaFileInfo();
    return parentInfo.getPackage() + PERIOD + parentInfo.getJavaName().toLowerCase();
}
#method_after
private static String getPackageFromParent(YangNode parent) {
    if (!(parent instanceof HasJavaFileInfo)) {
        throw new TranslatorException("invalid child node is being processed.");
    }
    JavaFileInfo parentInfo = ((HasJavaFileInfo) parent).getJavaFileInfo();
    return parentInfo.getPackage() + PERIOD + parentInfo.getJavaName().toLowerCase();
}
#end_block

#method_before
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), ENTRY);
    // Validate node identifier.
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), YangConstructType.TYPE_DATA, ctx);
    // Obtain the YANG data type.
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    // Create YANG type object and fill the values.
    YangType<?> type = new YangType();
    type.setNodeIdentifier(nodeIdentifier);
    type.setDataType(yangDataTypes);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) parentNodeOfLeaf, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf list to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) parentNodeOfLeafList, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addType((YangType<?>) type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) unionNode, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) typeDef, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    // Push the type to the stack.
    listener.getParsedDataStack().push(type);
}
#method_after
public static void processTypeEntry(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), ENTRY);
    // Validate node identifier.
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), YangConstructType.TYPE_DATA, ctx);
    // Obtain the YANG data type.
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    // Create YANG type object and fill the values.
    YangType<?> type = new YangType();
    type.setNodeIdentifier(nodeIdentifier);
    type.setDataType(yangDataTypes);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                type.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf list to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addType((YangType<?>) type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) unionNode, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, (YangNode) typeDef, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    // Push the type to the stack.
    listener.getParsedDataStack().push(type);
}
#end_block

#method_before
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        /**
         * Add attribute for augment info's list.
         */
        if (isHasAugmentationExtended()) {
            insertDataIntoJavaFile(file, getAugmentInfoAttribute());
        }
        insertDataIntoJavaFile(file, NEW_LINE);
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
            /**
             * Hash code method.
             */
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
            /**
             * Equals method.
             */
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + IMPL) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
            /**
             * To string method.
             */
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        /**
         * Constructor.
         */
        methods.add(getConstructorStart(className) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, curNode) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    /**
     * Add method for augment info's list.
     */
    if (isHasAugmentationExtended()) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getAugmentInfoListImpl());
        methods.add(getRemoveAugmentationImpl());
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + method + NEW_LINE);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        /**
         * Add attribute for augmented info's list.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            insertDataIntoJavaFile(file, getAugmentedInfoAttribute());
        }
        insertDataIntoJavaFile(file, NEW_LINE);
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
            /**
             * Hash code method.
             */
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
            /**
             * Equals method.
             */
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + IMPL) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
            /**
             * To string method.
             */
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        /**
         * Constructor.
         */
        methods.add(getConstructorStart(className) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, curNode) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    /**
     * Add method for augment info's list.
     */
    if (isHasAugmentationExtended(getExtendsList())) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getAugmentInfoListImpl());
        methods.add(getRemoveAugmentationImpl());
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + method + NEW_LINE);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
/**
 * Sets class to be extended by generated file.
 *
 * @param extendsList list of classes to be extended.
 */
private void setExtendsList(List<String> extendsList) {
    this.extendsList = extendsList;
}
#method_after
/**
 * Sets class to be extended by generated file.
 *
 * @param extendsList list of classes to be extended
 */
private void setExtendsList(List<String> extendsList) {
    this.extendsList = extendsList;
}
#end_block

#method_before
private String parseAttribute(JavaAttributeInfo attr) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(getSmallCase(attr.getAttributeName()));
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    }
}
#method_after
private String parseAttribute(JavaAttributeInfo attr) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(getSmallCase(attr.getAttributeName()), null);
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    }
}
#end_block

#method_before
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setNewAttrInfo(newAttrInfo);
    if (isAttributePresent) {
        if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
            addAttribute(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
            addGetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
            addSetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, generatedJavaFiles);
        }
        if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
            addSetterImpl(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
            addConstructor(newAttrInfo);
        }
        if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
            addHashCodeMethod(newAttrInfo);
        }
        if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
            addEqualsMethod(newAttrInfo);
        }
        if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
            addToStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(newAttrInfo);
        }
    }
    return;
}
#method_after
void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo newAttrInfo) throws IOException {
    setNewAttrInfo(newAttrInfo);
    if (isAttributePresent) {
        if ((generatedTempFiles & ATTRIBUTES_MASK) != 0) {
            addAttribute(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_INTERFACE_MASK) != 0) {
            addGetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & SETTER_FOR_INTERFACE_MASK) != 0) {
            addSetterForInterface(newAttrInfo);
        }
        if ((generatedTempFiles & GETTER_FOR_CLASS_MASK) != 0) {
            addGetterImpl(newAttrInfo, generatedJavaFiles);
        }
        if ((generatedTempFiles & SETTER_FOR_CLASS_MASK) != 0) {
            addSetterImpl(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_IMPL_MASK) != 0) {
            addConstructor(newAttrInfo);
        }
        if ((generatedTempFiles & HASH_CODE_IMPL_MASK) != 0) {
            addHashCodeMethod(newAttrInfo);
        }
        if ((generatedTempFiles & EQUALS_IMPL_MASK) != 0) {
            addEqualsMethod(newAttrInfo);
        }
        if ((generatedTempFiles & TO_STRING_IMPL_MASK) != 0) {
            addToStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(newAttrInfo);
        }
        if ((generatedTempFiles & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(newAttrInfo);
        }
    }
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    setCurYangNode(curNode);
    List<String> imports = new ArrayList<>();
    if (curNode instanceof HasJavaImportData && isAttributePresent) {
        imports = ((HasJavaImportData) curNode).getJavaImportData().getImports(getNewAttrInfo());
    }
    /**
     * Prepares java file generator for extends list.
     */
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    /**
     * Generate java code.
     */
    if ((fileType & INTERFACE_MASK) != 0 | (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /**
         * Adds import for HasAugmentation class.
         */
        if (isExtendHasAugmentation(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isExtendAugmentedInfo(getExtendsList())) {
            addAugmentInfoImport(curNode, imports, true);
        }
        /**
         * Create interface file.
         */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create builder interface file.
         */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append builder interface file to interface file and close it.
             */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isExtendHasAugmentation(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isExtendAugmentedInfo(getExtendsList())) {
            addAugmentInfoImport(curNode, imports, false);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 | (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isExtendHasAugmentation(getExtendsList())) {
            addAugmentInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        /**
         * Create builder class file.
         */
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create impl class file.
         */
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append impl class to builder class and close it.
             */
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    /**
     * Creates type def class file.
     */
    if ((fileType & GENERATE_TYPEDEF_CLASS) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        setTypedefClassJavaFileHandle(getJavaFileHandle(getJavaClassName(TYPEDEF_CLASS_FILE_NAME_SUFFIX)));
        setTypedefClassJavaFileHandle(generateTypeDefClassFile(getTypedefClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type class file.
     */
    if ((fileType & GENERATE_UNION_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypeClassJavaFileHandle(getJavaFileHandle(getJavaClassName(UNION_TYPE_CLASS_FILE_NAME_SUFFIX)));
        setTypeClassJavaFileHandle(generateUnionClassFile(getTypeClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Close all the file handles.
     */
    close(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    setCurYangNode(curNode);
    List<String> imports = new ArrayList<>();
    if (curNode instanceof HasJavaImportData && isAttributePresent) {
        imports = ((HasJavaImportData) curNode).getJavaImportData().getImports(getNewAttrInfo());
    }
    /**
     * Prepares java file generator for extends list.
     */
    prepareJavaFileGeneratorForExtendsList(getExtendsList());
    /**
     * Generate java code.
     */
    if ((fileType & INTERFACE_MASK) != 0 | (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /**
         * Adds import for HasAugmentation class.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, true);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
        }
        /**
         * Create interface file.
         */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create builder interface file.
         */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append builder interface file to interface file and close it.
             */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (isHasAugmentationExtended(getExtendsList())) {
            addHasAugmentationImport(curNode, imports, false);
        }
        if (isAugmentedInfoExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, false);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 | (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent) {
            addImportsToStringAndHasCodeMethods(curNode, imports);
        }
        if (isHasAugmentationExtended(getExtendsList())) {
            addAugmentedInfoImport(curNode, imports, true);
            addArrayListImport(curNode, imports, true);
        }
        /**
         * Create builder class file.
         */
        setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
        setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), imports, curNode, isAttributePresent));
        /**
         * Create impl class file.
         */
        if ((fileType & IMPL_CLASS_MASK) != 0) {
            setImplClassJavaFileHandle(getJavaFileHandle(getJavaClassName(IMPL_CLASS_FILE_NAME_SUFFIX)));
            setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent));
            /**
             * Append impl class to builder class and close it.
             */
            mergeJavaFiles(getImplClassJavaFileHandle(), getBuilderClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getBuilderClassJavaFileHandle(), getJavaClassDefClose());
    }
    /**
     * Creates type def class file.
     */
    if ((fileType & GENERATE_TYPEDEF_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypedefClassJavaFileHandle(getJavaFileHandle(getJavaClassName(TYPEDEF_CLASS_FILE_NAME_SUFFIX)));
        setTypedefClassJavaFileHandle(generateTypeDefClassFile(getTypedefClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Creates type class file.
     */
    if ((fileType & GENERATE_UNION_CLASS) != 0) {
        addImportsToStringAndHasCodeMethods(curNode, imports);
        setTypeClassJavaFileHandle(getJavaFileHandle(getJavaClassName(UNION_TYPE_CLASS_FILE_NAME_SUFFIX)));
        setTypeClassJavaFileHandle(generateUnionClassFile(getTypeClassJavaFileHandle(), curNode, imports));
    }
    /**
     * Close all the file handles.
     */
    close(false);
}
#end_block

#method_before
public static String getConstructor(String yangName, JavaAttributeInfo attr) {
    String attributeName = getSmallCase(attr.getAttributeName());
    String constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCaptialCase(getCamelCase(attributeName)) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    return constructor;
}
#method_after
public static String getConstructor(String yangName, JavaAttributeInfo attr) {
    String attributeName = getSmallCase(attr.getAttributeName());
    String constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, null) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCaptialCase(getCamelCase(attributeName, null)) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    return constructor;
}
#end_block

#method_before
public static String getRemoveAugmentationImpl() {
    String method = FOUR_SPACE_INDENTATION;
    method = method + getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + "remove" + AUGMENTATION + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_METHOD_PREFIX + AUGMENTED_INFO + LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + "clear" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return method;
}
#method_after
public static String getRemoveAugmentationImpl() {
    String method = FOUR_SPACE_INDENTATION;
    method = method + getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + VOID + SPACE + "remove" + AUGMENTATION + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_METHOD_PREFIX + AUGMENTED_INFO + LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + CLEAR + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return method;
}
#end_block

#method_before
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, String pkg) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(pkg);
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(codeGenDir);
}
#method_after
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName(), yangPlugin.getConflictResolver())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) javaCodeGeneratorInfo));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(yangPlugin.getCodeGenDir());
}
#end_block

#method_before
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, codeGenDir);
    generateTempFiles(javaCodeGeneratorInfo, codeGenDir);
    javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
    /**
     * For augmentation of nodes.
     */
    if (javaCodeGeneratorInfo instanceof YangContainer || javaCodeGeneratorInfo instanceof YangCase || javaCodeGeneratorInfo instanceof YangChoice || javaCodeGeneratorInfo instanceof YangInput || javaCodeGeneratorInfo instanceof YangList || javaCodeGeneratorInfo instanceof YangNotification || javaCodeGeneratorInfo instanceof YangOutput) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(HAS_AUGMENTATION);
    } else if (javaCodeGeneratorInfo instanceof YangAugment) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(AUGMENTED_INFO);
    }
}
#method_after
public static void generateCodeOfNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
    javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) javaCodeGeneratorInfo, isMultiInstance);
    /**
     * For augmentation of nodes.
     */
    if (javaCodeGeneratorInfo instanceof YangContainer || javaCodeGeneratorInfo instanceof YangCase || javaCodeGeneratorInfo instanceof YangChoice || javaCodeGeneratorInfo instanceof YangInput || javaCodeGeneratorInfo instanceof YangList || javaCodeGeneratorInfo instanceof YangNotification || javaCodeGeneratorInfo instanceof YangOutput) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(HAS_AUGMENTATION);
    } else if (javaCodeGeneratorInfo instanceof YangAugment) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addToExtendsList(AUGMENTED_INFO);
    }
}
#end_block

#method_before
public static void generateCodeOfType(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, codeGenDir);
    generateTempFiles(javaCodeGeneratorInfo, codeGenDir);
}
#method_after
public static void generateCodeOfType(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, boolean isMultiInstance) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
}
#end_block

#method_before
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir, String rootPkg) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, codeGenDir, rootPkg);
    generateTempFiles(javaCodeGeneratorInfo, codeGenDir);
}
#method_after
public static void generateCodeOfRootNode(JavaCodeGeneratorInfo javaCodeGeneratorInfo, YangPluginConfig yangPlugin, String rootPkg) throws IOException {
    if (!(javaCodeGeneratorInfo instanceof YangNode)) {
    // TODO:throw exception
    }
    updatePackageInfo(javaCodeGeneratorInfo, yangPlugin, rootPkg);
    generateTempFiles(javaCodeGeneratorInfo, yangPlugin.getCodeGenDir());
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfType(this, codeGenDir, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfType(this, yangPlugin, false);
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfType(this, codeGenDir, false);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    generateCodeOfType(this, yangPlugin, false);
}
#end_block

#method_before
@Test
public void processUnionTranslator() throws IOException, ParserException {
    clean("src/test/org/onosproject/yang");
    YangNode node = manager.getDataModel("src/test/resources/UnionTranslator.yang");
    generateJavaCode(node, "target/UnionTestGenFile");
}
#method_after
@Test
public void processUnionTranslator() throws IOException, ParserException {
    clean("src/test/org/onosproject/yang");
    YangNode node = manager.getDataModel("src/test/resources/UnionTranslator.yang");
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/UnionTestGenFile");
    generateJavaCode(node, yangPluginConfig);
    clean("target/UnionTestGenFile");
}
#end_block

#method_before
private Instruction decodeExtension() {
    ObjectNode node = (ObjectNode) json.get(InstructionCodec.EXTENSION);
    if (node != null) {
        DeviceId deviceId = getDeviceId();
        ExtensionTreatmentCodec interpreter;
        DriverHandler driverHandler = getDriver(deviceId);
        if (driverHandler.hasBehaviour(ExtensionTreatmentCodec.class)) {
            interpreter = driverHandler.behaviour(ExtensionTreatmentCodec.class);
        } else {
            interpreter = null;
        }
        ExtensionTreatment treatment = interpreter.decode(node, null);
        return Instructions.extension(treatment, deviceId);
    }
    return null;
}
#method_after
private Instruction decodeExtension() {
    ObjectNode node = (ObjectNode) json.get(InstructionCodec.EXTENSION);
    if (node != null) {
        DeviceId deviceId = getDeviceId();
        ServiceDirectory serviceDirectory = new DefaultServiceDirectory();
        DeviceService deviceService = serviceDirectory.get(DeviceService.class);
        Device device = deviceService.getDevice(deviceId);
        if (device.is(ExtensionTreatmentCodec.class)) {
            ExtensionTreatmentCodec treatmentCodec = device.as(ExtensionTreatmentCodec.class);
            ExtensionTreatment treatment = treatmentCodec.decode(node, null);
            return Instructions.extension(treatment, deviceId);
        } else {
            log.warn("There is no codec to decode extension for device {}", deviceId.toString());
        }
    }
    return null;
}
#end_block

#method_before
private void encodeExtension(ObjectNode result) {
    final Instructions.ExtensionInstructionWrapper extensionInstruction = (Instructions.ExtensionInstructionWrapper) instruction;
    ExtensionTreatmentCodec treatmentCodec;
    DriverHandler driverHandler = getDriver(extensionInstruction.deviceId());
    if (driverHandler.hasBehaviour(ExtensionTreatmentCodec.class)) {
        treatmentCodec = driverHandler.behaviour(ExtensionTreatmentCodec.class);
    } else {
        treatmentCodec = null;
    }
    result.set(InstructionCodec.EXTENSION, treatmentCodec.encode(extensionInstruction.extensionInstruction(), context));
}
#method_after
private void encodeExtension(ObjectNode result) {
    final Instructions.ExtensionInstructionWrapper extensionInstruction = (Instructions.ExtensionInstructionWrapper) instruction;
    DeviceId deviceId = extensionInstruction.deviceId();
    ServiceDirectory serviceDirectory = new DefaultServiceDirectory();
    DeviceService deviceService = serviceDirectory.get(DeviceService.class);
    Device device = deviceService.getDevice(deviceId);
    if (device.is(ExtensionTreatmentCodec.class)) {
        ExtensionTreatmentCodec treatmentCodec = device.as(ExtensionTreatmentCodec.class);
        ObjectNode node = treatmentCodec.encode(extensionInstruction.extensionInstruction(), context);
        result.set(InstructionCodec.EXTENSION, node);
    } else {
        log.warn("There is no codec to encode extension for device {}", deviceId.toString());
    }
}
#end_block

#method_before
public void processArpPacketFromRouter(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    log.info("arpEvent called from {} to {}", Ip4Address.valueOf(((IPv4) ethernet.getPayload()).getSourceAddress()).toString(), Ip4Address.valueOf(((IPv4) ethernet.getPayload()).getDestinationAddress()).toString());
    ARP arp = (ARP) ethernet.getPayload();
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    MacAddress targetMac = getTargetMacForTargetIp(targetIp.getIp4Address());
    if (targetMac == MacAddress.NONE) {
        return;
    }
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#method_after
public void processArpPacketFromRouter(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    ARP arp = (ARP) ethernet.getPayload();
    log.debug("arpEvent called from {} to {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    MacAddress targetMac = getTargetMacForTargetIp(targetIp.getIp4Address());
    if (targetMac == MacAddress.NONE) {
        return;
    }
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#end_block

#method_before
private String getToken() {
    if (isTokenInvalid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        Invocation.Builder builder = getClientBuilder(keystoneUrl + URI_TOKENS);
        String response = builder.accept(MediaType.APPLICATION_JSON).post(Entity.json(request), String.class);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path(PATH_ACCESS).path(PATH_TOKEN).path(PATH_ID).asText();
        } catch (IOException e) {
            log.warn("getToken()", e);
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#method_after
private String getToken() {
    if (!isTokenValid()) {
        String request = "{\"auth\": {\"tenantName\": \"admin\", " + "\"passwordCredentials\":  {\"username\": \"" + userName + "\",\"password\": \"" + pass + "\"}}}";
        Invocation.Builder builder = getClientBuilder(keystoneUrl + URI_TOKENS);
        String response = builder.accept(MediaType.APPLICATION_JSON).post(Entity.json(request), String.class);
        ObjectMapper mapper = new ObjectMapper();
        try {
            ObjectNode node = (ObjectNode) mapper.readTree(response);
            tokenId = node.path(PATH_ACCESS).path(PATH_TOKEN).path(PATH_ID).asText();
            tokenExpires = node.path(PATH_ACCESS).path(PATH_TOKEN).path(PATH_EXPIRES).asText();
        } catch (IOException e) {
            log.warn("getToken()", e);
        }
        log.debug("token response:" + response);
    }
    return tokenId;
}
#end_block

#method_before
@Override
public FlowRule build() {
    checkArgument((flowId != null) ^ (appId != null), "Either an application" + " id or a cookie must be supplied");
    checkNotNull(selector, "Traffic selector cannot be null");
    checkArgument(timeout != null || permanent != null, "Must either have " + "a timeout or be permanent");
    checkNotNull(deviceId, "Must refer to a device");
    checkNotNull(priority, "Priority cannot be null");
    checkArgument(priority >= MIN_PRIORITY, "Priority cannot be less than " + MIN_PRIORITY);
    // the flow ID directly
    if (appId != null) {
        flowId = computeFlowId(appId);
    }
    return new DefaultFlowRule(deviceId, selector, treatment, priority, flowId, permanent, timeout, tableId);
}
#method_after
@Override
public FlowRule build() {
    FlowId localFlowId;
    checkArgument((flowId != null) ^ (appId != null), "Either an application" + " id or a cookie must be supplied");
    checkNotNull(selector, "Traffic selector cannot be null");
    checkArgument(timeout != null || permanent != null, "Must either have " + "a timeout or be permanent");
    checkNotNull(deviceId, "Must refer to a device");
    checkNotNull(priority, "Priority cannot be null");
    checkArgument(priority >= MIN_PRIORITY, "Priority cannot be less than " + MIN_PRIORITY);
    // the flow ID directly
    if (appId != null) {
        localFlowId = computeFlowId(appId);
    } else {
        localFlowId = flowId;
    }
    return new DefaultFlowRule(deviceId, selector, treatment, priority, localFlowId, permanent, timeout, tableId);
}
#end_block

#method_before
private int hash() {
    Funnel<TrafficSelector> selectorFunnel = (from, into) -> from.criteria().stream().forEach(c -> into.putBytes(c.toString().getBytes()));
    HashFunction hashFunction = Hashing.murmur3_32();
    HashCode hashCode = hashFunction.newHasher().putBytes(deviceId.toString().getBytes()).putObject(selector, selectorFunnel).putInt(priority).putInt(tableId).hash();
    return hashCode.asInt();
}
#method_after
private int hash() {
    Funnel<TrafficSelector> selectorFunnel = (from, into) -> from.criteria().stream().forEach(c -> into.putString(c.toString(), Charsets.UTF_8));
    HashFunction hashFunction = Hashing.murmur3_32();
    HashCode hashCode = hashFunction.newHasher().putString(deviceId.toString(), Charsets.UTF_8).putObject(selector, selectorFunnel).putInt(priority).putInt(tableId).hash();
    return hashCode.asInt();
}
#end_block

#method_before
@Override
public void processClientMessage(PccId pccId, PcepMessage msg) {
    PcepClient pc = getClient(pccId);
    switch(msg.getType()) {
        case NONE:
            break;
        case OPEN:
            break;
        case KEEP_ALIVE:
            break;
        case PATH_COMPUTATION_REQUEST:
            break;
        case PATH_COMPUTATION_REPLY:
            break;
        case NOTIFICATION:
            break;
        case ERROR:
            break;
        case INITIATE:
            if (!pc.capability().statefulPceCapability() && !pc.capability().pcInstantiationCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case UPDATE:
            if (!pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case LABEL_UPDATE:
            if (!pc.capability().pceccCapability() && !pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case CLOSE:
            log.info("Sending Close Message  to {" + pccId.toString() + "}");
            pc.sendMessage(Collections.singletonList(pc.factory().buildCloseMsg().build()));
            // now disconnect client
            pc.disconnectClient();
            break;
        case REPORT:
            // Only update the listener if respective capability is supported else send PCEP-ERR msg
            if (pc.capability().statefulPceCapability()) {
                for (PcepEventListener l : pcepEventListener) {
                    l.handleMessage(pccId, msg);
                }
            } else {
                // Send PCEP-ERROR message.
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case LABEL_RANGE_RESERV:
            break;
        case MAX:
            break;
        case END:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void processClientMessage(PccId pccId, PcepMessage msg) {
    PcepClient pc = getClient(pccId);
    switch(msg.getType()) {
        case NONE:
            break;
        case OPEN:
            break;
        case KEEP_ALIVE:
            break;
        case PATH_COMPUTATION_REQUEST:
            break;
        case PATH_COMPUTATION_REPLY:
            break;
        case NOTIFICATION:
            break;
        case ERROR:
            break;
        case INITIATE:
            if (!pc.capability().pcInstantiationCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case UPDATE:
            if (!pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case LABEL_UPDATE:
            if (!pc.capability().pceccCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case CLOSE:
            log.info("Sending Close Message  to {" + pccId.toString() + "}");
            pc.sendMessage(Collections.singletonList(pc.factory().buildCloseMsg().build()));
            // now disconnect client
            pc.disconnectClient();
            break;
        case REPORT:
            // Only update the listener if respective capability is supported else send PCEP-ERR msg
            if (pc.capability().statefulPceCapability()) {
                for (PcepEventListener l : pcepEventListener) {
                    l.handleMessage(pccId, msg);
                }
            } else {
                // Send PCEP-ERROR message.
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case LABEL_RANGE_RESERV:
            break;
        case MAX:
            break;
        case END:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void processClientMessage(PccId pccId, PcepMessage msg) {
    PcepClient pc = getClient(pccId);
    switch(msg.getType()) {
        case NONE:
            break;
        case OPEN:
            break;
        case KEEP_ALIVE:
            // log.debug("Sending Keep Alive Message  to {" + pccIpAddress.toString() + "}");
            pc.sendMessage(Collections.singletonList(pc.factory().buildKeepaliveMsg().build()));
            break;
        case PATH_COMPUTATION_REQUEST:
            break;
        case PATH_COMPUTATION_REPLY:
            break;
        case NOTIFICATION:
            break;
        case ERROR:
            break;
        case CLOSE:
            // log.debug("Sending Close Message  to { }", pccIpAddress.toString());
            pc.sendMessage(Collections.singletonList(pc.factory().buildCloseMsg().build()));
            break;
        case INITIATE:
            if (!pc.capability().statefulPceCapability() && !pc.capability().pcInstantiationCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case REPORT:
            // Only update the listener if respective capability is supported else send PCEP-ERR msg
            if (pc.capability().statefulPceCapability()) {
                for (PcepEventListener l : pcepEventListener) {
                    l.handleMessage(pccId, msg);
                }
            } else {
                // Send PCEP-ERROR message.
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case UPDATE:
            if (!pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case LABEL_UPDATE:
            if (!pc.capability().pceccCapability() && !pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), PcepErrorDetailInfo.ERROR_TYPE_19, PcepErrorDetailInfo.ERROR_VALUE_5)));
            }
            break;
        case MAX:
            break;
        case END:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void processClientMessage(PccId pccId, PcepMessage msg) {
    PcepClient pc = getClient(pccId);
    switch(msg.getType()) {
        case NONE:
            break;
        case OPEN:
            break;
        case KEEP_ALIVE:
            // log.debug("Sending Keep Alive Message  to {" + pccIpAddress.toString() + "}");
            pc.sendMessage(Collections.singletonList(pc.factory().buildKeepaliveMsg().build()));
            break;
        case PATH_COMPUTATION_REQUEST:
            break;
        case PATH_COMPUTATION_REPLY:
            break;
        case NOTIFICATION:
            break;
        case ERROR:
            break;
        case CLOSE:
            // log.debug("Sending Close Message  to { }", pccIpAddress.toString());
            pc.sendMessage(Collections.singletonList(pc.factory().buildCloseMsg().build()));
            break;
        case INITIATE:
            if (!pc.capability().pcInstantiationCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case REPORT:
            // Only update the listener if respective capability is supported else send PCEP-ERR msg
            if (pc.capability().statefulPceCapability()) {
                for (PcepEventListener l : pcepEventListener) {
                    l.handleMessage(pccId, msg);
                }
            } else {
                // Send PCEP-ERROR message.
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case UPDATE:
            if (!pc.capability().statefulPceCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case LABEL_UPDATE:
            if (!pc.capability().pceccCapability()) {
                pc.sendMessage(Collections.singletonList(getErrMsg(pc.factory(), ERROR_TYPE_19, ERROR_VALUE_5)));
            }
            break;
        case MAX:
            break;
        case END:
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // Get the pcc client
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // If stateful and PC Initiation capability is not supported by client not sending Initiate msg
    if (pc.capability().statefulPceCapability() && pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#method_after
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // Get the pcc client
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // If stateful and PC Initiation capability is not supported by client not sending Initiate msg
    if (pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().statefulPceCapability() && pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#method_after
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepSetupTunnel(tunnel, path, pc);
    }
}
#end_block

#method_before
@Override
public void releaseTunnel(Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    if (pc.capability() != null && pc.capability().statefulPceCapability() && pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#method_after
@Override
public void releaseTunnel(Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#end_block

#method_before
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().statefulPceCapability() && pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#method_after
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    if (pc.capability().pcInstantiationCapability()) {
        pcepReleaseTunnel(tunnel, pc);
    }
}
#end_block

#method_before
private void capabilityNegotiation(PcepOpenMsg pOpenmsg) {
    LinkedList<PcepValueType> tlvList = pOpenmsg.getPcepOpenObject().getOptionalTlv();
    boolean pceccCapability = false;
    boolean statefulPceCapability = false;
    boolean pcInstantiationCapability = false;
    ListIterator<PcepValueType> listIterator = tlvList.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        switch(tlv.getType()) {
            case PceccCapabilityTlv.TYPE:
                pceccCapability = true;
                break;
            case StatefulPceCapabilityTlv.TYPE:
                statefulPceCapability = true;
                StatefulPceCapabilityTlv stetefulPcCapTlv = (StatefulPceCapabilityTlv) tlv;
                if (stetefulPcCapTlv.getIFlag()) {
                    pcInstantiationCapability = true;
                }
                break;
            default:
                continue;
        }
    }
    this.pceccCapability = pceccCapability;
    this.statefulPceCapability = statefulPceCapability;
    this.pcInstantiationCapability = pcInstantiationCapability;
}
#method_after
private void capabilityNegotiation(PcepOpenMsg pOpenmsg) {
    LinkedList<PcepValueType> tlvList = pOpenmsg.getPcepOpenObject().getOptionalTlv();
    boolean pceccCapability = false;
    boolean statefulPceCapability = false;
    boolean pcInstantiationCapability = false;
    ListIterator<PcepValueType> listIterator = tlvList.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        switch(tlv.getType()) {
            case PceccCapabilityTlv.TYPE:
                pceccCapability = true;
                break;
            case StatefulPceCapabilityTlv.TYPE:
                statefulPceCapability = true;
                StatefulPceCapabilityTlv stetefulPcCapTlv = (StatefulPceCapabilityTlv) tlv;
                if (stetefulPcCapTlv.getIFlag()) {
                    pcInstantiationCapability = true;
                }
                break;
            default:
                continue;
        }
    }
    this.capability = new ClientCapability(pceccCapability, statefulPceCapability, pcInstantiationCapability);
}
#end_block

#method_before
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        insertDataIntoJavaFile(file, NEW_LINE);
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
            /**
             * Hash code method.
             */
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
            /**
             * Equals method.
             */
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + IMPL) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
            /**
             * To string method.
             */
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        /**
         * Constructor.
         */
        methods.add(getConstructorStart(className) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, curNode) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + method + NEW_LINE);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, IMPL_CLASS_MASK, null, path);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        /**
         * Add attribute for augmented info's list.
         */
        if (isHasAugmentationExtended(getExtendsList())) {
            insertDataIntoJavaFile(file, getAugmentedInfoAttribute());
        }
        insertDataIntoJavaFile(file, NEW_LINE);
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
            /**
             * Hash code method.
             */
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
            /**
             * Equals method.
             */
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + IMPL) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
            /**
             * To string method.
             */
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        /**
         * Constructor.
         */
        methods.add(getConstructorStart(className) + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, curNode) + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    /**
     * Add method for augment info's list.
     */
    if (isHasAugmentationExtended(getExtendsList())) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getAugmentInfoListImpl());
        methods.add(getRemoveAugmentationImpl());
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + method + NEW_LINE);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING));
    /**
     * Constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addTypeDefConstructor());
    /**
     * Of method.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addOfMethod());
    try {
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while tyoe def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((HasJavaFileInfo) curNode).getJavaFileInfo();
    String className = getCaptialCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, curNode));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING));
    /**
     * Constructor.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addTypeDefConstructor());
    /**
     * Of method.
     */
    methods.add(((HasTempJavaCodeFragmentFiles) curNode).getTempJavaCodeFragmentFiles().addOfMethod());
    try {
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, curNode));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + partString(getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, curNode).replace(NEW_LINE, EMPTY_STRING))));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, curNode)));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, curNode) + getToStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return file;
}
#end_block

#method_before
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    if (type.equals(INT8)) {
        return BYTE;
    } else if (type.equals(INT16)) {
        return SHORT;
    } else if (type.equals(INT32)) {
        return INT;
    } else if (type.equals(INT64)) {
        return LONG;
    } else if (type.equals(UINT8)) {
        return SHORT;
    } else if (type.equals(UINT16)) {
        return INT;
    } else if (type.equals(UINT32)) {
        return LONG;
    } else if (type.equals(UINT64)) {
    // TODO: BIGINTEGER.
    } else if (type.equals(DECIMAL64)) {
    // TODO: DECIMAL64.
    } else if (type.equals(STRING)) {
        return STRING_DATA_TYPE;
    } else if (type.equals(BOOLEAN)) {
        return BOOLEAN_DATA_TYPE;
    } else if (type.equals(ENUMERATION)) {
    // TODO: ENUMERATION.
    } else if (type.equals(BITS)) {
    // TODO:BITS
    } else if (type.equals(BINARY)) {
    // TODO:BINARY
    } else if (type.equals(LEAFREF)) {
    // TODO:LEAFREF
    } else if (type.equals(IDENTITYREF)) {
    // TODO:IDENTITYREF
    } else if (type.equals(EMPTY)) {
    // TODO:EMPTY
    } else if (type.equals(UNION)) {
    // TODO:UNION
    } else if (type.equals(INSTANCE_IDENTIFIER)) {
    // TODO:INSTANCE_IDENTIFIER
    } else if (type.equals(DERIVED)) {
        return yangType.getDataTypeName();
    }
    return null;
}
#method_after
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE;
        case INT16:
            return SHORT;
        case INT32:
            return INT;
        case INT64:
            return LONG;
        case UINT8:
            return SHORT;
        case UINT16:
            return INT;
        case UINT32:
            return LONG;
        case UINT64:
            return BIG_INTEGER;
        case DECIMAL64:
        // TODO: DECIMAL64.
        case STRING:
            return STRING_DATA_TYPE;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        if (type.equals(INT8)) {
            return BYTE_WRAPPER;
        } else if (type.equals(INT16)) {
            return SHORT_WRAPPER;
        } else if (type.equals(INT32)) {
            return INTEGER_WRAPPER;
        } else if (type.equals(INT64)) {
            return LONG_WRAPPER;
        } else if (type.equals(UINT8)) {
            return SHORT_WRAPPER;
        } else if (type.equals(UINT16)) {
            return INTEGER_WRAPPER;
        } else if (type.equals(UINT32)) {
            return LONG_WRAPPER;
        } else if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(STRING)) {
            return STRING_DATA_TYPE;
        } else if (type.equals(BOOLEAN)) {
            return BOOLEAN_WRAPPER;
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
        }
    } else {
        if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(STRING)) {
            return STRING_DATA_TYPE;
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            return getCaptialCase(getCamelCase(yangType.getDataTypeName()));
        }
    }
    return null;
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
            // TODO:UNION
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
            // TODO:EMPTY
            case UNION:
            // TODO:UNION
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getCaptialCase(getCamelCase(yangType.getDataTypeName(), null));
            default:
                return null;
        }
    }
}
#end_block

#method_before
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, String classInfo) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        if (type.equals(INT8) || type.equals(INT16) || type.equals(INT32) || type.equals(INT64) || type.equals(UINT8) || type.equals(UINT16) || type.equals(UINT32) || type.equals(STRING) || type.equals(BOOLEAN)) {
            return JAVA_LANG;
        } else if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            return getTypDefsPackage(yangType);
        }
    } else {
        if (type.equals(UINT64)) {
        // TODO: BIGINTEGER.
        } else if (type.equals(DECIMAL64)) {
        // TODO: DECIMAL64.
        } else if (type.equals(STRING)) {
            return JAVA_LANG;
        } else if (type.equals(ENUMERATION)) {
        // TODO: ENUMERATION.
        } else if (type.equals(BITS)) {
        // TODO:BITS
        } else if (type.equals(BINARY)) {
        // TODO:BINARY
        } else if (type.equals(LEAFREF)) {
        // TODO:LEAFREF
        } else if (type.equals(IDENTITYREF)) {
        // TODO:IDENTITYREF
        } else if (type.equals(EMPTY)) {
        // TODO:EMPTY
        } else if (type.equals(UNION)) {
        // TODO:UNION
        } else if (type.equals(INSTANCE_IDENTIFIER)) {
        // TODO:INSTANCE_IDENTIFIER
        } else if (type.equals(DERIVED)) {
            return getTypDefsPackage(yangType);
        }
    }
    return null;
}
#method_after
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, String classInfo) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
            case INT16:
            case INT32:
            case INT64:
            case UINT8:
            case UINT16:
            case UINT32:
            case STRING:
            case BOOLEAN:
                return JAVA_LANG;
            case UINT64:
                return JAVA_MATH;
            case DECIMAL64:
            // TODO: DECIMAL64.
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
            // TODO:EMPTY
            case UNION:
            // TODO:UNION
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getTypDefsPackage(yangType);
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
            // TODO: BIGINTEGER.
            case DECIMAL64:
            // TODO: DECIMAL64
            case STRING:
                return JAVA_LANG;
            case ENUMERATION:
            // TODO: ENUMERATION.
            case BITS:
            // TODO:BITS
            case BINARY:
            // TODO:BINARY
            case LEAFREF:
            // TODO:LEAFREF
            case IDENTITYREF:
            // TODO:IDENTITYREF
            case EMPTY:
            // TODO:EMPTY
            case UNION:
            // TODO:UNION
            case INSTANCE_IDENTIFIER:
            // TODO:INSTANCE_IDENTIFIER
            case DERIVED:
                return getTypDefsPackage(yangType);
            default:
                return null;
        }
    }
}
#end_block

#method_before
private static String getTypDefsPackage(YangType<?> type) {
    Object var = type.getDataTypeExtendedInfo();
    if (!(var instanceof YangDerivedInfo)) {
        throw new TranslatorException("type should have been derived.");
    }
    YangJavaTypeDef typedef = (YangJavaTypeDef) ((YangDerivedInfo<?>) var).getReferredTypeDef();
    if (typedef.getJavaFileInfo() != null || typedef.getJavaFileInfo().getPackage() != null) {
        return getPackageFromParent(typedef.getParent());
    }
    return typedef.getJavaFileInfo().getPackage();
}
#method_after
private static String getTypDefsPackage(YangType<?> type) {
    Object var = type.getDataTypeExtendedInfo();
    if (!(var instanceof YangDerivedInfo)) {
        throw new TranslatorException("type should have been derived.");
    }
    if (!(((YangDerivedInfo<?>) var).getReferredTypeDef() instanceof YangTypeDef)) {
        throw new TranslatorException("derived info is not an instance of typedef.");
    }
    YangJavaTypeDef typedef = (YangJavaTypeDef) ((YangDerivedInfo<?>) var).getReferredTypeDef();
    if (typedef.getJavaFileInfo().getPackage() == null) {
        return getPackageFromParent(typedef.getParent());
    }
    return typedef.getJavaFileInfo().getPackage();
}
#end_block

#method_before
public static void generateJavaCode(YangNode rootNode, String codeGenDir) throws IOException {
    YangNode curNode = rootNode;
    TraversalType curTraversal = ROOT;
    while (curNode != null) {
        if (curTraversal != PARENT) {
            setCurNode(curNode);
            generateCodeEntry(curNode, codeGenDir);
        }
        if (curTraversal != PARENT && curNode.getChild() != null) {
            curTraversal = CHILD;
            curNode = curNode.getChild();
        } else if (curNode.getNextSibling() != null) {
            generateCodeExit(curNode);
            curTraversal = SIBILING;
            curNode = curNode.getNextSibling();
        } else {
            generateCodeExit(curNode);
            curTraversal = PARENT;
            curNode = curNode.getParent();
        }
    }
}
#method_after
public static void generateJavaCode(YangNode rootNode, YangPluginConfig yangPlugin) throws IOException {
    YangNode curNode = rootNode;
    TraversalType curTraversal = ROOT;
    while (curNode != null) {
        if (curTraversal != PARENT) {
            setCurNode(curNode);
            generateCodeEntry(curNode, yangPlugin);
        }
        if (curTraversal != PARENT && curNode.getChild() != null) {
            curTraversal = CHILD;
            curNode = curNode.getChild();
        } else if (curNode.getNextSibling() != null) {
            generateCodeExit(curNode);
            curTraversal = SIBILING;
            curNode = curNode.getNextSibling();
        } else {
            generateCodeExit(curNode);
            curTraversal = PARENT;
            curNode = curNode.getParent();
        }
    }
}
#end_block

#method_before
private static void generateCodeEntry(YangNode curNode, String codeGenDir) throws IOException {
    if (curNode instanceof JavaCodeGenerator) {
        ((JavaCodeGenerator) curNode).generateCodeEntry(codeGenDir);
    } else {
        throw new TranslatorException("Generated data model node cannot be translated to target language code");
    }
}
#method_after
private static void generateCodeEntry(YangNode curNode, YangPluginConfig yangPlugin) throws IOException {
    if (curNode instanceof JavaCodeGenerator) {
        ((JavaCodeGenerator) curNode).generateCodeEntry(yangPlugin);
    } else {
        throw new TranslatorException("Generated data model node cannot be translated to target language code");
    }
}
#end_block

#method_before
private static void free(YangNode node) throws DataModelException {
    YangNode parent = node.getParent();
    parent.setChild(null);
    if (node.getNextSibling() != null) {
        parent.setChild(node.getNextSibling());
    } else if (node.getPreviousSibling() != null) {
        parent.setChild(node.getPreviousSibling());
    }
    node = null;
}
#method_after
private static void free(YangNode node) {
    YangNode parent = node.getParent();
    parent.setChild(null);
    if (node.getNextSibling() != null) {
        parent.setChild(node.getNextSibling());
    } else if (node.getPreviousSibling() != null) {
        parent.setChild(node.getPreviousSibling());
    }
    node = null;
}
#end_block

#method_before
public static void translatorErrorHandler(YangNode rootNode) throws IOException, DataModelException {
    /**
     * Free other resources where translator has failed.
     */
    freeRestResources();
    /**
     * Start removing all open files.
     */
    YangNode curNode = rootNode;
    setCurNode(curNode.getChild());
    TraversalType curTraversal = ROOT;
    while (!(curNode == null)) {
        if (curTraversal != PARENT) {
            close(curNode);
        }
        if (curTraversal != PARENT && curNode.getChild() != null) {
            curTraversal = CHILD;
            curNode = curNode.getChild();
        } else if (curNode.getNextSibling() != null) {
            curTraversal = SIBILING;
            curNode = curNode.getNextSibling();
        } else {
            curTraversal = PARENT;
            curNode = curNode.getParent();
        }
    }
    freeRestResources();
    curNode = null;
}
#method_after
public static void translatorErrorHandler(YangNode rootNode) throws IOException, DataModelException {
    /**
     * Free other resources where translator has failed.
     */
    freeRestResources();
    /**
     * Start removing all open files.
     */
    YangNode curNode = rootNode;
    setCurNode(curNode.getChild());
    TraversalType curTraversal = ROOT;
    while (curNode != null) {
        if (curTraversal != PARENT) {
            close(curNode);
        }
        if (curTraversal != PARENT && curNode.getChild() != null) {
            curTraversal = CHILD;
            curNode = curNode.getChild();
        } else if (curNode.getNextSibling() != null) {
            curTraversal = SIBILING;
            curNode = curNode.getNextSibling();
        } else {
            curTraversal = PARENT;
            curNode = curNode.getParent();
        }
    }
    freeRestResources();
}
#end_block

#method_before
@Override
public void generateCodeEntry(String baseCodeGenDir) throws IOException {
    String modulePkg = getRootPackage(getVersion(), getNameSpace().getUri(), getRevision().getRevDate());
    YangJavaModelUtils.generateCodeOfRootNode(this, baseCodeGenDir, modulePkg);
}
#method_after
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws IOException {
    String modulePkg = getRootPackage(getVersion(), getNameSpace().getUri(), getRevision().getRevDate());
    YangJavaModelUtils.generateCodeOfRootNode(this, yangPlugin, modulePkg);
}
#end_block

#method_before
@Override
public YangNode getDataModel(String yangFile) throws IOException, ParserException {
    /**
     * Create a char stream that reads from YANG file. Throws an exception
     * in case input YANG file is either null or non existent.
     */
    ANTLRInputStream input;
    try {
        input = new ANTLRFileStream(yangFile);
    } catch (IOException e) {
        e.printStackTrace();
        throw e;
    }
    // Create a lexer that feeds off of input char stream.
    GeneratedYangLexer lexer = new GeneratedYangLexer(input);
    // Create a buffer of tokens pulled from the lexer.
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    // Create a parser that feeds off the tokens buffer.
    GeneratedYangParser parser = new GeneratedYangParser(tokens);
    // Remove console error listener.
    parser.removeErrorListeners();
    // Create instance of customized error listener.
    ParseTreeErrorListener parseTreeErrorListener = new ParseTreeErrorListener();
    // Add customized error listener to catch errors during parsing.
    parser.addErrorListener(parseTreeErrorListener);
    ParseTree tree;
    try {
        // Begin parsing YANG file and generate parse tree.
        tree = parser.yangfile();
    } catch (ParserException parserException) {
        parserException.setFileName(yangFile);
        throw parserException;
    }
    // Create a walker to walk the parse tree.
    ParseTreeWalker walker = new ParseTreeWalker();
    // Create a listener implementation class object.
    TreeWalkListener treeWalker = new TreeWalkListener();
    /**
     * Walk parse tree, provide call backs to methods in listener and build
     * data model tree.
     */
    try {
        walker.walk(treeWalker, tree);
    } catch (ParserException listenerException) {
        // TODO free incomplete data model tree.
        listenerException.setFileName(yangFile);
        throw listenerException;
    } finally {
    // TODO free parsable stack
    }
    // Returns the Root Node of the constructed data model tree.
    return treeWalker.getRootNode();
}
#method_after
@Override
public YangNode getDataModel(String yangFile) throws IOException, ParserException {
    /**
     * Create a char stream that reads from YANG file. Throws an exception
     * in case input YANG file is either null or non existent.
     */
    ANTLRInputStream input;
    try {
        input = new ANTLRFileStream(yangFile);
    } catch (IOException e) {
        throw new ParserException("YANG file error : YANG file does not exist.");
    }
    // Create a lexer that feeds off of input char stream.
    GeneratedYangLexer lexer = new GeneratedYangLexer(input);
    // Create a buffer of tokens pulled from the lexer.
    CommonTokenStream tokens = new CommonTokenStream(lexer);
    // Create a parser that feeds off the tokens buffer.
    GeneratedYangParser parser = new GeneratedYangParser(tokens);
    // Remove console error listener.
    parser.removeErrorListeners();
    // Create instance of customized error listener.
    ParseTreeErrorListener parseTreeErrorListener = new ParseTreeErrorListener();
    // Add customized error listener to catch errors during parsing.
    parser.addErrorListener(parseTreeErrorListener);
    ParseTree tree;
    try {
        // Begin parsing YANG file and generate parse tree.
        tree = parser.yangfile();
    } catch (ParserException parserException) {
        parserException.setFileName(yangFile);
        throw parserException;
    }
    // Create a walker to walk the parse tree.
    ParseTreeWalker walker = new ParseTreeWalker();
    // Create a listener implementation class object.
    TreeWalkListener treeWalker = new TreeWalkListener();
    /**
     * Walk parse tree, provide call backs to methods in listener and build
     * data model tree.
     */
    try {
        walker.walk(treeWalker, tree);
    } catch (ParserException listenerException) {
        // TODO free incomplete data model tree.
        listenerException.setFileName(yangFile);
        throw listenerException;
    } finally {
    // TODO free parsable stack
    }
    // Returns the Root Node of the constructed data model tree.
    return treeWalker.getRootNode();
}
#end_block

#method_before
public List<String> getImports(JavaAttributeInfo attr) {
    String importString;
    List<String> imports = new ArrayList<>();
    for (JavaQualifiedTypeInfo importInfo : getImportSet()) {
        if (!importInfo.getPkgInfo().equals(EMPTY_STRING) && importInfo.getClassInfo() != null && !importInfo.getPkgInfo().equals(JAVA_LANG)) {
            importString = IMPORT + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
            imports.add(importString);
        }
    }
    if (attr.isListAttr()) {
        imports.add(getImportForList());
    }
    java.util.Collections.sort(imports);
    return imports;
}
#method_after
public List<String> getImports(JavaAttributeInfo attr) {
    String importString;
    List<String> imports = new ArrayList<>();
    for (JavaQualifiedTypeInfo importInfo : getImportSet()) {
        if (!importInfo.getPkgInfo().equals(EMPTY_STRING) && importInfo.getClassInfo() != null && !importInfo.getPkgInfo().equals(JAVA_LANG)) {
            importString = IMPORT + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
            imports.add(importString);
        }
    }
    if (attr.isListAttr()) {
        imports.add(getImportForList());
    }
    sort(imports);
    return imports;
}
#end_block

#method_before
private String parseAttribute(JavaAttributeInfo attr) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(getSmallCase(attr.getAttributeName()));
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    }
}
#method_after
private String parseAttribute(JavaAttributeInfo attr) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(getSmallCase(attr.getAttributeName()), null);
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr());
    }
}
#end_block

#method_before
public void addTypeDefAttributeToTempFiles(YangNode curNode) throws IOException {
    JavaAttributeInfo javaAttributeInfo = getAttributeInfoOfTypeDef(curNode, ((YangTypeDef) curNode).getDataType(), ((YangTypeDef) curNode).getName(), false);
    addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#method_after
public void addTypeDefAttributeToTempFiles(YangNode curNode) throws IOException {
    JavaAttributeInfo javaAttributeInfo = getAttributeInfoOfTypeDef(curNode, ((YangTypeDef) curNode).getTypeDefBaseType(), ((YangTypeDef) curNode).getName(), false);
    addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo);
}
#end_block

#method_before
private static YangStatusType getValidStatus(GeneratedYangParser.StatusStatementContext ctx) {
    YangStatusType status;
    String value = removeQuotesAndHandleConcat(ctx.status().getText());
    switch(value) {
        case CURRENT_KEYWORD:
            status = YangStatusType.CURRENT;
            break;
        case DEPRECATED_KEYWORD:
            status = YangStatusType.DEPRECATED;
            break;
        case OBSOLETE_KEYWORD:
            status = YangStatusType.OBSOLETE;
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_CONTENT, STATUS_DATA, value, ENTRY));
    }
    return status;
}
#method_after
private static YangStatusType getValidStatus(GeneratedYangParser.StatusStatementContext ctx) {
    YangStatusType status;
    String value = removeQuotesAndHandleConcat(ctx.status().getText());
    switch(value) {
        case CURRENT_KEYWORD:
            {
                status = YangStatusType.CURRENT;
                break;
            }
        case DEPRECATED_KEYWORD:
            {
                status = YangStatusType.DEPRECATED;
                break;
            }
        case OBSOLETE_KEYWORD:
            {
                status = YangStatusType.OBSOLETE;
                break;
            }
        default:
            {
                ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(STATUS_DATA) + " " + ctx.status().getText() + " is not valid.");
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
    }
    return status;
}
#end_block

#method_before
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(JavaIdentifierSyntax.getCamelCase(name));
    String javaDoc;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.TYPE_DEF_CONSTRUCTOR)) {
        javaDoc = generateForTypeDefConstructor(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#method_after
public static String getJavaDoc(JavaDocType type, String name, boolean isList) {
    name = JavaIdentifierSyntax.getSmallCase(JavaIdentifierSyntax.getCamelCase(name, null));
    String javaDoc;
    if (type.equals(JavaDocType.IMPL_CLASS)) {
        javaDoc = generateForImplClass(name);
    } else if (type.equals(JavaDocType.BUILDER_CLASS)) {
        javaDoc = generateForBuilderClass(name);
    } else if (type.equals(JavaDocType.INTERFACE)) {
        javaDoc = generateForInterface(name);
    } else if (type.equals(JavaDocType.BUILDER_INTERFACE)) {
        javaDoc = generateForBuilderInterface(name);
    } else if (type.equals(JavaDocType.PACKAGE_INFO)) {
        javaDoc = generateForPackage(name);
    } else if (type.equals(JavaDocType.GETTER_METHOD)) {
        javaDoc = generateForGetters(name, isList);
    } else if (type.equals(JavaDocType.TYPE_DEF_SETTER_METHOD)) {
        javaDoc = generateForTypeDefSetter(name);
    } else if (type.equals(JavaDocType.TYPE_DEF_CONSTRUCTOR)) {
        javaDoc = generateForTypeDefConstructor(name);
    } else if (type.equals(JavaDocType.SETTER_METHOD)) {
        javaDoc = generateForSetters(name, isList);
    } else if (type.equals(JavaDocType.OF_METHOD)) {
        javaDoc = generateForOf(name);
    } else if (type.equals(JavaDocType.DEFAULT_CONSTRUCTOR)) {
        javaDoc = generateForDefaultConstructors(name);
    } else if (type.equals(JavaDocType.BUILD_METHOD)) {
        javaDoc = generateForBuild(name);
    } else {
        javaDoc = generateForConstructors(name);
    }
    return javaDoc;
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (MacAddress macAddress : this.neighbor) {
        bytes.addAll(Bytes.asList(macAddress.toBytes()));
    }
    return Bytes.toArray(bytes);
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (MacAddress macAddress : this.neighbor) {
        bytes.addAll(Bytes.asList(macAddress.toBytes()));
    }
    return Bytes.toArray(bytes);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("neighbor", neighbor).toString();
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (String areaAddress : this.areaAddress) {
        bytes.add((byte) (areaAddress.length() / 2));
        bytes.addAll(IsisUtil.areaAddressToBytes(areaAddress));
    }
    return Bytes.toArray(bytes);
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (String areaAddress : this.areaAddress) {
        bytes.add((byte) (areaAddress.length() / 2));
        bytes.addAll(IsisUtil.areaAddressToBytes(areaAddress));
    }
    return Bytes.toArray(bytes);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("areaAddress", areaAddress).toString();
}
#end_block

#method_before
public byte[] asBytes() {
    List<Byte> bytes = new ArrayList<>();
    bytes.add((byte) this.defaultMetric());
    if (this.isDelayIsInternal()) {
        bytes.add((byte) Integer.parseInt("10000000"));
    } else {
        bytes.add((byte) Integer.parseInt("00000000"));
    }
    if (this.isExpenseIsInternal()) {
        bytes.add((byte) Integer.parseInt("10000000"));
    } else {
        bytes.add((byte) Integer.parseInt("00000000"));
    }
    if (this.isErrorIsInternal()) {
        bytes.add((byte) Integer.parseInt("10000000"));
    } else {
        bytes.add((byte) Integer.parseInt("00000000"));
    }
    bytes.addAll(IsisUtil.sourceAndLanIdToBytes(this.neighborId()));
    return Bytes.toArray(bytes);
}
#method_after
public byte[] asBytes() {
    List<Byte> bytes = new ArrayList<>();
    bytes.add((byte) this.defaultMetric());
    if (this.isDelayIsInternal()) {
        bytes.add((byte) Integer.parseInt(value1));
    } else {
        bytes.add((byte) Integer.parseInt(value2));
    }
    if (this.isExpenseIsInternal()) {
        bytes.add((byte) Integer.parseInt(value1));
    } else {
        bytes.add((byte) Integer.parseInt(value2));
    }
    if (this.isErrorIsInternal()) {
        bytes.add((byte) Integer.parseInt(value1));
    } else {
        bytes.add((byte) Integer.parseInt(value2));
    }
    bytes.addAll(IsisUtil.sourceAndLanIdToBytes(this.neighborId()));
    return Bytes.toArray(bytes);
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    byte[] areaArea = new byte[this.tlvLength()];
    return areaArea;
}
#method_after
private byte[] tlvBodyAsBytes() {
    byte[] areaArea = new byte[this.tlvLength()];
    return areaArea;
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    byte[] bytes = this.hostName.getBytes();
    return bytes;
}
#method_after
private byte[] tlvBodyAsBytes() {
    byte[] bytes = this.hostName.getBytes();
    return bytes;
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    bytes.add((byte) this.reserved());
    for (MetricsOfReachability metricsOfReachability : this.metricsOfReachabilities) {
        bytes.addAll(Bytes.asList(metricsOfReachability.asBytes()));
    }
    return Bytes.toArray(bytes);
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    bytes.add((byte) this.reserved());
    for (MetricsOfReachability metricsOfReachability : this.metricsOfReachabilities) {
        bytes.addAll(Bytes.asList(metricsOfReachability.asBytes()));
    }
    return Bytes.toArray(bytes);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("metricsOfReachabilities", metricsOfReachabilities).toString();
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (LspEntry lspEntry : lspEntryList) {
        bytes.addAll(Bytes.asList(lspEntry.lspEntryAsBytes()));
    }
    return Bytes.toArray(bytes);
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (LspEntry lspEntry : lspEntryList) {
        bytes.addAll(Bytes.asList(lspEntry.lspEntryAsBytes()));
    }
    return Bytes.toArray(bytes);
}
#end_block

#method_before
@Override
public void readFrom(ChannelBuffer channelBuffer) {
// implementing
}
#method_after
@Override
public void readFrom(ChannelBuffer channelBuffer) {
// TODO
}
#end_block

#method_before
@Override
public byte[] asBytes() {
    // implementing
    return null;
}
#method_after
@Override
public byte[] asBytes() {
    // TODO
    return null;
}
#end_block

#method_before
public static List<Byte> tlvToBytes(IsisTlv isisTlv) {
    List<Byte> tlvBytes = new ArrayList<>();
    if (isisTlv instanceof AreaAddressTlv) {
        AreaAddressTlv areaAddressTlv = (AreaAddressTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(areaAddressTlv.asBytes()));
    } else if (isisTlv instanceof IpInterfaceAddressTlv) {
        IpInterfaceAddressTlv ipInterfaceAddressTlv = (IpInterfaceAddressTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(ipInterfaceAddressTlv.asBytes()));
    } else if (isisTlv instanceof ProtocolSupportedTlv) {
        ProtocolSupportedTlv protocolSupportedTlv = (ProtocolSupportedTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(protocolSupportedTlv.asBytes()));
    } else if (isisTlv instanceof PaddingTlv) {
        PaddingTlv paddingTlv = (PaddingTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(paddingTlv.asBytes()));
    } else if (isisTlv instanceof IsisNeighborTlv) {
        IsisNeighborTlv isisNeighborTlv = (IsisNeighborTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(isisNeighborTlv.asBytes()));
    } else if (isisTlv instanceof AdjacencyStateTlv) {
        AdjacencyStateTlv isisAdjacencyState = (AdjacencyStateTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(isisAdjacencyState.asBytes()));
    } else if (isisTlv instanceof HostNameTlv) {
        HostNameTlv hostNameTlv = (HostNameTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(hostNameTlv.asBytes()));
    } else if (isisTlv instanceof IpExternalReachabilityTlv) {
        IpExternalReachabilityTlv ipExternalReachabilityTlv = (IpExternalReachabilityTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(ipExternalReachabilityTlv.asBytes()));
    } else if (isisTlv instanceof IpInternalReachabilityTlv) {
        IpInternalReachabilityTlv ipInternalReachabilityTlv = (IpInternalReachabilityTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(ipInternalReachabilityTlv.asBytes()));
    } else if (isisTlv instanceof IsReachabilityTlv) {
        IsReachabilityTlv isReachabilityTlv = (IsReachabilityTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(isReachabilityTlv.asBytes()));
    } else if (isisTlv instanceof LspEntriesTlv) {
        LspEntriesTlv lspEntriesTlv = (LspEntriesTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(lspEntriesTlv.asBytes()));
    } else {
        log.debug("TlvsToBytes::UNKNOWN TLV TYPE ::TlvsToBytes ");
    }
    return tlvBytes;
}
#method_after
public static List<Byte> tlvToBytes(IsisTlv isisTlv) {
    List<Byte> tlvBytes = new ArrayList<>();
    if (isisTlv instanceof AreaAddressTlv) {
        AreaAddressTlv areaAddressTlv = (AreaAddressTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(areaAddressTlv.asBytes()));
    } else if (isisTlv instanceof IpInterfaceAddressTlv) {
        IpInterfaceAddressTlv ipInterfaceAddressTlv = (IpInterfaceAddressTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(ipInterfaceAddressTlv.asBytes()));
    } else if (isisTlv instanceof ProtocolSupportedTlv) {
        ProtocolSupportedTlv protocolSupportedTlv = (ProtocolSupportedTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(protocolSupportedTlv.asBytes()));
    } else if (isisTlv instanceof PaddingTlv) {
        PaddingTlv paddingTlv = (PaddingTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(paddingTlv.asBytes()));
    } else if (isisTlv instanceof IsisNeighborTlv) {
        IsisNeighborTlv isisNeighborTlv = (IsisNeighborTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(isisNeighborTlv.asBytes()));
    } else if (isisTlv instanceof AdjacencyStateTlv) {
        AdjacencyStateTlv isisAdjacencyState = (AdjacencyStateTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(isisAdjacencyState.asBytes()));
    } else if (isisTlv instanceof HostNameTlv) {
        HostNameTlv hostNameTlv = (HostNameTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(hostNameTlv.asBytes()));
    } else if (isisTlv instanceof IpExtendedReachabilityTlv) {
        IpExtendedReachabilityTlv ipExtendedReachabilityTlv = (IpExtendedReachabilityTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(ipExtendedReachabilityTlv.asBytes()));
    } else if (isisTlv instanceof IpInternalReachabilityTlv) {
        IpInternalReachabilityTlv ipInternalReachabilityTlv = (IpInternalReachabilityTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(ipInternalReachabilityTlv.asBytes()));
    } else if (isisTlv instanceof IsReachabilityTlv) {
        IsReachabilityTlv isReachabilityTlv = (IsReachabilityTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(isReachabilityTlv.asBytes()));
    } else if (isisTlv instanceof LspEntriesTlv) {
        LspEntriesTlv lspEntriesTlv = (LspEntriesTlv) isisTlv;
        tlvBytes.addAll(Bytes.asList(lspEntriesTlv.asBytes()));
    } else {
        log.debug("TlvsToBytes::UNKNOWN TLV TYPE ::TlvsToBytes ");
    }
    return tlvBytes;
}
#end_block

#method_before
public static TrafficEngineeringSubTlv findSubTlv(TlvHeader tlvHeader, ChannelBuffer channelBuffer) {
    TrafficEngineeringSubTlv subTlv = null;
    switch(SubTlvType.get(tlvHeader.tlvType())) {
        case ADMINISTRATIVEGROUP:
            AdministrativeGroup administrativeGroup = new AdministrativeGroup(tlvHeader);
            administrativeGroup.readFrom(channelBuffer);
            subTlv = administrativeGroup;
            break;
        case MAXIMUMBANDWIDTH:
            MaximumBandwidth maximumBandwidth = new MaximumBandwidth(tlvHeader);
            maximumBandwidth.readFrom(channelBuffer);
            subTlv = maximumBandwidth;
            break;
        case MAXIMUMRESERVABLEBANDWIDTH:
            MaximumReservableBandwidth maxResBandwidth = new MaximumReservableBandwidth(tlvHeader);
            maxResBandwidth.readFrom(channelBuffer);
            subTlv = maxResBandwidth;
            break;
        case TRAFFICENGINEERINGMETRIC:
            TrafficEngineeringMetric teMetric = new TrafficEngineeringMetric(tlvHeader);
            teMetric.readFrom(channelBuffer);
            subTlv = teMetric;
            break;
        case UNRESERVEDBANDWIDTH:
            UnreservedBandwidth unreservedBandwidth = new UnreservedBandwidth(tlvHeader);
            unreservedBandwidth.readFrom(channelBuffer);
            subTlv = unreservedBandwidth;
            break;
        default:
            break;
    }
    return subTlv;
}
#method_after
public static TrafficEngineeringSubTlv findSubTlv(TlvHeader tlvHeader, ChannelBuffer channelBuffer) {
    TrafficEngineeringSubTlv subTlv = null;
    switch(SubTlvType.get(tlvHeader.tlvType())) {
        case ADMINISTRATIVEGROUP:
            AdministrativeGroup administrativeGroup = new AdministrativeGroup(tlvHeader);
            administrativeGroup.readFrom(channelBuffer);
            subTlv = administrativeGroup;
            break;
        case MAXIMUMBANDWIDTH:
            MaximumBandwidth maximumBandwidth = new MaximumBandwidth(tlvHeader);
            maximumBandwidth.readFrom(channelBuffer);
            subTlv = maximumBandwidth;
            break;
        case MAXIMUMRESERVABLEBANDWIDTH:
            MaximumReservableBandwidth maxResBandwidth = new MaximumReservableBandwidth(tlvHeader);
            maxResBandwidth.readFrom(channelBuffer);
            subTlv = maxResBandwidth;
            break;
        case TRAFFICENGINEERINGMETRIC:
            TrafficEngineeringMetric teMetric = new TrafficEngineeringMetric(tlvHeader);
            teMetric.readFrom(channelBuffer);
            subTlv = teMetric;
            break;
        case UNRESERVEDBANDWIDTH:
            UnreservedBandwidth unreservedBandwidth = new UnreservedBandwidth(tlvHeader);
            unreservedBandwidth.readFrom(channelBuffer);
            subTlv = unreservedBandwidth;
            break;
        default:
            // TODO
            break;
    }
    return subTlv;
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (Ip4Address ip4Address : this.interfaceAddress) {
        bytes.addAll(Bytes.asList(ip4Address.toOctets()));
    }
    return Bytes.toArray(bytes);
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (Ip4Address ip4Address : this.interfaceAddress) {
        bytes.addAll(Bytes.asList(ip4Address.toOctets()));
    }
    return Bytes.toArray(bytes);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("interfaceAddress", interfaceAddress).toString();
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (MetricOfInternalReachability metricOfInternalReachability : this.metricOfInternalReachability) {
        bytes.addAll(Bytes.asList(metricOfInternalReachability.asBytes()));
    }
    return Bytes.toArray(bytes);
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (MetricOfInternalReachability metricOfInternalReachability : this.metricOfInternalReachability) {
        bytes.addAll(Bytes.asList(metricOfInternalReachability.asBytes()));
    }
    return Bytes.toArray(bytes);
}
#end_block

#method_before
public static IsisTlv findTlv(TlvHeader tlvHeader, ChannelBuffer channelBuffer) {
    IsisTlv isisTlv = null;
    switch(TlvType.get(tlvHeader.tlvType())) {
        case AREAADDRESS:
            AreaAddressTlv areaAddressTlv = new AreaAddressTlv(tlvHeader);
            areaAddressTlv.readFrom(channelBuffer);
            isisTlv = areaAddressTlv;
            break;
        case AUTHENTICATION:
            break;
        case EXTENDEDISREACHABILITY:
            break;
        case IDRPINFORMATION:
            IdrpInformationTlv idrpInformationTlv = new IdrpInformationTlv(tlvHeader);
            idrpInformationTlv.readFrom(channelBuffer);
            isisTlv = idrpInformationTlv;
            break;
        case IPEXTERNALREACHABILITY:
            IpExternalReachabilityTlv iperTlv = new IpExternalReachabilityTlv(tlvHeader);
            iperTlv.readFrom(channelBuffer);
            isisTlv = iperTlv;
            break;
        case IPINTERFACEADDRESS:
            IpInterfaceAddressTlv ipTlv = new IpInterfaceAddressTlv(tlvHeader);
            ipTlv.readFrom(channelBuffer);
            isisTlv = ipTlv;
            break;
        case IPINTERNALREACHABILITY:
            IpInternalReachabilityTlv iprTlv = new IpInternalReachabilityTlv(tlvHeader);
            iprTlv.readFrom(channelBuffer);
            isisTlv = iprTlv;
            break;
        case ISALIAS:
            break;
        case PROTOCOLSUPPORTED:
            ProtocolSupportedTlv psTlv = new ProtocolSupportedTlv(tlvHeader);
            psTlv.readFrom(channelBuffer);
            isisTlv = psTlv;
            break;
        case ISREACHABILITY:
            IsReachabilityTlv isrTlv = new IsReachabilityTlv(tlvHeader);
            isrTlv.readFrom(channelBuffer);
            isisTlv = isrTlv;
            break;
        case ISNEIGHBORS:
            IsisNeighborTlv isisNeighborTlv = new IsisNeighborTlv(tlvHeader);
            isisNeighborTlv.readFrom(channelBuffer);
            isisTlv = isisNeighborTlv;
            break;
        case LSPENTRY:
            LspEntriesTlv lspEntriesTlv = new LspEntriesTlv(tlvHeader);
            lspEntriesTlv.readFrom(channelBuffer);
            isisTlv = lspEntriesTlv;
            break;
        case PADDING:
            PaddingTlv paddingTlv = new PaddingTlv(tlvHeader);
            paddingTlv.readFrom(channelBuffer);
            isisTlv = paddingTlv;
            break;
        case ADJACENCYSTATE:
            AdjacencyStateTlv adjacencyStateTlv = new AdjacencyStateTlv(tlvHeader);
            adjacencyStateTlv.readFrom(channelBuffer);
            isisTlv = adjacencyStateTlv;
            break;
        default:
            break;
    }
    return isisTlv;
}
#method_after
public static IsisTlv findTlv(TlvHeader tlvHeader, ChannelBuffer channelBuffer) {
    IsisTlv isisTlv = null;
    switch(TlvType.get(tlvHeader.tlvType())) {
        case AREAADDRESS:
            AreaAddressTlv areaAddressTlv = new AreaAddressTlv(tlvHeader);
            areaAddressTlv.readFrom(channelBuffer);
            isisTlv = areaAddressTlv;
            break;
        case AUTHENTICATION:
            // TODO
            break;
        case EXTENDEDISREACHABILITY:
            // TODO
            break;
        case IDRPINFORMATION:
            IdrpInformationTlv idrpInformationTlv = new IdrpInformationTlv(tlvHeader);
            idrpInformationTlv.readFrom(channelBuffer);
            isisTlv = idrpInformationTlv;
            break;
        case IPEXTENDEDREACHABILITY:
            IpExtendedReachabilityTlv iperTlv = new IpExtendedReachabilityTlv(tlvHeader);
            iperTlv.readFrom(channelBuffer);
            isisTlv = iperTlv;
            break;
        case IPINTERFACEADDRESS:
            IpInterfaceAddressTlv ipTlv = new IpInterfaceAddressTlv(tlvHeader);
            ipTlv.readFrom(channelBuffer);
            isisTlv = ipTlv;
            break;
        case IPINTERNALREACHABILITY:
            IpInternalReachabilityTlv iprTlv = new IpInternalReachabilityTlv(tlvHeader);
            iprTlv.readFrom(channelBuffer);
            isisTlv = iprTlv;
            break;
        case ISALIAS:
            break;
        case PROTOCOLSUPPORTED:
            ProtocolSupportedTlv psTlv = new ProtocolSupportedTlv(tlvHeader);
            psTlv.readFrom(channelBuffer);
            isisTlv = psTlv;
            break;
        case ISREACHABILITY:
            IsReachabilityTlv isrTlv = new IsReachabilityTlv(tlvHeader);
            isrTlv.readFrom(channelBuffer);
            isisTlv = isrTlv;
            break;
        case ISNEIGHBORS:
            IsisNeighborTlv isisNeighborTlv = new IsisNeighborTlv(tlvHeader);
            isisNeighborTlv.readFrom(channelBuffer);
            isisTlv = isisNeighborTlv;
            break;
        case LSPENTRY:
            LspEntriesTlv lspEntriesTlv = new LspEntriesTlv(tlvHeader);
            lspEntriesTlv.readFrom(channelBuffer);
            isisTlv = lspEntriesTlv;
            break;
        case PADDING:
            PaddingTlv paddingTlv = new PaddingTlv(tlvHeader);
            paddingTlv.readFrom(channelBuffer);
            isisTlv = paddingTlv;
            break;
        case ADJACENCYSTATE:
            AdjacencyStateTlv adjacencyStateTlv = new AdjacencyStateTlv(tlvHeader);
            adjacencyStateTlv.readFrom(channelBuffer);
            isisTlv = adjacencyStateTlv;
            break;
        default:
            break;
    }
    return isisTlv;
}
#end_block

#method_before
public static boolean sameNetwork(Ip4Address ip1, Ip4Address ip2, String mask) {
    try {
        byte[] a1 = ip1.toOctets();
        byte[] a2 = ip2.toOctets();
        byte[] m = InetAddress.getByName(mask).getAddress();
        for (int i = 0; i < a1.length; i++) {
            if ((a1[i] & m[i]) != (a2[i] & m[i])) {
                return false;
            }
        }
    } catch (Exception e) {
        log.debug("Exception::IsisUtil::sameNetwork:: {}", e.getMessage());
    }
    return true;
}
#method_after
public static boolean sameNetwork(Ip4Address ip1, Ip4Address ip2, byte[] mask) {
    try {
        byte[] a1 = ip1.toOctets();
        byte[] a2 = ip2.toOctets();
        for (int i = 0; i < a1.length; i++) {
            if ((a1[i] & mask[i]) != (a2[i] & mask[i])) {
                return false;
            }
        }
    } catch (Exception e) {
        log.debug("Exception::IsisUtil::sameNetwork:: {}", e.getMessage());
    }
    return true;
}
#end_block

#method_before
@Override
public void readFrom(ChannelBuffer channelBuffer) {
    this.adjacencyType = channelBuffer.readByte();
}
#method_after
@Override
public void readFrom(ChannelBuffer channelBuffer) {
    this.setAdjacencyType(channelBuffer.readByte());
    if (channelBuffer.readableBytes() > 0) {
        this.setLocalCircuitId(channelBuffer.readInt());
        byte[] tempByteArray = new byte[IsisUtil.ID_SIX_BYTES];
        channelBuffer.readBytes(tempByteArray, 0, IsisUtil.ID_SIX_BYTES);
        this.setNeighborSystemId(IsisUtil.systemId(tempByteArray));
        this.setNeighborLocalCircuitId(channelBuffer.readInt());
    }
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    byte[] bytes = { adjacencyType };
    return bytes;
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    bytes.add(this.adjacencyType);
    bytes.addAll(Bytes.asList(IsisUtil.convertToFourBytes(this.localCircuitId)));
    bytes.addAll(IsisUtil.sourceAndLanIdToBytes(this.neighborSystemId));
    bytes.addAll(Bytes.asList(IsisUtil.convertToFourBytes(this.neighborLocalCircuitId)));
    return Bytes.toArray(bytes);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("adjacencyType", adjacencyType).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).omitNullValues().add("adjacencyType", adjacencyType).add("localCircuitId", localCircuitId).add("neighborSystemId", neighborSystemId).add("neighborLocalCircuitId", neighborLocalCircuitId).toString();
}
#end_block

#method_before
public byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (byte byt : this.protocolSupported) {
        bytes.add(byt);
    }
    byte[] byteArray = new byte[bytes.size()];
    int i = 0;
    for (byte byt : bytes) {
        byteArray[i++] = byt;
    }
    return byteArray;
}
#method_after
private byte[] tlvBodyAsBytes() {
    List<Byte> bytes = new ArrayList<>();
    for (byte byt : this.protocolSupported) {
        bytes.add(byt);
    }
    byte[] byteArray = new byte[bytes.size()];
    int i = 0;
    for (byte byt : bytes) {
        byteArray[i++] = byt;
    }
    return byteArray;
}
#end_block

#method_before
@Test
public void getCamelCaseTest() {
    String camelCase = getCamelCase(WITHOUT_CAMEL_CASE);
    assertThat(camelCase.equals(WITH_CAMEL_CASE), is(true));
    String camelCase1 = getCamelCase(WITHOUT_CAMEL_CASE1);
    assertThat(camelCase1.equals(WITH_CAMEL_CASE1), is(true));
    String camelCase2 = getCamelCase(WITHOUT_CAMEL_CASE2);
    assertThat(camelCase2.equals(WITH_CAMEL_CASE2), is(true));
}
#method_after
@Test
public void getCamelCaseTest() {
    String camelCase = getCamelCase(WITHOUT_CAMEL_CASE, null);
    assertThat(camelCase.equals(WITH_CAMEL_CASE), is(true));
    String camelCase1 = getCamelCase(WITHOUT_CAMEL_CASE1, null);
    assertThat(camelCase1.equals(WITH_CAMEL_CASE1), is(true));
    String camelCase2 = getCamelCase(WITHOUT_CAMEL_CASE2, null);
    assertThat(camelCase2.equals(WITH_CAMEL_CASE2), is(true));
    String camelCase3 = getCamelCase(WITHOUT_CAMEL_CASE3, null);
    assertThat(camelCase3.equals(WITH_CAMEL_CASE3), is(true));
    String camelCase4 = getCamelCase(WITHOUT_CAMEL_CASE4, null);
    assertThat(camelCase4.equals(WITH_CAMEL_CASE4), is(true));
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /**
         * For deleting the generated code in previous build.
         */
        clean(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG);
        clean(getDirectory(baseDir, outputDirectory));
        setCurrentProject(project);
        searchDir = getDirectory(baseDir, yangFilesDir);
        codeGenDir = getDirectory(baseDir, genFilesDir) + SLASH;
        List<String> yangFiles = YangFileScanner.getYangFiles(searchDir);
        Iterator<String> yangFileIterator = yangFiles.iterator();
        while (yangFileIterator.hasNext()) {
            String yangFile = yangFileIterator.next();
            try {
                YangNode yangNode = yangUtilsParser.getDataModel(yangFile);
                setRootNode(yangNode);
                generateJavaCode(yangNode, codeGenDir);
            } catch (ParserException e) {
                String logInfo = "Error in file: " + e.getFileName();
                if (e.getLineNumber() != 0) {
                    logInfo = logInfo + " at line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine();
                }
                if (e.getMessage() != null) {
                    logInfo = logInfo + NEW_LINE + e.getMessage();
                }
                getLog().info(logInfo);
            }
        }
        addToSource(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG, project, context);
        copyYangFilesToTarget(yangFiles, getDirectory(baseDir, outputDirectory), project);
    } catch (Exception e) {
        try {
            translatorErrorHandler(getRootNode());
            clean(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG);
        } catch (IOException | DataModelException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage());
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /**
         * For deleting the generated code in previous build.
         */
        clean(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG);
        clean(getDirectory(baseDir, outputDirectory));
        searchDir = getDirectory(baseDir, yangFilesDir);
        codeGenDir = getDirectory(baseDir, genFilesDir) + SLASH;
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForHyphen);
        List<String> yangFiles = YangFileScanner.getYangFiles(searchDir);
        YangPluginConfig yangPlugin = new YangPluginConfig();
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        Iterator<String> yangFileIterator = yangFiles.iterator();
        while (yangFileIterator.hasNext()) {
            String yangFile = yangFileIterator.next();
            try {
                YangNode yangNode = yangUtilsParser.getDataModel(yangFile);
                setRootNode(yangNode);
                generateJavaCode(yangNode, yangPlugin);
            } catch (ParserException e) {
                String logInfo = "Error in file: " + e.getFileName();
                if (e.getLineNumber() != 0) {
                    logInfo = logInfo + " at line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine();
                }
                if (e.getMessage() != null) {
                    logInfo = logInfo + NEW_LINE + e.getMessage();
                }
                getLog().info(logInfo);
            }
        }
        addToSource(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG, project, context);
        copyYangFilesToTarget(yangFiles, getDirectory(baseDir, outputDirectory), project);
    } catch (Exception e) {
        try {
            translatorErrorHandler(getRootNode());
            clean(getDirectory(baseDir, genFilesDir) + DEFAULT_PKG);
        } catch (IOException | DataModelException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage());
    }
}
#end_block

#method_before
/**
 * Sets current root YANG node of data-model tree.
 *
 * @param rootNode current root YANG node of data-model tree
 */
public void setRootNode(YangNode rootNode) {
    this.rootNode = rootNode;
}
#method_after
public void setRootNode(YangNode rootNode) {
    this.rootNode = rootNode;
}
#end_block

#method_before
private static String getPkgFromNameSpace(String nameSpace) {
    ArrayList<String> pkgArr = new ArrayList<String>();
    nameSpace = nameSpace.replace(QUOTES, EMPTY_STRING);
    String properNameSpace = nameSpace.replaceAll(REGEX_WITH_SPECIAL_CHAR, COLAN);
    String[] nameSpaceArr = properNameSpace.split(COLAN);
    for (String nameSpaceString : nameSpaceArr) {
        pkgArr.add(nameSpaceString);
    }
    return getPkgFrmArr(pkgArr);
}
#method_after
private static String getPkgFromNameSpace(String nameSpace) {
    ArrayList<String> pkgArr = new ArrayList<String>();
    nameSpace = nameSpace.replace(QUOTES, EMPTY_STRING);
    String properNameSpace = nameSpace.replaceAll(REGEX_WITH_ALL_SPECIAL_CHAR, COLAN);
    String[] nameSpaceArr = properNameSpace.split(COLAN);
    for (String nameSpaceString : nameSpaceArr) {
        pkgArr.add(nameSpaceString);
    }
    return getPkgFrmArr(pkgArr);
}
#end_block

#method_before
private static String getYangRevisionStr(String date) throws TranslatorException {
    String[] revisionArr = date.split(HYPHEN);
    String rev = REVISION_PREFIX;
    rev = rev + revisionArr[INDEX_ZERO];
    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {
        for (int i = INDEX_ONE; i < revisionArr.length; i++) {
            Integer val = Integer.parseInt(revisionArr[i]);
            if (val < 10) {
                rev = rev + "0";
            }
            rev = rev + val;
        }
        return rev;
    } else {
        throw new TranslatorException("Date in revision is not proper: " + date);
    }
}
#method_after
private static String getYangRevisionStr(String date) throws TranslatorException {
    String[] revisionArr = date.split(HYPHEN);
    String rev = REVISION_PREFIX;
    rev = rev + revisionArr[INDEX_ZERO];
    if (Integer.parseInt(revisionArr[INDEX_ONE]) <= MAX_MONTHS && Integer.parseInt(revisionArr[INDEX_TWO]) <= MAX_DAYS) {
        for (int i = INDEX_ONE; i < revisionArr.length; i++) {
            Integer val = Integer.parseInt(revisionArr[i]);
            if (val < VALUE_CHECK) {
                rev = rev + ZERO;
            }
            rev = rev + val;
        }
        return rev;
    } else {
        throw new TranslatorException("Date in revision is not proper: " + date);
    }
}
#end_block

#method_before
private static String getPkgFrmArr(ArrayList<String> pkgArr) {
    String pkg = EMPTY_STRING;
    int size = pkgArr.size();
    int i = 0;
    for (String member : pkgArr) {
        boolean presenceOfKeyword = JAVA_KEY_WORDS.contains(member);
        if (presenceOfKeyword || member.matches(REGEX_FOR_FIRST_DIGIT)) {
            String prefixString = getMavenProjectArtifactId();
            member = prefixString + member;
        }
        pkg = pkg + member;
        if (i != size - 1) {
            pkg = pkg + PERIOD;
        }
        i++;
    }
    return pkg;
}
#method_after
private static String getPkgFrmArr(ArrayList<String> pkgArr) {
    String pkg = EMPTY_STRING;
    int size = pkgArr.size();
    int i = 0;
    for (String member : pkgArr) {
        boolean presenceOfKeyword = JAVA_KEY_WORDS.contains(member);
        if (presenceOfKeyword || member.matches(REGEX_FOR_FIRST_DIGIT)) {
            member = YANG_AUTO_PREFIX + member;
        }
        pkg = pkg + member;
        if (i != size - 1) {
            pkg = pkg + PERIOD;
        }
        i++;
    }
    return pkg;
}
#end_block

#method_before
public static String getCamelCase(String yangIdentifier) {
    List<String> stringArrangement = new ArrayList<String>();
    String properYangIdentifier = yangIdentifier.replaceAll(REGEX_WITH_SPECIAL_CHAR, COLAN);
    String[] strArray = properYangIdentifier.split(COLAN);
    if (strArray[0].isEmpty()) {
        for (int i = 1; i < strArray.length; i++) {
            stringArrangement.add(strArray[i]);
        }
        strArray = stringArrangement.toArray(new String[stringArrangement.size()]);
    }
    for (int i = 0; i < strArray.length; i++) {
        boolean presenceOfKeyword = JAVA_KEY_WORDS.contains(strArray[i]);
        if (presenceOfKeyword || strArray[i].matches(REGEX_FOR_FIRST_DIGIT)) {
            String prefixString = getMavenProjectArtifactId();
            strArray[i] = prefixString + strArray[i];
        }
    }
    String camelCase = strArray[0];
    for (int i = 1; i < strArray.length; i++) {
        camelCase = camelCase + strArray[i].substring(0, 1).toUpperCase() + strArray[i].substring(1);
    }
    return camelCase;
}
#method_after
public static String getCamelCase(String yangIdentifier, YangToJavaNamingConflictUtil conflictResolver) {
    if (conflictResolver != null) {
        String replacementForHyphen = conflictResolver.getReplacementForHyphen();
        String replacementForPeriod = conflictResolver.getReplacementForPeriod();
        String replacementForUnderscore = conflictResolver.getReplacementForUnderscore();
        if (replacementForPeriod != null) {
            yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_PERIOD, PERIOD + replacementForPeriod.toLowerCase() + PERIOD);
        }
        if (replacementForUnderscore != null) {
            yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_UNDERSCORE, UNDER_SCORE + replacementForUnderscore.toLowerCase() + UNDER_SCORE);
        }
        if (replacementForHyphen != null) {
            yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_HYPHEN, HYPHEN + replacementForHyphen.toLowerCase() + HYPHEN);
        }
    }
    yangIdentifier = yangIdentifier.replaceAll(REGEX_FOR_IDENTIFIER_SPECIAL_CHAR, COLAN);
    String[] strArray = yangIdentifier.split(COLAN);
    if (strArray[0].isEmpty()) {
        List<String> stringArrangement = new ArrayList<String>();
        for (int i = 1; i < strArray.length; i++) {
            stringArrangement.add(strArray[i]);
        }
        strArray = stringArrangement.toArray(new String[stringArrangement.size()]);
    }
    return applyCamelCaseRule(strArray);
}
#end_block

#method_before
private static void setLengthRestriction(YangType type, GeneratedYangParser.LengthStatementContext ctx) {
    if (type.getDataType() != YangDataTypes.STRING) {
        // TODO: support derived for base built in type of string
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(LENGTH_DATA) + " name " + ctx.length().getText() + "can be sub-statement of only string type");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    YangStringRestriction stringRestriction = (YangStringRestriction) type.getDataTypeExtendedInfo();
    if (stringRestriction == null) {
        stringRestriction = new YangStringRestriction();
        type.setDataTypeExtendedInfo(stringRestriction);
    }
    YangRangeRestriction<BigInteger> lengthRestriction = new YangRangeRestriction<>();
    YangRangeInterval<BigInteger> rangeInterval = new YangRangeInterval<>();
    String rangeArgument = removeQuotesAndHandleConcat(ctx.length().getText());
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(LENGTH_INTERVAL));
        if (rangeBoundary.length == 1) {
            rangeBoundary[1] = rangeBoundary[0];
        }
        rangeInterval.setStartValue(new BigInteger(rangeBoundary[0]));
        rangeInterval.setEndValue(new BigInteger(rangeBoundary[1]));
        try {
            lengthRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LENGTH_DATA, rangeArgument, ENTRY, e.getMessage()));
        }
    }
    stringRestriction.setLengthRestriction(lengthRestriction);
}
#method_after
private static void setLengthRestriction(YangType type, GeneratedYangParser.LengthStatementContext ctx) {
    YangStringRestriction stringRestriction;
    YangBuiltInDataTypeInfo<?> startValue, endValue;
    YangRangeRestriction lengthRestriction = new YangRangeRestriction<>();
    if (type.getDataType() != YangDataTypes.STRING && type.getDataType() != YangDataTypes.DERIVED) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(LENGTH_DATA) + " name " + ctx.length().getText() + " can be used to restrict the built-in type string or types derived from string.");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    if (type.getDataType() == YangDataTypes.STRING) {
        stringRestriction = (YangStringRestriction) type.getDataTypeExtendedInfo();
    } else {
        stringRestriction = (YangStringRestriction) ((YangDerivedInfo<?>) type.getDataTypeExtendedInfo()).getExtendedInfo();
    }
    if (stringRestriction == null) {
        stringRestriction = new YangStringRestriction();
        if (type.getDataType() == YangDataTypes.STRING) {
            type.setDataTypeExtendedInfo(stringRestriction);
        } else {
            ((YangDerivedInfo<YangStringRestriction>) type.getDataTypeExtendedInfo()).setExtendedInfo(stringRestriction);
        }
    }
    String rangeArgument = removeQuotesAndHandleConcat(ctx.length().getText());
    String[] rangeArguments = rangeArgument.trim().split(Pattern.quote(PIPE));
    for (String rangePart : rangeArguments) {
        String startInterval, endInterval;
        YangRangeInterval rangeInterval = new YangRangeInterval<>();
        String[] rangeBoundary = rangePart.trim().split(Pattern.quote(LENGTH_INTERVAL));
        if (rangeBoundary.length > 2) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(LENGTH_DATA) + " " + rangeArgument + " is not valid.");
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        if (rangeBoundary.length == 1) {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[0];
        } else {
            startInterval = rangeBoundary[0];
            endInterval = rangeBoundary[1];
        }
        try {
            startValue = getDataObjectFromString(startInterval, YangDataTypes.UINT64);
            endValue = getDataObjectFromString(endInterval, YangDataTypes.UINT64);
        } catch (DataTypeException e) {
            ParserException parserException = new ParserException(e.getMessage());
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        rangeInterval.setStartValue(startValue);
        rangeInterval.setEndValue(endValue);
        try {
            lengthRestriction.addRangeRestrictionInterval(rangeInterval);
        } catch (DataModelException e) {
            ParserException parserException = new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LENGTH_DATA, rangeArgument, ENTRY, e.getMessage()));
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
    }
    stringRestriction.setLengthRestriction(lengthRestriction);
}
#end_block

#method_before
@Override
public void enterRangeStatement(GeneratedYangParser.RangeStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterRangeStatement(GeneratedYangParser.RangeStatementContext ctx) {
    RangeRestrictionListener.processRangeRestrictionEntry(this, ctx);
}
#end_block

#method_before
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
    RpcListener.processRpcEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
    RpcListener.processRpcExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterInputStatement(GeneratedYangParser.InputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterInputStatement(GeneratedYangParser.InputStatementContext ctx) {
    InputListener.processInputEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitInputStatement(GeneratedYangParser.InputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitInputStatement(GeneratedYangParser.InputStatementContext ctx) {
    InputListener.processInputExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
    OutputListener.processOutputEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
    OutputListener.processOutputExit(this, ctx);
}
#end_block

#method_before
@Test
public void processValidLengthStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidLengthStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(rangeInterval.getStartValue(), is(BigInteger.valueOf(0)));
    assertThat(rangeInterval.getEndValue(), is(BigInteger.valueOf(100)));
}
#method_after
@Test
public void processValidLengthStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidLengthStatement.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(0)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(100)));
}
#end_block

#method_before
@Test
public void processLengthStatementInsideLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthStatementInsideLeafList.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(rangeInterval.getStartValue(), is(BigInteger.valueOf(1)));
    assertThat(rangeInterval.getEndValue(), is(BigInteger.valueOf(100)));
}
#method_after
@Test
public void processLengthStatementInsideLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthStatementInsideLeafList.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    assertThat(leafListInfo.getLeafName(), is("invalid-interval"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("string"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.STRING));
    YangStringRestriction stringRestriction = (YangStringRestriction) leafListInfo.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(1)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(100)));
}
#end_block

#method_before
@Test
public void processLengthStatementInsideTypeDef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthStatementInsideTypeDef.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild();
    YangStringRestriction stringRestriction = (YangStringRestriction) typedef.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(rangeInterval.getStartValue(), is(BigInteger.valueOf(1)));
    assertThat(rangeInterval.getEndValue(), is(BigInteger.valueOf(100)));
}
#method_after
@Test
public void processLengthStatementInsideTypeDef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/LengthStatementInsideTypeDef.yang");
    assertThat((node instanceof YangModule), is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild();
    YangStringRestriction stringRestriction = (YangStringRestriction) typedef.getDataType().getDataTypeExtendedInfo();
    YangRangeRestriction lengthRestriction = stringRestriction.getLengthRestriction();
    ListIterator<YangRangeInterval> lengthListIterator = lengthRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = lengthListIterator.next();
    assertThat(((YangUint64) rangeInterval.getStartValue()).getValue(), is(BigInteger.valueOf(1)));
    assertThat(((YangUint64) rangeInterval.getEndValue()).getValue(), is(BigInteger.valueOf(100)));
}
#end_block

#method_before
private static void setPatternRestriction(YangType type, GeneratedYangParser.PatternStatementContext ctx) {
    if (type.getDataType() != YangDataTypes.STRING) {
        // TODO: support derived for base built in type of string
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(PATTERN_DATA) + " name " + ctx.string().getText() + "can be sub-statement of only string type");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    YangStringRestriction stringRestriction = (YangStringRestriction) type.getDataTypeExtendedInfo();
    if (stringRestriction == null) {
        stringRestriction = new YangStringRestriction();
        type.setDataTypeExtendedInfo(stringRestriction);
    }
    String patternArgument = removeQuotesAndHandleConcat(ctx.string().getText());
    stringRestriction.addPattern(patternArgument);
}
#method_after
private static void setPatternRestriction(YangType type, GeneratedYangParser.PatternStatementContext ctx) {
    YangStringRestriction stringRestriction;
    if (type.getDataType() != YangDataTypes.STRING && type.getDataType() != YangDataTypes.DERIVED) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(PATTERN_DATA) + " name " + ctx.string().getText() + " can be used to restrict the built-in type string or types derived from string.");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    if (type.getDataType() == YangDataTypes.STRING) {
        stringRestriction = (YangStringRestriction) type.getDataTypeExtendedInfo();
    } else {
        stringRestriction = (YangStringRestriction) ((YangDerivedInfo<?>) type.getDataTypeExtendedInfo()).getExtendedInfo();
    }
    if (stringRestriction == null) {
        stringRestriction = new YangStringRestriction();
        if (type.getDataType() == YangDataTypes.STRING) {
            type.setDataTypeExtendedInfo(stringRestriction);
        } else {
            ((YangDerivedInfo<YangStringRestriction>) type.getDataTypeExtendedInfo()).setExtendedInfo(stringRestriction);
        }
    }
    String patternArgument = ctx.string().getText().replace("\"", EMPTY_STRING);
    stringRestriction.addPattern(patternArgument);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("Missing temporary file handle for" + "current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, false);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("missing temp file hand for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, true);
}
#end_block

#method_before
public static void processUnionEntry(TreeWalkListener listener, GeneratedYangParser.UnionSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, UNION_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangUnion unionNode = new YangUnion();
        Parsable typeData = listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, UNION_DATA, "", ENTRY);
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                // Set the name of union same as leaf.
                unionNode.setName(((YangLeaf) tmpData).getLeafName() + unionClassSuffix);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leaf = listener.getParsedDataStack().pop();
                // Add the union node to the parent holder of leaf.
                addChildToParentNode(listener, unionNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leaf);
                break;
            case LEAF_LIST_DATA:
                // Set the name of union same as leaf list.
                unionNode.setName(((YangLeafList) tmpData).getLeafName() + unionClassSuffix);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leafList = listener.getParsedDataStack().pop();
                // Add the union node to the parent holder of leaf.
                addChildToParentNode(listener, unionNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leafList);
                break;
            case UNION_DATA:
                YangUnion yangUnion = (YangUnion) tmpData;
                /*
                     * In case parent of union is again a union, name of the
                     * child union is parent union name suffixed with running
                     * integer number, this is done because under union there
                     * could be multiple child union types.
                     */
                unionNode.setName(yangUnion.getName() + unionClassSuffix + yangUnion.getChildUnionNumber());
                // Increment the running number.
                yangUnion.setChildUnionNumber(yangUnion.getChildUnionNumber());
                // Add union as a child to parent union.
                addChildToParentNode(listener, unionNode);
                break;
            case TYPEDEF_DATA:
                YangTypeDef typeDef = (YangTypeDef) tmpData;
                // Set the name of union same as typedef name.
                unionNode.setName(typeDef.getName() + unionClassSuffix);
                // Add union as a child to parent type def.
                addChildToParentNode(listener, unionNode);
                break;
            // TODO deviate.
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ((YangType<?>) typeData).getDataTypeName(), ENTRY));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(unionNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, UNION_DATA, "", ENTRY));
    }
}
#method_after
public static void processUnionEntry(TreeWalkListener listener, GeneratedYangParser.UnionSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, UNION_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangUnion unionNode = new YangUnion();
        Parsable typeData = listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, UNION_DATA, "", ENTRY);
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                // Set the name of union same as leaf.
                unionNode.setName(((YangLeaf) tmpData).getLeafName() + UNION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leaf = listener.getParsedDataStack().pop();
                // Add the union node to the parent holder of leaf.
                addChildToParentNode(listener, unionNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leaf);
                break;
            case LEAF_LIST_DATA:
                // Set the name of union same as leaf list.
                unionNode.setName(((YangLeafList) tmpData).getLeafName() + UNION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leafList = listener.getParsedDataStack().pop();
                // Add the union node to the parent holder of leaf.
                addChildToParentNode(listener, unionNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leafList);
                break;
            case UNION_DATA:
                YangUnion parentUnion = (YangUnion) tmpData;
                /*
                     * In case parent of union is again a union, name of the
                     * child union is parent union name suffixed with running
                     * integer number, this is done because under union there
                     * could be multiple child union types.
                     */
                unionNode.setName(parentUnion.getName() + UNION_CLASS_SUFFIX + parentUnion.getChildUnionNumber());
                // Increment the running number.
                parentUnion.setChildUnionNumber(parentUnion.getChildUnionNumber() + 1);
                // Add union as a child to parent union.
                addChildToParentNode(listener, unionNode);
                break;
            case TYPEDEF_DATA:
                YangTypeDef typeDef = (YangTypeDef) tmpData;
                // Set the name of union same as typedef name.
                unionNode.setName(typeDef.getName() + UNION_CLASS_SUFFIX);
                // Add union as a child to parent type def.
                addChildToParentNode(listener, unionNode);
                break;
            // TODO deviate.
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ((YangType<?>) typeData).getDataTypeName(), ENTRY));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(unionNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, UNION_DATA, "", ENTRY));
    }
}
#end_block

#method_before
public static void processEnumerationEntry(TreeWalkListener listener, GeneratedYangParser.EnumSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangEnumeration enumerationNode = new YangEnumeration();
        Parsable typeData = listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                // Set the name of enumeration same as leaf.
                enumerationNode.setName(((YangLeaf) tmpData).getLeafName() + enumClassSuffix);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leaf = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leaf);
                break;
            case LEAF_LIST_DATA:
                // Set the name of enumeration same as leaf list.
                enumerationNode.setName(((YangLeafList) tmpData).getLeafName() + enumClassSuffix);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leafList = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leafList);
                break;
            case UNION_DATA:
                YangUnion yangUnion = (YangUnion) tmpData;
                /*
                     * In case parent of enumeration is a union, name of the
                     * enumeration is parent union name suffixed with running
                     * integer number, this is done because under union there
                     * could be multiple child union types.
                     */
                enumerationNode.setName(yangUnion.getName() + yangUnion.getChildUnionNumber() + enumClassSuffix);
                // Increment the running number.
                yangUnion.setChildUnionNumber(yangUnion.getChildUnionNumber());
                // Add union as a child to parent union.
                addChildToParentNode(listener, enumerationNode);
                break;
            case TYPEDEF_DATA:
                YangTypeDef typeDef = (YangTypeDef) tmpData;
                // Set the name of enumeration same as typedef name.
                enumerationNode.setName(typeDef.getName() + enumClassSuffix);
                // Add enumeration as a child to parent type def.
                addChildToParentNode(listener, enumerationNode);
                break;
            // TODO deviate.
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ((YangType<?>) typeData).getDataTypeName(), ENTRY));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(enumerationNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ENUMERATION_DATA, "", ENTRY));
    }
}
#method_after
public static void processEnumerationEntry(TreeWalkListener listener, GeneratedYangParser.EnumSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangEnumeration enumerationNode = new YangEnumeration();
        Parsable typeData = listener.getParsedDataStack().pop();
        // Check for stack to be non empty.
        checkStackIsNotEmpty(listener, MISSING_HOLDER, ENUMERATION_DATA, "", ENTRY);
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                // Set the name of enumeration same as leaf.
                enumerationNode.setName(((YangLeaf) tmpData).getLeafName() + ENUMERATION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leaf = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leaf);
                break;
            case LEAF_LIST_DATA:
                // Set the name of enumeration same as leaf list.
                enumerationNode.setName(((YangLeafList) tmpData).getLeafName() + ENUMERATION_CLASS_SUFFIX);
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leafList = listener.getParsedDataStack().pop();
                // Add the enumeration node to the parent holder of leaf.
                addChildToParentNode(listener, enumerationNode);
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leafList);
                break;
            case UNION_DATA:
                YangUnion yangUnion = (YangUnion) tmpData;
                /*
                     * In case parent of enumeration is a union, name of the
                     * enumeration is parent union name suffixed with running
                     * integer number, this is done because under union there
                     * could be multiple child union types.
                     */
                enumerationNode.setName(yangUnion.getName() + yangUnion.getChildUnionNumber() + ENUMERATION_CLASS_SUFFIX);
                // Increment the running number.
                yangUnion.setChildUnionNumber(yangUnion.getChildUnionNumber() + 1);
                // Add union as a child to parent union.
                addChildToParentNode(listener, enumerationNode);
                break;
            case TYPEDEF_DATA:
                YangTypeDef typeDef = (YangTypeDef) tmpData;
                // Set the name of enumeration same as typedef name.
                enumerationNode.setName(typeDef.getName() + ENUMERATION_CLASS_SUFFIX);
                // Add enumeration as a child to parent type def.
                addChildToParentNode(listener, enumerationNode);
                break;
            // TODO deviate.
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ((YangType<?>) typeData).getDataTypeName(), ENTRY));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(enumerationNode);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, ENUMERATION_DATA, "", ENTRY));
    }
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("missing temp file hand for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, false);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("missing temp file hand for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfRootNode(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String baseCodeGenDir) throws IOException {
    String subModulePkg = getRootPackage(getVersion(), getNameSpaceFromModule(getBelongsTo()), getRevision().getRevDate());
    YangJavaModelUtils.generateCodeOfRootNode(this, baseCodeGenDir, subModulePkg);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("missing temp file hand for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String baseCodeGenDir) throws IOException {
    processGenerateCodeEntryOfRootNode(this, baseCodeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String baseCodeGenDir) throws IOException {
    String modulePkg = getRootPackage(getVersion(), getNameSpace().getUri(), getRevision().getRevDate());
    YangJavaModelUtils.generateCodeOfRootNode(this, baseCodeGenDir, modulePkg);
}
#end_block

#method_before
public static void updatePackageInfo(YangJavaInfo yangJavaInfo, String codeGenDir) throws IOException {
    yangJavaInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) yangJavaInfo).getName())));
    yangJavaInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) yangJavaInfo));
    yangJavaInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(yangJavaInfo.getJavaFileInfo().getPackage()));
    yangJavaInfo.getJavaFileInfo().setBaseCodeGenPath(codeGenDir);
}
#method_after
private static void updatePackageInfo(JavaCodeGeneratorInfo javaCodeGeneratorInfo, String codeGenDir) throws IOException {
    javaCodeGeneratorInfo.getJavaFileInfo().setJavaName(getCaptialCase(getCamelCase(((YangNode) javaCodeGeneratorInfo).getName())));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackage(getCurNodePackage((YangNode) javaCodeGeneratorInfo));
    javaCodeGeneratorInfo.getJavaFileInfo().setPackageFilePath(getPackageDirPathFromJavaJPackage(javaCodeGeneratorInfo.getJavaFileInfo().getPackage()));
    javaCodeGeneratorInfo.getJavaFileInfo().setBaseCodeGenPath(codeGenDir);
}
#end_block

#method_before
public static void createTempFragmentFile(YangJavaInfo yangJavaInfo) throws IOException {
    String absloutePath = getAbsolutePackagePath(yangJavaInfo.getJavaFileInfo().getBaseCodeGenPath(), yangJavaInfo.getJavaFileInfo().getPackageFilePath());
    yangJavaInfo.setTempJavaCodeFragmentFiles(new TempJavaCodeFragmentFiles(yangJavaInfo.getJavaFileInfo().getGeneratedFileTypes(), absloutePath, yangJavaInfo.getJavaFileInfo().getJavaName()));
}
#method_after
private static void createTempFragmentFile(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    String absolutePath = getAbsolutePackagePath(javaCodeGeneratorInfo.getJavaFileInfo().getBaseCodeGenPath(), javaCodeGeneratorInfo.getJavaFileInfo().getPackageFilePath());
    javaCodeGeneratorInfo.setTempJavaCodeFragmentFiles(new TempJavaCodeFragmentFiles(javaCodeGeneratorInfo.getJavaFileInfo().getGeneratedFileTypes(), absolutePath, javaCodeGeneratorInfo.getJavaFileInfo().getJavaName()));
}
#end_block

#method_before
public static void updateLeafInfoInTempFragmentFiles(YangJavaInfo yangJavaInfo) throws IOException {
    if (yangJavaInfo instanceof YangNode) {
        yangJavaInfo.getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles((YangNode) yangJavaInfo);
        yangJavaInfo.getTempJavaCodeFragmentFiles().addCurNodeInfoInParentTempFile((YangNode) yangJavaInfo, false);
    } else {
    // TODO change IO exception to translator exception and throw here
    }
}
#method_after
private static void updateLeafInfoInTempFragmentFiles(JavaCodeGeneratorInfo javaCodeGeneratorInfo) throws IOException {
    if (javaCodeGeneratorInfo instanceof YangLeavesHolder) {
        javaCodeGeneratorInfo.getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles((YangNode) javaCodeGeneratorInfo);
    } else {
    // TODO: either write a util for ENUM and UNION or, call the
    // corresponding implementation in ENUM and UNION
    }
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("missing temp file hand for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, false);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("Missing temp file handle for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, false);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("Missing temporary file handle for" + "current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, false);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("missing temp file hand for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, false);
}
#end_block

#method_before
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new RuntimeException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#method_after
@Override
public JavaFileInfo getJavaFileInfo() {
    if (javaFileInfo == null) {
        throw new TranslatorException("Missing java info in java datamodel node");
    }
    return javaFileInfo;
}
#end_block

#method_before
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    if (tempFileHandle == null) {
        throw new RuntimeException("missing temp file hand for current node " + getJavaFileInfo().getJavaName());
    }
    return tempFileHandle;
}
#method_after
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
    return tempFileHandle;
}
#end_block

#method_before
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    processGenerateCodeEntryOfLeafHolder(this, codeGenDir);
// TODO:getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles(this);
}
#method_after
@Override
public void generateCodeEntry(String codeGenDir) throws IOException {
    generateCodeOfNode(this, codeGenDir, false);
// TODO:getTempJavaCodeFragmentFiles().addCurNodeLeavesInfoToTempFiles(this);
}
#end_block

#method_before
@Override
public TunnelId createOrUpdateTunnel(Tunnel tunnel) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null && !"".equals(tunnel.tunnelId().toString())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        if (old == null) {
            log.info("This tunnel[" + tunnel.tunnelId() + "] is not available.");
            return tunnel.tunnelId();
        }
        DefaultAnnotations oldAnno = (DefaultAnnotations) old.annotations();
        SparseAnnotations newAnno = (SparseAnnotations) tunnel.annotations();
        Tunnel newT = new DefaultTunnel(old.providerId(), old.src(), old.dst(), old.type(), old.state(), old.groupId(), old.tunnelId(), old.tunnelName(), old.path(), DefaultAnnotations.merge(oldAnno, newAnno));
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
        return tunnel.tunnelId();
    } else {
        TunnelId tunnelId = TunnelId.valueOf(idGenerator.getNewId());
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), tunnelId, tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
        TunnelKey key = TunnelKey.tunnelKey(tunnel.src(), tunnel.dst());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        Set<TunnelId> tunnelnameSet = tunnelNameAsKeyStore.get(tunnel.tunnelName());
        if (tunnelnameSet == null) {
            tunnelnameSet = new HashSet<TunnelId>();
        }
        tunnelnameSet.add(tunnelId);
        tunnelNameAsKeyStore.put(tunnel.tunnelName(), tunnelnameSet);
        Set<TunnelId> srcAndDstKeySet = srcAndDstKeyStore.get(key);
        if (srcAndDstKeySet == null) {
            srcAndDstKeySet = new HashSet<TunnelId>();
        }
        srcAndDstKeySet.add(tunnelId);
        srcAndDstKeyStore.put(key, srcAndDstKeySet);
        Set<TunnelId> typeKeySet = typeKeyStore.get(tunnel.type());
        if (typeKeySet == null) {
            typeKeySet = new HashSet<TunnelId>();
        }
        typeKeySet.add(tunnelId);
        typeKeyStore.put(tunnel.type(), typeKeySet);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
        return tunnelId;
    }
}
#method_after
@Override
public TunnelId createOrUpdateTunnel(Tunnel tunnel) {
    return handleCreateOrUpdateTunnel(tunnel, null);
}
#end_block

#method_before
@Override
public TunnelId createOrUpdateTunnel(Tunnel tunnel, State state) {
    // tunnelIdAsKeyStore.
    if (tunnel.tunnelId() != null && !"".equals(tunnel.tunnelId().toString())) {
        Tunnel old = tunnelIdAsKeyStore.get(tunnel.tunnelId());
        if (old == null) {
            log.info("This tunnel[" + tunnel.tunnelId() + "] is not available.");
            return tunnel.tunnelId();
        }
        DefaultAnnotations oldAnno = (DefaultAnnotations) old.annotations();
        SparseAnnotations newAnno = (SparseAnnotations) tunnel.annotations();
        Tunnel newT = new DefaultTunnel(old.providerId(), old.src(), old.dst(), old.type(), state, old.groupId(), old.tunnelId(), old.tunnelName(), old.path(), DefaultAnnotations.merge(oldAnno, newAnno));
        tunnelIdAsKeyStore.put(tunnel.tunnelId(), newT);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_UPDATED, tunnel);
        notifyDelegate(event);
        return tunnel.tunnelId();
    } else {
        TunnelId tunnelId = TunnelId.valueOf(idGenerator.getNewId());
        Tunnel newT = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.state(), tunnel.groupId(), tunnelId, tunnel.tunnelName(), tunnel.path(), tunnel.annotations());
        TunnelKey key = TunnelKey.tunnelKey(tunnel.src(), tunnel.dst());
        tunnelIdAsKeyStore.put(tunnelId, newT);
        Set<TunnelId> tunnelnameSet = tunnelNameAsKeyStore.get(tunnel.tunnelName());
        if (tunnelnameSet == null) {
            tunnelnameSet = new HashSet<TunnelId>();
        }
        tunnelnameSet.add(tunnelId);
        tunnelNameAsKeyStore.put(tunnel.tunnelName(), tunnelnameSet);
        Set<TunnelId> srcAndDstKeySet = srcAndDstKeyStore.get(key);
        if (srcAndDstKeySet == null) {
            srcAndDstKeySet = new HashSet<TunnelId>();
        }
        srcAndDstKeySet.add(tunnelId);
        srcAndDstKeyStore.put(key, srcAndDstKeySet);
        Set<TunnelId> typeKeySet = typeKeyStore.get(tunnel.type());
        if (typeKeySet == null) {
            typeKeySet = new HashSet<TunnelId>();
        }
        typeKeySet.add(tunnelId);
        typeKeyStore.put(tunnel.type(), typeKeySet);
        TunnelEvent event = new TunnelEvent(TunnelEvent.Type.TUNNEL_ADDED, tunnel);
        notifyDelegate(event);
        return tunnelId;
    }
}
#method_after
@Override
public TunnelId createOrUpdateTunnel(Tunnel tunnel, State state) {
    return handleCreateOrUpdateTunnel(tunnel, state);
}
#end_block

#method_before
@DELETE
@Path("{networkId}")
public Response removeVirtualNetwork(@PathParam("networkId") long networkId) {
    final NetworkId nid = NetworkId.networkId(networkId);
    vnetAdminService.removeVirtualNetwork(nid);
    return Response.ok().build();
}
#method_after
@DELETE
@Path("{networkId}")
public Response removeVirtualNetwork(@PathParam("networkId") long networkId) {
    NetworkId nid = NetworkId.networkId(networkId);
    vnetAdminService.removeVirtualNetwork(nid);
    return Response.ok().build();
}
#end_block

#method_before
// VirtualDevice
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{networkId}/devices")
public Response getVirtualDevices(@PathParam("networkId") long networkId) {
    final NetworkId nid = NetworkId.networkId(networkId);
    Set<VirtualDevice> vdevs = vnetService.getVirtualDevices(nid);
    return ok(encodeArray(VirtualDevice.class, "devices", vdevs)).build();
}
#method_after
// VirtualDevice
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{networkId}/devices")
public Response getVirtualDevices(@PathParam("networkId") long networkId) {
    NetworkId nid = NetworkId.networkId(networkId);
    Set<VirtualDevice> vdevs = vnetService.getVirtualDevices(nid);
    return ok(encodeArray(VirtualDevice.class, "devices", vdevs)).build();
}
#end_block

#method_before
@DELETE
@Path("{networkId}/devices/{deviceId}")
public Response removeVirtualDevice(@PathParam("networkId") long networkId, @PathParam("deviceId") String deviceId) {
    final NetworkId nid = NetworkId.networkId(networkId);
    final DeviceId did = DeviceId.deviceId(deviceId);
    vnetAdminService.removeVirtualDevice(nid, did);
    return Response.ok().build();
}
#method_after
@DELETE
@Path("{networkId}/devices/{deviceId}")
public Response removeVirtualDevice(@PathParam("networkId") long networkId, @PathParam("deviceId") String deviceId) {
    NetworkId nid = NetworkId.networkId(networkId);
    DeviceId did = DeviceId.deviceId(deviceId);
    vnetAdminService.removeVirtualDevice(nid, did);
    return Response.ok().build();
}
#end_block

#method_before
// VirtualPort
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{networkId}/devices/{deviceId}/ports")
public Response getVirtualPorts(@PathParam("networkId") long networkId, @PathParam("deviceId") String deviceId) {
    final NetworkId nid = NetworkId.networkId(networkId);
    Iterable<VirtualPort> vports = vnetService.getVirtualPorts(nid, DeviceId.deviceId(deviceId));
    return ok(encodeArray(VirtualPort.class, "ports", vports)).build();
}
#method_after
// VirtualPort
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{networkId}/devices/{deviceId}/ports")
public Response getVirtualPorts(@PathParam("networkId") long networkId, @PathParam("deviceId") String deviceId) {
    NetworkId nid = NetworkId.networkId(networkId);
    Iterable<VirtualPort> vports = vnetService.getVirtualPorts(nid, DeviceId.deviceId(deviceId));
    return ok(encodeArray(VirtualPort.class, "ports", vports)).build();
}
#end_block

#method_before
@DELETE
@Path("{networkId}/devices/{deviceId}/ports/{portNum}")
public Response removeVirtualPort(@PathParam("networkId") long networkId, @PathParam("deviceId") String deviceId, @PathParam("portNum") long portNum) {
    final NetworkId nid = NetworkId.networkId(networkId);
    vnetAdminService.removeVirtualPort(nid, DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum));
    return Response.ok().build();
}
#method_after
@DELETE
@Path("{networkId}/devices/{deviceId}/ports/{portNum}")
public Response removeVirtualPort(@PathParam("networkId") long networkId, @PathParam("deviceId") String deviceId, @PathParam("portNum") long portNum) {
    NetworkId nid = NetworkId.networkId(networkId);
    vnetAdminService.removeVirtualPort(nid, DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum));
    return Response.ok().build();
}
#end_block

#method_before
// VirtualLink
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{networkId}/links")
public Response getVirtualLinks(@PathParam("networkId") long networkId) {
    final NetworkId nid = NetworkId.networkId(networkId);
    Set<VirtualLink> vlinks = vnetService.getVirtualLinks(nid);
    return ok(encodeArray(VirtualLink.class, "links", vlinks)).build();
}
#method_after
// VirtualLink
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{networkId}/links")
public Response getVirtualLinks(@PathParam("networkId") long networkId) {
    NetworkId nid = NetworkId.networkId(networkId);
    Set<VirtualLink> vlinks = vnetService.getVirtualLinks(nid);
    return ok(encodeArray(VirtualLink.class, "links", vlinks)).build();
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    metricsService.unregisterReporter(this);
    stopReport();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    stopReport();
    metricsService.unregisterReporter(this);
    log.info("Stopped");
}
#end_block

#method_before
@Activate
public void activate() {
    cfgService.registerProperties(getClass());
    coreService.registerApplication("org.onosproject.influxdbmetrics");
    metricsService.registerReporter(this);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    cfgService.registerProperties(getClass());
    coreService.registerApplication("org.onosproject.influxdbmetrics");
    metricsService.registerReporter(this);
    startReport();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    metricsService.unregisterReporter(this);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    stopReport();
    metricsService.unregisterReporter(this);
    log.info("Stopped");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    metricsService.unregisterReporter(this);
    stopReport();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.unregisterProperties(getClass(), false);
    stopReport();
    metricsService.unregisterReporter(this);
    log.info("Stopped");
}
#end_block

#method_before
public void startReport() {
    configGraphite();
    graphiteReporter.start(reportPeriod, REPORT_TIME_UNIT);
    log.info("Start to report metrics to graphite server.");
}
#method_after
public void startReport() {
    configGraphite();
    graphiteReporter = buildReporter(graphite);
    graphiteReporter.start(reportPeriod, REPORT_TIME_UNIT);
    log.info("Start to report metrics to graphite server.");
}
#end_block

#method_before
@Override
public void enterRangeStatement(GeneratedYangParser.RangeStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterRangeStatement(GeneratedYangParser.RangeStatementContext ctx) {
    RangeRestrictionListener.processRangeRestrictionEntry(this, ctx);
}
#end_block

#method_before
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitAugmentStatement(GeneratedYangParser.AugmentStatementContext ctx) {
    AugmentListener.processAugmentExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
    RpcListener.processRpcEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitRpcStatement(GeneratedYangParser.RpcStatementContext ctx) {
    RpcListener.processRpcExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterInputStatement(GeneratedYangParser.InputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterInputStatement(GeneratedYangParser.InputStatementContext ctx) {
    InputListener.processInputEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitInputStatement(GeneratedYangParser.InputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitInputStatement(GeneratedYangParser.InputStatementContext ctx) {
    InputListener.processInputExit(this, ctx);
}
#end_block

#method_before
@Override
public void enterOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void enterOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
    OutputListener.processOutputEntry(this, ctx);
}
#end_block

#method_before
@Override
public void exitOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
// TODO: implement the method.
}
#method_after
@Override
public void exitOutputStatement(GeneratedYangParser.OutputStatementContext ctx) {
    OutputListener.processOutputExit(this, ctx);
}
#end_block

#method_before
@Override
public List<YangImport> getImportList() {
    return importList;
}
#method_after
public List<YangImport> getImportList() {
    return importList;
}
#end_block

#method_before
@Override
public void addToImportList(YangImport importedModule) {
    getImportList().add(importedModule);
}
#method_after
public void addToImportList(YangImport importedModule) {
    getImportList().add(importedModule);
}
#end_block

#method_before
@Override
public List<YangInclude> getIncludeList() {
    return includeList;
}
#method_after
public List<YangInclude> getIncludeList() {
    return includeList;
}
#end_block

#method_before
@Override
public void addToIncludeList(YangInclude includeModule) {
    getIncludeList().add(includeModule);
}
#method_after
public void addToIncludeList(YangInclude includeModule) {
    getIncludeList().add(includeModule);
}
#end_block

#method_before
@Override
public String getPrefix() {
    return prefix;
}
#method_after
public String getPrefix() {
    return prefix;
}
#end_block

#method_before
@Override
public void setPrefix(String prefix) {
    this.prefix = prefix;
}
#method_after
public void setPrefix(String prefix) {
    this.prefix = prefix;
}
#end_block

#method_before
public List<String> getImports(JavaAttributeInfo attr) {
    String importString;
    List<String> imports = new ArrayList<>();
    for (JavaQualifiedTypeInfo importInfo : getImportSet()) {
        importString = IMPORT;
        if (importInfo.getPkgInfo() != EMPTY_STRING && importInfo.getClassInfo() != null && importInfo.getPkgInfo() != JAVA_LANG) {
            importString = importString + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
            imports.add(importString);
        }
    }
    if (attr.isListAttr()) {
        imports.add(setImportForList());
    }
    java.util.Collections.sort(imports);
    return imports;
}
#method_after
public List<String> getImports(JavaAttributeInfo attr) {
    String importString;
    List<String> imports = new ArrayList<>();
    for (JavaQualifiedTypeInfo importInfo : getImportSet()) {
        importString = IMPORT;
        if (importInfo.getPkgInfo() != EMPTY_STRING && importInfo.getClassInfo() != null && importInfo.getPkgInfo() != JAVA_LANG) {
            importString = importString + importInfo.getPkgInfo() + PERIOD + importInfo.getClassInfo() + SEMI_COLAN + NEW_LINE;
            imports.add(importString);
        }
    }
    if (attr.isListAttr()) {
        imports.add(getImportForList());
    }
    java.util.Collections.sort(imports);
    return imports;
}
#end_block

#method_before
@Override
public List<YangImport> getImportList() {
    return importList;
}
#method_after
public List<YangImport> getImportList() {
    return importList;
}
#end_block

#method_before
@Override
public void addToImportList(YangImport importedModule) {
    getImportList().add(importedModule);
}
#method_after
public void addToImportList(YangImport importedModule) {
    getImportList().add(importedModule);
}
#end_block

#method_before
@Override
public List<YangInclude> getIncludeList() {
    return includeList;
}
#method_after
public List<YangInclude> getIncludeList() {
    return includeList;
}
#end_block

#method_before
@Override
public void addToIncludeList(YangInclude includeModule) {
    getIncludeList().add(includeModule);
}
#method_after
public void addToIncludeList(YangInclude includeModule) {
    getIncludeList().add(includeModule);
}
#end_block

#method_before
public static void processTypeExit(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_CURRENT_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT);
    Parsable parsableType = listener.getParsedDataStack().pop();
    if (!(parsableType instanceof YangType)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    YangType<?> type = (YangType<?>) parsableType;
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT);
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) parentNodeOfLeaf, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) parentNodeOfLeafList, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addToTypeList(type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType(type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, typeDef, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
}
#method_after
public static void processTypeExit(TreeWalkListener listener, GeneratedYangParser.TypeStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_CURRENT_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT);
    Parsable parsableType = listener.getParsedDataStack().pop();
    if (!(parsableType instanceof YangType)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
    YangType<?> type = (YangType<?>) parsableType;
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT);
    YangDataTypes yangDataTypes = YangDataTypes.getType(ctx.string().getText());
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            YangLeaf leaf = (YangLeaf) tmpData;
            leaf.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) parentNodeOfLeaf, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case LEAF_LIST_DATA:
            YangLeafList leafList = (YangLeafList) tmpData;
            leafList.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Parent YANG node of leaf to be added in resolution information.
                Parsable leafListData = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                listener.getParsedDataStack().push(leafListData);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
                }
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) parentNodeOfLeafList, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        case UNION_DATA:
            YangUnion unionNode = (YangUnion) tmpData;
            try {
                unionNode.addToTypeList((YangType<?>) type);
            } catch (DataModelException e) {
                ParserException parserException = new ParserException(e.getMessage());
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            break;
        case TYPEDEF_DATA:
            /* Prepare the base type info and set in derived type */
            YangTypeDef typeDef = (YangTypeDef) tmpData;
            typeDef.setDataType((YangType<?>) type);
            /*
                 * If data type is derived, resolution information to be added
                 * in resolution list.
                 */
            if (yangDataTypes == YangDataTypes.DERIVED) {
                // Get the prefix information
                String prefix = ((YangType<?>) type).getPrefix();
                // Create empty derived info and attach it to type extended info.
                YangDerivedInfo<?> yangDerivedInfo = new YangDerivedInfo<>();
                ((YangType<YangDerivedInfo>) type).setDataTypeExtendedInfo(yangDerivedInfo);
                // Add resolution information to the list
                YangResolutionInfo resolutionInfo = new YangResolutionInfo<YangType>(type, ResolutionType.TYPEDEF_RESOLUTION, (YangNode) typeDef, prefix, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
            }
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, TYPE_DATA, ctx.string().getText(), EXIT));
    }
}
#end_block

#method_before
private boolean resolveLinkingForNode(YangNode node, YangNode parentNode) throws DataModelException {
    /*
         * Check if name of node name matches with the entity name under
         * resolution.
         */
    if (isNodeNameSameAsResolutionInfoName(node)) {
        // Add reference of entity to the node under resolution.
        addReferredEntityLink(node);
        // Check if referred entity has further reference to uses/type.
        if (!(isMoreReferencePresent(node))) {
            // Resolve all the entities in stack.
            resolveStackAndAddToStack(node);
            return true;
        } else {
            // Add referred type/uses to the stack.
            addToPartialResolvedStack(node);
            /*
                 * Check whether referred type is resolved, partially resolved
                 * or unresolved.
                 */
            if (isReferenceFullyResolved()) {
                // Resolve the stack which is complete.
                resolveCompleteStack();
                return true;
            } else if (isReferencePartiallyResolved()) {
                /*
                     * Update the resolution type to partially resolved for all
                     * type/uses in stack
                     */
                updateResolutionTypeToPartial();
                return true;
            } else {
                /*
                     * Check if prefix is present to find that the derived
                     * reference is for intra file or inter file, if it's
                     * inter-file return and stop further processing.
                     */
                if (isExternalPrefixPresent(node)) {
                    /*
                         * Update the resolution type to partially resolved for
                         * all type/uses in stack
                         */
                    updateResolutionTypeToPartial();
                    return true;
                } else {
                    /*
                         * If prefix is not present it indicates intra-file
                         * dependency in this case set the node back to first
                         * child, as referred entity may appear in any order and
                         * continue with the resolution.
                         */
                    isMoreReferenceDetected = true;
                    return false;
                }
            }
        }
    }
    return false;
}
#method_after
private boolean resolveLinkingForNode(YangNode node, YangNode parentNode) throws DataModelException {
    /*
         * Check if name of node name matches with the entity name under
         * resolution.
         */
    if (isNodeNameSameAsResolutionInfoName(node)) {
        // Adds reference of entity to the node under resolution.
        addReferredEntityLink(node);
        // Check if referred entity has further reference to uses/type.
        if (!(isMoreReferencePresent(node))) {
            // Resolve all the entities in stack.
            resolveStackAndAddToStack(node);
            return true;
        } else {
            // Adds referred type/uses to the stack.
            addToPartialResolvedStack(node);
            /*
                 * Check whether referred type is resolved, partially resolved
                 * or unresolved.
                 */
            if (isReferenceFullyResolved()) {
                // Resolve the stack which is complete.
                resolveCompleteStack();
                return true;
            } else if (isReferencePartiallyResolved()) {
                /*
                     * Update the resolution type to partially resolved for all
                     * type/uses in stack
                     */
                updateResolutionTypeToPartial();
                return true;
            } else {
                /*
                     * Check if prefix is present to find that the derived
                     * reference is for intra file or inter file, if it's
                     * inter-file return and stop further processing.
                     */
                if (isExternalPrefixPresent(node)) {
                    /*
                         * Update the resolution type to partially resolved for
                         * all type/uses in stack
                         */
                    updateResolutionTypeToPartial();
                    return true;
                } else {
                    /*
                         * If prefix is not present it indicates intra-file
                         * dependency in this case set the node back to first
                         * child, as referred entity may appear in any order and
                         * continue with the resolution.
                         */
                    isMoreReferenceDetected = true;
                    return false;
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
private void updateResolutionTypeToPartial() throws DataModelException {
    // For all entries in stack calls for the resolution in type/uses.
    for (T entity : getPartialResolvedStack()) {
        if (!(entity instanceof Resolvable)) {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
        if (((Resolvable) entity).getResolvableStatus() == ResolvableStatus.UNRESOLVED) {
            // Set the resolution status in inside the type/uses.
            ((Resolvable) entity).setResolvableStatus(ResolvableStatus.PARTIALLY_RESOLVED);
        }
    }
}
#method_after
private void updateResolutionTypeToPartial() throws DataModelException {
    // For all entries in stack calls for the resolution in type/uses.
    for (T entity : getPartialResolvedStack()) {
        if (!(entity instanceof Resolvable)) {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
        if (((Resolvable) entity).getResolvableStatus() == ResolvableStatus.UNRESOLVED) {
            // Sets the resolution status in inside the type/uses.
            ((Resolvable) entity).setResolvableStatus(ResolvableStatus.PARTIALLY_RESOLVED);
        }
    }
}
#end_block

#method_before
private void resolveStackAndAddToStack(YangNode node) throws DataModelException {
    if (getEntityToResolve() instanceof YangType) {
        // Add to the stack only for YANG typedef.
        getPartialResolvedStack().push((T) ((YangTypeDef) node).getDataType());
    }
    // Don't add to stack in case of YANG grouping.
    // Resolve the complete stack.
    resolveCompleteStack();
}
#method_after
private void resolveStackAndAddToStack(YangNode node) throws DataModelException {
    if (getEntityToResolve() instanceof YangType) {
        // Adds to the stack only for YANG typedef.
        getPartialResolvedStack().push((T) ((YangTypeDef) node).getDataType());
    }
    // Don't add to stack in case of YANG grouping.
    // Resolve the complete stack.
    resolveCompleteStack();
}
#end_block

#method_before
private void resolveCompleteStack() throws DataModelException {
    // For all entries in stack calls for the resolution in type/uses.
    for (T entity : getPartialResolvedStack()) {
        if (!(entity instanceof Resolvable)) {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
        ((Resolvable) entity).resolve();
        // Set the resolution status in inside the type/uses.
        ((Resolvable) entity).setResolvableStatus(ResolvableStatus.RESOLVED);
    }
    /*
         * Set the resolution status in resolution info present in resolution
         * list.
         */
    setIsResolved(true);
}
#method_after
private void resolveCompleteStack() throws DataModelException {
    // For all entries in stack calls for the resolution in type/uses.
    for (T entity : getPartialResolvedStack()) {
        if (!(entity instanceof Resolvable)) {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
        ((Resolvable) entity).resolve();
        // Sets the resolution status in inside the type/uses.
        ((Resolvable) entity).setResolvableStatus(ResolvableStatus.RESOLVED);
    }
    /*
         * Sets the resolution status in resolution info present in resolution
         * list.
         */
    setIsResolved(true);
}
#end_block

#method_before
private void addToPartialResolvedStack(YangNode node) throws DataModelException {
    if (getPartialResolvedStack().peek() instanceof YangType) {
        // Add to the stack only for YANG typedef.
        getPartialResolvedStack().push((T) ((YangTypeDef) node).getDataType());
    } else if (getPartialResolvedStack().peek() instanceof YangUses) {
        getPartialResolvedStack().push((T) getUsesInGrouping(node));
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
}
#method_after
private void addToPartialResolvedStack(YangNode node) throws DataModelException {
    if (getPartialResolvedStack().peek() instanceof YangType) {
        // Adds to the stack only for YANG typedef.
        getPartialResolvedStack().push((T) ((YangTypeDef) node).getDataType());
    } else if (getPartialResolvedStack().peek() instanceof YangUses) {
        getPartialResolvedStack().push((T) getUsesInGrouping(node));
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
}
#end_block

#method_before
public String getTargetNode() {
    return targetNode;
}
#method_after
public List<YangNodeIdentifier> getTargetNode() {
    return targetNode;
}
#end_block

#method_before
public void setTargetNode(String targetNode) {
    this.targetNode = targetNode;
}
#method_after
public void setTargetNode(List<YangNodeIdentifier> nodeIdentifiers) {
    this.targetNode = nodeIdentifiers;
}
#end_block

#method_before
@Override
public String getName() {
    return targetNode;
}
#method_after
@Override
public String getName() {
    return name;
}
#end_block

#method_before
@Override
public void setName(String name) {
    targetNode = name;
}
#method_after
@Override
public void setName(String name) {
    this.name = name;
}
#end_block

#method_before
public Map<DeviceId, Ip4Address> nodes() {
    Map<DeviceId, Ip4Address> nodeMap = Maps.newHashMap();
    JsonNode jsonNodes = object.get(NODES);
    if (jsonNodes == null) {
        log.error("There's no node information");
        return null;
    }
    jsonNodes.forEach(jsonNode -> {
        try {
            nodeMap.putIfAbsent(DeviceId.deviceId(jsonNode.path(BRIDGE_ID).asText()), Ip4Address.valueOf(jsonNode.path(DATAPLANE_IP).asText()));
        } catch (IllegalArgumentException | NullPointerException e) {
            log.error("Failed to read {}", e.toString());
        }
    });
    return nodeMap;
}
#method_after
public Map<DeviceId, Ip4Address> nodes() {
    Map<DeviceId, Ip4Address> nodeMap = Maps.newHashMap();
    JsonNode jsonNodes = object.get(NODES);
    if (jsonNodes == null) {
        log.error("There's no node information");
        return null;
    }
    jsonNodes.forEach(jsonNode -> {
        try {
            nodeMap.putIfAbsent(DeviceId.deviceId(jsonNode.path(BRIDGE_ID).asText()), Ip4Address.valueOf(jsonNode.path(DATAPLANE_IP).asText()));
        } catch (IllegalArgumentException | NullPointerException e) {
            log.error("Failed to read {}", e.getMessage());
        }
    });
    return nodeMap;
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    deviceService.removeListener(internalDeviceListener);
    deviceEventExecutorService.shutdown();
    configEventExecutorService.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    deviceService.removeListener(internalDeviceListener);
    deviceEventExecutorService.shutdown();
    configEventExecutorService.shutdown();
    hostService.removeListener(internalHostListener);
    configService.removeListener(configListener);
    configRegistry.unregisterConfigFactory(configFactory);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.deviceOwner().equals(ROUTER_INTERFACE) && !openstackPort.deviceOwner().equals(DEVICE_OWNER_GATEWAY)) {
        if (!openstackPort.fixedIps().isEmpty()) {
            registerDhcpInfo(openstackPort);
        }
    }
}
#method_after
@Override
public void createPorts(OpenstackPort openstackPort) {
    if (!openstackPort.deviceOwner().equals(ROUTER_INTERFACE) && !openstackPort.deviceOwner().equals(DEVICE_OWNER_GATEWAY) && !openstackPort.fixedIps().isEmpty()) {
        registerDhcpInfo(openstackPort);
    }
}
#end_block

#method_before
@Override
public void removePort(String uuid) {
    // When VMs are remvoed, the flow rules for the VMs are removed using ONOS port update event.
    // But, when router is removed, no ONOS port event occurs and we need to use Neutron port event.
    // Here we should not touch any rules for VMs.
    log.debug("port {} was removed", uuid);
    String routerPortName = PORTNAME_PREFIX_ROUTER + uuid.substring(0, 11);
    OpenstackPortInfo routerPortInfo = openstackPortInfoMap.get(routerPortName);
    if (routerPortInfo != null) {
        dhcpService.removeStaticMapping(routerPortInfo.mac());
        deviceService.getPorts(routerPortInfo.deviceId()).forEach(port -> {
            String pName = port.annotations().value("portName");
            if (pName.equals(routerPortName)) {
                OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, openstackService, driverService, config);
                rulePopulator.removeSwitchingRules(port, openstackPortInfoMap);
                openstackPortInfoMap.remove(routerPortName);
                return;
            }
        });
    }
}
#method_after
@Override
public void removePort(String uuid) {
    // When VMs are remvoed, the flow rules for the VMs are removed using ONOS port update event.
    // But, when router is removed, no ONOS port event occurs and we need to use Neutron port event.
    // Here we should not touch any rules for VMs.
    log.debug("port {} was removed", uuid);
    String routerPortName = PORTNAME_PREFIX_ROUTER + uuid.substring(0, 11);
    OpenstackPortInfo routerPortInfo = openstackPortInfoMap.get(routerPortName);
    if (routerPortInfo != null) {
        dhcpService.removeStaticMapping(routerPortInfo.mac());
        deviceService.getPorts(routerPortInfo.deviceId()).forEach(port -> {
            String pName = port.annotations().value(PORTNAME);
            if (pName.equals(routerPortName)) {
                OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, openstackService, driverService, config);
                rulePopulator.removeSwitchingRules(port, openstackPortInfoMap);
                openstackPortInfoMap.remove(routerPortName);
                return;
            }
        });
    }
}
#end_block

#method_before
private void processPortUpdated(Device device, Port port) {
    String portName = port.annotations().value(PORTNAME);
    synchronized (openstackPortInfoMap) {
        if (portName.startsWith(PORTNAME_PREFIX_VM)) {
            if (port.isEnabled()) {
                OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, openstackService, driverService, config);
                rulePopulator.populateSwitchingRules(device, port);
                OpenstackPort openstackPort = rulePopulator.openstackPort(port);
                Ip4Address vmIp = (Ip4Address) openstackPort.fixedIps().values().stream().findAny().orElseGet(null);
                openstackPort.securityGroups().stream().forEach(sgId -> sgRulePopulator.populateSecurityGroupRules(device.id(), sgId, vmIp, openstackPortInfoMap));
                updatePortMap(device.id(), port.annotations().value(PORTNAME), openstackService.networks(), openstackService.subnets(), openstackPort);
            // In case portupdate event is driven by vm shutoff from openstack
            } else if (!port.isEnabled() && openstackPortInfoMap.containsKey(portName)) {
                log.debug("Flowrules according to the port {} were removed", port.number().toString());
                OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, openstackService, driverService, config);
                rulePopulator.removeSwitchingRules(port, openstackPortInfoMap);
                openstackPortInfoMap.get(portName).securityGroups().stream().forEach(sgId -> sgRulePopulator.removeSecurityGroupRules(device.id(), sgId, openstackPortInfoMap.get(portName).ip(), openstackPortInfoMap, securityGroupMap));
                dhcpService.removeStaticMapping(openstackPortInfoMap.get(port.annotations().value(PORTNAME)).mac());
                openstackPortInfoMap.remove(port.annotations().value(PORTNAME));
            }
        }
    }
}
#method_after
private void processPortUpdated(Device device, Port port) {
    String portName = port.annotations().value(PORTNAME);
    synchronized (openstackPortInfoMap) {
        if (portName.startsWith(PORTNAME_PREFIX_VM)) {
            if (port.isEnabled()) {
                OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, openstackService, driverService, config);
                rulePopulator.populateSwitchingRules(device, port);
                OpenstackPort openstackPort = rulePopulator.openstackPort(port);
                Ip4Address vmIp = (Ip4Address) openstackPort.fixedIps().values().stream().findAny().orElseGet(null);
                openstackPort.securityGroups().stream().forEach(sgId -> sgRulePopulator.populateSecurityGroupRules(device.id(), sgId, vmIp, openstackPortInfoMap));
                updatePortMap(device.id(), port.annotations().value(PORTNAME), openstackService.networks(), openstackService.subnets(), openstackPort);
            // In case portupdate event is driven by vm shutoff from openstack
            } else if (!port.isEnabled() && openstackPortInfoMap.containsKey(portName)) {
                log.debug("Flowrules according to the port {} were removed", port.number());
                OpenstackSwitchingRulePopulator rulePopulator = new OpenstackSwitchingRulePopulator(appId, flowObjectiveService, deviceService, openstackService, driverService, config);
                rulePopulator.removeSwitchingRules(port, openstackPortInfoMap);
                openstackPortInfoMap.get(portName).securityGroups().stream().forEach(sgId -> sgRulePopulator.removeSecurityGroupRules(device.id(), sgId, openstackPortInfoMap.get(portName).ip(), openstackPortInfoMap, securityGroupMap));
                dhcpService.removeStaticMapping(openstackPortInfoMap.get(port.annotations().value(PORTNAME)).mac());
                openstackPortInfoMap.remove(port.annotations().value(PORTNAME));
            }
        }
    }
}
#end_block

#method_before
private void processPortRemoved(Device device, Port port) {
    log.debug("port {} is removed", port.toString());
}
#method_after
private void processPortRemoved(Port port) {
    log.debug("port {} is removed", port.toString());
}
#end_block

#method_before
private void registerDhcpInfo(OpenstackPort openstackPort) {
    Ip4Address ip4Address;
    Ip4Address subnetMask;
    Ip4Address gatewayIPAddress;
    Ip4Address dhcpServer;
    Ip4Address domainServer;
    OpenstackSubnet openstackSubnet;
    ip4Address = (Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null);
    openstackSubnet = openstackService.subnets().stream().filter(n -> n.networkId().equals(openstackPort.networkId())).findFirst().get();
    subnetMask = Ip4Address.valueOf(buildSubnetMask(openstackSubnet.cidr()));
    gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
    dhcpServer = gatewayIPAddress;
    // TODO: supports multiple DNS servers
    if (openstackSubnet.dnsNameservers().isEmpty()) {
        domainServer = Ip4Address.valueOf("8.8.8.8");
    } else {
        domainServer = openstackSubnet.dnsNameservers().get(0);
    }
    List<Ip4Address> options = Lists.newArrayList();
    options.add(subnetMask);
    options.add(dhcpServer);
    options.add(gatewayIPAddress);
    options.add(domainServer);
    dhcpService.setStaticMapping(openstackPort.macAddress(), ip4Address, true, options);
}
#method_after
private void registerDhcpInfo(OpenstackPort openstackPort) {
    Ip4Address ip4Address, subnetMask, gatewayIPAddress, dhcpServer, domainServer;
    OpenstackSubnet openstackSubnet;
    ip4Address = (Ip4Address) openstackPort.fixedIps().values().stream().findFirst().orElse(null);
    openstackSubnet = openstackService.subnets().stream().filter(n -> n.networkId().equals(openstackPort.networkId())).findFirst().get();
    subnetMask = Ip4Address.valueOf(buildSubnetMask(openstackSubnet.cidr()));
    gatewayIPAddress = Ip4Address.valueOf(openstackSubnet.gatewayIp());
    dhcpServer = gatewayIPAddress;
    // TODO: supports multiple DNS servers
    if (openstackSubnet.dnsNameservers().isEmpty()) {
        domainServer = Ip4Address.valueOf(DNS_SERVER_IP);
    } else {
        domainServer = openstackSubnet.dnsNameservers().get(0);
    }
    List<Ip4Address> options = ImmutableList.of(subnetMask, dhcpServer, gatewayIPAddress, domainServer);
    dhcpService.setStaticMapping(openstackPort.macAddress(), ip4Address, true, options);
}
#end_block

#method_before
private byte[] buildSubnetMask(String cidr) {
    int prefix;
    String[] parts = cidr.split("/");
    prefix = Integer.parseInt(parts[1]);
    int mask = 0xffffffff << (32 - prefix);
    byte[] bytes = new byte[] { (byte) (mask >>> 24), (byte) (mask >> 16 & 0xff), (byte) (mask >> 8 & 0xff), (byte) (mask & 0xff) };
    return bytes;
}
#method_after
private byte[] buildSubnetMask(String cidr) {
    int prefix;
    String[] parts = cidr.split(FORWARD_SLASH);
    prefix = Integer.parseInt(parts[1]);
    int mask = 0xffffffff << (32 - prefix);
    byte[] bytes = new byte[] { (byte) (mask >>> 24), (byte) (mask >> 16 & 0xff), (byte) (mask >> 8 & 0xff), (byte) (mask & 0xff) };
    return bytes;
}
#end_block

#method_before
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                processDeviceAdded((Device) deviceEvent.subject());
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = (Device) deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    processDeviceAdded(device);
                }
                break;
            case PORT_ADDED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved((Device) deviceEvent.subject(), deviceEvent.port());
                break;
            default:
                log.debug("Unsupported deviceEvent type {}", deviceEvent.type().toString());
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                processHostRemoved((Host) hostEvent.subject());
                break;
            default:
                log.debug("Unsupported hostEvent type {}", hostEvent.type().toString());
                break;
        }
    }
}
#method_after
@Override
public void run() {
    if (event instanceof DeviceEvent) {
        DeviceEvent deviceEvent = (DeviceEvent) event;
        switch(deviceEvent.type()) {
            case DEVICE_ADDED:
                log.debug("device {} is added", deviceEvent.subject().id());
                break;
            case DEVICE_AVAILABILITY_CHANGED:
                Device device = deviceEvent.subject();
                if (deviceService.isAvailable(device.id())) {
                    log.debug("device {} is added", device.id());
                }
                break;
            case PORT_ADDED:
                processPortUpdated(deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_UPDATED:
                processPortUpdated(deviceEvent.subject(), deviceEvent.port());
                break;
            case PORT_REMOVED:
                processPortRemoved(deviceEvent.port());
                break;
            default:
                log.debug("Unsupported deviceEvent type {}", deviceEvent.type().toString());
                break;
        }
    } else if (event instanceof HostEvent) {
        HostEvent hostEvent = (HostEvent) event;
        switch(hostEvent.type()) {
            case HOST_REMOVED:
                log.debug("host {} was removed", hostEvent.subject().toString());
                break;
            default:
                log.debug("Unsupported hostEvent type {}", hostEvent.type().toString());
                break;
        }
    }
}
#end_block

#method_before
private boolean findPortinDevice(Device d, String openstackPortName) {
    Port port = deviceService.getPorts(d.id()).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).findAny().orElse(null);
    return port != null ? true : false;
}
#method_after
private boolean findPortinDevice(Device d, String openstackPortName) {
    Port port = deviceService.getPorts(d.id()).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).findAny().orElse(null);
    return port != null;
}
#end_block

#method_before
public void removeExternalRules(OpenstackRouterInterface routerInterface) {
    OpenstackSubnet openstackSubnet = openstackService.subnet(routerInterface.subnetId());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(openstackSubnet.networkId())).matchEthDst(GATEWAYMAC);
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).forEach(d -> {
        if (checkGatewayNode(d.id())) {
            removeRule(d.id(), sBuilder, ForwardingObjective.Flag.VERSATILE, ROUTING_RULE_PRIORITY);
        } else {
            removeRule(d.id(), sBuilder, ForwardingObjective.Flag.SPECIFIC, ROUTING_RULE_PRIORITY);
        }
    });
}
#method_after
public void removeExternalRules(OpenstackRouterInterface routerInterface) {
    OpenstackSubnet openstackSubnet = openstackService.subnet(routerInterface.subnetId());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(openstackSubnet.networkId())).matchEthDst(GATEWAYMAC);
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).forEach(d -> {
        ForwardingObjective.Flag flag = checkGatewayNode(d.id()) ? ForwardingObjective.Flag.VERSATILE : ForwardingObjective.Flag.SPECIFIC;
        removeRule(d.id(), sBuilder, flag, ROUTING_RULE_PRIORITY);
    });
}
#end_block

#method_before
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    Device gatewayNode = getGatewayNode();
    Device portNode = deviceService.getDevice(portDeviceId);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    tBuilder.setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), config.nodes().get(portNode.id())), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#method_after
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    Device gatewayNode = getGatewayNode();
    Device portNode = deviceService.getDevice(portDeviceId);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    tBuilder.setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), config.nodes().get(portNode.id())), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#end_block

#method_before
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP, OpenstackPortInfo portInfo) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(portInfo.vni()).matchIPSrc(IpPrefix.valueOf(portInfo.ip(), 32));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), 32));
    removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
}
#method_after
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP, OpenstackPortInfo portInfo) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(portInfo.vni()).matchIPSrc(IpPrefix.valueOf(portInfo.ip(), PREFIX_LENGTH));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
}
#end_block

#method_before
@Override
public void updateRouter(OpenstackRouter openstackRouter) {
    if (openstackRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        Ip4Address externalIp = openstackRouter.gatewayExternalInfo().externalFixedIps().values().stream().findFirst().orElse(null);
        OpenstackRouter router = getRouterfromExternalIp(externalIp);
        checkExternalConnection(router, getOpenstackRouterInterface(router));
    } else {
        unsetExternalConnection();
    }
}
#method_after
@Override
public void updateRouter(OpenstackRouter openstackRouter) {
    if (openstackRouter.gatewayExternalInfo().externalFixedIps().size() > 0) {
        checkExternalConnection(openstackRouter, getOpenstackRouterInterface(openstackRouter));
    } else {
        unsetExternalConnection();
    }
}
#end_block

#method_before
private void reloadInitL3Rules() {
    l3EventExecutorService.submit(() -> openstackService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).forEach(p -> {
        OpenstackRouterInterface routerInterface = portToRouterInterface(p);
        updateRouterInterface(routerInterface);
    }));
}
#method_after
private void reloadInitL3Rules() {
    l3EventExecutorService.execute(() -> openstackService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).forEach(p -> {
        OpenstackRouterInterface routerInterface = portToRouterInterface(p);
        updateRouterInterface(routerInterface);
    }));
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!context.inPacket().receivedFrom().deviceId().toString().equals(config.gatewayBridgeId())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    // TODO: Considers IPv6 later.
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.submit(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                Port port = getExternalPort(pkt.receivedFrom().deviceId(), config.gatewayExternalInterfaceName());
                if (port == null) {
                    log.warn("There`s no external interface");
                    break;
                }
                OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port, config));
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.submit(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!context.inPacket().receivedFrom().deviceId().toString().equals(config.gatewayBridgeId())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    // TODO: Considers IPv6 later.
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.execute(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                Optional<Port> port = getExternalPort(pkt.receivedFrom().deviceId(), config.gatewayExternalInterfaceName());
                if (!port.isPresent()) {
                    log.warn("There`s no external interface");
                } else {
                    OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                    l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port.get(), config));
                }
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.execute(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#end_block

#method_before
private int getPortNum(MacAddress sourceMac, int destinationAddress) {
    int portNum = findUnusedPortNum();
    if (portNum == 0) {
        clearPortNumMap();
        portNum = findUnusedPortNum();
    }
    tpPortNumMap.put(portNum, sourceMac.toString().concat(":").concat(String.valueOf(destinationAddress)));
    return portNum;
}
#method_after
private int getPortNum(MacAddress sourceMac, int destinationAddress) {
    int portNum = findUnusedPortNum();
    if (portNum == 0) {
        clearPortNumMap();
        portNum = findUnusedPortNum();
    }
    tpPortNumMap.put(portNum, sourceMac.toString().concat(COLON).concat(String.valueOf(destinationAddress)));
    return portNum;
}
#end_block

#method_before
private Port getExternalPort(DeviceId deviceId, String interfaceName) {
    return deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).equals(interfaceName)).findAny().orElse(null);
}
#method_after
private Optional<Port> getExternalPort(DeviceId deviceId, String interfaceName) {
    return deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).equals(interfaceName)).findAny();
}
#end_block

#method_before
private void checkExternalConnection(OpenstackRouter router, Collection<OpenstackRouterInterface> interfaces) {
    checkNotNull(router, "Router can not be null");
    checkNotNull(interfaces, "routerInterfaces can not be null");
    Ip4Address externalIp = router.gatewayExternalInfo().externalFixedIps().values().stream().findFirst().orElse(null);
    if ((externalIp == null) || (!router.gatewayExternalInfo().isEnablePnat())) {
        log.debug("Not satisfied to set pnat configuration");
        return;
    }
    if (router.id() == null) {
        interfaces.forEach(i -> initiateL3Rule(getRouterfromExternalIp(externalIp), i));
    } else {
        interfaces.forEach(i -> initiateL3Rule(router, i));
    }
}
#method_after
private void checkExternalConnection(OpenstackRouter router, Collection<OpenstackRouterInterface> interfaces) {
    checkNotNull(router, "Router can not be null");
    checkNotNull(interfaces, "routerInterfaces can not be null");
    Ip4Address externalIp = router.gatewayExternalInfo().externalFixedIps().values().stream().findFirst().orElse(null);
    if ((externalIp == null) || (!router.gatewayExternalInfo().isEnablePnat())) {
        log.debug("Not satisfied to set pnat configuration");
        return;
    }
    interfaces.forEach(this::initiateL3Rule);
}
#end_block

#method_before
private OpenstackRouter getRouterfromExternalIp(Ip4Address externalIp) {
    OpenstackRouter router = getExternalRouter(true).stream().filter(r -> r.gatewayExternalInfo().externalFixedIps().values().stream().findFirst().orElse(null).equals(externalIp)).findAny().orElse(null);
    return checkNotNull(router);
}
#method_after
private Optional<OpenstackRouter> getRouterfromExternalIp(Ip4Address externalIp) {
    return getExternalRouter(true).stream().filter(r -> r.gatewayExternalInfo().externalFixedIps().values().stream().findAny().get().equals(externalIp)).findAny();
}
#end_block

#method_before
private void initiateL3Rule(OpenstackRouter router, OpenstackRouterInterface routerInterface) {
    long vni = Long.parseLong(openstackService.network(openstackService.port(routerInterface.portId()).networkId()).segmentId());
    rulePopulator.populateExternalRules(vni);
}
#method_after
private void initiateL3Rule(OpenstackRouterInterface routerInterface) {
    long vni = Long.parseLong(openstackService.network(openstackService.port(routerInterface.portId()).networkId()).segmentId());
    rulePopulator.populateExternalRules(vni);
}
#end_block

#method_before
private Collection<OpenstackRouterInterface> getOpenstackRouterInterface(OpenstackRouter router) {
    List<OpenstackRouterInterface> interfaces = Lists.newArrayList();
    openstackService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).filter(p -> p.deviceId().equals(router.id())).forEach(p -> {
        OpenstackRouterInterface routerInterface = portToRouterInterface(p);
        interfaces.add(routerInterface);
    });
    return interfaces;
}
#method_after
private Collection<OpenstackRouterInterface> getOpenstackRouterInterface(OpenstackRouter router) {
    List<OpenstackRouterInterface> interfaces = Lists.newArrayList();
    openstackService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).filter(p -> p.deviceId().equals(router.id())).forEach(p -> {
        interfaces.add(portToRouterInterface(p));
    });
    return interfaces;
}
#end_block

#method_before
private void populateFlowRulesForTunnelTag(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value("portName"));
    String portName = port.annotations().value("portName");
    String vni = getVniForPort(portName);
    if (vmIp != null) {
        setFlowRuleForTunnelTag(device.id(), port, vni);
    }
}
#method_after
private void populateFlowRulesForTunnelTag(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value(PORT_NAME));
    String portName = port.annotations().value(PORT_NAME);
    String vni = getVniForPort(portName);
    if (vmIp != null) {
        setFlowRuleForTunnelTag(device.id(), port, vni);
    }
}
#end_block

#method_before
private void populateFlowRulesForTrafficToSameCnode(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value("portName"));
    String portName = port.annotations().value("portName");
    String vni = getVniForPort(portName);
    if (vmIp != null) {
        setFlowRuleForVMsInSameCnode(vmIp, device.id(), port, vni);
    }
}
#method_after
private void populateFlowRulesForTrafficToSameCnode(Device device, Port port) {
    Ip4Address vmIp = getFixedIpAddressForPort(port.annotations().value(PORT_NAME));
    String portName = port.annotations().value(PORT_NAME);
    String vni = getVniForPort(portName);
    if (vmIp != null) {
        setFlowRuleForVMsInSameCnode(vmIp, device.id(), port, vni);
    }
}
#end_block

#method_before
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value("portName");
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    String vni = getVniForPort(portName);
    Ip4Address hostDpIpAddress = config.nodes().get(device.id());
    if (hostDpIpAddress == null) {
        log.debug("There's no openstack node information for device id {}", device.id().toString());
        return;
    }
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(device)) {
            deviceService.getPorts(d.id()).forEach(p -> {
                String pName = p.annotations().value("portName");
                if (!p.equals(port) && vni.equals(getVniForPort(pName))) {
                    Ip4Address hostxDpIpAddress = config.nodes().get(d.id());
                    Ip4Address fixedIpx = getFixedIpAddressForPort(pName);
                    if (port.isEnabled()) {
                        setVxLanFlowRule(vni, device.id(), hostxDpIpAddress, fixedIpx);
                        setVxLanFlowRule(vni, d.id(), hostDpIpAddress, fixedIp);
                    }
                }
            });
        }
    });
}
#method_after
private void populateFlowRulesForTrafficToDifferentCnode(Device device, Port port) {
    String portName = port.annotations().value(PORT_NAME);
    Ip4Address fixedIp = getFixedIpAddressForPort(portName);
    String vni = getVniForPort(portName);
    Ip4Address hostDpIpAddress = config.nodes().get(device.id());
    if (hostDpIpAddress == null) {
        log.debug("There's no openstack node information for device id {}", device.id().toString());
        return;
    }
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(device)) {
            deviceService.getPorts(d.id()).forEach(p -> {
                String pName = p.annotations().value(PORT_NAME);
                if (!p.equals(port) && vni.equals(getVniForPort(pName))) {
                    Ip4Address hostxDpIpAddress = config.nodes().get(d.id());
                    Ip4Address fixedIpx = getFixedIpAddressForPort(pName);
                    if (port.isEnabled()) {
                        setVxLanFlowRule(vni, device.id(), hostxDpIpAddress, fixedIpx);
                        setVxLanFlowRule(vni, d.id(), hostDpIpAddress, fixedIp);
                    }
                }
            });
        }
    });
}
#end_block

#method_before
public OpenstackPort openstackPort(Port port) {
    String uuid = port.annotations().value("portName").substring(3);
    return openstackPortList.stream().filter(p -> p.id().startsWith(uuid)).findAny().orElse(null);
}
#method_after
public OpenstackPort openstackPort(Port port) {
    String uuid = port.annotations().value(PORT_NAME).substring(3);
    return openstackPortList.stream().filter(p -> p.id().startsWith(uuid)).findAny().orElse(null);
}
#end_block

#method_before
public void removeSwitchingRules(Port removedPort, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    OpenstackPortInfo openstackPortInfo = openstackPortInfoMap.get(removedPort.annotations().value("portName"));
    DeviceId deviceId = openstackPortInfo.deviceId();
    Ip4Address vmIp = openstackPortInfo.ip();
    PortNumber portNumber = removedPort.number();
    long vni = openstackPortInfo.vni();
    removeFlowRuleForTunnelTag(deviceId, portNumber);
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp, vni);
    removeFlowRuleForVMsInDiffrentCnode(removedPort, deviceId, vmIp, vni, openstackPortInfoMap);
}
#method_after
public void removeSwitchingRules(Port removedPort, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    OpenstackPortInfo openstackPortInfo = openstackPortInfoMap.get(removedPort.annotations().value(PORT_NAME));
    DeviceId deviceId = openstackPortInfo.deviceId();
    Ip4Address vmIp = openstackPortInfo.ip();
    PortNumber portNumber = removedPort.number();
    long vni = openstackPortInfo.vni();
    removeFlowRuleForTunnelTag(deviceId, portNumber);
    removeFlowRuleForVMsInSameCnode(deviceId, vmIp, vni);
    removeFlowRuleForVMsInDiffrentCnode(removedPort, deviceId, vmIp, vni, openstackPortInfoMap);
}
#end_block

#method_before
private boolean checkIfAnyPortRemainedInSameCnode(Port removedPort, DeviceId deviceId, long vni, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    for (Map.Entry<String, OpenstackPortInfo> entry : openstackPortInfoMap.entrySet()) {
        if (!removedPort.annotations().value("portName").equals(entry.getKey())) {
            if (entry.getValue().vni() == vni && entry.getValue().deviceId().equals(deviceId)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean checkIfAnyPortRemainedInSameCnode(Port removedPort, DeviceId deviceId, long vni, Map<String, OpenstackPortInfo> openstackPortInfoMap) {
    for (Map.Entry<String, OpenstackPortInfo> entry : openstackPortInfoMap.entrySet()) {
        if (!removedPort.annotations().value(PORT_NAME).equals(entry.getKey())) {
            if (entry.getValue().vni() == vni && entry.getValue().deviceId().equals(deviceId)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private ExtensionTreatment buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue("tunnelDst", hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#method_after
private ExtensionTreatment buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue(TUNNEL_DST, hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#end_block

#method_before
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value("portName").equals(OpenstackSwitchingManager.PORTNAME_PREFIX_TUNNEL)).findAny().orElse(null);
    if (port == null) {
        log.error("No TunnelPort was created.");
        return null;
    }
    return port.number();
}
#method_after
private PortNumber getTunnelPort(DeviceId deviceId) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).equals(OpenstackSwitchingManager.PORTNAME_PREFIX_TUNNEL)).findAny().orElse(null);
    if (port == null) {
        log.error("No TunnelPort was created.");
        return null;
    }
    return port.number();
}
#end_block

#method_before
private void setUpConfiguration() {
    ReactiveRoutingConfig config = configService.getConfig(coreService.registerApplication(RoutingConfigurationService.REACTIVE_ROUTING_APP_ID), RoutingConfigurationService.CONFIG_CLASS);
    if (config == null) {
        log.warn("No reactive routing config available!");
        return;
    }
    for (LocalIpPrefixEntry entry : config.localIp4PrefixEntries()) {
        localPrefixTable4.put(createBinaryString(entry.ipPrefix()), entry);
        gatewayIpAddresses.add(entry.getGatewayIpAddress());
    }
    for (LocalIpPrefixEntry entry : config.localIp6PrefixEntries()) {
        localPrefixTable6.put(createBinaryString(entry.ipPrefix()), entry);
        gatewayIpAddresses.add(entry.getGatewayIpAddress());
    }
    virtualGatewayMacAddress = config.virtualGatewayMacAddress();
}
#method_after
private void setUpConfiguration() {
    ReactiveRoutingConfig config = configService.getConfig(coreService.registerApplication(RoutingConfigurationService.REACTIVE_ROUTING_APP_ID), RoutingConfigurationService.CONFIG_CLASS);
    if (config == null) {
        log.warn("No reactive routing config available!");
        return;
    }
    for (LocalIpPrefixEntry entry : config.localIp4PrefixEntries()) {
        localPrefixTable4.put(createBinaryString(entry.ipPrefix()), entry);
        gatewayIpAddresses.add(entry.getGatewayIpAddress());
    }
    for (LocalIpPrefixEntry entry : config.localIp6PrefixEntries()) {
        localPrefixTable6.put(createBinaryString(entry.ipPrefix()), entry);
        gatewayIpAddresses.add(entry.getGatewayIpAddress());
    }
    virtualGatewayMacAddress = config.virtualGatewayMacAddress();
    // Setup BGP peer connect points
    ApplicationId routerAppId = coreService.getAppId(Router.ROUTER_APP_ID);
    if (routerAppId == null) {
        log.info("Router application ID is null!");
        return;
    }
    BgpConfig bgpConfig = configService.getConfig(routerAppId, BgpConfig.class);
    if (bgpConfig == null) {
        log.info("BGP config is null!");
        return;
    } else {
        bgpPeerConnectPoints = bgpConfig.bgpSpeakers().stream().flatMap(speaker -> speaker.peers().stream()).map(peer -> interfaceService.getMatchingInterface(peer)).filter(Objects::nonNull).map(intf -> intf.connectPoint()).collect(Collectors.toSet());
    }
}
#end_block

#method_before
public Set<LocalIpPrefixEntry> localIp4PrefixEntries() {
    Set<LocalIpPrefixEntry> prefixes = Sets.newHashSet();
    JsonNode prefixesNode = object.get(IP4LOCALPREFIXES);
    if (prefixesNode == null) {
        Log.warn("ip4LocalPrefixes is null!");
        return prefixes;
    }
    prefixesNode.forEach(jsonNode -> {
        prefixes.add(new LocalIpPrefixEntry(IpPrefix.valueOf(jsonNode.get(IPPREFIX).asText()), IpPrefixType.valueOf(jsonNode.get(TYPE).asText()), IpAddress.valueOf(jsonNode.get(GATEWAYIP).asText())));
    });
    return prefixes;
}
#method_after
public Set<LocalIpPrefixEntry> localIp4PrefixEntries() {
    Set<LocalIpPrefixEntry> prefixes = Sets.newHashSet();
    JsonNode prefixesNode = object.get(IP4LOCALPREFIXES);
    if (prefixesNode == null) {
        log.warn("ip4LocalPrefixes is null!");
        return prefixes;
    }
    prefixesNode.forEach(jsonNode -> {
        prefixes.add(new LocalIpPrefixEntry(IpPrefix.valueOf(jsonNode.get(IPPREFIX).asText()), IpPrefixType.valueOf(jsonNode.get(TYPE).asText()), IpAddress.valueOf(jsonNode.get(GATEWAYIP).asText())));
    });
    return prefixes;
}
#end_block

#method_before
public Set<LocalIpPrefixEntry> localIp6PrefixEntries() {
    Set<LocalIpPrefixEntry> prefixes = Sets.newHashSet();
    JsonNode prefixesNode = object.get(IP6LOCALPREFIXES);
    if (prefixesNode == null) {
        Log.warn("ip6LocalPrefixes is null!");
        return prefixes;
    }
    prefixesNode.forEach(jsonNode -> {
        prefixes.add(new LocalIpPrefixEntry(IpPrefix.valueOf(jsonNode.get(IPPREFIX).asText()), IpPrefixType.valueOf(jsonNode.get(TYPE).asText()), IpAddress.valueOf(jsonNode.get(GATEWAYIP).asText())));
    });
    return prefixes;
}
#method_after
public Set<LocalIpPrefixEntry> localIp6PrefixEntries() {
    Set<LocalIpPrefixEntry> prefixes = Sets.newHashSet();
    JsonNode prefixesNode = object.get(IP6LOCALPREFIXES);
    if (prefixesNode == null) {
        log.warn("ip6LocalPrefixes is null!");
        return prefixes;
    }
    prefixesNode.forEach(jsonNode -> {
        prefixes.add(new LocalIpPrefixEntry(IpPrefix.valueOf(jsonNode.get(IPPREFIX).asText()), IpPrefixType.valueOf(jsonNode.get(TYPE).asText()), IpAddress.valueOf(jsonNode.get(GATEWAYIP).asText())));
    });
    return prefixes;
}
#end_block

#method_before
private TrafficType trafficTypeClassifier(ConnectPoint srcConnectPoint, IpAddress dstIp) {
    LocationType dstIpLocationType = getLocationType(dstIp);
    Optional<Interface> srcInterface = interfaceService.getInterfacesByPort(srcConnectPoint).stream().findFirst();
    switch(dstIpLocationType) {
        case INTERNET:
            if (srcInterface.isPresent() && (!interfaceService.getInterfaceConnectPoints().contains(srcConnectPoint))) {
                return TrafficType.HOST_TO_INTERNET;
            } else {
                return TrafficType.INTERNET_TO_INTERNET;
            }
        case LOCAL:
            if (srcInterface.isPresent() && (!interfaceService.getInterfaceConnectPoints().contains(srcConnectPoint))) {
                return TrafficType.HOST_TO_HOST;
            } else {
                // TrafficType.DROP.
                return TrafficType.INTERNET_TO_HOST;
            }
        case NO_ROUTE:
            return TrafficType.DROP;
        default:
            return TrafficType.UNKNOWN;
    }
}
#method_after
private TrafficType trafficTypeClassifier(ConnectPoint srcConnectPoint, IpAddress dstIp) {
    LocationType dstIpLocationType = getLocationType(dstIp);
    Optional<Interface> srcInterface = interfaceService.getInterfacesByPort(srcConnectPoint).stream().findFirst();
    Set<ConnectPoint> bgpPeerConnectPoints = config.getBgpPeerConnectPoints();
    switch(dstIpLocationType) {
        case INTERNET:
            if (srcInterface.isPresent() && (!bgpPeerConnectPoints.contains(srcConnectPoint))) {
                return TrafficType.HOST_TO_INTERNET;
            } else {
                return TrafficType.INTERNET_TO_INTERNET;
            }
        case LOCAL:
            if (srcInterface.isPresent() && (!bgpPeerConnectPoints.contains(srcConnectPoint))) {
                return TrafficType.HOST_TO_HOST;
            } else {
                // TrafficType.DROP.
                return TrafficType.INTERNET_TO_HOST;
            }
        case NO_ROUTE:
            return TrafficType.DROP;
        default:
            return TrafficType.UNKNOWN;
    }
}
#end_block

#method_before
@Override
public void setUpConnectivityInternetToHost(IpAddress hostIpAddress) {
    checkNotNull(hostIpAddress);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (hostIpAddress.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
    }
    // Match the destination IP prefix at the first hop
    IpPrefix ipPrefix = hostIpAddress.toIpPrefix();
    selector.matchIPDst(ipPrefix);
    // Rewrite the destination MAC address
    MacAddress hostMac = null;
    ConnectPoint egressPoint = null;
    for (Host host : hostService.getHostsByIp(hostIpAddress)) {
        if (host.mac() != null) {
            hostMac = host.mac();
            egressPoint = host.location();
            break;
        }
    }
    if (hostMac == null) {
        hostService.startMonitoringIp(hostIpAddress);
        return;
    }
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(hostMac);
    Key key = Key.of(ipPrefix.toString(), appId);
    int priority = ipPrefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    if (interfaceService.getInterfaceConnectPoints().isEmpty()) {
        log.error("The ingress points are empty!");
        return;
    }
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(interfaceService.getInterfaceConnectPoints()).egressPoint(egressPoint).priority(priority).constraints(CONSTRAINTS).build();
    log.trace("Generates ConnectivityInternetToHost intent {}", intent);
    submitReactiveIntent(ipPrefix, intent);
}
#method_after
@Override
public void setUpConnectivityInternetToHost(IpAddress hostIpAddress) {
    checkNotNull(hostIpAddress);
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    if (hostIpAddress.isIp4()) {
        selector.matchEthType(Ethernet.TYPE_IPV4);
    } else {
        selector.matchEthType(Ethernet.TYPE_IPV6);
    }
    // Match the destination IP prefix at the first hop
    IpPrefix ipPrefix = hostIpAddress.toIpPrefix();
    selector.matchIPDst(ipPrefix);
    // Rewrite the destination MAC address
    MacAddress hostMac = null;
    ConnectPoint egressPoint = null;
    for (Host host : hostService.getHostsByIp(hostIpAddress)) {
        if (host.mac() != null) {
            hostMac = host.mac();
            egressPoint = host.location();
            break;
        }
    }
    if (hostMac == null) {
        hostService.startMonitoringIp(hostIpAddress);
        return;
    }
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder().setEthDst(hostMac);
    Key key = Key.of(ipPrefix.toString(), appId);
    int priority = ipPrefix.prefixLength() * PRIORITY_MULTIPLIER + PRIORITY_OFFSET;
    Set<ConnectPoint> interfaceConnectPoints = interfaceService.getInterfaces().stream().map(intf -> intf.connectPoint()).collect(Collectors.toSet());
    if (interfaceConnectPoints.isEmpty()) {
        log.error("The interface connect points are empty!");
        return;
    }
    Set<ConnectPoint> ingressPoints = new HashSet<>();
    for (ConnectPoint connectPoint : interfaceConnectPoints) {
        if (!connectPoint.equals(egressPoint)) {
            ingressPoints.add(connectPoint);
        }
    }
    MultiPointToSinglePointIntent intent = MultiPointToSinglePointIntent.builder().appId(appId).key(key).selector(selector.build()).treatment(treatment.build()).ingressPoints(ingressPoints).egressPoint(egressPoint).priority(priority).constraints(CONSTRAINTS).build();
    log.trace("Generates ConnectivityInternetToHost intent {}", intent);
    submitReactiveIntent(ipPrefix, intent);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp();
    sSfibInstaller = new SingleSwitchFibInstaller();
    // component config service
    ComponentConfigService mockComponenetConfigServ = EasyMock.createMock(ComponentConfigService.class);
    expect(mockComponenetConfigServ.getProperties(anyObject())).andReturn(ImmutableSet.of());
    mockComponenetConfigServ.registerProperties(sSfibInstaller.getClass());
    EasyMock.expectLastCall();
    mockComponenetConfigServ.unregisterProperties(sSfibInstaller.getClass(), false);
    EasyMock.expectLastCall();
    expect(mockComponenetConfigServ.getProperties(anyObject())).andReturn(ImmutableSet.of());
    sSfibInstaller.componentConfigService = mockComponenetConfigServ;
    replay(mockComponenetConfigServ);
    // component context
    ComponentContext mockContext = EasyMock.createMock(ComponentContext.class);
    Dictionary<String, Boolean> properties = null;
    expect(mockContext.getProperties()).andReturn(properties);
    replay(mockContext);
    coreService = new TestCoreService();
    routingService = new TestRoutingService();
    routerConfig = new TestRouterConfig();
    // interfaceService = createMock(InterfaceService.class);
    interfaceService = new TestInterfaceService();
    networkConfigService = createMock(NetworkConfigService.class);
    flowObjectiveService = createMock(FlowObjectiveService.class);
    deviceService = new TestDeviceService();
    sSfibInstaller.networkConfigService = networkConfigService;
    sSfibInstaller.interfaceService = interfaceService;
    sSfibInstaller.flowObjectiveService = flowObjectiveService;
    sSfibInstaller.coreService = coreService;
    sSfibInstaller.routingService = new TestRoutingService();
    sSfibInstaller.deviceService = deviceService;
    setUpNetworkConfigService();
    setUpInterfaceService();
    sSfibInstaller.activate(mockContext);
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp();
    sSfibInstaller = new SingleSwitchFibInstaller();
    // component config service
    ComponentConfigService mockComponenetConfigServ = EasyMock.createMock(ComponentConfigService.class);
    expect(mockComponenetConfigServ.getProperties(anyObject())).andReturn(ImmutableSet.of());
    mockComponenetConfigServ.registerProperties(sSfibInstaller.getClass());
    EasyMock.expectLastCall();
    mockComponenetConfigServ.unregisterProperties(sSfibInstaller.getClass(), false);
    EasyMock.expectLastCall();
    expect(mockComponenetConfigServ.getProperties(anyObject())).andReturn(ImmutableSet.of());
    sSfibInstaller.componentConfigService = mockComponenetConfigServ;
    replay(mockComponenetConfigServ);
    // component context
    ComponentContext mockContext = EasyMock.createMock(ComponentContext.class);
    Dictionary properties = null;
    expect(mockContext.getProperties()).andReturn(properties);
    replay(mockContext);
    coreService = new TestCoreService();
    routingService = new TestRoutingService();
    routerConfig = new TestRouterConfig();
    // interfaceService = createMock(InterfaceService.class);
    interfaceService = new TestInterfaceService();
    networkConfigService = createMock(NetworkConfigService.class);
    flowObjectiveService = createMock(FlowObjectiveService.class);
    deviceService = new TestDeviceService();
    sSfibInstaller.networkConfigService = networkConfigService;
    sSfibInstaller.interfaceService = interfaceService;
    sSfibInstaller.flowObjectiveService = flowObjectiveService;
    sSfibInstaller.coreService = coreService;
    sSfibInstaller.routingService = new TestRoutingService();
    sSfibInstaller.deviceService = deviceService;
    setUpNetworkConfigService();
    setUpInterfaceService();
    sSfibInstaller.activate(mockContext);
}
#end_block

#method_before
private void sendFilteringObjective(boolean install, FilteringObjective.Builder fob, Interface intf) {
    ObjectiveContext context = new ObjectiveContextImpl((objective) -> log.info("Installed filter for interface {}", intf), (objective, error) -> log.error("Failed to install filter for interface {}: {}", intf, error));
    FilteringObjective filter = install ? fob.add(context) : fob.remove(context);
    flowObjectiveService.filter(deviceId, filter);
}
#method_after
private void sendFilteringObjective(boolean install, FilteringObjective.Builder fob, Interface intf) {
    ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.info("Installed filter for interface {}", intf), (objective, error) -> log.error("Failed to install filter for interface {}: {}", intf, error));
    FilteringObjective filter = install ? fob.add(context) : fob.remove(context);
    flowObjectiveService.filter(deviceId, filter);
}
#end_block

#method_before
private static void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            if (treatmentInterpreter != null) {
                builder.extension(treatmentInterpreter.mapAction(action), deviceId);
            } else {
                @SuppressWarnings("unchecked")
                OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
                builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            }
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
            if (treatmentInterpreter != null) {
                builder.extension(treatmentInterpreter.mapAction(action), deviceId);
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
        case ARP_SHA:
        case ARP_SPA:
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#method_after
private static void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                } catch (UnsupportedOperationException e) {
                    log.warn(e.getMessage());
                }
            } else {
                @SuppressWarnings("unchecked")
                OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
                builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            }
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                } catch (UnsupportedOperationException e) {
                    log.warn(e.getMessage());
                }
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
        case ARP_SHA:
        case ARP_SPA:
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#end_block

